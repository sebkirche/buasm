TITLE MACROS          ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
@TOPCODE:

[STR.A.ApplicationName: B$ ' Bottom Up Assembler: V. 03.00.005A' EOS]

;;

    English:

    To understand what these Macros do for you you can click on them and choose UNFOLD.
    You will know what kind of code they generate. Macros are useful in assembly programming
    because they bring long-term READABILITY.

    All the Macros you plan to use should be here in this TITLE. Here are some important
    guidelines you should know when implementing Macros:

    1. Macros shouldn't use registers internally for their functionment.
    2. Macros shoudn't use global variables or global labels
    3. Don't encapsulate easy APIs.

    Français:

    Pour mieux (bien) comprendre ce que ces Macros 'génèrent' nous vous invitons à un double
    clic gauche sur leurs évocations dans le code. Choisissez l'option "Unfold" dans le menu
    pop: Vous verrez ainsi que RosAsm ne substitue pas de code à votre insue mais que c'est
    VOUS qui construisez vos substitutions -> Pour gagner en lisibilisé, en souplesse et en
    facilité de maintenance de votre code. Plus il sera lisible et facilement compréhensible,
    plus vous pourrez y retourner facilement après plusieurs mois ou permettre à d'autres de
    participer sa la maintenance...

    Toutes les Macros utilisées dans RosASm doivent être déclarées ici et, dans la mesure du
    possible, regroupées par catégories. N'implémentez pas de nouvelles Macros utilisant en
    interne des registres, des variables globales ou des Label globaux (c'est une source de
    conflits).
    !!! Par principe, ne multipliez pas la création de nouvelles Macros -> Evitez, par-dessus
    toutes choses, les diverses formes d'encapsulations d'API: Cela n'apporte rien au niveau
    de la lisibilité (au contraire) et provoque de nombreuses sources d'erreurs:
    Soignez les commentaires et utilisez des Proc/routines communes
    ________________________________________________________________

    ; List of Local labels to use and that Macros use:

    ; Labels locaux utilisée au sein des Macros:
      (Liste à compléter en fonction des nouvelles implémentations)
    ________________________________________________________________

    P9 -> [ExitP]
    P7 -> [On]

    M0 ~ M9 et N0 ~N9 [If][Else_If][Else][End_If]

    O0 ~ O9 [Repeat][Until] [While][End_While]

    Jumps: S0 ~ S9

    Loops: L1 ~ L9 and L0 unique Loop or without link to other loops 
           L1 ~ L9 et L0 Boucle unique ou sans imbrication avec d'autres boucles
    _________________________________________________________________

    ; Internal variables of the Macro parser used inside the Macros:
      (List to complete when new implémentations are made)

    ; Variables interne du Macro parser utilisée au sein des Macros:
      (Liste à compléter en fonction des nouvelles implémentations)
    _________________________________________________________________

    &1 -> Size of arguments / Taille des arguments

    &2 -> Size of local variables and structures / Taille des variables locales et des structure

    &3 -> String of register or variable saved / Chaîne de registre ou variables préservées

    &4 -> Structure name / Nom de la structure

    &5 -> Structure offset counter / Compteur d'offsets de structure

    &6 -> Constructor of strings for debugg.dll macros / Constructeur de Châines pour les Macro de debugg.dll

    &&1 -> Compteur de Macros [If][Else] / Macros counter

    M N &&1 -> Counter of the times this macro was used. This is used to generate proper label names M0 to M9
    M N &&1 -> Compteur d'emboîtements, utilisés pour la création des labels M0..M9, N0..N9

    &&2 -> Compteur de Macros [Repeat][Until] [While][Wend] / Macros counter 

    O&&2 -> Pour la construction des labels [Repeat][Until] [While][End_While] 
            For the construction of the labels [Repeat][Until] [While][End_While] 

;;
_______________

; Basic macros
_______________

;;

    Description : Macros that Move data around
                  Macros de déplacement des données


    Examples:

        Mov eax 45 | Mov D$edi '0000'

        [Mov] eax D$eax, B$MyVar 0_7F, eax MyLp

        Mov eax {ARGB 0_C1 0_C2 0_C3 0_A0}

        Push ebx
        
        Pop ebx

        [Push] W$eax,
               D$eax,
               ax

        [Pop] ax,
              D$eax,
              W$eax

        [Move] D$MyVar D$eax, W$eax W$Mylp

;;

[Mov

    mov #1 #2

    #+2]

[ARGB

    (#1 or (#2 shl 8) or (#3 shl 16) or (#4 shl 24))]

[Push

    push #1

    #+1]

[Pop

    pop #1

    #+1]

[Move

    push #2 | pop #1

    #+2]

;;

    Description : Macros used to Call functions
                  Macros utilisées pour appeller vos fonctions et les API

    EOS = End of String Equate
          Equate de fin de chaîne

    Examples :

    [Call] Label

    STDCALL convention : The function will cleanup the stack
                         La fonction est résponable de la restauration de la pile

    Call Label D$MyParameter,
               MyLp ...

    Call Label D$MyParameter,
               {B$ 'StringASCII' EOS}, ; ParaMacro: Local label generation [@xxx: B$ 'StringASCII' EOS]
                                       ;            Génération d'un Label local [@xxx: B$ 'StringASCII' EOS]
               {U$ 'StringUNICODE' EOS},
               MyLp ...

    STDCALL convention : the DLL function will cleanup the stack
                         La dll est résponable de la restauration de la pile

    Call 'DLLNAME.FunctionName'

    Call 'DLLNAME.FunctionName' D$Parameter,
                                Lp ...

    cdecl convention (MSVCRT mainly)
    The caller must cleanup the stack (add esp, [DWORD]*numberOfArguments)
    !!! Le CCall est résponable de la restauration de la pile

    [CCall] 'NOMDLL.AdresseName' D$Parameter,
                                 Lp ...

;;

[Call

    push #L>2

    Call #1]
;;
[CCall

    push #L>2

    Call #1

    #If #N>1

        add esp ((#N-1)*DWORD)

    #EndIf]
;;
______________________________

; Macros HLL Proc / Functions
______________________________

;;

    For the GUI messages routines, if you don't modify the initial stack, you can use the MSG
    equates (they are coded to work with a typical stack value) See [CALLBACK]

    Pour les Routines de traitement des messages GUI, afin d'éviter la transmission redondante
    d'arguments, CE TANT QUE LA PILE N'EST PAS MODIFIEE PAR UN PASSAGE D'ARGUMENT(S) OU PAR UN
    PUSHs DE TYPE Uses OU PUSH EBX, il est possible d'utiliser les Equates de MSG voir [CALLBACK]

    ~~~~~~~~~~~~~~~~~
    Label:

        You can access the arguments like this when the EQUATES work
        D$[HWND] D$[MSG] D$[WPARAM] D$[LPARAM]

        Utilisables -> D$[HWND] D$[MSG] D$[WPARAM] D$[LPARAM]

    ret or [RetR]

    ~~~~~~~~~~~~~~~~~

        You can use -> D$HWND D$MSG D$WPARAM D$LPARAM
        Utilisables -> D$HWND D$MSG D$WPARAM D$LPARAM

        [StackOn]

            You can use these Macros when you are in StackOn : [Local]/[Locals] [Structure] [Uses]
            And you cannot use that now -> D$HWND D$MSG D$WPARAM D$LPARAM

            !!! Attention les Macros [Local]/[Locals] [Structure] [Uses] ne sont pas utilisables
            dans les routines en dehors de StackOn / StackOff
            Inutilisables -> D$HWND D$MSG D$WPARAM D$LPARAM

        [StackOff]

        You can use these again -> D$HWND D$MSG D$WPARAM D$LPARAM
        Utilisables ici à nouveau -> D$HWND D$MSG D$WPARAM D$LPARAM

    ret or Retr

    ~~~~~~~~~~~~~~~~~
      !!! Align your structures (From the biggest member (Q$) to the smallest (B$)
      !!! Alignez vos strutures (de la plus grande taille (Q$) à la plus petite (B$)

  *(1~5)  Structure @STC.XXXXXX, -> (D)@STRUC.XXXXXX contenant le Lp -> @STC.XXXXXX
              QWORD .Q.Var1,     -> Q@STRUC.Q.XXXXXX.Var1  ; QWORD or 2*DWORD aligned
              DWORD .DU.Var2,    -> D@STRUC.DU.XXXXXX.Var2 ; DWORD aligned LSD
              DWORD .DU.Var3,    -> D@STRUC.DU.XXXXXX.Var2 ; DWORD aligned MSD
               WORD .WU.Var4,    -> W@STRUC.WU.XXXXXX.Var3 ; WORD  aligned LSW
               WORD .WU.Var5,    -> W@STRUC.WU.XXXXXX.Var4 ; WORD  aligned MSW
               BYTE .BU.Var6,    -> B@STRUC.BU.XXXXXX.Var5 ; BYTE  aligned LSB
               BYTE .BU.Var7,    -> B@STRUC.BS.XXXXXX.Var6 ; BYTE  aligned MSB
               BYTE .BS.Var8,    -> B@STRUC.BU.XXXXXX.Var7 ; etc.
               BYTE .BU.Var9     -> B@STRUC.BU.XXXXXX.Var8

        (@STC.XXXXXXSIZE is en equate generated by a Macro that contains the structure
         size -> mov eax (!!! not D) @STC.XXXXXXSIZE)

        (@STC.XXXXXXSIZE est une equate générée par la Macro et contenant la taille en bytes
         de la structure -> mov eax (!!! pas de préfixe de taille D) @STC.XXXXXXSIZE)

;;

;;
[Proc

    #1                          ; Creation of global label / Création du label global

    StackOn]

[StackOn

    &1=0                        ; &1 = Size of arguments. We zero the counter
                                ; &1 = Taille des arguments. RAZ compteur

    &2=0                        ; &2 = Size of local variables and structures. We zero the counter
                                ; &2 = Taille des variables locales et des structure. RAZ compteur

    &3=                         ; &3 = String of saved variables. Set string to zero
                                ;      Chaîne de variables préservées. RAZ chaîne

    &4=                         ; &4 = Structure name / Nom de la structure

    &5=0                        ; Zero structure offset counter / RAZ compteur d'offsets de structure

    push ebp                    ; Stack frame init / Initialisation du cadre de pile

    mov ebp esp]

[Argument
                                ; Callback = 1*DWORD  Argument = 1*DWORD
    {#1 ebp+((1*DWORD)+DWORD)}  ; Equate creation [MyProc@ParamA ebp+8]
                                ; Fabrique equate [MyProc@ParamA ebp+8]

    &1=DWORD]                   ; Save size of arg / Sauvegarde la taille de l'arguments

[Arguments

    {#1 ebp+((#x*DWORD)+DWORD)} ; Equate creation ex:[MyProc@ParamA ebp+0C]
                                ; Fabrique equate ex:[MyProc@ParamA ebp+0C]

    #+1                         ; Next argument / Argument suivant

    &1=(#N*DWORD)]              ; Save size of args / Sauvegarde la taille des arguments

[Local

    {#1 ebp-DWORD}              ; Equate creation [MyProc@LocalA ebp-4]
                                ; Fabrique equate [MyProc@LocalA ebp-4]

    &2=DWORD                    ; Offset counter update / MAJ du compteur d'offet

    sub esp DWORD]              ; Save space for local variable on stack
                                ; Reserve la place pour la variable locale sur la pile

[Locals

    {#1 ebp-(&2+(#x*DWORD))}    ; Equate creation ex:[MyProc@LocalA ebp-4]

    #+1                         ; Next local variable / Variable locale suivante

    &2=&2+(#N*DWORD)            ; Offset counter update / MAJ du compteur d'offet

    sub esp (#N*DWORD)]         ; Save space for local variables on stack
                                ; Reserve la place pour les variables locales sur la pile

[Structure

    &4=#1                       ; &4 structure name / &4 Nom structure

    &5=0                        ; Zero structure offset counter / RAZ compteur

    BuildMember #2 #L>2]        ; Create structure on stack / Fabrique la structure sur la pile

[BuildMember

     {&4#2 ebp-(&2+&5+#3)}      ; Member Equates creation ex:[MyProc@MyStructure.MyMembre2 D$ebp-08]
                                ; Fabrique equates membre ex:[MyProc@MyStructure.MyMembre2 D$ebp-08]

     &5=&5+#3                   ; Size counter incrementation / Inc le compteur de la taille

     #+2                        ; Next member/ Membre suivant

     {&4 D$ebp-(&2+&5+DWORD)}   ; Equate creation (Structure LP) ex:[MyProc@MyStructure D$ebp-0C]
                                ; Fabrique equate Lp structure ex:[MyProc@MyStructure D$ebp-0C]

     {&4Size (&5)}              ; Equate creation (Sizeof structure) ex: [MyProc@MyStructureSize 08]
                                ; Fabrique equate taille structure ex: [MyProc@MyStructureSize 08]

     sub esp (&5)               ; Save space on stack for the structure
                                ; Reserve la place pour la structure sur la pile

     push esp                   ; Save structure LP / Sauvegarde le Lp de la structure

     &2=&2+&5+DWORD]            ; Offset counter update / MAJ du compteur d'offet

[Uses

    push #1>L                   ; Save register/variables on the stack
                                ; Sauvegarde registres/variables sur la pile

    &3=pop #L>1]                ; Automatic reg restore pop code
                                ; Fabrique la chaîne de commande de restauration registres/variables
;;

[Return

    #If #N=1                    ; Test if there is a return argument / Test si un argument en retour

        mov eax #1              ; Return &TRUE -> mov eax &TRUE | jump P9> (EndP)

    #EndIf                      ; Single return  = Exit Proc / Return seul = Exit Proc

    jmp P9>] ; jmp ExitP]                  ; See next equate / Saute à EndP, voir equate suivante

;;

[ExitP P9>]                     ; Equate to exit proc / Equate pour sortie Proc -> cmp eax &NULL | je ExitP

[StackOff

    P9:                         ; Jump label for ExitP / Label de saut pour ExitP

    &2=0                        ; &2 = Size of local variables and structures. We zero the counter

    &3 | &3=                    ; If &3 >'' restore the registers/variables saved and reset to zero string &3
                                ; Si &3 >'' restaure les registres/variables sauvegardés et RAZ chaîne &3

    &4=                         ; &4 = Structure name / Nom de la structure

    &5=0                        ; Zero structure offset counter / RAZ compteur d'offsets de structure

    mov esp ebp                 ; Restore stack pointer / Restaure le pointeur de pile

    pop ebp]                    ; Restore ebp / Restaure le cadre de pile appelant

[EndP

    StackOff

    RetR]

[RetR

    ExitF

    ret &1                      ; Return to caller and clean the stack by numberofArgs*DWORD
                                ; Retour à l'appelant et retrait des arguments de la pile

    &1=0]                       ; We zero the counter / RAZ compteur

[ExitF

    #If &&1=> '0'               ; Check if If/Else Macros are paired
                                ; Vérifie si les Macros [If]/[Else_If]/[End_If] sont apairées

        #Error 'Unpaired use of If / End_If !'

    #EndIf

    #If &&2=> '0'               ; Check if while, repeat Macros are paired
                                ; Vérifie si les Macros [Repeat]/[Until] [While]/[Wend] sont apairées

        #Error 'Unpaired use of loop constructs !'

    #EndIf]
;;
_______________________________________

; Conditional Branch HLL macros

; Macros HLL branchements contitionels
_______________________________________

; [EQUATES_HLL] Equates for cond jumps / Equates pour la forme HLL integers signés et non-signés seulement

;;

    Multiple conditional branch (Maximum of 4 + a jmp):

    Multiple branchement conditionel (4 + jmp maxi.):

    Comp D$eax Label = S1>

    Comp eax edx > S1> < S2> = S3> NEGATIVE S9> -> [EQUATES_HLL]

    Comp eax D$LabelA = LabelB,
                      < S2>,
                      NEGATIVE L1<, -> [EQUATES_HLL]
                      ZERO S9>      -> [EQUATES_HLL]
                     
                      jmp S0>

    cmp is kept for spaguetti code / cmp est conservé pour le code spaghetti

;;

[Comp

    #If #N<4

        #Error '[A] [B] [Condition] [Label] !'

    #Else

        cmp #1 #2 | JmpIf #3>L

    #EndIf]

;;
    
    Conditional execution / Exécution conditionelle
    On eax > ebx Mov ebx eax
    On eax = ebx Call Procedure
    On eax > ebx Mov ebx eax, jmp S1<

;;

[On

    cmp #1 #3 | jn#2 P7>

        #4>L

    P7:]

;;
    
    Conditional AND jmp / Saut AND conditionel

    sub eax 45 | JmpIf ZERO L1<

    sub D$ebx 127 |JmpIf ZERO S1>,
                         NEGATIVE S2>
   
    Test eax ebx ZERO S1>
    
    Test eax NA ZERO S1>,
                NEGATIVE S2>
    
    Test D$FL.Var &TRUE TRUE S1>
  
    Test D$FL.Var &TRUE FALSE S1>
    
    On eax = ebx Call Procedure
    On eax > ebx Mov ebx eax, jmp S1<

;;

[JmpIf

    j#1 #2

    #+2]

[Test

    test #1 #2

    JmpIf #3>L]

;;
    
    If/Else/Else_If/End_If -> !!! Short jumps only. Structure properly!
                              !!! Sauts courts uniquement (structurez convenablement).

    If eax = 0
        ...
    Else_If eax > 17, eax < 42
            ...

        If ebx = &FALSE
            ...

        Else
            ...

        End_If

        ...

    End_If
    
;;

;;
[IncCnt1

    #If &&1=0       ; Zero the counter / RAZ compteur l'ors de la première évocation de la macro

        &&1= '0'

    #Else

        &&1=&&1+1   ; Can be incremented up to 9 / Incrément jusqu'à '9'

    #EndIf]

[If.

    cmp #1 #3

    jn#2 M&&1>

    #+3]

[If

    IncCnt1

    If. #1>L]

[Else_If

    jmp N&&1>

 M&&1:

    If. #1>L]

[Else

    jmp N&&1>

 M&&1:]

[End_If

    M&&1:
    N&&1:

    &&1=&&1-1]
;;

;;

    Repeat macro

        ... 

    Until B$esi = EOS 

;;

[Repeat

    #If &&2=0

        &&2= '0'

    #Else

        &&2=&&2+1

    #EndIf

    O&&2:]

[Until

    cmp #1 #3 | jn#2 O&&2<

    O&&2: &&2=&&2-1]

;;

    While B$esi <> EOS 

        ... 

    EndWhile 

;;

[While

    #If &&2=0

        &&2= '0'

    #Else

        &&2=&&2+1

    #EndIf

    O&&2:

    cmp #1 #3 | jn#2 O&&2>]

[End_While

    jmp O&&2<

    O&&2: &&2=&&2-1]

;;

    !!! EXCEPTIONEL NE JAMAIS FAIRE DE MACROS D'ENCAPSULATION DE CE GENRE

    Macros pour utiliser le module de debuggage de la DEBUG.DLL:

        ; Saute une ligne
        OutPutStringLiteral CR LF

        ; Affiche le nom de la variable [FLOAT] et son contenu
        OutPutFloat F$F.Variable | OutPutStringLiteral CR LF

        ; Affiche le nom de la variable [REEL] et son contenu
        OutPutReel R$R.Variable | OutPutStringLiteral CR LF

        ; Affiche le nom de la variable [DWORD] non signé et son contenu au format decimal
        OutPutDec D$DU.Variable | OutPutStringLiteral CR LF

        ; Affiche le nom du Lp -> Préfixe.Variable et son adresse au format hexadecimal
        OutPutDec DU.Variable | OutPutStringLiteral CR LF

        ; Idem avec un registre
        Mov eax 1999 | OutPutDec eax | OutPutStringLiteral CR LF

        ; Affiche le nom de du registre et son contenu au format hexadecimal
        Mov eax 0_ABCDEF | OutPutHex eax | OutPutStringLiteral CR LF

        ; Affiche le nom de la variable [DWORD] non signé et son contenu au format hexadecimal
        OutPutHex D$DU.Variable | OutPutStringLiteral CR LF

        ; Affiche le nom du registre et son contenu signed au format decimal
        Mov eax 0-32000 | OutPutSignedDec eax | OutPutStringLiteral CR LF

        ; Idem
        Mov eax 0FFFF_FFFF | OutPutSignedDec eax | OutPutStringLiteral CR LF

        ; Affiche le nom du Lpointeur sur la chaine de bytes et son contenu au format ASCII
        OutPutString STR.A.Variable | OutPutStringLiteral CR LF

        ; Affiche le contenu ASCII transmis
        OutPutStringLiteral "1234567890123456789012345678901234567890123456789012345678901234567890123456" CR LF,
                            "1234567890123456789012345678901234567890123456789012345678901234567890123456" CR LF,
                            "1234567890123456789012345678901234567890123456789012345678901234567890123456" CR LF,
                            "1234567890123456789012345678901234567890123456789012345678901234567890123456" CR LF,
                            "1234567890123456789012345678901234567890123456789012345678901234567890123456" CR LF,
                            "1234567890123456789012345678901234567890123456789012345678901234567890123456" CR LF,
                            "1234567890123456789012345678901234567890123456789012345678901234567890123456" CR LF,
                            "1234567890123456789012345678901234567890123456789012345678901234567890123456" CR LF,

                            ;...

                            "1234567890123456789012345678901234567890123456789012345678901234567890123456" CR LF,
                            "1234567890123456789012345678901234567890123456789012345678901234567890123456" CR LF,
                            "1234567890123456789012345678901234567890123456789012345678901234567890123456" CR LF,
                            "1234567890123456789012345678901234567890123456789012345678901234567890123456" CR LF,
                            "1234567890123456789012345678901234567890123456789012345678901234567890123456" CR LF

        ; Ajoute dans le fichier DebugLog.txt le contenu ASCII transmis (EOS n'est pas
        ; nécessaire en fin de liste).
        ; !!! Le texte n'apparait pas dans la fenêtre de debugg, c'est une REM pour le fichier
        OutPutLog "Texte enregistré dans le fichier DebugLog.txt" CR LF

        ; Affiche le dernier message d'erreur
        OutPutError

;;

[OutPutDec

    &6=#1

    {&0: B$ "&6" EOS}

    &6=

    Call 'DEBUGG.OutPutDec' &0,
                            #1]

[OutPutSignedDec

    &6=#1

    {&0: B$ "&6" EOS}

    &6=

    Call 'DEBUGG.OutPutSignedDec' &0,
                                  #1]

[OutPutHex

    &6=#1

    {&0: B$ "&6" EOS}

    &6=

    Call 'DEBUGG.OutPutHex' &0,
                            #1]

[OutPutFloat

    fld #1

    &6=#1

    {&0: B$ "&6" EOS}

    &6=

    Call 'DEBUGG.OutPutFloat' &0]

[OutPutReel

    fld #1

    &6=#1

    {&0: B$ "&6" EOS}

    &6=

    Call 'DEBUGG.OutPutReel' &0]

[OutPutString

    &6=#1

    {&0: B$ "&6" EOS}

    &6=

    Call 'DEBUGG.OutPutString' &0,
                               #1]

[OutPutError

    Call 'DEBUGG.OutPutError' ]

[OutPutStringLiteral

    {&0: B$ #F>L EOS}

    Call 'DEBUGG.OutPutStringSimple' &0]

[OutPutLog

    {&0: B$ #F>L EOS}

    Call 'DEBUGG.OutPutLogFile' &0]

[OutVideDebbug

    Call 'DEBUGG.VideDebbug']
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE EQUATES         ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;

    English:

    Equates guidelines:

    - All the global equates should be here in this TITLE.
      It applies to Individual equates and structure equates

    - They must be regrouped in categories

    - They must be in alphabetical order of their prefix

    - They must be in alphabetical order

    Français:

    - TOUTES les définitions d'EQUATES à portées globales doivent se trouver dans ce TITLE:
      que ce soit des EQUATES individuelles ou des structures d'EQUATES

    - Etre rangées par catégories

    - Etre rangées en ordre alphabétique de préfixe

    - Etre rangées en ordre alphabétique de nom (à moins que ce ne soit une Struture
      d'Equates évidement)

;;
________________________________________________________________________

; Message [MSG_PUMP] equates (Used in WindowProc or DialogProc)

; Equates pour manipuler les arguments provenant du [MSG_PUMP] dans les
; routines de traitements des WindowProc ou DialogProc
________________________________________________________________________

[CALLBACK ebp+(01*DWORD)  ; Adresse de retour
 HWND     ebp+(02*DWORD)  ; Handle de la fenêtre courante
 MSG      ebp+(03*DWORD)  ; Id message fenêtre courant
 WPARAM   ebp+(04*DWORD)  ; 32-bit message-specifique
 LPARAM   ebp+(05*DWORD)] ; 32-bit message-specifique
______________________________________________________________________

; Size equates : Mov eax D$esi+(2*DWORD),
;                     cl B$ah+(3*BYTE)

; Equates d'offsets taille: Mov eax D$esi+(2*DWORD),
;                           cl B$ah+(3*BYTE)
______________________________________________________________________

[BYTE     1  ; 0-128/+127 or 0/255 00/00_FF
 ASCII    1  ; Need the A suffix in some APIS (See also Tools menu -> Ascii Table)
 DWORD    4  ; 0-2147483648/+2147483647 or 0/4294967295 00/00_FFFF_FFFF
 FLOAT    4  ; http://en.wikipedia.org/wiki/IEEE_754-1985
 QWORD    8  ; 00/00_FFFF_FFFF_FFFF_FFFF
 REEL     8  ; http://en.wikipedia.org/wiki/IEEE_754-1985
 UNICODE  2  ; Need the W suffix in some APIs
 WORD     2  ; 0-32768/32767 ou 0/65535 00/00_FFFF
 XWORD   16] ; For SSE
______________________

; Equates for strings

; Equates chaînes
______________________

[EOS      0_0           ; End of string (BYTE)
 SPC      0_20          ; Space (BYTE)
 TAB      0_9           ; Tabulation (BYTE)
 CR       0_D           ; Carriage return (BYTE)
 CRCR     0_D_0D        ; Double carriage return (WORD)
 LF       0_A           ; Line feed (BYTE)
 LFLF     0_A_0A        ; Double line feed (WORD)
 CRLF     0_A_0D        ; Carriage return + line feed (WORD)
 LFCR     0_D_0A        ; Line feed + carriage return (WORD)
 CRLF2    0_A_0D_0A_0D  ; Double carriage return + line feed (DWORD)
 CRLFEOS0 0_A_0D_00     ; Carriage return + line feed + EOS + 0 (DWORD)
 MLC      0_D_3B_3B_0A] ; MLC: Multi-Lines Comment: LF;;CR (DWORD)
___________________

; Equates for HLL

; Equates pour HLL
___________________

@EQUATES_HLL:

[= e    < b     > a     =< be   <= be   => ae   >= ae   <> ne

        <s l    >s g    =<s le  <=s le  =>s ge  >=s ge
        s< l    s> g    s=< le  s<= le  s=> ge  s>= ge

 FIND_EOS z   NOT_EOS  nz ; End Of String Search
 ZERO     z   NOT_ZERO nz ; Numérique
 NULL     z   NOT_NULL nz ; Lp
 FALSE    z   TRUE     nz ; Flags
 ODD      po  EVEN     pe ; Parité Impair/Pair
 NEGATIVE s   POSITIVE ns]; Sign
______________________________________

; Coordinates equate structures

; Structures d'equates de coordonnées
______________________________________

[PX (00*WORD)
 PY (01*WORD)]

[POINTX (00*DWORD)
 POINTY (01*DWORD)]

[LEFT   (00*DWORD)
 TOP    (01*DWORD)
 RIGHT  (02*DWORD)
 BOTTOM (03*DWORD)]

; MINMAXINFO Structure Equates Windows
[MINMAXINFO.ptReserved     (0*DWORD)
 MINMAXINFO.ptMaxSize      (2*DWORD)
 MINMAXINFO.ptMaxPosition  (4*DWORD)
 MINMAXINFO.ptTrackSize    (6*DWORD)
 MINMAXINFO.ptMaxTrackSize (8*DWORD)]
_______________

; Flag equates
_______________

[NA         0-1         ; 0-1 00_11111111_11111111_11111111_11111111 BYTE/WORD/DWORD
 NO         0_FFFF_FFFF ; 0-1 00_11111111_11111111_11111111_11111111 DWORD
 YES        0+1]        ; 1   00_00000000_00000000_00000000_00000001 0_1 &TRUE BYTE/WORD/DWORD
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE START_BUASM     ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

; Colors:
[ARVB.DialogsBackColor: B$ 0_F0 0_F0 0_FF 0_00] ; For Edit Controls, List Boxes (Default: Light Blue)

                                          ; Source Editor colors:
[ARVB.BackColor: B$ 0_FF 0_FF 0_FF 0_00   ; white BackGround color
 StatementColor: D$ 0_00_00_00            ; black for instructions
 BracketColor: D$ 0_A0                    ; [red] for Data / Equates / Macros
 TextColor: D$ 0_64_00                    ; 'green' for text
 CommentColor: D$ 0_82_00_00 ]            ; blue for comments


[DRAWLINELEN 92]    ; This is the number of '_' in a Line drawn by [Ctrl][_]

[UPPERCASEMASK 0_DF] ; (not 020) applied on a Byte.

;;
 To modify the default font used by the [Print] feature, Right Click on >>>  cbbuffer  <<<
 and do what you can there. Be aware that specifying a font for a Printer under Win32
 is absolutely crazy; i won't help you... Welcome to the one who could rewrite this
 in RosAsm.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

; Displacements inside a 'SectionsHeaders': ; 'PeHeader'

[SECTION_NAME 0
 SECTION_RVASIZE 8
 SECTION_RVA 12
 SECTION_FILESIZE 16
 SECTION_FILEPOINTER 20

 SECTION_RELOC_PTR 24
 SECTION_LINES_NUMBER_PTR 28
 SECTION_RELOC_NUMBER 32
 SECTION_NUMBER_OF_LINES_NUMBER 34

 SECTION_FLAG 36

 SECTIONHEADERSIZE 40]
_____________________________________________________________________________________________

;;
 
    Used abreviations:

    EOI      End Of Instruction
    meEOI    Macro Expension EOI
    CR       Carriage Returrn
    LF       Line Feed
    ALEOD    Api Lists End Of Data
    RVA      Relative Virtual Adress
    Len      Lenght

    Usual Tintel abreviations:

    SIB      Scale_Base_Index Byte
    Mod/RM   Mode and Register/Memory Byte
    tttnBits condition encodage

    MLC      Multi-Lines Comments

;;
_____________________________________________________________________________________________

; General purpose macros:

[inc | inc #1 | #+1]    [dec | dec #1 | #+1]

[If | #=3 | cmp #1 #3 | jn#2 I1>]
[Else_If | #=3 | jmp I9> | I1: | cmp #1 #3 | jn#2 I1>]
[Else | Jmp I9> | I1:]
[End_If | I1: | I9:]

[.If | #=3 | cmp #1 #3 | jn#2 J1>>]
[.Else_If | #=3 | jmp J9>> | J1: | cmp #1 #3 | jn#2 j1>>]
[.Else | Jmp j9>> | j1:]
[.End_If | j1: | j9:]

[..If | #=3 | cmp #1 #3 | jn#2 K1>>]
[..Else_If | #=3 | jmp K9>> | K1: | cmp #1 #3 | jn#2 K1>>]
[..Else | Jmp K9>> | K1:]
[..End_If | K1: | K9:]

[...If | #=3 | cmp #1 #3 | jn#2 Z1>>]
[...Else_If | #=3 | jmp Z9>> | Z1: | cmp #1 #3 | jn#2 Z1>>]
[...Else | Jmp Z9>> | Z1:]
[...End_If | Z1: | Z9:]

[.While | #=3 | X0: | cmp #1 #3 | jn#2 X9>>]
[.End_While | jmp X0<< | X9:]

[..While | #=3 | Y0: | cmp #1 #3 | jn#2 Y9>>]
[..End_While | jmp Y0<< | Y9:]

[Do | D0:]
[Loop_Until | #=3 | cmp #1 #3 | jn#2 D0<]
[Do_Loop | jmp D0<<]

[.Do | E0:]
[.Loop_Until | #=3 | cmp #1 #3 | jn#2 E0<<]

[Exchange | push #1 | push #2 | pop #1 | pop #2 | #+2]

[Agree | cmp #1 #3 | j#2 A9> | #+3]
[Reject | cmp #1 #3 | j#2 A8> | #+3 | jmp A9> | A8: | ret | A9:]

_________________________________________________________________________________________
_________________________________________________________________________________________
; Proc Macros and Equates. Internal storages are:
;
; &1 <<< Size of Argument(s) (for ending Ret n, in EndP). Set by Argument(s)
; &2 <<< Size of Local (for Stack Management). Set by Local
; &3 <<< What to pop before ret. Set by Uses.

[Proc | &1=0 | &2=0 | &3= | #1 | push ebp | mov ebp esp]

[ExitP | jmp P9>]

[Arguments | {#1 Arg#x} | #+1 | &1=SizeOf#x]
[Argument  | {#1 Arg#x} | #+1 | &1=SizeOf#x]

[Local | {#1 Local#x} | #+1 | sub esp SizeOf#x | &2=SizeOf#x]

[StrucPtrs | {#3 ebp+#2+#F} | #+2]

[Structure | {#1 ebp-&2-4} | sub esp #2+4 | mov D$#1 esp | StrucPtrs 0-&2-#2-4 #L>3]

[Uses | push #1>L | &3=pop #L>1]

[EndP | P9: | &3 | mov esp ebp | pop ebp | ret &1]

; For pointing to transmitted parameters (upper "Arg#x" fall here):

[Arg1 ebp+8    Arg2 ebp+12    Arg3 ebp+16    Arg4 ebp+20   Arg5 ebp+24
 Arg6 ebp+28   Arg7 ebp+32    Arg8 ebp+36    Arg9 ebp+40   Arg10 ebp+44]

; For pointing Local Stack declared data (upper "Local#x" fall here):

[Local1 ebp-4     Local2 ebp-8     Local3 ebp-12    Local4 ebp-16    Local5 ebp-20
 Local6 ebp-24    Local7 ebp-28    Local8 ebp-32    Local9 ebp-36    Local10 ebp-40]

; To help preventing from stack sizes' mistakes (upper "SizeOf#x" fall here):

[SizeOf1 4     SizeOf2 8     SizeOf3 12    SizeOf4 16    SizeOf5 20
 SizeOf6 24    SizeOf7 28    SizeOf8 32    SizeOf9 36    SizeOf10 40]

____________________________________________________________________________________________
____________________________________________________________________________________________

; Some basic System calls:

[HIDE_PUSHBUTTON_OK 1]

SetIconDialog:
    ______________________________________________

    ; Attribue l'icône de BUAsm au dialog courant
    ______________________________________________

    Call 'USER32.SetClassLongA' D$HWND,
                                &GCL_HICON,
                                D$STRUC.WINDOWCLASS@hIcon

ret

WM_CTLCOLOREDIT:
    __________________________________________________

    ; Attribue RVB fond utilisateur au dialog courant
    __________________________________________________

    Call 'USER32.SendMessageA' D$LPARAM,
                               &EM_SETSEL,
                               0-1,
                               0

    Call 'GDI32.SetBkColor' D$WPARAM,
                            D$ARVB.DialogsBackColor

    ; Eax doit être rtourné à l'OS dans le dialog
    Mov eax D$H.DialogsBackGroundBrush

ret


EndDialog:
    ______________________________

    ; Fermeture du dialog courant
    ______________________________


    Call 'USER32.EndDialog' D$HWND,
                            0

ret

Proc MessageBox:

    Argument @STR.A

    pushad

        Call 'USER32.MessageBoxA' D$H.MainWindow,
                                  D@STR.A,
                                  &NULL,
                                  &MB_SYSTEMMODAL

    popad

EndP


Proc HexPrint:

    Argument @DWORD

    [@STR.A.HexprintString: B$ '         Hex' EOS]

    pushad

        Mov eax D@DWORD,
            edx eax,
            ecx 7

L0:     Mov al dl

            and eax 0F

            Mov al B$STR.A.Hexa+eax,
                B@STR.A.HexprintString+ecx al

            shr edx 4

        sub ecx 1 | jns L0<

        Call 'USER32.MessageBoxA' D$H.MainWindow,,
                                  @STR.A.HexprintString,
                                  &NULL,
                                  &MB_SYSTEMMODAL+&MB_ICONINFORMATION

    popad

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; Replaces a Chunk in an existing Data set, by another Chunk.

Proc ChunkReplace:

    Argument @TargetA,          ; Original Buffer insertion start Point (first Byte)
             @TargetB,          ; Original Buffer insertion End Point (after last Byte)
             @TargetEnd,        ; Original Buffer end (Byte after last valid content)
             @TargetMemEnd,     ; Original Buffer Memory limit (after last Byte)
             @SourceA,          ; Substitute Start Point (first Byte)
             @SourceB           ; Substitute End Point (after last Byte)
    Local @NewEnd

    Uses esi, edi, ecx, edx

        Mov ecx D@SourceB | sub ecx D@SourceA
        Mov edx D@TargetB | sub edx D@TargetA
        Move D@NewEnd D@TargetEnd | add D@NewEnd ecx | sub D@NewEnd edx
        .If ecx > edx
          ; If the new Chunk is bigger than the old one:
            sub ecx edx
            Mov edi D@TargetEnd | dec edi | Mov esi edi | add edi ecx

            If edi >= D@TargetMemEnd
                Mov eax &FALSE | ExitP
            End_If

            Mov ecx D@TargetEnd | sub ecx D@TargetB | inc ecx | std | rep movsb | cld

        .Else_If ecx < edx
          ; If the new Chunk is smaller than the old one:
            xchg ecx edx | sub ecx edx
            Mov edi D@TargetB, esi edi | sub edi ecx

            Mov ecx D@TargetEnd | sub ecx D@TargetB | rep movsb
        .End_If

      ; Now, Copy the Chunk:
        Mov esi D@SourceA, edi D@TargetA
        Mov ecx D@SourceB | sub ecx D@SourceA | jecxz L9>
            Mov edx ecx | shr ecx 2 | rep movsd
            Mov ecx edx | and ecx 00_11 | jecxz L9>
                rep movsb

L9:     Mov eax D@NewEnd, B$eax 0 | Mov eax &TRUE
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[LP.NewMem: D$ ?]

[TABLES_SECURITY 100]

Proc ExtendTableMemory:

    Argument @Mem,
             @Pointer,
             @End

    pushad

        Test D$FL.Dynamic &TRUE TRUE S1>

            Call 'USER32.MessageBoxA' D$H.MainWindow,,
                                      &NULL,
                                      {B$ 'Petit problème...' EOS},
                                      &MB_OK

            Call CloseProgressBar

            Mov esp D$OldStackPointer
    popad

EndP


S1:     Mov eax D@Mem,
            eax D$eax

        Push eax

            Mov ecx D@Pointer, ecx D$ecx

            ; Get the actual Size, multiply by 2, and add the security:
            sub ecx eax | shl ecx 1

            Push ecx

                add ecx TABLES_SECURITY | Call VirtualAlloc LP.NewMem,
                                                            ecx
                ; Copy:
                Mov edi D$LP.NewMem
                Mov esi D@Mem, esi D$esi
                Mov ecx D@End, ecx D$ecx | sub ecx esi | AlignOn PAGE_SIZE ecx

                shr ecx 2 | rep movsd

            Pop ecx

            ; Save the new Mem Limit:
            add ecx D$LP.NewMem | Mov eax D@End, D$eax ecx

            ; Adjust and Save the new follow-up Pointer:
            Mov ebx D@Mem, ebx D$ebx
            Mov eax D@Pointer, eax D$eax
            sub eax ebx | add eax D$LP.NewMem
            Mov ebx D@Pointer, D$ebx eax

            ; Save the new Mem:
            Mov eax D$LP.NewMem | Mov ebx D@Mem, D$ebx eax

        Pop eax

        Call VirtualFree eax

    popad

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; Enough for small Tables:

Proc BubbleSort:

    Arguments @Array,
              @Size ; In bytes

    Uses eax,
         ecx,
         edx,
         edi

    Mov edi D@Array, ecx D@Size | shr ecx 2 | jecxz P9> ; TODO ExitP

L1: lea edx D$edi+ecx*DWORD

        Mov eax D$edi

L2:     sub edx DWORD | Comp eax D$edx s<= S1>

            xchg eax D$edx

S1:     Comp edx edi <> L2<

    stosd | loop L1<

EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc zStringsSort:
    Argument @Source, @Destination, @Number

        Mov ecx D@Number, edi D@Destination

L0:     Push ecx
            Mov esi D@Source, ecx D@Number, edx 0, bl 0FF

L1:         lodsb

            .If al = 0FF
                ; nop
            .Else_If al < bl
                Mov bl al | lea edx D$esi-1
            .Else_If al = bl
                Push ebx
                    Push edx, esi
                        While al = bl
                            lodsb | inc edx | Mov bl B$edx
                            cmp al 0 | je L2>
                        End_While
L2:                 Pop esi, edx
                    On al < bl, lea edx D$esi-1
                Pop ebx
            .End_If

            While B$esi <> 0 | inc esi | End_While | inc esi | loop L1<

            If edx > 0
                Mov esi edx
                While B$esi <> 0
                    movsb | Mov B$esi-1 0FF
                End_While

                Mov B$edi 0 | inc edi
            End_If

        Pop ecx | dec ecx | cmp ecx 0 | ja L0<<
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

[BUAsmFilesPath: B$ ? # &MAX_PATH]

GetBUAsmFilesPath:

    Push esi,
         edi

        Mov esi EquatesName, edi BUAsmFilesPath

        While B$esi <> EOS | movsb | End_While

        While B$edi <> '\' | sub edi ASCII | End_While

        Mov B$edi+1 EOS

    Pop edi,
        esi

ret
____________________________________________________________________________________________

; Trash Buffers:


[LP.MemTrash: D$ ?]

[LP.Trash: D$ ?
 STR.A.Trash: B$ ? # &MAX_PATH
 Trash1: B$ ? # 40_000
 Trash2: B$ ? # 40_000
 Trash3: B$ ? # 40_000]

ClearTrashTables:

    Push edi,
         ecx,
         eax

        Mov edi STR.A.Trash,
            ecx ((&MAX_PATH+(3*40_000))/DWORD)

        xor eax eax | rep stosd

    Pop eax,
        ecx,
        edi

ret
____________________________________________________________________________________________

[GetHexaFromTextError: D$ ?]

Proc GetHexaFromText:

    Argument @Buffer

    Uses esi

        Mov esi D@Buffer, edx 0, B$GetHexaFromTextError &FALSE

        While B$esi > 0

            lodsb | On al > 'Z', sub al SPC

            sub al '0' | On al > 9, sub al 7

            If al > 0F

                Call MessageBox {B$ 'The Number should be HexaDecimal' EOS}

                Mov B$GetHexaFromTextError &TRUE

EndP

            End_If

            shl edx 4 | or dl al

        End_While

        Mov eax edx

EndP
____________________________________________________________________________________________

; Computes the Length of a zero-ended Ascii String. Regs under caller responsability:

StrLen: ; edi -> String // StrLenProc

    Mov ecx 0-1,
        al 0

    repne scasb

    Mov eax 0-2 | sub eax ecx      ; Lenght in eax.

ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Strings         ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
  TITLE where to save the BUAsm Messages Strings having a possible counter-part
  in the national languages Files.
  
  In the BUAsmFiles Folder, if a 'BUAsmStrings.xx' is found out, the substitution
  is done by 'OpenStringsFile'.
  
  Organization:
  
  * The default English Strings are declared the usual way.
  
  * The [TABLE.STR.A.Error] contains 2 Dwords Records. Typically:
  
      STRING1 ErrorMessageTitlePtr: ErrorMessageTitle
      
      Where: 
      - 'STRING1' is the StringID (Number 1)
      - 'ErrorMessageTitlePtr' is the Substitution Label
      - 'ErrorMessageTitle' is the Pointer to the default English Strings, in the Source
      
   The StringIDs purpose is to introduce some flexibility in the management:
   
   1) The ID as found in the 'BUAsmStrings.xx' File and in the [TABLE.STR.A.Error]
   are simple Ordinal, and must be given, in both cases, in the Ordinal order.
   
   2) Some Strings and IDs may be missing.
   
   * How it works:
   
   When a National Language String is found out, it is loaded for once, in Memory.
   
   CRLF are zeroed and the Strings are parsed:
   
   When some '$$$$25' is found, the 'OpenStringsFile' translates '25' into Binary
   and searches the matching Record ID, inside the [TABLE.STR.A.Error]. Once this
   Record is pointed out, the String Pointer is overwritten, in order to point
   to the char after '$$$$25 '.
   
   In failures cases, an error Message is send.
   
   __________________________
   For the BUAsm volunteers:
   
   When you develop your TITLE, do not use this. Simply write your own errors
   Messages inside your TITLE, the usual way.
   
   Then, only when you think that your developements are more or less in a fixed
   state, considering the errors Messages, Implement the Internationalization.
   
   How to:
   
   1) Move your Strings here, after the existing ones.
   2) If there is not enough 'STRINGXXX' available, add the ones you need.
   3) Extend the [TABLE.STR.A.Error] to hold your own Strings.
   4) In your Source, replace all the concerned 'StringSymbol' by 'D$StringSymbolPtr'.
   2) Take a copy of 'BUAsmStrings.en', and append your Strings.
   
   For the Equates Ordinals, you can go to the next 1000 Boundary, so that each
   Volunteer (or purpose) will have a set of 1000 Strings IDs reserved, in order
   to ease a little bit the future Maintainance. For example, the Equal Pre-Parser
   Strings could begin at 2000, the Debugger Strings at 3000, and so on... I plan
   to use 1000 for the BUAsm Menu, and some other things.
   
   Once done, send me, all at once: Your TITLE, The Strings TITLE and the
   'BUAsmStrings.en' File.
;;



[ErrorMessageTitle: B$ ' error' EOS]  ; Error,  OutOnError

; List of error messages:

[EmptyString: B$   '                                                        ' EOS]
[MissingFile: B$ 'File not found' EOS]
[BusyFile: B$ 'Unable to open: System mangling destination file' EOS]
[CreationFile: B$ 'Error when trying writting file' EOS]
[OpenFile: B$ 'File To open Not found' EOS]
[MissFile: B$ 'File not found' EOS]
[NoReadFile: B$ 'Unable to read file' EOS]
[MissEquateVal: B$ 'Missing equate value' EOS]
[EquateLabel: B$ 'An Equate name can not be followed by a Colon Char' EOS]
[TextEquate: B$ 'Missing ">" Char at the end of Text Equate' EOS]
[MacPara: B$ 'Bad parameters number in macro evocation' EOS]
[MissingParameter: B$ 'Bad parameters number in Macro evocation' EOS]
[MacNumber: B$ 'Bad # construction' EOS]
[BadMacroDirection: B$ 'Always ">", for Macros Multiple Parameters. Never "<"' EOS]
[TooBigX: B$ '#x limit is 9' EOS]
[TooMuchParam: B$ 'Too much Parameters found when unfolding' EOS]
[InfiniteLoop: B$ 'An infinite loop has been generated when unfolding this macro' EOS]
[MacrosOverFlow: B$ 'More than 4000 Bytes outputed at once, when unfolding this Macro!!!' EOS]
[UnknownData: B$ 'Unknown data type' EOS]
[UnknownSize: B$ 'Unknown Size marker' EOS]
[Mem3D: B$ '64 Bits (Q$...) mem size expected for all 3D Now instructions' EOS]
[NewHmem: B$ '"H$" now reserved for futher developement. Use "R$" or "F$" instead' EOS]
[PrefetchMem: B$ 'Prefetch/w/0/1/2/NTA syntax: > PrefetchXXX B$Address' EOS]
[DsizeForLab: B$ 'D$ needed for Labels data' EOS]
[Unknown: B$ 'Unknown text structure. May be internal error' EOS]
[BadSeparator: B$ 'Unexpected separator' EOS]
[BinType: B$ 'Invalid binary number' EOS]
[HexType: B$ 'Invalid Hexa number' EOS]
[DezimalType: B$ 'Invalid decimal number' EOS]
[OutOfRange: B$ 'Out of range value' EOS]
[DefEquate: B$ 'This equate or macro symbol is already used' EOS]
[DefReEquate: B$ 'This equate symbole is not in use' EOS]
[TooMuchLabels: B$ 'More than 2 labels is this expression' EOS]
[BadLabel: B$ 'Bad character in Label name' EOS]
[LabelDup: B$ 'Duplicate label definition' EOS]
[SymbolDup: B$ 'Duplicate symbol definition' EOS]
[OrphanColon: B$ 'Orphan Colon sign encounted' EOS]
[LocalDefLabel: B$ 'Local label not allowed in data definition' EOS]
[NoLocalCall: B$ 'You cannot Call for a Local Label' EOS]
[NotAnOpcode: B$ 'Unknown mnemonic' EOS]
[OverByte: B$ 'Value out of byte range' EOS]
[OverWord: B$ 'Value out of word range' EOS]
[OverDword: B$ 'Value out of Dword range' EOS]
[LenSize: B$ 'Leading Len can only be dWord or word' EOS]
[BadReal: B$ 'Bad real number declaration' EOS]
[OrphanPrefix: B$ 'An instruction prefix can not stand alone' EOS]
[DoubleSOP: B$ 'Double Segment override not allowed' EOS]
[NotSegment: B$ 'Unresolved segment override' EOS]
[Parameter: B$ 'Unvalid parameter' EOS]
[Double0: B$ 'Only one "&0" automatic Label per Macro' EOS]
[MissingSign: B$ 'Need of equal or colon sign' EOS]
[MissingSeparator: B$ 'Missing space at end of a Data String declaration' EOS]
[BadMacroLoop: B$ 'Bad placement of Loop instruction in Macro' EOS]
[TooMuch: B$ 'Too much operands found' EOS]
[DBsize: B$ 'Hexa Octets values expected for Code Bytes' EOS]
[LockError: B$ 'No Lock Prefix with this instruction' EOS]
[LockMemError: B$ 'Lock: One Member must be Memory' EOS]
[MissingOperand: B$ 'Missing operand' EOS]
[NotEnough: B$ 'Missing operand' EOS]
[MemMem: B$ 'Expressions are allowed for only one memory adressing parameter' EOS]
[Parenthesis: B$ 'Unpaired parenthesis' EOS]
[ParaMacro: B$ 'ad ParaMacro' EOS]
[MacroVariableIndice: B$ 'Macros Variables are from "&1" to "&100" (Decimal)' EOS]
[NestedMacroVariable: B$ 'Imbricated declaration of Macro Variable' EOS]
[MarkerBefore: B$ '$ize Marker wanted before Real Expression' EOS]
[MarkerAfter: B$ '$ize Marker wanted after Real Expression' EOS]
[ExpressionMember: B$ 'Immediate only in Expressions' EOS]
[NoDataLocalLabel: B$ 'No Local Labels in Data: They are reserved for Code' EOS]
[RealNotation: B$ 'Real Expression: only +-*/ Operators, no nested Parenthesis' EOS]
[ExpressionSign: B$ 'Bad operator in Expression' EOS]
[DataLoopNumber: B$ 'For Huge Data Declaration, use Virtual (?) Data or Call for VirtualAlloc' EOS]
[SmallDataLoop: B$ 'What do you mean with "repeat less than 2 times???..."' EOS]
[BadLoop: B$ 'Loop with no previous Data Declaration' EOS]
[VDataLoopNumber: B$ 'For huge Virtual Tables: VirtualAlloc or [Configuration]/[Bad Habits]' EOS]
[TooMuchExpression: B$ 'Expression number too big in result or before multiplication' EOS]
[ExpressionNOT: B$ 'NOT must be at leading Pos of an Expression member' EOS]
[ExpressionSHR: B$ 'SHR / SHL Parameter over Byte size in Expression' EOS]
[OpenText: B$ 'Unpaired text delimiter' EOS]
[Orphanbracket: B$ 'Unpaired square bracket' EOS]
[UnexpectedCRLF: B$ 'Unexpected CR LF after Bracket' EOS]
[MissingSeparator1: B$ 'Missing Separator before Text Delimiter' EOS]
[MissingSeparator2: B$ 'Missing Separator after Text Delimiter' EOS]
[UnPairedNestedBrackets: B$ 'Unpaired {Nested} Brackets' EOS]
[NestedBrackets: B$ "'{}' chars are reserved for nested Declarations" EOS]
[PseudoLocal: B$ "Pseudo local '@Label' before any Plain Label declaration" EOS]
[DoubleSIB: B$ 'Only one Index and one base allowed in SIB' EOS]
[EspIndex: B$ 'ESP can t be use as an index in SIB' EOS]
[Expression: B$ 'Impossible effective address parameter' EOS]
[ScaleValue: B$ 'Scale possible values are 2, 4, 8 and extensions to 3, 5, 9' EOS]
[ESPsib: B$ 'ESP can t be used as index register' EOS]
[DoubleIndex: B$ 'Only one index allowed in expression' EOS]
[DoubleLabel: B$ 'Double label or unknown error' EOS]
[UnknownParameter: B$ 'unable to resolve this parameter' EOS]
[EnterStack: B$ 'Enter Stack size goes up to 0FFFC and must be 4 Bytes aligned' EOS]
[EnterLevel: B$ 'Enter level goes from 0 to 31' EOS]
[LeaInstead: B$ 'To retrieve Label+imm Adress, use LEA. Exemple: " > lea ebx D$Label+8" ' EOS]
[MixType: B$ 'these two parameters types not allowed together' EOS]
[MissType: B$ 'UnFitting sizes of operands' EOS]
[OperandsTypes: B$ 'Failure of Analyze in operands types for this mnemonic' EOS]
[BadAlign: B$ 'The Alignment must be a power of two between 4 and 0100' EOS]
[OperandSize: B$ 'Bad operand size' EOS]
[FPregNotAssumed: B$ "Can't guess Registers for this FP Instruction" EOS]
[LeaTypes: B$ '"lea reg, mem" only. For "lea eax imm", use "Mov eax imm"' EOS]
[LeaSize: B$ 'There is no Byte form for lea' EOS]
[EndingImm: B$ 'Third imm parameter wanted' EOS]
[Xmarker: B$ 'X$Memory parameter wanted' EOS]
[OverFlow: B$ 'Over flow of immediate number' EOS]
[UnknownSymbol: B$ 'This symbolic name does not fit with any label' EOS]
[WhatIsThis: B$ 'What is this?' EOS]
[UnAble: B$ 'BUAsm has been unable to assemble this instruction' EOS]
[NotYetSign: B$ 'Only + - signs allowed here, or see [Expressions] in Help' EOS]
[NotYetMnemo: B$ 'Sorry, this mnemonic is not yet implemented. Information needed' EOS]
  ;ShortDis: B$ 'Need of long dis., >> or << (never on LOOP)' EOS
[TooLongOf: B$ '     Byte(s) out of range' EOS]
[ShortDis: B$ "Need of long dis., >> or << (never on LOOP)
#1 #2 out of range" EOS]

[NoPlainLabelForLoop: B$ 'Local Up Short Label is required for LOOP' EOS]
[LongLoop: B$ 'Local Up Short Label is required for LOOP' EOS]
[NoPlainLabelForJECX: B$ 'Short Local Label (up or down) is required for JCXZ / JECXZ' EOS]
[LongDis: B$ 'Only Short displacement allowed with this mnemonic' EOS]
[NForbiden: B$ 'N symbol not allowed here. Use L' EOS]
[MixedLen: B$ "You can't mix 'head LEN' and 'Free LEN'" EOS]
[BadLoopNumber: B$ 'decimal value expected for data declaration loop number' EOS]
[VirtualData: B$ 'Bad Virtual Data' EOS]
[NestedLoop: B$ 'Sorry, data loop can not be nested' EOS]
[NeedByteSize: B$ 'Byte size required' EOS]
[OnlyAcc: B$ 'Only accumulator with this instruction' EOS]
[TxtTooMuch: B$ 'Text parameter exceeding 4 bytes' EOS]
[GPregister: B$ 'A register must be general purpose' EOS]
[VERRword: B$ 'VERR/VERW / LTR parameter must be 16 bits register or memory' EOS]
[WishEreg: B$ 'Memory adressing expects full 32 bit general purpose registers' EOS]
[BadApi: B$ "Api calls form is: Call 'Module.Function'" EOS]
[NoApi: B$ 'No Api Call found in source' EOS]
[DllNotFound: B$ 'Internal error: user called DLL not found at compile time' EOS]
[ApiNotFound: B$ 'Internal error: user called API not found at compile time' EOS]
[NoLocal: B$ 'Local Label not allowed here' EOS]
[NoEntry: B$ 'Entry Point not found (should be "Main:" if not modified)' EOS]
[BadFPUcond: B$ 'FPU available conditions: B, E, BE, NA, U, NB, AE, NE, NZ, NBE, A, NU' EOS]
[ST0wished: B$ 'One of these two reg must be ST0' EOS]
[STwished: B$ 'Only ST0, ST1, ...., ST7  regs with this mnemonic' EOS]
[FADDPreg0: B$ 'FADDP second Reg must be ST0' EOS]
[FSUBPreg0: B$ 'FSUBP second Reg must be ST0' EOS]
[BadFpChar: B$ 'Unexpected Char inside Float Expression' EOS]
[NoAdressee: B$ 'Internal: Unknown adressee' EOS]
[BadMemRelease: B$ 'Internal: Fail of Memory release' EOS]
[NotPE: B$ 'No source in this PE. Disassemble it?' EOS]
[NotPeExe: B$ 'This is not a PE File' EOS]
[BadWinEqu: B$ 'Unknown Win Equates name' EOS]
[IdTooSmall: B$ 'ID base number must be between 1 and 65535' EOS]
[IdTooBig: B$ 'ID base number must be between 1 and 65535' EOS] ;;;1000 and 32000' EOS
[BadLibName: B$ 'Wrong Module name' EOS]
[DoubleFunction: B$ 'Impossible: Same Function in 2 DLLs       ' EOS]
[BadFunctionName: B$ 'Wrong api name' EOS]
[BadOrdinal: B$ 'Wrong api Ordinal' EOS]
[NoAapi: B$ 'No ending "A" here' EOS]
[MacVarOverFlow: B$ 'Too long Data (or infinite storage loop) for Macro "&x="' EOS]
[MacVarNumber: B$ 'Too high Number for a Macro Variable' EOS]
[MissingApiA: B$ 'Ending "A" (or "W") wanted' EOS]
;[BadPreParse: B$ 'PREPARSE is for: Alternates, Equal' EOS]
[MissingCLASSname: B$ 'Missing Class Name' EOS]
[NoParentClass: B$ 'Parent CLASS not found when unfolding Inheritance' EOS]
[SizeOfResource: B$ 'Too Big Resources. Big Images or Sounds should be left in Files' EOS]
[NumerAsSymbol: B$ 'A Number cannot be a Symbolic Name' EOS]
[UnexpectedReg: B$ 'Unexpected Register or too short Symbol' EOS]
[TextKilling: B$ 'This Macro removes a Text Delimiter' EOS]
[NestedMacroLoop: B$ 'Split your Macro: No Nested Loop here' EOS]
[ConditionalLoop: B$ 'A Macro Loop cannot be inside a Conditional "If"' EOS]
[UnpairedMacroIf: B$ 'Unpaired If in the Macro Declaration' EOS]
[BadCMIndice: B$ 'Bad Conditional Indice (should be from 1 to 99)' EOS]
[BadConditionalmacro: B$ 'Bad Conditional macro' EOS]
[ZZZZreserved: B$ 'Symbols in "ZZZZZZZZ" form are reserved for Automatic Labels' EOS]
[BadSyntaxBeforeComma: B$ "Bad syntax. Inside your macro and before the comma, you inserted Naked Operator Signs (+ - / ^ *).
BUAsm will fix this automatically in order to you continue assembling your app.
  Please, consider fixing the sytax manually the next time you assemble your program, to avoid this warning." EOS]


;;
  This Table is for holding the national languages, if some 'BUAsmStrings.xx' is
  found out, at launch time. 
;;

[TABLE.STR.A.Error:
 1 ErrorMessageTitlePtr: ErrorMessageTitle
 2 @EmptyStringPtr: EmptyString
 3 @MissingFilePtr: MissingFile
 4 BusyFilePtr: BusyFile
 5 @CreationFilePtr: CreationFile
 6 @OpenFilePtr: OpenFile
 7 @MissFilePtr: MissFile
 8 @NoReadFilePtr: NoReadFile
 9 MissEquateValPtr: MissEquateVal
 10 EquateLabelPtr: EquateLabel
 11 TextEquatePtr: TextEquate
 12 MacParaPtr: MacPara
 13 MacNumberPtr: MacNumber
 14 BadMacroDirectionPtr: BadMacroDirection
 15 TooBigXPtr: TooBigX
 16 @TooMuchParamPtr: TooMuchParam
 17 InfiniteLoopPtr: InfiniteLoop
 18 MacrosOverFlowPtr: MacrosOverFlow
 19 UnknownDataPtr: UnknownData
 20 UnknownSizePtr: UnknownSize
 21 Mem3DPtr: Mem3D
 22 NewHmemPtr: NewHmem
 23 PrefetchMemPtr: PrefetchMem
 24 DsizeForLabPtr: DsizeForLab
 25 UnknownPtr: Unknown
 26 BadSeparatorPtr: BadSeparator
 27 BinTypePtr: BinType
 28 HexTypePtr: HexType
 29 DezimalTypePtr: DezimalType
 30 OutOfRangePtr: OutOfRange
 31 @DefEquatePtr: DefEquate
 32 @DefReEquatePtr: DefReEquate
 33 TooMuchLabelsPtr: TooMuchLabels
 34 BadLabelPtr: BadLabel
 35 @LabelDupPtr: LabelDup
 36 SymbolDupPtr: SymbolDup
 37 OrphanColonPtr: OrphanColon
 38 @LocalDefLabelPtr: LocalDefLabel
 39 NoLocalCallPtr: NoLocalCall
 40 NotAnOpcodePtr: NotAnOpcode
 41 OverBytePtr: OverByte
 42 OverWordPtr: OverWord
 43 OverDwordPtr: OverDword
 44 LenSizePtr: LenSize
 45 BadRealPtr: BadReal
 46 @OrphanPrefixPtr: OrphanPrefix
 47 @DoubleSOPPtr: DoubleSOP
 48 NotSegmentPtr: NotSegment
 49 ParameterPtr: Parameter
 50 MissingParameterPtr: MissingParameter
 51 Double0Ptr: Double0
 52 @MissingSignPtr: MissingSign
 53 MissingSeparatorPtr: MissingSeparator
 54 BadMacroLoopPtr: BadMacroLoop
 55 TooMuchPtr: TooMuch
 56 @DBsizePtr: DBsize
 57 LockErrorPtr: LockError
 58 LockMemErrorPtr: LockMemError
 59 MissingOperandPtr: MissingOperand
 60 NotEnoughPtr: NotEnough
 61 @MemMemPtr: MemMem
 62 ParenthesisPtr: Parenthesis
 63 ParaMacroPtr: ParaMacro
 64 MacroVariableIndicePtr: MacroVariableIndice
 65 NestedMacroVariablePtr: NestedMacroVariable
 66 MarkerBeforePtr: MarkerBefore
 67 MarkerAfterPtr: MarkerAfter
 68 @ExpressionMemberPtr: ExpressionMember
 69 NoDataLocalLabelPtr:  NoDataLocalLabel
 70 RealNotationPtr: RealNotation
 71 ExpressionSignPtr: ExpressionSign
 72 DataLoopNumberPtr: DataLoopNumber
 73 SmallDataLoopPtr: SmallDataLoop
 74 BadLoopPtr: BadLoop
 75 VDataLoopNumberPtr: VDataLoopNumber
 76 TooMuchExpressionPtr: TooMuchExpression
 77 ExpressionNOTPtr: ExpressionNOT
 78 ExpressionSHRPtr: ExpressionSHR
 79 OpenTextPtr: OpenText
 80 OrphanBracketPtr: OrphanBracket
 81 UnexpectedCRLFPtr: UnexpectedCRLF
 82 MissingSeparator1Ptr: MissingSeparator1
 83 MissingSeparator2Ptr: MissingSeparator2
 84 UnPairedNestedBracketsPtr: UnPairedNestedBrackets
 85 @NestedBracketsPtr: NestedBrackets
 86 @PseudoLocalPtr: PseudoLocal
 87 @DoubleSIBPtr: DoubleSIB
 88 @EspIndexPtr: EspIndex
 89 ExpressionPtr: Expression
 90 ScaleValuePtr: ScaleValue
 91 ESPsibPtr: ESPsib
 92 DoubleIndexPtr: DoubleIndex
 93 @DoubleLabelPtr: DoubleLabel
 94 UnknownParameterPtr: UnknownParameter
 95 EnterStackPtr: EnterStackPtr
 96 @EnterLevelPtr: EnterLevel
 97 @LeaInsteadPtr: LeaInstead
 98 MixTypePtr: MixType
 99 MissTypePtr: MissType
 100 OperandsTypesPtr: OperandsTypes
 101 BadAlignPtr: BadAlign
 102 OperandSizePtr: OperandSize
 103 FPregNotAssumedPtr: FPregNotAssumed
 104 LeaTypesPtr: LeaTypes
 105 LeaSizePtr: LeaSize
 106 EndingImmPtr: EndingImm
 107 XmarkerPtr: Xmarker
 108 OverFlowPtr: OverFlow
 109 UnknownSymbolPtr: UnknownSymbol
 110 WhatIsThisPtr: WhatIsThis
 111 @UnAblePtr: UnAble
 112 NotYetSignPtr: NotYetSign
 113 NotYetMnemoPtr: NotYetMnemo
 114 ShortDisPtr: ShortDis
 115 @TooLongOfPtr: TooLongOf
 116 NoPlainLabelForLoopPtr: NoPlainLabelForLoop
 117 LongLoopPtr: LongLoop
 118 NoPlainLabelForJECXPtr: NoPlainLabelForJECX
 119 LongDisPtr: LongDis
 120 NForbidenPtr: NForbiden
 121 MixedLenPtr: MixedLen
 122 BadLoopNumberPtr: BadLoopNumber
 123 VirtualDataPtr: VirtualData
 124 NestedLoopPtr: NestedLoop
 125 NeedByteSizePtr: NeedByteSize
 126 OnlyAccPtr: OnlyAcc
 127 TxtTooMuchPtr: TxtTooMuch
 128 GPregisterPtr: GPregister
 129 VERRwordPtr: VERRword
 130 WishEregPtr: WishEreg
 131 BadApiPtr: BadApi
 132 NoApiPtr: NoApi
 133 @DllNotFoundPtr: DllNotFound
 134 @ApiNotFoundPtr: ApiNotFound
 135 NoLocalPtr: NoLocal
 136 NoEntryPtr: NoEntry
 137 BadFPUcondPtr: BadFPUcond
 138 ST0wishedPtr: ST0wished
 139 STwishedPtr: STwished
 140 FADDPreg0Ptr: FADDPreg0
 141 FSUBPreg0Ptr: FSUBPreg0
 142 @BadFpCharPtr: BadFpChar
 143 @NoAdresseePtr: NoAdressee
 144 @BadMemReleasePtr: BadMemRelease
 145 NotPEPtr: NotPE
 146 NotPeExePtr: NotPeExe
 147 BadWinEquPtr: BadWinEqu
 148 IdTooSmallPtr: IdTooSmall
 149 IdTooBigPtr: IdTooBig
 150 BadLibNamePtr: BadLibName
 151 DoubleFunctionPtr: DoubleFunction
 152 BadFunctionNamePtr: BadFunctionName
 153 BadOrdinalPtr: BadOrdinal
 154 NoAapiPtr: NoAapi
 155 MacVarOverFlowPtr: MacVarOverFlow
 156 @MacVarNumberPtr: MacVarNumber
 157 MissingApiAPtr: MissingApiA
 158 BadPreParsePtr: BadPreParsePtr
 159 @MissingCLASSnamePtr: MissingCLASSname
 160 @NoParentClassPtr: NoParentClass
 161 @SizeOfResourcePtr: SizeOfResource
 162 NumerAsSymbolPtr: NumerAsSymbol
 163 UnexpectedRegPtr: UnexpectedReg

 164 TextKillingPtr: TextKilling
 165 NestedMacroLoopPtr: NestedMacroLoop
 166 UnpairedMacroIfPtr: UnpairedMacroIf
 167 ConditionalLoopPtr: ConditionalLoop
 168 @BadCMIndicePtr: BadCMIndice
 169 BadConditionalmacroPtr: BadConditionalmacro
 170 BadSyntaxBeforeCommaPtr: BadSyntaxBeforeComma
____________________________________________________________________________________________
; Debugger strings

 3000 StrRunPtr: StrRun
 3001 StrStepIntoPtr: StrStepInto
 3002 StrStepOverPtr: StrStepOver
 3003 StrStepPtr: StrStep
 3004 StrReturnPtr: StrReturn
 3005 StrRetPtr: StrRet
 3006 StrTerminatePtr: StrTerminate
 3007 StrPausePtr: StrPause
 3008 StrHoldOnBpPtr: StrHoldOnBp
 3009 StrInstStepPtr: StrInstStep
 3010 StrSrcStepPtr: StrSrcStep
 3011 StrShowAllPtr: StrShowAll
 3012 StrFontPtr: StrFont
 3013 StrCPUInfoPtr: StrCPUInfo
 3014 StrFPUStatusPtr: StrFPUStatus
 3015 StrShowCodeAtPtr: StrShowCodeAt
 3016 StrAboutPtr: StrAbout
 3017 StrDbgHelpPtr: StrDbgHelp

 3040 StrDataFmtPtr: StrDataFmt

 3050 StrContinuePtr: StrContinue
 3051 StrBreakPtr: StrBreak
 3052 StrSettingsPtr: StrSettings
 3053 StrInformationPtr: StrInformation
 3054 StrHelpPtr: StrHelp

 3060 StrShowInMemInspPtr: StrShowInMemInsp
 3061 StrShowPInMemInspPtr: StrShowPInMemInsp
 3062 StrShowDeclPtr: StrShowDecl
 3063 StrBreakOnWPtr: StrBreakOnW
 3064 StrBreakOnRWPtr: StrBreakOnRW
 3065 StrSortByNamePtr: StrSortByName
 3066 StrSortByAddrPtr: StrSortByAddr

 3080 StrShowInvokePtr: StrShowInvoke
 3081 StrShowAllCallsPtr: StrShowAllCalls
 3082 StrHideModCallsPtr: StrHideModCalls
 3083 StrHideIMCallsPtr: StrHideIMCalls
 3084 StrShowLocalsPtr: StrShowLocals

 3100 FmtHexPtr:      FmtHex
 3101 FmtUDecPtr:     FmtUDec
 3102 FmtSDecPtr:     FmtSDec
 3103 FmtBinaryPtr:   FmtBinary
 3104 FmtFloatPtr:    FmtFloat
 3105 FmtPUBPtr:      FmtPUB
 3106 FmtPSBPtr:      FmtPSB
 3107 FmtPUWPtr:      FmtPUW
 3108 FmtPSWPtr:      FmtPSW
 3109 FmtPUDPtr:      FmtPUD
 3110 FmtPSDPtr:      FmtPSD
 3111 FmtPUQPtr:      FmtPUQ
 3112 FmtPSQPtr:      FmtPSQ
 3113 FmtPFPtr:       FmtPF
 3114 FmtPDPtr:       FmtPD
 3115 FmtHexAnsiPtr:  FmtHexAnsi
 3116 FmtHexDWPtr:    FmtHexDW
 3117 FmtHexWPtr:     FmtHexW
 3118 FmtFloatsPtr:   FmtFloats
 3119 @FmtDoublesPtr:  FmtDoubles
 3120 FmtAsciiPtr:    FmtAscii
 3121 FmtHexCookedPtr: FmtHexCooked

 TABLE.STR.A.ErrorEnd: LP.TABLE.STR.A.Error: TABLE.STR.A.Error]

[StringNamePath: B$ ? # &MAX_PATH]
[H.BUAStringsFile: D$ ?
 BUAsmStringsFilelenght: D$ ?
 BUAsmStringsMemory: D$ ?]
[StringsLanguage: B$ '.en' EOS]
[BUAsmStringsFiles: B$ 'BUAsmStrings' EOS]
[UnicodeStrings: &FALSE]

; Tag Dialog 4800

SetNationalLanguage:

    .If eax = 10
        Mov D$StringsLanguage '.en'
    .Else_If eax = 11
        Mov D$StringsLanguage '.fr'
    .Else_If eax = 12
        Mov D$StringsLanguage '.br'
    .Else_If eax = 13
        Mov D$StringsLanguage '.sp'
    .Else_If eax = 14
        Mov D$StringsLanguage '.zh'
    .Else_If eax = 15
        Mov D$StringsLanguage '.it'
    .Else_If eax = 16
        Mov D$StringsLanguage '.de'
    .Else_If eax = 17
        Mov D$StringsLanguage '.no'
    .Else_If eax = 18
        Mov D$StringsLanguage '.ca'
    .Else_If eax = 201
        Call GetNationalFont
    .End_If

    Call OpenStringsFile
ret


OpenStringsFile:

    Call GetBUAsmFilesPath

    Mov esi BUAsmFilesPath, edi StringNamePath

    While B$esi <> 0 | movsb | End_While

    Mov D$edi 'Lang', B$edi+4 '\' | add edi 5
    Mov esi BUAsmStringsFiles
    While B$esi <> 0 | movsb | End_While | Move D$edi D$StringsLanguage

    Call 'KERNEL32.FindFirstFileA' StringNamePath, STRUC.FindFile

    ...If eax <> &INVALID_HANDLE_VALUE

        Call 'KERNEL32.FindClose' eax

        Call 'KERNEL32.CreateFileA' StringNamePath, &GENERIC_READ,
                                    &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                    &FILE_ATTRIBUTE_NORMAL, 0
        Mov D$H.BUAStringsFile eax

        Call 'KERNEL32.GetFileSize' eax,
                                    0

        Mov D$BUAsmStringsFilelenght eax

        add eax 10

        Call VirtualAlloc BUAsmStringsMemory,
                          eax

        add D$BUAsmStringsMemory 10

        Call 'KERNEL32.ReadFile' D$H.BUAStringsFile, D$BUAsmStringsMemory,
                                 D$BUAsmStringsFilelenght, NumberOfReadBytes, 0

        Call 'KERNEL32.CloseHandle' D$H.BUAStringsFile

        Mov esi D$BUAsmStringsMemory,
            edx esi ;!!! EDX pour ParseNationalUstrings/ParseNationalStrings !!!

        add edx D$BUAsmStringsFilelenght

        If D$StringsLanguage = '.zh'
            Mov B$UnicodeStrings &TRUE | Call ParseNationalUstrings
        Else
            Mov B$UnicodeStrings &FALSE | Call ParseNationalStrings
        End_If

    ...Else
        Mov D$StringsLanguage '.en'

    ...End_If
ret


ParseNationalUstrings:
    .While esi < edx
        ..If W$esi < '1'
            ;
        ..Else_If W$esi <= '9'
            cmp W$esi-8 '$' | jne L9>>
                cmp W$esi-6 '$' | jne L9>>
                    cmp W$esi-4 '$' | jne L9>>
                        cmp W$esi-2 '$' | jne L9>>

          ; Write the Strings Zero End Marks upon the '$':
            Mov W$esi-12 0

          ; Compute the ID Number
L0:         Mov ecx 0

L0:         lodsw
            cmp ax SPC | je L7>
            cmp ax '9' | ja L5>
            cmp ax '0' | jb L5>
                sub ax '0'
                lea ecx D$ecx+ecx*4
                lea ecx D$eax+ecx*2
            jmp L0<

L5:         Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'Bad National Strings File. English assumed' EOS},
                                          {B$ 'National Strings' EOS}, 0
            Mov D$StringsLanguage '.en'
            ret

          ; esi point to the beginning of a String, and ecx is the ID Number.
          ; Write it into the 'StringsTable'. Allow missing Ordinal IDs:
L7:         Mov ebx D$LP.TABLE.STR.A.Error

            While D$ebx > ecx
                sub ebx 8 | On ebx < TABLE.STR.A.Error jmp L5<
            End_While
            While D$ebx < ecx
                add ebx 8 | On ebx >= TABLE.STR.A.ErrorEnd jmp L5<
            End_While
            Mov D$ebx+4 esi | Mov D$LP.TABLE.STR.A.Error ebx
        ..End_If

L9:     add esi 2
    .End_While

  ; Write the Strings Zero End Marks for the last Strings:
    Mov W$esi 0
ret


ParseNationalStrings:
    .While esi < edx
        ..If B$esi < '1'
            ;
        ..Else_If B$esi <= '9'
            cmp D$esi-4 '$$$$' | jne L9>>

          ; Write the Strings Zero End Marks:
            Mov B$esi-6 0

          ; Compute the ID Number
L0:         Mov ecx 0

L0:         lodsb
            cmp al SPC | je L7>
            cmp al '9' | ja L5>
            cmp al '0' | jb L5>
                sub al '0'
                lea ecx D$ecx+ecx*4
                lea ecx D$eax+ecx*2
            jmp L0<

L5:         Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'Bad National Strings File. English assumed' EOS},
                                          {B$ 'National Strings' EOS}, 0
            Mov D$StringsLanguage '.en'
            ret

          ; esi point to the beginning of a String, and ecx is the ID Number.
          ; Write it into the 'StringsTable'. Allow missing Ordinal IDs:
L7:         Mov ebx D$LP.TABLE.STR.A.Error

            While D$ebx > ecx
                sub ebx 8 | On ebx < TABLE.STR.A.Error jmp L5<
            End_While
            While D$ebx < ecx
                add ebx 8 | On ebx >= TABLE.STR.A.ErrorEnd jmp L5<
            End_While
            Mov D$ebx+4 esi | Mov D$LP.TABLE.STR.A.Error ebx
        ..End_If

L9:     inc esi
    .End_While

  ; Write the Strings Zero End Marks for the last Strings:

    Mov B$esi 0
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
  Custom Strings Routines:
  
  See usage downward, at 'TestCustomString'.
;;
[CustomError
 If D$StringsLanguage = '.zh'
    Call CopyUnicodeToTrash1 #1
    BuildTheUnicodeMessage #2>L
 Else
    Call CopyToTrash1 #1
    BuildTheAsciiMessage #2>L
 End_If]

[BuildTheUnicodeMessage | Call CustomUnicodeStringProc #1, #2, #3 | #+3
    mov esi D$Trash1Ptr, edi STR.A.Trash
    While W$esi > 0 | movsw | End_While | movsb]

[BuildTheAsciiMessage | Call CustomStringProc #1, #2, #3 | #+3
    mov esi D$Trash1Ptr, edi STR.A.Trash
    While B$esi > 0 | movsb | End_While | movsw]

[CustomString | Call CopyToTrash1 #1 | CustomString2 #2>L]

[CustomString2 | Call CustomStringProc #1, #2, #3 | #+3
 mov esi D$Trash1Ptr, edi STR.A.Trash
 While B$esi > 0 | movsb | End_While | movsb]

Proc CopyToTrash1:
    Argument @Source
    Uses esi

        Mov esi D@Source, edi Trash1
        While B$esi <> 0 | movsb | End_While | movsb

        Mov D$Trash1Ptr Trash1, D$Trash2Ptr Trash2
EndP


Proc CopyUnicodeToTrash1:
    Argument @Source
    Uses esi

        Mov esi D@Source, edi Trash1
        While W$esi <> 0 | movsw | End_While | movsw

        Mov D$Trash1Ptr Trash1, D$Trash2Ptr Trash2
EndP


Proc CustomStringProc:
    Arguments @Xn, @Type, @Arg
    Uses esi, edi, ebx

        Mov esi D$Trash1Ptr, edi D$Trash2Ptr

        Mov eax D@Xn
        While W$esi <> ax
            movsb | On B$esi = 0, ExitP
        End_While

        If D@Type = 'Int'
            Mov eax D@Arg | Call WriteEax

        Else_If D@Type = 'Str'
            Push esi
                Mov esi D@Arg
                While B$esi <> 0 | movsb | End_While
            Pop esi

        End_If

        add esi 2 | While B$esi <> 0 | movsb | End_While | Mov B$edi 0

       Exchange D$Trash1Ptr D$Trash2Ptr
EndP


Proc CustomUnicodeStringProc:
    Arguments @Xn, @Type, @Arg
    Uses esi, edi, ebx

        Mov esi D$Trash1Ptr, edi D$Trash2Ptr
;;
   '@Xn' stands is the '#1', '#2', '#3' thingies. We make it Unicode, that is,
   for example:
   
   '#1' (031, 023) >>> 0, 031, 0, 023 >>> '#', 0, '1', 0
;;
        Mov eax D@Xn | movzx ebx ah
        shl ebx 16 | or eax ebx  | and eax 0FF00FF

        While D$esi <> eax
            movsw | On W$esi = 0, ExitP
        End_While

        If D@Type = 'Int'
            Mov eax D@Arg | Call WriteEaxUnicode

        Else_If D@Type = 'Str'
            Push esi
                Mov esi D@Arg
                While B$esi <> 0 | movsb | Mov B$edi 0 | inc edi | End_While
            Pop esi

        End_If

        add esi 4 | While W$esi <> 0 | movsw | End_While | Mov W$edi 0

        Exchange D$Trash1Ptr D$Trash2Ptr
EndP


WriteEaxUnicode:
    Mov ebx eax

L3: If ebx = 0
        Mov W$edi '0' | add edi 2 | ret
    End_If

    Push 0-1

L0: Mov eax ebx | shr ebx 4 | and eax 0F

    Mov al B$STR.A.Hexa+eax
    Push eax
    cmp ebx 0 | ja L0<
    Mov W$edi '0' | add edi 2
L0: Pop eax | cmp eax 0-1 | je L9>
    Mov B$edi al | inc edi | Mov B$edi 0 | inc edi | jmp L0<
L9: ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Mem             ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;

    Memory Management
  
    VirtualAlloc Reserves Memory Chunks with a 01_0000 alignement and Commit Chunks with
    a 0_1000 alignement. These Memory Manager Routines purpose is to completely secure
    and simplify the calls for Mems and to save all these rooms spoiled by the 01_0000
    alignement. To simplify things, let us Call 'Mother Chunks' the 01_0000 aligned ones
    (Reservations default) and 'Child Chunks' the 0_1000 aligned ones (Commition default)

    For developements, an Equate [GUARD_PAGE] may be set to 0_1000. This ensure that, in
    case of overflowing writes to a given Memory Chunk, even if 2 chunks are contiguous,
    Win will effectively raise a exception. With this Guard set, the Manager may eat up
    to 8 times less Mem (when dealing with small Chunks). Without Guard ([GUARD_PAGE] set to
    zero), the eaten Mem may be up to 16 times smaller. (This [GUARD_PAGE] has no relation
    with what Win Doc calls so)

    When small Chunks are wanted, the Memory Manager reuse free Chunks that may be found
    inside already Reserved 01_0000 aligned Chunks

    All Chunks are recorded in a [MemTable]. Each Record is:

    Pointer / Size / Mother_Pointer

    Where 'Pointer' is the Pointer to the Committed Chunks, Size is the Size of the
    Committed Chunks eventually added of the GUARD_PAGE (0_1000 or 0), and 'Mother_Pointer'
    is a Pointer to the 01_0000 aligned Chunk to which may belong the Committed Chunk. Even
    the Mother Chunk get this last Value pointing to itself. This last Value is used to
    control if and when, the Memory manager may effectively Release the whole Chunk. Until
    all of the nested and Mother Chunks are not Decommitted, the Memory Manager do not
    Release the whole Mother Chunk, but proper releasing will be done, whatever order of
    the [VirtualFree] calls, even if the [VirtualFree] MotherChunk is called first and
    the [VirtualFree] ThirdChildChunk last

    If more than expected (here [MEM_TABLE_SIZE]) Chunks are required, this is to say,
    if too much Mems are not released (in other words, if i have forgotten to release
    some Allocated Memories), i should also see an error Message 'NoMoreMem' if the
    [MemTable] is overflowed. Added to this i set a Menu Item in Tools to see how
    much Memory Chunks are activated at any time [ViewBUAsmMems]. This does not tell
    how much Mem is used. This only tells how much Chunks are recorded in the [MemTable],
    no matter what Size

    When releasing, if the Pointer value is corrupted, we should also see an error
    Message for [MemInternalAlert]


    All this is much heavy, but gives full control on any Management problem, and the
    calls remain completly simple:

    VirtualAlloc Pointer,
                 Size

    VirtualFree Pointer

    When back from [VirtualAlloc], the Pointer holds the new Memory Pointer.
    [VirtualFree] reset D$Pointer Value to zero. If called a second time (with a nul
    pointer, the Proc aborts without any error Message, because, in some complex cases
    organisation of the source flow, it may become difficult to know if, at some given
    time, the Mem has already be freed or not. This save from having to write:

    On D$Pointer > 0 VirtualFree Pointer

    This is the only one case for which the Manager does not send an error Message
    in case of bad Call from the Application. If a wrong Address is sent to VirtualFree,
    for example an Application Table Address instead of a Pointer content, the proper
    error Message is sent

    A [LastMemRecord] is also managed in order to save from scaning wide [MemTable] for
    nop, as we cannot rely on zeroed Records to know if we have finished scaning

    !!! VirtualAlloc / VirtualFree protect ALL registers

;;
____________________________________________________________________________________________

[MAIN_BLOCK_SIZE (16*PAGE_SIZE)

 GUARD_PAGE       PAGE_SIZE ; GUARD_PAGE = PAGE_SIZE Protection débordement en écriture
; GUARD_PAGE       &FALSE    ; GUARD_PAGE = &FALSE pas de protection débordement en écriture
]

; MemTable is 3 DWORD per record: / LP -> Mem / MemChunkSize / Mother LP /...
[MEM_LP         (0*DWORD)
 MEM_CHUNK_SIZE (1*DWORD)
 MEM_MOTHER_LP  (2*DWORD)
 MEM_RECORD     (3*DWORD) ; !!! A changer en 4*DWORD pour simplifier les calculs et rajouter un flag
 MEM_TABLE_SIZE ((MAXRESOURCE+50)*3) ] ; room for 50 Chunks + Resources Chunks.

[MemChunSize: D$ ?
 LastMemRecord: D$ ?
 TempoMemPointer: D$ ?] ; Used when no named Pointer is used by caller
                        ; (cases of Tables of Memory Pointers, for example)

[TABLE.MemBUAsm: D$ ? # MEM_TABLE_SIZE BUAsmMemTableEnd:]


[MemAlert: B$ 'Memory attribution failure' EOS]
[MemInternalAlert: B$ 'Error inside BUAsm Memory Management' EOS]
[MemAlertText: B$ "   BUAsm is going to close. Shut down some Aplications and re-run      " EOS]

Proc VirtualAlloc:

    Arguments @Pointer,
              @Size

    pushad

        Mov edi TABLE.MemBUAsm

        ; Edi = Lp -> Enregistrement libre
        While D$edi+MEM_LP <> &NULL

            add edi MEM_RECORD | Comp edi BUAsmMemTableEnd = VirtualAllocERROR1

        End_While

        ; GUARD_PAGE = 01_000 entraîne une erreur en cas de débordement d'écriture dans un bloc
        Mov ecx D@Size

        AlignOn PAGE_SIZE ecx | add ecx GUARD_PAGE

        Mov D$MemChunSize ecx,
            D$edi+MEM_CHUNK_SIZE ecx

        ; La réservation mémoire se fait par blocs de 010_000 bytes [MAIN_BLOCK_SIZE]
        ; Aucun bloc n'est inférieur à 0_1000 bytes [PAGE_SIZE]
        ; ou 0_2000 bytes dans le cas de GUARD_PAGE = [PAGE_SIZE]
        ; Les emplacements libres à l'intérieur d'un bloc Main ne sont donc pas supérieurs à
        ; MAIN_BLOCK_SIZE-(PAGE_SIZE+GUARD_PAGE) soit 0_F000 ou 0_E000 si GUARD_PAGE = [PAGE_SIZE]

        Comp ecx (MAIN_BLOCK_SIZE-(PAGE_SIZE+GUARD_PAGE)) > S1>

        Call IsThereSomeRoom
        ; Eax = 0 ou Lp
        ; Eax= Lp / Ebx = Mother Lp

        Test eax eax NOT_ZERO S2>

            ; Bloc parent
S1:         Mov ecx D$MemChunSize | AlignOn MAIN_BLOCK_SIZE ecx

            Call 'KERNEL32.VirtualAlloc' &NULL,
                                         ecx,
                                         &MEM_RESERVE, ;+&MEM_TOP_DOWN,
                                         &PAGE_READWRITE

            On eax = &NULL Call HexPrint D$MemChunSize

            Mov D$edi+MEM_LP eax,        ; Lp
                D$edi+MEM_MOTHER_LP eax  ; Mother Lp = Lp

        jmp S3>

S2:     Mov D$edi+MEM_LP eax,        ; Lp
            D$edi+MEM_MOTHER_LP ebx  ; Mother Lp ([IsThereSomeRoom] ebx)

S3:     On edi > D$LastMemRecord Mov D$LastMemRecord edi

        ; Bloc enfant
        Mov ecx D$MemChunSize | sub ecx GUARD_PAGE

        Call 'KERNEL32.VirtualAlloc' eax,
                                     ecx,
                                     &MEM_COMMIT,
                                     &PAGE_READWRITE

        test eax eax ZERO VirtualAllocERROR2

        ; MAJ: Lp transmis
        Mov edx D@Pointer,
            D$edx eax

    popad

EndP


IsThereSomeRoom:

    ; Recherche si un Search is some empty room is available inside already Reserved Chunks. [MemChunSize]
    ; holds the size of the wanted Block + one Page:
    Mov esi TABLE.MemBUAsm

L1: Comp esi D$LastMemRecord > S4>

        test D$esi+MEM_LP NA ZERO S3>

            Mov eax D$esi+MEM_LP | add eax D$esi+MEM_CHUNK_SIZE

            Mov ebx eax | AlignOn MAIN_BLOCK_SIZE eax | sub eax ebx

        ; Eax = supposed free room in this 01_0000 aligned reserved Chunk or sub-Chunk.
        Comp eax D$MemChunSize < S3>

            Mov eax D$esi+MEM_LP | add eax D$esi+MEM_CHUNK_SIZE

            Mov ebx eax | add ebx D$MemChunSize

            ; Eax = Start // ebx = End of possible free Block.
            ; Both must be outside of any other Declared Block.
            ; This is to say, down here,  (ebx <= ecx) OR (eax >= edx). Example:
            ; eax > edx >>> good:

;    .........................................(eax)XXXXXXXXXXXXXXXXXXXXX(ebx)...
;    ...D$esi+LP_MEMXXXXXXXXXXXXXXXXXXXXX(edx)..................................

        Mov ecx TABLE.MemBUAsm

L2:     Comp ecx D$LastMemRecord > S2>

            Mov edx D$ecx+MEM_LP | add edx D$ecx+MEM_CHUNK_SIZE

            Comp ebx D$ecx+MEM_LP <= S1>

            Comp eax edx < S3>

S1:     add ecx MEM_RECORD | jmp L2<

S2:     Mov eax D$esi+MEM_LP,
            ebx D$esi+MEM_MOTHER_LP

        add eax D$esi+MEM_CHUNK_SIZE

ret

S3: add esi MEM_RECORD | jmp L1<

S4: xor eax eax

ret

VirtualAllocERROR1:

    popad

    ; This Alert can only happend if i completly corrupt a Mem Pointer Value
    ; so that it is no more founded in the [MemTable]

    Call 'USER32.MessageBoxA' D$H.MainWindow,
                              MemAlertText,
                              MemAlert,
                              &MB_SYSTEMMODAL+&MB_ICONSTOP

    Call ViewBUAsmMems

    Call MessageBox {B$ 'VirtualAlloc Buffer overflowed' EOS}

    Call 'KERNEL32.ExitProcess' 0

VirtualAllocERROR2:

    popad

    Call 'USER32.MessageBoxA' D$H.MainWindow,
                              MemInternalAlert,
                              MemAlert,
                              &MB_SYSTEMMODAL+&MB_ICONSTOP

    Call ViewBUAsmMems

    Call MessageBox {B$ 'VirtualAlloc Function failure' EOS}

    Call 'KERNEL32.ExitProcess' 0
____________________________________________________________________________________________

Proc VirtualFree:

    Argument @LP.VirtualMem

    pushad

        ; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        ; I sometimes increase the original Pointer to set a security top margin allowing
        ; computation begining by 'If D$esi-4 = ...", for example >>> Restore origin:
        ; (Chunks are always Page-aligned)
        ; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        Mov eax D@LP.VirtualMem,
            eax D$eax

        ; !!! TODO !!!
    ;    and eax 0_FFFF_F000 | jz S4>>
            Test eax eax ZERO S4>>
and eax 0_FFFF_F000

        Mov esi TABLE.MemBUAsm

        jmp S1>

L1:     add esi MEM_RECORD

            Comp esi D$LastMemRecord > VirtualFreeERROR

S1:     Comp D$esi+MEM_LP eax <> L1<

        ; Ne jamais détruire un parent directement, c'est la destruction de son dernier
        ; enfant qui lance sa destruction
        Comp D$esi+MEM_MOTHER_LP eax = S4>

        Mov ecx D$esi+MEM_CHUNK_SIZE | sub ecx GUARD_PAGE

        ; Détruire l'enfant
        Call 'KERNEL32.VirtualFree' eax,
                                    ecx,
                                    &MEM_DECOMMIT

        ; Effacer l'enregistrement de l'enfant
        Mov eax D$esi+MEM_MOTHER_LP,
            D$esi+MEM_LP &NULL,
            D$esi+MEM_CHUNK_SIZE &NULL,
            D$esi+MEM_MOTHER_LP &NULL

        ; Si aucun autre bloc enfant n'est présent dans le bloc parent
        ; nous pouvons détruire ce dernier

        Mov esi TABLE.MemBUAsm

L2:     Comp D$esi+MEM_MOTHER_LP eax = S3>

             add esi MEM_RECORD

        Comp esi D$LastMemRecord <= L2<

S2:     Call 'KERNEL32.VirtualFree' eax,
                                    &NULL,
                                    &MEM_RELEASE

S3:     Comp esi D$LastMemRecord <> S4>

        sub D$LastMemRecord MEM_RECORD

S4:     Mov eax D@LP.VirtualMem,
            D$eax &NULL

    popad

EndP


VirtualFreeERROR:

    popad

    Call 'USER32.MessageBoxA' D$H.MainWindow,
                              MemInternalAlert,
                              MemInternalAlert,
                              &MB_SYSTEMMODAL+&MB_ICONSTOP

    Call ViewBUAsmMems

    Call 'USER32.MessageBoxA' D$H.MainWindow,
                              {B$ 'VirtualFree Buffer overflow' EOS},
                              argh,
                              &MB_SYSTEMMODAL


    Call 'KERNEL32.ExitProcess' &NULL
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE MemView         ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

; Routine for: Menu > Tools > 'Show BUAsm mem'

[TABLE.MemView: D$ ? # (MEM_TABLE_SIZE*5)]

; Tag Dialog 10000
[IDD_SHOW_BUASM_MEM 10000
 IDC_DISPLAYMEMINFO    10]

ViewBUAsmMems:

    Call 'USER32.DialogBoxParamA' D$H.Instance,
                                  IDD_SHOW_BUASM_MEM,
                                  &NULL,
                                  ShowBUAsmMemDialog,
                                  &NULL

ret
_______________________________________________________

Proc ShowBUAsmMemDialog:

    Arguments @hwnd,
              @msg,
              @wParam,
              @lParam


    If D@msg = &WM_INITDIALOG

        Call DisplayBUAsmMemInfos

    Else_If D@msg = &WM_CTLCOLOREDIT

        Call WM_CTLCOLOREDIT | ExitP

    Else_If D@msg = &WM_COMMAND

        On W@wParam = HIDE_PUSHBUTTON_OK Call EndDialog

    Else_If D@msg = &WM_CLOSE

        Call EndDialog

    Else

        Return &FALSE

    End_If

    Mov eax &TRUE

EndP
_______________________________________________________

; Calculate the maximum size of the report....
;0000000: 023 069 066 06E  - Ascii: # i f n
;0403ED4: 073 079 073 02F  - Ascii: s y s /  Size = 43
;0403ED4: 073 079 073 02F  - Not used - Ascii: s y s /  Size = 54
;0403ED4: 073 079 073 02F  - Commited - Ascii: s y s /  Size = 54
;0403ED4: 073 079 073 02F  - Reserved - Ascii: s y s /  Size = 54
; MEM_TABLE_SIZE = 10650 dwords = 42600 bytes. The displacement is from 12 to 12 dwords
; So we have 887,5 * 4 (10650/12*4). 3550 Lines.
; On Our case this means:
; Size*3550 = 54*3550 = 191700 bytes
; Multiplication Factor = 191700/42600 = 4,5. So, for safety we do
; [MemTableView: D$ ? # (MEM_TABLE_SIZE*5)] = 213000 Bytes

DisplayBUAsmMemInfos:

    Push ebx,
         esi,
         edi

    Call SetIconDialog

;    Call SetFocusHideCloseButton

    Call 'USER32.SendDlgItemMessageA' D$HWND,
                                      IDC_DISPLAYMEMINFO,
                                      &EM_SETMARGINS,
                                      &EC_LEFTMARGIN+&EC_RIGHTMARGIN,
                                      10

    Mov edi TABLE.MemView,
        ecx (MEM_TABLE_SIZE*5)

    xor eax eax | rep stosd

    Mov esi TABLE.MemBUAsm,
        edi TABLE.MemView

    .While esi <= D$LastMemRecord

       push esi

            mov eax esi, ecx MEM_RECORD | sub eax TABLE.MemBUAsm | xor edx edx | div ecx

            Push NA

            Mov ecx 10

L1:         xor edx edx

                div ecx | Push edx

            Test eax eax NOT_ZERO L1<

            Pop eax

            Mov edx '0000'

            ; '0 ~ 9' ASCII -> Flag NA (0-1)
L2:         or dl al

                ror edx 8 | Pop eax

            Test eax NA POSITIVE L2<

            Mov eax edx | stosd | Mov al SPC | stosb

        Pop esi

        Push esi

            ; Adresse bloc en hexa
            mov eax D$esi+MEM_LP | Call WriteEax

            Mov al SPC | stosb

            ; Taille bloc en hexa
            mov eax D$esi+MEM_CHUNK_SIZE | Call WriteEax

            ; 4 premiers bytes dans le bloc
            Mov ecx 4

L3:         Push NA

                lodsb

                Mov dl al | and eax 0_F | Mov al B$STR.A.Hexa+eax | Push eax

                Test dl 0F0 | jmpIf ZERO S1>

                    Mov al dl | shr eax 4 | Mov al B$STR.A.Hexa+eax | Push eax

                jmp S2>

S1:             Mov al SPC | stosb

S2:             Push '0'

L4:             Pop eax | Comp eax NA = S3>

                    stosb

                jmp L4<

S3:             Mov eax SPC | stosb

            sub ecx 1 | JmpIf NOT_ZERO L3<

        pop esi

        Push esi

            mov edx D$esi+MEM_LP

            Test edx NA ZERO S5>

            Comp edx D$esi+MEM_MOTHER_LP = S4>

                Mov eax " CHI" | stosd | Mov eax "LD: " | stosd | Call WriteDwordAscii D$edx

            jmp S6>

S4:             Mov eax " MAI" | stosd | Mov eax "N:  " | stosd | Call WriteDwordAscii D$edx

            jmp S6>

S5:             Mov eax " NA " | stosd

S6:         Mov ax CRLF | stosw

        Pop esi

        add esi MEM_RECORD

    .End_While

    Mov B$edi EOS

    Call 'USER32.SetDlgItemTextA' D$HWND,
                                  IDC_DISPLAYMEMINFO,
                                  TABLE.MemView

    Pop edi,
        esi,
        ebx

ret
________________________________________________________________________________________________________

Proc WriteDwordAscii:

    Arguments @Value

    Uses esi

    lea esi D@Value

    Mov edx 4

L0: lodsb

        Comp al SPC => S1>

            Mov al '.'

S1:     Mov ah SPC

        stosw

    sub edx 1 | JmpIf NOT_ZERO L0<

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT

TITLE AsmMain         ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

; 'AsmMain' 'EncodeLines'
 _________________________________________________________________________________________
 _________________________________________________________________________________________

; After Macros and Equates replacement, CodeSourceA is of no more use.
; we reused it for CodeList storage table:

; EvilBro: This next routine is evil, because it uses D$SourceLen. I will have to do something
; about that in the future.

ReuseSourceAForCodeList:
    Mov eax D$CodeSourceA | and eax 0_FFFF_FF00  ; kill +010 margin in CodeSources tables
    Mov D$CodeList eax, edi eax                ; (needed for alignement)
    Mov ecx D$AsmTablesLength
    shr ecx 2
    Push eax, edi                              ; recent add > clean it all for ease of
        Mov eax 0 | rep stosd                  ; read of Hexa PEs.
    Pop edi, eax
    add eax 0400 | Mov D$CodeListPtr eax       ; clear header and
ret

;;
 This table is for the Debug routine. Each intruction got a pointer. When searching
 for some instruction in the Debugger, we read EIP reg and compare with this List
 in order to point to the source instruction (after error search with the computed
 number of instruction). This List is not closed after compilation.
;;

[IpTable: D$ ?
 IpTablePtr: D$ ?
 CodeOrigine: D$ ?]

InitDebugIpTable:

    Call VirtualFree IpTable

    Mov eax D$SourceLen | add eax 01000

    Call VirtualAlloc IpTable,
                      eax

    Move D$IpTablePtr D$IpTable, D$CodeOrigine D$CodeListPtr

ret


[Time1: D$ ?
 Time2: D$ ?
 Time3: D$ ?
 Time4: D$ ?]

[Alert: B$ 'Something is overwriting the Resources Pointers!!!' EOS]
[AlertTitle: B$ 'Internal Error!!!...' EOS]

AlertResources:
    Call 'USER32.MessageBoxA' D$H.MainWindow, Alert, AlertTitle, &MB_OK
ret


AsmMain:

    Mov D$EntryPointLabel 'MAIN',
        B$EntryPointLabel+(4*ASCII) EOS,
        D$EntryPointLabelLen 4

    On D$ResourcePointersSecurity <> 0 jmp AlertResources

    Mov D$FL.CompileErrorHappend &TRUE | On D$FL.SourceReady = &FALSE ret

    Mov eax D$CodeSource | On D$STRUCT.EditData@SourceEnd = eax ret

    Call 'KERNEL32.GetTickCount' | Mov D$Time1 eax

    ; To restore stack on error jump
    Mov D$OldStackPointer esp

    Mov D$NoMeanLabel 'ZZZZ',
        D$NoMeanLabel+(4*ASCII) 'ZZZZ',
        D$FL.CompileErrorHappend &FALSE,
        D$FirstPass &TRUE

    If D$FL.WeAreUnfolding = &FALSE

        Call InitProgressBar | Call InitProgressSteps 16,
                                                      1

    End_If

    ; Ensure Source is ended with at least one CR/LF for ease of line analyzes:
    Mov eax D$STRUCT.EditData@SourceEnd

    cmp W$eax-(1*WORD) 0A0D | je L1>

        cmp W$eax-(1*WORD) 0D0A | je L1>

            Mov W$eax 0A0D | add D$STRUCT.EditData@SourceEnd (1*WORD) | add D$SourceLen (1*WORD)

L1: Call GetAsmTables                       ; files ready for read in 'CodeSource'

    Call ClearUserStubMainData

    Call BarProgress

; -------------------------------  First Parsers Jobs ---------------------------------

    If B$ProfilerFlag = &TRUE
        Call InjectedCopyToCodeSourceA, D$CodeSource, D$SourceLen
    Else
        Call NewCopyToCodeSourceA D$CodeSource, D$SourceLen
    End_If

    Call CoolParsers
;jmp L7>>
    Call NewCountStatements | Call BarProgress

    Call NewPrepareExport

    Call HotParsers

    Call NoAutomaticLabel

;jmp L7>>
;;
 The Source is no longer a crude Ascii but a cooked translation.
 For example, spaces are no longer ' ' [SPC], but 'Space' (03), and so on.
 See 'LowSigns' and 'MyAsciiTable'.
;;
    Call ReplaceWin32Equates
;jmp L7>>

    Call InitIndex1

;jmp L7>>
   ;On B$ParseOOA = &TRUE, Call ClassParser     ; <<<<<<<<< Delayed (doesn't work at all).
    On B$ParseEqual = &TRUE, Call EqualParser
;jmp L7>>
    On B$ParseNew = &TRUE, Call NewParser       ; Volunteers private room
    On B$ParseBinInclude = &TRUE, Call BinIncluderParser

; jmp L7>>
    Call BarProgress
    Call 'USER32.SendMessageA'  D$H.ForBar, &WM_SETTEXT, 0, Storing
;jmp L7>>
    Call ClearQwordCheckSum
;jmp L7>>

; ------------------------  Start of the Macros and Equates Jobs ------------------------

L1: Call StoreEquatesAndMacros

    Call BarProgress
    Call 'USER32.SendMessageA' D$H.ForBar, &WM_SETTEXT, 0, Replacing

    Call NewReplaceMacAndEqu

    Call NewBrackets

    If B$MoreBracket = &TRUE
        Mov B$FirstPass &FALSE
        Call ResetForNewBrackets

        On D$FL.WeAreUnfolding = &TRUE Call UnfoldOutput

        jmp L1<

    End_If

    On D$FL.WeAreUnfolding = &TRUE ret

; ------------------------  End of the Macros and Equates Jobs ------------------------

L2: Call ExtendLocalSymbols
;;
  Do not remove this 'Exchange': There must be one, at the end of 'ExtendLocalSymbols',
  because it is also called from inside the 'HotParsers', for the @Locals first Pass.
;;
    Exchange D$CodeSourceA D$CodeSourceB
;;
  Down to here, we alway operated by reading at 'CodeSourceA' and writting at
  'CodeSourceB'. These manipulation are over: From here, we take source in
  'CodeSourceB', and will reuse CodeSourceA for building the Binary
;;

    Call InitIndex2

    Call 'USER32.SendMessageA' D$H.ForBar, &WM_SETTEXT, 0, BuildingImport
    Call BarProgress

    Call ReuseSourceAForCodeList ;| jmp L7>>

    Call BuildImport

;jmp L7>>
    Call InitIndex3
    Call BarProgress
    Call 'USER32.SendMessageA' D$H.ForBar, &WM_SETTEXT, 0, BuildingRsrc

    Call BuildRsrc

    Call 'KERNEL32.GetTickCount' | Mov D$Time2 eax
    Call BarProgress
    Call 'USER32.SendMessageA' D$H.ForBar, &WM_SETTEXT, 0, BuildingData


    Call BuildData                         ; result 'CodeSourceB' > 'CodeSourceB'

    Call BarProgress
    Call InitDebugIpTable
    Call 'USER32.SendMessageA' D$H.ForBar, &WM_SETTEXT, 0, Encoding

    If B$ShortenJumpsWanted = &TRUE
        Call InitShortenJmpsTable
        Call EncodeLines
        Call JmpsOptimize
        Call ReleaseShortenJmpsTable

    Else_If B$ProfilerFlag = &TRUE
        Call EncodeLines
        Call CreateProfilerTables

    Else
        Call EncodeLines                       ; Line > Para > Code > op
    End_If

;jmp L7>>
    Call 'KERNEL32.GetTickCount' | Mov D$Time3 eax
    Call BarProgress
    Call 'USER32.SendMessageA' D$H.ForBar, &WM_SETTEXT, 0, BuildingHeader

    Call PreparePeHeader | Call FixTableSizes

    Call BarProgress
    Call 'USER32.SendMessageA' D$H.ForBar, &WM_SETTEXT, 0, Fixing

    Call BuildRelocationAndFillSymbols

    If B$ExportsectionWanted = &TRUE
        Call PrepareDllVariables | Call FillExportSection
    End_If

    Call WritePeHeaders

    Call BarProgress
    Call 'USER32.SendMessageA' D$H.ForBar, &WM_SETTEXT, 0, Writing

    Call 'KERNEL32.GetTickCount' | Mov D$Time4 eax

    Call CloseProgressBar

    If D$FL.ShowStats = &TRUE
        Mov D$FL.UnusedSymbolsDialogWanted &FALSE
        Call 'USER32.DialogBoxParamA', D$H.Instance, 2, D$H.MainWindow, Statistics, 0
    Else
        Call WritePE | Call RecordMRU | On D$BookMarks > 0, Call SaveBookMarks
    End_If

L8:
    On B$CompletionWanted = &TRUE, Call BuildCompletionTable

    If D$FL.UnusedSymbolsDialogWanted = &TRUE
        Call DisplayUnusedSymbolsDialog D$H.Instance
    End_If

    Call ReleaseAsmTables

    If D$H.ShowTree <> 0
        On B$AutoRebuildTreeView = &TRUE, Call TreeUpDate
    End_If
   ;Call TestStatementsTable
ret

  ; For developments tests only (comments at "WriteDestination:"):
L7: Call SetTestSavingName |  Call WriteDestination | Call CloseProgressBar | jmp L8<<
____________________________________________________________________________________________
____________________________________________________________________________________________

[H.MultipleCompileFind: D$ ?
 OneOfMultiplePathNamePointer: D$ ?]

[MultipleCompilePathTitle: B$ 'For Multiple Compilations Test' EOS]

[MultipleCompilePath: B$ ? # &MAX_PATH]


MultipleCompileTests:

    Call BrowseForFolder D$H.MainWindow, MultipleCompilePathTitle

    On B$BrowseForFolderAborted = &TRUE ret

    Mov esi FolderPath, edi MultipleCompilePath

    While B$esi <> 0 | movsb | End_While | Mov B$edi '\' | inc edi

    Mov D$OneOfMultiplePathNamePointer edi

    Mov edi FolderPath | While B$edi <> 0 | inc edi | End_While

    Mov D$edi '\*.e', D$edi+(4*ASCII) 'xe'

    Call 'KERNEL32.FindFirstFileA' FolderPath,
                                   STRUC.FindFile

    If eax <> &INVALID_HANDLE_VALUE

        Mov D$H.MultipleCompileFind eax

L1:
        Mov esi STRUC.FindFile@cFileName, edi D$OneOfMultiplePathNamePointer

        While B$esi <> 0 | movsb | End_While | movsb

        Mov esi MultipleCompilePath edi SaveFilter

        While D$esi <> 0 | movsb | End_While | movsb

        Call DirectLoad

        Call 'USER32.MessageBoxA' D$H.MainWindow,
                                  SaveFilter,
                                  {B$ 'Ready to Compile...' EOS},
                                  &MB_SYSTEMMODAL

        Call AsmMain

        Mov D$OldStackPointer &NULL

        On D$FL.CompileErrorHappend = &TRUE jmp L9>

        Call 'KERNEL32.FindNextFileA' D$H.MultipleCompileFind,
                                      STRUC.FindFile
        cmp eax &TRUE | je L1<

    End_If

L9: Call 'KERNEL32.FindClose' D$H.MultipleCompileFind

ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Optimize        ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
  Release 2: Betov November 2006.
  _______________________________
    SetShortenJmpFlag
    
    SetJMPShortenJmpFlag
  
    JmpsOptimize
        ScanShortenJmpsTable
            InitScanShortenJmpsTable
            TryToShortenLong
                ShortenLongDown
                ShortenLongUp
        CompactLabelListAndCodeRef
            InitLabelListScanDwordPointer
            AdjustAboveListPointers
            AdjustLastListPointers
        CompactCodeList
        CompactShortenJmpsTable
       
        ScanCouples
            InitScanShortenJmpsTable
            IsJumpDownOrUp
            CouldBothBeShorten
                GetDisplacementDown
                GetDisplacementUp
            SetBothShort
  _______________________________
  
  Process:
  
  * A 'ShortenJmpsTable' Map is created by a cal from 'AsmMain': Empty Table,
    representing the Code area.
  
  * Jcc Encodage (above 'JMPmnemo') calls for 'SetShortenJmpFlag': 'LONG_Jcc' at the
    matching Byte of the 'ShortenJmpsTable'.
     
    JMP Encodage ('JMPmnemo') calls for 'SetJMPShortenJmpFlag': 'LONG_JMP' at the
    matching Byte of the 'ShortenJmpsTable'.
     
    Case of Plain Labels are not considered: They are always Long in RosAsm Syntax
    and the Jumps Sizes apply to Local Labels only.
  
  * After the Encodage, a "Long to Short" Optimization is computed, here.
;;
____________________________________________________________________________________________

[ShortenJumpsWanted: D$ &FALSE]

[ShortenJmpsTable: D$ ?
 CodeListOrigine: D$ ?]

InitShortenJmpsTable:
    On D$ShortenJmpsTable <> 0, Call ReleaseShortenJmpsTable

    Call VirtualAlloc ShortenJmpsTable,
                      D$SourceLen

    Move D$CodeListOrigine D$CodeListPtr
ret


ReleaseShortenJmpsTable:

    Call VirtualFree ShortenJmpsTable

ret
____________________________________________________________________________________________

;;
  Called from 'Encode' // 'Letter_J' // Cases of Jcc and JMP (DownLong or UpLong only):
  
  The Plain Labels are not considered (always long in RosAsm Syntax).
;;

[EndOfShortenJmpsTable: D$ ?]

[LONG_JMP 1, LONG_Jcc 2
 SHORTEN 3
 SHORTEN_LONG_JMP 4, SHORTEN_LONG_Jcc 5
 ALIGN_FLAG 010]

SetShortenJmpFlag:
    Push edi
        sub edi D$CodeListOrigine | add edi D$ShortenJmpsTable | add edi 2
        Mov B$edi LONG_Jcc, D$EndOfShortenJmpsTable edi
    Pop edi
    inc D$NumberOfLongToShort
ret


SetJMPShortenJmpFlag:
    Push edi
        sub edi D$CodeListOrigine | add edi D$ShortenJmpsTable | add edi 1
        Mov B$edi LONG_JMP, D$EndOfShortenJmpsTable edi
    Pop edi
    inc D$NumberOfLongToShort
ret


[AlignFound: D$ ?]

SetAlignFlag:
    Mov B$AlignFound &TRUE
ret
    Push edi
        sub edi D$CodeListOrigine | add edi D$ShortenJmpsTable
        Mov B$edi ALIGN_FLAG, D$EndOfShortenJmpsTable edi

        Mov ecx D$imm32
    Pop edi
ret
____________________________________________________________________________________________

[CodeRefScan: D$ ?
 NumberOfLongToShort: D$ ?
 JumpSizeStat: D$ ?]

;;
  On RosAsm itself, the Optimization adds 7% to the Compile time, and resolves
  7,619 Long to Short. The main "While" is run 4 times.
;;

JmpsOptimize:
    Mov eax D$CodeListPtr | dec eax

    Call ScanShortenJmpsTable
    Mov eax D$NumberOfLongToShort, D$JumpSizeStat eax

    While D$NumberOfLongToShort <> 0
L1:     Call CompactLabelListAndCodeRef

        Call CompactCodeList

        Call CompactShortenJmpsTable

        Call ScanShortenJmpsTable
        Mov eax D$NumberOfLongToShort | add D$JumpSizeStat eax
    End_While

    Call ScanCouples
    Mov eax D$NumberOfLongToShort | add D$JumpSizeStat eax
    On D$NumberOfLongToShort <> 0, jmp L1<
ret
____________________________________________________________________________________________

[LongInstruction: D$ ?] ; will be either 'LONG_JMP' or 'LONG_Jcc'

InitScanShortenJmpsTable:
    Mov ebx D$CodeRef | add ebx 5

  ; Case of Api Calls: ...|0FF dWordCodeAddress|:
  ;                   ....|.....|
    While B$ebx = 0FF | add ebx 6 | End_While

    Mov D$CodeRefName ebx

    While B$ebx > EOI | inc ebx | End_While | inc ebx

    Mov D$CodeRefScan ebx
  ; 'CodeRefScan' points to the first Char of a LabelName, in 'CodeRef'.

    Mov D$NumberOfLongToShort 0

    Call InitLabelListScanDwordPointer

    Mov esi D$ShortenJmpsTable
ret
____________________________________________________________________________________________

[CodeRefName: D$ ?
 CodeRefName1: D$ ?
 CodeRefName2: D$ ?]

ScanShortenJmpsTable:
;;
  Job: The 'ShortenJmpsTable' has been filled with 'LONG_JMP' or 'LONG_Jcc' at each
  location of a relative jump address (parallel to 'CodeListOrigine'). If JUMPs can
  be shorten, it turns them into 'SHORTEN_LONG_JMP' or 'SHORTEN_LONG_Jcc'.
  
  Calls for: 'TryToShortenLong' >>> 'ShortenLongDown' and 'ShortenLongUp'
;;

    Call InitScanShortenJmpsTable

  ; Scanning 'ShortenJmpsTable' 0 and 1 (esi ---> 'ShortenJmpsTable'):
L0: Mov edx D$EndOfShortenJmpsTable

    While B$esi = 0
        inc esi | cmp esi edx | ja L9>>
    End_While

  ; Here we have a Long Displacement that will be computed in 'FillCodeSymbols'.
    Mov al B$esi, B$LongInstruction al ; Either 'LONG_JMP' or 'LONG_Jcc'

  ; Translate into a 'CodeList' Pointer:
    Mov eax esi | sub eax D$ShortenJmpsTable | add eax D$CodeListOrigine

  ; Scan CodeRef:

  ; >>> Two Pointers (One in CodeList -eax-, and one in CodeRef -ecx-):
L1: Mov ecx D$ebx | and ecx (not relativeFlag)

    ..If ecx = eax
      ; Found matching Record, in CodeRef. Take a copy of the Name in 'CodeRefName':
        Mov eax ebx | sub eax 5 | Move D$CodeRefName D$eax

            Call TryToShortenLong

            .If B$CanBeShorten = &TRUE
                If B$LongInstruction = LONG_JMP
                    Mov B$esi SHORTEN_LONG_JMP
                Else_If B$LongInstruction = LONG_Jcc
                    Mov B$esi SHORTEN_LONG_Jcc
                End_If

              ; For the lasting 'FillCodeSymbols' to know it is a special "Short":
                Mov B$ebx-2 '.'
            .End_If

          ; Next CodeRef Record:
            add ebx 9 | inc esi
          ; Skip the Api calls:
            While B$ebx = 0FF | add ebx 6 | End_While
          ; Skip the "labelName|":
            While B$ebx > EOI | inc ebx | End_While | inc ebx

            jmp L0<<

        ..Else_If ecx <> 0
          ; Next CodeRef Record::
            add ebx 9
          ; Skip the Api calls:
            While B$ebx = 0FF | add ebx 6 | End_While
          ; Skip the "labelName|":
            While B$ebx > EOI | inc ebx | End_While | inc ebx

            jmp L1<<

        ..End_If
L9: ret
____________________________________________________________________________________________

[FirstDownCodeRefScan: D$ ?
 SecondUpCodeRefScan: D$ ?]

[FirstDownShortenJmp: D$ ?
 SecondUpShortenJmp: D$ ?]

ScanCouples:
    Call InitScanShortenJmpsTable
  ; >>> ebx ---> 'CodeRefScan' ---> 'CodeRef'.
  ; >>> esi ---> 'ShortenJmpsTable'.
    Mov edx D$EndOfShortenJmpsTable

    .While esi <= edx
        ...If B$esi <> 0
            Push esi, edx
            Call IsJumpDownOrUp

            ..If B$JumpIs = DOWN
                Mov D$CodeRefScan eax
                Mov D$FirstDownCodeRefScan eax, D$FirstDownShortenJmp esi
                Move W$CodeRefName1 W$eax-5
                Mov ebx esi | add esi 4
                Push esi, edx
                    Mov eax esi | add eax 133-4 | On eax < edx, Mov edx eax

                    While esi <= edx
                        .If B$esi <> 0
                            Call IsJumpDownOrUp ; >>> eax ---> 'CodeRefScan'

                            If B$JumpIs = UP
                                Mov D$SecondUpCodeRefScan eax
                                Move W$CodeRefName2 W$eax-5
                                Mov D$SecondUpShortenJmp esi
                                Call CouldBothBeShorten
                                On eax = &FALSE, jmp L2>
                                Call SetBothShort | jmp L4>
                            End_If

                        .End_If

L2:                     inc esi
                    End_While
L4:             Pop edx, esi

            ..End_If
            Pop edx, esi
        ...End_If

L5:     inc esi
    .End_While
ret
____________________________________________________________________________________________

[JumpIs: D$ ?]

[Down 1
 Up 2]

IsJumpDownOrUp:
    Push ebx, ecx
        Mov eax esi | sub eax D$ShortenJmpsTable | add eax D$CodeListOrigine
        Mov ebx D$CodeRefScan

    ; >>> Two Pointers (One to CodeList -eax-, and one to CodeRef -ecx-):
L1:     Mov ecx D$ebx | and ecx (not relativeFlag)

        .If ecx = eax
            If W$ebx-3 = '>>'
                Mov B$JumpIs DOWN
                Mov eax ebx

            Else_If W$ebx-3 = '<<'
                Mov B$JumpIs UP
                Mov eax ebx

            Else
                Mov B$JumpIs 0

            End_If

        .Else_If ecx = 0
            Mov B$JumpIs 0

        .Else
          ; Next Record in 'CodeRef':
            add ebx 9
          ; No API Call:
            While B$ebx = 0FF | add ebx 6 | End_While
          ; Skip the "labelName|":
            While B$ebx > EOI | inc ebx | End_While | inc ebx | jmp L1<<

        .End_If

L9: Pop ecx, ebx
ret


CouldBothBeShorten:
;;
  When reducing from (5 or 6) to 2, we reduce of (3 or 4)
  From Flag to Label:
  
  Down: (07F): 1 + 127 +(3 or 4) =
                129  +    3 or 4      = 132 or 133
                
  Up:   (080): 128 -(1 or 0) +(3 or 4) =
                128 or 129     3 or 4    = 130, 131, 132
;;

  ; In between Distance, in the 'ShortenJmpsTable' Table:
    Push ebx, ecx, edx
        Mov ebx D$FirstDownShortenJmp, edx D$SecondUpShortenJmp
        Mov ecx edx | sub ecx ebx

        Mov eax &FALSE

        If B$ebx = LONG_Jcc
            Mov ecx 135 | On B$edx = LONG_JMP, dec ecx
        Else
            Mov ecx 134 | On B$edx = LONG_Jcc, inc ecx
        End_If
        inc ecx

        Call GetDisplacementDown

        .If B$CanBeShorten = &TRUE
            If B$edx = LONG_Jcc
                Mov ecx 132 | On B$ebx = LONG_JMP, dec ecx
            Else
                Mov ecx 130 | On B$ebx = LONG_Jcc, inc ecx
            End_If
            inc ecx

            Call GetDisplacementUp

            If B$CanBeShorten = &TRUE
                Mov eax &TRUE
            Else
                Mov eax &FALSE
            End_If

        .Else
            Mov eax &FALSE

        .End_If

L9: Pop edx, ecx, ebx
ret
____________________________________________________________________________________________

SetBothShort:
    Mov eax D$FirstDownShortenJmp

    If B$eax = LONG_JMP
        Mov B$eax SHORTEN_LONG_JMP
    Else
        Mov B$eax SHORTEN_LONG_Jcc
    End_If

    Mov eax D$SecondUpShortenJmp

    If B$eax = LONG_JMP
        Mov B$eax SHORTEN_LONG_JMP
    Else
        Mov B$eax SHORTEN_LONG_Jcc
    End_If

    Mov eax D$FirstDownCodeRefScan, B$eax-2, '.'
    Mov eax D$SecondUpCodeRefScan,  B$eax-2, '.'

    add D$NumberOfLongToShort 2
ret
____________________________________________________________________________________________

[CanBeShorten: D$ ?
 ScanSize: D$ ?]

TryToShortenLong:
    pushad
;;
  ecx is a Pointer to CodeRef, to a Long jmp Displacement. Could it be Short?
  
  1) Is it Long Up or Long Down? >>> Read the '<<' or '>>', at D$CodeRefScan
;;
        Mov B$CanBeShorten &FALSE

        If W$CodeRefName+2 = '>>'
            Mov D$ScanSize (07F+4+1)
;;
  '+4' is the size of the long jump Displacement (We are pointing to the first Byte ot it).
  Either B$LongInstruction = LONG_Jcc, or LONG_JMP do not change a thing:
  Just moving it all upward 1 Byte, later, if LONG_Jcc.
  Why '+1'? Because the Processor will start from the Byte after the jump.
;;
            Call ShortenLongDown

        Else_If W$CodeRefName+2 = '<<'
            Mov D$ScanSize 080
          ; If an Instruction is a Jcc the Opcode length will switch from 2 to 1:
            On B$LongInstruction = LONG_Jcc, inc D$ScanSize

            Call ShortenLongUp

        End_If
    popad
ret
____________________________________________________________________________________________

ShortenLongDown:
  ; ebx = D$CodeRefScan >>> Label Name // ecx = 'CodeRef' Pointer to 'CodeList'

  ; Search a Label Declaration Pointer bigger that the CodeRef Evocation Pointer:
  ; eax = 'LabelList' Pointer to 'CodeList' // ecx = 'CodeRef' Pointer to 'CodeList'
  ; We search for a Pointer, in Label List, such as "ecx < D$esi < edx":
    Mov esi D$LabelListScanPointer

    While D$esi > ecx
        PreviousLabelListPointer esi
    End_While

    While D$esi < ecx
        NextLabelListPointer esi
    End_While

    Mov D$LabelListScanPointer esi

  ; Search the next same Label, in LabelList, as the one pointed by ebx.
  ; Store, for example 'K9', of "K9>>", in ebx:
    Mov bx W$CodeRefName
  ; Scan-Down Limit (07F (127) is the limit for positive signed bytes):
    Mov edx ecx | add edx D$ScanSize

  ; Search for the matching Label in the matching range, if any:
    While D$esi < edx
      ; Does 'esi-3' point to "K9", in "|K9|....f|" ?
      ; A LabelList Record is: // EOI, LabelName, EOI, Pointer, Flag, // EOI, ...
        .If W$esi-3 = bx
            cmp B$esi-4 EOI | jne L5>
            cmp B$esi-1 EOI | jne L5>
              ; Found a matching Label, that is Long, and that can be made Short:
                Mov B$CanBeShorten &TRUE
                inc D$NumberOfLongToShort | jmp L9>

        .Else
L5:         NextLabelListPointer esi

        .End_If

    End_While

    Mov B$CanBeShorten &FALSE
L9: ret
____________________________________________________________________________________________

GetDisplacementDown:
;;
  'FirstDownCodeRefScan' has kept track of the Reference. That is, the pointer to Codelist
  found in the CodeRef Table.
  
  We search for a Pointer, in LabelList, that would be bigger than 'FirstDownCodeRefScan',
  with a matching Name.
  
  Abort if bigger than 'FirstDownCodeRefScan' + 133.
;;
    pushad
      ; Go to the first Label closer to 'FirstDownShortenJmp'
        Mov esi D$LabelListScanPointer
        Mov eax D$FirstDownCodeRefScan, eax D$eax | and eax (not relativeFlag)

        While D$esi > eax
            PreviousLabelListPointer esi ; 'LabelList'
        End_While

        While D$esi < eax
            NextLabelListPointer esi ; 'LabelList'
        End_While
        PreviousLabelListPointer esi
        Mov D$LabelListScanPointer esi

      ; Search the next same Label, in LabelList, as the one pointed by ebx.
      ; Store, for example 'K9', of "K9>>", in ebx:
        Mov bx W$CodeRefName1
      ; Scan-Down Limit:
        Mov edx eax | add edx ecx

      ; Search for the matching Label in the matching range, if any:
        While D$esi < edx
            .If W$esi-3 = bx
                cmp B$esi-4 EOI | jne L5>
                cmp B$esi-1 EOI | jne L5>
                  ; Found a matching Label, that is Long, and that could be made Short:
                    Mov B$CanBeShorten &TRUE | jmp L9>

            .Else
L5:             NextLabelListPointer esi

            .End_If

        End_While

        Mov B$CanBeShorten &FALSE
L9: popad
ret
____________________________________________________________________________________________

; A Jump can be short Up if it is > 0FFFF_FF80

ShortenLongUp:
  ; ebx = D$CodeRefScan >>> Label Name // ecx = 'CodeRef' Pointer to 'CodeList'

  ; Search the next same Label, in LabelList, as the one pointed by ebx.
  ; Store, for example 'K9', of "K9>>", in ebx:
    Mov bx W$CodeRefName
    Mov edx ecx | sub edx D$ScanSize

  ; Search a Label Declaration Pointer smaller that the CodeRef Evocation Pointer:
  ; eax = 'LabelList' Pointer to 'CodeList' // ecx = 'CodeRef' Pointer to 'CodeList'
  ; We search for a Pointer, in Label List, such as "ecx < D$esi < edx":
    Mov esi D$LabelListScanPointer

    While D$esi > ecx
        PreviousLabelListPointer esi
    End_While

    While D$esi < ecx
        NextLabelListPointer esi
        On D$esi = 0, jmp L7>
    End_While

L7: PreviousLabelListPointer esi
    Mov D$LabelListScanPointer esi

  ; Search for the matching Label in the matching range, if any:
    While D$esi > edx
      ; Does 'esi-7' point to "K9", in "|K9|....f|
      ; A LabelList Record is: // EOI, LabelName, EOI, Pointer, Flag, // EOI, ...
        .If W$esi-3 = bx
            cmp B$esi-4 EOI | jne L5>
            cmp B$esi-1 EOI | jne L5>
          ; Found a matching Label, that is Long, and that can be made Short:
                Mov B$CanBeShorten &TRUE
                inc D$NumberOfLongToShort | jmp L9>

        .Else
L5:         PreviousLabelListPointer esi

        .End_If

    End_While

    Mov B$CanBeShorten &FALSE
L9: ret
____________________________________________________________________________________________

GetDisplacementUp:
;;
  'FirstDownCodeRefScan' has kept track of the Reference. That is, the pointer to Codelist
  found in the CodeRef Table.
  
  We search for a Pointer, in LabelList, that would be bigger than 'FirstDownCodeRefScan',
  with a matching Name.
;;
    pushad
      ; Go to the first Label closer to 'FirstDownShortenJmp'
        Mov esi D$LabelListScanPointer
        Mov eax D$SecondUpCodeRefScan, eax D$eax | and eax (not relativeFlag)

        While D$esi < eax
            nextLabelListPointer esi
        End_While

        While D$esi > eax
            PreviousLabelListPointer esi
        End_While
        NextLabelListPointer esi

        Mov D$LabelListScanPointer esi

      ; Search the next same Label, in LabelList, as the one pointed by ebx.
      ; Store, for example 'K9', of "K9>>", in ebx:
        Mov bx W$CodeRefName2
      ; Scan-Down Limit:
        Mov edx eax | sub edx ecx

      ; Search for the matching Label in the matching range, if any:
        Mov eax D$FirstDownCodeRefScan
        While D$esi > edx
            If W$esi-3 = bx
                ;On D$esi > eax, jmp L8>
                cmp B$esi-4 EOI | jne L5>
                cmp B$esi-1 EOI | jne L5>
                  ; Found a matching Label, that is Long, and that could be made Short:
                    Mov B$CanBeShorten &TRUE | jmp L9>

            Else
L5:             PreviousLabelListPointer esi

            End_If
        End_While

L8:     Mov B$CanBeShorten &FALSE
L9: popad
ret
____________________________________________________________________________________________

; LabelListScanPointer points to one of the dWord Pointers, in LabelList:

[LabelListScanPointer: D$ ?]

InitLabelListScanDwordPointer:
  ; Dword | ... // ...| Name | Dword1 Byte | // ....  ;;; 'StoreDataLabel'
  ;    ...|LabelName|....f|LabelName|....f|
    Mov esi D$LabelList | add esi 5
L0: While B$esi > EOI | inc esi | End_While | inc esi

    While B$esi+4 < FLAG_CODE_LABEL
        NextLabelListPointer esi
    End_While

    Mov D$LabelListScanPointer esi
  ; >>> D$LabelListScanPointer points to the dWord (Pointer to CodeList)
ret

[NextLabelListPointer
 add #1 6
 N4: cmp B$#1 EOI | je N5> | cmp D$#1 0 | je N5> | inc #1 | jmp N4<
 N5: inc #1]

[PreviousLabelListPointer
 sub #1 2
 N4: cmp B$#1 EOI | je N5> | cmp #1 LabelList | je N5> | dec #1 | jmp N4<
 N5: sub #1 5]

____________________________________________________________________________________________

;;
  'SHORTEN_LONG_JMP' or 'SHORTEN_LONG_Jcc' found in 'ShortenJmpsTable':
  
  * add 3 to eax.
  
  * All LabelList References to CodeList, downward this Pos, must be substract
    with eax.
    
  * All CodeRef Pointers to a downward Pos must also be substract with eax.
;;

CompactLabelListAndCodeRef:
    Mov ebx D$ShortenJmpsTable, edx D$EndOfShortenJmpsTable

    Call InitLabelListScanDwordPointer
  ; >>> esi ---> D$LabelListScanPointer

  ; Edi = Will point to the dWord1 of 'CodeRef':
    Mov edi D$CodeRef | add edi 5

  ; Case of Api Calls: ...|0FF dWordCodeAddress|:
  ;                   ....|.....|
    While B$edi = 0FF | add edi 6 | End_While

  ; Pointing to the 'CodeRef' Pointer to 'CodeList';
    While B$edi <> EOI | inc edi | End_While | inc edi

    Mov eax 0

    While ebx <= edx
        If B$ebx > SHORTEN
            Mov cl B$ebx, B$LongInstruction cl
            Call AdjustAboveListPointers
            add eax 3
        End_If

        inc ebx
    End_While

    Call AdjustLastListPointers
ret
____________________________________________________________________________________________

AdjustAboveListPointers:
  ; ("Above" means in between the previous access and the actual access).

    Push ebx
      ; esi ---> LabelList / edi ---> CodeRef.

      ; ecx = Offset matching the actual Shorten Jump Displacement, in 'CodeList':
        Mov ecx ebx | sub ecx D$ShortenJmpsTable | add ecx D$CodeListOrigine

      ; LabelList adjustments of the Pointers to Code:
      ; ("<" because the Label is necessary _before_ the Instruction).
        While D$esi < ecx
            sub D$esi eax
            NextLabelListPointer esi
            On D$esi = 0, jmp L1>
        End_While
;;
  CodeRef adjustments of the Pointers to Code:
  
  2 Problems: 
  
  1) The Records for Api calls are irregular. We just skip over them.
  
  2) The Pointer to 'CodeList', in 'CodeRef' (dWord1) the 'RelativeFlag' is [On].
;;
L1:     Mov ebx D$edi | and ebx (not RelativeFlag)
      ; "<=", because the Evocation Reference and the Shorten Jump match exactly:
        .While ebx <= ecx
            .If ebx = ecx
                If B$LongInstruction = SHORTEN_LONG_Jcc
                    inc eax
                End_If
            .End_If
            sub ebx eax
            test D$edi RelativeFlag ZERO L2>
                or ebx RelativeFlag
L2:         Mov D$edi ebx

          ; Next CodeRef Record:
            add edi 9
          ; Cases of Api calls. Comments in 'FillCodeSymbols'. We just skip over:
            While B$edi = 0FF | add edi 6 | End_While
            While B$edi <> EOI | inc edi
                On D$edi = 0, jmp L9>
            End_While
            inc edi
            Mov ebx D$edi | and ebx (not RelativeFlag)
        .End_While

L9: Pop ebx
ret
____________________________________________________________________________________________

AdjustLastListPointers:
  ; Same as above 'AdjustAboveListPointers', but just assume the lasting Records:

  ; LabelList adjustments:
    While D$esi <> 0
        sub D$esi eax
        NextLabelListPointer esi
    End_While

  ; CodeRef adjustments:
    .While D$edi <> 0
        Mov ebx D$edi | and ebx (not RelativeFlag)
        sub ebx eax | Test D$edi RelativeFlag ZERO L1>
            or ebx RelativeFlag

L1:     Mov D$edi ebx
      ; Next CodeRef Record:
        add edi 9
      ; Cases of Api calls. Comments in 'FillCodeSymbols'. We just skip over:
        While B$edi = 0FF | add edi 6 | End_While
        While B$edi <> EOI
            inc edi | On D$edi = 0, jmp L9>
        End_While | inc edi
    .End_While
L9: ret
____________________________________________________________________________________________

CompactCodeList:
    Mov ebx D$ShortenJmpsTable, edx D$EndOfShortenJmpsTable
    Mov esi D$CodeListOrigine, edi esi

    While ebx <= edx
        If B$ebx = SHORTEN_LONG_JMP
          ; jmp Long = 0E9 >>> jmp short = 0EB
            Mov B$edi-1 0EB, B$edi 0
            add esi 4 | add ebx 4 | inc edi

        Else_If B$ebx = SHORTEN_LONG_Jcc
          ; Example: B$esi-2 >>> 0F, 084 (JE long) >>> 074 (JE short), 0:
            Mov al B$esi-1 | sub al 010 | Mov B$edi-2 al, B$edi-1 0
            add esi 4 | add ebx 4

        Else
            movsb | inc ebx

        End_If

    End_While

  ; Copy the Bytes coming after the last modified CodeRef Pointer:
    While esi < D$CodeListPtr | movsb | End_While

  ; Cosmetic clean-up of the trailing Bytes in CodeList:
    Push edi
        Mov al 0 | While edi < D$CodeListPtr | stosb | End_While
    Pop edi
    Mov D$CodeListPtr edi
ret
____________________________________________________________________________________________

CompactShortenJmpsTable:
    Mov esi D$ShortenJmpsTable, edx D$EndOfShortenJmpsTable
    Mov edi esi, eax 0

    While esi <= edx
        If B$esi = SHORTEN_LONG_JMP
            Mov B$esi 0 | add esi 3

        Else_If B$esi = SHORTEN_LONG_Jcc
            Mov B$esi 0 | add esi 4

        Else
            movsb

        End_If

    End_While

    Mov D$EndOfShortenJmpsTable edi
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Parsers         ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
; Maintainer: Rikkert Wiggerink (EvilBro)
; Started: Somewhere in april 2003
; Email: r.wiggerink@student.utwente.nl
____________________________________________________________________________________________
;;
29-4-2003:
 This is the first version of the rewritten parsers in an official RosAsm release.
 This is by no means the end of the revision. :)
  
 The philosophy behind this revision:
    The routines that previously cleaned up the source have been replaced and split up into 
    many different routines (duplicate actions were removed). This is done for maintainance 
    purposes. Anyone who has taken a look at the old routines will see the importance of this 
    split up (from a maintainance point of view anyway :) )
    
    There will be some people who will think the clean up needs to be done in a single routine
    (Yes, I mean Kenny :) ). This will not work. It is what Betov started with when the old
    routines were written (and we all know the hell that followed from that... at least I do).
    There is also no need for the extra performance a single clean up routine would bring.
    On my Pentium 90 compilation of RosAsm takes 39.8 seconds with the new routines and 
    38.5 seconds with the old routines (average timing values used). That means that the new 
    routines are roughly a second slower (on a source like RosAsm). However, this second is 
    completely insignificant compared to the total compile time.

 All parsers I've written expect the source to be in CodeSourceA. They will either modify the 
 source in CodeSourceA directly or copy/modify the source to CodeSourceB. On exiting a routine
 the source will be in CodeSourceA. This is done for simplicity.

 Anyway, I expect that now this version is implemented in an official RosAsm release, errors 
 are bound to turn up. Just post them on the RosAsm forum or mail them directly to me and 
 I'll fix them.

 BTW 'Kill' means 'replace by spaces'. 'Strip' means 'replace by nothing'.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________
; NewCopyToCodeSourceA replaces CopyToCodeSourceA which always used CodeSource as the <Source>.
; usage: Call NewCopyToCodeSourceA <Source> <SourceLength>

Proc NewCopyToCodeSourceA:
    Arguments @Pointer, @Length

        Mov esi D@Pointer, ecx D@Length, edi D$CodeSourceA, D$StripLen ecx
        rep movsb
EndP

Proc InjectedCopyToCodeSourceA:
    Arguments @Pointer, @Length

        Mov esi InjectedTIME_COUNT, edi D$CodeSourceA, ecx D$InjectedTIME_COUNT_Len
        Mov D$StripLen ecx | rep movsb

        Mov esi D@Pointer, ecx D@Length | add D$StripLen ecx | rep movsb
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________
; CoolParsers are all parsers that do not change the position of statements in the source.

CoolParsers:
    Call CheckTextDelimitersPairing
    Call KillMultiLineComments ; and Comments
   ; Call KillSingleLineComments
    Call NewKillVirtualCRLF
    Call KillMeaninglessCommas
    Call CheckandKillPreParsers
        On B$ParseIncInclude = &TRUE, Call ClearIncludeStateMentsFromSource ;Call IncParser
        On B$ParseAlternates = &TRUE, Call AlternatesPreparsers
      ; +0.2 seconds (2.850 >>> 3.650) on RosAsm 4 Megas, with a Celeron 1.3.
    Call KillTitles ; + Old 'ConvertTextSigns'
   ; Call CheckBracketsPairing
    ;Call CheckNestedBracketsPairing
    Call CheckPairings
    Call ReplaceParaMacrosBrackets
   ; Call CheckOpenCloseSignPairing
ret
;;
CoolParsersOnInc:
        Call CheckTextDelimitersPairing
        Call KillMultiLineComments ; and Comments
       ; Call KillSingleLineComments
        Call NewKillVirtualCRLF
        Call KillMeaninglessCommas
;;

CoolParsersOnInc: ; CoolParsers
    Push D$CodeSourceA, D$StripLen

        Move D$CodeSourceA D$bininc.mem, D$StripLen D$bininc.filesize

        Call CheckTextDelimitersPairing
        Call KillMultiLineComments ; and Comments
       ; Call KillSingleLineComments
        Call NewKillVirtualCRLF
        Call KillMeaninglessCommas

    Pop D$StripLen, D$CodeSourceA
ret

____________________________________________________________________________________________
; HotParsers are parsers that can change the position of statements in the source.

HotParsers:
    Call TranslateAsciiToMyAscii

    Call StripUnderscore
    On B$ProfilerFlag = &TRUE, Call InjectDashLines

    Call StripUnneededSpaces
    Call ConvertCommasToSpace
    Call StripUnneededEOI
    Call ConvertEOIinBracketsTOmeEOI
   ; Call ConvertTextSigns    ; This one 'needs' to be done sooner. Would simplify earlier routines
    Call ExtendLocalSymbols
    Call IdentifyVirtualData
    Call ReorderSource
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
CheckTextDelimitersPairing:
    Mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

@TODO.CheckTextDelimitersPairing:

    Mov B$esi-1 LF      ; for MultiLineComment starting on the first line

    .While esi < ecx
        .If B$esi = '"'
            Mov edx esi
            Do
                inc esi | cmp esi ecx | je L9>  ; Error: no closing delimiter found inside source.
            Loop_Until B$esi = '"'
        .Else_If B$esi = "'"
            Mov edx esi
            Do
                inc esi
                cmp esi ecx | je L9>        ; Error: no closing delimiter found inside source.
                cmp B$esi CR | je L9>       ; Error: ' isn't allowed to be multiline.
            Loop_Until B$esi = "'"
        .Else_If B$esi = ';'
            If D$esi-1 = MLC
                Do
                    inc esi | cmp esi ecx | je L8>
                Loop_Until D$esi = MLC
                inc esi
            Else
                Do
                    inc esi
                Loop_Until B$esi < SPC
            End_If
        .End_If
        inc esi
    .End_While
L8: ret

L9: ;ERROR! Unpaired textdelimiter.
    Mov esi edx
    While B$esi > LF | dec esi | End_While
    Mov edi CookedErrorMessage
    While B$esi <> CR
        movsb | On edi = EndOfCookedErrorMessage, jmp L2>
    End_While
L2: Mov B$edi 0

    Mov B$Errorlevel 9 | Error D$OpenTextPtr

ret
____________________________________________________________________________________________
; Multiline comments are converted to spaces.

KillMultiLineComments:
    Mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    Mov B$esi-1 LF      ; for MultiLineComment starting on the first line

    .While esi < ecx
        ..If B$esi = '"'
            Do | inc esi | Loop_Until B$esi = '"'
        ..Else_If B$esi = "'"
            Do | inc esi | Loop_Until B$esi = "'"
        ..Else_If B$esi = ';'
            .If D$esi-1 = MLC
                Do
                    Mov B$esi SPC
                    inc esi | On esi >= ecx, ret
                Loop_Until D$esi = MLC
                Mov D$esi 0D202020  ; Replace 'LF ; ; CR' with 'Space Space Space CR'.
                add esi 3
            .Else
                ;On D$esi+1 = ' Tag', Call AssemblyTag
                Do | Mov B$esi SPC | inc esi | Loop_Until B$esi < SPC
            .End_If
        ..End_If
        inc esi
    .End_While
L8: ; KillMultiLineComments might have killed the closing CRLF, thus it is restored.
    Mov W$esi-2 0A0D
ret
________________________________________________________________________________________________
; Titles are converted to spaces.

KillTitles: ; ConvertTextSigns
    Mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = '"'
            Mov B$esi TextSign
            Do | inc esi | Loop_Until B$esi = '"'
            Mov B$esi TextSign
        .Else_If B$esi = "'"
            Mov B$esi TextSign
            Do | inc esi | Loop_Until B$esi = "'"
            Mov B$esi TextSign
        .Else_If D$esi = 'TITL'
            If B$esi-1 = LF
                On W$esi+4 <> 'E ', jmp L0>
                    Do | Mov B$esi SPC | inc esi | Loop_Until B$esi < SPC
L0:
            End_If
        .End_If

        inc esi

    .End_While

L8: ret

________________________________________________________________________________________________
; VirtualCRLFs are converted to spaces.

[DisableWarning: B$ 0]

NewKillVirtualCRLF:
    Mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    ..While esi < ecx
        ...If B$esi = '"'
            Do | inc esi | Loop_Until B$esi = '"'
        ...Else_If B$esi = "'"
            Do | inc esi | Loop_Until B$esi = "'"
        ...Else_If B$esi = ','
            Push esi
            .While W$esi-1 <> CRLF
                dec esi
                    ..If_Or B$esi = '+', B$esi = '-', B$esi = '/', B$esi = '*', B$esi = '^'
                        .If B$DisableWarning = &FALSE
                            SyntaxErrorInMacro1 D$BadSyntaxBeforeCommaPtr esi
                            pushad
                            Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ "Disable previous warning ?" EOS}, {B$ 'Syntax Error Found' EOS}, &MB_SYSTEMMODAL__&MB_ICONEXCLAMATION__&MB_YESNO
                            If eax = &IDYES
                                Mov B$DisableWarning &TRUE
                            End_If
                            popad

                        .End_If
                        Mov B$esi SPC
                    ..Else_If B$esi = SPC
                    ..Else ; any other char, exit
                        jmp L5>
                    ..End_If
            .End_While
         L5: | Pop esi
        ...Else_If B$esi = CR
            Mov edi esi, al SPC
            While B$edi <= SPC
                dec edi | On edi < D$CodeSourceA, jmp L7>
            End_While
            If B$edi = ','
                Do
                    stosb | cmp edi ecx | ja L8>
                Loop_Until B$edi > SPC
            End_If
        ...End_If

L7:     inc esi

    ..End_While
L8: ret
________________________________________________________________________________________________
; Meaningless commas are converted to spaces.
; Note: This routine will probably Move to HotParsers in the future.

KillMeaninglessCommas:
    Mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = '"'
            Do | inc esi | Loop_Until B$esi = '"'
        .Else_If B$esi = "'"
            Do | inc esi | Loop_Until B$esi = "'"
        .Else_If B$esi = ','
            Mov edi esi
            Do
                inc edi
            Loop_Until B$edi <> SPC

            If B$edi = '+'
                Mov esi edi
            Else_If B$edi = '-'
                Mov esi edi
            Else
                Mov B$esi SPC
            End_If
        .End_If

        inc esi

    .End_While
ret
____________________________________________________________________________________________
; Checks for PREPARSE statements, sets the right flags and then kills the PREPARSE statements.
; Note that any amount of PREPARSE statements can be used in the source with this new routine.

[ParseAlternates: D$ ?
 ParseEqual: D$ ?
 ParseOOA: D$ ?
 ParseNew: D$ ?
 ParseBinInclude: D$ ?
 ParseIncInclude: D$ ?]

CheckandKillPreParsers:

    Mov B$ParseAlternates &FALSE, B$ParseEqual &FALSE, B$ParseOOA &FALSE, D$FL.Dynamic &FALSE

    Mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = '"'
            Do | inc esi | Loop_Until B$esi = '"'
        .Else_If B$esi = "'"
            Do | inc esi | Loop_Until B$esi = "'"
        .Else_If D$esi = 'PREP'             ; PREPARSE
            ..If D$esi+4 = 'ARSE'
                If B$esi-1 = LF
                    On B$esi+8 <> SPC, jmp L6>
                    Call NewCheckPreparser
                    Do
                        Mov B$esi SPC
                        inc esi
                    Loop_Until B$esi < SPC
L6:
                End_If
            ..End_If
        .End_If

L7:     inc esi

    .End_While
L8: ret
_______________________________________________________________________________________________
; This routine is not really altered at this point compared to the old routine. This will be
; done in a future version as this version is really unreadable (and thus hard to maintain).

[FL.Dynamic: D$ ?
 MemReservation: D$ ?]

NewCheckPreparser:
    Mov D$MemReservation 0

    Mov edi esi
    add edi 9

L1: While B$edi = SPC | inc edi | End_While

    Mov eax D$edi | and eax (not 020202020)     ; Convert to uppercase.
    ...If eax = 'ALTE'                          ; ALTERNATES
        Mov eax D$edi+4 | and eax (not 020202020)
        ..If eax = 'RNAT'
            Mov ax W$edi+8 | and eax (not 02020)
            .If ax = 'ES'
                If B$edi+10 <= SPC
                    Mov B$ParseAlternates &TRUE | add edi 11 | jmp L8>>
                End_If
            .End_If
    ...Else_If eax = 'EQUA'                     ; EQUAL
        Mov al B$edi+4 | and eax (not SPC)
        .If al = 'L'
            If B$edi+5 <= SPC
                Mov B$ParseEqual &TRUE | add edi 6 | jmp L8>>
            End_If
        .End_If
    ...Else_If eax = 'BINI'                     ; BinIncluder
        Mov eax D$edi+4 | and eax (not 020202020)
        .If eax = 'NCLU'
            Mov eax D$edi+7 | and eax (not 020202020)
            If eax = 'UDER'
                Mov B$ParseBinInclude &TRUE | add edi 12 | jmp L8>>
            End_If
        .End_If
    ...Else_If eax = 'INCI'                     ; IncIncluder
        Mov eax D$edi+4 | and eax (not 020202020)
        .If eax = 'NCLU'
            Mov eax D$edi+7 | and eax (not 020202020)
            If eax = 'UDER'
                Mov B$ParseIncInclude &TRUE | add edi 12 | jmp L8>>
            End_If
        .End_If
    ...Else_If ax = 'OO'                        ; OOA
        Mov al B$edi+2 | and eax (not SPC)
        .If al = 'A'
            If B$edi+3 <= SPC
                Mov B$ParseOOA &TRUE | add edi 4 | jmp L8>>
            End_If
        .End_If
    ...Else_If ax = 'NE'                        ; Prepare New
        Mov al B$edi+2 | and eax (not SPC)
        .If al = 'W'
            If B$edi+3 <= SPC
                Mov B$ParseNew &TRUE | add edi 4 | jmp L8>>
            End_If
        .End_If
    ...Else_If ax = 'EN'                        ; Preparse EntryPoint
        Mov eax D$edi+2 | and eax (not 020202020)
        .If eax = 'TRYP'
            Mov eax D$edi+6 | and eax (not 020202020)
            If eax = 'OINT'
                Call TakeNewEntryPoint | ret   ; Must be separated on one line
            End_If
        .End_If
    ...Else_If eax = 'DYNA'                        ; Preparse Dynamic
        Mov eax D$edi+3 | and eax (not 020202020)
        If eax = 'AMIC'
            Mov D$FL.Dynamic &TRUE | add edi 8 | jmp L8>
        End_If
;;
  ; Must be run before this time...
  
    ...Else_If eax = 'RESE'                        ; Preparse Reserve
        Mov eax D$edi+3 | and eax (not 020202020)
        If eax = 'ERVE'
            Call ReadMemoryReservation
            add edi 8 | jmp L8>
        End_If
;;

    ...End_If

    Mov B$edi-1 0, esi edi
    While B$edi > SPC | inc edi | End_While | Mov B$edi 0
    Mov B$ErrorLevel 9 | Error D$BadPreParsePtr, esi

L8:  On B$edi >= SPC, jmp L1<<

; Possible add of multiple Pre-Parsers conflicts checking...
ret

[BadEntryDef: B$ 'Bad definition of EntryPoint in "Preparse EntryPoint"' EOS]

TakeNewEntryPoint: ; Preparse EntryPoint Name
    Push esi, edi, ecx
        Mov esi edi | add esi 11 | Mov edi EntryPointLabel, ecx 0

        While B$esi > SPC
            lodsb | and eax (not SPC) | stosb | inc ecx
        End_While
        Mov B$edi 0

        Mov B$ErrorLevel 9
        Mov D$EntryPointLabelLen ecx | On ecx = 0, error BadEntryDef
    Pop ecx, edi, esi
ret
________________________________________________________________________________________________

[InsideBrackets: D$ ?
 VirtualBracketsCount: D$ ?
 FirstBracket: D$ ?
 LastBracket: D$ ?
 FirstVirtualBracket: D$ ?
 LastVirtualBracket: D$ ?
 FirstParenthesis: D$ ?
 LastParenthesis: D$ ?]

CheckPairings:
    Mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    Mov B$InsideBrackets &FALSE, edx esi
    Mov D$OpenSignsCount 0, D$VirtualBracketsCount 0

    .While esi < ecx
        Mov al B$esi

        .If al = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign

        .Else_If al = '['
            If B$InsideBrackets = &TRUE
                jmp L9>>
            Else_If D$VirtualBracketsCount <> 0
                jmp L9>>
            Else_If D$OpenSignsCount <> 0
                jmp L9>>
            Else
                Mov B$InsideBrackets &TRUE, D$FirstBracket esi
            End_If

        .Else_If al = ']'
            Mov D$LastBracket esi
            If D$VirtualBracketsCount <> 0
                jmp L9>>
            Else_If B$OpenSignsCount <> 0
                jmp L9>>
            Else_If B$InsideBrackets = &FALSE
                jmp L9>>
            End_If
            Mov B$InsideBrackets &FALSE

        .Else_If al = '{'
            Mov D$FirstVirtualBracket esi
            If B$InsideBrackets = &FALSE
                On D$VirtualBracketsCount > 0, jmp L9>> ; <<<<<<<<<<<<<<<<<<<<
            End_If
            inc D$VirtualBracketsCount

        .Else_If al = '}'
            Mov D$LastVirtualBracket esi
            dec D$VirtualBracketsCount | On D$VirtualBracketsCount = 0-1, jmp L9>>

        .Else_If al = '('
            On B$OpenSignsCount = 0, Mov D$FirstParenthesis esi
            inc B$OpenSignsCount

        .Else_If al = ')'
            Mov D$LastParenthesis esi
            dec D$OpenSignsCount | On D$OpenSignsCount = 0-1, jmp L9>>
        .End_If

        inc esi
    .End_While

    If B$InsideBrackets = &TRUE
        Mov B$esi '[' | jmp L9>
    Else_If D$VirtualBracketsCount <> 0
        Mov B$esi '{' | jmp L9>
    Else_If B$OpenSignsCount <> 0
        Mov B$esi ')' | jmp L9>
    End_If
ret

L9: ; Pointing the unpairing error:
    Push esi
        .If B$esi = '['
            If D$VirtualBracketsCount <> 0
                Mov esi D$FirstVirtualBracket
            Else_If D$OpenSignsCount <> 0
                Mov esi D$FirstParenthesis
            Else
                Mov esi D$FirstBracket
            End_If

        .Else_If B$esi = ']'
            If D$VirtualBracketsCount <> 0
                Mov esi D$FirstVirtualBracket
            Else_If D$OpenSignsCount <> 0
                Mov esi D$FirstParenthesis
            Else
                ;
            End_If

        .Else_If B$esi = '{'
            Mov esi D$FirstVirtualBracket
        .Else_If B$esi = '}'
            ;
        .Else_If B$esi = '('
            Mov esi D$FirstParenthesis
        .Else_If B$esi = ')'
            ;
        .End_If

        sub esi D$CodeSourceA | add esi D$CodeSource
        Mov eax esi
        While B$esi > LF | dec esi | End_While | inc esi
        While B$eax > LF | inc eax | End_While | dec eax

        Mov D$LP.BlockStartText esi,
            D$LP.BlockEndText eax,
            D$FL.BlockInside &TRUE

        Mov D$STRUCT.EditData@UpperLine esi

        Call UpOneLine | Call UpOneLine | Call UpOneLine

    Pop esi

  ; Set the Error Message Text:
    .If B$esi = '['
        If D$VirtualBracketsCount <> 0
            Mov eax UnPairedNestedBrackets
        Else_If D$OpenSignsCount <> 0
            Mov eax D$ParenthesisPtr
        Else
            Mov eax D$OrphanBracketPtr
        End_If

    .Else_If B$esi = ']'
        If D$VirtualBracketsCount <> 0
            Mov eax D$UnPairedNestedBracketsPtr
        Else_If D$OpenSignsCount <> 0
            Mov eax D$ParenthesisPtr
        Else
            Mov eax D$OrphanBracketPtr
        End_If

    .Else_If B$esi = '{'
        Mov eax D$UnPairedNestedBracketsPtr

    .Else_If B$esi = '}'
        Mov eax D$UnPairedNestedBracketsPtr

    .Else_If B$esi = '('
        Mov eax D$ParenthesisPtr

    .Else_If B$esi = ')'
        Mov eax D$ParenthesisPtr

    .Else
        Mov eax D$unknownPtr

    .End_If

    Mov edi CookedErrorMessage, esi D$LP.BlockStartText

    While esi < D$LP.BlockEndText

        movsb | On edi = EndOfCookedErrorMessage, jmp L2>

    End_While

L2: Mov B$edi 0

    Mov B$Errorlevel 9 | error eax
ret
____________________________________________________________________________________________

[InsideParaMacro: D$ ?]

ReplaceParaMacrosBrackets:
    Mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    Mov B$InsideBrackets &FALSE, B$InsideParaMacro &FALSE, ebx 0, edx 0

    .While esi < ecx
        lodsb

        ..If al = TextSign
            While B$esi <> TextSign | inc esi | End_While | inc esi
        ..Else_If al = '['
            Mov B$InsideBrackets &TRUE
        ..Else_If al = ']'
            Mov B$InsideBrackets &FALSE
        ..Else_If al = '{'
            .If B$InsideBrackets = &FALSE
                Mov B$esi-1 OpenParaMacro
                Mov B$InsideParaMacro &TRUE
            .Else
                Mov ebx esi | dec ebx
                While B$ebx <> '['
                    dec ebx
                    On B$ebx = '|', jmp L2>
                    On B$ebx = LF, jmp L2>
                    If B$ebx > SPC
                        Mov B$esi-1 OpenParaMacro
                        Mov B$InsideParaMacro &TRUE | jmp L2>
                    End_If
                End_While
            .End_If

        ..Else_If al = '}'
            If B$InsideParaMacro = &TRUE
                Mov B$esi-1 CloseParaMacro
                Mov B$InsideParaMacro &FALSE
            End_If

        ..End_If
L2: .End_While
ret
________________________________________________________________________________________________
; This routine will be moved to Hotparsers at a later time.
[OpenSignsCount: D$ ?]


____________________________________________________________________________________________
________________________________________________________________________________________________
NewCountStatements:
  ; How many statements:
    Mov B$ErrorLevel 0
    Mov esi D$CodeSourceA, D$StatementsCounter 0, D$LinesCounter 0
    Mov B$DontCountNext &FALSE
    Mov ebx esi | add ebx D$StripLen

    .While esi < ebx
        .If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign
        .Else_If B$esi = LF
            Mov B$DontCountNext &FALSE
        .Else_If B$esi = '|'
            Mov B$DontCountNext &FALSE
        .Else_If B$esi = '['
            inc D$LinesCounter
            .Do
                If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                End_If
                inc esi
            .Loop_Until B$esi = ']'
            Mov B$DontCountNext &FALSE
        .Else_If B$esi > SPC
            ..If B$esi <> '_'
                If B$DontCountNext = &FALSE
                    inc D$LinesCounter
                    Mov B$DontCountNext &TRUE
                End_If
            ..End_If
        .End_If

        inc esi
    .End_While

; set mem tables:

L9: If D$LinesCounter = 0

        Call CloseProgressBar

        Call 'USER32.MessageBoxA' D$H.MainWindow,
                                  {B$ "BUAsm can't compile empty files" EOS},
                                  {B$ ' Sorry' EOS},
                                  &MB_OK

        Mov D$FL.CompileErrorHappend &TRUE

        Mov esp D$OldStackPointer | ret ; direct error
       ; Pop eax | ret                  ; Abort, Pop caller and return to Message Loop
    End_If

    Mov eax D$LinesCounter | add eax 20 | shl eax 3  ; 2 > dword +1 > security

    Call VirtualAlloc StatementsTable,
                      eax

    Call VirtualAlloc StatementsTable2,
                      eax

;StoreStatements:

    Mov ecx D$CodeSource | sub ecx D$CodeSourceA    ; Ajust from CodeSource to CodeSourceA.
    Mov esi D$CodeSourceA, edi D$StatementsTable
    Mov B$DontCountNext &FALSE
    Move D$StatementsPtr D$StatementsTable | Move D$edi esi | add D$edi ecx
    Mov ebx esi | add ebx D$StripLen

    .While esi < ebx
        .If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign
        .Else_If B$esi = LF
            Mov B$DontCountNext &FALSE
        .Else_If B$esi = '|'
            Mov B$DontCountNext &FALSE
        .Else_If B$esi = '['

            Mov eax esi | add eax ecx | stosd | add D$StatementsPtr 4

            .Do
                If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                End_If

                inc esi
            .Loop_Until B$esi = ']'

            Mov B$DontCountNext &FALSE

        .Else_If B$esi > SPC
            ..If B$esi <> '_'
                If B$DontCountNext = &FALSE
                    Mov eax esi | add eax ecx | stosd | add D$StatementsPtr 4
                    Mov B$DontCountNext &TRUE
                End_If
            ..End_If
        .End_If

        inc esi
    .End_While

    Mov eax 0 | stosd
ret
________________________________________________________________________________________________
________________________________________________________________________________________________
; As of now a '_' outside a Win_equate is the same '' like it is supposed to be according to
; RosAsm help.

StripUnderscore:
    Mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = TextSign
            Do | movsb | Loop_Until B$esi = TextSign
        .Else_If B$esi = '&'
            If B$esi+1 > '9'
                Do | movsb | Loop_Until B$esi <= SPC
            End_If
        .Else_If B$esi = '_'
            Do | inc esi | Loop_Until B$esi <> '_'
        .End_If
        movsb
    .End_While

    Mov ecx edi
    sub ecx D$CodeSourceB
    Mov D$StripLen ecx

    Exchange D$CodeSourceA D$CodeSourceB
ret
________________________________________________________________________________________________
; To simplify operations, the source is converted to a special format called MyAscii.

[LowSigns            31
    TextSign            30

  NoSpaceAfterThis    29
    numSign             28   ; #  01C
    IfNumSign           27   ; Substitute of # for the Conditional macros #If, ... 01B

    OpenParaMacro       26   ; { for ParaMacros  01A
  NoSpaceBeforeThis   25
    CloseParaMacro      24   ; } for ParaMacros

    CommaSign           23   ; ,

    OpenVirtual         22   ; [   016 (Macros expanded '[' -{-)
    CloseVirtual        21   ; ]   015 (Macros expanded ']' -}-) 019
    OpenBracket         20   ; [   014
    CloseBracket        19   ; ]   013
; 18, 17 >>> NewOpenBracket / NewCloseBracket
  PartEnds            16
    memMarker           15   ; $ or $  exemple: Mov B$MYVALUE 1
    colonSign           14   ; :
    openSign            13   ; (
    closeSign           12   ; )

  OperatorSigns       11
    addSign             10   ; +
    subSign              9   ; -
    mulSign              8   ; *
    divSign              7   ; /
    expSign              6   ; ^
; 5
  Separators          4
   ; Statement           0FF
    Space               3    ; space
    EOI                 2    ; |  End Of Instruction (separator)
    meEOI               1]   ; |  End Of Instruction in macro expansion
                             ; 0 is used as erase sign inside treatements


[MyAsciiTable: B$ 0 1 2 3 4 5 6 7 8 Space EOI 11 12 EOI 14 15 16 17 18 19 20 21,
 22 23 24 25 26 27 28 29 30 31 Space '!' '"' NumSign memMarker '%' '&' 39 OpenSign,
 CloseSign MulSign AddSign CommaSign SubSign '.' DivSign 48 49 50 51 52 53 54,
 55 56 57 ColonSign ';' '<' 61 '>' '?' '@', ; !!! pas de virgule au départ à chaque !!!
 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90, ;!!! ; (A > Z)
 Openbracket '\' Closebracket expSign 95 96, ;!!!
 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90, ;!!! ; (A > Z)
 '{' EOI '}' 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143, ; !!!
 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164, ; !!!
 165 166 memMarker 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183,
 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204,
 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225,
 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246,
 247 248 249 250 251 252 253 254 255]

TranslateAsciiToMyAscii:
    Mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen, ebx 0
    add ecx D$CodeSourceA

    .While esi < ecx
        If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign

        Else
            Mov bl B$esi
            Mov al B$ebx+MyAsciiTable
            Mov B$esi al

        End_If

        inc esi
    .End_While
ret
________________________________________________________________________________________________

StripUnneededSpaces:
    Mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = TextSign
            Do | movsb | Loop_Until B$esi = TextSign | movsb
        .Else_If B$esi = Space
            ..If B$esi+1 = OpenSign
                If B$edi-1 = CloseSign
                    movsb
                Else_If B$edi-1 = CloseParaMacro
                    movsb
                Else_If B$edi-1 < NoSpaceAfterThis
                    inc esi
                Else
                    movsb
                End_If
            ..Else_If B$esi+1 < NoSpaceBeforeThis
                inc esi
            ..Else_If B$edi-1 < NoSpaceAfterThis
                If B$edi-1 = CloseSign
                    movsb
                Else_If B$edi-1 = CloseParaMacro
                    movsb
                Else
                    inc esi
                End_If
            ..Else_If B$esi+1 = '}'
                inc esi
            ..Else_If B$esi-1 = '{'
                inc esi
            ..Else
                movsb
            ..End_If
        .Else
            movsb
        .End_If
    .End_While

    Mov ecx edi | sub ecx D$CodeSourceB | Mov D$StripLen ecx

    Exchange D$CodeSourceA D$CodeSourceB
ret
____________________________________________________________________________________________

; Remaining some valid Comma. Example "Mov eax, -1".

ConvertCommasToSpace:
    Mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    While esi < ecx
        On B$esi = CommaSign, Mov B$esi Space
        inc esi
    End_While
ret
________________________________________________________________________________________________
StripUnneededEOI:
    Mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen | add ecx D$CodeSourceA

; Ensure that the source starts with an EOI
    If B$esi <> EOI
        Mov B$edi EOI
        inc edi
    End_If

    .While esi < ecx
        .If B$esi = TextSign
            Do | movsb | Loop_Until B$esi = TextSign | movsb
        .Else_If B$esi = EOI
            ..If B$esi+1 = EOI
                inc esi
            ..Else_If B$esi+1 = CloseBracket
                inc esi
            ..Else_If B$esi+1 = OpenBracket
                If B$edi-1 = CloseBracket
                    inc esi
                Else
                    movsb
                End_If
            ..Else
                movsb
            ..End_If
        .Else
            movsb
        .End_If
    .End_While

    Mov ecx edi
    sub ecx D$CodeSourceB
    Mov D$StripLen ecx

    Mov B$edi EOI,  B$edi+1 EOI | add D$Striplen 2          ; write end mark '||'

    Exchange D$CodeSourceA D$CodeSourceB
ret
____________________________________________________________________________________________

ConvertEOIinBracketsTOmeEOI:
    Mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen, ebx 0 | add ecx D$CodeSourceA

    Mov B$InsideBrackets &FALSE

    .While esi < ecx
        .If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign
        .Else_if B$esi = OpenBracket
            Mov B$InsideBrackets &TRUE
        .Else_if B$esi = CloseBracket
            Mov B$InsideBrackets &FALSE
        .Else_if B$esi = EOI
            If B$InsideBrackets = &TRUE
                Mov B$esi meEOI
            End_If
        .End_If
        inc esi
    .End_While
ret
________________________________________________________________________________________________
;;
  Automatic Labels (created by the Assembler, for example, with the "&0" Macro Key,
  are 8 Bytes Long. Example: ZZZZZZZZ: (See 'NoMeanLabel').
  
  The user cannot make use of this form of Labels.
;;

NoAutomaticLabel:
    Mov esi D$CodeSourceA, edx esi | add edx D$Striplen

    .While esi < edx
        If B$esi = TextSign
            inc esi
            While B$esi <> TextSign | inc esi | End_While
        End_If

        ..If B$esi = 'Z'
            .If B$esi-1 < LowSigns
                If D$esi = 'ZZZZ'
                  ; We have something begining with 'ZZZZ'. Must 8 chars long: 'ZZZZZZZ'
                    cmp B$esi+8 LowSigns | ja L2>

                    cmp B$esi+7 LowSigns | jb L2>
                    cmp B$esi+6 LowSigns | jb L2>
                    cmp B$esi+5 LowSigns | jb L2>
                    cmp B$esi+4 LowSigns | jb L2>

                        Mov B$esi+9 0, B$Errorlevel 9 | error ZZZZreserved, esi

                End_If
            .End_If
        ..End_If

L2:     inc esi
    .End_While
ret
________________________________________________________________________________________________
; The way local symbols are defined in the RosAsm syntax needs to be reviewed. Until that is
; properly done (somewhere in the future) this routine will have to do. :)

[LastFoundLabel: B$ ? # 80]
;;
  Beware: This Routine is called twice:
  
  First time from inside the HotParsers, to expand the 'normal' @Locals
  
  A second time for 'AsmMain', after the Equates and Macros Jobs, to expand the
  @Locals inserted by Macros Evocations.
;;
ExtendLocalSymbols:
    Mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen | add ecx D$CodeSourceA

    Mov B$LastFoundLabel 0

    .While esi < ecx
        ...If B$esi = TextSign
            Do | movsb | Loop_Until B$esi = TextSign

        ...Else_If B$esi = ColonSign
          ; On '::' don't process (as the label is already stored):
            ..If B$esi-1 < LowSigns
                ; Error holded downward.

            ..Else_If B$esi-1 <> ColonSign
              ; nonlocal label, as local labels are always 2 characters:
                .If B$esi-3 > LowSigns
                    Push esi
                    Mov al 0
                    Do | dec esi | On B$esi = '@', Mov al 1 | Loop_Until B$esi < LowSigns
                    If al = 1
                        Pop esi

                    Else
                        Pop eax
                        inc esi
                        Mov ebx LastFoundLabel
                        Do | lodsb | Mov B$ebx al | inc ebx | Loop_Until B$esi = ColonSign
                        Mov B$ebx 0
                    End_If

                .End_If
            ..End_If

        ...Else_If B$esi = OpenBracket
            Mov ebx esi | inc ebx
            While B$ebx > LowSigns | inc ebx | End_While
            If B$ebx = meEOI
                While B$esi <> CloseBracket | movsb | End_While
            End_If

        ...Else_If B$esi = '@'
            If B$esi-1 < LowSigns
                Mov ebx LastFoundLabel
                While B$ebx <> 0
                    Mov al B$ebx | inc ebx | stosb
                End_While
            Else_if B$esi-2 < LowSigns
                Mov al memMarker | stosb
                Mov ebx LastFoundLabel
                While B$ebx <> 0
                    Mov al B$ebx | inc ebx | stosb
                End_While
            End_If

            Do | movsb | Loop_Until B$esi < LowSigns
        ...End_If

        movsb
    .End_While

    Mov ecx edi | sub ecx D$CodeSourceB | Mov D$StripLen ecx

    Exchange D$CodeSourceA D$CodeSourceB
ret
________________________________________________________________________________________________

[VirtualDataFlag: D$ ?]

IdentifyVirtualData:
    Mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign
        .Else_If B$esi = OpenBracket
            Mov edx esi, B$VirtualDataFlag &FALSE
            .Do
                inc esi
                If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                Else_If B$esi = '{'
                    Do | inc esi | Loop_Until B$esi = '}'
                Else_If B$esi = '?'
                    Mov B$VirtualDataFlag &TRUE
                End_If
            .Loop_Until B$esi = CloseBracket

            If B$VirtualDataFlag = &TRUE
                Mov B$edx OpenVirtual, B$esi CloseVirtual
            End_If
        .End_If
        inc esi
    .End_While
ret
________________________________________________________________________________________________
; The source in CodeSourceA is reorders to: Data/Equates/Macro, Virtual Data, Code..

ReorderSource:
    Mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen | add ecx D$CodeSourceA

    Move D$StatementsPtr D$StatementsTable, D$StatementsPtr2  D$StatementsTable2

; Copy Brackets to CodeSourceB:

  ; this might be needed to skip first EOI if present.
    On B$esi = EOI, inc esi

    .While esi < ecx
        .If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign | inc esi

        .Else_If B$esi = OpenBracket
            lea edx D$esi+1

            .Do
                If B$esi = TextSign
                    Do | movsb | Loop_Until B$esi = TextSign
                End_If
                movsb

            .Loop_Until B$esi = CloseBracket
            movsb

            Mov eax D$StatementsPtr, eax D$eax
            Mov ebx D$StatementsPtr2, D$ebx eax
            add D$StatementsPtr2 4 | On D$edx <> 'ZZZZ', add D$StatementsPtr 4

        .Else_If B$esi = OpenVirtual
            .Do
                If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                End_If
                inc esi
            .Loop_Until B$esi = CloseVirtual
            inc esi

            add D$StatementsPtr 4

        .Else_If B$esi = EOI
            If B$esi-1 = CloseBracket
                ; nop
            Else_If B$esi-1 = CloseVirtual
                ; nop
            Else_If B$esi-1 = EOI
                ; nop
            Else
                add D$StatementsPtr 4
            End_If
            inc esi
        .Else
            inc esi
        .End_If
    .End_While

    Mov esi D$CodeSourceA

  ; Copy Virtual to CodeSourceB.
  ; this might be needed to skip first EOI if present.
    If B$esi = EOI
        inc esi
    End_If

    Move D$StatementsPtr D$StatementsTable

    .While esi < ecx
        .If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign | inc esi

        .Else_If B$esi = OpenBracket
            .Do
                If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                End_If
                inc esi
            .Loop_Until B$esi = CloseBracket
            inc esi

            add D$StatementsPtr 4

        .Else_If B$esi = OpenVirtual
            lea edx D$esi+1

            .Do
                If B$esi = TextSign
                    Do | movsb | Loop_Until B$esi = TextSign
                End_If
                movsb
            .Loop_Until B$esi = CloseVirtual
            movsb

            Mov eax D$StatementsPtr, eax D$eax
            Mov ebx D$StatementsPtr2, D$ebx eax
            add D$StatementsPtr2 4 | On D$edx <> 'ZZZZ', add D$StatementsPtr 4

        .Else_If B$esi = EOI
            If B$esi-1 = CloseBracket
                ; nop
            Else_If B$esi-1 = CloseVirtual
                ; nop
            Else_If B$esi-1 = EOI
                ; nop
            Else
                add D$StatementsPtr 4
            End_If
            inc esi

        .Else
            inc esi

        .End_If
    .End_While


    Mov B$edi EOI
    inc edi

    Mov esi D$CodeSourceA

  ; Copy the other statements to CodeSourceB.
  ; this might be needed to skip first EOI if present.
    If B$esi = EOI
        inc esi
    End_If

    Move D$StatementsPtr D$StatementsTable

    .While esi < ecx
        .If B$esi = TextSign
            Do | movsb | Loop_Until B$esi = TextSign | movsb

        .Else_If B$esi = OpenBracket
            .Do
                If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                End_If
                inc esi
            .Loop_Until B$esi = CloseBracket
            inc esi
            add D$StatementsPtr 4

        .Else_If B$esi = OpenVirtual
            .Do
                If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                End_If
                inc esi
            .Loop_Until B$esi = CloseVirtual
            inc esi
            add D$StatementsPtr 4

        .Else_If B$esi = EOI
            If B$esi-1 = CloseBracket
                ; nop
            Else_If B$esi-1 = CloseVirtual
                ; nop
            Else_If B$esi-1 = EOI
                ; nop
            Else
                Mov eax D$StatementsPtr, eax D$eax
                Mov ebx D$StatementsPtr2
                Mov D$ebx eax

                add D$StatementsPtr 4
                add D$StatementsPtr2 4
            End_If
            movsb

        .Else
            movsb

        .End_If
    .End_While

    Mov ecx edi
    sub ecx D$CodeSourceB
    Mov D$StripLen ecx

    Mov eax D$StatementsPtr2, D$eax 0

    Exchange D$CodeSourceA D$CodeSourceB
    Exchange D$StatementsTable D$StatementsTable2

    Call StripNewlyAddedUnneededEOI
ret
____________________________________________________________________________________________

; called by 'ReorderSource' only. 'StripUnneededEOI' ('HotParsers') is a bit similar.

StripNewlyAddedUnneededEOI:

    Mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = TextSign
            Do | movsb | Loop_Until B$esi = TextSign | movsb

        .Else_If B$esi = EOI
            ..If B$esi+1 = EOI
                inc esi
            ..Else
                movsb
            ..End_If

        .Else
            movsb

        .End_If
    .End_While

    Mov ecx edi | sub ecx D$CodeSourceB | Mov D$StripLen ecx

  ; Write the end mark '||':
    Mov B$edi EOI | inc D$Striplen
    If B$edi-1 <> EOI
        Mov B$edi+1 EOI | inc D$Striplen
    End_If

    Exchange D$CodeSourceA D$CodeSourceB
ret
________________________________________________________________________________________________
____________________________________________________________________________________________

NewPrepareExport:

    Call VirtualFree ExportListAPtr

    Call VirtualFree ExportListBPtr

    Call NewHowManyExport

    If B$ExportsectionWanted = &TRUE

        Call NewStoreToExportListA

        Call NewSortExportListA

    End_If
ret


NewHowManyExport:
    Mov B$ExportsectionWanted &FALSE

    Mov esi D$CodeSourceA, ecx esi, ebx 0, edx 0 | add ecx D$StripLen

    .While esi < ecx
        .If W$esi = '::'
            Mov B$ErrorLevel 9
            If B$esi+2 = ':'
                Mov B$esi-1, EOI, B$esi+3 EOI
                error D$WhatIsThisPtr esi
            End_If
            While B$esi-1 = SPC | Mov B$esi-1 ':' | Mov B$esi+1 SPC |dec esi | End_While ; jE! crack spaces
            While B$esi-1 > SPC | dec esi | End_While
            While B$esi <> ':' | inc esi | inc ebx | End_While
            inc ebx
            inc edx
        .Else_If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign
       ; .Else_If B$esi = '['
       ;     .Do
       ;         If B$esi = TextSign
       ;             Do | inc esi | Loop_Until B$esi = TextSign
       ;         End_If
       ;         inc esi
       ;     .Loop_Until B$esi = ']'
        .End_If
        inc esi
    .End_While

    If edx > 0
        Mov B$ExportsectionWanted &TRUE
        Mov D$NumberOfExportedFunctions edx
        add ebx 40                           ; Header
        add ebx 255                          ; name room
        shl edx 4                            ; pointers > n*16 (*10 would be enough..)
        add ebx edx
        Mov D$ExportSectionLen ebx

        Call VirtualAlloc ExportListAPtr,
                          ebx

        Call VirtualAlloc ExportListBPtr,
                          ebx

    End_If

ret


NewStoreToExportListA:
    Mov esi D$CodeSourceA, edi D$ExportListAPtr
    Mov ecx esi | add ecx D$StripLen

    ..While esi < ecx
        ..If W$esi = '::'
            While B$esi-1 > SPC | dec esi | End_While
            If B$esi = '@'
                Mov B$esi-1 EOI
                While B$esi <> ':' | inc esi | End_While | Mov B$esi+2 EOI
                Mov B$ErrorLevel 9
                Error BadLabel, esi
            End_If
            While B$esi <> ':' | movsb | End_While
            Mov al EOI | stosb

        ..Else_If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign

        ..Else_If B$esi = '['
            .Do
                .If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                .Else_If W$esi = '::'
                    While B$esi-1 > SPC | dec esi | End_While
                    If B$esi = '@'
                        Mov B$esi-1 EOI
                        While B$esi <> ':' | inc esi | End_While | Mov B$esi+2 EOI
                        Mov B$ErrorLevel 9
                        Error BadLabel, esi
                    End_If
                    On B$esi = '[', inc esi
                    While B$esi <> ':' | movsb | End_While | movsb
                    Mov al EOI | stosb
                    Mov B$esi Space
                .End_If
                inc esi
            .Loop_Until B$esi = ']'

        ..End_If
        inc esi
    ..End_While
ret


; EvilBro: I haven't actually rewritten this routine yet.
NewSortExportListA:
    Mov edi D$ExportListBPtr, ecx D$NumberOfExportedFunctions

L0: Push ecx
        Mov esi D$ExportListAPtr, ecx D$NumberOfExportedFunctions, edx 0, bl 0FF

L1:     lodsb
        .If al = 0FF
            ; nop
        .Else_If al < bl
            Mov bl al | lea edx D$esi-1
        .Else_If al = bl
            Push ebx
                Push edx, esi
                    While al = bl
                        lodsb | inc edx | Mov bl B$edx
                        cmp al EOI | je L2>
                    End_While
L2:             Pop esi, edx
                On al < bl, lea edx D$esi-1
            Pop ebx
        .End_If

        While B$esi > EOI
            inc esi
        End_While
        inc esi | loop L1<

        If edx > 0
            Mov esi edx
            While B$esi > EOI
                movsb | Mov B$esi-1 0FF
            End_While
            Mov al EOI | stosb
        End_If

    Pop ecx | dec ecx | cmp ecx 0 | ja L0<<

    Exchange D$ExportListAPtr D$ExportListBPtr
    Mov edi D$ExportListBPtr, eax 0 | stosd | stosd | stosd | stosd | stosd
    Mov eax D$NumberOfExportedFunctions | stosd | stosd
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; This shouldn't be here, but is now for development purposes.

FromDataToStructure:
    Mov D$DisScale 4, D$EquateValue 0

    Call 'USER32.GetDlgItemTextA' D$H.DataToStructureDialog, 10, D$DataTextTable, 01000
    On eax < 10, ret

    Mov B$WeAreInTheCodeBox &TRUE
;    Push D$CodeSource, D$SourceLen, D$SourceEnd
        Mov eax esp,
            D$OldStackPointer eax,
            D$FL.CompileErrorHappend &FALSE

        Mov eax D$DataTextTable
        While B$eax > 0
            inc eax
        End_While
        Mov B$eax CR, B$eax+1 LF | add eax 2
        inc eax

        sub eax D$DataTextTable
        Push eax
            Call GetAsmTables
        Pop eax
        Call NewCopyToCodeSourceA D$DataTextTable, eax ; D$DataTextTableLen

        Call Coolparsers

        Call NewCountStatements

        On D$FL.CompileErrorHappend = &TRUE jmp L9>>

        Call Hotparsers | On D$FL.CompileErrorHappend = &TRUE jmp L9>>


        Mov esi D$CodeSourceA, edi D$StructureTextTable, D$FirstDataLabel 0

        On B$esi = OpenBracket, inc esi
        Mov B$edi '[' | inc edi

L0:     .While B$esi > EOI
            Mov ebx esi
            While B$ebx > LowSigns | inc ebx | End_While
            .If B$ebx = ColonSign
                On D$FirstDataLabel = 0, Mov D$FirstDataLabel esi
                While B$esi <> ColonSign | movsb | End_While
                Mov B$edi SPC | inc edi
                Mov eax D$EquateValue | Call WriteEax
                Mov B$edi CR, B$edi+1 LF, B$edi+2 SPC | add edi 3
            .Else_If B$ebx = MemMarker
                If B$ebx-1 = 'D'
                    Mov D$DisScale 4
                Else_If B$ebx-1 = 'W'
                    Mov D$DisScale 2
                Else_If B$ebx-1 = 'U'
                    Mov D$DisScale 2
                Else_If B$ebx-1 = 'B'
                    Mov D$DisScale 1
                Else_If B$ebx-1 = 'Q'
                    Mov D$DisScale 8
                Else_If B$ebx-1 = 'R'
                    Mov D$DisScale 8
                Else_If B$ebx-1 = 'F'
                    Mov D$DisScale 4
                Else_If B$ebx-1 = 'T'
                    Mov D$DisScale 10
                End_If
            .Else_If B$ebx = NumSign
                inc esi
                If B$esi = '0'
                    Call TranslateHexa
                Else
                    Call TranslateDecimal
                End_If
                mul D$DisScale | sub eax D$DisScale | add D$EquateValue eax | jmp L1>>
            .Else_If B$esi = '?'
                Mov eax D$DisScale | add D$EquateValue eax
            .Else_If B$esi < '0'

            .Else_If B$esi > '9'

            .Else
                Mov eax D$DisScale | add D$EquateValue eax
                While B$esi > LowSigns | inc esi | End_While
            .End_If
            inc esi
L1:     .End_While
        On D$FirstDataLabel = 0, jmp L9>

        inc esi | cmp B$esi EOI | ja L0<<

L2:     Mov B$edi CR, B$edi+1 LF | add edi 2
        Mov esi D$FirstDataLabel
        While B$esi <> ColonSign
            On B$esi = 0, jmp L9>
            movsb
        End_While
        Mov D$edi 'SIZE', B$edi+4 SPC | add edi 5
        Mov eax D$EquateValue | Call WriteEax
        Mov B$edi ']', B$edi+1 0
        Call 'USER32.SetDlgItemTextA' D$H.DataToStructureDialog, 11, D$StructureTextTable

L9:     Call ReleaseAsmTables

;    Pop D$SourceEnd, D$SourceLen, D$CodeSource
    Mov B$WeAreInTheCodeBox &FALSE
ret

____________________________________________________________________________________________

EncodeDecode:
    Mov B$WeAreInTheCodeBox &TRUE
;    Push D$CodeSource, D$SourceLen, D$SourceEnd
      ; ('AsmMain' 'OutOnError')
        Mov D$OldStackPointer esp,
            D$FL.CompileErrorHappend &FALSE

; What on earth is EncodeSource???
        Mov eax EncodeSource ;, D$CodeSource eax
        While B$eax > 0
            inc eax
        End_While
        Mov B$eax CR, B$eax+1 LF | add eax 2
        inc eax

;        Mov D$SourceEnd eax |
[EncodeSourceLen: D$ ?]
        sub eax EncodeSource | Mov D$EncodeSourceLen eax

        Call GetAsmTables
        Call NewCopyToCodeSourceA EncodeSource D$EncodeSourceLen

        Call Coolparsers

        Call NewCountStatements

        Call ClearQwordCheckSum

        On D$FL.CompileErrorHappend = &TRUE jmp L9>>

        Call Hotparsers

        On D$FL.CompileErrorHappend = &TRUE jmp L9>>

        Call InitIndex1 | Call InitIndex2

        Exchange D$CodeSourceA D$CodesourceB
        Push D$SourceLen
            Move D$SourceLen D$EncodeSourceLen
            Move D$AsmTablesLength D$SourceLen
            Call ReuseSourceAForCodeList
        Pop D$SourceLen
        Call InitIndex3

        Call BuildData                          ; result 'CodeSourceB' > 'CodeSourceB'

        On D$FL.CompileErrorHappend = &TRUE jmp L9>>

        Call InitDebugIpTable
        Mov B$ErrorLevel 7                      ; For outOnError, Error

        Call ReCodeLine | On D$FL.CompileErrorHappend = &TRUE jmp L9>>

      ; Prepare Text to show in the Code Hexa view:
        Mov esi D$CodeOrigine, edi HexaCodeText
        While esi < D$CodeListPtr
            movzx eax B$esi | inc esi
            Mov ebx eax | shr ebx 4
            and eax 0F | and ebx 0F
            Mov al B$STR.A.Hexa+eax, bl B$STR.A.Hexa+ebx
            shl eax 8 | or eax ebx | or eax 020200000 | stosd
        End_While
        Mov D$edi 0

      ; Disassemble: (DisMain)
        Mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
        Mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
        Mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE
        Mov esi D$CodeOrigine, edi DecodeText
L0:     movzx eax B$esi | inc esi | Call D$DisOp1+eax*4
        On B$DisFlag = DISDONE, jmp L0<
        Mov D$edi 0

      ; In case of text organisation (sub edi 6, for example), we reset:
        If D$DummyDecodeText+4 <> 0
            Mov eax DecodeText
            While B$eax-1 > 0
                dec eax
            End_While
            Mov ecx DecodeText | sub ecx eax
            Mov esi DecodeText | add esi 160-1 | Mov edi esi | sub esi ecx
            std
L0:             movsb | cmp edi DecodeText | jae L0<
            cld
            Mov D$DummyDecodeText 0, D$DummyDecodeText+4 0
        End_If

L9:     Call ReleaseAsmTables

;    Pop D$SourceEnd, D$SourceLen, D$CodeSource
    Mov B$WeAreInTheCodeBox &FALSE

    Mov D$EncodeSecurity 0 ; Ensure the Buffer never overflows
ret


EncodeError:
L0: Mov ebx, esp | cmp ebx, D$OldStackPointer | jnb L1>
    Pop ebx | jmp L0<
L1: sub esp 8 | Call ErrorMessageBox 0, D$ErrorMessagePtr
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; Some routines I haven't got round to deleting. :)

[StripLen: D$ ?
 TextDelimiter: D$ ?
 TextGoingOn: D$ ?]

IsItFirstText:
    cmp B$TextGoingOn &FALSE | je L1>            ; if OFF > test if ON  needed
L0:   cmp al, B$TextDelimiter | jne L9>         ; if ON  > test if OFF needed
        Jmp L3>
L1: cmp al '"' | je L2>
      cmp al "'" | jne L9>
L2: Mov B$TextDelimiter al
L3: Mov al, TextSign | xor B$TextGoingOn &TRUE
L9: cmp B$TextGoingOn &TRUE
ret

IsItText:                                       ; called by many routines after cleaner
    cmp al, TextSign | jne L9>
L2: xor B$TextGoingOn &TRUE
L9: cmp B$TextGoingOn &TRUE
    ret

[IfItIsText | cmp al TextSign | jne M9>         ; macro a bit faster than 'Call IsIttext'
 M0: stosb | lodsb | cmp al TextSign | jne M0<     ; when it fits
    jmp #1
 M9:]


; same as IsItFirstText, but simplified: no error check, no modification of AL. This
; is for other text ruling routines:
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Alternates      ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
                             Pre-Parser (Alternate syntaxes).
____________________________________________________________________________________________

 None of these routines change the lenght of Data.
 None checks for any Error; Error are holded by downward computations.
;;

AlternatesPreParsers:
    Call BToBS | Call ByteToBS | Call BytePtrToBS | Call ImplicitSize
    Call BracketsToPPBrackets
        Call DbToBS
        Call EqualToEquates | Call EQUToEquates
    Call ReWriteBrackets
ret
____________________________________________________________________________________________


; For Pre-Parser analyzes, we turn '[...]' for Data and Equates into:

[PP_OPEN_DATA 20    PP_CLOSE_DATA 21    PP_OPEN_EQU 22    PP_CLOSE_EQU 23]

BracketsToPPBrackets:
    Mov esi D$CodeSourceA, edx D$StripLen, cl 0 | add edx esi

    .While esi < edx
        lodsb
        .If al = ';'
            While al <> LF
                lodsb | cmp esi edx | ja L9>>
            End_While
        .Else_If al = "'"
            Do
                lodsb | cmp esi edx | ja L9>>
            Loop_Until al = "'"
        .Else_If al = '"'
            Do
                lodsb | cmp esi edx | ja L9>>
            Loop_Until al = '"'
        .Else_If al = '['
            Mov ebx esi
            While B$ebx = SPC
                inc ebx                         ; jump over possible leading spaces
            End_While
            While B$ebx > SPC
                inc ebx                         ; go to end of first word
            End_While
            If B$ebx-1 = ':'
L1:            Mov B$esi-1 PP_OPEN_DATA         ; <<<<<<<<<<<<<<<<<<<<<<
                Mov cl PP_OPEN_DATA

            Else   ; ( B$ebx = SPC )
                While B$ebx = SPC
                    inc ebx                     ; Verify no [Symbol : (>Data) // CR/| (>Macro)
                End_While
                On B$ebx = ':', jmp L1<
                On B$ebx = CR, jmp L3>
                On B$ebx = '|', jmp L3>
                    Mov B$esi-1 PP_OPEN_EQU     ; <<<<<<<<<<<<<<<<<<<<<<
                    Mov cl PP_OPEN_EQU

          ;  Else_If B$ebx = CR // '|'
L3:            ; case of Macro (not used actually here...).
            End_If

        .Else_If al = ']'
            If cl = PP_OPEN_DATA
                Mov B$esi-1 PP_CLOSE_DATA
            Else_If cl = PP_OPEN_EQU
                Mov B$esi-1 PP_CLOSE_EQU
            End_If
            Mov cl 0
        .End_If

    .End_While
L9: ret


; Turns "DD / DW / DB"   into:   "D$ / W$ / B$":

DbToBS:
    Mov edi D$CodeSourceA, ecx D$StripLen

        Mov al PPOPENDATA, bl PPCLOSEDATA

L3:     repne scasb
        .If ecx > 0
            Push eax
                .While B$edi <> bl
                    Mov eax D$edi | or eax 020202020
                    If B$edi = '"'
L1:                     inc edi | dec ecx | jz L7>>
                        cmp B$edi '"' | jne L1<
                    Else_If B$edi = "'"
L1:                     inc edi | dec ecx | jz L7>>
                        cmp B$edi "'" | jne L1<
                    Else_If eax = ' dd '
                        Mov D$edi ' D$ '
                    Else_If eax = ' db '
                        Mov D$edi ' B$ '
                    Else_If eax = ' dw '
                        Mov D$edi ' W$ '
                    Else_If eax = ' dq '
                        Mov D$edi ' Q$ '
                    Else_If eax = ' dr '
                        Mov D$edi ' R$ '
                    Else_If eax = ' df '
                        Mov D$edi ' F$ '
                    Else_If eax = ' dt '
                        Mov D$edi ' T$ '
                    End_If
                    inc edi | dec ecx | jz L7>
                .End_While
L7:         Pop eax
        .End_If

        cmp ecx 0 | ja L3<<
ret


; Replaces:  "One EQU 1"   by:   "One     1":

EQUToEquates:
    Mov edi D$CodeSourceA, ecx D$StripLen

        Mov al PPOPENEQU, bl PPCLOSEEQU

L3:     repne scasb
        .If ecx > 0
            Push eax
                While B$edi <> bl
                    Mov eax D$edi | or eax 020202020
                    If B$edi = '"'
L1:                     inc edi | dec ecx | jz L7>
                        cmp B$edi '"' | jne L1<
                    Else_If B$edi = "'"
L1:                     inc edi | dec ecx | jz L7>
                        cmp B$edi "'" | jne L1<
                    Else_If eax = ' equ'
                        Mov al B$edi+4 | or al SPC
                        On al = SPC, Mov D$edi '    '
                    End_If
                    inc edi | dec ecx | jz L7>
                End_While
L7:         Pop eax
        .End_If

        cmp ecx 0 | ja L3<
ret


; Replaces:  "One = 1"   by:   "One   1":

EqualToEquates:
    Mov edi D$CodeSourceA, ecx D$StripLen

        Mov al PPOPENEQU, bl PPCLOSEEQU

L3:     repne scasb
        ...If ecx > 0
            Push eax
                While B$edi <> bl
                    ..If B$edi = '"'
L1:                     inc edi | dec ecx | jz L7>
                        cmp B$edi '"' | jne L1<
                    ..Else_If B$edi = "'"
L1:                     inc edi | dec ecx | jz L7>
                        cmp B$edi "'" | jne L1<
                    ..Else_If B$edi = '='
                        .If B$edi-1 = SPC
                            If B$edi+1 = SPC
                                Mov B$edi SPC
                            End_If
                        .End_If
                    ..End_If
                    inc edi | dec ecx | jz L7>
                End_While
L7:         Pop eax
        ...End_If

        cmp ecx 0 | ja L3<
ret


; Simple replace of 'Byte Ptr[Value]' by:
;                   'B$       Value '

BytePtrToBS:
    Mov esi D$CodeSourceA | Mov ecx esi | add ecx D$StripLen

    .While esi < ecx
        Push esi

        Mov eax D$esi, bl B$esi+4 | or eax 020202020 | or bl SPC

        ...If B$esi = '"'
            Pop eax
L1:         inc esi | cmp B$esi '"' | jne L1<
            Push esi
        ...Else_If B$esi = "'"
            Pop eax
L1:         inc esi | cmp B$esi "'" | jne L1<
            Push esi
        ...Else_If eax = 'byte'
            Mov dx 'B$', ebx 0 | jmp L1>>
        ...Else_If eax = 'dwor'
            If bl = 'd'
                Mov dx 'D$', ebx 1 | jmp L1>>
            End_If
        ...Else_If eax = 'word'
            Mov dx 'W$', ebx 0 | jmp L1>>
        ...Else_If eax = 'qwor'
            If bl = 'd'
                Mov dx 'Q$', ebx 1 | jmp L1>>
            End_If
        ...Else_If eax = 'real'
            Mov dx 'R$', ebx 0 | jmp L1>>
        ...Else_If eax = 'floa'
            If bl = 't'
                Mov dx 'F$', ebx 1 | jmp L1>>
            End_If
        ...Else_If eax = 'tbyt'
            If bl = 'e'
                Mov dx 'T$', ebx 1 | jmp L1>
            End_If
        ...Else_If eax = 'twor'
            If bl = 'd'
                Mov dx 'T$', ebx 1 | jmp L1>
            End_If
        ...Else_If eax = 'owor'
            If bl = 'd'
                Mov dx 'O$', ebx 1 | jmp L1>
            End_If
        ...Else_If eax = 'xwor'
            If bl = 'd'
                Mov dx 'X$', ebx 1 | jmp L1>
            End_If

L1:         ..If B$esi-1 = SPC
                jmp L1>
            ..Else_If B$esi-1 = ','
                jmp L1>
            ..Else
                jmp L7>>
            ..End_If

L1:         Mov eax esi | add esi 4 | add esi ebx

L2:         ..If B$esi = SPC
                While B$esi = SPC
                    inc esi | On esi > ecx, jmp L7>>
                End_While
                dec esi
                Mov ebx D$esi | or ebx 020202020
                .If ebx = ' ptr'
                    add esi 4
                    While B$esi = SPC
                        inc esi | On esi > ecx, jmp L7>>
                    End_While
                    If B$esi = '['
                        Mov W$eax dx | add eax 2
                        While B$eax <> '['
                            Mov B$eax SPC | inc eax | On B$eax = 13, jmp L7>
                        End_While
                        Mov B$eax SPC
                        While B$eax <> ']'
                            inc eax | On B$eax = 13, jmp L7>
                        End_While
                        Mov B$eax SPC
                    End_If
                .End_If
            ..End_If
        ...End_If
L7:     Pop esi
        inc esi
    .End_While
ret


; Simple replace of 'Byte [Value]' by:
;                   'B$    Value '

ByteToBS:
    Mov esi D$CodeSourceA | Mov ecx esi | add ecx D$StripLen

    .While esi < ecx
        Push esi
        Mov eax D$esi, bl B$esi+4 | or eax 020202020 | or bl SPC
        ...If B$esi = '"'
            Pop eax
L1:         inc esi | cmp B$esi '"' | jne L1<
            Push esi
        ...Else_If B$esi = "'"
            Pop eax
L1:         inc esi | cmp B$esi "'" | jne L1<
            Push esi
        ...Else_If eax = 'byte'
            Mov dx 'B$', ebx 0 | jmp L1>>
        ...Else_If eax = 'dwor'
            If bl = 'd'
                Mov dx 'D$', ebx 1 | jmp L1>>
            End_If
        ...Else_If eax = 'word'
            Mov dx 'W$', ebx 0 | jmp L1>>
        ...Else_If eax = 'qwor'
            If bl = 'd'
                Mov dx 'D$', ebx 1 | jmp L1>>
            End_If
        ...Else_If eax = 'real'
            Mov dx 'R$', ebx 0 | jmp L1>>
        ...Else_If eax = 'floa'
            If bl = 't'
                Mov dx 'F$', ebx 1 | jmp L1>>
            End_If
        ...Else_If eax = 'tbyt'
            If bl = 'e'
                Mov dx 'T$', ebx 1 | jmp L1>
            End_If
        ...Else_If eax = 'twor'
            If bl = 'd'
                Mov dx 'T$', ebx 1 | jmp L1>
            End_If
        ...Else_If eax = 'owor'
            If bl = 'd'
                Mov dx 'O$', ebx 1 | jmp L1>
            End_If
        ...Else_If eax = 'xwor'
            If bl = 'd'
                Mov dx 'X$', ebx 1 | jmp L1>
            End_If

L1:         ..If B$esi-1 = SPC
                jmp L1>
            ..Else_If B$esi-1 = ','

L1:             Mov eax esi | add esi 4 | add esi ebx

                While B$esi = SPC
                    inc esi | On esi > ecx, jmp L7>>
                End_While
                .If B$esi = '['
                    Mov W$eax dx | add eax 2
                    While B$eax <> '['
                        Mov B$eax SPC | inc eax | On B$eax = 13, jmp L7>
                    End_While
                    Mov B$eax SPC
                    While B$eax <> ']'
                        inc eax | On B$eax = 13, jmp L7>
                    End_While
                    Mov B$eax SPC
                .End_If
            ..End_If
        ...End_If
L7:     Pop esi
        inc esi
    .End_While
ret


[ImplicitReg: D$ ? ?
 EndOfImplicitReg: D$ ?]

; Replaces  Mov eax [ebx]  by  Mov eax D$ebx. It never changes the Source size because
; "Mov eax [ebx]"  and  "Mov eax D$ebx" are same text length.

ImplicitSize:
    Mov esi D$CodeSourceA, edi D$CodeSourceB | Mov ecx esi | add ecx D$StripLen

L0: .While esi < ecx

        ...If B$esi = '"'
L1:         movsb | cmp B$esi '"' | jne L1<
            movsb
        ...Else_If B$esi = "'"
L1:         movsb | cmp B$esi "'" | jne L1<
            movsb
        ...Else_If B$esi = '['
            Mov ebx esi | dec ebx
            ..If B$ebx = SPC
                jmp L1>
            ..Else_If B$ebx = ','

L1:             dec ebx | cmp B$ebx SPC | je L1<
                          cmp B$ebx ',' | je L1<
                Mov B$OneOperandwBit 0FF
                .If B$ebx > SPC                             ; Mov eax [ebx]
                    dec ebx
                    While B$ebx > SPC
                        dec ebx                             ; Search start of 'eax'
                    End_While
                    On B$ebx <> SPC, jmp L3>
                        inc ebx
                        pushad
                            Mov esi ebx, edi ImplicitReg
                            While B$esi > SPC
                                lodsb | and al 00_1101_1111 | stosb               ; upper case
                                On edi = EndOfImplicitReg, jmp L2>
                            End_While                                             ; wanted for
                            Mov B$edi Space | Mov esi ImplicitReg | Call IsItaReg ; IsItaReg
L2:                     popad

                        cmp B$OneOperandwBit 0FF | jne L4>
                      ; Case of "Mov [ebx] eax":
L3:                         While B$ebx <> ']'
                                inc ebx | On B$ebx = CR, jmp L7>>
                            End_While
                            inc ebx | On B$ebx <> SPC, jmp L7>>
                            While B$ebx = SPC
                                inc ebx
                            End_While
                            pushad
                                Mov esi ebx, edi ImplicitReg
                                While B$esi > SPC
                                    lodsb | and al 00_1101_1111 | stosb               ; upper case
                                    On edi = EndOfImplicitReg, jmp L2>
                                End_While                                             ; wanted for
                                Mov B$edi Space | Mov esi ImplicitReg | Call IsItaReg ; IsItaReg
L2:                         popad

                        cmp B$OneOperandwBit 0FF | je L7>
L4:                     cmp B$OneOperandwBit BYTE_SIZE | jne L4>
                            Mov ax 'B$' | stosw | jmp L5>
L4:                     cmp B$OneOperandwBit WORD_SIZE | jne L4>
                            Mov ax 'W$' | stosw | jmp L5>
L4:                     cmp B$OneOperandwBit DWORD_SIZE | jne L7>
                            Mov ax 'D$' | stosw

L5:                     inc esi
L5:                     cmp B$esi ']' | je L6>
                        cmp B$esi 14 | jb L7>
                            movsb | jmp L5<
L6:                         inc esi | jmp L0<<
L7:                     movsb

                .Else
                    movsb

                .End_If

             ..Else
                  movsb

             ..End_If

         ...Else
            movsb

         ...End_If
     .End_While

    Exchange D$CodeSourceA D$CodeSourceB
ret


; Simple replace of 'B[Value]' by:
;                   'B$Value '
;                   'B [Value]' >>>

BToBS:
    Mov esi D$CodeSourceA | Mov ecx esi | add ecx D$StripLen

    .While esi < ecx
        ...If B$esi = '"'
L1:         inc esi | cmp B$esi '"' | jne L1<
        ...Else_If B$esi = "'"
L1:         inc esi | cmp B$esi "'" | jne L1<
        ...Else_If B$esi = '['
            Mov ebx esi | dec ebx
            While B$ebx = SPC
                dec ebx
            End_While
            ..If B$ebx-1 = SPC
                jmp L1>
            ..Else_If B$ebx-1 = ','
L1:             Mov al B$ebx | or al SPC
                .If al = 'd'
                    jmp L2>>
                .Else_If al = 'b'
                    jmp L2>>
                .Else_If al = 'w'
                    jmp L2>>
                .Else_If al = 'b'
                    jmp L2>
                .Else_If al = 'q'
                    jmp L2>
                .Else_If al = 'r'
                    jmp L2>
                .Else_If al = 'f'
                    jmp L2>
                .Else_If al = 't'
                    jmp L2>
                .Else_If al = 'o'
                    jmp L2>
                .Else_If al = 'x'
L2:                 inc ebx
                    If B$ebx = '['
                        Mov B$ebx '$'
                    Else
                        Mov B$ebx '$'
                        While B$ebx <> '['
                            inc ebx
                        End_While
                        Mov B$ebx SPC
                    End_If
                    While B$ebx <> ']'
                        inc ebx | On B$ebx = 13, jmp L7>
                    End_While
                    Mov B$ebx SPC
                .End_If
            ..End_If
        ...End_If
L7:     inc esi
    .End_While
ret


; Last routine:

ReWriteBrackets:
    Mov esi D$CodeSourceA | Mov ecx esi | add ecx D$StripLen
    Mov ebx 0
    .While esi < ecx
        Mov al B$esi
        If al = PP_OPEN_DATA
            Mov B$esi '['
        Else_If al = PP_CLOSE_DATA
            Mov B$esi ']'
        Else_If al = PP_OPEN_EQU
            Mov B$esi '['
        Else_If al = PP_CLOSE_EQU
            Mov B$esi ']'
        End_If
        inc esi
    .End_While
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Assembler       ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;

  'EncodeLines' 'NewSearchApiName'
____________________________________________________________________________________________
____________________________________________________________________________________________

 This part holds the various Routines envolved in the general Assembly process. No
 overall description can be given for them. The simpler way to understand the Assembler
 organisation is to start at 'AsmMain', and to follow up with Right-Click.

 At a TITLE point of vue, the Assembler is dispatched into 4 TITLEs:
 
 [Parsers] / [Assembler] / [AsmMain] / [Encoder]


 Just a quick description:
 
 Encodage of an instruction is done in 4 steps.

 In the first one, parameters are analyzed by '...ParameterAnalyze's routines. They
 tell us how many parameters, what kind of parameter each and if they are 'complex'
 (for exemple if SIB is needed); all needed variables and flags are set.

 In 'Encode', (second step) we do nothing else than 'routing' the more stupid way
 according with mnemonics and parameters. I did this this way to give the easiest
 access for new mnemonics adding. Killing to write but blazing fast and simple to
 maintain.

 When jumping out 'Encode', a third party performs ending fitting controls and writes
 true code in CodeList. This is this collection of small routines which names discribe
 the critical Intel significants like 'op_op_modReg2Rm_imm8'. I cut encodage itself
 in second and third steps just to make source shorter but these two steps are, in fact,
 one and same operation.

 At the very end of assembly job, a 'FillSymbol' routine fullfills the zeroed part of
 code with whished labels' adresses, either absolute or relative (at coding time these
 values may be unknown, and we work one pass. RosAsm is, as far as i know, the only
 one assembler that do it this way, with respect of user defined sizes).
____________________________________________________________________________________________
____________________________________________________________________________________________
;;

[LinkerDllDefault: D$ 0_1000_0000]

[FL.RelocsWanted: D$ ?]
; some basic equates:
                        ; As concerned tables have 3 dwords per pointed resource
                        ; Allow 100
[MAXDIALOG      1200    ; Dialogs
 MAXMENU        1200    ; Menus
 MAXBITMAP      1200    ; BitMaps
 MAXSTRINGS     1200    ; ...
 MAXFONT        1200
 MAXWAVE        1200
 MAXAVI         1200
 MAXRCDATA      1200
 MAXCURSOR      1200
 MAXICON        1200

 MAXRESOURCE    3500    ; Allow, as a whole, 1000 different resources in one PE

 LINKERDEFAULT  0_40_0000
 DRIVERDEFAULT  0_1_0000

 PAGE_SIZE      0_1000
 PAGE_MASK      0_FFFF_F000
 DWORD_HIGH_BIT 0_8000_0000

 ; For Encoding of reg field
 REG_EAX    00_0000
 REG_AX     00_0000
 REG_AL     00_0000
 REG_ECX    00_0001
 REG_CX     00_0001
 REG_CL     00_0001
 REG_EDX    00_0010
 REG_DX     00_0010
 REG_DL     00_0010
 REG_EBX    00_0011
 REG_BX     00_0011
 REG_BL     00_0011
 REG_ESP    00_0100
 REG_SP     00_0100
 REG_AH     00_0100
 REG_EBP    00_0101
 REG_BP     00_0101
 REG_CH     00_0101
 REG_ESI    00_0110
 REG_SI     00_0110
 REG_DH     00_0110
 REG_EDI    00_0111
 REG_DI     00_0111
 REG_BH     00_0111

 ; For Encoding of the Segment Register (sreg) Field
 REG_ES     00_00_0000
 REG_CS     00_00_1000
 REG_SS     00_01_0000
 REG_DS     00_01_1000
 REG_FS     00_10_0000
 REG_GS     00_10_1000

 ; For Encoding of Special-Purpose Register (eee) Field
 ; (Control Registers and Debug Registers cannot be used in applications. There need
 ; privilege 0 and are for system - not implemented in 'Encode:' Mov to/from Debug/Control
 ; registers))
 REG_CR0    00_0000
 REG_CR2    00_0010
 REG_CR3    00_0011
 REG_CR4    00_0100
 REG_DR0    00_0000
 REG_DR1    00_0001
 REG_DR2    00_0010
 REG_DR3    00_0011
 REG_DR6    00_0110
 REG_DR7    00_0111

 ; For encoding of FPU regs
 REG_ST0 0
 REG_ST1 1
 REG_ST2 2
 REG_ST3 3
 REG_ST4 4
 REG_ST5 5
 REG_ST6 6
 REG_ST7 7

 ; For encoding of MMX registers
 REG_MM0 0
 REG_MM1 1
 REG_MM2 2
 REG_MM3 3
 REG_MM4 4
 REG_MM5 5
 REG_MM6 6
 REG_MM7 7

 ; For Encoding of Operand Size (w) Bit
 BYTE_SIZE  00_00000000  ; True wBit, when encoding, can only be 0 (byte size) or
 WORD_SIZE  00_00000011  ; 1 (full size). Word / Double size discrimination
 DWORD_SIZE 00_00000001  ; Will be done by Operand-size override (066 if bit 2 set)
 QWORD_SIZE 00_00000100  ; FPU
 TBYTE_SIZE 00_00001000  ; FPU
; BCD_SIZE   00_00001111  ; Packed BCD
; FPU_SIZE   00_00001010  ; 108 bytes of FPU image > now X$ !!!!!
 OWORD_SIZE 00_00010000  ; XMM memories
 USO_SIZE   00_11111111  ; Fitting with specific Unregular Size Opcodes

;;
 
    Following are to fill 'Operands', which is a global image of what operands in a line.
    In some unregular cases, AL, AX and EAX may have specific encodage we can't' guess
    while analysing parameters. having symbols in order allow tests like:
    cmp Operands, REG_TO_MEM | ja >L1    instead of:
    cmp operands, REG_TO_MEM | je >L1    which solves this problem in case of no use of
    possible Areg by an instruction encodage.

;;

 REG_TO_REG  1
 MEM_TO_REG  2
 REG_TO_MEM  3
 IMM_TO_REG  4
 IMM_TO_MEM  5
 REG_TO_IMM  6    ; OUT imm8 accum
 IMM_TO_IMM  7    ; ENTER and OUT
 ;  MEM_TO_MEM  8  ; for FPU ???

 GENERAL_REG  1   ; General registers
 SEGMENT_REG  2   ; Segment register
 CONTROL_REG  3   ; Control registers
 DEBUG_REG    4   ; Debug registers
 IMM_VALUE    5   ; Immediate values
 MEM_LABEL    6   ; Memory symbolic adresses (.$ Labels)
 DISPLACEMENT 7
 REG_FPU      8   ; FPU regs
 REG_MMX      9   ; MMX regs
 REG_XMM     10   ; XMM regs


 BYTE_MEM    'B' ; Byte sized memory
 UNICODE_MEM 'U' ; Unicode string
 WORD_MEM    'W' ; Word size memory
 DWORD_MEM   'D' ; Dword size memory
 QWORD_MEM   'Q' ; Qword bytes size memory
 REEL_MEM    'R' ; Reel 8 bytes size for FPU real numbers
 TBYTE_MEM   'T' ; Ten bytes size  for FPU real numbers
 REEL2_MEM   'H' ; Height bytes size for FPU real numbers (to keep a while....)
 FLOAT_MEM   'F' ; Four bytes size for FPU real numbers
 OWORD_MEM   'O' ; OctoWords XMM sizes
 XWORD_MEM   'X' ; Weird and XMM sizes

 ; Where to jump:
 JMP_DOWN_LONG  00_1000 ; ja L9>>
 JMP_DOWN_SHORT 00_0100 ; jmp L7>
 JMP_UP_LONG    00_0010 ; jz L0<<
 JMP_UP_SHORT   00_0001 ; loop L5<

]
;;
 ; Labels flags:
 FLAG_CODE_LABEL 00_0100
 FLAG_DATA_LABEL 00_0010
 FLAG_DONE       00_0001]
;;


; Labels flags:

[FLAG_CODE_LABEL 00_0100
 FLAG_DATA_LABEL 00_0010
 FLAG_DONE      00_0001]

____________________________________________________________________________________________
____________________________________________________________________________________________

; Main asm memories:

[AsmTablesLength: D$ ?]

GetAsmTables:
    ;VirtualFree D$NewWinEquatesMem

    Call VirtualFree IpTable

    Call VirtualFree StatementsTable

    Call VirtualFree StatementsTable2

    Call VirtualFree PlainLabelList

    Call VirtualFree EquateList

    Call VirtualFree MacroData

    Call GetResourcesSize

    add eax D$SourceLen | add eax 1_000_000 | add eax D$MemReservation

    Mov D$AsmTablesLength eax

    Call VirtualAlloc CodeSourceA,
                      eax

    add D$CodeSourceA 010

    ;Mov eax D$SourceLen | add eax 1_000_000 | add eax D$MemReservation
    Call VirtualAlloc CodeSourceB,
                      D$AsmTablesLength

    add D$CodeSourceB 010

ret


GetResourcesSize:

    xor eax eax

    Mov edx CursorList | Call AddResourcesSyze

    Mov edx GroupCursorList | Call AddResourcesSyze

    Mov edx IconList | Call AddResourcesSyze

    Mov edx MenuList | Call AddResourcesSyze

    Mov edx DialogList | Call AddResourcesSyze

    Mov edx StringsList | Call AddResourcesSyze

    Mov edx GroupIconList | Call AddResourcesSyze

    Mov edx WaveList | Call AddResourcesSyze

    Mov edx AviList | Call AddResourcesSyze

    Mov edx RCdataList | Call AddResourcesSyze

    Mov edx BitMapList | Call AddResourcesSyze

ret

AddResourcesSyze:

    While D$edx <> &NULL

        add eax D$edx+MEM_MOTHER_LP

        add edx MEM_RECORD

    End_While

ret


; clear memory (CodeList now is a reuse of CodeSourceB):

ReleaseAsmTables:

    Call VirtualFree CodeSourceA

    Call VirtualFree CodeSourceB

    Call VirtualFree LabelList

    Call VirtualFree MacroList

    Call VirtualFree CodeRef

    Call VirtualFree DataRef

    Call VirtualFree Relocation

    Call VirtualFree ApiListA

    Call VirtualFree ApiListB

    Call VirtualFree DllList

    Mov D$CookedErrorMessage 0

    If B$ProfilerFlag = &TRUE

        Call ReleaseProfilerTables

        Mov B$ProfilerFlag &FALSE

    End_If

ret


ReleaseMainFile:

    Call VirtualFree UserPeStart

    Mov D$CodeSource &NULL

ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; Files access:
____________________________________________________________________________________________
____________________________________________________________________________________________

[STRUC.OPENFILENAME:
 @lStructSize: D$ len
 @hwndOwner: D$ 0
 @hInstance: D$ 0
 @lpstrFilter: D$ PEFilesFilters
 @lpstrCustomFilter: D$ uFileFilter
 @nMaxCustFilter: D$ &MAX_PATH
 @nFilterIndex: D$ 1
 @lpstrFile: D$ SaveFilter
 @nMaxFile: D$ &MAX_PATH
 @lpstrFileTitle: D$ ChoosenFile
 @nMaxFileTitle: D$ &MAX_PATH
 @lpstrInitialDir: D$ &NULL
 @lpstrTitle: D$ 0 ;OpenPEFileTitle
 @Flags: D$ &OFN_LONGNAMES+&OFN_EXPLORER+&OFN_FILEMUSTEXIST+&OFN_PATHMUSTEXIST+&OFN_HIDEREADONLY
 @nFileOffset: W$ 0
 @nFileExtension: W$ 0
 @lpstrDefExt: D$ 0
 @lCustData: D$ 0
 @lpfnHook: D$ 0
 @lpTemplateName: D$ 0]
; @pvReserved: D$ 0
; @dwReserved: D$ 0
; @FlagsEx: D$ 0]


[PEFilesFilters:
 B$ 'Files (*.exe, *.dll, *.wll, *.ocx, *.drv, *.bpl, *.cpl, *.fon, *.mpd, *.vbx, *.vxd, *.sys)' EOS
 B$ '*.exe;*.dll;*.wll;*.ocx;*.drv;*.bpl;*.cpl;*.fon;*.mpd;*.vbx;*.vxd;*.sys' EOS
 B$ 'Executable Files (*.exe)' EOS
 B$ '*.exe' EOS
 B$ 'Dll Files (*.dll, *.wll)' EOS
 B$ '*.dll;*.wll' EOS
 B$ 'Delphi Dll Files (*.bpl)' EOS
 B$ '*.bpl' EOS
 B$ 'Ocx Files (*.ocx)' EOS
 B$ '*.ocx' EOS
 B$ 'Driver Files (*.drv)' EOS
 B$ '*.drv' EOS
 B$ 'Cpl Files (*.cpl)' EOS
 B$ '*.cpl' EOS
 B$ 'fon Files(*.fon)' EOS
 B$ '*.fon' EOS
 B$ 'mpd Files(*.mpd)' EOS
 B$ '*.mpd' EOS
 B$ 'vbx Files(*.ocx)' EOS
 B$ '*.ocx' EOS
 B$ 'vbx Files(*.vbx)' EOS
 B$ '*.vbx' EOS
 B$ 'vxd Files(*.vxd)' EOS
 B$ '*.vxd' EOS
 B$ 'sys Files(*.sys)' EOS
 B$ '*.sys' EOS
 B$ 'All Files' EOS
 B$  '*.*' EOS 0]


; 'Open File Name' Box:

[uFileFilter: B$ ? # &MAX_PATH]
[SaveFilter: B$ ? # &MAX_PATH]
[ChoosenFile: B$ ? # &MAX_PATH]

;[OpenFileTitle: B$ 'Choose a file...' EOS]

[UserPeStart: D$ ?
 UserPeLen: D$ ?
 UserPeEnd: D$ ?]

[H.Source: D$ ?
 SourceLen: D$ ?
 H.Destination: D$ ?

 NumberOfReadBytes: D$ ?]

;[SourceFile: B$ 'Src.b' EOS]  ;;  DestinationFile: 'Dest2.exe' EOS, '                       ']

; All the second ? in lists declarations are for mem size. We need it for 'VirtualFree'

[CodeSource: D$ ? ?
 CodeSourceA: D$ ? ?
 CodeSourceB: D$ ? ?]

;;
  Beware: 'CodeSource' is *not* the Memory Chunk Pointer. 'CodeSource' is a Pointer to
  the Source inside 'UserPeStart'. See, for example 'ReleaseMainFile'.
  
  For a direct Allocation/Re-Allocation, it must be, for example:
  > VirtualAlloc UserPeStart 1_000_000 | Move D$CodeSource D$UserPeStart
  
  The only case 'CodeSource' is a real Memory Chunk is while disassembling. The switch
  between the two pointer, with the wished release, is done when the Disassembly is 
  finished.
;;

[InstructionAptr: D$ ?
 InstructionBptr: D$ ?]

;;
  'MacroList': |NAME|dWord1 dWord2 Byte|
  
  dWord1: Ptr to MacroData // dWord2: Lenght of these Data // Byte: Done Flag
;;

[EquateList: D$ ? ?
 MacroData: D$ ? ?
 MacroList: D$ ? ?
 Relocation: D$ ? ?
 DataList: D$ ? ?
 LabelList: D$ ? ?
 CodeList: D$ ? ?
 Coderef: D$ ? ?
 DataRef: D$ ? ?
 DllList: D$ ? ?
 ApiListA: D$ ? ?
 ApiListB: D$ ? ?]

; 'CodeRef' is: Dword | ... //... | Name | Dword1 dWord2 | // ....       ; 'CodeRefPtr'
;               ....|LabelName|........|LabelName|........|
; Where dWord is the Table Size.
; In the Records, Dword1 is a Pointer to CodeList and dWord2 a Pointer to Source.

; 'LabelList' is: Dword | ... // ...| Name | Dword1 Byte | // ....
; Where dWord is the Table Size.
; In the Records, Dword1 is the Pointer to CodeList, and Byte can be either/or:
; [FLAG_CODE_LABEL] [FLAG_DATA_LABEL] [FLAG_DONE]

[DataRefLimit: D$ ?
 EquateListLimit: D$ ?
 MacroListLimit: D$ ?
 MacroDataLimit: D$ ?
 LabelListLimit: D$ ?]

[EquateListPtr: D$ ?
 MacroDataPtr: D$ ?
 MacroListPtr: D$ ?
 RelocationPtr: D$ ?
 DataListPtr: D$ ?
 DataListPtrAtLastColon: D$ ?
 LabelListPtr: D$ ?
 CodeListPtr: D$ ?
 CoderefPtr: D$ ?
 DataRefPtr: D$ ?
 DllListPtr: D$ ?
 ApiListAPtr: D$ ?
 ApiListBPtr: D$ ?]

[LenOfCode: D$ ?
 FL.SourceReady: D$ ?
 FL.OldSourceReady: D$ ?]

;[SourceFilterPtr: D$ 1]
[OpenSourceFileTitle: B$ 'Choose main asm file...' EOS]
;[OpenPEFileTitle: B$ 'Choose main BUA PE file...' EOS]
[ChangeNameTitle: B$ 'Change the PE File Name...' EOS]
[SaveDlgNameTitle: B$ 'Give the Dialog Template File Name' EOS]

[ SourceFilesFilters:
  B$ 'Sources' EOS
  B$ '*.asm' EOS
  B$ 'All' EOS
  B$ '*.*' EOS 0]

 ;[PEFilesFilters: B$ 'RosAsm PE'     0  '*.exe;*.scr;*.dll' EOS 0]


[OpenSourceStruc:
 D$ len
 hwndFileOwner: D$ 0
 OSSInstance: D$ 0
 SourceFilesFilters
 uFileFilter
 260
 1
 SaveFilter
 260
 ChoosenFile
 260
 0                                ; SaveFilter:  full Path/Name.ext
                                  ; ChoosenFile: only Name.ext
 OpenSourceFileTitle
 D$ &OFN_LONGNAMES+&OFN_EXPLORER+&OFN_FILEMUSTEXIST+&OFN_PATHMUSTEXIST+&OFN_HIDEREADONLY
 0
 0
 0
 0
 0]

____________________________________________________________________________________________

SetBUAWindowText:

    Push esi,
         edi

    Mov esi STR.A.ApplicationName,
        edi STR.A.Trash

L1: movsb

    Test B$esi 0_FF NOT_ZERO L1<

S1: Mov eax '    ' | stosd

    Mov esi SaveFilter

L2: movsb

    Test B$esi 0_FF NOT_ZERO L2<

    Call 'USER32.SetWindowTextA' D$H.MainWindow,
                                 STR.A.Trash

    Pop edi,
        esi

ret

;;

  CreateFile is called by 'LoadSrc' 'ReplaceSourceOnly' 'OpenBUAsmPE',
                          'DirectMRUload', 'DirectLoad', 'LastMRULoading',
                          'ReloadForDissassembler'

;;

CreateSourceFile:

    On D$H.Source > 0 Call 'KERNEL32.CloseHandle' D$H.Source

    Call 'KERNEL32.CreateFileA' SaveFilter,
                                &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE,
                                0,
                                &OPEN_EXISTING,
                                &FILE_ATTRIBUTE_NORMAL,
                                &NULL

    Comp eax &INVALID_HANDLE_VALUE = S1>

        Mov D$H.Source eax

        Call 'KERNEL32.GetFileSize' eax,
                                    0

        Mov D$SourceLen eax

ret

S1: Call MessageBox D$BusyFileptr

    mov eax &INVALID_HANDLE_VALUE

ret
 _______________________________

; Opening file:

Proc ClearPATH:

    Argument @STR.A.PATH

    Uses edi

    Mov ecx (&MAX_PATH/DWORD),
        edi D@STR.A.PATH

    xor eax eax | rep stosd

EndP


LoadSourceFile:

    ; Eax = D$SourceLen sinon &INVALID_HANDLE_VALUE
    Call CreateSourceFile

    Comp eax &INVALID_HANDLE_VALUE <> S1>

ret

S1: add eax 1_000_000  ; !!! TODO pas très clair ni très propre !!! -> TITLE_MAX ?!? pas sûr...

    Call VirtualAlloc UserPeStart,
                      eax

    Move D$CodeSource D$UserPeStart

    add eax D$UserPeStart | AlignOn PAGE_SIZE eax | sub eax 32

    Mov D$EndOfSourceMemory eax

    Push edi

        Mov edi D$CodeSource,
            ax CRLF,
            ecx 5

        rep stosw

        Mov eax edi       ; security for back test like ESI or EDI - 2 (sys page fault)

    Mov D$CodeSource eax

    Call 'KERNEL32.ReadFile' D$H.Source,
                             eax,                ; eax = mem buffer start
                             D$SourceLen,
                             NumberOfReadBytes,
                             &NULL

    Call 'KERNEL32.CloseHandle' D$H.Source

    Mov D$H.Source &NULL

    Mov edi D$CodeSource | add edi D$SourceLen | Mov eax CRLF2, ecx 100 | rep stosd
    Mov edi D$CodeSource, ecx 5 | sub edi 10 | rep stosw
    Mov eax D$CodeSource | add eax D$SourceLen | Mov D$STRUCT.EditData@SourceEnd eax
  ;  add eax 1_000_000 | Mov D$EndOfSourceMemory eax

    pop edi

ret


; In case user wants to Load a Source Only and Resources are actually available, sends
; a warning Message:

[LosingResources: B$ 'Delete actual Resources?' EOS]
[WarningTitle: B$ ' Warning:' EOS]

LooseResources:
    Mov B$KeepResources &FALSE, eax 0
    or eax D$CursorList | or eax D$IconList | or eax D$MenuList
    or eax D$DialogList | or eax D$StringsList | or eax D$WaveList
    or eax D$AviList | or eax D$RCdataList | or eax D$BitMapList

    On eax = 0, ret

    Mov B$KeepResources &TRUE

    .If D$NoResourcesPE = &FALSE
        Call 'USER32.MessageBoxA' D$H.MainWindow, LosingResources, WarningTitle,
                                 &MB_SYSTEMMODAL__&MB_ICONSTOP__&MB_YESNO
        If eax = &IDYES
            Mov B$KeepResources &FALSE
        End_If
    .Else
        Mov B$KeepResources &FALSE
    .End_If
ret

[MainName: B$ ? # &MAX_PATH]
[KeepResources: D$ ?]

OpenSourceOnly:

    Call ClearPATH SaveFilter

    Call 'Comdlg32.GetOpenFileNameA' OpenSourceStruc

    Test D$SaveFilter NA NOT_ZERO S1>

ret

S1: On D$FL.SourceReady = &TRUE Call ReleaseMainFile

    Call VirtualFree UserPeStart

    Call ClearBackTable | On B$KeepResources = &FALSE Call ReleaseResourceMemory

    Call LoadSourceFile | Call StoreChoosenName SaveFilter

    Mov D$FL.SourceReady &TRUE | Move D$STRUCT.EditData@UpperLine D$CodeSource

    Call KillTabs | Call KillTrailingSpaces

    Call SetBUAWindowText

    Mov D$SavingExtension '.exe'

    Call StartEdition

ret


[IncludeLen: D$ ?]

IncludeSource:

    Call ClearPATH SaveFilter | Call 'Comdlg32.GetOpenFileNameA' OpenSourceStruc

    On D$SaveFilter = 0 ret

    Call ClearBackTable

    Call 'KERNEL32.CreateFileA' SaveFilter,
                                &GENERIC_READ, &FILE_SHARE_READ__&FILE_SHARE_WRITE,
                                0, &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, &NULL
    If eax = &INVALID_HANDLE_VALUE
        Call MessageBox D$BusyFilePtr | ret
    Else
        Mov D$H.Source eax
    End_If

    Call 'KERNEL32.GetFileSize' eax, 0 | Mov D$IncludeLen eax

    Call ReMapSourceMemoryIfNeeded D$IncludeLen

    If eax = &IDNO
        Call 'KERNEL32.CloseHandle' D$H.Source | Mov D$H.Source 0 | ret
    End_If

  ; Ensure the inclusion will not break an existing line in two parts:
    Mov edi D$STRUCT.EditData@CurrentWritingPos
    While B$edi-1 <> LF | inc edi | inc D$STRUCT.EditData@CurrentWritingPos |  End_While

  ; Make room inside actual Source by copying backward:
  ; esi at Source End // edi at Source End + whished room:
    Mov esi D$STRUCT.EditData@SourceEnd | add esi 400
    Mov edi esi | add edi D$IncludeLen | add edi 2      ; this '2' is for added CRLF at end.

  ; How many bytes to Move = how many bytes between Source End and actual Pos:
    Mov ecx D$STRUCT.EditData@SourceEnd | add ecx 400 | sub ecx D$STRUCT.EditData@CurrentWritingPos | inc ecx

    std | rep movsb | cld

    Move D$LP.BlockStartText D$STRUCT.EditData@CurrentWritingPos


    Call 'KERNEL32.ReadFile' D$H.Source, D$LP.BlockStartText, D$IncludeLen, NumberOfReadBytes, 0
    Call 'KERNEL32.CloseHandle' D$H.Source | Mov D$H.Source 0

    Mov edi D$STRUCT.EditData@CurrentWritingPos | add edi D$IncludeLen | Mov W$edi CRLF

    Mov D$LP.BlockEndText edi | sub D$LP.BlockEndText 1

    Mov eax D$IncludeLen | add eax 2 | add D$SourceLen eax | add D$STRUCT.EditData@SourceEnd eax
    Mov D$FL.BlockInside &TRUE

    Mov esi D$LP.BlockStartText,
        ecx D$LP.BlockEndText

    sub ecx esi

    Call BlockCleaner
ret


[OpeningSourceOnly: D$ ?]

ReplaceSourceOnly:  ; 'ControlS'
    Mov B$KeepResources &TRUE

    ..If D$TABLE.Titles = 0
L1:     Call OpenSourceOnly | Call LoadBookMarks

    ..Else
        Mov B$OpeningSourceOnly &TRUE
      ; Tag Dialog 26001
        Call 'USER32.DialogBoxParamA' D$H.Instance, 26001, &NULL, AllOrPartProc, &NULL
        Mov B$OpeningSourceOnly &FALSE

        .If B$AllOrPart = 0-1
            Call RestoreRealSource | Mov D$TABLE.Titles &NULL | jmp L1<

        .Else_If B$AllOrPart = 1   ; 'OpenSourceOnly'

            Call ClearPATH SaveFilter | Call 'Comdlg32.GetOpenFileNameA' OpenSourceStruc

            On D$SaveFilter = EOS ret

                Call CreateSourceFile | On eax = &INVALID_HANDLE_VALUE ret
                Mov eax D$CodeSource | add eax D$SourceLen | Mov D$STRUCT.EditData@SourceEnd eax

                Call 'KERNEL32.ReadFile' D$H.Source, D$CodeSource, D$SourceLen,
                                         NumberOfReadBytes 0

                Call 'KERNEL32.CloseHandle' D$H.Source | Mov D$H.Source 0

                Call KillTabs | Call KillTrailingSpaces

        .End_If

    ..End_If
ret


; In case of 'New' Internaly called because user attempted to load a 'no source inside'
; PE, we change the Saving File Name to 'NoName.exe':

[NoNameNewFile: B$ 'NoName.exe' EOS]
[NewFileBoxTitle: B$ 'New File Name' EOS]

NewFileNameDialog:
    Call GetDirectory ActualDir

  ; Tag Dialog 5
    Call 'USER32.DialogBoxParamA' D$H.Instance, 5, D$H.MainWindow, NewFileType, 0

    Mov eax D$FileTypeChoice

    .If eax = 0-1
L8:     Call SetDirectory ActualDir | jmp L9>>

    .Else
        Call GetBaseName
X1:     Mov edi D$BaseNamePointer
        Mov ebx ActualDir
        While B$ebx <> 0 | inc ebx | End_While
        Mov B$ebx '\' | inc ebx
        While B$esi <> 0
            Mov al B$esi, B$edi al, B$ebx al
            inc esi, ebx, edi
        End_While
        Mov B$edi 0, B$ebx 0
    .End_If

    Call SetDirectory ActualDir

    Call 'KERNEL32.CopyFileA', BaseFilesPath, ActualDir, &TRUE

    ..If eax = &FALSE
        Call 'KERNEL32.GetLastError'

        .If eax = &ERROR_FILE_EXISTS

            Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'Overwrite?' EOS},
                                    {B$ 'File already exist' EOS}, &MB_YESNO
            If eax = &IDYES
                Call 'KERNEL32.CopyFileA', BaseFilesPath, ActualDir, &FALSE

            Else
                jmp L9>>
            End_If

        .Else
            jmp L8<<

        .End_If
    ..End_If

    Mov esi ActualDir, edi SaveFilter
    While B$esi <> 0 | movsb | End_While | movsb

    Call DirectLoad
    Mov D$FL.RelocsWanted &FALSE
    Call ChangeName
    cmp D$SavingExtension '.DLL' | setz B$FL.RelocsWanted ; jE! Relocs for Dll
    Mov D$FL.SourceReady &TRUE
    Call AskForRedraw
    Call ReInitUndo
    Call SetPartialEditionFromPos | Call EnableMenutems
    Call LoadBookMarks
L9: ret


ChangeName:
    or D$STRUC.OPENFILENAME@Flags &OFN_OVERWRITEPROMPT
    Mov D$STRUC.OPENFILENAME@lpstrTitle NewFileBoxTitle
    Call 'Comdlg32.GetSaveFileNameA' STRUC.OPENFILENAME
    Mov D$STRUC.OPENFILENAME@lpstrTitle &NULL
    On eax = &FALSE, ret

    xor D$STRUC.OPENFILENAME@Flags &OFN_OVERWRITEPROMPT | jmp L1>

AutoNew:
    Mov edi SaveFilter, eax 0, ecx 65 | rep stosd


    Mov edi SaveFilter

@NewEmptyFromMenu:
    Mov esi NoNameNewFile
    While B$esi > 0
        movsb
    End_While
    movsb

L1: Call SaveNewFileName

    On eax = &FALSE jmp NewFileNameDialog

    Call SetBUAWindowText

  ; (If here, eax = D$SourceLen)
    xor D$STRUC.OPENFILENAME@Flags &OFN_OVERWRITEPROMPT

    Mov eax &TRUE
ret
____________________________________________________________________________________________

[FileTypeChoice: D$ ?
 H.NewChoiceList: D$ ?]

; Tag Dialog 5

Proc NewFileType:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_COMMAND
        ..If D@wParam = &IDCANCEL
L0:         Mov D$FileTypeChoice 0-1
L1:         Call 'USER32.EndDialog' D@hwnd 0

        ..Else
            .If W@wParam = 10
                If W@wParam+2 = &LBN_DBLCLK
                    Call 'USER32.SendMessageA' D$H.NewChoiceList, &LB_GETCURSEL, 0, 0
                    inc eax | Mov D$FileTypeChoice eax | jmp L1<

                End_If

            .End_If

        ..End_If

    ...Else_If D@msg = &WM_INITDIALOG

        Call SetIconDialog

        Call 'USER32.GetDlgItem' D@hwnd, 10 | Mov D$H.NewChoiceList eax

        Call SetBaseList

    ...Else
        popad | Mov eax &FALSE | ExitP

    ...End_If

    popad | Mov eax &TRUE
EndP


[BaseFilesPath: D$ ? # &MAX_PATH]

[BaseNamePointer: D$ 0] ; !!! je pense qu'il y à un truc...

[@H.BasesList: D$ ?
 @BaseListEnd: D$ ?]

SetBaseList:
INT3 | NOP ; !!! TODO !!!
;;
    Call GetBUAsmFilesPath

    Mov esi BUAsmFilesPath, edi BaseFilesPath
    While B$esi <> 0 | movsb | End_While
    Mov D$edi 'Base', D$edi+4 's\'
    add edi 6 | Mov D$BaseNamePointer edi

    Push esi | Mov esi {B$ 'BasesList.txt' EOS} | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi

    Mov B$edi EOS

    Call 'KERNEL32.CreateFileA' BaseFilesPath, &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                &FILE_ATTRIBUTE_NORMAL, 0

    .If eax = &INVALID_HANDLE_VALUE
        Mov eax 0-1 | ret

    .Else
        Mov D$H.BasesList eax
        Call 'KERNEL32.GetFileSize' eax, 0     ; !!!!!!!!!!!!!! TODO !!!!!!!!!!!!!! ICI !!!
        Mov D$BaseListEnd Trash | add D$BaseListEnd eax
        Call 'KERNEL32.ReadFile' D$H.BasesList, Trash, eax, NumberOfReadBytes, 0
        Call 'KERNEL32.CloseHandle' D$H.BasesList

        Mov esi Trash
        .While esi < D$BaseListEnd
            While B$esi <> SPC | inc esi | End_While
            Mov edi TrashString
            While B$esi <> CR | movsb | End_While | Mov B$edi 0 | add esi 2

            Call 'USER32.SendMessageA' D$H.NewChoiceList,
                                       &LB_ADDSTRING,
                                       0,
                                       TrashString

        .End_While

    .End_If
;;
ret


GetBaseName:
  ; eax = Indice (Indice zero assumed as 'NewEmpty' by 'SetBaseList').
    Mov esi LP.MemTrash, ecx 1 ; !!! TODO !!!

  ; Skip lines until indice matches:
    .While ecx < eax
        While B$esi <> CR | inc esi | End_While | add esi 2
        inc ecx
    .End_While

  ; Set a zero at the end of the File Name:
    Push esi
        While B$esi <> SPC | inc esi | End_While
        Mov D$esi 0
    Pop esi
ret
____________________________________________________________________________________________

[BadNewExtension: B$ 'Bad Extension' EOS]

SaveNewFileName:

    Mov esi SaveFilter,
        edi MainName

L0: lodsb | stosb | Comp B$esi '.' = S1>

    Comp B$esi EOS <> L0<

S1: On B$esi+(4*ASCII) <> EOS jmp L0<

    Mov B$edi EOS

    ; Eax =Suffixe tout en minuscules
    lodsd | or eax 020202000

    Comp eax '.exe' = S3>

    Comp eax '.dll' = S3>

    Comp eax '.sys' = S3>

    Comp eax '.scr' = S3>

    Comp al '.' = S2>

    Comp al EOS = S2>

    Call MessageBox BadNewExtension

    Mov eax &FALSE

ret

S2: sub esi (4*ASCII)

    Mov edi esi,
        eax '.exe'

    stosd | Mov B$edi EOS   ; Complete user given name (any use?...)

    ; Eax = Suffixe tout en majuscules
S3: or eax 020202000 ; | xor eax 020202000

    Mov D$SavingExtension eax,
        eax &TRUE

ret

StartNewFile:

    Call ReInitUndo
    Call ReInitHeaderFormat
    On D$FL.SourceReady = &TRUE Call ReleaseMainFile

    Call ClearBackTable | Call ReleaseResourceMemory

    Mov D$SourceLen 0

    ;  VirtualAlloc CodeSource 1_000_000
    Call VirtualAlloc UserPeStart,
                      1_000_000

    Move D$CodeSource D$UserPeStart

    add D$CodeSource 10     ; security for back test like ESI or EDI - 2 (no page fault)

    Mov edi D$CodeSource
    Mov eax 0A0D0A0D, ecx 100 | rep stosd                            ; end security tail
    Mov edi D$CodeSource, ecx 5 | sub edi 10 | rep stosw
    Mov eax D$CodeSource
    Mov D$STRUCT.EditData@SourceEnd eax, D$STRUCT.EditData@CurrentWritingPos eax, D$STRUCT.EditData@CaretLine 0, D$STRUCT.EditData@CaretRow 1
    add eax 1_000_000 | Mov D$EndOfSourceMemory eax

    Mov D$FL.SourceReady &TRUE | Move D$STRUCT.EditData@UpperLine D$CodeSource

    Mov D$TABLE.Titles &NULL, D$PreviousPartialSourceLen 0

  ; Clear possible previous resources:
    Call ClearCustomList

    Call AskForRedraw

ret


[UserPEStartOfResources: D$ ?
 ResourcesSize: D$ ?]

SearchPEstartOfResource:
    Mov B$NoResourcesPE &FALSE
    Mov esi D$UserPeStart, D$UserPEStartOfResources 0
    movzx eax W$esi+8
   ; Mov eax 0 | add esi 8 | lodsw    ; parag. size of dos header end >PE header adress
    shl eax 4 | sub eax 4
    Mov esi D$UserPeStart | add esi eax | lodsd      ; eax = PE header

    Mov esi D$UserPeStart | add esi eax
    cmp W$esi 'PE' | jne L9>
 ______________________________________

; read data in PeHeader:

L0: Mov ecx 0 | Mov cx w$esi+6            ; word record of section number
    add esi 136 | lodsd | Mov ebx eax     ; RVA of resources from "Image Data Dir..."
    Mov D$ResourcesRVA eax
    Move D$ResourcesSize D$esi

                     ; jmp over general purpose headers and reach PE sections headers:
    add esi 120                           ; esi points to RVA of first section header
    If eax = 0
        Mov B$NoResourcesPE &TRUE | ret
    End_If

L0: lodsd | cmp eax ebx | je L1>
        add esi 36 | loop L0<
          jmp L9>
 ______________________________________

  ; if here, '.rsrc' section found:

L1:
    add esi 4 | lodsd                            ; > app ptr to resources
    add eax D$UserPeStart | Mov D$UserPEStartOfResources eax
L9: ret


[EndOfSectionSearch: D$ ?]

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
 This is a little 'unregular' CheckSum stored in an 'unregular' place. It does *not*
 prevent final user from viruses. It is designed to protect RosAsm programmers who
 exchange files from dispatching corrupted files.

 The base idea is that we can hope that nobody will ever write any virus specifically
 designed to target RosAsm produced PEs. Not at all sophisticated, and very easy to
 overcome, but who would?

 As is, if infected, when you [Load] the file in RosAsm, you get a MessageBox to alert
 you. Nothing more, but i think that it is a very good solution to allow Asm communauty
 to exchange files without fearing.
;;
[CheckMessageTitle: B$ 'Bad CheckSum' EOS]

[CheckInfo: B$ "
 This File has been modified, either
 by an external Tool, or by a Virus.     " EOS]

ReadCheckSum:
    pushad
      ; If a real PE CheckSum has been written, it must be zeroed, before calculation
      ; because it was stored after 'MyCheckSum':
        Mov esi D$UserPeStart | add esi CheckSum | sub esi DosHeader
        Mov D$esi 0

      ; 'MyCheckSum' must not be considered:
        Mov esi D$UserPeStart | add esi MyCheckSum | sub esi DosHeader
        Mov edx D$esi, D$esi 0, ebx 0, eax 0

        .If edx > 0
            Mov esi D$UserPeStart, ecx D$UserPeLen

L0:         lodsb | add ebx eax | loop L0<

            If edx <> ebx
                Call 'USER32.MessageBoxA' D$H.MainWindow, CheckInfo, CheckMessageTitle,
                                           &MB_SYSTEMMODAL__&MB_ICONEXCLAMATION
            End_If
        .End_If
    popad
ret


WriteCheckSum:
    Mov eax 0, ebx 0, esi D$CodeList, ecx D$LenOfCode
L0: lodsb | add ebx eax | loop L0<

    If B$ExportsectionWanted = &TRUE
        Mov esi D$ExportListBPtr, ecx D$ExportSectionLen
L0:     lodsb | add ebx eax | loop L0<
    End_If

    .If D$SavingExtension = '.SYS'
        jmp L0>
    .Else_If D$FL.RelocsWanted = &TRUE ;SavingExtension = '.DLL' ; jE!
L0:     If D$RelocSectionSize => 8 ;jE!
            Mov esi D$Relocation, ecx D$RelocSectionSize
L0:         lodsb | add ebx eax | loop L0<
        End_If
    .End_If

    Mov esi D$CodeSource, ecx D$SourceLen
L0: lodsb | add ebx eax | loop L0<

    Mov edi D$CodeList | add edi MyCheckSum | sub edi DosHeader
    Mov D$edi ebx
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
  Regular PE CheckSum (original Source for csum.exe, from 'RudeBoy'):
  
  Will be needed for Drivers.


    Mov edx 0, esi D$FilePointer, ecx D$FileLen | shr ecx 1

L0: lodsw
    add edx eax
    Mov eax edx
    and edx 0ffff 
    shr eax 010
    add edx eax
    loop L0<

    Mov eax edx
    shr eax 010
    add ax dx
    add eax dwFileLen
  
____________________________________________________________________________________________

Another one:

    Mov ecx, D$Length, esi D$BufferPointer, eax 0
    shr ecx, 1              

    clc                                 
L0: adc ax W$esi+ecx*2-2 | dec ecx | jnz L0<
    
    adc eax D$Length
    
    
    
    
    MicrosoftCheckSum2              PROC C uses esi, buf:dword, len:dword
        Mov             ecx, [len]           
        Mov             edx, [buf]           
        shr             ecx, 1               
        xor             eax, eax             

        clc                                  
@@theLoop:
        adc ax, [edx + (ecx * 2) - 2]
        dec ecx
        jnz @@theLoop
        adc  eax, [len]
        ret
;;

WriteSysFile:
    Call SetExeSavingName

    Call OpenDestinationFile

    Mov D$NumberOfReadBytes 0

    Call AraseSourceHeader | Call AraseCheckSum

    Call WritePeCheckSum

    Call 'KERNEL32.WriteFile' D$H.Destination, D$CodeList, D$LenOfCode,
                              NumberOfReadBytes, 0

    If B$ExportsectionWanted = &TRUE
        Call 'KERNEL32.WriteFile' D$H.Destination, D$ExportListBPtr,
                                  D$FileAlignedExportSectionLen, NumberOfReadBytes, 0
    End_If

    If D$SavingExtension = '.SYS'
        jmp L1>
    Else_If D$FL.RelocsWanted = &TRUE ;D$SavingExtension = '.DLL' ; jE!
L1:
        If D$RelocSectionSize => 8 ;jE!
          Call 'KERNEL32.WriteFile' D$H.Destination,
                                   D$Relocation, D$FileAlignedRelocationSize,
                                   NumberOfReadBytes, 0
        End_If
    End_If

  ;  Call 'KERNEL32.WriteFile' D$H.Destination, D$CodeSource, D$SourceLen,
  ;                            NumberOfReadBytes, 0

    Call 'KERNEL32.CloseHandle' D$H.Destination | Mov D$H.Destination 0
ret


AraseSourceHeader:
    Mov edi D$LocOfSourceHeader
    Mov ecx 20, eax 0 | rep stosd
ret


AraseCheckSum:
    Mov edi D$CodeList | add edi MyCheckSum | sub edi DosHeader
    Mov D$edi 0
ret


WritePeCheckSum:
    Mov esi D$CodeList, ecx D$LenOfCode, eax 0, ebx ecx
    shr ecx, 1

    clc
L0: adc ax W$esi+ecx*2-2 | dec ecx | jnz L0<
    adc ax 0

    If B$ExportsectionWanted = &TRUE
        Mov esi D$ExportListBPtr, ecx D$FileAlignedExportSectionLen
        add ebx ecx
        shr ecx 1
        clc
L0:     adc ax W$esi+ecx*2-2 | dec ecx | jnz L0<
        adc ax 0
    End_If

    If D$RelocSectionSize => 8 ;jE!
        Mov esi D$Relocation, ecx D$FileAlignedRelocationSize
        add ebx ecx
        shr ecx 1
        clc
L0:     adc ax W$esi+ecx*2-2 | dec ecx | jnz L0<
       ; adc ax 0
    End_If
;;
    Mov esi D$CodeSource, ecx D$SourceLen
        add ebx ecx
        shr ecx 1
        clc
L0:     adc ax W$esi+ecx*2-2 | dec ecx | jnz L0<
;;
    adc eax ebx | Call WriteEaxToPeCheckSum
ret


WriteEaxToPeCheckSum:
    Mov edi D$CodeList | sub edi DosHeader | add edi CheckSum
    Mov D$edi eax
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[H.BookMarksFile: D$ ?
 BookMarksFileLen: D$ ?]

[STRUC.FindFile:
 @dwFileAttributes: D$ ?
 @ftCreationTime.dwLowDateTime: D$ ?
 @ftCreationTime.dwHighDateTime: D$ ?
 @ftLastAccessTime.dwLowDateTime: D$ ?
 @ftLastAccessTime.dwHighDateTime: D$ ?
 @ftLastWriteTime.dwLowDateTime: D$ ?
 @ftLastWriteTime.dwHighDateTime: D$ ?
 @nFileSizeHigh: D$ ?
 @nFileSizeLow: D$ ?
 @dwReserved0: D$ ?
 @dwReserved1: D$ ?
 @cFileName: B$ ? # &MAX_PATH
 @cAlternate: B$ ? # 14]

LoadBookMarks:
    Mov D$NumberOfBookMarks 0
    Mov edi SaveFilter, al 0, ecx 0-1 | repne scasb
    While B$edi <> '.'
        dec edi
    End_While

    Push D$edi, edi

        Mov D$edi '.BKM'

        Call 'KERNEL32.FindFirstFileA' SaveFilter STRUC.FindFile
        .If eax = &INVALID_HANDLE_VALUE

            Call VirtualFree BookMarks

            Pop edi, D$edi | ret

        .Else

            Call 'KERNEL32.FindClose' eax

        .End_If

        Call 'KERNEL32.CreateFileA' SaveFilter &GENERIC_READ,
                                    &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                    &FILE_ATTRIBUTE_NORMAL, 0
   Pop edi, D$edi

   If eax = &INVALID_HANDLE_VALUE
        Call MessageBox D$BusyFilePtr

        Pop eax | ret                       ; Pop return adress of caller and ret to Callback

   Else
        Mov D$H.BookMarksFile eax
   End_If

    Call 'KERNEL32.GetFileSize'  eax 0 | Mov D$BookMarksFileLen eax

    Call VirtualFree BookMarks

    Call VirtualAlloc BookMarks,
                      01000

    Call 'KERNEL32.ReadFile' D$H.BookMarksFile D$BookMarks D$BookMarksFileLen,
                            NumberOfReadBytes 0
    Call CreateTreeViewList | Call SetTreeDialogPos

    Call 'KERNEL32.CloseHandle' D$H.BookMarksFile

ret



[EndOfSourceMemory: D$ ?]

OpenBUAsmPE:

    Mov eax D$FL.SourceReady,
        D$FL.SourceReady &FALSE,
        D$FL.OldSourceReady eax

    Call ClearPATH SaveFilter | Call ClearPATH ChoosenFile

    Call 'Comdlg32.GetOpenFileNameA' STRUC.OPENFILENAME

    test D$SaveFilter NA NOT_ZERO S1>

        Mov eax D$FL.OldSourceReady,
            D$FL.SourceReady eax

EndP

S1:DirectLoad:

    Call ReleaseMainFile | Call StoreChoosenName SaveFilter

    Call ClearBackTable | Call ReleaseResourceMemory

    Call VirtualFree UserPeStart

LastLoading:

    Mov esi MainName

    While B$esi <> EOS | add esi ASCII | EndWhile

    While B$esi <> '\' | sub esi ASCII | EndWhile

    Push D$esi

        Mov B$esi+1 EOS | Call SetDirectory MainName

    Pop D$esi

    Call CreateSourceFile | On eax = &INVALID_HANDLE_VALUE ret

; ESi = SaveFilter !!! Voir plus bas !!!

    Call GetFileNameFromPath

  ; > eax = source len

;;

    The reason for allocating a twice (>>> shl eax 1) bigger Mem:
  
    When having TITLEs inside, the editor make a Copy of the edited TITLE, at the bottom
    of this Mem. Therefore, if the Source is made of two TITLEs, a very short one, say
    for Macros, and a very big one, for everything else, we need twice more Mem. Plus the
    additional Edition security, of course:

;;

    Mov D$UserPeEnd eax,
        D$UserPeLen eax

    shl eax 1 | add eax 100_000

    Call VirtualAlloc UserPeStart,
                      eax

    Mov edx D$UserPeStart,
        eax edx

    add D$UserPeEnd eax

    AlignOn PAGE_SIZE eax | sub eax 32 | add eax edx | Mov D$EndOfSourceMemory eax

    Call 'KERNEL32.ReadFile' D$H.Source,
                             D$UserPeStart,
                             D$UserPeLen,
                             NumberOfReadBytes,
                             &NULL

    Call 'KERNEL32.GetLastError'



    Call 'KERNEL32.CloseHandle' D$H.Source

    Mov D$H.Source &NULL

    Mov eax D$UserPeStart | On W$eax <> 'MZ' jmp ExitNotPeExe

    Mov eax D$UserPeStart | sub eax DosHeader | add eax PeHeaderPointer

    Mov ebx D$eax, eax D$UserPeStart | add eax ebx

    On eax >= D$UserPeEnd jmp ExitNotPeExe

    On W$eax <> 'PE' jmp ExitNotPeExe

    cmp D$eax+0A0 0 | setne B$FL.RelocsWanted; jE! RelocsWanted

    Mov B$ThisSourceIsDisassembled &FALSE

    Mov eax D$UserPeStart | add eax 0178 | Mov esi eax     ; +0178 > first section header

    add eax 400 | Mov D$EndOfSectionSearch eax             ; +(10*40) bytes per section

L0: lodsd | cmp eax '.src' | je L1>
        add esi 36 | cmp esi D$EndOfSectionSearch | jb L0<
            jmp TryDisassembly

ExitNotPeExe:

    Call MessageBox D$NotPeExePtr | Call AutoNew | jmp StartNewFile


L1: lodsd | lodsd | Mov D$SourceLen eax
    lodsd | lodsd | lodsd
  ; eax = 0 based pointer to source

  ; 'MessageBox' messages could send a WM_PAINT before complete initializations:
    Mov D$TABLE.Titles &NULL, D$LP.ActualTitle &NULL

    Call ReadCheckSum | Call ReadHeaderFormat

    add eax D$UserPeStart | Mov D$CodeSource eax

    Mov edi D$CodeSource | add edi D$SourceLen | Mov eax 0A0D0A0D, ecx 100

    rep stosd

    Mov eax D$CodeSource | add eax D$SourceLen | Mov D$STRUCT.EditData@SourceEnd eax
   ; add eax 1_000_000 | Mov D$EndOfSourceMemory eax
    Move D$STRUCT.EditData@UpperLine D$CodeSource | Mov D$FL.SourceReady &TRUE

    Call KillTabs | Call KillTrailingSpaces

    Call SearchPEstartOfResource | On B$NoResourcesPE = &TRUE, jmp L9>>

    ; Upload icon:

; Icon storing more stand-alone because of feature for reading icon in other PEs. So does
; it again job done by 'SearchPEstartOfResource'. So, i make it set 'ResourcesRVA' value
; (very durty, but...).

    Move D$iExePtr D$UserPeStart | Call ReadRosAsmPeIcon ; load icon with icon editor routine

    If B$PeIconFound = &TRUE
        Mov esi eax | Mov edi iIcon | rep movsb         ; Copying to icon editor buffer
         Call StoreIcon                                  ; and copy it to 'compilable' image
    End_If

   ; Call ReadRosAsmPeMenus

   ; Call ReadRosAsmPeDialogs

  ;  Call ReadRosAsmBitMaps

  ;  Call ReadRosAsmStrings

   ; Call ReadRosAsmWaves

   ; Call ReadRosAsmAvis

   ; Call ReadRosAsmRCs

   ; Call ReadRosAsmCursors | Call ReadRosAsmGroupCursors

   ; Call ReadRosAsmIcons | Call ReadRosAsmGroupIcons

    Call ReadRosAsmResources

L9: Mov edi D$CodeSource, ecx 5, eax CRLF | sub edi 10 | rep stosw ; security for back search

    Mov D$DestinationFile EOS

    Call SetBUAWindowText

    Call StartEdition

ret

; For 'FillExportSection':

GetFileNameFromPath:
    Push eax, esi, edi
        Mov esi SaveFilter, eax esi
        Mov edi ChoosenFile

        While B$esi <> 0 | inc esi | End_while

        While esi > eax
            dec esi
            On B$esi = '\', jmp L1>
        End_While

L1:     inc esi

        While B$esi <> 0
            movsb
        End_While
        Mov B$edi 0
    Pop edi, esi, eax
ret


[DisChoice: D$ ?]

TryDisassembly:
    On D$AddressToBeForced = &TRUE, jmp DisMain

  ; Tag Dialog 27000
    Call 'USER32.DialogBoxParamA' D$H.Instance, 27000, D$H.MainWindow, DisassembleProc, 0
    Test D$DisChoice 0_8000_0000 ZERO L9>
        and D$DisChoice 0FF | jmp Dismain

L9:     Call AutoNew | jmp StartNewFile

____________________________________________________________________________________________

[WithCommentedHexa: &FALSE   WithForcedMapFile: &TRUE  WithMacros: &TRUE]

; Tag Dialog 27000

Proc DisassembleProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_COMMAND                  ; User action
        ..If D@wParam = &IDCANCEL                   ; User clicks on upper right [X]
            and D$DisChoice 0FF
            Call 'USER32.EndDialog' D@hwnd 0
          ; Call 'USER32.DestroyWindow' D@hwnd ; Comments...

        ..Else_If D@wParam = &IDOK
            or D$DisChoice 0_8000_0000
            Call 'USER32.EndDialog' D@hwnd 0

        ..Else_If D@wParam = &IDHELP
            Call Help B_U_AsmName, DisassemblerHelp, ContextHlpMessage

        ..Else
            movzx eax W@wParam
            If eax = 10
                Mov B$WithCommentedHexa &FALSE
            Else_If eax = 11
                Mov B$WithCommentedHexa &TRUE
            Else_If eax = 12
                Mov B$WithCommentedHexa &FALSE
            Else_If eax = 14
                xor B$WithForcedMapFile &TRUE
            Else_If eax = 15
                xor B$WithMacros &TRUE
            Else_If eax = 16
                xor B$AMDassumed &TRUE
            End_If

        ..End_If

    ...Else_If D@msg = &WM_INITDIALOG          ; Win ready to build the Dialog
        If B$WithCommentedHexa = &TRUE
            Call 'USER32.CheckDlgButton' D@hwnd, 11, &TRUE
        Else_If B$WithMacros = &TRUE
            Call 'USER32.CheckDlgButton' D@hwnd, 15, &TRUE
        Else
            Call 'USER32.CheckDlgButton' D@hwnd, 10, &TRUE
        End_If

        Call IsForcedMapFile
        .If eax = &TRUE
            Call Enable D@hwnd, 14
            If B$WithForcedMapFile = &TRUE
                Call 'USER32.CheckDlgButton' D@hwnd, 14, &TRUE
            End_If
        .Else
            Call Disable D@hwnd, 14
        .End_If

        If B$AMDassumed = &TRUE
            Call 'USER32.CheckDlgButton' D@hwnd, 16, &TRUE
        End_If


  ;  ...Else_If D$Message = &WM_CTLCOLOREDIT        ; Win ready to paint the Dialog
  ;      ; Control of output

    ...Else
        popad | Mov eax &FALSE | ExitP               ; Non processed

    ...End_If

    popad | Mov eax &TRUE                           ; Processed
EndP
____________________________________________________________________________________________

; >>> peheader <<<

ReadHeaderFormat:
    pushad
        Mov eax D$UserPeStart | add eax 0178 | Mov esi eax     ; +0178 > first section header
        add eax 400 | Mov D$EndOfSectionSearch eax             ; +(10*40) bytes per section

      ; Data Characteristics:
        Push esi
L0:         lodsd | cmp eax '.dat' | je L1>
                add esi 36 | cmp esi D$EndOfSectionSearch | jb L0<
                jmp L0>
L1:         add esi 32
            lodsd | Mov D$DataCharacteristics eax
L0:     Pop esi

      ; Code Characteristics:
L0:     lodsd | cmp eax '.tex' | je L1>

            add esi 36 | cmp esi D$EndOfSectionSearch | jb L0<

            Call MessageBox D$NotPEPtr

ret

L1:     add esi 32
        lodsd | Mov D$CodeCharacteristics eax

      ; SubSystem, DLL_characteristcs:
        Mov esi PeHeader | sub esi DosHeader
        add esi D$UserPeStart                   ; >>> 'PE' 0 0
        add esi 52                              ; >>>> ImageBase

        Mov eax D$esi, D$ImageBase eax, D$LinkerDllDefault eax

        Mov edi SubSystem | add esi 40          ; >>> SubSystem // DLL characteristcs
        Mov ax W$esi, W$DllAttachDetach ax

        movsd
        movsd   ; AppStackMax
        movsd   ; AppStackMin
        movsd   ; AppHeapMax
        movsd   ; AppHeapMin
    popad
ret


ReInitHeaderFormat:
    Push edi
        Mov edi SubSystem
        Mov eax 2 | stosd                       ; Subsystem GUI  //  DLL characteristics 0
        Mov eax 0100000 | stosd                 ; AppStackMax
        Mov eax   01000 | stosd                 ; AppStackMin
        Mov eax 0100000 | stosd                 ; AppHeapMax
        Mov eax       0 | stosd                 ; AppHeapMin
        Mov D$CodeCharacteristics 0_60000020    ; readable, runable, code
        Mov D$DataCharacteristics 0_C0000040    ; readable, writeble, Data
        Mov W$DllCharacteristics 0
    Pop edi
ret
 _______________________________

; Writing files:

[DestinationFile: B$ ? # &MAX_PATH]

OpenDestinationFile:
    On D$H.Destination > 0, Call 'KERNEL32.CloseHandle' D$H.Destination

    Call 'KERNEL32.CreateFileA' DestinationFile, &GENERIC_WRITE,
                                &FILE_SHARE_READ__&FILE_SHARE_WRITE, 0,
                                &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE
        Call MessageBox D$BusyFilePtr

        Mov D$FL.CompileErrorHappend &TRUE

      ; Pop return adress of caller and ret to Callback:
        Pop eax | ret

    Else
        Mov D$H.Destination eax

    End_If
ret

____________________________________________________________________________________________
;;
 This is for developpements test:

 DANGER >>> Writes a 'Test.a' on the disk without warning.
 
 'WriteDestination' is used only by 'AsmMain' when you branch to it. All these commented
 lines are for tests along developpement giving ability, by calling it, to output
 internal tables for exemple, if we want to see what is in 'DllList', we route here with
 a 'jmp L7>' after 'BuildImport'; with "Mov eax, 010000 | Push eax" and "Push D$DllList"
 uncommented.
;;
WriteDestination:
    Call OpenDestinationFile

   ; hexprint D$StripLen
   ; showme DestinationFile

    Push 0
    Mov D$NumberOfReadBytes 0 | Push NumberOfReadBytes

      Mov eax, 0100

 ;;;; Just uncomment the one you want in 'Test.a':

    ; Push D$LenOfCode, D$CodeSource
    ; Push D$StripLen, D$CodeSourceB
     Push D$StripLen, D$CodeSourceA
    ; Push eax, D$EquateList
    ; Push eax, D$MacroList
    ; Push eax, D$PlainLabelList
    ; Push eax, D$MacroData
    ; Push eax, D$DataList
    ; Push eax, D$LabelList
    ; Push D$StripLen, D$Coderef
    ; Push eax, D$DataRef
    ; Push eax, D$DllList
    ; Push eax, D$ApiListA
    ; Push eax, D$ApiListB
    ; Push eax, D$Relocation
    ; Push eax, D$TreeList
    ; Push eax, D$CodeList
    ; Push eax, D$ExportListAPtr
;;
    Mov esi D$StatementsTable | While D$esi > 0 | add esi 4 | End_While
    sub esi D$StatementsTable
    Push esi, D$StatementsTable
;;

   ; Mov eax D$EndOfSectionsMap | sub eax D$SectionsMap | Push eax
;
 ;   Push D$SectionsMap

    Push D$H.Destination
    Call 'KERNEL32.WriteFile'
ret


ControlS:
    ..If D$TABLE.Titles = &NULL
        Call SaveSource
        Call 'USER32.MessageBoxA' D$H.MainWindow, DestinationFile,
                                {B$ 'Saved in actual Directory:' EOS}, 0

    ..Else
        Call 'USER32.DialogBoxParamA' D$H.Instance, 26000, &NULL, AllOrPartProc, &NULL

        .If B$AllOrPart = 0-1
            Call RestoreRealSource | Call SaveSource
            Call SetPartialEditionFromPos

        .Else_If B$AllOrPart = 1
            Mov B$WeAreSavingPart &TRUE
            Call SaveSource
            Mov B$WeAreSavingPart &FALSE

        .Else_If B$AllOrPart = 9
            Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ "     Do you wish to save all the TITLEs
of this Application into as many asm Files?      " EOS}, {B$ 'Sure?' EOS}, &MB_YESNO
            If eax = &IDYES
                Mov B$WeAreSavingPart &TRUE
                Call SaveActualPos
                Call GetTitlesNumber

L0:             Push ecx
                    Call SelectTitle ecx | Call SaveSource
                Pop ecx
                loop L0<

                Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'Done' EOS}, 0, 0
                Call RestoreActualPos
                Mov B$WeAreSavingPart &FALSE
            End_If

        .End_If

    ..End_If
ret


[ActualPos: D$ ?]

SaveActualPos:
    Move D$ActualPos D$STRUCT.EditData@CurrentWritingPos
ret


Proc SelectTitle:

    Argument @Indice

    Call RestoreRealSource

    Mov eax D@Indice | sub eax 1 | Mov D$ID.ActualTitle eax

    Move D$STRUCT.EditData@CurrentWritingPos D$TABLE.Titles+eax*DWORD

    Call SetPartialEdition

    Mov esi D$CodeSource, edi PartName

    If D$esi = 'TITL'

        add esi 5 | While B$esi = SPC | inc esi | End_While

        While B$esi > SPC | movsb | End_While | Mov B$edi 0

    Else

        Mov D$PartName 'Top'

    End_If

EndP


GetTitlesNumber:
    Mov esi TABLE.Titles, ecx 0
    While D$esi <> 0
        inc ecx | add esi 4
    End_While
ret


RestoreActualPos:
    Move D$STRUCT.EditData@CurrentWritingPos D$ActualPos
ret


[BackUpPathName: B$ ? # &MAX_PATH]
[BackUpNewPathName: B$ ? # &MAX_PATH]

[WIN32_FIND_DATA:
 @dwFileAttributes: D$ ?
 @ftCreationTime.dwLowDateTime: D$ ?
 @ftCreationTime.dwHighDateTime: D$ ?
 @ftLastAccessTime.dwLowDateTime: D$ ?
 @ftLastAccessTime.dwHighDateTime: D$ ?
 @ftLastWriteTime.dwLowDateTime: D$ ?
 @ftLastWriteTime.dwHighDateTime: D$ ?
 @nFileSizeHigh: D$ ?
 @nFileSizeLow: D$ ?
 @dwReserved0: D$ ?
 @dwReserved1: D$ ?
 @cFileName: B$ ? # &MAX_PATH
 @cAlternate: B$ ? # 80]

[H.BackUpFile: D$ ?
 LastBackUpIndice: D$ ?]

[MaxBackUp: B$ '0010' EOS]

ControlK:
    On D$MaxBackUp = '0000' ret

    If D$FL.ReadyToRun = &FALSE
        Call 'USER32.MessageBoxA' D$H.MainWindow,
                                 {B$ 'You have to [Compile] or to [Run] before a PE BackUp' EOS},
                                 {B$ '[Ctrl][K] BackUp aborted:' EOS}, 0
        ret
    End_If

    Mov esi MainName, edi BackUpPathName

    While B$esi <> 0 | movsb | End_While
    While B$esi <> '\' | dec esi | dec edi | End_While

    Push esi
        While B$esi <> 0 | movsb | End_While
        Mov B$edi '\' | inc esi
        Mov D$edi 'Back', D$edi+4 'Up\ ' | add edi 7
    Pop esi

    inc esi | While B$esi <> 0 | movsb | End_While
    Mov B$edi '*' | inc edi
    Mov eax D$SavingExtension | stosd | Mov B$edi 0

    Push edi
        Call 'KERNEL32.FindFirstFileA' BackUpPathName, WIN32_FIND_DATA
        Mov D$H.BackUpFile eax
    Pop edi

    ...If eax = &INVALID_HANDLE_VALUE
        While B$edi <> '\' | dec edi | End_While | Mov B$edi 0
        Push edi
            Call 'KERNEL32.CreateDirectoryA' BackUpPathName, 0
        Pop edi
        Mov B$edi '\'
        While B$edi <> '*' | inc edi | End_While
        Mov D$edi '0000' | add edi 4
L0:     Mov eax D$SavingExtension | stosd | Mov B$edi 0
        Mov esi MainName | While B$esi <> 0 | inc esi | End_While
        Move D$esi D$SavingExtension | Mov B$esi+4 0
        Push esi
            Call 'KERNEL32.CopyFileA' MainName, BackUpPathName, &FALSE
        Pop esi
        Mov B$esi 0

    ...Else
L2:     Call 'KERNEL32.FindNextFileA' D$H.BackUpFile, WIN32_FIND_DATA
        cmp eax &TRUE | je L2<

        Call 'KERNEL32.FindClose' D$H.BackUpFile

        Mov esi WIN32_FIND_DATA@cFileName
        While B$esi <> 0 | inc esi | End_While
        While B$esi <> '.' | dec esi | End_While
        Call IncTextDwordBeforeEsi

        Mov edi BackUpPathName
        While B$edi <> 0 | inc edi | End_While
        While B$edi <> '*' | dec edi | End_While
        Mov eax D$esi-4, D$LastBackUpIndice eax | stosd | jmp L0<<

    ...End_If

    Mov eax D$MaxBackUp, ebx D$LastBackUpIndice | bswap eax | bswap ebx

    .If ebx >= eax
        Mov esi BackUpPathName
        While B$esi <> 0 | inc esi | End_While
        While B$esi <> '.' | dec esi | End_While
        sub esi 4 | Mov D$esi '0000'
        Mov ebx esi | sub ebx BackUpPathName
        Push ebx
            Call 'KERNEL32.DeleteFileA' BackUpPathName
            Mov esi BackUpPathName, edi BackUpNewPathName
            While B$esi <> 0 | movsb | End_While | Mov B$edi 0
        Pop ebx

L0:     lea esi D$BackUpPathName+ebx+4
        Call IncTextDwordBeforeEsi
        Mov eax D$MaxBackUp, edx D$esi-4 | bswap eax | bswap edx | cmp edx eax | ja L9>
        Push ebx
            Call 'KERNEL32.MoveFileA' BackUpPathName, BackUpNewPathName
        Pop ebx
        If eax = &TRUE
            lea esi D$BackUpNewPathName+ebx+4
            Call IncTextDwordBeforeEsi
        End_If
        jmp L0<

L9:     Mov esi BackUpNewPathName, edi BackUpPathName
        While B$esi <> 0 | movsb | End_While | Mov B$edi 0
        lea esi D$BackUpPathName+ebx+4
        Call DecTextDwordBeforeEsi

    .End_If

    Call 'USER32.MessageBoxA' D$H.MainWindow, BackUpPathName, {B$ 'Backup done to:' EOS}, 0
ret

IncTextDwordBeforeEsi:
    inc B$esi-1
    ..If B$esi-1 > '9'
        Mov B$esi-1 '0' | inc B$esi-2
        .If B$esi-2 > '9'
            Mov B$esi-2 '0' | inc B$esi-3
            If B$esi-3 > '9'
                Mov B$esi-3 '0' | inc B$esi-4
            End_If
        .End_If
    ..End_If
ret

decTextDwordBeforeEsi:
    dec B$esi-1
    ..If B$esi-1 < '0'
        Mov B$esi-1 '9' | dec B$esi-2
        .If B$esi-2 < '0'
            Mov B$esi-2 '9' | dec B$esi-3
            If B$esi-3 < '0'
                Mov B$esi-3 '9' | dec B$esi-4
            End_If
        .End_If
    ..End_If
ret

____________________________________________________________________________________________



[PartName: D$ ? # 16]

[WeAreSavingPart: D$ ?
 AllOrPart: D$ ?]

[ReplaceSourceText: B$ 'Load Source' EOS]

; Tag Dialog 26000

Proc AllOrPartProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_INITDIALOG
            On B$OpeningSourceOnly = &TRUE,
                Call 'USER32.SendMessageA' D@hwnd, &WM_SETTEXT, 0, ReplaceSourceText

            Mov esi D$LP.ActualTitle
            .If esi = D$RealCodeSource
                If D$esi <> 'TITL'
                    Mov D$PartName 'Top ', B$PartName+3 EOS

                    Call 'USER32.SetDlgItemTextA' D@hwnd,
                                                  1,
                                                  STR.A.DefaultTopTITLE

                    jmp L8>>
                End_If
            .End_If

            While B$esi > SPC | inc esi | End_While ; jump over 'TITLE'

            While B$esi = SPC | inc esi | End_While ; >>> 'TitleName
            Mov edi PartName
            While B$esi > SPC | movsb | End_While
            Mov al EOS | stosb
            Call 'USER32.SetDlgItemTextA' D@hwnd, 1, PartName
            jmp L8>>

    ...Else_If D@msg = &WM_COMMAND
        Mov eax D@wParam | and D@wParam 0FFFF | shr eax 16

        If D@wParam = &IDCANCEL
            Mov B$AllOrPart 0

        Else_If D@wParam = &IDOK
            Mov B$AllOrPart 1

        Else_If D@wParam = 3
            Mov B$AllOrPart 0-1

        Else_If D@wParam = 4
            Mov B$AllOrPart 9

        End_If

        Call 'USER32.DestroyWindow' D@hwnd

    ...Else
L8:     popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE
L9: EndP


[IncSaveTitle: B$ 'Saving .inc or .asm ? ...' EOS]
[IncSaveBody: B$ "
 
   Yes > Save the inc File in its original Directory      
   
   No  > Save the asm File in current Directory" EOS]


SaveSource:
    .If B$WeAreSavingPart = &TRUE
        Call RestoreRealSource

        Call SearchForIncInclude

        If eax = &TRUE
            Mov esi D$PointerToIncFileName, edi DestinationFile
            While B$esi > SPC | movsb | End_While | Mov B$edi 0
        End_If

        Push eax
            Call SetPartialEditionFromPos
        Pop eax

        If eax = &TRUE
            Call 'USER32.MessageBoxA' D$H.MainWindow, IncSaveBody, IncSaveTitle,
                                      &MB_SYSTEMMODAL_&MB_YESNO
            On eax = &IDYES, jmp L2>
        End_If
    .End_If

    Call SetAsmSavingName

L2: Call OpenDestinationFile | Mov D$NumberOfReadBytes 0
    Call 'KERNEL32.WriteFile'  D$H.Destination, D$CodeSource, D$SourceLen,
                               NumberOfReadBytes, 0

    Call 'KERNEL32.CloseHandle' D$H.Destination | Mov D$H.Destination 0
ret


SearchForIncInclude:
    Mov esi D$CodeSource, eax &FALSE

    .While esi < D$STRUCT.EditData@SourceEnd
        Call IsItPREPARSE
        .If eax = &TRUE
            add esi 9
L1:         While B$esi = SPC | inc esi | End_While
            If B$esi = ','
                inc esi | jmp L1<
            End_If

            Mov eax &FALSE | Call IsItIncIncluder

            If eax = &TRUE
                Mov eax &FALSE | Call IsTheActualTitleIncluded | On eax = &TRUE, ret
            End_If
        .End_If

        inc esi

    .End_While

    Mov eax &FALSE
ret


IsItPREPARSE:
    ..If D$esi = 'PREP'
        .If D$esi+4 = 'ARSE'
            If B$esi-1 < SPC
                On B$esi+8 = SPC, Mov eax &TRUE
            End_If
        .End_If
    ..End_If
ret


IsItIncIncluder:
L0:
    Mov ebx D$esi | or ebx 020202020
    ..If ebx = 'inci' ; IncIncluder
        Mov ebx D$esi+4 | or ebx 020202020
        .If ebx = 'nclu'
            Mov bx W$esi+8 | or bx 02020
            If bx = 'de'
                Mov bl B$esi+10 | or bl SPC | On bl = 'r', Mov eax &TRUE
            End_If
        .End_If
    ..End_If

    .If eax = &FALSE
L1:     While B$esi > SPC | inc esi | End_While

        While B$esi = SPC  | inc esi | End_While

        If B$esi = ','
            inc esi | jmp L1<
        End_If

        On B$esi > SPC, jmp L0<
    .End_If
ret

IsTheActualTitleIncluded:
    Push esi
        Mov esi D$CodeSource, eax &FALSE

        While esi < D$STRUCT.EditData@SourceEnd
            ...If D$esi = 'INCI'  ; INCI NCLU DE
                ..If D$esi+4 = 'NCLU'
                    .If W$esi+8 = 'DE'
                        If B$esi-1 < SPC
                            On B$esi+10 = SPC, Call IsThisTheActualTitle
                            On eax = &TRUE, jmp L9>
                        End_If
                    .End_If
                ..End_If
            ...End_If

            inc esi
        End_While
L9: Pop esi
ret


[PointerToIncFileName: D$ ?]

IsThisTheActualTitle:
    add esi 10
    While B$esi = SPC | inc esi | End_While
    Mov D$PointerToIncFileName esi

    Mov edx &FALSE
    While B$esi <> CR | inc esi | End_While
    While B$esi <> '\' | dec esi | End_While | inc esi
    Mov edi D$LP.ActualTitle  ; TITLE xxxx
    add edi 6 | While B$edi = SPC | inc edi | End_While

    While B$esi <> '.'
        Mov al B$esi, bl B$edi | inc esi | inc edi | cmp al bl | jne L7>
    End_While

    .If B$esi = '.'
        If B$edi <= SPC
            Mov edx &TRUE
        End_If
    .End_If

L7: Mov eax edx
ret

____________________________________________________________________________________________


[ExportAjust: D$ ?]    ; The value to turn an Export section Adress to RVA

PrepareDllVariables:
    Mov eax D$AppStartOfCode
    add eax D$AppTrueCodeSize | AlignOn 0200 eax | Mov D$AppStartOfExp eax
    add eax D$ExportSectionLen | AlignOn 0200 eax

    If D$RelocSectionSize => 8 ;jE!
        Mov D$AppStartOfReloc eax | add eax D$RelocSectionSize | AlignOn 0200 eax
    Else
        Mov D$AppStartOfSrc eax | dec W$NumberOfSections
    End_If
    sub eax D$AppStartOfExp | add D$AppAllDataSize eax

    Move eax D$ExportSectionLen , D$AppExpTrueSize eax
    AlignOn 0200 eax | Mov D$AppExpAlignedSize eax

    Mov eax D$AppCodeRVAoffset
    add eax D$AppFileSizeOfCode | AlignOn 01000 eax | Mov D$AppBaseOfExp eax

    add eax D$AppExpAlignedSize | AlignOn 01000 eax

    Move D$SectionTable D$AppBaseOfExp
    Move D$SectionTable+4 D$AppExpAlignedSize

  ; For ease of 'FillExportSection' job:
    Mov eax D$AppBaseOfExp | sub eax D$ExportListBPtr | Mov D$ExportAjust eax

    Mov eax D$ExportSectionLen | AlignOn 0200 eax | Mov D$FileAlignedExportSectionLen eax
ret

;;
 Same for Resources (DLL cases, too).

StripResourcesHeader:
    Mov edi ResourceSectionHeader | sub edi DosHeader | add edi D$CodeList
    Mov esi DataSectionHeader | sub esi DosHeader | add esi D$CodeList
    Mov ecx SourceSectionHeader | sub ecx DataSectionHeader

  ; Just because if we already stripped the Import Section in a DLL, all the records
  ; we are attempting to point to are one Section upward now:
    If D$ImportTrueSize = 0
        sub esi 40 | sub edi 40 | sub ecx 40
    End_If

    rep movsb
    Mov ebx NumberOfSections | sub ebx DosHeader | add ebx D$CodeList
    dec W$ebx

  ; Clear the Image Base record for Resource RVA and Size:
    Mov edi AppBaseOfRsrc | sub edi DosHeader | add edi D$CodeList
    Mov eax 0 | stosd | stosd
ret
;;

WritePE:
    If D$SavingExtension = '.SYS'
        Call SetSysSourceSavingName
    Else
        Call SetExeSavingName
        Mov eax 0 | Call WriteEaxToPeCheckSum
    End_If

    Call OpenDestinationFile

    Mov D$NumberOfReadBytes 0

    Call WriteCheckSum

    Call 'KERNEL32.WriteFile' D$H.Destination, D$CodeList, D$LenOfCode,
                              NumberOfReadBytes, 0

    If B$ExportsectionWanted = &TRUE
        Call 'KERNEL32.WriteFile' D$H.Destination, D$ExportListBPtr,
                                  D$FileAlignedExportSectionLen, NumberOfReadBytes, 0
    End_If

    If D$SavingExtension = '.SYS'
        jmp L1>
    Else_If D$FL.RelocsWanted = &TRUE ;D$SavingExtension = '.DLL' ; jE!
L1:
        If D$RelocSectionSize => 8 ;jE!
          Call 'KERNEL32.WriteFile' D$H.Destination,
                                   D$Relocation, D$FileAlignedRelocationSize,
                                   NumberOfReadBytes, 0
        End_If
    End_If

    Call 'KERNEL32.WriteFile' D$H.Destination, D$CodeSource, D$SourceLen,
                              NumberOfReadBytes, 0

    Call 'KERNEL32.CloseHandle' D$H.Destination | Mov D$H.Destination 0

    On D$SavingExtension = '.SYS', Call WriteSysFile
ret

;;
  It has happend that under some condition(s), it is possible that a wrong
  paring of CR/LF come out in a Source. For example "0D, 0D, 0A". As these
  conditions are unknown, a fix is done, here, at Write-Time:

CheckCRLFs:
    Mov esi D$CodeSource, edx esi, eax 0 | add edx D$SourceLen
    
    While esi < edx
        If B$esi = CR
            On B$esi+1 <> LF, inc eax
        Else_If B$esi = LF
            On B$esi-1 <> CR, inc eax
        End_If
        
        inc esi
    End_While
 
    ..If eax <> 0
        Mov ecx D$SourceLen | add ecx eax | VirtualAlloc Trash ecx
        Mov esi D$CodeSource, edi D$Trash, edx esi | add edx D$SourceLen
        
        While esi < edx
            .If B$esi = CR
                If B$esi+1 <> LF
                    movsb | Mov B$edi LF | inc edi | inc D$SourceLen
                    hexprint 1
                Else
                    movsb
                End_If
            .Else_If B$esi = LF
                If B$esi-1 <> CR
                    Mov B$edi CR | inc edi | movsb | inc D$SourceLen
                    hexprint 2
                Else
                    movsb
                End_If
            .Else
                movsb
            .End_If
            
        End_While
        
        Call 'KERNEL32.WriteFile' D$H.Destination, D$Trash, D$SourceLen,
                              NumberOfReadBytes, 0
hexprint D$SourceLen
        Call 'KERNEL32.CloseHandle' D$H.Destination | Mov D$H.Destination 0
        
        Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ "
A bad pairing of CR/LF has been found in the Source,
at Write-Time. The problem is fixed, but RosAsm is
going to shut down, and you will have to Re-Load.

Do not care, then, of the Alert Message for corruption.

Sorry for the inconvenient.

In case you could point out what action(s), in the Editor,
could help reproducing these wrong CR/LFs, please report.
" EOS}, 
                                     {B$ 'Source failure' EOS}, 0
        
        Call 'KERNEL32.ExitProcess' 0
        
    ..End_If
ret
;;

SaveBookMarks:
    Mov edi DestinationFile, ecx 0-1, al 0 | repne scasb
    While B$edi <> '.'
        dec edi
    End_While

    Push D$edi, edi
        Mov eax '.BKM' | stosd

        Call OpenDestinationFile

        Mov edi D$BookMarks, al 0, ecx 0-1
L0:     repne scasb | cmp B$edi 0 | ja L0<
        sub edi D$BookMarks | inc edi                    ; edi = lenght.

        Call 'KERNEL32.WriteFile'  D$H.Destination, D$BookMarks, edi,
                                   NumberOfReadBytes, 0

        Call 'KERNEL32.CloseHandle' D$H.Destination | Mov D$H.Destination 0
    Pop edi, D$edi
ret


Proc StoreChoosenName:

    Argument @STR.A.Name

    Uses esi,
         edi

    Call ClearPATH MainName

    Mov edi MainName,
        esi D@STR.A.Name

L1: lodsb | stosb | Test al 0_FF NOT_ZERO L1<

L2: sub edi ASCII | Comp B$edi '.' <> L2< ; '.' Can be inside the name / '.' peut aussi se trouver dans le nom

    Mov B$edi EOS

L3: sub esi ASCII | Comp B$esi '.' <> L3<

    ; TODO traduction
    ; Eax = Suffixe en minuscules
    lodsd | or eax 0_20_20_20_00

    mov D$SavingExtension eax

;;
  
    If eax = '.exe'
    
    
    Else_If eax = '.scr'
    
    Else_If eax = '.asm'
    
    Else_If eax = '.dll'
    
    Else_If eax = '.sys'
    
        Move D$SavingExtension D$SysExtension
    
    Else
    
        INT3 | NOP ; TODO :) Prévoir un message ...
    
    End_If
;;

EndP

[SavingExtension: D$ '.exe']

SetExeSavingName:
    Mov edi DestinationFile, ecx 262, al 0 | rep stosb
    Mov edi DestinationFile, esi MainName
    If B$esi = 0
        Mov ax W$DefaultFileName | stosw | jmp L9>
    End_If
L0: lodsb | cmp al 0 | je L9>
        stosb | jmp L0<
L9: Mov eax D$SavingExtension | stosd
    Mov B$edi 0
ret


SetSysSourceSavingName:
    Mov edi DestinationFile, ecx 262, al 0 | rep stosb
    Mov edi DestinationFile, esi MainName
    If B$esi = 0
        Mov ax W$DefaultFileName | stosw | jmp L9>
    End_If
L0: lodsb | cmp al 0 | je L8>
        stosb | jmp L0<

L8: On W$edi-6 <> 'So', jmp L8>

    If D$edi-4 = 'urce'
        Mov B$esi  -7, 0 | jmp L9>
    End_If

L8: Mov D$edi 'Sour', W$edi+4 'ce' | add edi 6

L9: Mov eax D$SavingExtension | stosd
    Mov B$edi 0
ret


[TestName: B$ 'Test.a' EOS]

SetTestSavingName:
    Mov edi DestinationFile, ecx 262, al 0 | rep stosb
    Mov edi DestinationFile, esi TestName
L0: lodsb | stosb | cmp al 0 | ja L0<
    Mov B$edi 0
ret


[DefaultFileName: B$ 'PE.' EOS]


; Revue: Does not work if the Path contains some '.' Period in a Folder Name (!!!!)....

[FullPartName: B$ ? # &MAX_PATH]

SetAsmSavingName:

    Call ClearPATH DestinationFile

    If B$WeAreSavingPart = &TRUE

        Mov esi MainName, edi FullPartName, ecx (&MAX_PATH/DWORD) | rep movsd | dec edi

        While B$edi = EOS | sub edi (1*ASCII) | End_While

L0:     cmp B$edi '\' | je L1>

        cmp B$edi ':' | je L1>

        sub edi (1*ASCII) | jmp L0<

L1:     add edi (1*ASCII)

        Mov esi PartName

        While B$esi > EOS | movsb | End_While | movsb

        Mov esi FullPartName

    Else
        Mov esi MainName

    End_If

    Mov edi DestinationFile

    If B$esi = EOS

        Mov ax W$DefaultFileName | stosw | jmp L9>

    End_If

L0: lodsb | cmp al EOS | je L9>
           ; cmp al '.' | je L9>
    stosb | jmp L0<

L9: On B$edi-(4*ASCII) = '.' sub esi (4*ASCII)  ; BUAsm outputs are always with 3 Chars Extensions

    Mov eax '.asm' | stosd

ret

 ________________________________________________________________________________________
 ________________________________________________________________________________________


____________________________________________________________________________________________
____________________________________________________________________________________________

[ShowWinEquateError: &TRUE]

ReplaceWin32Equates:
    Mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen
    Mov B$ShowWinEquateError &TRUE, B$ErrorLevel 8  ; 'error8'

L0: lodsb

    ..If al = '&'
        On B$esi < 'A', jmp L2>>
        Push ecx, esi, edi
            ;dec esi |
            Mov D$imm32 0 | Call NewSearchForWinEquate
        Pop edi, eax, ecx
      ; Mov ebx esi | sub ebx eax | sub ecx ebx ; Same:
        add ecx eax | sub ecx esi | jz L9>
            Mov eax D$imm32 | Call WriteEax


    ..Else_If al = textSign
        On B$esi-2 > LowSigns, jmp L7>
        dec ecx | Mov bl al
L1:     stosb | lodsb
        If al = TextSign
            On B$esi > LowSigns, jmp L8>
            jmp L2>
        End_If
        loop L1<

    ..Else

L2:     stosb

    ..End_If

    loop L0<

L9: sub edi D$CodeSourceB | Mov D$StripLen edi
    Exchange D$CodeSourceA D$CodeSourceB

    Mov D$imm32 0
ret

L7: Mov edx D$MissingSeparator1Ptr | jmp L9>

L8: Mov edx D$MissingSeparator2Ptr

L9: Mov B$Errorlevel 9, ebx esi
    While B$esi > EOI | dec esi | End_While | inc esi
    While B$ebx > EOI | inc ebx | End_While | Mov B$ebx 0
    error edx, esi

 ________________________________________________________________________________________
 ________________________________________________________________________________________


  _____________________
  _____________________

; Same as Above, but with some specific computing of newly added [] inside macros
; unfolded. To be restructured later: make the OpenBracket > OpenVirtual job a called
; routine for both here and uper treatements. Too hot now...

ResetForNewBrackets:
    Mov esi D$CodeSourceA, edx esi | add edx D$StripLen
L0: .While esi < edx
        lodsb

        If al = TextSign
            While B$esi <> TextSign | inc esi | End_While | inc esi

        Else_If al = '?'
            On B$esi > LowSigns, jmp L0<
            On B$esi-2 > LowSigns, jmp L0<
            Mov ebx esi
            While B$ebx <> OpenBracket
                On B$ebx = OpenVirtual, jmp L0<
                dec ebx
            End_While
            Mov B$ebx OpenVirtual, ecx ebx

            While B$esi <> CloseBracket
                inc esi
                On esi >= edx, error D$UnPairedNestedBracketsPtr, ecx
            End_While
            Mov B$esi CloseVirtual

        End_If
    .End_While
;;
 'ReorderSource' halas impossible, here.
 
 keeping instructions and brackets' declarations mixed together drives to many
 problems; so we now rewrite it all: at first all bracket declarations, then all
 Virtual Data and at last all EOI instructions text:
;;
    Move D$StatementsPtr D$StatementsTable, D$StatementsPtr2  D$StatementsTable2

    Mov esi D$CodeSourceA,  edi D$CodesourceB

    Mov ecx esi | add ecx D$Striplen | sub ecx 3         ; end of source adress

    On B$esi = EOI, inc esi

  ; Store, first, Brackets / VirtualBrackets:
L0: lodsb | cmp esi ecx | ja L9>>
    If al = TextSign
T0:     lodsb | cmp al TextSign | jne T0<
        jmp L0<
    End_If

    cmp al OpenVirtual | je L1>
    cmp al Openbracket | je L1>
    .If al = EOI
        If B$esi = OpenVirtual
            Call IsMixed | On eax = &TRUE, add D$StatementsPtr 4
        Else_If B$esi = OpenBracket
            Call IsMixed | On eax = &TRUE, add D$StatementsPtr 4
        Else
            add D$StatementsPtr 4
        End_If
    .End_If

    jmp L0<

  ; Brackets / VirtualBrackets found >>> adjust the Statements Table and copy:
L1: Call FillStatementsTable2 | add D$StatementsPtr 4

    stosb | Mov B$esi-1 0FF | lodsb | jmp L2> ; 0FF mark for start of [ in next part
L1: stosb | Mov B$esi-1 0 | lodsb             ; write [...brackets...]
L2: Call IsItText | je L1<                    ; for "text with CR/LF inside"
    cmp al CloseVirtual | je L3>
    cmp al Closebracket | jne L1<
L3: Mov B$esi-1 0 | stosb

    jmp L0<<

L9:  _________________________________

  ; Restart the copy for Code Statements:
L3: Mov esi D$CodeSourceA

    Move D$StatementsPtr D$StatementsTable

L4: lodsb | cmp esi ecx | jae L9>> ;!!!!!!!!!    ; je and not ja because of ending EOIs...
    .If al = 0FF
        add D$StatementsPtr 4
        While B$esi = 0 | lodsb | End_While | jmp L4<

    .Else_If al = EOI
        If B$edi-1 = EOI
            sub D$StatementsPtr 4 | sub D$StatementsPtr2 4 | dec ebx
            Call FillStatementsTable2 | add D$StatementsPtr 4 | jmp L4<<
        End_If
        Call FillStatementsTable2 | add D$StatementsPtr 4

    .Else_If al = meEOI
        On B$esi <> 0FF, jmp L8>
        On B$esi-2 = 0, jmp L4<<

    .End_If
  ; Write the instructions:
L8: stosb | jmp L4<<
  ; Last EOI:
L9: stosb | Mov eax edi | sub eax D$CodeSourceB | Mov D$Striplen eax

    Mov eax D$StatementsPtr2, D$eax 0
    Exchange D$StatementsTable D$StatementsTable2
    ;Call TestStatementsTable
    Exchange D$CodeSourceA D$CodeSourceB
ret


; Does the Statement's unfold result in mixed chunks of normal Code and of Declarations?

IsMixed:
    Push esi
        Mov al B$esi

        If al = OpenVirtual
            Mov bl CloseVirtual
        Else
            Mov bl CloseBracket
        End_If

        While B$esi <> EOI
            inc esi

            .If B$esi = bl
                On B$esi+1 = meEOI, inc esi

                If B$esi+1 = EOI
                    Mov eax &FALSE | jmp L9>
                Else_If B$esi+1 = OpenVirtual
                    Mov bl CloseVirtual
                Else_If B$esi+1 = OpenBracket
                    Mov bl CloseBracket
                Else
                    Mov eax &TRUE | jmp L9>
                End_If
            .End_If

        End_While

L9: Pop esi
ret


FillStatementsTable2:
    Push eax, ebx
        Mov eax D$StatementsPtr, eax D$eax
        Mov ebx D$StatementsPtr2, D$ebx eax
        add D$StatementsPtr2 4
    Pop ebx, eax
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

;;

  Parser of the Parameters being declared as Macros (or direct Data with Automatic Labels).
  Example:
  
  > [Return | mov eax #1]

  > Return {RGB 0_C1 0_C2 0_C3 0_A0} -> Unfold -> MOV EAX 0A0C3C2C1

;;

[ParaMacrosMaxLevel: D$ ?
 ParaMacroLevel: D$ ?
 MacroModifiedExpression: D$ ?]

ParaMacrosParser:
    Mov esi D$InstructionB, edi D$InstructionA

    Mov edx D$StripLen | add edx esi
    Mov D$ParaMacrosMaxLevel 0, D$ParaMacroLevel 0

    While esi < edx
        On B$esi = CloseParaMacro, jmp L1>
        On B$esi = OpenParaMacro, inc D$ParaMacrosMaxLevel
        movsb
    End_While

    On D$ParaMacrosMaxLevel = 0, ret

L1: Mov B$MacroModifiedExpression &TRUE

    Mov esi D$InstructionB, edi D$InstructionA, ecx D$ParaMacrosMaxLevel

    .While esi < edx
        ...If B$esi = OpenParaMacro
            inc D$ParaMacroLevel

            ..If D$ParaMacroLevel = ecx
                Push edx
                    inc esi     ; Strip 'OpenParaMacro' Char.

                    If B$esi = TextSign
                        Call UnfoldDataParameter

                    Else_If B$esi+1 = memMarker
                        Call UnfoldDataParameter

                    Else
                        Call UnfoldMacroParameter

                    End_If

                    Mov B$MacroJobIsOver &FALSE
                Pop edx

            ..Else
                movsb

            ..End_If

        ...Else_If B$esi = CloseParaMacro
            dec D$ParaMacroLevel
            movsb

        ...Else
            movsb

        ...End_If
    .End_While

    Mov ecx edi | sub ecx D$InstructionA
    Mov D$StripLen ecx
    Exchange D$InstructionA D$InstructionB
    Exchange D$InstructionAEnd D$InstructionBEnd
ret


UnfoldDataParameter:
    Call CreateNoMeanLabel | Call WriteNoMeanLabel

    Push esi
        inc esi | While B$esi <> CloseParaMacro | inc esi | End_While | inc esi

        While esi < edx | movsb | End_While
        While B$edi-1 = EOI | dec edi | End_While

        Mov B$edi meEOI, B$edi+1 '{' | add edi 2
        Call WriteNoMeanLabel | Mov B$edi ColonSign | inc edi
    Pop esi

    While B$esi <> CloseParaMacro | movsb | End_While
    Mov B$edi '}', B$edi+1 EOI, B$edi+2 EOI | add edi 3

    Mov esi edx
ret

UnfoldMacroParameter:
    Push D$Striplen
        Mov D$InstructionAptr esi, ebx esi, ecx 0

      ; clear all possible 'Done Flag's:
        While B$ebx <> CloseParamacro
            On B$ebx = 0, error D$ParaMacroPtr
            and B$ebx 00_0111_1111
            inc ecx | inc ebx
        End_While

      ; End Mark and 'Striplen', for the Macros Parser:
        Mov B$ebx EOI | Mov D$StripLen ecx

      ; Count the Macro Name Length for 'IsItInMacroList':
        Mov ebx esi, D$OneWordLen 0
        While B$ebx > LowSigns
            inc D$OneWordLen | inc ebx
        End_While

        Push esi
            Push edi
                Call GetFromQwordCheckSum esi, D$MacroList, D$MacroListLimit
                On eax = 0, error D$ParaMacroPtr

                While B$eax > LowSigns | inc eax | End_While | inc eax
                Mov esi D$eax, ecx D$eax+4

            Pop edi

            Mov D$InstructionBptr edi
            Call ReplaceFromMacroData

        Pop esi

        While B$esi <> EOI | inc esi | End_While | inc esi

    Pop D$Striplen
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;
; Mov eax (((12*3) xor 001010101)+2)

[InsideExpression: D$ ?
 StartOfSourceExpression: D$ ?
 StartOfDestinationExpression: D$ ?
 RealExpression: D$ ?
 RealHexaSize: D$ ?]

;;
 Simply searches for '(', saves Pos and Call for the translation after count of nested
 levels in ebx.

 In case of Real, i change the Mem Marker from 'R$/F$' to 'Q$/D$' because i store the
 computed Real in Hexa format (it would be far too complicated to rewrite them in
 Math Decimal notation).
;;

ExpressionParser:
    Mov edx esi | add edx D$Striplen
    Mov B$InsideExpression &FALSE, B$RealHexaSize 0
    Mov ebx 0, ecx 0

L0: .While esi < edx
        lodsb

        ..If al = TextSign
            stosb | While B$esi <> TextSign | movsb | End_While | movsb | jmp L0<
        ..Else_If al = OpenSign
            .If B$InsideExpression = &FALSE
                cmp B$esi-2 memMarker | jne L3>
                Mov al B$esi-3 | and al 00_0111_1111 ; Mask Equates and Macros Done Flag.
                cmp al 'F' | jne L1>
                    Mov B$edi-2 'D', B$RealHexaSize 8 | jmp L2>
L1:             cmp al 'R' | jne L3>
                    Mov B$edi-2 'Q', B$RealHexaSize 16
L2:                 Mov B$RealExpression &TRUE | jmp L4>
L3:             Mov B$RealExpression &FALSE
L4:             Mov ebx 0, ecx 0
                Mov D$StartOfSourceExpression esi, D$StartOfDestinationExpression edi
            .End_If
            inc ebx | inc ecx | Mov B$InsideExpression &TRUE

        ..Else_If al = CloseSign
            On ecx = 0, error D$ParenthesisPtr
            dec ecx

        ..Else_If al = OpenVirtual
            On B$InsideExpression = &TRUE, error D$ParenthesisPtr
            Call CheckBracketExpression

        ..Else_If al = Openbracket
            On B$InsideExpression = &TRUE, error D$ParenthesisPTR
            Call CheckBracketExpression

        ..Else_If al = EOI
            On B$InsideExpression = &TRUE, error D$ParenthesisPtr

        ..End_If

        ..If ebx > 0
            .If ecx = 0
                Push edx
                    If B$RealExpression = &TRUE
                        Call ComputeRealExpression
                    Else
                        Call ComputeExpression
                    End_If
                    Call WriteExpresionResult
                    Mov ebx 0, ecx 0, B$InsideExpression &FALSE
                Pop edx
                jmp L0<<
            .End_If
        ..End_If

        stosb
    .End_While
ret

;;
Due to the way the Expression Parser replaces Real by 'D$' / 'Q$' Hexa, all the
Components of a Data set with Real Expressions have to be given with a size marker.
The checking operations are repeatedly splitted for speed purpose.
;;


CheckBracketExpression:
; To be reviewed entirely. There is something out of logic at "L1":
    Push ebx
    Push eax, esi
      ; Is there any Parenthesis???
;;
        While esi < edx
            On B$esi = OpenSign, jmp L1>
            inc esi
        End_While
        jmp L9>>

      ; OK, OpenSign Inside. Is there any Real Marker???
L1:     Pop esi | Push esi
        While esi < edx
            If B$esi = MemMarker
                Mov al B$esi-1 | and al 00_0111_1111
                On al = 'F', jmp L1>
                On al = 'R', jmp L1>
            End_If
            inc esi
        End_While
        jmp L9>>
;;
        Mov ebx 0
        While esi < edx
            lodsb
            .If al = MemMarker
                Mov bl B$esi-2 | and bl 00_0111_1111

            .Else_If al = OpenSign
                If bl = 'F'
                    jmp L1>
                Else_If bl = 'R'
                    jmp L1>
                End_If

            .End_If
        End_While
        jmp L9>>


      ; OK, OpenSign plus Real Marker inside >>> Want SizeMarkers everywhere. Not
      ; 'everywhere', in fact, but before and after the Expression... :
L1:     Pop esi | Push esi
        .While esi < edx
            ...If B$esi = OpenSign
              ; MemMarker wanted before Real Expression:
                If B$esi-1 <> numSign
                    On B$esi-1 <> MemMarker, error D$MarkerBeforePtr
                End_If

                Mov eax 1
                While eax > 0
                    inc esi
                    If B$esi = OpenSign
                        inc eax
                    Else_If B$esi = CloseSign
                        dec eax
                    End_If
                    On B$esi = CloseBracket, error D$ParenthesisPtr
                    On B$esi = CloseVirtual, error D$ParenthesisPtr
                End_While

              ; Now, ebx at the end of Expression. CloseBracket >>> OK:
                cmp B$esi+1 CloseBracket | je L9>
                cmp B$esi+1 CloseVirtual | je L9>

                inc esi | On B$esi > Separators, error D$MarkerAfterPtr

                Push esi
                    inc esi
                    While B$esi > PartEnds
                        inc esi
                    End_While
                    .If B$esi = ColonSign
                        On B$esi+2 <> MemMarker, error D$MarkerAfterPtr
                    .Else_If B$esi <> MemMarker
                        Error D$MarkerAfterPtr
                    .End_If
                Pop esi

            ...End_If
L8:         inc esi
        .End_While

L9: Pop esi, eax
    Pop ebx
ret


[ExpressionResult: D$ ? ?
 Operator: D$ ?]

[ExpressionA: D$ ?
 ExpressionB: D$ ?]

[ExpressionAPtr: D$ ?
 ExpressionBPtr: D$ ?]

[ExpressionALimit: D$ ?
 ExpressionBLimit: D$ ?]

InitExpressionBuffers:

    Call VirtualAlloc ExpressionA,
                      PAGE_SIZE

    add eax 0800

    Mov D$ExpressionALimit eax,
        D$ExpressionAPtr eax

    Call VirtualAlloc ExpressionB,
                      PAGE_SIZE

    add eax 0800

    Mov D$ExpressionBLimit eax,
        D$ExpressionBPtr eax

ret

; Main parsing of one Expression. Calls for storage (in Binary) and for re-write after
; computation, from the more inside level to first one:

ComputeExpression:

    Push esi

        Mov ecx esi, esi D$StartOfSourceExpression, edi D$ExpressionA
        dec esi | sub ecx esi | rep movsb            ; copy the Expression to 'ExpressionA'.
        Mov al 0 | stosb

L0:     Mov D$ExpressionResult 0, D$ExpressionResult+4 0, B$Operator OpenSign
        Mov esi D$ExpressionA, edi D$ExpressionB, edx 0

        Push ebx
L1:         lodsb | stosb | cmp al OpenSign | jne L1<
                dec ebx | jnz L1<
        Pop ebx

        If edi > D$ExpressionBLimit

            Call ExtendTableMemory ExpressionA,
                                   ExpressionAPtr,
                                   ExpressionALimit

            Call ExtendTableMemory ExpressionB,
                                   ExpressionBPtr,
                                   ExpressionBLimit

        End_If

L2:     On B$esi = Space, inc esi
        Mov eax D$esi | and al 00_0111_1111     ; clear possible 'Done Flag'.

        ...If al >= 'A'
            ..If ax = 'OR'
                Mov B$Operator 'O' | add esi 2 | On B$esi = Space, inc esi
            ..Else_If ax = 'XO'
                If B$esi+2 = 'R'
                    Mov B$Operator 'X' | add esi 3 | On B$esi = Space, inc esi
                Else
                    jmp L9>> ;error D$ExpressionMemberPtr
                End_If
            ..Else_If al = 'S'
                If W$esi+1 = 'HL'
                    Mov B$Operator 'L' | add esi 3 | On B$esi = Space, inc esi
                Else_If W$esi+1 = 'HR'
                    Mov B$Operator 'R' | add esi 3 | On B$esi = Space, inc esi
                Else
                    jmp L9>> ;error D$ExpressionMemberPtr
                End_If
            ..Else_If ax = 'AN'
                If B$esi+2 = 'D'
                    Mov B$Operator 'A' | add esi 3 | On B$esi = Space, inc esi
                Else
                    jmp L9>> ;error D$ExpressionMemberPtr
                End_If
            ..Else_If ax = 'NO'
                If B$esi+2 = 'T'
                    Mov B$Operator 'N' | add esi 3 | On B$esi = Space, inc esi
                Else
                    jmp L9>> ;error D$ExpressionMemberPtr
                End_If
            ..Else
                jmp L9>> ;error D$ExpressionMemberPtr
            ..End_If

        ...Else_If al < '0'
            Move D$Operator D$esi | Mov B$Operator al | inc esi

        ...Else_If al <= '9'
            Push ebx
                If ax = '00'
                    Call TranslateBinary | dec esi | Call StoreOnExpression
                Else_If al = '0'
                    Call TranslateHexa | dec esi | Call StoreOnExpression
                Else
                    and B$esi 00_0111_1111
                    Call TranslateDecimal | dec esi | Call StoreOnExpression

                End_If
            Pop ebx

        ...Else
            jmp L9>> ;error D$ExpressionMemberPtr

        ...End_If

        cmp B$esi-1 CloseSign | jne L2<<
            Call ReWriteExpression
            dec ebx | jnz L0<<
L9: Pop esi
    ret


[ExpressionReal: R$ ?
 RealExpressionResult: R$ ?]

ComputeRealExpression:
    On ebx > 1, error D$RealNotationPtr

    Push esi
        Mov ecx esi, esi D$StartOfSourceExpression, edi D$ExpressionA
        dec esi | sub ecx esi ;| rep movsb          ; copy the Expression to 'ExpressionA'.
      ; Since the Expression parser has moved in between the Equates and Macros jobs,
      ; we have to mask out the Byte HighBit (Done Flag):
L0:     lodsb | and al 00_0111_1111 | stosb | loop L0<
        Mov al 0 | stosb


L0:     Mov D$RealExpressionResult 0, D$RealExpressionResult+4 0, B$Operator OpenSign
        Mov esi D$ExpressionA, edi D$ExpressionB, edx 0

        Push ebx
L1:         lodsb | stosb | cmp al OpenSign | jne L1<
                dec ebx | jnz L1<
        Pop ebx

L2:     On B$esi = Space, inc esi

        ...If B$esi < '0'
            Move D$Operator D$esi | inc esi

        ...Else_If B$esi <= '9'
            Push ebx
                Mov edi ExpressionReal | Call atof      ; Result in ST0
                dec esi
                Call StoreOnRealExpression
            Pop ebx

        ...Else
            error D$RealNotationPtr

        ...End_If

        cmp B$esi CloseSign | jne L2<<
            Call ReWriteRealExpression
            dec ebx | jnz L0<<

L9: Pop esi
ret

StoreOnExpression:
    ..If B$Operator >= 'A'
        .If B$Operator = 'O'
            or D$ExpressionResult+4 edx | or D$ExpressionResult eax

        .Else_If B$Operator = 'X'
            xor D$ExpressionResult+4 edx | xor D$ExpressionResult eax

        .Else_If B$Operator = 'N'
            On D$ExpressionResult > 0, error D$ExpressionNOTPtr
            On edx > 0, error D$ExpressionNOTPtr
            not eax
            Mov D$ExpressionResult eax

        .Else_If B$Operator = 'A'
            and D$ExpressionResult+4 edx | and D$ExpressionResult eax

        .Else_If B$Operator = 'L'
            On edx > 0, error D$ExpressionSHRPtr
            On eax > 0FF, error D$ExpressionSHRPtr
                Mov cl al
                shl D$ExpressionResult+4 cl
                shl D$ExpressionResult cl | adc D$ExpressionResult+4 0

        .Else_If B$Operator = 'R'
            On edx > 0, error D$ExpressionSHRPtr
            On eax > 0FF, error D$ExpressionSHRPtr
                Mov cl al
                shr D$ExpressionResult cl
                shr D$ExpressionResult+4 cl | adc D$ExpressionResult 0

        .Else
            Mov D$ExpressionResult+4 edx, D$ExpressionResult eax

        .End_If

    ..Else_If B$Operator = AddSign
        add D$ExpressionResult+4 edx | add D$ExpressionResult eax

    ..Else_If B$Operator = SubSign
        sub D$ExpressionResult+4 edx | sub D$ExpressionResult eax

    ..Else_If B$Operator = MulSign
        On edx > 0, error D$TooMuchExpressionPtr
        On D$ExpressionResult+4 > 0, error D$TooMuchExpressionPtr
        Mov ecx eax, eax D$ExpressionResult
        mul ecx
        Mov D$ExpressionResult+4 edx | Mov D$ExpressionResult eax

    ..Else_If B$Operator = DivSign
        Mov ecx eax, eax D$ExpressionResult, edx D$ExpressionResult+4
        div ecx | Mov edx 0
        Mov D$ExpressionResult+4 0 | Mov D$ExpressionResult eax

    ..Else_If B$Operator = OpenSign
        Mov D$ExpressionResult+4 edx, D$ExpressionResult eax

    ..Else
        error D$ExpressionSignPtr

    ..End_If
ret


; The result of new computed Value is in ST0.

[TempoReal: Q$ ?]

StoreOnRealExpression:
    ..If B$RealHexaSize = 8
        fstp F$TempoReal | fld F$RealExpressionResult
        .If B$Operator = AddSign
            fadd F$TempoReal
        .Else_If B$Operator = SubSign
            fsub F$TempoReal
        .Else_If B$Operator = MulSign
            fmul F$TempoReal
        .Else_If B$Operator = DivSign
            fdiv F$TempoReal
        .Else_If B$Operator = OpenSign
            fld F$TempoReal
        .Else
            error D$RealNotationPtr
        .End_If
        fstp F$RealExpressionResult
    ..Else
        fstp R$TempoReal | fld R$RealExpressionResult
        .If B$Operator = AddSign
            fadd R$TempoReal
        .Else_If B$Operator = SubSign
            fsub R$TempoReal
        .Else_If B$Operator = MulSign
            fmul R$TempoReal
        .Else_If B$Operator = DivSign
            fdiv R$TempoReal
        .Else_If B$Operator = OpenSign
            fld R$TempoReal
        .Else
            error D$RealNotationPtr
        .End_If
        fstp R$RealExpressionResult
    ..End_If
ret


[StartOfHexaExpression: D$ ?]

ReWriteExpression:
    Push ebx
        On edx > 0, error D$TooMuchExpressionPtr
        Mov esi D$ExpressionA, edi D$ExpressionB

L1:     lodsb | stosb | cmp al OpenSign | jne L1<
                dec ebx | jnz L1<
        dec edi                                         ; skip first '('.
        Mov eax D$ExpressionResult

        Mov ebx eax, ecx 8, B$StartOfHexaExpression &TRUE

L0:     Mov eax ebx | and eax 0_F000_0000 | shr eax 28
        add al '0' | On al > '9', add al 7
        shl ebx 4
        .If B$StartOfHexaExpression = &TRUE
            If al > '0'
                Mov B$StartOfHexaExpression &FALSE
                Mov B$edi '0' | inc edi
            End_If
        .End_If
        On B$StartOfHexaExpression = &FALSE, stosb | loop L0<

        If B$StartOfHexaExpression = &TRUE              ; Case of result = 0
            Mov B$edi '0' | inc edi
        End_If

        While B$esi-1 <> CloseSign
            inc esi                                     ; jmp over resolved part.
        End_While

        If B$esi > PartEnds
            Mov al Space | stosb
        End_If

        While B$esi-1 > 0
            movsb                       ; recopy remainder of expression.
        End_While
        Exchange D$ExpressionA D$ExpressionB
        Exchange D$ExpressionALimit D$ExpressionBLimit
    Pop ebx
ret


ReWriteRealExpression:
    Push ebx
       ; On edx > 0, error TooMuchExpression ; ??????!!!!!!......
        Mov esi D$ExpressionA, edi D$ExpressionB

L1:     lodsb | stosb | cmp al OpenSign | jne L1<
                dec ebx | jnz L1<
        dec edi                                         ; skip first '('.

        Mov ecx D$RealHexaSize, B$StartOfHexaExpression &TRUE

        If ecx = 16
            Mov ebx D$RealExpressionResult+4
        Else
            Mov ebx D$RealExpressionResult
        End_If

L0:     Mov eax ebx | and eax 0_F000_0000 | shr eax 28
        add al '0' | On al > '9', add al 7
        shl ebx 4
        .If B$StartOfHexaExpression = &TRUE
            If al > '0'
                Mov B$StartOfHexaExpression &FALSE
                Mov B$edi '0' | inc edi
            End_If
        .End_If
        On ecx = 9, Mov ebx D$RealExpressionResult
        On B$StartOfHexaExpression = &FALSE, stosb | loop L0<

        If B$StartOfHexaExpression = &TRUE              ; Case of result = 0
            Mov B$edi '0' | inc edi
        End_If

        While B$esi-1 <> CloseSign
            inc esi                                     ; jmp over resolved part.
        End_While

        If B$esi > PartEnds
            Mov al Space | stosb
        End_If

        While B$esi-1 > 0
            movsb                                       ; recopy remainder of expression.
        End_While
        Exchange D$ExpressionA D$ExpressionB
        Exchange D$ExpressionALimit D$ExpressionBLimit
    Pop ebx
ret


; True final result rewrite in source:

WriteExpresionResult:
    Push esi
        Mov edi D$StartOfDestinationExpression, esi D$ExpressionA
      ; (Expression 'A' and not 'B' as source, because they are switched after each pass).

      ; SourceCleaner may leave one more SpAce when ",(" encounted >>> to review.
        If B$edi-1 <> Space
            .If B$edi-1 > NoSpaceAfterThis
               ; Mov al Space | stosb
            .End_If
        End_If

        While B$esi > 0
            movsb
        End_While
;;
   ; For Analyzes:
  
        Push edi
            Mov B$edi 0
            Mov edi D$StartOfDestinationExpression
            sub edi 3
            howme edi
            exprint D$edi
        Pop edi
;;
    Pop esi
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
 Routines for adressing the lists used for data, data labels and code labels
 three main tables are used:
                              DataList, LabelList, CodeRef.
 DataList is a simple list of double words values. LabelList is a index for DataList
 (set of couples of name / adress pointing to DataList). CodeRef is an index
 (same couples structure), pointing to code symbols evocation (offset in code).

 The two index tables are sets of fields like this:
                             ...|MySymbol|000024A0...|...

 Tables will begin with a dWord for the size in bytes. (of little use)


 Filling certain heads words with zeros is usefull in case of error search
;;

[ListsLength: D$ ?]

InitIndex1:
;;
  None of these tables should be greater than stripLen.
  For a big file like RosAsm source, it makes about 3 Mo. for the 11 tables together
  could be much shorter, if any problem, mainly for last 4 tables.
  
  Though, because of Macros possibly creating Data Labels, for example, it is
  possible to overflow easily, particulary on very small files. So one Page is
  added to these Allocations.
  
  Also 'ListsLength', that is used in 'GetFromQwordCheckSum' for controling the
  matching of a scanned Name with its proper List, must be aligned on its final
  - and not so predictable - size (AlignOn 01000).
;;
    add D$StripLen 01000

    Move D$ListsLength D$StripLen
    AlignOn 01000 D$ListsLength

    Call VirtualAlloc LabelList,
                      D$StripLen

    Mov edi D$LabelList | Mov eax 0 | stosd
    Mov al EOI | stosb | Mov D$LabelListPtr edi
    add edi D$StripLen | sub edi TABLES_SECURITY | Mov D$LabelListLimit edi

    Call VirtualAlloc EquateList,
                      D$StripLen

    Mov edi D$EquateList | Mov eax 0 | stosd
    Mov al EOI | stosb | Mov D$EquateListPtr edi
    add edi D$StripLen | sub edi TABLES_SECURITY | Mov D$EquateListLimit edi

    Call VirtualFree EquateSubstitutes

    Call VirtualAlloc EquateSubstitutes,
                      D$StripLen

    Mov edi D$EquateSubstitutes | Mov D$EquateSubstitutesPtr edi
    add edi D$StripLen | sub edi TABLES_SECURITY
    Mov D$EquateSubstitutesLimit edi
    Move D$LastEquateList D$EquateList
    Move D$LastEquateListPtr D$EquateListPtr

    Call VirtualAlloc MacroList,
                      D$StripLen

    Mov edi D$MacroList | Mov eax 0 | stosd
    Mov al EOI | stosb | Mov D$MacroListPtr edi
    add edi D$StripLen | sub edi TABLES_SECURITY | Mov D$MacroListLimit edi

    Call VirtualAlloc MacroData,
                      D$StripLen

    Move D$MacroDataPtr D$MacroData
    Mov eax D$MacroData | add eax D$StripLen | sub eax TABLES_SECURITY
    Mov D$MacroDataLimit eax

    sub D$StripLen 01000
ret


InitIndex2:
  ; Don't supress reloc table: Pointers needed for setting of other values:
    Call VirtualAlloc Relocation,
                      D$StripLen

    Move D$RelocationPtr D$Relocation

    Call VirtualAlloc ApiListA,
                      D$StripLen

    Move D$ApiListAPtr D$ApiListA

    Call VirtualAlloc ApiListB,
                      D$StripLen

    Move D$ApiListBPtr D$ApiListB

    Call VirtualAlloc DllList,
                      D$StripLen

    Move D$DllListPtr D$DllList

ret


InitIndex3:

    Call VirtualFree DllList

    Call VirtualFree ApiListB

    Call VirtualFree ApiListA

    Call VirtualAlloc CodeRef,
                      D$StripLen

    Mov edi D$CodeRef | Mov eax 0 | stosd
    Mov al EOI | stosb | Mov D$CodeRefPtr edi

    Call VirtualAlloc DataRef,
                      D$StripLen

    Mov edi D$DataRef | Mov eax 0 | stosd
    Mov al EOI | stosb | Mov D$DataRefPtr edi
    Mov eax D$StripLen | add eax D$DataRef | sub eax TABLES_SECURITY
    Mov D$DataRefLimit eax
ret

 ________________________________________________________________________________________
 ________________________________________________________________________________________
;;
 analyze of data declarations and macros (+ equates)

 Macros and equates bodies are all stored in MacroData. MacroList and EquateList
 could also be only one table, but i choose to separate them because i wanted to
 alternate the two replacement routines (see ReplaceEquatesAndMacros) for flow
 control (source goes forth and back between CodeSourceA and CodeSourceB) and
 because i wanted equate to be replaced in macro statement 'before' expanding job
 Third reason: A macro is always first word of a line / equates may be anywhere
 in a line; so, the job is different.
 ________________________________________________________________________________________

 MacroList looks  ....|name|dWord1 dWord2 Byte|....
                            dWord1 = adress in MacroData
                                  dWord2 = lenght of statement(s)
                                         byte is set to 0 when storing
 This byte is not for expanding control. It is only for end user can check if unsused
 macro are in his source file (The "Unused Symbols" thingie in the Statistics)

 EquateList looks the same.

 MacroData is a simple text list of what is to replace equates and macros without
 any separators.

 EquateList:
 MacroList:         ; storage of macros and equates ...|name|adr/len/flag|...
 MacroData:         ; raugh storage of macros and equates body(no lenght as first word)
;;
 _______________________________________________________________________________________

[LoadAndClear | lodsb | mov B$esi-1 0]
 _______________________________________________________________________________________

; MacroList begin with a Dword for lenght of table followed by macro items.
 _______________________________________________________________________________________

[LastOctetInSource: D$ ?]

StoreEquates:
    Mov edi D$EquateListPtr,  B$esi-1 0FF

    If edi > D$EquateListLimit
        Call ExtendTableMemory EquateList, EquateListPtr, EquateListLimit
        Mov edi D$EquateListPtr
    End_If

L0: Push esi | Mov ebx 0
L1:     lodsb | inc ebx | cmp al LowSigns | ja L1<
    Pop esi | dec ebx | ;Call IsItNewEquate  ; with lenght in ebx

L1: LoadAndClear
    If al = Closebracket
        Error D$MissEquateValPtr
    Else_If al = ColonSign
        While B$edi-1 <> EOI | dec edi | End_While
        Error D$EquateLabelPtr edi
    End_If
    cmp al, Space | je L2>                  ; write name in EquateList up to first space
    On al < LowSigns, error D$MissEquateValPtr
        stosb | jmp L1<
L2: Mov al EOI | stosb
    Mov eax D$MacroDataPtr | stosd          ; write futur adress of data in Macrolist

    Call SetQwordCheckSum D$EquateListPtr

    Mov D$EquateListPtr edi                 ; save pointer
    Mov edi eax                             ; switch from index to data

L3: loadAndClear | cmp al Separators | jb L9>   ; write equate body
    cmp al Closebracket | je L9>            ; in macroData

    .If al = TextSign
        stosb
L4:     loadAndClear | stosb | cmp al TextSign | jne L4<

    .Else_If al = '<'
        On B$esi = SpAce, LoadAndClear
L4:     loadAndClear | cmp al '>' | je L3<
        On al = Closebracket, error D$TextEquatePtr
        stosb
      ; If Space before '>', strip Space:
        If B$esi = Space
            On B$esi+1 = '>', LoadAndClear
        End_If
        jmp L4<

    .Else
        stosb

    .End_If
    jmp L3<

L9: Mov bl al                               ; save lasting sign for ending test
    Mov eax edi | sub eax, D$macroDataPtr   ; written data lenght in ax
    Mov D$MacroDataPtr edi                  ; save pointer
    If edi > D$MacroDataLimit
        Call ExtendTableMemory MacroData, MacroDataPtr, MacroDataLimit
    End_If
    Mov edi D$EquateListPtr | stosd         ; store data lenght in MacroList (second word)
    Mov al 0 | stosb                        ; room for 'done' flag used when replacing
    Mov al EOI | stosb
    Mov D$EquateListPtr edi                 ; save pointer
    cmp bl Separators | jb L0<<             ; one more equate > store again
ret

_______________________________________________________________________________________

StoreMacros:
    Mov edi D$MacroListPtr,  B$esi-1 0

    If edi > D$MacroListLimit
        Call ExtendTableMemory MacroList, MacroListPtr, MacroListLimit
        Mov edi D$MacroListPtr
    End_If

    Push esi
        Mov ebx 0
L0:     lodsb | inc ebx | cmp al LowSigns | ja L0<
    Pop esi
    dec ebx | ;Call IsItNewMacro           ; with symbol lenght in ebx

L1: LoadAndClear | cmp al meEOI | je L2>  ; write name in MacroList up to first separator
        stosb | jmp L1<

L2: Mov al EOI | stosb                    ; no meEOI in MacroList (yes in MacroData)
    Mov eax D$MacroDataPtr | stosd        ; write futur adress of data in Macrolist

    Call SetQwordCheckSum D$MacroListPtr

    Mov D$MacroListPtr edi                ; save pointer
    Mov edi eax                           ; switch EDI from index to data

L3: LoadAndClear | cmp al CloseBracket | je L9>
        stosb | jmp L3<                   ; write macro body and loop
L9: Mov eax edi | sub eax D$macroDataPtr  ; written data lenght in eax
    Mov D$MacroDataPtr edi

    If edi > D$MacroDataLimit
        Call ExtendTableMemory MacroData, MacroDataPtr, MacroDataLimit
    End_If

    Mov edi D$MacroListPtr

    stosd                                 ; store data lenght in MacroList (second word)
    Mov al 0 | stosb                      ; room for 'done' flag used when replacing
    Mov al EOI | stosb
    Mov D$MacroListPtr edi
ret
 ________________________________________________________________________________________

; here we use 'LastOctetInSource' instead of checking '||'

StripZeros:
    Mov esi D$CodeSourceA,  edi D$CodeSourceB,  ebx 0
L0: lodsb | cmp esi D$LastOctetInSource | jae L9>>
        cmp al 0FF | je L0<
        cmp al 0 | je L0<

L1:     .If al = EOI                            ; difficulty: double separators '||' may
            If B$edi-1 = meEOI                  ; result after storage. case: '|[....]|'
                Mov B$edi-1 EOI | jmp L0<       ; same on second pass after '{}'.
            Else_If B$edi-1 = EOI
                jmp L0<
            End_If

        .Else_If al = meEOI
            If B$edi-1 = meEOI
                jmp L0<
            Else_If B$edi-1 = EOI
                jmp L0<
            End_If

        .End_If

L5: stosb | inc ebx | jmp L0<<
L9: Mov al EOI | stosb | inc ebx | Mov D$StripLen ebx
    Mov eax 02020202 | stosd                    ; security

    Exchange D$CodeSourceA D$CodeSourceB
ret


StripDoneStatementsPointers:
    Mov esi D$StatementsTable, edi esi

L0: lodsd
    If eax = FLAG_DONE
        jmp L0<
    Else_If eax > 0
        stosd | jmp L0<
    End_If

    stosd

; Test of Last recorded Code Statement:

;    Mov eax edi | sub eax 8 | Mov eax D$eax
;
;    Mov ebx eax, dl B$ebx+3, B$OldChar dl, B$ebx+3 0
;    pushad
;        Mov esi eax
;        Call SetDebuggeeText
;        Call AskForRedraw
;    popad
;    exprint eax

ret
 _______________________________________________________________________________________

; after storing equates and macros, stripped results of remaining source will be
; written from CodeSourceA to CodeSourceB.
; At last, StripZero will work back again < > A
 _______________________________________________________________________________________
[FirstPassTest: D$ ?]

StoreAllEquates:
    Mov B$FirstPassTest 0

    Mov esi D$CodeSourceA,  ecx D$StripLen | add ecx esi | inc ecx  ; ecx = max esi value
    Mov D$LastOctetInSource ecx,  B$ErrorLevel 0,  D$bracketCounter 0
    Move D$StatementsPtr D$StatementsTable | sub D$StatementsPtr 4

L0: lodsb | Call IsItText | je L0<
        cmp al EOI | je L9>>                        ; EOI >>> no more brackets.
    cmp al OpenVirtual | jne L1>
        inc D$bracketCounter
        add D$StatementsPtr 4 | jmp L0<
L1: cmp al Openbracket | jne L0<                    ; loop until '['
        inc D$bracketCounter
        add D$StatementsPtr 4
        Push esi
        cmp B$esi '<' | jne L2>                     ; Data Alignement?
       ; cmp B$esi+1 '0' | jb L2>
       ; cmp B$esi+1 '9' | ja L2>
        or B$esi 00_1000_0000  ; to prevent ReplaceEquates from replacing '[<' by '[B' in
                               ; case user define an Equate for '<' Char (not reserved Char)
        Pop eax | jmp L0<
L2:     lodsb | cmp al, OpenParaMacro | ja L2<
            Mov ecx esi                             ; for end reached test
        Pop esi
    cmp al ColonSign | jne L3>                      ; data?
        Mov esi, ecx | jmp L0<
L3: cmp al Space | jne L3>                          ; equate?
        Call StoreEquates
            Mov eax D$StatementsPtr, D$eax FLAG_DONE
        jmp L0<
L3: cmp al meEOI | je L0<                           ; macro?

L3: Error D$UnknownDataPtr

L9: Mov edi D$EquateListPtr, ecx 20 | rep stosb     ; '|||||||' as security tail
    Mov eax, D$EquateListPtr | sub eax, D$EquateList; write size of equate list
    Mov edi, D$Equatelist | inc eax | stosd         ; at first word
ret


StoreAllMacros:
    Mov esi D$CodeSourceA,  ecx D$StripLen | add ecx esi | inc ecx  ; ecx = max esi value
    Mov D$LastOctetInSource ecx,  B$ErrorLevel 0,  D$bracketCounter 0
    Move D$StatementsPtr D$StatementsTable | sub D$StatementsPtr 4

L0: lodsb | Call IsItText | je L0<
    cmp al EOI | je L9>                             ; EOI >>> no more brackets.
    cmp al OpenVirtual | jne L1>
        inc D$bracketCounter
        add D$StatementsPtr 4 | jmp L0<
L1: cmp al 0FF | je L8>
    cmp al Openbracket | jne L0<                    ; loop until '['
    cmp B$esi '<' | je L0<
L7:     inc D$bracketCounter
        add D$StatementsPtr 4
        Push esi
L2:         lodsb | cmp al, LowSigns | ja L2<
            Mov ecx esi                             ; for end reached test
        Pop esi

L3: cmp al meEOI | jne L0<                          ; macro?
        On B$esi = meEOI, error D$UnexpectedCRLFPtr
        Call storeMacros
            Mov eax D$StatementsPtr, D$eax FLAG_DONE
        jmp L0<

L8: lodsb | cmp al 0 | je L8<
    inc D$bracketCounter
    add D$StatementsPtr 4
    dec esi | jmp L0<<

L9: Mov edi D$MacroListPtr, ecx 20 | rep stosb      ; '|||||||' as security tail
    Mov eax, D$MacroListPtr | sub eax D$MacroList   ; write size of macro list
    Mov edi, D$Macrolist | inc eax | stosd          ; at first word
ret


StoreEquatesAndMacros:
    Call StoreAllEquates
    Call ResolveEquates
    Call StoreAllMacros
    Call StripZeros

    Call StripDoneStatementsPointers
  ; Source: A > B
  ; Call TestStatementsTable
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[SortTempoMemory: D$ ?]

;;
 Source and Destination are Pointers to 2 Tables (same lenght). Source holds a set
 of zero ended strings to be sorted and stored in Destination. Source is overwritten
 with 0FF Bytes when finished.
;;
[SortSource: D$ ?
 SortDestination: D$ ?
 SortStringNumber: D$ ?]


; Pointers by Sizes: Each dWord will be (possibily -0, if none-) a Pointer to the
; position of the first Equate Equate in the List having the 'given' number of Chars.
; ('given' by the Routine that will finally *search* for the Equate body:
[LabelsPointersBySizes: @EquatesPointersBySizes: D$ ? # 100]

[SortBySizeOver: D$ ?]

; input: EBX = lenght of researched label set by caller; >ESI > first letter of new label

[SearchMain: D$ ?]
SearchForEntryPoint:
    Mov B$SearchMain &TRUE
        Call GetFromQwordCheckSum EntryPointLabel, D$LabelList, D$LabelListLimit
        If eax = 0
            Mov B$ErrorLevel 9
            error D$NoEntryPtr
        End_If

        While B$eax <> EOI | inc eax | End_While | inc eax
        or B$eax+4 FLAG_DONE
        Mov eax D$eax

    Mov B$SearchMain &FALSE
ret

 _________________________________________________________________________________________
;;
 replacements of equates and macro evocation of source file
                              source: < > A
 ReplaceMacAndEqu reads one word from source and Call IsItInMacroList. If yes, this
 called routine returns, after read in Macrolist, in ECX the lenght of stored text
 data in MacroData and in ESI the offset of these data.
 Then, ReplaceMacAndEqu calls ReplaceFromMacroData to read these data and write them
 in destination file (a new 'source file'). If a '#' symbol is encounted, in turn,
 ParametersUnfolding is called to read the source parameters
 ________________________________________________________________________________________

 input: InstructionBptr point one text word and OneWordLen gets its lenght; al = last
 character of a one word.
 to avoid a same symbol be booth a label and an equate/macro, no unfolding before ':'
;;

[OneWordLen: D$ ?]

 _______________________________________________________________________________________
;;
 Effective replacement of macros:
 It allows loop if '#+n' statement found at the end of declaration, while getting
 control on parameters number when needed....
 Constant First parameter allowed with '#F'. Last one, with '#L'
 Reverse job allowed with '#n' and global replacement with #x>y'

 Very simple for user > very difficult inside...
;;
 _______________________________________________________________________________________

[AfterLastParameter: D$ ?
 NumberOfMacroParameters: D$ ?
 LastMacPara: D$ ?
 FirstUnfolded: D$ ?
 LastUnfolded: D$ ?
 UnfoldingRotations: D$ ?]

SearchLastParameter:
    Push esi
        Mov B$LastMacPara '0', D$NumberOfMacroParameters 0 | Mov esi D$InstructionAptr

      ; Number of spaces >>> Number of Parameters:
        lodsb
        While al > EOI
            If al = space
L1:             inc B$LastMacPara
                inc D$NumberOfMacroParameters
           ; Else_If al = ColonSign
           ;     On B$esi <> EOI, jmp L1<
            End_If
            lodsb
        End_While

        dec esi | Mov D$AfterLastParameter esi
    Pop esi
ret


[NoLabel: D$ ?
 NoSizeMarker: D$ ?]

; Unfolds one parameter

ParameterUnfolding:
    Mov B$NoLabel &FALSE, B$NoSizeMarker &FALSE
    .If B$esi = '!'
        inc esi
        If B$esi = '!'
            inc esi | Mov B$NoSizeMarker &TRUE
        Else
            Mov B$NoLabel &TRUE
        End_If
    .End_If
    Push ecx, esi
        Mov bl al | cmp bl 'F' | jne L0>    ; 'x' of #x in bl
            Mov bl '1' | jmp L6>>
L0:     cmp bl, 'L' | jne L1>
            Mov bl B$LastMacPara | jmp L6>>
L1:     cmp bl 'N' | jne L2>
            Mov bl B$LastMacPara ; | add bl B$MacrosX ; ah have been 'neg'ed
        ;    On bl = '1',  Mov B$FirstUnfolded &TRUE | jmp L6>>

L2:     On bl < '1',  error D$MacNumberPtr
        On bl > '9',  error D$MacNumberPtr
        add bl B$MacrosX | On bl = '1',  Mov B$FirstUnfolded &TRUE
        On bl = B$LastMacPara,  Mov B$LastUnfolded &TRUE
        ...If B$esi >= '0'
            ..If B$esi <= '9'
              ; Extreemely durty hack to inc _ESI_ and dec ECX: (!!!!!!!!!!!!!!!!!)
                Pop eax, ecx
                    inc eax | dec ecx
                Push ecx, eax
                sub bl '0' | lea ebx D$ebx*4+ebx | shl ebx 1
                lodsb | sub al '0' | add bl al
                add bl '0'
                .If B$esi >= '0'
                    If B$esi <= '9'
                        error D$TooBigXpTR
                    End_If
                .End_If
            ..End_If

        ...End_If

L6:     Mov esi D$InstructionAptr                ; switch from MacroData to clean Code Source (A)

L7:     lodsb                                  ; and search parameter
        On al =< EOI, error D$MissingParameterPtr
        cmp al space | jne L7<                 ; spaces count gives
        inc ecx
            dec bl | cmp bl, '0' | jne L7<       ; parameter position
        and B$esi 00_0111_1111                 ; Strip Equates-done-Flag, if any, because
                                                 ; it may corrupt macro-built-symbols.
        On B$NoSizeMarker = &TRUE, add esi 2

L8:     lodsb | cmp al Separators | jb L9>     ; read in sourceA
        stosb | jmp L8<                        ; write parameter in destination (SourceB)

L9: Pop esi, ecx
    If B$NoLabel = &TRUE
       dec edi, ecx
       On B$edi = TextSign, error D$TextKillingPtr
    Else_If B$NoSizeMarker = &TRUE
        sub ecx 2
    End_If
ret


MultiParaCheck:
    cmp al 'F' | jne L0>
        Mov al '1' | jmp L9>
L0: cmp al 'L' | jne L1>
        Mov al B$LastMacPara | jmp L9>
L1: On al = 'N',  error D$NForbidenPtr
L2: On al < '1',  error D$MacNumberPtr
    On al > '9',  error D$MacNumberPtr
L9: ret
 ____________________________________________
;;
 #
 2   >  al  > bl  |               |  >  al
 >                |  >  xchg  >   |
 L          > al  |               |  >  bl
;;
 ____________________________________________


MultiParametersUnfolding:               ; #x>y  has been found  al = x
   ; On ah > 0, error MacNumber
    On B$MacrosX > 0, error D$MacNumberPtr
    Call MultiParacheck

    dec ecx | Mov bl al | lodsb         ; ecx = lenght from 'IsItInMacroList'
    dec ecx | lodsb                     ; bl = x   al = y
    Call MultiParacheck

    Push esi, ecx
        Mov esi D$InstructionAptr              ; switch from MacroData to clean Code Source
        xchg al bl | cmp al bl | ja L2>

L1:     Call UnfoldOneOfMultiPara | inc al | cmp al bl | jna L1<
            jmp L9>

L2:     Call UnfoldOneOfMultiPara | dec al | cmp bl al | jna L2<

L9: Pop ecx, esi
ret


UnfoldOneOfMultiPara:
    Push eax ebx
        Mov bl al | Mov esi D$InstructionAptr

      ; Search parameter:
L1:     lodsb
        On al <= EOI, error D$MissingParameterPtr
      ; Spaces count gives parameter position:
        cmp al space | jne L1<
            dec bl | cmp bl, '0' | jne L1<

L2:     lodsb | cmp al, Separators | jb L8>
          ; Cases of Text Parameters (???...):
            If al = TextSign
                stosb
                While B$esi <> TextSign | movsb | End_While
                movsb | jmp L2<
          ; Case of {... #2>L} nested Declarations found in Macro Declarations:
            Else_If al = '}'
                error {"| wanted between Multiple Parameters and '}', in Macro Declaration" EOS},
                      D$InstructionAptr
            End_If
          ; write parameter in destination
            stosb | jmp L2<
L3:         dec D$AfterLastParameter
      ; Space forced (avoid '|' when reading, at first, the last parameter)
L8:     Mov al space | stosb
L9: Pop ebx eax
ret
;;
; I do not recall the reason why i did this strange '}' thingie, previously:
L2:     lodsb
        cmp al, Separators | jb L9>
        cmp al '}' | je L3>
          ; write parameter in destination
            stosb | jmp L2<
L3:         dec D$AfterLastParameter
      ; Space forced (avoid '|' when reading at first the last parameter)
L9:     Mov al space | stosb                   
    Pop ebx eax
ret
;;

;;
  These are the 128 Bytes Tables for storing whatever the user wants to store:
  The internal macros Variables, &0, &1,... , &99:
;;

[MacrosVariablesTable: D$ ? # (32*102)]
[MacroCounters: D$ ? # 100]
[MACRO_VARIABLES 100]

ClearMacroVariable:
    Mov edi MacrosVariablesTable, ecx ((32*102)+100), eax 0 | rep stosd
ret


[MixedInternalVariables: B$ 'You cannot mix Internal Variables by text and by Number' EOS]
[CounterSyntax: B$ "Macros Counters syntax example:
&&21=&&21+1 // &&3=&&60-1 // &&5=0" EOS]

StoreMacroVariableByNumber: ; StoreMacroVariable
  ; eax = Displacement to the MacroVariable Record, inside 'MacrosVariablesTable'

  ; esi is pointing after '&&23='

  ; Macros Variables Declarations are not true Statements.
  ; So, we have to strip the leading '|' (meEOI) previously written:
    ;dec edi

    Push edi
        lea edi D$MacroCounters+eax*4

L0:     cmp B$esi EOI | jbe L9>>

        lodsb

        .If al = '&'
            lodsb | dec ecx
            On al <> '&', error MixedInternalVariables
                dec ecx
                Call ParseCounterToCounterAttribution
              ; Unwanted meEOI:
                ;dec ecx

        .Else_If al = TextSign
          ; skip first TextSign
            dec ecx
            Call GetAttributionChar | Mov D$edi ebx
          ; skip last TextSign
            inc esi | dec ecx

        .Else_If al = NumSign
            dec ecx | lodsb | dec ecx
            If al = 'N'
                Move D$edi D$NumberOfMacroParameters
            Else
                error CounterSyntax
            End_If

        .Else_If al < '0'
            error CounterSyntax

        .Else_If al <= '9'
            dec esi
            Call GetAttributionNumber | Mov D$edi ebx

        .Else_If al = 'P'
            Call SaveStatementCounter | sub ecx 3

        .Else
            error CounterSyntax

        .End_If

        ;loop L0<
L9: Pop edi
ret


;;
  Example: &&51=Pos (For the #If #ErrorPos).
  
  Saves the actual Source Parsing Pointer into a Macro Counter that the user will
  possibly reuse for having his private error message coming out, with the source
  being pointed to, eventually, at an upward position from the error detection.
;;
SaveStatementCounter:
    If W$esi = 'OS'
        Mov eax D$StatementsPtr
        Mov D$edi eax
        add esi 2
    Else
        error CounterSyntax
    End_If
ret


ParseCounterToCounterAttribution:
    Call GetMacroVariableDis | Mov eax D$MacroCounters+eax*4

    ..If ecx = 0
        ; eax ready

    ..Else_If B$esi <= EOI
        ; eax ready

    ..Else_If B$esi = AddSign
        inc esi | dec ecx
        Call GetAttributionNumber
        add eax ebx
        ;.If B$esi = '1'
        ;    inc eax | stosd | inc esi | dec ecx
        ;    If ecx <> 0
        ;        On B$esi > EOI, error CounterSyntax
        ;    End_If
        ;.Else
        ;    error CounterSyntax
        ;.End_If

    ..Else_If B$esi = SubSign
        inc esi | dec ecx
        Call GetAttributionNumber
        sub eax ebx
       ; .If B$esi = '1'
       ;     dec eax | stosd | inc esi | dec ecx
       ;     If ecx <> 0
       ;         On B$esi > EOI, error CounterSyntax
       ;     End_If
       ; .Else
       ;     error CounterSyntax
       ; .End_If

    ..Else
        error CounterSyntax

    ..End_If

    Mov D$edi eax
ret


[CounterAttribution: B$ 'Bad Number Attribution for internal Counter' EOS]

GetAttributionNumber:
    If W$esi = '00'
        Call GetAttributionBinary
    Else_If B$esi = '0'
        Call GetAttributionHexa
    Else_If B$esi < '0'
        error CounterAttribution
    Else_If B$esi <= '9'
        Call GetAttributionDecimal
    Else
        error CounterAttribution
    End_If
ret


GetAttributionBinary:
    Mov ebx 0 | inc esi | dec ecx

L0: If B$esi = '1'
        shl ebx 1 | or ebx 1
    Else_If B$esi = '0'
        shl ebx 1
    Else
        ret
    End_If
    inc esi | dec ecx | jnz L0<
ret


GetAttributionHexa:
    Mov ebx 0
    Push eax
L0:     If B$esi < '0'
            Pop eax | ret
        Else_If B$esi <= '9'
            shl ebx 4 | Mov al B$esi | sub al '0' | or bl al
        Else_If B$esi < 'A'
            Pop eax | ret
        Else_If B$esi <= 'F'
            shl ebx 4 | Mov al B$esi | sub al '0' | sub al 7 | or bl al
        Else
            Pop eax | ret
        End_If
        inc esi | dec ecx | jnz L0<
    Pop eax
ret


GetAttributionDecimal:
    Push eax
    Mov ebx 0
L0: lodsb
    If al < '0'
        ; Out
    Else_If al > '9'
        ; Out
    Else
        sub al '0'
        lea ebx D$ebx+ebx*4
        lea ebx D$eax+ebx*2
        dec ecx | jnz L0<
    End_If

    dec esi | Pop eax
ret

[CounterTextAttribution: B$ 'Max Text Attribution is 4 Chars, for a Counter' EOS]

GetAttributionChar:
    Mov ebx 0

L0: or bl B$esi  | dec ecx | inc esi
    On B$esi = TextSign, ret
    shl ebx 8 | or bl B$esi  | dec ecx | inc esi
    On B$esi = TextSign, ret
    shl ebx 8 | or bl B$esi  | dec ecx | inc esi
    On B$esi = TextSign, ret
    shl ebx 8 | or bl B$esi  | dec ecx | inc esi
    On B$esi <> TextSign, error CounterTextAttribution
ret
____________________________________________________________________________________________

[WritingLowCounter:
B$ 'Only "0" to "9" or "A" to "Z" accepted.', "
Bad writing attempt with Counter &&"
 WritingCounter: 0 0 0] ; !!! alignement

WriteMacroVariableByNumber:
    Mov ebx eax
    Mov eax D$MacroCounters+eax*4 | stosb

    If al < '0'
        ; bad
    Else_If al > 'Z'
        ; bad
    Else_If al <= '9'
        ; good '1' to '9'
        ret
    Else_If al >= 'A'
        ; goo ''A' to 'Z'
        ret
    End_If

    Mov edi WritingCounter, eax ebx
    Call WriteEaxDecimal | Mov B$edi EOS
    error WritingLowCounter
ret


StoreMacroVariable:
  ; eax = Displacement to the MacroVariable Record, inside 'MacrosVariablesTable'

  ; Macros Variables Declarations are not true Statements.
  ; So, we have to strip the leading '|' (meEOI) previously written:
    On B$edi-1 = meEOI, dec edi

    Push edi
        lea edi D$MacrosVariablesTable+eax

L0:     cmp B$esi EOI | jbe L9>>
        lodsb                           ; read data from MacroData
        .If al = NumSign                ; if parameter, > unfolding
            lodsb | dec ecx
            If al = 'X'
                Mov al B$MacrosX | inc al | Call AlToDecimal | loop L0<

            Else_If al = 'N'
                Mov al B$NumberOfMacroParameters | Call AlToDecimal | loop L0<

            Else_If B$esi = '>'
                Mov bl B$LastMacPara
                cmp al '9' | ja L2>
                    cmp al bl | ja L3>
L2:             cmp bl '9' | ja L4>
                    cmp B$esi+1 'L' | je L4>
                        cmp B$esi+1 bl | jbe L4>
L3:             dec edi
                cmp B$edi ColonSign | je C1>
                    cmp B$edi EOI | ja L3<
                        jmp C2>
C1:             inc edi
C2:             add esi 2 | sub ecx 2

                jmp L6>
L4:             Call MultiParametersUnfolding
                dec edi
L6:             dec ecx

            Else
                Call ParameterUnfolding | dec ecx | jnz L0<<

            End_If

        .Else_If al = '&'
            Call GetMacroVariableDis | shl eax 7
            On B$esi = '=', error D$NestedMacroVariablePtr
            Call WriteMacroVariable
            jmp L8>
L7:         jmp L0<<
L8:         loop L7<

        .Else_If al = '!'
            dec edi
            jmp L8>
L7:         jmp L0<<
L8:         loop L7<

        .Else
            jmp L8>
L7:         jmp L0<<
L8:         stosb | loop L7<                    ; write body in MacroVx

        .End_If

L9:     Mov al 0 | stosb
    Pop edi
ret


WriteMacroVariable:
    Push esi, ebx
        lea esi D$MacrosVariablesTable+eax
        Mov ebx edi | add ebx 80

        If B$esi = 0
         ; This is commented out because it outputs NOPEs every now and then when unwished.
         ; I don't find example, when it could be a problem for Conditional Macros...

         ; Mov D$edi 'NOPE' | add edi 4
           Pop ebx, esi | ret
        End_If
        If B$esi = Space
           inc esi
           ; jE! skip Space, if is 1st byte!
        End_If
        .While B$esi > 0
            If B$esi = '&'
                inc esi
                Push ecx
                    Call GetMacroVariableDis | shl eax 7
                    On B$esi = '=', error D$NestedMacroVariablePtr

                    Push esi
                        Call WriteMacroVariable
                    Pop esi
                Pop ecx
            Else
                movsb | On edi = ebx, error D$MacVarOverFlowPtr
            End_If
        .End_While

    Pop ebx, esi
ret

____________________________________________________________________________________________

[NoMeanLabel: B$ 'ZZZZZZZZ' EOS]
[NoMeanEaten: D$ 0]

; B$esi > '0' of '&0' when called:

DataNoMeanLabel:
    lodsb                                                ; strip '0'
    If B$esi = ColonSign                                 ; '&0:' Declaration
        On B$NoMeanEaten = &TRUE, error D$Double0Ptr
        Call CreateNoMeanLabel
        inc esi | sub ecx 3                              ; strip ':' and '&0:' count
        Call WriteNoMeanLabel
        Mov al ColonSign | stosb
        Mov B$NoMeanEaten &TRUE
    Else                                                 ; '&0' Evocation
        Call WriteNoMeanLabel
        sub ecx 2                                        ; strip '&0' count
  ;  Else
        ; i think no error check usefull here because compilation will fail later...
    End_If
ret


; Prepares a new Automatic Label Name, to be written by 'WriteNoMeanLabel':

CreateNoMeanLabel:
    Push edi
        Mov edi NoMeanLabel | add edi 7
        dec B$edi
        While B$edi < 'A'
            Mov B$edi 'Z' | dec edi | dec B$edi
        End_While
    Pop edi
ret


; Write the Automatic Label at edi (without trailing Colon):

WriteNoMeanLabel:
    Push esi, ecx
        Mov esi NoMeanLabel, ecx 8 | rep movsb
    Pop ecx, esi
ret

____________________________________________________________________________________________

; Writes al to edi in Decimal form:

AlToDecimal:
    Push ecx, eax
        Mov ecx 10
        Push 0-1
L1:     Mov ah 0 | div cl | add ah '0' | Push eax | cmp al 0 | ja L1<

L2:     Pop eax
        If eax <> 0-1
            Mov B$edi ah | inc edi | jmp L2<
        End_If
    Pop eax, ecx
ret

;;
  Gets the Macro Variable Displacement, in the 'MacrosVariablesTable'.
  
  called from: 'ReplaceFromMacroData', 'StoreMacroVariable', plus 'WriteFromMacroVariable'
  in cases of nested MacroVariable.
;;

GetMacroVariableDis:
  ; esi points to the Number first Char after the '&':
    Mov al B$esi
    cmp al '9' | ja L0>
    cmp al '0' | jae L1>
L0:     error D$MacroVariableIndicePtr

L1: dec ecx
    Push ebx
        Mov eax 0, ebx 0

L0:     lodsb | sub al '0' | add ebx eax
        cmp B$esi '0' | jb L9>
        cmp B$esi '9' | ja L9>
          ; ebx = ebx*10:
            lea ebx D$ebx*4+ebx | shl ebx 1 | loop L0<

L9:     Mov eax ebx
    Pop ebx

  ; eax = &Variable Indice from 1 to 100:
    On eax > MACRO_VARIABLES, error D$MacroVariableIndicePtr

  ; eax = Displacement to the proper 128 Byte Record:
  ;  shl eax 7 ; Done by caller
ret


[MacrosX: D$ ?]

ReplaceFromMacroData:
    Call SearchLastParameter

    Mov edi D$InstructionBptr

    Mov B$MacrosX 0, B$FirstUnfolded &FALSE, B$LastUnfolded &FALSE, B$NoMeanEaten &FALSE

X0: Push ecx, esi
      ; read data from MacroData:
L0:     lodsb

        ...If al = NumSign
          ; "#" Parameter, > Unfolding:
            Call ParseMacroParameter

            If ecx = 0-1
                Pop esi, ecx | jmp X0<
            Else_If ecx > 0
               jmp L0<
            Else
                jmp L9>>
            End_If

        ...Else_If al = '&'

            ..If B$esi = '0'
            ; '&0' found:
                Call DataNoMeanLabel | cmp ecx 0 | ja L0<
                    jmp L9>>

            ..Else
                .If B$esi = '&'
                ; &&1... &&99 numbered Variable:
                    dec ecx | inc esi
                    cmp B$esi '0' | jb N0>
                    cmp B$esi '9' | ja N0>
                        Call ParserMacroVariableByNumber | cmp ecx 0 | jg L0<<
                        jmp L9>

                .Else_If B$esi < '1'
                  ; nop
                .Else_If B$esi > '9'
                  ; nop
                .Else
                  ; &1... &99 Variable:
                    Call ParseMacroVariable | cmp ecx 0 | ja L0<<

                    jmp L9>

                .End_If

            ..End_If
        ...End_If

N0:     stosb                          ; write
        On edi >= D$InstructionAEnd, error D$MacrosOverFlowPtr
        dec ecx | jnz L0<<
L9: Pop esi, ecx                                 ; true stack restore
ret

____________________
; '#' NumSign found:

ParseMacroParameter:
    lodsb | dec ecx

    ..If al = SubSign
        On B$esi-3 > EOI, error D$BadMacroLoopPtr
      ; +/- in bl // 1/.../9 in al:
        Mov bl, al | lodsb | dec ecx

      ; Sign was "-":
        If B$FirstUnfolded = &FALSE
            sub al '0' | sub B$MacrosX al
            On B$MacrosX >= 080, error D$InfiniteLoopPtr
            On B$LastMacPara = '0', error D$MacNumberPtr

          ; Restart unfolding signal:
            Mov ecx 0-1

        Else
          ; job is done. strip lasting separator:
            dec edi
          ; if some more text after loop symbol (another one is ready from source)
            On ecx > 0, dec ecx

        End_If
        ret

    ..Else_If al = addSign
        On B$esi-3 > EOI, error D$BadMacroLoopPtr
        Mov bl, al | lodsb | dec ecx
      ; sign was "+":
        If B$LastUnfolded = &FALSE
            sub al '0' | add B$MacrosX al
            On B$MacrosX >= 080, error D$InfiniteLoopPtr
            On B$LastMacPara = '0', error D$MacNumberPtr

          ; Restart unfolding signal:
            Mov ecx 0-1

        Else
          ; job is done. strip lasting separator:
            dec edi
          ; if some more text after loop symbol (another one is ready from source)
            On ecx > 0, dec ecx

        End_If
        ret

    ..Else_If al = 'X'
        Mov al B$MacrosX | On al >= 080, neg al
        inc al | Call AlToDecimal

    ..Else_If al = 'N'
        Mov al B$NumberOfMacroParameters
        Call AlToDecimal

    ..Else_If al = '='
      ; Case of "#=4", for forced Parameters control:
        dec ecx | On ecx = 0, error D$MacParaPtr
        lodsb | sub al '0' | On al > 9, error D$MacNumberPtr
        add al '0' | On B$LastMacPara <> al, error D$MissingParameterPtr
        lodsb | dec ecx | On ecx = 0, error D$MacNumberPtr

    ..Else_If B$esi = '<'
        error D$BadMacroDirectionPtr

    ..Else_If B$esi = '>'
        Mov bl B$LastMacPara

        If al <= '9'
          ; 'x' expressed number out of parameter range?
            cmp al bl | ja L3>>
        End_If

        .If bl > '9'
          ; #x>y found (x in AL)
            Call MultiParametersUnfolding
            dec edi
        .Else_If B$esi+1 = 'L'
            Call MultiParametersUnfolding
            dec edi
        .Else_If B$esi+1 <= bl
            Call MultiParametersUnfolding
            dec edi
        .Else
L3:         Do
              ; if no parameter fitting with parameter in...
                dec edi

                If B$edi = ColonSign
                    inc edi | jmp C2>
                End_If
            Loop_Until B$edi <= EOI
          ; previous possible mnemonic written at L0:
C2:         add esi 2 | sub ecx 2
        .End_If

    ..Else
      ; #1/.../#9/#F/#L   found:
        Call ParameterUnfolding
    ..End_If

L6: dec ecx | ret

____________________________________________________________________________________________



ParserMacroVariableByNumber:
    dec ecx
    Call GetMacroVariableDis
    .If B$esi = '='
      ; strip '=', keep '1' in al
        inc esi | dec ecx
        If B$esi = Space
            inc esi | dec ecx
        End_If

        Call StoreMacroVariableByNumber

        If ecx = 0
            Mov D$edi 'NOPE' | add edi 4
        Else
          ; Strip next '|' (End >>> None >>> 'jg':
            inc esi | dec ecx
        End_If

    .Else
        Call WriteMacroVariableByNumber

    .End_If
ret


ParseMacroVariable:
  ; For the previous '&':
    dec ecx
    Call GetMacroVariableDis | shl eax 7
    .If B$esi = '='
        inc esi | dec ecx   ; strip '='
        Call StoreMacroVariable

      ;  If ecx = 0
      ;      Mov D$edi 'NOPE' | add edi 4
      ;  Else
      ;    ; Strip next '|' (End >>> None >>> 'jg':
      ;      inc esi | dec ecx
      ;  End_If

    .Else
        Call WriteMacroVariable

    .End_If
ret

 ________________________________________________________________________________________
;;
; NestingCheck compares source before and after unfolding (sourceA / SourceB)
; if something is different , a macro job has been done. We loop all this job
; the stupid way until it be found of no more use.
; When NestingCheck is called, ESI points either to SourceCodeB or to MacroData,
; depending of the replacement work: as text from ESI could be either shorter or
; longer than new text in EDI, a lenght for shorter > ECX > REPE CMPSB can't be known...
; We can't check if parameters were all used because it is allowed to transmit dummy
; parameters (parameters that would be written in macro evocation only for ease of read
; purpose, for exemple).
;
;
; Infinite loop is not completly impossible. exemple:
;        [ Mov | mov #2 #1 ]
;          Mov eax, ebx      ; >>>>  Mov ebx, eax ... and so on.
;
; The only one solution i choose is to stop unfolding after a certain iterations number:
;;

[MacroJobIsOver: D$ ?]

NestingCheck:
    Push esi, ecx, eax, edi
        Mov esi D$InstructionAptr, edi D$InstructionBptr, ecx 0

        Mov ah B$esi-1        ; exemple: with  [Api | Push #L>2 | Call #1], an
        Mov al B$edi-1        ; api Call without parameter will be authorized :
        cmp ax ((EOI shl 8)+meEOI) | jne L0>
        ;cmp ax 0201 | jne L0> ; no error message. Compute > (02h)Call(03h)Function(02)
            Mov B$edi-1 EOI    ; and not:                    (01h)Call(03h)Function(02)

L0:     Mov ah B$esi,  al B$edi
        ;and eax 00_01111111__01111111
        inc esi | inc edi
        cmp ax ((EOI shl 8)+meEOI) ;0201 ; this appends when a nested macro evocation does'nt have fitting
            jne L1>             ; transmited parameters and is authorized (L>2 for example)
        Mov B$edi 2 | Mov al 2
L1:     cmp ah al | jne L2>                   ; AH <> AL          >  Job is not over
            cmp al meEOI | je L9>
            cmp al EOI | je L9>               ; AH = AL = '|' (12)    >  Job is over
            jmp L0<
L2:     On B$UnfoldingRotations = 0FF, error D$InfiniteLoopPtr
        Mov D$MacroJobIsOver &FALSE
L9: Pop edi, eax, ecx, esi
ret


ReplaceOneMacro: ; esi = D$InstructionB, edi = D$InstructionA
    movsb | jmp L1>                           ; first separator

L0: stosb

L1: lodsb | IfItIsText L0<
        cmp al EOI | je N0>
            cmp al LowSigns | jb L0<          ; meEOI...
                dec esi | jmp L2>
N0:     cmp B$esi EOI | jne L2>               ; end marker = '||' > write it
            stosb | stosb | ret               ; and exit

L2: Mov D$InstructionAptr esi,  D$InstructionBptr edi,  D$OneWordLen 0

L3: lodsb | cmp al LowSigns | jb L4>          ; search now lenght of text word:
        inc D$OneWordLen | jmp L3<            ; lenght of one text word in OneWordLen

; now: one source word is pointed by InstructionBptr and OneWordLen contain the length.

L4: cmp al ColonSign | je L9>>                 ; is it a line label?
    Mov esi D$InstructionAptr

    and B$esi 00_0111_1111

    Call GetFromQwordCheckSum esi, D$MacroList, D$MacroListLimit
    cmp eax 0 | je L5>

        While B$eax > LowSigns | inc eax | End_While | inc eax
        Mov esi D$eax, ecx D$eax+4

        Call MacroWithIf

        Call ReplaceFromMacroData

        Call NestingCheck

        Mov esi D$AfterLastParameter | jmp L1<<

  ; direct writing:
L5: Mov esi D$InstructionAptr,  edi D$InstructionBptr

L6: lodsb | cmp al EOI | jbe L7>
        stosb | jmp L6<
L7:     dec esi | jmp L1<<

  ; write line labels:
L9: Mov esi D$InstructionAptr,  edi D$InstructionBptr
L8: lodsb | cmp al ColonSign | je L9>
        stosb | jmp L8<

L9: dec esi | jmp L1<<
____________________________________________________________________________________________

ReplaceEquates:
    movsb | jmp L1>                             ; strip first separator
L0: stosb
L1: lodsb | cmp al TextSign | jne C5>
        stosb
C0: lodsb | stosb | cmp al TextSign | jne C0<
        jmp L1<

C5: cmp al EOI | ja L2>                         ; all possible separators.
C6:     cmp B$esi EOI | jne L0<                 ; end marker = '||' > write it
            stosb | stosb
            ret

L2: cmp al LowSigns | jb L0<
    dec esi | Mov D$InstructionBptr esi,  D$InstructionAptr edi,  D$OneWordLen 0

L3: lodsb | cmp al LowSigns | jb L4>            ; search now lenght of text word
        inc D$OneWordLen | jmp L3<              ; > lenght in 'OneWordLen'

  ; now: one source word is pointed by InstructionBptr and OneWordLen contain the length
L4: Mov esi D$InstructionBptr
    test B$esi 00_1000_0000 NOT_ZERO L6>>           ; to avoid testing words not in list
    cmp B$esi '0' | jb L4>
    cmp B$esi '9' | ja L4>                     ; No need Parsing Numbers.
        Mov ecx 0 | jmp L5>

L4: ;Call IsItInEquateList                       ; > MacroData adress in esi, len in ecx
   ; On al = ColonSign, inc D$OneWordLen

    cmp al ColonSign | jne L4>
        Mov ecx 0 | jmp L5>

L4: Call GetFromQwordCheckSum esi, D$EquateList, D$EquateListLimit

    Mov ecx eax | cmp ecx 0 | je L5>
        While B$eax > LowSigns | inc eax | End_While | inc eax
        Mov esi D$eax, ecx D$eax+4

L5: cmp ecx 0 | ja L5>                          ; ecx = lenght from 'IsItInMacroList'
        Mov esi D$InstructionBptr
        or B$esi 00_1000_0000                   ; word was not in list > flag cancel next time
    jmp L6>

  ; write equate body from MacroData (equ and mac body are all in Macrodata)
L5: Mov edi D$InstructionAptr | rep movsb | Mov D$InstructionAptr edi
    Mov esi D$InstructionBptr | add esi D$OneWordLen | Mov D$InstructionBptr esi
    Mov D$MacroJobIsOver &FALSE | jmp L1<<

L6: ; direct writing from source:
    Mov esi D$InstructionBptr,  edi D$InstructionAptr,  ecx D$OneWordLen | rep movsb
    Mov D$InstructionBptr esi,  D$InstructionAptr edi | jmp L1<<
____________________________________________________________________________________________

_________________________________________________________________________________________
;;
 As many full passes as needed: one full for equate, one full for macros, ... and loop
 until job is found to be of no more use; this is to say when source and destination
 are the same. All this process is so made one more time than really needed. RosAsm
 Spoil most of compile time here. I have not found something faster with same flexibility.
 Setting a high bit on 'non equates words' saves about 1/7 of compile time.
;;
_________________________________________________________________________________________

ClearDoneHighBit:
    Mov esi D$CodeSourceA, ecx D$StripLen, B$InsideText &FALSE
L0: On B$esi = TextSign, xor B$InsideText &TRUE
    On B$InsideText = &FALSE, and B$esi 00_0111_1111
L9: inc esi | loop L0<
  ret


ReplaceMacAndEqu:
    Mov B$UnfoldingRotations 0
L0: inc B$UnfoldingRotations | On B$UnfoldingRotations = 0FF, error D$InfiniteLoopPtr

    Mov D$MacroJobIsOver &TRUE
    Mov esi D$InstructionA, edi D$InstructionB

        Call ReplaceEquates ; zReplaceEquates

        Mov ecx edi | sub ecx D$InstructionB | Mov D$StripLen ecx
            If B$MacroJobIsOver = &FALSE
                Exchange D$InstructionA D$InstructionB
                Exchange D$InstructionAEnd D$InstructionBEnd | jmp L0<<
            End_If

            .Do
                Mov B$MacroModifiedExpression &FALSE

                    Call ParaMacrosParser

                        Mov esi D$InstructionB, edi D$InstructionA

                        Call ExpressionParser

                          ; We have to do this here (and not before the RET of
                          ; 'ExpressionParser') because 'ExpressionParser' is
                          ; also called from 'ReplaceEquOnly':
                            Mov ecx edi | sub ecx D$InstructionA | Mov D$StripLen ecx
                            Exchange D$InstructionA D$InstructionB
                            Exchange D$InstructionAEnd D$InstructionBEnd
                 inc B$UnfoldingRotations
                 On B$UnfoldingRotations = 0FF, error D$InfiniteLoopPtr

            .Loop_Until B$MacroModifiedExpression = &FALSE

        Mov esi D$InstructionB, edi D$InstructionA

        Call ReplaceOneMacro

        ;;;;;;;;;;;;;;;;;;; Remove EOI, meEOIs and Spaces right after an EOI:
        Mov D$edi 0

        Mov esi D$InstructionA, edi esi
        .While B$esi <> 0
            lodsb | stosb
            If al < Separators
                While B$esi = meEOI | inc esi | End_While
            End_If
        .End_While
        ;;;;;;;;;;;;;;;;;;

        Mov ecx edi | sub ecx D$InstructionA

      ; If D$InstructionA = EOI, EOI (Cases of empty outputs - impossible actually -):
L2:     If ecx <= 2
            Mov edi D$InstructionA, B$edi EOI, D$edi+1 'NOPE', B$edi+5 EOI
            Mov D$StripLen 6 | ret
        End_If

        If ecx <> D$StripLen
            Mov D$MacroJobIsOver &FALSE
           ; On B$UnfoldingRotations = 0FF, hexprint 6
            On B$UnfoldingRotations = 0FF, error D$InfiniteLoopPtr
        End_If
        Mov D$StripLen ecx

L9: cmp D$MacroJobIsOver &TRUE | jne L0<<                          ; set by 'NestingCheck'
ret                                                                ; when over > SourceB

____________________________________________________________________________________________

zReplaceEquOnly:
    Mov B$UnfoldingRotations 0
L0: inc B$UnfoldingRotations | On B$UnfoldingRotations = 0FF, error D$InfiniteLoopPtr

    Call zReplaceEquates

    Mov ecx edi | sub ecx D$InstructionB
    Mov D$StripLen ecx

    Exchange D$InstructionA D$InstructionB,
             D$InstructionAEnd D$InstructionBEnd

    On B$MacroJobIsOver = &FALSE, jmp L0<<

    Call zExpressionParser
ret


zReplaceEquates:
    Mov D$MacroJobIsOver &TRUE, esi D$InstructionA, edi D$InstructionB

    .While B$esi <> 0
        Mov al B$esi

        ..If al = TextSign
            movsb | While B$esi <> TextSign | movsb | End_While | movsb

        ..Else_If al < LowSigns
            movsb
            On B$esi = '0', jmp L1> ; In case, if the 1st found byte is '0', it obviusly anumbers, and also means
                                    ; it is TextSign, so simply copy the whole data.
        ..Else_If al < '0'
          ; Example: '.If':
            jmp L2>

        ..Else_If al >= '0'
            .If al <= '9'
              ; Simple copy (numbers, non-Equates):
L1:             While B$esi > LowSigns | movsb | End_While

            .Else
              ; Skip non-Equates:
L2:             test B$esi 00_1000_0000 NOT_ZERO L1<

              ; Is it in EquateList:
                Call GetFromQwordCheckSum esi, D$EquateList, D$EquateListLimit
                If eax = 0
                    ; Not an Equate:
                    ; the OR will only happens if the Byte is > '9' and <= LowSigns
                    On B$esi <= LowSigns, or B$esi 00_1000_0000
                    jmp L1<

                Else
                  ; Equate body in 'MacroData' (equ and mac body are all in 'Macrodata'):
                    While B$eax > LowSigns | inc eax | End_While | inc eax
                    Push esi
                        Mov esi D$eax, ecx D$eax+4
                        rep movsb
                    Pop esi

                    Mov D$MacroJobIsOver &FALSE
                  ; Skip the done Equate:
                    While B$esi > LowSigns | inc esi | End_While

                End_If
            .End_If

        ..End_If
    .End_While

    Mov B$edi 0
ret



zExpressionParser:
    Mov esi D$InstructionA, edi D$InstructionB
    Mov edx esi | add edx D$Striplen | inc edx
    Mov B$InsideExpression &FALSE, B$RealHexaSize 0
    Mov ebx 0, ecx 0

L0: .While esi < edx
        lodsb

        ..If al = TextSign
            stosb | While B$esi <> TextSign | movsb | End_While | movsb | jmp L0<

        ..Else_If al = OpenSign
            .If B$InsideExpression = &FALSE
                cmp B$esi-2 memMarker | jne L3>
                Mov al B$esi-3 | and al 00_0111_1111 ; Mask Equates and Macros Done Flag.
                cmp al 'F' | jne L1>
                    Mov B$edi-2 'D', B$RealHexaSize 8 | jmp L2>
L1:             cmp al 'R' | jne L3>
                    Mov B$edi-2 'Q', B$RealHexaSize 16
L2:                 Mov B$RealExpression &TRUE | jmp L4>
L3:             Mov B$RealExpression &FALSE
L4:             Mov ebx 0, ecx 0
                Mov D$StartOfSourceExpression esi, D$StartOfDestinationExpression edi
            .End_If
            inc ebx | inc ecx | Mov B$InsideExpression &TRUE

        ..Else_If al = CloseSign
            On ecx = 0, error D$ParenthesisPtr
            dec ecx

        ..Else_If al = 0
            On B$InsideExpression = &TRUE, error D$ParenthesisPtr
            Call CheckBracketExpression

        ..End_If

        ..If ebx > 0
            .If ecx = 0
                Push edx
                    If B$RealExpression = &TRUE
                        Call ComputeRealExpression
                    Else
                        Call ComputeExpression
                    End_If
                    Call zWriteExpressionResult
                    Mov ebx 0, ecx 0, B$InsideExpression &FALSE
                    Mov B$MacroModifiedExpression &TRUE
                Pop edx
                jmp L0<<
            .End_If
        ..End_If

        stosb
    .End_While

    Mov ecx edi | sub ecx D$InstructionB | Mov D$StripLen ecx

    Exchange D$InstructionA D$InstructionB,
             D$InstructionAEnd D$InstructionBEnd
ret


zWriteExpressionResult:
    Push esi
        Mov esi D$ExpressionA, edi D$StartOfDestinationExpression

        While B$esi > 0
            movsb
        End_While
    Pop esi
ret
____________________________________________________________________________________________


;;
        Mov ecx edi | sub ecx D$InstructionA

      ; If D$InstructionA = EOI, EOI (Cases of empty outputs - impossible actually -):
        If ecx <= 2
            Mov edi D$InstructionA, B$edi EOI, D$edi+1 'NOPE', B$edi+5 EOI
            Mov D$StripLen 6 | ret
        End_If

        If ecx <> D$StripLen
            Mov D$MacroJobIsOver &FALSE
           ; On B$UnfoldingRotations = 0FF, hexprint 6
            On B$UnfoldingRotations = 0FF, error D$InfiniteLoopPtr
        End_If
        Mov D$StripLen ecx

L9: cmp D$MacroJobIsOver &TRUE | jne L0<<                          ; set by 'NestingCheck'
ret                                                                ; when over > SourceB
;;

;;
 In previous versions, 'ReplaceMacAndEqu' was called from AsmMain and all replacement job
 was done at once. This new version cuts the job in as tiny parts as possible in order
 to avoid no use loop analyzes.

 First, as Data brackets are stored at the begining of the cleaned source (and can't
 contain any Macro), we compute them one set by one set, only Equates replacement.

 Second, each instruction is done in turn. All this saves about 15% of replacement job.
 2 wide tables are used to store the parts, and exchanges are done between the pointers
 just because i do not wish to rewrite it all for more accurate namings.
;;

[InstructionA: D$ ?
 InstructionB: D$ ?
 InstructionAEnd: D$ ?
 InstructionBEnd: D$ ?
 CodeSourceBpointer: D$ ?
 CodeSourceApointer: D$ ?
 OpenType: D$ ?
 CloseType: D$ ?]

;;
  NewReplaceMacAndEqu
  
        zReplaceEquOnly
                zReplaceEquates
                zExpressionParser
        
        ReplaceMacAndEquStatement
                zReplaceEquates
                ParaMacrosParser
                        UnfoldDataParameter
                        UnfoldMacroParameter
                zExpressionParser
                        CheckBracketExpression
                        ComputeRealExpression
                        ComputeExpression
                        WriteExpressionResult
                ReplaceOneMacro
                        MacroWithIf
                        ReplaceFromMacroData
                        NestingCheck
;;

NewReplaceMacAndEqu:
  ; Initializations:

    Call ClearMacroVariable

    Call VirtualAlloc InstructionA,
                      D$StripLen

    Mov eax D$InstructionA | add eax D$StripLen | AlignOn 01000 eax | Mov D$InstructionAEnd eax

    Call VirtualAlloc InstructionB,
                      D$StripLen

    Mov eax D$InstructionB | add eax D$StripLen | AlignOn 01000 eax | Mov D$InstructionBEnd eax

    Mov B$ErrorLevel 0, D$BracketCounter 0

    Move D$StatementsPtr D$StatementsTable,
         D$CodeSourceBpointer D$CodeSourceB,
         D$CodeSourceApointer D$CodeSourceA

    Mov edi D$CodeSourceBpointer

;;
  The Source has been re-organized: Brackets first // Code Statements last. The
  Brackets sets do not need anything else but the Equates jobs. So, we parse them,
  first. Once an EOI is encounted, this first job is over:
;;

L0: Mov esi D$CodeSourceApointer, edi D$InstructionA
    cmp B$esi EOI | je L0>>

  ; Take a copy one Bracket Statement:
    Mov al B$esi ; copy B$esi to al. Forget the lodsb because it will increment esi, bypassing the good pointer
    Mov B$OpenType al; <--- I added only this to it points to the proper place on the next instruction, so what is being copied to edi is the starting byte (014)

    Do
        lodsb | stosb
        If al = TextSign
L1:         lodsb | stosb | cmp al TextSign | jne L1<
        End_If
        On B$esi-1 = CloseVirtual, jmp C1>
    Loop_Until B$esi-1 = CloseBracket

C1: Mov al B$esi-1, B$CloseType al
  ; Keep track of the real Source:
    Mov D$CodeSourceApointer esi
  ; Set an end-mark:
    Mov B$edi 0 ; <-------- Here i added too.. We need to set the last byte to 0, and not edi-1.
                ; Othewise we are erasing the good final ending mark (edi was already incremented during the loop,
                ; so the proper place is edi and not edi-1

    inc D$BracketCounter

    Call zReplaceEquOnly ; <<<<<<<<<<<<<<<<

    add D$StatementsPtr 4

  ; Copy the Bracket Statement back to CodeSourceB:
    Mov esi D$InstructionA, edi D$CodeSourceBpointer

    Mov al B$OpenType | stosb
    inc esi ; <---- Ok we want to copy to edi, but on stosb we already copied the 1st byte 014 to edi. So, to avoid duplications, we simply increment esi to the next byte
    While B$esi <> 0 | movsb | End_While ; copy the whole thing to edi
    dec edi ; decrease edi to we put the proper close type here
    Mov al B$CloseType | stosb ; put the CoseType at the real end of our data. (After the string)

    Mov D$CodeSourceBpointer edi | jmp L0<<
____________________________________________________

L0: Mov esi D$CodeSourceApointer
    sub D$StatementsPtr 4
    Mov B$ErrorLevel 0, D$StatementsCounter 0

[LenghtOfBracketStatements: D$ ?]

    Mov eax D$CodeSourceApointer | sub eax D$CodeSourceA | Mov D$LenghtOfBracketStatements eax

  ; Take a copy for the Macros jobs:
L0: Mov edi D$InstructionA

    Mov al EOI | stosb
    Do
        movsb
    Loop_Until B$esi-1 = EOI

    Mov D$CodeSourceApointer esi | Mov al EOI | stosb | stosb

    inc D$StatementsCounter | Call ReplaceMacAndEqu  ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    add D$StatementsPtr 4

    Mov esi D$InstructionA, edi D$CodeSourceBpointer | lodsb

L5: lodsb | stosb | cmp al EOI | jne L5<

    Mov D$CodeSourceBpointer edi | Mov esi D$CodeSourceApointer | cmp B$esi EOI | jne L0<<
    movsb

    Exchange D$CodeSourceA D$CodeSourceB

    Push edi
        inc edi | sub edi D$CodeSourceA | Mov D$StripLen edi
    Pop edi
    Mov eax ((EOI shl 24)+(EOI shl 16)+(EOI shl 8)+EOI)  | stosd   ; security

    Call VirtualFree InstructionA

    Call VirtualFree InstructionB

    Call ClearDoneHighBit

ret

____________________________________________________________________________________________
;;
  'NewBrackets' makes nested Declarations of '[...]' available for next Equates and
  Macros job pass. We have to replace all substitutes by the true signs ('{' > '[',
  and so on). But we have a difficult problem to solve first: These new Declarations
  will be Move to top of 'file' by next treatements, and in case of user error search
  among these new created statements, we have to be able to point out the wrong
  original Statement (the user macro Evocation). So have we to add some source pointers
  in 'StatementsTable', with the same pointer value as the one of user Macro. One
  added difficulty is that, is some case, exemple:

  > [CreateEquatesMacro | {#1 #2} | +2]

  ... the original Macro was stored as a Code Statement into 'StatementsTable'. After
  unfolding, there is no more code at this place. So have we to strip one record for
  this, in such cases:
;;
[MoreBracket: D$ ?
 InsideNewBracket: D$ ?
 TrueCodeInside: D$ ?]

NewBrackets:
    Mov esi D$CodeSourceA
    Mov ecx esi | add ecx D$Striplen                    ; end of source adress

    Move D$StatementsPtr D$StatementsTable, D$StatementsPtr2 D$StatementsTable2

    ..While esi < ecx
L0:    lodsb
;On D$esi = 'ENTS', int3
       ...If al = TextSign
L1:         lodsb | cmp al TextSign | jne L1<

       ...Else_If al = '{'
         ; Possible "Bracket only" statement:
      ; On D$esi+15 = 'BIDO', int3
       ; MainWindowProc@BIDON
           ..If B$esi-2 = EOI
               sub D$StatementsPtr 4 | sub D$StatementsPtr2 4
               Mov B$TrueCodeInside &FALSE
               .While al <> EOI
                   If al = '{'
                       Mov ebx D$StatementsPtr, ebx D$ebx
                       Mov edx D$StatementsPtr2, D$edx ebx | add D$StatementsPtr2 4
                       While al <> '}'
                           On al = textSign, Call SkipText
                           lodsb
                       End_While
                      ; dec esi ; <<<<<<<< New add while tracking the "Unfolder bug".

                   Else_If al = meEOI
                       On B$esi = EOI, jmp L2>
                       On B$esi <> '{', Mov B$TrueCodeInside &TRUE

                   Else_If al = TextSign
                       Call Skiptext

                   End_If

L2:                lodsb
               .End_While

               If B$TrueCodeInside = &TRUE
                   Mov ebx D$StatementsPtr, ebx D$ebx
                   Mov edx D$StatementsPtr2, D$edx ebx | add D$StatementsPtr2 4
               End_If
               add D$StatementsPtr 4
               dec esi

           ..Else
             ; (B$esi-2 = meEOI // al = '{') ---> code sure inside...
               sub D$StatementsPtr 4
               .While al <> EOI
                   If al = '{'
                       Mov ebx D$StatementsPtr, ebx D$ebx
                       Mov edx D$StatementsPtr2, D$edx ebx | add D$StatementsPtr2 4
                       While al <> '}'
                            On al = textSign, Call SkipText
                            lodsb
                       End_While

                   End_If
L2:                lodsb
               .End_While

               dec esi
               add D$StatementsPtr 4

           ..End_If

       ...Else_If al = OpenBracket
           Mov ebx D$StatementsPtr, ebx D$ebx | add D$StatementsPtr 4
           Mov edx D$StatementsPtr2, D$edx ebx | add D$StatementsPtr2 4

       ...Else_If al = OpenVirtual
           Mov ebx D$StatementsPtr, ebx D$ebx | add D$StatementsPtr 4
           Mov edx D$StatementsPtr2, D$edx ebx | add D$StatementsPtr2 4

       ...Else_If al = EOI
           On B$esi = OpenVirtual, jmp L3>
           On B$esi = OpenBracket, jmp L3>
               Mov ebx D$StatementsPtr, ebx D$ebx | add D$StatementsPtr 4
               Mov edx D$StatementsPtr2, D$edx ebx | add D$StatementsPtr2 4
L3:
       ...End_If

    ..End_While

    Mov eax D$StatementsPtr2, D$eax 0
    Exchange D$StatementsTable D$StatementsTable2
________________________

; Now, we simply replace substitutes by true Chars. Use of BL reg as a 'Level Counter'
; in order to allow infinite nestings.

    Mov B$MoreBracket &FALSE, B$InsideNewBracket &FALSE
    Mov esi D$CodeSourceA,  edi D$CodesourceB, ebx 0

    .While esi < ecx
L0:    lodsb
       .If al = TextSign
         ; Skip Text:
L1:        stosb | lodsb | cmp al TextSign | jne L1<

       .Else_If al = '{'
           inc bl | On bl > 1, jmp L8>
           xor B$InsideNewBracket &TRUE
           On B$esi = Space, lodsb
           Mov al OpenBracket, B$MoreBracket &TRUE

       .Else_If al = '}'
           dec bl | jnz L8>
           xor B$InsideNewBracket &TRUE
           On B$esi = Space, lodsb
           ;On B$edi-1 = Space, dec edi
           ;On B$edi-1 = meEOI, dec edi
           On B$edi-1 < Separators, dec edi
           Mov al CloseBracket

       .Else_If al = '%'
           If B$InsideNewBracket = &TRUE
               On bl = 1, Mov al NumSign
               On bl = 2, Mov al NumSign

           End_If

       .End_If

L8:    stosb

    .End_While

    Mov eax ((EOI shl 24)+(EOI shl 16)+(EOI shl 8)+EOI) | stosd
    Mov eax edi | sub eax D$CodeSourceB | Mov D$Striplen eax

   ; Call TestStatementsTable
    Exchange D$CodeSourceA D$CodeSourceB
ret


SkipText:
    lodsb | While al <> TextSign | lodsb | End_While
ret
__________________________________________________________________________________________
__________________________________________________________________________________________

; PE Import section construction

; uses 3 tables:   ApiListA to store zero ended api calls
;                  ApiListB to store function name with a number at first for Dll
;                  DllList  to store Dll names
__________________________________________________________________________________________


[ALEOD 0FF]       ; Api Lists End Of Data


[AlignOn | add #2 #1-1 | and #2 0-#1]
; Same for Aligning on a Variable-defined-Alignment (eax broken):
[Align_on_Variable | Push eax
                         Mov eax #1 | dec eax | add #2 eax | xor eax 0-1 | and #2 eax
                     Pop eax]


[DllNumber: D$ ?
 FunctionNumber: D$ ?
 ImportHeaderPtr: D$ ?
 ImportTablePtr: D$ ?]


InitApiTables:
   Mov ax 0FF00                               ; in memory: 00 FF end mark
   Mov edi D$ApiListA | Mov W$edi ax
   Mov edi D$ApiListB | Mov W$edi ax
   Mov edi D$DllList  | Mov W$edi ax
ret
;;
 Test that api Call is in the good form:  Call 'LIB.Function' (one point, no space, not
 open text and turn dll name upper case to prevent from double storage).
 Return: EBX = lenght / ECX = lenght-1  (- last "'")
;;
TestGoodApiCall:
    Push esi
      Mov ecx 0,  ebx 0                       ; ebx = '.' counter (must be 0 / 1 / or 2)
      Push esi
        While B$esi <> TextSign | On B$esi = '.', inc ebx | inc esi | End_While
      Pop esi
      On ebx = 0, jmp L9>

      Mov ebx 0
L0:   lodsb | inc ecx | cmp ebx, 0 | ja L1>   ; if ebx = 0  >>>  before '.'  >>>  dll name
        cmp al 'a' | jb L1>
        cmp al 'z' | ja L1>
          sub al 32                     ; turn upper case dll name
          Mov B$esi-1 al                ; rewrite CodeSourceB
L1:   On al = '.',  inc ebx
      cmp al Space | je L8>
      cmp ecx 1600 ; 150 ; 125 ; 120 |
      je L8>              ; too long
      cmp al TextSign | jne L0<
      cmp ebx 3 |  jb L9>               ; only one '.' wanted
                                        ; ... or 2 in case of Module given Extension...
L8:       Mov B$ErrorLevel 6
          Mov edi D$ApiListA            ; just to store zero ended name for error search
          Pop esi
              While B$esi > TextSign
                  movsb
              End_While
              Mov al 0 | stosb
              Mov esi D$ApiListA
              Error D$BadApiPtr

L9: Pop esi
ret
 ________________________________________________________________________________________

 ; storage of all encounted api calls in ApilistA:

StoreApi:                                ; 5 =  Call 'LIBRARY.Function'
  ; add esi 5                            ;       .....^
    Call TestGoodApiCall
L0: lodsb | cmp al TextSign | je L1>
      stosb | jmp L0<                    ; write in ApilistA
L1: Mov al 0 | stosb
ret


; Simple copy of api calls into 'ApiListA' by 'StoreApi'.
; 'ApiListA' will be: LIBRARY.Function, 0, LIBRARY.Function, 0, ... 0FF

SearchForApis:
    Mov esi D$CodeSourceB,  edi D$ApiListA

    ;add esi D$LenghtOfBracketStatements

    While B$esi <> EOI | inc esi | End_While | inc esi

  ; Regular Rosasm Api calls:
L0: ...If D$esi = 'Call'        ; Call '
L1:     If W$esi+4 = ((TextSign shl 8)+Space)
            add esi 6 | Call StoreApi | jmp L0<
        End_If
;;
  For fancyful things for Disassemblies re-compilation: Store in eax +1 for each TextSign,
  +1 for each '.', +1 if lenght > 6.
  
  Must have: 1 or two '.' // 2 TextSigns // be longer than '..xx' (6 Chars).
;;
    ...Else_If B$esi = Textsign
        inc esi | Mov eax 1, ebx esi

        While B$esi > LowSigns
            If B$esi = '.'
                inc ah
           ; Else_If B$esi < '0'  ; Dement Chars in some Api Names !!!!.... :(
           ;      jmp L5>
            Else_If B$esi > 'z'
                jmp L5>
            End_If

            inc esi
        End_While

        On B$esi = TextSign, inc al

        On ah = 2, dec ah       ; 2 '.' allowed in:  Mov eax 'MODULE.ext.Funtion'

        .If eax = 01_02
            Mov ecx esi | sub ecx ebx
            If ecx > 6
                Mov esi ebx | Call StoreApi | jmp L0<<
            End_If
        .End_If

    ...End_If

L5: lodsb | cmp al EOI | jne L0<<
    cmp B$esi EOI | jne L0<<                     ; End of file reached?

    .If edi = D$ApiListA
        On D$SavingExtension = '.DLL', jmp L9>

            Call 'USER32.MessageBoxA' D$H.MainWindow,
            {B$ "Are you sure you want to continue assemblying this?" EOS},
            D$NoApiPtr, &MB_SYSTEMMODAL__&MB_ICONEXCLAMATION__&MB_YESNO
            If eax = &IDNO

                Mov D$FL.CompileErrorHappend &TRUE,
                    D$NextSearchPos 0

                Call CloseProgressBar
                cld | Mov esp D$OldStackPointer
                Call ReleaseAsmTables
                ret ; for 'no search' errors (esi known) or 'Main:' missing
           End_If
           jmp L9>
    .End_If

    Mov al ALEOD |  stosb                       ; end mark for ApiList (strings are zero ended)
L9: ret

;;
'ApiListA' may contain 3 different forms o api calls: 
> MODULE.Function, 0, MODULE.ext.Function, 0, Function, 0...
We turn them all into:
> MODULE.ext.Function, 0, MODULE.ext.Function, 0, MODULE.ext.Function, 0...
;;
FullfillApiList:
    Mov D$ModuleHandlesListPointer ModuleHandlesList

  ; First generalise the found MODULE(s) to all naked 'Function'(s)
    Mov esi D$ApiListA, edi D$ApiListB

    Call FullfillWithExtensions

    Mov esi D$ApiListA | While B$esi = 0 | inc esi | End_While

    Call FullfillWithoutExtensions

    Mov B$edi ALEOD | Exchange D$ApiListA D$ApiListB

    Mov ebx D$ModuleHandlesListPointer, D$ebx 0

; Test for viewing the new Api List:
;;
    Mov esi D$ApiListA
    .While B$esi <> ALEOD
        howMe esi
        While B$esi <> 0 | inc esi | End_While | inc esi
    .End_While
    Error BadApi
;;

  ; Now, verify that 'ApiListB' is entirely zeroed:

    Mov esi D$ApiListB
    .While B$esi <> ALEOD
        If B$esi <> 0
            Mov B$ErrorLevel 6 | Error D$BadApiPtr
        End_If
        inc esi
    .End_While
ret


FullfillWithExtensions: ; 'FullfillWithoutExtensions'
    ..While B$esi <> ALEOD
        Mov ebx esi, edx 0, ecx 0

        While B$esi <> 0
            inc esi
            .If B$esi = '.'
                If edx = 0
                    lea edx D$esi+1
                Else_If ecx = 0
                    Mov ecx edx | lea edx D$esi+1
                Else
                    Error D$BadApiPtr
                End_If
            .End_If
        End_While
      ; Here, edx > Start of Function Name,
      ;       ecx > Start of Module Extension,
      ;       ebx > Start of Module Name
      ;       esi > ending 0
        ..If ecx <> 0
          ; Cases of 'MODULE.ext.Function':
            Mov eax edx | sub eax ecx
            If eax > 4
                Mov B$ErrorLevel 6, esi ebx
                error D$BadApiPtr
            End_If
            Mov esi ebx, D$StartOfDllName edi, D$StartOfFunctionName edx

            While B$esi <> '.' | movsb | End_While | movsb

          ; HAL DLL cannot be loaded in User Mode (consider it like a .sys):
            Mov B$WasSysModule &FALSE

            Call IsItHAL

          ; Also, .sys Modules cannot be loaded like a DLL:
            Mov eax D$esi | or eax 0202020
            On eax = 'sys.', Mov B$WasSysModule &TRUE

            While B$esi <> '.' | movsb | End_While | Mov D$edi 0

            .If D$ApiCheckFlag <> 2
                If B$WasSysModule = &FALSE
                    Call VerifyModuleWithExtensionExist
                    Call VerifyFunctionExist
                End_If
            .End_If

            movsb | While B$esi <> 0 | movsb | End_While | movsb

            Call AraseSameFunctions

        ..End_If

        While B$esi = 0 | inc esi | End_While
    ..End_While
ret


[WasSysModule: WasHALdll: D$ ?]

IsItHAL:
    Mov eax D$StartOfDllName, eax D$eax | or eax 0202020
    If eax = 'hal.'
        Mov B$WasSysModule &TRUE
    Else_If eax = 'hal'
        Mov B$WasSysModule &TRUE
    End_If
ret


FullfillWithoutExtensions: ; 'FullfillWithExtensions'
L0: ..While B$esi <> ALEOD
        Mov ebx esi, edx 0, ecx 0
        While B$esi <> 0
            inc esi
            If B$esi = '.'
                lea edx D$esi+1 | jmp L1>
            End_If
        End_While

      ; Here, edx > Start of Function Name,
      ;       ebx > Start of Module Name
L1:     ..If edx <> 0
          ; Cases of 'MODULE.Function'
            Mov D$StartOfDllName edi, D$StartOfFunctionName edx
            Mov esi ebx | While B$esi <> '.' | movsb | End_While | Mov B$edi 0

            Mov B$WasSysModule &FALSE | Call IsItHAL

            .If B$WasHALdll = &FALSE
                If D$ApiCheckFlag <> 2
                    Call VerifyModuleExist | stosd
                    Call VerifyFunctionExist
                Else
                    Mov D$edi '.dll' | add edi 4
                End_If
            .Else
                Mov D$edi '.dll' | add edi 4
            .End_If

            While B$esi <> 0 | movsb | End_While | Mov D$edi 0 | inc edi

            Call AraseSameFunctions

        ..End_If

        While B$esi = 0 | inc esi | End_While
    ..End_While
ret


; A 'MODULE.ext.Function' or a 'MODULE.Function' has been found, and recorded.
; We arase all other occurences of 'xxxxFunction':
[CopyOfFunctionName STR.A.Trash] ;: ? #32]

AraseSameFunctions:
  ; Now, arase all other evocations of 'MODULE.ext.Function', 'MODULE.Function',
  ; 'Function', in 'ApiListA':
    Push esi, edi, edx

        Mov esi D$StartOfFunctionName, edi CopyOfFunctionName
        While B$esi <> 0 | movsb | End_While | Mov D$edi 0

        Mov esi D$ApiListA, edi CopyOfFunctionName, bl B$edi
      ; edx used to test if the first name in ApiListA fits with the searched one:
        Mov edx esi | inc edx

L1:     .While B$esi <> ALEOD
            lodsb

            ...If al = bl
                If esi = edx
                    ; Compare (Cases of very first api Call in 'ApiListA' given without DLL)
                Else_If B$esi-2 = 0
                    ; Compare
                Else_If B$esi-2 = '.'
                    ; Compare
                Else
                    jmp L1<
                End_If
                Push ebx, esi
                    dec esi | Mov edi CopyOfFunctionName
L2:                 Mov al B$esi, bl B$edi
                    On al <> bl, jmp L7>>
                    On al = 0, jmp L5>
                    On bl = 0, jmp L5>
                    inc esi | inc edi | jmp L2<
L5:                 or al bl
                    ..If al = 0               ; Same > arase:
                        Mov edx esi
                        Pop esi | Push esi
                        Mov ebx 0
                        While B$esi <> 0
                            dec esi | On B$esi = '.', inc ebx
                            cmp esi D$ApiListA | je L2>
                        End_While
                        inc esi
L2:                     .If ebx > 0
                            Mov ebx D$StartOfDllName
                            Mov ebx D$ebx
                            On ebx = D$esi, jmp L2>
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ; New: for Disassemblies:
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                If B$CopyOfFunctionName = '0'
                                    While B$esi <> 0 | inc esi | End_While | jmp L7>
                                End_If
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                Mov B$ErrorLevel 6 | error D$DoubleFunctionPtr
                        .End_If
L2:                     While B$esi <> 0 | Mov B$esi 0 | inc esi | End_While
                    ..End_If
L7:             Pop esi, ebx
            ...End_If

        .End_While
    Pop edx, edi, esi
ret


IsItNewDll:
    Push edi
      Mov edi D$DllList | Mov ebx 0 | jmp L1>
L0:   Mov al 0,  ecx 0FF
        repne scasb
      cmp B$edi ALEOD | jne L1>
        Mov ebx 0 | jmp L9>
L1:     Push esi edi
          Mov ecx 0FF,  eax 0 | inc ebx
            repe cmpsb
          Mov al B$edi-1,  ah B$esi-1
        Pop edi esi
        cmp eax 02E00 | jne L0<         ; ('.' in ApiListA, 0 in DllList)
L9: Pop edi
ret                                     ; >>> ebx = Dll #n or 0


IsItNewFunction:       ; edi > ApiListB end; esi > ApiListA function name; al > dll #n
    Push edi
      Mov bl al | Mov edi D$ApiListB | jmp L1>
L0:   Mov al 0,  ecx 0FF
        repne scasb
      cmp B$edi ALEOD | jne L1>             ; reach end ?
        Mov al bl | jmp L9>
L1:   cmp B$edi bl | jne L0<
        inc edi
        Push esi edi
          Mov eax 0
L2:       Mov al B$edi,  ah B$esi
          inc edi | inc esi
          cmp eax 0 | je L3>
          cmp ah al | je L2<
L3:     Pop edi esi
        cmp eax 0 | jne L0<
L9: Pop edi
    cmp al 0
ret                                         ; >>> ebx = Dll #n or 0


StoreDllName:
    cmp D$DllNumber 0 | je L1>
    Call IsItNewDll | cmp ebx 0 | je L1>    ; if 0  >>>  new name to store

L0: lodsb | cmp al '.' | jne L0<
    inc esi
L3: lodsb | cmp al '.' | jne L3<
L4: Mov eax ebx                             ; ebx from 'IsItNewDll'
ret

L1: Push edi
        Mov edi D$DllListPtr
      ; write a new "Dll" name (with Extension):
L2:     lodsb | stosb | cmp al '.' | jne L2<
        While B$esi <> '.' | movsb | End_While
        inc esi
        Mov al 0 | stosb | Mov B$edi ALEOD                     ; end mark
        Mov D$DllListPtr edi | inc D$DllNumber | Mov eax D$DllNumber
    Pop edi
ret


SortApis:
    Mov D$DllNumber 0,  D$FunctionNumber 0
    Mov esi D$ApiListA,  edi D$ApiListB
    Mov eax 0,  ebx 0
L0: cmp B$esi ALEOD | je L9>>
      Call StoreDllName             ; return: ebx = 0 if new, else Dll #
      Call IsItNewFunction          ; return: ebx = 0 if new, else Dll #
        ja L2>
L1:  lodsb
       cmp al 0 | jne L1<
         jmp L0<
L2:  stosb                          ; write dll #n
L3:  lodsb
     stosb                          ; write function name until 0
       cmp al 0 | jne L3<
         Mov B$edi ALEOD | inc D$FunctionNumber | jmp L0<
L9: ret

;;
 "FreeLibrary" function does NOT really strip off the DLL from memory, if it is of no
 more use. This appends only when we exit our Process. So, After each DDL testing, we
 let it in memory. At each test, we first check if it is already loaded, instead.
;;
[H.Dll: D$ ?
 StartOfDllName: D$ ?
 StartOfFunctionName: D$ ?
 RosAsmDLL: D$ ?]

[ModuleHandlesList: D$ ? # 100]
[ModuleHandlesListPointer: D$ ?]

VerifyModuleExist:
    pushad
        Mov esi D$StartOfDllName

        Call TryToLoadModule '.dll'
        If eax <> &NULL
            Mov D$H.Dll eax | popad | Mov eax '.dll' | ret
        End_If

        Call TryToLoadModule '.sys'
        If eax <> &NULL
            Mov D$H.Dll eax | popad | Mov eax '.sys' | ret
        End_If

        Call TryToLoadModule '.drv'
        If eax <> &NULL
            Mov D$H.Dll eax | popad | Mov eax '.drv' | ret
        End_If

        Call TryToLoadModule '.exe'
        If eax <> &NULL
            Mov D$H.Dll eax | popad | Mov eax '.exe' | ret
        End_If

    Mov esi D$StartOfDllName, B$ErrorLevel 4 | error D$BadLibNamePtr


VerifyModuleWithExtensionExist:
    pushad
        Mov B$RosAsmDLL &TRUE | Call 'KERNEL32.GetModuleHandleA' D$StartOfDllName

        .If eax = &NULL
            Mov B$RosAsmDLL &FALSE | Call 'KERNEL32.LoadLibraryExA' D$StartOfDllName, 0, D$APICheckFlag
; &DONT_RESOLVE_DLL_REFERENCES &LOAD_LIBRARY_AS_DATAFILE &LOAD_WITH_ALTERED_SEARCH_PATH
            If eax = &NULL
                Call TryModuleFromAppDirectory D$StartOfDllName
            End_If

            Mov ebx D$ModuleHandlesListPointer, D$ebx eax
            add D$ModuleHandlesListPointer 4
        .End_If

        If eax = &NULL
            Mov esi D$StartOfDllName, B$ErrorLevel 4 | error D$BadLibNamePtr
        End_If

        Mov D$H.Dll eax
    popad
ret


[ExeSysDrvModuleName: D$ ? # 20]

Proc TryToLoadModule:
    Argument @Ext

        Mov esi D$StartOfDllName, edi ExeSysDrvModuleName
        While B$esi <> 0 | movsb | End_While
        Mov B$edi 0
        Move D$edi D@Ext | Mov B$edi+4 0

        Mov B$RosAsmDLL &TRUE | Call 'KERNEL32.GetModuleHandleA' ExeSysDrvModuleName

        .If eax = &NULL
            Mov B$RosAsmDLL &FALSE | Call 'KERNEL32.LoadLibraryExA' ExeSysDrvModuleName, 0, D$APICheckFlag

            If eax = &NULL
                Call TryModuleFromAppDirectory ExeSysDrvModuleName
            End_If

            If eax <> &NULL
                Mov ebx D$ModuleHandlesListPointer, D$ebx eax
                add D$ModuleHandlesListPointer 4
            End_If
        .End_If
EndP


;;
  Some users' reports seem to imply that, under some OS Versions, the Directory
  that is considered the default one, for the LoadLibrary Function, could be the
  one where RosAsm lies, instead of the one where the Compiled App lies.
  
  This routines tries to force the Full Path as a last rescue.
;;
[ModuleFullPath: B$ ? # &MAX_PATH]

Proc TryModuleFromAppDirectory:

    Argument @Module

    Uses edi,
         esi

    Mov edi ModuleFullPath,
        esi MainName

    While B$esi <> EOS | movsb | End_While

    While B$edi-1 <> '\' | sub edi (1*ASCII) | End_While

    Mov esi D@Module

    While B$esi <> EOS | movsb | End_While | movsb

    Call 'KERNEL32.LoadLibraryA' ModuleFullPath

;;

    If eax = 0
        ; Call 'KERNEL32.GetLastError'
        ; ---> &ERROR_NOACCESS 
            
        Call 'KERNEL32.CreateFileA' ModuleFullPath,
                                    &GENERIC_READ,
                                    &FILE_SHARE_READ+&FILE_SHARE_WRITE,
                                    0,
                                    &OPEN_EXISTING,
                                    &FILE_ATTRIBUTE_NORMAL,
                                    0
            
    End_If

;;

EndP


[Aerror: D$ ?]

VerifyFunctionExist:
    pushad
        Mov eax D$StartOfFunctionName

        If B$eax = '0'
            Mov esi eax | Call TranslateHexa
            Call 'KERNEL32.GetProcAddress' D$H.Dll, eax
            On eax = &NULL, error D$BadOrdinalPtr
        Else
            Call 'KERNEL32.GetProcAddress' D$H.Dll, D$StartOfFunctionName
        End_If

        .If eax = &NULL
            Mov edi D$StartOfFunctionName, al 0, ecx 0FFFF | repne scasb
            sub edi 2
            Push D$edi, edi
                If B$edi = 'A'
                    Mov B$Aerror &FALSE
                Else
                    inc edi | Mov al 'A' | stosb | Mov B$Aerror &TRUE
                End_If
                Mov al 0 | stosb

              ; test with ending 'A'
                Call 'KERNEL32.GetProcAddress' D$H.Dll, D$StartOfFunctionName

                Mov esi D$StartOfFunctionName, B$ErrorLevel 5  ; error5
            Pop edi, D$edi
            inc edi
            Push eax
                Mov al "'" | stosb | Mov al 0 | stosb          ; retore for string search
            Pop eax
            If eax = &NULL
                error D$BadFunctionNamePtr
            Else_If B$Aerror = &TRUE
                error D$MissingApiAPtr
            Else
                error D$NoAapiPtr
            End_If
        .End_If
    popad
ret

; Room for headers has been set by 'InitIndex' (CodeListPtr=CodeList+0400)

; We read a Dll Name in DllList (> first = #1)
; We read all #1Functions in ApiListB, and so on.

CreateImportSection:
 ; room for header = (dWord * 5) * (DllNumber + 1)
 ; room for Tables 1, 2 = FunctionNumber + group zero ending = FunctionNumber + DllNumber

    Mov D$H.Dll 0
    Mov edi D$CodeListPtr                   ; set at 0400 by 'List.a' initialisations
    Mov D$ImportHeaderPtr edi

    Mov eax D$Dllnumber | inc eax
    shl eax 2 | Mov ebx eax | shl ebx 2 | add eax ebx    ; (eax*4)+(eax*16) = eax * 20
    Mov ecx eax | Mov D$AppImportSize eax   ; write import header size in PE sections header
    Push eax
      Mov al 0 | rep stosb        ; room for header (eax = header size)
    Pop eax
    Mov D$ImportTablePtr edi      ; Pointer for Functions names adresses tables writing
    Mov eax D$FunctionNumber | add eax D$Dllnumber
    shl eax 2                     ; eax = room for Dwords (shl 2) ptrs
    Mov edx eax                   ; EDX = one table size
    add edi eax                   ; room for table 1
    Mov ebx edi
      sub ebx D$CodeList
      add ebx 01000                       ; 'uBaseOfImport' not yet filled
        sub ebx 0400                      ; 'uStartOfImport' not yet filled
          Mov D$AppSecondImport ebx       ; write adress in PE sections header
          Mov D$AppSecondImportSize edx   ; write size in PE sections header
    add edi eax                           ; room for table 2

    Mov esi D$DllList | Mov eax D$ApiListB,  D$ApiListBPtr eax
    Mov cl 1                              ; cl = DLL indice for each function

nextdll:
    On B$esi = ALEOD,  jmp L9>>     ; end mark in DllList
    Mov eax edi | sub eax D$CodeList | add eax 01000-0400
    Mov ebx D$ImportHeaderPtr
    Mov D$ebx+12 eax                ; List adress of dll name written at header fourth dWord
    Mov eax D$ImportTablePtr | sub eax D$CodeList | add eax 01000-0400
    Mov D$ebx eax | add eax edx | Mov D$ebx+16 eax
    Mov D$StartOfDllName edi
L0: lodsb                           ; from DllList
      cmp al 0 | je L1>
        stosb                       ; write dll name in Import name list
      jmp L0<
L1: Mov B$edi 0                     ; end mark in Import table (will be overwritten)

    Mov D$DllListPtr esi
    Mov al 0 | stosb
T0: Mov esi D$ApiListBPtr

L2: lodsb
     cmp al cl | je L4>             ; actual DLL function?
     cmp al, ALEOD | jne L3>        ; reach end of ApiListB ?
       Mov W$edi 0 | add edi 2
       test edi 1 ZERO T0>
         Mov B$edi 0 | inc edi
T0:    Mov ebx D$ImportTablePtr
       Mov D$ebx 0                 ; write function name end of chunk in table 1
       Mov D$ebx+edx 0             ; write function name end of chunk in table 2
       add D$ImportTablePtr 4      ; ready for next one
       inc cl
       Mov  esi D$DllListPtr
       add D$ImportHeaderPtr 20

       jmp nextdll
L3: lodsb
      cmp al 0 | jne L3<
        jmp L2<

L4: Mov ebx D$ImportTablePtr
    test edi 1 ZERO T0>
      Mov B$edi 0 | inc edi
T0: If B$esi = '0'
        pushad
            Push ebx, edx
                Call TranslateHexa | or eax 08000_0000
            Pop edx, ebx
            Mov D$ebx eax                  ; write function ordinal in table 1
            Mov D$ebx+edx eax              ; write function ordinal in table 2
            add D$ImportTablePtr 4         ; ready for next one
        popad
        Mov D$StartOfFunctionName esi
L5:     lodsb | cmp al 0 | jne L5<
    Else
        Mov eax edi | sub eax D$CodeList | add eax 01000-0400
        Mov D$ebx eax                  ; write function name adress in table 1
        Mov D$ebx+edx eax              ; write function name adress in table 2
        add D$ImportTablePtr 4         ; ready for next one
        Mov ax 0
        stosw
        Mov D$StartOfFunctionName edi

L5:     lodsb | stosb | cmp al 0 | jne L5<   ; writing Functions names list
    End_If
    jmp L2<<                    ; two '0' ??? needed ???... alignement needed ???
                                ; usual import tables names lists seem to be aligned.
L9: ret


BuildImport:
    Call InitApiTables

    Call SearchForApis      ; copy all api calls in ApiListA (> edi > end of ApiListA).

    If edi = D$ApiListA     ; case of DLL with no api Call
        Mov D$uBaseOfRsrc 01000, D$uImportSize 0 | ret
    End_If

    Call FullfillApiList   ; FullFill each Function in the 'MODULE.ext.Function' Form.

    Call SortApis          ; >>> Dll in DllList, Functions in ApiListB + Dll #n at first

    Call CreateImportSection

    Mov eax edi | AlignOn 0200 eax | Mov ecx eax | sub ecx edi

    Push edi, eax
      Mov al 0 | rep stosb  ; fill with 0 because destination have been "reused".
    Pop eax edi

    Mov D$CodeListPtr eax

    sub eax D$CodeList | sub eax 0400 | add eax 01000 | AlignOn 01000 eax
    Mov D$uBaseOfRsrc eax
    Mov eax edi | sub eax 0400 | sub eax D$CodeList | Mov D$uImportSize eax

  ; Release all the loaded Modules not belonging to RosAsm Process:
    Mov esi ModuleHandlesList
    While D$esi <> 0
        lodsd
        Push esi
            Call 'KERNEL32.FreeLibrary' eax
        Pop esi
    End_While
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

@ExportSectionComments:
;;
; Export Section looks like this:
;
; [.Export: D$ 0, 0, 0, DLLName, 1, NumberOfFunctions, NumberOfFunctions,
;              ExportAdressesTable, ExportNamesTable, ExportOrdinals
;
;  DLLName: 'MYDLL.DLL', 0  0 0 0 0 0 0 0 0 .....
;
;  ExportAdressesTable: Function1, Function2, Function3 ....
;
;  ExportNamesTable: Function1Name, Function2Name, Function3Name  ....
;
;  ExportOrdinals: W$ 0, 1, 2 ....
;
;
;      Function1Name: B$ 'Function1' EOS
;      Function2Name: B$ 'Function2' EOS
;      Function3Name: B$ 'Function3' EOS ....]
;;

[ExportAdressesTablePtr: D$ ?
 ExportNamesTablePtr: D$ ?
 ExportOrdinals: D$ ?
 FunctionNamesPtr: D$ ?
 ExportSectionLen: D$ ?
 FileAlignedExportSectionLen: D$ ?]

FillExportSection:
    Mov D$Ordinal 0
    Mov edi D$ExportListBPtr, eax 0 | stosd | stosd | stosd
    Mov ebx edi                         ; ebx ready to write the DLLName Pointer.
    stosd | Mov eax 1 | stosd
    add edi 8                           ; (nf / nf already written by 'NewBuildExport').
    add edi 12                          ; Start of DLLName.
    Mov eax edi | add eax D$ExportAjust
    Mov D$ebx eax                       ; write DLName pointer.

    Mov esi ChoosenFile
    Push edi
L0: lodsb
    If al >= 'a'
        and al 00_11011111
    End_If
    stosb | cmp B$esi '.' | ja L0<
    Pop eax

    Mov eax D$SavingExtension | or eax 020202000 | xor eax 020202000 | stosd
    Mov al 0 | stosb | AlignOn 4 edi

  ; edi points now to 'ExportAdressesTable'. We store the edi in the Header record
  ; 'FunctionsAdressesTable':
    Mov eax edi | add eax D$ExportAjust
    Mov esi D$ExportListBPtr, D$esi+28 eax, D$ExportAdressesTablePtr eax

  ; We will have as many dWords for Adresses as Exported Functions. So, next header record,
  ; 'ExportNamesTable' will be:
    Mov eax D$NumberOfExportedFunctions | shl eax 2 | add eax edi | add eax D$ExportAjust
    Mov esi D$ExportListBPtr, D$esi+32 eax, D$ExportNamesTablePtr eax
    sub eax D$ExportAjust | Mov edi eax

  ; We will have as many dWords for Names Pointers as Exported Functions.
    Mov eax D$NumberOfExportedFunctions | shl eax 2 | add eax edi | add eax D$ExportAjust
    Mov esi D$ExportListBPtr, D$esi+36 eax, D$ExportOrdinals eax
    sub eax D$ExportAjust | Mov edi eax

  ; We will have as many Words for Ordinals as Exported Functions.
    Mov eax D$NumberOfExportedFunctions | shl eax 1 | add eax edi | add eax D$ExportAjust
    Mov D$FunctionNamesPtr eax

    Mov esi D$ExportListAPtr

L1: Call StoreExportAdresse | Call StoreExportNamePtr
    Call StoreExportOrdinal | Call StoreFunctionName

    dec D$NumberOfExportedFunctions | jnz L1<
ret


; This is same as 'SearchRegularLabel' with some specifics (no error control -impossible-)
; + end control

[DataExportedLabel: D$ ?]

StoreExportAdresse:
    Mov B$DataExportedLabel &FALSE
    Mov edi D$LabelList | add edi 5

L0: Push esi

L1:     lodsb | Mov bl B$edi | inc edi
L2:     If al = '_'
            lodsb | jmp L2<
        Else_If al = EOI
            cmp bl EOI | je L8>
        Else_If al = ':'
            Mov B$DataExportedLabel &TRUE | jmp L8>
        Else_If al >= 'a'
            and al 00_11011111 | cmp al bl | je L1<
        Else
            cmp al bl | je L1<
        End_If

        cmp bl EOI | jbe L3>            ; case of LabelList name shorter than searched Label
        Mov ecx 0FF,  al EOI | repne scasb      ; longer: LabelList edi ptr > after next '|'
L3:     add edi 6                                   ; |LABELNAME|dWord FlagByte|NEXTNAME

L7: Pop esi | jmp L0<

L8: Pop esi
    Mov eax D$edi

    sub eax D$CodeList

    If B$DataExportedLabel = &FALSE
        add eax D$AppBaseOfCode
        sub eax D$AppStartOfCode
    Else
        add eax D$AppBaseOfData
        sub eax D$AppStartOfData
    End_If

    Mov edi D$ExportAdressesTablePtr | sub edi D$ExportAjust | stosd   ; Make it RVA.
    add D$ExportAdressesTablePtr 4
ret


StoreExportNamePtr:
    Mov edi D$ExportNamesTablePtr, eax D$FunctionNamesPtr
    sub edi D$ExportAjust
    stosd | add D$ExportNamesTablePtr 4
ret


[Ordinal: D$ ?]

StoreExportOrdinal:
    Mov edi D$ExportOrdinals, eax D$Ordinal | sub edi D$ExportAjust | stosw
    add D$ExportOrdinals 2 | inc D$Ordinal
ret


StoreFunctionName:
    Mov edi D$FunctionNamesPtr | sub edi D$ExportAjust
    While B$esi <> EOI
        If B$esi = ':'
            inc esi | jmp L2>
        End_If
        movsb
    End_While
L2: Mov al 0 | stosb | add edi D$ExportAjust | Mov D$FunctionNamesPtr edi
    inc esi
ret

[ExportsectionWanted: D$ ?
 NumberOfExportedFunctions: D$ ?]

[ExportListAPtr: D$ ?
 ExportListBPtr: D$ ?]
 __________________________________________________________________________________________
 __________________________________________________________________________________________
;;
 these 2 following stubs are used to create new PE. only 'Labelled' values are
 modified according with source values. Main filling work is done by the 'Build...'
 routines.

 These two stubs must remain all in one single data set (prevent from RosAms data
 alignement).

00000000: Dos exe file header stub:
;;

[DosHeader:
B$ 'MZ'  ; dos exe signature
D$ 030090; Size of file (I don't understand what it means...)
W$ 00    ; Number of reloc. adresses
W$ 04    ; this dos header size (16*4)
W$ 00    ; min size
W$ 0FFFF ; max size
W$ 00    ; SP reg. value at run time

W$ 0B8  ; checksum for header
W$ 00   ; IP reg. value
W$ 00   ; start of Cseg in file
W$ 00   ; start of reloc. table in file
W$ 040  ; overlay default
W$ 0,0,0

W$ 0,0,0,0, 0,0,0,0     ; reserved words

W$ 0,0,0,0
MyCheckSum: D$ 0  ; 30
PeHeaderPointer:
D$ 080   ; File adress of win header

B$   0E, 01F, 0BA, 0E, 00, 0B4, 09, 0CD, 021, 0B8, 01, 04C, 0CD, 021
; Push cs // Pop ds // Mov dx 0E // Mov ah 09 // int 021 // Mov ax 4C01 // int 021
; 18
B$ ;'Spindoz 32 spit PEfile made wiz RosAsm Assembler.$'
   'This program cannot be run in DOS mode', CR, LF, '$' EOS, 0, 0, 0, 0, 0, 0, 0, 0

; 50+18+30 = 98
; if you modify upper string you must absolutely keep the same lenght.

PeHeader:

B$ 'PE' EOS, 0          ; signature
W$ 014C                 ; 386 and more
NumberOfSections:
W$ 04                   ; 4 sections (code, data, import, resource) not 5...
B$ 0,0,0,0              ; time and date stamp
D$ 0                    ; pointer to symbol table (for debug)
D$ 0                    ; number of symbol
W$ 0E0                  ; size of 'optional header'
@PeHeaderCharacteristics:
W$ 00100001111          ; characteristics
   ; bit 0 > 1 > reloc. infos not there
  ; bit 1 > 1 > Runable
 ; bit 2 > 1 > no line number for debug
; bit 3 > 1 > no bebug symbol
; others : unknown
B$ 0B,01                ; referred as 'magic'...
W$ 03                   ; linker version
AppCodeSize: D$ 0       ; size of code (.text section)
AppAllDataSize: D$ 0    ; size of initialized data (.data + .rsrc+... + .reloc)
D$ 0                    ; size of uninitialised data
AppRVAentryPoint: D$ 0  ; RVA entry point adress (414h in RDNrect file)
AppBaseOfCode: D$ 0     ; RVA Base of code (0400 in file)
SHAppBaseOfData: D$ 0   ; RVA Base of data ('SH' because one more 'AppBaseOfData' down there)
ImageBase:
D$ 0400000              ; image base (linker base default)
D$ PAGE_SIZE            ; sections alignement
D$ 0200                 ; file alignement
W$ 04,00                ; OS version
W$ 01,00                ; image version
W$ 04,00                ; sub system version
B$ 00,00,00,00          ; reserved
AppRVAimageSize: D$ 0   ; RVA image size
D$ 0400                 ; headers size
CheckSum:
D$ 0                    ; checksum (works when zero)
SubSystem:
W$ 02                   ; sub system
DllCharacteristics:     ; 0001h - Per-Process Library Initialization
                        ; 0002h - Per-Process Library Termination
                        ; 0004h - Per-Thread Library Initialization
                        ; 0008h - Per-Thread Library Termination
W$ 0                   ; DLL characteristics
AppStackMax: D$ 0100000     ; stack max
AppStackMin: D$ 01000       ; stack min
AppHeapMax: D$ 0100000      ; heap max
AppHeapMin: D$ 0            ; heap min
D$ 0                   ; loader flags
D$ 0_10                 ; number of possible entries in following section table (16 records)

; Section table (called image data directory):
; first Dwords are the RVA adresses; second ones are the sizes
SectionTable:
D$                 00,                        00   ; export
; In fact, not 'Base_of' but rather a pointer to the Import Directory.
; Some Linkers do not write the Import Directory at first place of .Import,
; but at second place (why do it simple when you can do i complicated???...).
AppBaseOfImport: D$ 0  AppImportSize:       D$ 0   ; import header (Directory only)
AppBaseOfRsrc:   D$ 0    AppRsrcSize:       D$ 0   ; resource
D$                 00,                        00   ; exeption
D$                 00,                        00   ; security
RelocSectionTable:
D$                 00,                        00   ; Relocation
DebugDir:
D$                 00,                        00   ; debug
D$                 00,                        00   ; copyright
D$                 00,                        00   ; machine values (mips gp and global ptr)
D$                 00,                        00   ; thread local storage
D$                 00,                        00   ; load configuration directory
D$                 00,                        00   ;
AppSecondImport: D$ 0  AppSecondImportSize: D$ 0   ; second import (Address Table)
D$                 00,                        00
D$                 00,                        00
D$                 00,                        00

SectionsHeaders:

@idataSectionHeader:         ; (import section)

B$   '.idata' EOS, 0
AppImportTrueSize: D$ 0     ; EndOfImport - StartOfImport  true size (Virtual Size)
AppBaseOfImports: D$ 0      ; RVA
AppImportAlignedSize: D$ 0  ; 200h+ImportExt (Physical File Size)
AppStartOfImport: D$ 0      ; idata ptr
D$ 0,0,0
D$ 0_C0000040               ; readable, writable, initialised data


@ResourceSectionHeader:

B$ '.rsrc' EOS, 0, 0
AppRsrcTrueSize: D$ 0       ; EndOfResource-StartOfResource  true size
AppBaseOfRsrcs: D$ 0        ; RVA
AppRsrcAlignedSize: D$ 0    ; 200h+ResourceExt
AppStartOfRsrc: D$  0
D$ 0,0,0
D$ 0_40000040               ; readable initialised data


@DataSectionHeader:

B$ '.data' EOS, 0, 0
AppDataTrueSize: D$ 0       ; EndOfData-StartOfData  true size
AppBaseOfData: D$ 0         ; RVA
AppDataAlignedSize: D$ 0    ; 200h+DataExt    aligned size
AppStartOfData: D$ 0        ; data ptr
D$ 0,0,0
DataCharacteristics:
D$ 0_C0000040               ; readable, writable, initialised data


; Code section header: (the four 'dummy' D$ and W$ are of no mean in EXE and DLL files)

B$ '.text' EOS, 0, 0
AppTrueCodeSize: D$   0     ; true size of code in file
AppCodeRVAoffset: D$   0    ; RVA offset (aligned on 01000 boundary)
AppFileSizeOfCode: D$   0   ; file aligned size of code (0200 aligned)
AppStartOfCode: D$   00     ; pointer to code (true first code in file - not entry point-)
D$   00                     ; dummy reloc ptr
D$   00                     ; dummy line number ptr
W$   00                     ; dummy reloc number
W$   00                     ; dummy number of line number
CodeCharacteristics:
D$   0_60000020             ; characteristics (readable, runable, code)

@ExportSectionHeader:        ;, if any:
D$ 0 0
AppExpTrueSize: D$ 0
AppBaseOfExp: D$ 0
AppExpAlignedSize: D$ 0
AppStartOfExp: D$ 0   0 0 0
D$ 0_40000040               ; readable initialised data

@RelocSectionHeader:         ;, if Export:
D$ 0 0
@AppRelocTrueSize: D$ 0
@AppBaseOfReloc: D$ 0
@AppRelocAlignedSize: D$ 0
AppStartOfReloc: D$ 0   0 0 0
D$ 0_40000040               ; readable initialised data

D$ 0 0   0 0 0 0   0 0 0 0  ; just ensure to stop win search of sections.

D$ 0 0   0 0 0 0   0 0 0 0

@SourceSectionHeader:
B$ '.src' EOS, 0, 0, 0      ; Used by RosAsm only (not by loader: 4 sections, not 5)
AppSrcTrueSize: D$ 0        ; D$SourceLen  true size
AppBaseOfSrc: D$ 0          ; RVA
AppSrcAlignedSize: D$ 0     ; 200h+ResourceExt
AppStartOfSrc: D$  0
D$ 0,0,0
D$ 06000840                 ; Not readable initialised data; don't keep; don't cache...


EOPE:
PeHeaderSize: D$  EOPE-PeHeader]  ; 'Len' unusable here
 ________________________________________________________________________________________

; User stub main data:

[uImportSize: D$ 0  uRsrcSize: D$ 0  uDataSize: D$ 0  uCodeSize: D$ 0
 uStartOfImport: D$ 0  uStartOfRsrc: D$ 0  uStartOfData: D$ 0  uStartOfCode: D$ 0
 uEndOfFile: D$ 0  uBaseOfImport: D$ 0  uBaseOfRsrc: D$ 0  uBaseOfData: D$ 0
; uBaseOfExport: D$ 0 uExportSize: D$ 0
 uBaseOfCode: D$ 0  uImageSize: D$ 0  uCodeRVA: D$ 0  uAllDataSize: D$ 0
 @uStackMax: D$ 0  @uStackMin: D$ 0  @uHeapMax: D$ 0  @uHeapMin: D$ 0]

; exemple with the fixed values i used in the very first versions:

; [CodeExt 05C00  DataExt 01000  ImportExt 0200  RsrcExt 0200]
; [StartOfImport 0400]
; [StartOfRsrc   0800]   ; 0600+ImportExt (0200)
; [StartOfData   0C00]   ; 0800+ImportExt+RsrcExt (0400)
; [StartOfCode   1E00]   ; 0A00+ImportExt+RsrcExt+DataExt (01400)
; [EndOfFile     7D00]   ; 0C00+ImportExt+RsrcExt+DataExt+CodeExt (07100)

 _________________________________________________________________________________________

; For Saving here the true sizes of each section because they are aligned for computations.
; I need them at the end to fill the so called 'Virtual' sizes records (first record of
; each type header:


[ImportTrueSize: D$ 0       ; !!! * Ici embrouille si passe tout-ça en datas virtuelles
 ResourcesTrueSize: D$ 0    ; !!! problème à la compilation.
 DataTrueSize: D$ 0         ; !!! débordement à tous les coups...
 CodeTrueSize: D$ 0]        ; !!!

[LockInstruction: D$ ?]

[TrueUserDataSize: D$ 0]    ; !!! voir * ci-dessus si D$ ? au lieux de D$ 0 bug -> [@TODO.CheckTextDelimitersPairing]
                            ; [ClearUserStubMainData] ecx TrueUserDataSize | add ecx 4

; Was no use without the new DLLs stuff, but, when building a DLL after having an EXE PE
; compiled, some of these Data may remain with a 'wrong' value from the previous compilation.

ClearUserStubMainData:
    Mov edi uImportSize, eax 0, ecx TrueUserDataSize | add ecx 4
    sub ecx edi | shr ecx 2 | rep stosd
ret

UserMainData:
    Move D$ImportTrueSize D$uImportSize,
         D$ResourcesTrueSize D$uRsrcSize,
         D$DataTrueSize D$uDataSize

    Mov eax D$uImportSize | AlignOn 0200 eax

    Mov D$uImportSize eax | Mov ecx eax
    Mov eax D$uRsrcSize | AlignOn 0200 eax
    Mov D$uRsrcSize eax | add ecx, eax
    Move D$TrueUserDataSize D$uDataSize    ; preserve for the whole (with virtual size) Align
    Mov eax D$uDataSize | AlignOn 0200 eax
    Mov D$uDataSize eax | add ecx, eax
    Mov eax D$CodelistPtr | sub eax D$CodeList | sub eax 0400 | sub eax, ecx
    Move D$CodeTrueSize eax
    Mov D$AppTrueCodeSize eax
    AlignOn 0200 eax | Mov D$uCodeSize eax

    Mov eax 0400 | Mov D$uStartOfImport eax
        add eax D$uImportSize | Mov D$uStartOfRsrc eax
        add eax, D$URsrcSize | Mov D$uStartOfData eax
        add eax D$uDataSize | Mov D$uStartOfCode eax
        add eax D$uCodeSize | Mov D$uEndOfFile eax

    Mov eax 01000 | Mov D$uBaseOfImport eax
        add eax D$UImportSize | AlignOn 01000 eax
        Mov D$uBaseOfRsrc eax
        add eax D$uRsrcSize | AlignOn 01000 eax
        Mov D$uBaseOfData eax
        add eax D$TrueUserDataSize | add eax D$uVirtualDataSize | AlignOn 01000 eax
        Mov D$uBaseOfCode eax
        add eax D$uCodeSize | AlignOn 01000 eax
        Mov D$uImageSize eax

    Mov eax LINKERDEFAULT | add eax D$uBaseOfCode
        sub eax D$uStartOfCode | Mov D$uCodeRVA eax

    Mov eax D$uStartOfCode | sub eax D$uStartOfImport | Mov D$uAllDataSize eax
ret
 _______________________________________________________________________________________


PreparePeHeader:
  Call UserMainData

  Move D$AppCodeSize D$uCodeSize
  Move D$AppAllDataSize D$uAllDataSize

  Call SearchForEntryPoint
  sub eax D$CodeList | sub eax D$uStartOfCode | add eax D$uBaseOfCode
  Mov D$AppRVAentryPoint eax

  Move D$AppBaseOfCode D$uBaseOfCode
  Move D$SHAppBaseOfData D$uBaseOfData
  Move D$AppRVAimageSize D$uImageSize

;  hexprint D$uBaseOfCode,
;           D$uBaseOfImport,
;           D$uBaseOfCode

  Move D$AppBaseOfImport D$uBaseOfImport

  Move D$AppBaseOfRsrc D$uBaseOfRsrc
  Move D$AppRsrcSize D$uRsrcSize       ; should be unaligned size of the section

__________________

  Move D$AppCodeRVAoffset D$uBaseOfCode
  Move D$AppFileSizeOfCode D$uCodeSize
  Move D$AppStartOfCode D$uStartOfCode

  Mov eax D$DataTrueSize | add eax D$uVirtualDataSize

  Move D$AppDataTrueSize eax
  Move D$AppBaseOfData D$uBaseOfData
  Move D$AppDataAlignedSize D$uDataSize
  Move D$AppStartOfData D$uStartOfData

  Move D$AppImportTrueSize D$ImportTrueSize
  Move D$AppBaseOfImports D$uBaseOfImport
  Move D$AppImportAlignedSize D$uImportSize
  Move D$AppStartOfImport D$uStartOfImport

  Move D$AppRsrcTrueSize D$ResourcesTrueSize
  Move D$AppBaseOfRsrcs D$uBaseOfRsrc
  Move D$AppRsrcAlignedSize D$uRsrcSize
  Move D$AppStartOfRsrc D$uStartOfRsrc

; Store source values in .Src section:
  Move D$AppSrcTrueSize D$SourceLen
  Mov eax D$uBaseOfCode | add eax D$LenOfCode | AlignOn 01000 eax
  Mov D$AppBaseOfSrc eax
  Mov eax D$SourceLen | AlignOn 0200 eax
  Mov D$AppSrcAlignedSize eax
  Mov eax D$uEndOfFile | Mov D$AppStartOfSrc eax

; Copy:
  Mov esi DosHeader | Mov edi D$CodeList
  Mov ecx 080 | rep movsb                                   ; store Dos header
  Mov ecx D$PeHeaderSize | Mov esi PeHeader | rep movsb     ; room for PE header
ret


[LocOfSourceHeader: D$ ?]

WritePeHeaders:
    or D$SavingExtension 020202000 | xor D$SavingExtension 020202000

    Mov esi DosHeader, edi D$CodeList

    Mov ecx PeHeader | sub ecx esi | shr ecx 2 | rep movsd

    Mov W$edi 'PE', W$edi+2 0                   ; signature
    add edi 4 | Mov W$edi 014C                  ; 386 and more

  ; Compute Number of Sections (NumberOfSections):
    Mov eax 1                                   ; Code Section anyway, i suppose.
    On D$uImportSize > 0, inc eax               ; If Import Section wanted.
    On D$uRsrcList > 0, inc eax                 ; If Resources Section wanted.
    On D$uDataSize > 0, inc eax                 ; If Data Section wanted.
                                                ; Code section assumed.
    On B$ExportsectionWanted = &TRUE, inc eax   ; If Export Section wanted.

    If D$SavingExtension = '.SYS'
        jmp L1>
    Else_If D$FL.RelocsWanted = &TRUE ;D$SavingExtension = '.DLL' ; jE!
L1:     On D$RelocSectionSize => 8, inc eax      ;jE! If Reloc Section wanted.
    End_If
    add edi 2 | stosw                           ; NumberOfSections

    Mov eax 0 | stosd | stosd | stosd           ; time and date stamp
                                                ; pointer to symbol table (for debug)
                                                ; number of symbol
    Mov W$edi 0E0 | add edi 2                   ; size of 'optional header'

    Mov eax &IMAGE_FILE_32BIT_MACHINE__&IMAGE_FILE_EXECUTABLE_IMAGE
    or eax &IMAGE_FILE_LINE_NUMS_STRIPPED__&IMAGE_FILE_LOCAL_SYMS_STRIPPED
    If D$SavingExtension = '.DLL'
        or eax &IMAGE_FILE_DLL
        On D$RelocSectionSize < 8, or eax &IMAGE_FILE_RELOCS_STRIPPED ;jE!
    Else_If D$SavingExtension = '.SYS'
        On D$RelocSectionSize < 8, or eax &IMAGE_FILE_RELOCS_STRIPPED ;jE!
    Else
        or eax &IMAGE_FILE_RELOCS_STRIPPED
    End_If


    Mov W$edi ax | add edi 2                    ; 'PeHeaderCharacteristics'

    Mov D$edi 03010B | add edi 4                ; B$ 0B,01  ; referred as 'magic'...
                                                ; W$ 03     ; Dummy linker version (???)
    Mov eax D$uCodeSize | stosd                 ; size of code (.text section)

    Mov eax D$AppAllDataSize | stosd            ; size of initialized data (.data + .rsrc+... + .reloc)

    Mov D$edi 0 | add edi 4                     ; Never any real Uninitialised section.

    Call SearchForEntryPoint
    sub eax D$CodeList | sub eax D$uStartOfCode
    add eax D$uBaseOfCode | stosd               ; RVA entry point (Adress of 'Main:')

    Mov eax D$uBaseOfCode | stosd               ; RVA Base of code (0400 in file)
    Mov eax D$uBaseOfData | stosd               ; RVA Base of data

    If D$SavingExtension = '.DLL'
        Mov eax D$LinkerDllDefault
    Else_If D$SavingExtension = '.SYS'
        Mov eax DRIVERDEFAULT
    Else
        Mov eax LINKERDEFAULT                   ; image base
    End_If

   ; Mov eax LINKERDEFAULT ; ??? Should it be allowed or not ???
   ; Does not seem to work... Whereas 2 indentical DLLs, with same Base work well.
    stosd

    Mov D$edi PAGE_SIZE | add edi 4             ; sections alignement
    Mov D$edi 0200 | add edi 4                  ; file alignement

    Mov D$edi 04 | add edi 4                    ; W$ 04,00       ; OS version
    Mov D$edi 01 | add edi 4                    ; W$ 01,00       ; image version
    Mov D$edi 04 | add edi 4                    ; W$ 04,00       ; sub system version
    Mov eax 0 | stosd                           ; B$ 00,00,00,00 ; reserved

; 'AppRVAimageSize:'
    Mov D$FinalImageSize edi
    Mov eax 0 | stosd                           ; RVA image size
    Mov D$edi 0400 | add edi 4                  ; headers size
    Mov D$edi 0 | add edi 4                     ; checksum (works when zero)
    Mov ax W$SubSystem | stosw                  ; sub system

    If D$SavingExtension = '.DLL'
        Mov ax W$DllCharacteristics
    Else_If D$SavingExtension = '.SYS'
        Mov W$edi-2 1 ; SubSystem NATIVE jE! - corrected.
        Mov ax 0; &IMAGE_DLLCHARACTERISTICS_WDM_DRIVER. removed WDM, bcoz WDM is not unloadable
    Else
        Mov eax 0
    End_If
    stosw                                       ; DllCharacteristics
    Mov eax D$AppStackMax | stosd
    Mov eax D$AppStackMin | stosd
    Mov eax D$AppHeapMax | stosd
    Mov eax D$AppHeapMin | stosd

    Mov D$edi 0 | add edi 4                     ; loader flags
    Mov D$edi 010 | add edi 4                   ; number of possible entries in following
                                                ; section table (16 records)
    _________________________

    Push edi
        Mov eax 0, ecx 020 | rep stosd  ; Clear all 16 * (2 dWords) Entires ('SectionTable').
    Pop edi

 [FinalBaseOfExport: D$ ?
  FinalAppBaseOfReloc: D$ ?
  FinalImageSize: D$ ?]

    If B$ExportsectionWanted = &TRUE
        Mov D$FinalBaseOfExport edi, eax 0 | stosd
        Mov eax D$ExportSectionLen | stosd
    Else
        add edi 8
    End_If

    If D$uImportSize > 0
        Mov eax D$uBaseOfImport | stosd
        Mov eax D$Dllnumber | inc eax
        shl eax 2 | Mov ebx eax | shl ebx 2 | add eax ebx    ; (eax*4)+(eax*16) = eax * 20
        stosd
    Else
        add edi 8
    End_If

    If D$uRsrcList > 0
        Mov eax D$uBaseOfRsrc | stosd
        Mov eax D$uRsrcSize | stosd
    Else
        add edi 8
    End_If

    add edi 16                                  ; Now pointing to 'RelocSectionTable'

    .If D$SavingExtension = '.SYS'
        jmp L1>
    .Else_If D$FL.RelocsWanted = &TRUE ;D$SavingExtension = '.DLL' ; jE!
L1:     If D$RelocSectionSize => 8 ;jE!
            Mov eax 0, D$FinalAppBaseOfReloc edi | stosd
            Mov eax D$RelocSectionSize | stosd
        Else
            add edi 8
        End_If
    .Else
        add edi 8
    .End_If

    add edi (12*4)                              ; Now pointing to 'AppSecondImport'

    Mov eax D$AppSecondImport | stosd
    Mov eax D$AppSecondImportSize | stosd

    add edi (6*4)                               ; Now pointing to 'SectionsHeaders'
    _____________

    Mov D$NextSectionHeaderRVA 01000, D$NextSectionHeaderFilePointer 0400

    If D$uImportSize > 0
        Call WriteOneSectionHeader '.ida', 'ta', D$ImportTrueSize,
            &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
    End_If

    If D$uRsrcList > 0
        Call WriteOneSectionHeader '.rsr', 'c', D$ResourcesTrueSize,
            &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ
    End_If

    If D$uDataSize > 0
        Push D$NextSectionHeaderRVA
        Mov eax D$DataTrueSize
        Call WriteOneSectionHeader '.dat', 'a', eax, D$DataCharacteristics
           ; &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE

      ;  Mov eax D$uDataSize | add eax D$uVirtualDataSize
        Mov eax D$TrueUserDataSize | add eax D$uVirtualDataSize

        Pop D$NextSectionHeaderRVA
        Mov D$edi-(8*4) eax | AlignOn 01000 eax | add D$NextSectionHeaderRVA eax
    End_If

  ; 'AppTrueCodeSize'
    Call WriteOneSectionHeader '.tex', 't', D$CodeTrueSize, D$CodeCharacteristics
       ; &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_MEM_EXECUTE___&IMAGE_SCN_MEM_READ

  ; 'ExportSectionHeader'
    If B$ExportsectionWanted = &TRUE
        Mov ebx D$FinalBaseOfExport, eax D$NextSectionHeaderRVA, D$ebx eax

        Call WriteOneSectionHeader '.eda', 'ta', D$ExportSectionLen,
            &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ
    End_If

  ; 'RelocSectionHeader'
    .If D$SavingExtension = '.SYS'
        jmp L1>
    .Else_If D$FL.RelocsWanted = &TRUE ;D$SavingExtension = '.DLL' ; jE!
L1:     If D$RelocSectionSize => 8 ;jE!
            Mov ebx D$FinalAppBaseOfReloc, eax D$NextSectionHeaderRVA, D$ebx eax

            Call WriteOneSectionHeader '.rel', 'oc', D$RelocSectionSize,
                &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ
        End_If
    .End_If

    Mov ebx D$FinalImageSize, eax D$NextSectionHeaderRVA, D$ebx eax

  ; Security Dummy empty Headeers before Source
    Mov eax 0, ecx 10 | rep stosd
  ; SourceSectionHeader
  ; Not readable initialised data; don't keep; don't cache...
    Mov D$LocOfSourceHeader edi
    Call WriteOneSectionHeader '.src', 0, D$SourceLen, 06000840

    Mov ecx D$CodeList | add ecx 0400 | sub ecx edi | shr ecx 2
    Mov eax 0 | rep stosd
;Else
;    Mov ecx 20, eax 0 | rep stosd
;End_If
ret


; Writes 10 dWords for each Section Header:

[NextSectionHeaderRVA: D$ ?
 NextSectionHeaderFilePointer: D$ ?]

Proc WriteOneSectionHeader:
    Arguments @NameLow, @NameHigh, @Size, @Flags

        Mov eax D@NameLow | stosd
        Mov eax D@NameHigh | stosd
        Mov eax D@Size | stosd
        Mov eax D$NextSectionHeaderRVA | stosd
        Mov eax D@Size | AlignOn 0200 eax | stosd
        Mov ecx eax
        AlignOn 01000 eax | add D$NextSectionHeaderRVA eax
        Mov eax D$NextSectionHeaderFilePointer | stosd
        Mov eax 0 | stosd | stosd | stosd
        Mov eax D@Flags | stosd
        add D$NextSectionHeaderFilePointer ecx
EndP



;&IMAGE_FILE_32BIT_MACHINE 0100h
;IMAGE_FILE_AGGRESIVE_WS_TRIM 010h
;&IMAGE_FILE_BYTES_REVERSED_HI 8000h
;&IMAGE_FILE_BYTES_REVERSED_LO 080h
;IMAGE_FILE_DEBUG_STRIPPED 0200h
;&IMAGE_FILE_DLL 2000h
;&IMAGE_FILE_EXECUTABLE_IMAGE 02h
;IMAGE_FILE_LARGE_ADDRESS_AWARE 020h
;&IMAGE_FILE_LINE_NUMS_STRIPPED 04h
;&IMAGE_FILE_LOCAL_SYMS_STRIPPED 08h
;IMAGE_FILE_NET_RUN_FROM_SWAP 0800h
;IMAGE_FILE_NET_RUN_FROM_SWAP 800
;IMAGE_FILE_RELOCS_STRIPPED 01h
;IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 0400h
;IMAGE_FILE_SYSTEM 1000h
;IMAGE_FILE_UP_SYSTEM_ONLY 4000h
 _________________________________________________________________________________________

@ResourcesStub:
____________________________________________________________________________________________

[NodeFlag  080000000]

    ;RT_NEWRESOURCE      02000
    ;RT_ERROR            07fff

[RT_AVI              0-1
 RT_WAVE             0-2
 RT_CURSOR           00_0001
 RT_BITMAP          00_0010
 RT_ICON             00_0011
 RT_MENU             00_0100
 RT_DIALOG           00_0101
 RT_STRING           00_0110
 RT_FONTDIR          00_0111
 RT_FONT             00_1000
 RT_ACCELERATORS     00_1001
 RT_RCDATA           00_1010
 RT_MESSAGETABLE     00_1011
 RT_GROUP_CURSOR     00_1100
 RT_GROUP_ICON       00_1110
 RT_VERSION     00_0001_0000]

    ;[RT_NEWBITMAP        (RT_BITMAP|RT_NEWRESOURCE)
    ; RT_NEWMENU          (RT_MENU|RT_NEWRESOURCE)
    ; RT_NEWDIALOG        (RT_DIALOG|RT_NEWRESOURCE) ]

;RT_GROUP_CURSOR  equ RT_CURSOR + DIFFERENCE
;RT_GROUP_ICON  equ RT_ICON + DIFFERENCE
;RT_VERSION   equ 16
;RT_DLGINCLUDE  equ 17
;RT_PLUGPLAY  equ 19
;RT_VXD   equ 20
;RT_ANICURSOR  equ 21
;RT_ANIICON   equ 22
;RT_HTML   equ 23
 ________________________________________________________________________________________

; Level 2: (resource TYPEs directory)

[@Level2Rt_Icon:
W$ 0,0,0,0,0,0,0,1   ; 1 record
D$ 01, 080000050     ;Level3Rt_Icon-StartOfRsrc+NodeFlag;80000070h; ID 1: icon; > 0C70h

@Level2Rt_Group_Icon:
W$ 0,0,0,0,0,0,0,1   ; 1 record
D$ 064, 080000068    ;Level3Rt_Group_Icon-StartOfRsrc+NodeFlag; ID 64h: Group icon > 0C88h

; Level 3: (last one to one language resources pointers - lang. dir -)

@Level3Rt_Icon:
W$ 0,0,0,0,0,0,0,1
D$ 0409, 080 ;Level4Rt_Icon-StartOfRsrc;B8h, 409 = langage ID: can_english; B8h > CB8h

@Level3Rt_Group_Icon:
W$ 0,0,0,0,0,0,0,1
D$ 0409, 090  ;Level4Rt_Group_Icon-StartOfRsrc   ;C8h, CC8h

;Level 4: (records of each resource: PTR, size, CodePage, reserved)

;;RsrcRVA = BaseOfRsrc-StartOfRsrc

@Level4Rt_Icon:
;;D$ IconHeader+RsrcRVA, 02E8, 0, 0  ; icon at CF0h;         size=2E8h
D$ 020A8, 02E8, 0, 0

@Level4Rt_Group_Icon:
;;D$ Group_Icon+RsrcRVA, 014, 0, 0   ; group icon at FD8h;   size = 14h
D$ 02390, 014, 0, 0

; icon data. This icon image is for compilation only. At start of RosAsm Run, the default
; icon is copyed from Icon Editor to here. The Editor version is in fact used as temporary
; storage.

uIcon:

@IconHeader:
B$ 028,0,0,0   ; size
 020,0,0,0     ; width
 040,0,0,0     ; height (maybe 40h because of the two masks)
 01,0          ; planes
 04,0          ; bit count
 0,0,0,0       ; compression 0
 080,02,0,0    ; 0280 > size of icon data
 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0   ; (dummy)


@IconPalette:
;Blue,green,red,0    (16 color palette -values seams to be fixed ones-)

   0,  0,  0,  0 ; color 0
   0,  0,080,  0 ;       1
   0,080,  0,  0 ;       2
   0,080,080,  0 ;       3
 080,  0,  0,  0 ;       4
 080,  0,080,  0 ;       5
 080,080,  0,  0 ;       6
 0C0,0C0,0C0,  0 ;       7
 080,080,080,  0 ;       8
   0,  0,0FF,  0 ;       9
   0,0FF,  0,  0 ;       A
   0,0FF,0FF,  0 ;       B
 0FF,  0,  0,  0 ;       C
 0FF,  0,0FF,  0 ;       D
 0FF,0FF,  0,  0 ;       E
 0FF,0FF,0FF,  0 ;       F

@IconXorMask:
; XOR color mask: (32*16 octets > 2 pixels / byte > 32*32 pixels)

     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0C,0F0,  0
    09,099,099,099,099,099,099,099,099,099,099,099,099, 0C,0C0,  0
    09,099,099,099,099,099,099,099,099,099,099,099,099, 0C,0CC,  0
     0,  0, 09,099,099,099,099,099,099,099,099,099,099, 0C,0CC,0C0
    03,03B, 09,099,099,099,099,099,099,099,099,099,099, 0C,0CC,0CF
     0,033, 09,099,090,  0,  0,  0,  0,099,099,099,099, 0C,0CC,0CF
     0, 03, 09,099,090,0DB,0BB,0BB,0B0,099,099,099,099, 0C,0CC,0CF
     0,  0, 09,099,090,0DD,0BB,0BB,0B0,099,099,099,099, 0C,0CC,0CF
     0,  0, 09,099,090,0DD,0DB,0BB,0B0,099,099,099,099, 0C,0CC,0CF
     0,  0, 09,099,090,0DD,0DD,033,030,099,099,099,099, 0C,0CC,0CF
     0,  0,  0,  0,  0,0DD,0DD,0FF,0F0,099,099,099,099, 0C,0CC,0CF
     0,  0, 03,03B,0BB,0BD,0DD,  0,  0,099,099,099,099, 0C,0CC,0CF
     0, 0F,  0,033,0BB,0BB,0DD,  0,  0,099,099,099,099, 0C,0CC,0CF
     0,  0,0C0, 03,03B,0BB,0BD,  0,  0,  0,  0,  0,  0, 0C,0CC,0CF
    0E,0E0,0CC,  0,033,033,033,  0, 0F,033,0BB,0BB,0BB,0BB,0CC,0CF
    0E,0E0,0CC,0C0,  0,  0,  0,  0,0FF,0F3,03B,0BB,0BB,0BB,0BC,0CF
    0E,0E0,0CC,0CC,  0,  0,  0,  0, 0C,0FF,033,0BB,0BB,0BB,0BB,0CF
    0E,0E0,0CC,0CC,  0, 0E,0EE,0EE, 0C,0CF,0F3,033,033,033,033,03F
    0E,0E0,0CC,0CC,  0, 0E,0EE,0EE, 0C,0CC,0FF,0FF,0FF,0FF,0FF,0FF
    0E,0E0,0CC,0CC,  0, 0E,0EE,0EE, 0C,0CC,0CF,0FF,0FF,0FF,0FF,0FF
    0E,0E0,  0,  0,  0, 0E,0EE,0EE, 0C,0C0,  0,  0,  0,  0,  0,  0
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,  0
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0C0
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0CC
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0CC
     0,  0,  0,  0,  0,  0,  0,  0, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0CC
    03,03B,0BB,0BB,0BB,0BB,0BB,0BB,0BB,0C0,0AA,0AA,0AA,0AA, 0C,0CC
     0,033,0BB,0BB,0BB,0BB,0BB,0BB,0BB,0B0,0AA,0AA,0AA,0AA, 0C,0CC
     0, 03,03B,0BB,0BB,0BB,0BB,0BB,0BB,0B0,  0,  0,  0,  0, 0C,0CC
     0,  0,033,033,033,033,033,033,033,033, 03,0BB,0BB,0BB,0BB,0CC
     0,  0,  0,  0,  0,  0,  0,  0,  0,0FF,0F0,03B,0BB,0BB,0BB,0BC
     0,  0,  0,  0,  0,  0,  0,  0,  0,0FF,0FF, 03,033,033,033,033

@IconAndMask:
; AND monochrome mask: (8*16 octects > 8 pixels / byte > 32*32 pixels)

     0,  0,  0, 07,  0,  0,  0, 07,  0,  0,  0, 03,  0,  0,  0, 01
   080,  0,  0,  0,0C0,  0,  0,  0,0E0,  0,  0,  0,0F0,  0,  0,  0
   0F0,  0,  0,  0,0F0,  0,  0,  0,0F0,  0,  0,  0,0F8, 03,080,  0
   0EC, 03,080,  0, 06, 03,080,  0, 03, 03,080,  0, 01,0FF,  0,  0
     0,0C0,  0,  0,  0,0C0,  0,  0,  0,0C0,  0,  0,  0,0C0,  0,  0
     0,  0,  0, 07,  0,  0,  0, 03,  0,  0,  0, 01,  0,  0,  0,  0
     0,  0,  0,  0,  0,  0,  0,  0,080,  0,  0,  0,0C0,  0,  0,  0
   0E0,  0,  0,  0,0F0,  0,  0,  0,0FF,0FF,0C0,  0,0FF,0FF,0C0,  0

uIconEnd:
;;
 Group icon and entry may be considered as fixed, like upper headers. Theorycaly, they are
 not, but in practice, they are. More than that, all these values don't seam to be used
 by win95: changing them all to anything else doesn't make any difference... I suppose
 that Win simply reads the sections headers and jumps directly to the file icon header
 (before palette), which one is NOT unused.
;;
; group icon: (icons directory)

uGroupIcon:
W$  00      ; reserved
    01      ; type 1 (always)
    01      ; 1 entry following
            ; As opposed to what doc says: no padding here.
; icon entry:
B$ 020, 020 ; width, height
B$ 010, 0   ; 16 colors, reserved
W$ 01, 04   ; 1 color plane, 4 bits
D$ 02E8     ; size in bytes (true)
W$ 1        ; Seams to be the order number for both Cursors and icons as they come in the tree.
uGroupIconEnd:
@EndOfRsrc: 0] ; !!! WORD
____________________________________________________________________________________________

[CopyOfuIcon:

;CopyOfIconHeader:
B$ 028,0,0,0   ; size
 020,0,0,0     ; width
 040,0,0,0     ; height (maybe 40h because of the two masks)
 01,0          ; planes
 04,0          ; bit count
 0,0,0,0       ; compression 0
 080,02,0,0    ; 0280 > size of icon data
 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0   ; (dummy)


;CopyOfIconPalette:
;Blue,green,red,0    (16 color palette -values seams to be fixed ones-)

   0,  0,  0,  0 ; color 0
   0,  0,080,  0 ;       1
   0,080,  0,  0 ;       2
   0,080,080,  0 ;       3
 080,  0,  0,  0 ;       4
 080,  0,080,  0 ;       5
 080,080,  0,  0 ;       6
 0C0,0C0,0C0,  0 ;       7
 080,080,080,  0 ;       8
   0,  0,0FF,  0 ;       9
   0,0FF,  0,  0 ;       A
   0,0FF,0FF,  0 ;       B
 0FF,  0,  0,  0 ;       C
 0FF,  0,0FF,  0 ;       D
 0FF,0FF,  0,  0 ;       E
 0FF,0FF,0FF,  0 ;       F

;CopyOfIconXorMask:
; XOR color mask: (32*16 octets > 2 pixels / byte > 32*32 pixels)

     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0C,0F0,  0
    09,099,099,099,099,099,099,099,099,099,099,099,099, 0C,0C0,  0
    09,099,099,099,099,099,099,099,099,099,099,099,099, 0C,0CC,  0
     0,  0, 09,099,099,099,099,099,099,099,099,099,099, 0C,0CC,0C0
    03,03B, 09,099,099,099,099,099,099,099,099,099,099, 0C,0CC,0CF
     0,033, 09,099,090,  0,  0,  0,  0,099,099,099,099, 0C,0CC,0CF
     0, 03, 09,099,090,0DB,0BB,0BB,0B0,099,099,099,099, 0C,0CC,0CF
     0,  0, 09,099,090,0DD,0BB,0BB,0B0,099,099,099,099, 0C,0CC,0CF
     0,  0, 09,099,090,0DD,0DB,0BB,0B0,099,099,099,099, 0C,0CC,0CF
     0,  0, 09,099,090,0DD,0DD,033,030,099,099,099,099, 0C,0CC,0CF
     0,  0,  0,  0,  0,0DD,0DD,0FF,0F0,099,099,099,099, 0C,0CC,0CF
     0,  0, 03,03B,0BB,0BD,0DD,  0,  0,099,099,099,099, 0C,0CC,0CF
     0, 0F,  0,033,0BB,0BB,0DD,  0,  0,099,099,099,099, 0C,0CC,0CF
     0,  0,0C0, 03,03B,0BB,0BD,  0,  0,  0,  0,  0,  0, 0C,0CC,0CF
    0E,0E0,0CC,  0,033,033,033,  0, 0F,033,0BB,0BB,0BB,0BB,0CC,0CF
    0E,0E0,0CC,0C0,  0,  0,  0,  0,0FF,0F3,03B,0BB,0BB,0BB,0BC,0CF
    0E,0E0,0CC,0CC,  0,  0,  0,  0, 0C,0FF,033,0BB,0BB,0BB,0BB,0CF
    0E,0E0,0CC,0CC,  0, 0E,0EE,0EE, 0C,0CF,0F3,033,033,033,033,03F
    0E,0E0,0CC,0CC,  0, 0E,0EE,0EE, 0C,0CC,0FF,0FF,0FF,0FF,0FF,0FF
    0E,0E0,0CC,0CC,  0, 0E,0EE,0EE, 0C,0CC,0CF,0FF,0FF,0FF,0FF,0FF
    0E,0E0,  0,  0,  0, 0E,0EE,0EE, 0C,0C0,  0,  0,  0,  0,  0,  0
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,  0
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0C0
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0CC
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0CC
     0,  0,  0,  0,  0,  0,  0,  0, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0CC
    03,03B,0BB,0BB,0BB,0BB,0BB,0BB,0BB,0C0,0AA,0AA,0AA,0AA, 0C,0CC
     0,033,0BB,0BB,0BB,0BB,0BB,0BB,0BB,0B0,0AA,0AA,0AA,0AA, 0C,0CC
     0, 03,03B,0BB,0BB,0BB,0BB,0BB,0BB,0B0,  0,  0,  0,  0, 0C,0CC
     0,  0,033,033,033,033,033,033,033,033, 03,0BB,0BB,0BB,0BB,0CC
     0,  0,  0,  0,  0,  0,  0,  0,  0,0FF,0F0,03B,0BB,0BB,0BB,0BC
     0,  0,  0,  0,  0,  0,  0,  0,  0,0FF,0FF, 03,033,033,033,033

;CopyOfIconAndMask:
; AND monochrome mask: (8*16 octects > 8 pixels / byte > 32*32 pixels)

     0,  0,  0, 07,  0,  0,  0, 07,  0,  0,  0, 03,  0,  0,  0, 01
   080,  0,  0,  0,0C0,  0,  0,  0,0E0,  0,  0,  0,0F0,  0,  0,  0
   0F0,  0,  0,  0,0F0,  0,  0,  0,0F0,  0,  0,  0,0F8, 03,080,  0
   0EC, 03,080,  0, 06, 03,080,  0, 03, 03,080,  0, 01,0FF,  0,  0
     0,0C0,  0,  0,  0,0C0,  0,  0,  0,0C0,  0,  0,  0,0C0,  0,  0
     0,  0,  0, 07,  0,  0,  0, 03,  0,  0,  0, 01,  0,  0,  0,  0
     0,  0,  0,  0,  0,  0,  0,  0,080,  0,  0,  0,0C0,  0,  0,  0
   0E0,  0,  0,  0,0F0,  0,  0,  0,0FF,0FF,0C0,  0,0FF,0FF,0C0,  0

CopyOfuIconEnd: D$ CopyOfuIconEnd-CopyOfuIcon]

____________________________________________________________________________________________

;;
 This is what would looks like a hand made menu:

[uMenu:     U$ 01 04 00 00       ; 01 unknown by me; 04 must be &RT_MENU

0 0 0 0          M00_Tree       0   0  '&Tree' 0  0


0 0 0 0          0                0   1  '&File' 0  0 0 0
0 0 0 0          M00_New         0   0  '&New' 0
0 0 0 0          M00_Open        0   0  '&Open' Tab 'F3' 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 0 0          M00_Open_source_only 0   0  'Open source only' 0
0 0 1 0          M00_Open_Icon_only   0   0  'Open Icon only' 0
0 0 1 0          M00_Open_Menu_only   0   0  'Open Menu only' 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 1 0          M00_Side_open   0   0  '&Side open' 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 1 0          M00_Save_As      0   0  'Save &As' 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 0 0          M00_Save_Source_only 0   0  'Save source only' Tab 'F2' 0 0
0 0 1 0          M00_Save_Icon_only   0   0  'Save Icon only' Tab 'F2' 0 0
0 0 1 0          M00_Save_Menu_only   0   0  'Save Menu only' Tab 'F2' 0 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 0 0          M00_Exit        0 080  'E&xit' Tab 'Alt+X' 0 0


0 0 0 0          0               0   1  '&Edit' 0  0 0 0
0 0 1 0          M00_Undo       0   0  '&Undo' Tab 'Ctrl+Z' 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 0 0          M00_Cut        0   0  'Cu&t' Tab 'Ctrl+X'   0 0
0 0 0 0          M00_Copy       0   0  '&Copy' Tab 'Ctrl+C'    0
0 0 0 0          M00_Paste      0   0  '&Paste' Tab 'Ctrl+V' 0 0
0 0 0 0          M00_Delete     0   0  '&Delete' Tab 'Del'   0 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 1 0          M00_Select_All  0 080  'Select &All'  0 0

0 0 0 0          0               0   1  'Search' 0 0 0
0 0 0 0          M00_Find       0   0  'Find' 0
0 0 0 0          M00_Replace    0 080  'Replace' 0 0

0 0 0 0          M00_Compile      0   0  '&Compile' 0           ; alone

0 0 1 0          M00_Run          0   0  '&Run' 0

0 0 0 0          M00_Calc         0   0  'Calc' 0

0 0 1 0          M00_HexAsc       0   0  'HexAsc' 0

0 0 0 0          0                 0   1  'Resources' 0 0 0 0
0 0 0 0          M00_Icon         0   0  '&Icon' 0 0
0 0 1 0          M00_Dialog_box       0   0  '&Dialog Box' 0 0
0 0 1 0          M00_BitMap       0   0  '&BitMap' 0 0
0 0 1 0          M00_Cursor       0   0  '&Cursor' 0 0
0 0 1 0          M00_String       0   0  '&String' 0 0
0 0 1 0          M00_Font         0   0  '&Font' 0 0
0 0 1 0          M00_Accelerators 0   0  '&Accelerators' 0 0
0 0 1 0          M00_RcData       0   0  'RcData' 0
0 0 1 0          M00_MessageTable 0   0  'MessageTable' 0
0 0 0 0          M00_Menus         0 080  '&Menus' 0

0 0 0 0          M00_Configuration       0   0  'Configuration' 0 0

0 0 0 0          0                 0    1  '&Help' 0 0 0 0
0 0 0 0          M00_Help_Editor    0    0  'Help &Editor' 0
0 0 0 0          M00_Help_Tree_view    0    0  'Help Tree &View' 0 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 1 0          M00_Asm_Mnemonics        0    0  'Asm &Mnemonics' 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 1 0          M00_Win32_Api_List         0    0  'Win32 &Api List' 0 0
0 0 1 0          M00_Win32_Equates_List      0    0  'Win32 E&quates List' 0 0
0 0 1 0          M00_Win32_Structures_List        0    0  'Win32 &Structures List' 0
0 0 1 0          M00_Win32_Data_Types        0    0  'Win32 Data &Types' 0 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 0 0          M00_About        0  080  '&About' Tab 'F1' 0 0

0 0 0 0          M00_<<<<_         0   0  '   <<<<  ' 0 0

0 0 0 0          M00_>>>>_      0   080  '   >>>>  ' 0 0


    ; hot keys (see later):

  ;  01  070  03E8  00    ;03E8 > about ID  (F1)
  ;  01  071  03F4  00    ;03F4 > Save ID   (F2)
  ;  01  072  03EC  00    ;03EC > Open ID   (F3)
  ; 090  078  03ED  00    ;03ED > Exit ID   (Alt-X)  78 > 'x'

  ; D$ 0 0 0 0 0 0 0

uMenuEnd:]
;;

 __________________________________________________________________________________________
;;
 Resource section begin with a tree structure pointing to data. This tree is like a
 hard disk directory structure. At root, we find the main entries, one for each resource
 type. At last, we find something like a file icon: pointers to true data. This last one
 is a leave (the 'file icon', not the true data). Up others are nodes.
 The levels are:
 - root dir (points to resources types)
 - types dir (points to languages types)
 - pointers dir (points to true data)

 Each dir has an height words header. they are all zero but last one: records number in
 the dir; and as many records of two dWords. Exemple for root dir with two resources:

[Resources: W$ 0,0,0,0,0,0,0,2  ; 2 next resources records
 D$ &RT_ICON,  0_80000020        ; 080 > it points to a node.
 &RT_GROUP_ICON, 0_80000038      ; 020 / 038 are displacememnts Ptr (from start of .rsrc)

 Leaves have no 8 words header and are 4 dWords long (RVA ptr / size / CodePage / reserved)

 The only info i found about CodePage dWord is this:
 "... CodePage ...should be used when decoding code point values within the resource data.
  Typically for new applications the code page would be the unicode code page."
 (??????????????????!!!!!!!!!!!!!!!) >>> set at zero until i understand more...

 For .rsrc section construction, we first search for the total lenght of this tree, save
 pointers to each dir and work downside up: first write the data, then fill dirs backward.
 uRsrcsList is a temporary list containing needed information on each resource in
 memory.
;;
 ___________________________________________________________________________________________

[ID_Icon 1,  Language 0409,  ID_Group_Icon 1]

; resource temporary list: up to 200 resource >>> to change for dynamic memory later.

[@DumRL: 0 0 0 0 0]  ; to stop upward search on zeros

[uRsrcList:         ; BUAsm infos storage for .rsrc section building (5 dWords per resource)
   D$ 0             ; Type
      0             ; ID
  0_409             ; Language
      0             ; Data pointer
      0             ; Size
      # MAXRESOURCE]
[@Dum2RL: D$ 0 0 0 0 0]

[RsrcHeadPtr: D$ ?
 RsrcSectionOrigine: D$ ?
 RsrcSectionPtr: D$ ?
 RsrcTypePtr: D$ ?
 RsrcLangPtr: D$ ?
 RsrcPtrPtr: D$ ?
 uRsrcListPtr: D$ ?]

; We set here the list of existing resources for the app resources section. We store
; the type, the ID, Dummy language, Pointer to resource data and size. For menu, i let
; some 'RosAsm developpement internal' test that i use to study menus encoding:

[TypeByName: D$ ?]


[NoResources: D$ ?
 NoMainIcon: D$ ?]
 ________________________________________________________________________________________
 ________________________________________________________________________________________

;                                   data job
 ________________________________________________________________________________________
 ________________________________________________________________________________________

[LenOfDataSet: D$ ?
 AfterLastDataLabel: D$ ?
 DataLoopValue: D$ ?
 DefSize: D$ ?]

BuildData:
    Mov eax D$CodeListPtr | Mov D$DataList eax | Mov D$DataListPtr eax

        Call StoreDatas

    Mov eax D$DataListPtr | sub eax D$DataList | Mov D$uDataSize eax

    Mov eax D$DataListPtr

  ; Clear all possible trailing left Source Text:
    Push eax
        While B$eax <> 0
            Mov B$eax 0 | inc eax
        End_While
    Pop eax

    AlignOn 0200 eax | Mov D$CodeListPtr eax

        Call StoreVirtualData

;;
  Case of ?Data without any Data >>> We force a dummy .Data Section, because usually,
  in RosAsm outputed PEs, the ?Data are a simple RVA extension of Data, for saving the
  addition of one more, and no use .bss Section, with a different header:
;;
    .If D$uDataSize = 0
        If D$uVirtualDataSize <> 0
            add D$CodeListPtr 0200
            Mov D$uDataSize 1
        End_If
    .End_If

    Call StripDoneStatementsPointers
ret


TranslateText:
    lodsb                        ; strip first text sign

    On B$DefSize = UNICODE_MEM jmp TranslateUnicode

L0: lodsb | cmp al TextSign | je L9>
      stosb | jmp L0<
L9: lodsb                        ; strip lasting one
    If al = CloseBracket
        dec esi
    Else_If al > Separators
        Error D$MissingSeparatorPtr
    End_If
    Mov edx 0
ret


TranslateUnicode:
L0: lodsb | cmp al TextSign | je L9>
        stosb | Mov al 0 | stosb | jmp L0<
L9: lodsb                        ; strip lasting one
    Mov edx 0
ret


; translations from text expressions to true numbers. Text is previously pointed by esi
; results stored in (ebx >) EDX:EAX

TranslateBinary:
    lodsw                                               ; clear first '00'
NackedBinary:
    Mov ebx 0, edx 0, ecx 0
L0: lodsb | cmp al Closebracket | jbe L9>
    sub al '0' | shld edx ebx 1 | shl ebx 1 | or bl al
    cmp edx ecx | jb L8>
        Mov ecx edx
            cmp al 2 | jb L0<
L8:             Mov ecx D$BinTypePtr | jmp BadNumberFormat
L9: Mov eax ebx
ret


TranslateHexa:
    lodsb                                               ; clear first '0'
NackedHexa:
    Mov ebx 0,  edx 0, ecx 0
L0: lodsb | cmp al LowSigns | jbe L9>
        sub al '0' | cmp al 9 | jbe L2>
            sub al 7
L2: shld edx ebx 4 | shl ebx 4 | or bl al
    cmp edx ecx | jb L8>
        Mov ecx edx
            cmp al 0F | jbe L0<
L8: Mov ecx D$HexTypePtr | jmp BadNumberFormat
L9: Mov eax ebx
ret


TranslateDecimal:
    Mov eax 0, ecx 0

L2: Mov cl B$esi | inc esi                        ; (eax used for result > no lodsb)
    cmp cl LowSigns | jbe  L9>

      Mov edx 10 | mul edx | jo L3>               ; loaded part * 10
                                                  ; Overflow >>> Qword
        sub  ecx '0' | jc L7>
        cmp  ecx 9   | ja L7>

          add  eax ecx | jnc  L2<
            jmp  L4>                              ; carry >>> Qword

                                                  ; if greater than 0FFFF_FFFF:
L3: sub ecx '0' | jc L7>
    cmp ecx 9   | ja L7>

      add eax ecx

L4:   adc edx 0
      Mov cl B$esi | inc  esi
      cmp cl LowSigns | jbe L9>

        Mov ebx eax, eax edx, edx 10 | mul edx    ; high part * 10
          jo L6>                                  ; Qword overflow
            xchg eax ebx | Mov edx 10 | mul edx   ; low part * 10
            add  edx ebx
            jnc   L3<                             ; carry >>> overflow

L6:           On B$esi < '0', error D$OverFlowPtr
              If B$esi <= '9'
                  inc esi | jmp L6<
              End_If

L7: Mov ecx D$DezimalTypePtr | jmp BadNumberFormat
L9: ret                                           ; >>> number in EDX:EAX


TranslateAny:
    If W$esi = '00'
        Call TranslateBinary
    Else_If B$esi = '0'
        Call TranslateHexa
    Else
        Call TranslateDecimal
    End_If
ret

;;
 In error cases, we come here with the error Message in ecx. This is done this way, in
 order to give zero time penality to Clean written Sources. Here, we check for
 alternate expressions of Numbers ( ...B, ... xB, ...D, ...xD, ...H, ...xH, and crazy
 leading zeros in excess).
 
 Note that the whole thingy may be run twice (No care of time cost for alien syntaxes,
 but full care of time for clean written Source -zero added cost for them-).
 
 esi is after the bad Char.
;;

BadNumberFormat:
    dec esi
L0: lodsb | On al = 'X', lodsb

    .If al = 'H'
        cmp B$esi LowSigns | ja L7>
    .Else_If al = 'D'
        cmp B$esi LowSigns | ja L7>
    .Else_If al = 'B'
        cmp B$esi LowSigns | ja L7>
    .Else
      ; Try to read a Type Marker at the end, and re-run if possible:
L7:     While B$esi > LowSigns | inc esi | End_While | dec esi | lodsb
        If al = 'H'
            On ecx = HexType, Error ecx
        Else_If al = 'D'
            On ecx = DezimalType, Error ecx
        Else_If al = 'B'
            On ecx = BinType, Error ecx
        Else
            Error ecx
        End_If
    .End_If

    dec esi
;;
 esi now points to the last Char of the Number. We overwrite it: We kill the Types Markers
 and we fill at the other end (start), with zeros:
;;
    Push edi
        Mov edi esi | dec esi | On B$esi = 'X', dec esi
        std
            While B$esi > LowSigns | movsb | End_While
        cld
        While B$edi > LowSigns | Mov B$edi '0' | dec edi | End_While
    Pop edi

    inc esi | While B$esi = '0' | inc esi | End_While

  ; Cases of, for example, "[<0200h" DataAlignment:
    On B$esi = '<', inc esi

    If al = 'H'
        jmp NackedHexa
    Else_If al = 'D'
        jmp TranslateDecimal
    Else  ; al = 'B'
        jmp NackedBinary
    End_If

____________________________________________________________________________________________

AsciiToQword:
L0: Call atof
    On al > CloseBracket, error D$BadRealPtr
    fadd D$edi
    fstp Q$edi

L9: cmp B$esi-1 addSign | jne L9>
        Mov al addSign | dec esi | jmp L0<<
L9: cmp B$esi-1 subSign | jne L9>
        Mov al subSign | dec esi | jmp L0<<

L9: add edi 8
    Mov eax edi | sub eax D$DataListPtr | add D$LenOfDataSet eax
    Mov D$DataListPtr edi
ret

FAsciiToQword:
L0: Call atof
    On al > CloseBracket, error D$BadRealPtr
    fadd D$edi
    fstp D$edi

L9: cmp B$esi-1 addSign | jne L9>
        Mov al addSign | dec esi | jmp L0<<
L9: cmp B$esi-1 subSign | jne L9>
        Mov al subSign | dec esi | jmp L0<<

L9: add edi 4
    Mov eax edi | sub eax D$DataListPtr | add D$LenOfDataSet eax
    Mov D$DataListPtr edi
ret


TAsciiToQword:
L0: Call atof
    On al > CloseBracket, error D$BadRealPtr
    fadd D$edi
    fstp T$edi

L9:   cmp B$esi-1 addSign | jne L9>
        Mov al addSign | dec esi | jmp L0<<
L9:   cmp B$esi-1 subSign | jne L9>
        Mov al subSign | dec esi | jmp L0<<

L9: add edi 10
    Mov eax edi | sub eax D$DataListPtr | add D$LenOfDataSet eax
    Mov D$DataListPtr edi
ret



[DataSign: D$ ?]

StoreDataRef:
    On B$DefSize <> 'D' error D$DsizeForLabPtr
    Push edi
        Mov edi D$DataRefPtr
        ..If D$FL.Dynamic = &TRUE
            If edi > D$DataRefLimit
                Call ExtendTableMemory DataRef, DataRefPtr, DataRefLimit
                Mov edi D$DataRefPtr
            End_If
        ..End_If

L0:     lodsb | cmp al LowSigns | jb L1>
        stosb | jmp L0<
L1:     Mov al EOI | stosb
        Mov eax D$DataListPtr | stosd
        Mov eax D$bracketCounter | stosd
        Mov al B$DataSign | stosb
        Mov al EOI | stosb
      Mov D$DataRefPtr edi
    Pop edi
ret


; j'ai oubli  de commenter   '<<<<' pourquoi faut-il ajouter un dWord apr s la valeur de
; LEN. Sans ce 0 suppl mentaire, la donn e suivante est  crasee (0). Comme  a, tout
; fonctionne mais je ne sais plus pourquoi!!!!!!!!!!...........

;;

    !!! Perso je soupçonne un problème d'alignement ;))
;;

[HeadLenPtr: 0    HeadLenFlag: 0    HeadLenSize: DWORD_MEM]

StoreOneData:
    Mov B$DataSign &FALSE
    Push edi

        cmp B$esi+1 MemMarker | jne L0>
            lodsb | Mov B$DefSize al | lodsb

L0:     Mov edi D$DataListPtr | Mov D$edi 0 | Mov al B$esi
            cmp al Separators | ja L0>
            inc esi | Mov al B$esi

L0:     cmp al 'L' | jne L0>>
            cmp B$esi+1 'E' | jne L0>>
            cmp B$esi+2 'N' | jne L0>>
            cmp B$esi+3 LowSigns | ja L0>>

              ; Direct storage for LEN keyword:
                Mov eax D$LenOfDataSet
                .If eax = 0
                    Mov B$HeadLenFlag &TRUE, D$HeadLenPtr edi

                  ; Store dummy zero. Will be overwritten, after, at the top of 'StoreDatas'
                  ; HeadLen may be W$ for some Win32 Structures. Byte should be no use:
                    If B$DefSize = DWORD_MEM
                        stosd | Mov D$HeadLenSize DWORD_MEM D$LenOfDataSet 4
                    Else_If B$DefSize = WORD_MEM
                        stosw | Mov D$HeadLenSize WORD_MEM D$LenOfDataSet 2
                    Else_If B$DefSize = BYTE_MEM
                        stosb | Mov D$HeadLenSize BYTE_MEM D$LenOfDataSet 1
                    Else
                        error D$LenSizePtr
                    End_If

                .Else_If B$HeadLenFlag = &TRUE
                    error D$MixedLenPtr

                .Else
                  ; Normal Len (after Data) is always a dWord, whatever 'DefSize':
                    stosd | Mov D$LenOfDataSet 0

                .End_If

                Mov D$DataListPtr edi | add esi 4
    Pop edi
    ret

L0:     cmp B$DefSize 'R' | jne L0>
        Call AsciiToQword
    Pop edi
    ret

L0:     cmp B$DefSize 'H' | jne L0>
        error D$NewHmemPtr
      ; Call AsciiToQword
    Pop edi
    ret

L0:     cmp B$DefSize 'F' | jne L0>
        Call FAsciiToQword
    Pop edi
    ret

L0:     cmp B$DefSize 'T' | jne L0>
      ;  Push esi
      ;      Call ParseFpWords
      ;  Pop eax
      ;  On esi = eax,
        Call TAsciiToQword
    Pop edi
    ret

L0:     Mov B$DataSign &FALSE | cmp al SubSign | jne L1>
        Mov B$DataSign &TRUE | lodsb | Mov al B$esi | jmp L1>
L1:     cmp al addsign | jne L2>
        lodsb | Mov al B$esi
L2:     cmp al TextSign | jne L2>
        Call TranslateText | jmp E9>>   ; (direct storage of text in Translation routine)
L2:     cmp al '0' | ja L4>
        cmp B$esi+1 '0' | jne L2>
            Call TranslateBinary | jmp L5>
L2:     Call TranslateHexa | jmp L5>
L4:     cmp al '9' | jbe L4>
            Call StoreDataRef | jmp L9>>
L4:     Call TranslateDecimal

L5:     cmp edx 0 | je L5>
        On B$DefSize <> 'Q', error D$OverFlowPtr
            jmp Q7>>

L5:     cmp B$DefSize 'D' | je L7>
        cmp B$DefSize 'B' | je L6>
        cmp B$DefSize 'W' | je U0>
        cmp B$DefSize 'U' | je U0>
        cmp B$DefSize 'Q' | je Q7>                              ; keep (Q$ with edx = 0)
            error D$UnknownSizePtr

U0:     cmp eax 0FFFF | ja L8>>                                 ; if here, DefSize = 'W'
        On B$DataSign = &TRUE, neg ax | add W$edi ax | jnc L9>  ; include 0 unicode endMark
            jmp L8>>
L6:     cmp eax 0FF | ja L8>>                                   ; 'B'
        On B$DataSign = &TRUE, neg al | add B$edi al | jnc L9>
            jmp L8>>
L7:     On B$DataSign = &TRUE, neg eax | add D$edi eax | jnc L9>; 'D'
        jmp L8>>
Q7:     If B$DataSign = &TRUE
            Push 0 | Push 0 | sub D$esp eax | sbb D$esp+4 edx ;jE!
            Pop eax | Pop edx
        End_If

        add D$edi eax | jnc Q8>
        add edx 1 | On edx = 0, error D$OverFlowPtr
Q8:     add edi 4 | add D$edi edx | jnc Q9>
            jmp L8>>
Q9:     sub edi 4

L9:     cmp B$esi-1 addSign | jne L9>
            Mov al addSign | dec esi | jmp L0<<
L9:     cmp B$esi-1 subSign | jne L9>
            Mov al subSign | dec esi | jmp L0<<

L9:     cmp B$DefSize 'D' | jne L9>
            add edi 4 | jmp E9>
L9:     cmp B$DefSize 'B' | jne L9>
            inc edi   | jmp E9>
L9:     cmp B$DefSize 'Q' | jne L9>
            add edi 8 | jmp E9>
L9:     add edi 2                         ; good for 'W' and 'U'

E9:     Mov eax edi | sub eax D$DataListPtr | add D$LenOfDataSet eax
        Mov D$DataListPtr edi
    Pop edi
ret

L8: error D$OverFlowPtr

 _________________________________________________________________________________________
;;
 storage of labels and datas founded in data declarations square brackets:
 datas are stored in 'DataList'. Labels are stored in the same 'LabelList' as
 code labels, but with adress high bit set.
 indentifications of either label or data is made through Space or Colon ending signs.
 the only one difficulty is that a declaration might end with a label (in case
 user programmer wish to know some data lenght without using 'len', for exemple)
;;
 _________________________________________________________________________________________

AlignDataSet:
    ..If B$esi = '<'
        lodsb                       ; strip '<'
        On B$esi = Space, lodsb
        If W$esi = '00'
            Call TranslateBinary | cmp eax 0 | je L9>>
            dec eax | add D$DataListPtr eax
            inc eax | neg eax | and D$DataListPtr eax

        Else_If B$esi = '0'
            Call TranslateHexa | cmp eax 0 | je L9>>
            dec eax | add D$DataListPtr eax
            inc eax | neg eax | and D$DataListPtr eax

        Else_If B$esi < '1'
            ; Don't Align

        Else_If B$esi > '9'
            ; Don't Align

        Else
            Call TranslateDecimal
            dec eax | add D$DataListPtr eax
            inc eax | neg eax | and D$DataListPtr eax

        End_If
    ..Else
        Push esi
            While B$esi > LowSigns | inc esi | End_While | inc esi
            Mov eax 4
            .If B$esi+1 = memMarker
                If B$esi = 'B'
                    Mov eax 1
                Else_If B$esi = 'D'
                    Mov eax 4
                Else_If B$esi = 'W'
                    Mov eax 2
                Else_If B$esi = 'U'
                    Mov eax 2
                Else_If B$esi = 'F'
                    Mov eax 4
                Else_If B$esi = 'R'
                    Mov eax 8
                Else_If B$esi = 'Q'
                    Mov eax 8
                Else_If B$esi = 'T'
                    Mov eax 16
                End_If
            .End_If
        Pop esi
        Align_On_Variable eax D$DataListPtr
    ..End_If
L9: ret


[DataLabelsCounter: D$ ?
 CodeLabelsCounter: D$ ?]

[DataLoopWinEquate: D$ ? # 20]

[LOOPDATAMAX 01_000]

[ColonWanted: D$ ?]

StoreDatas:
    Mov esi D$CodeSourceB
    Mov B$ErrorLevel 0,  D$bracketCounter 0, D$DataLabelsCounter 0
    Mov D$HeadLenPtr 0, D$HeadLenFlag 0, D$HeadLenSize DWORD_MEM

    Move D$StatementsPtr D$StatementsTable | sub D$StatementsPtr 4

L0: .If B$HeadLenFlag = &TRUE
        Mov ebx D$HeadLenPtr, eax D$LenOfDataSet, B$HeadLenFlag &FALSE

        If B$HeadLenSize = DWORD_MEM
            Mov D$ebx eax
        Else_If B$HeadLenSize = WORD_MEM
            On eax > 0FFFF, error D$OverWordPtr
            Mov W$ebx ax
        Else
            On eax > 0FF, error D$OverBytePtr
            Mov B$ebx al
        End_If
    .End_If

L1: lodsb
    If al = TextSign
        While B$esi <> TextSign
            lodsb
        End_While
        lodsb | jmp L1<

    Else_If al = OpenVirtual
        inc D$bracketCounter | add D$StatementsPtr 4
        While al <> CloseVirtual
             lodsb
        End_While
        jmp L1<

    Else_If al = Openbracket
        inc D$bracketCounter | add D$StatementsPtr 4 | jmp L1>

    Else_If al = EOI
        ret

    Else
        jmp L1<

    End_If

L1: Mov D$LenOfDataSet 0
    Mov B$DefSize 'D'   ; default size: dWord

    Call AlignDataSet

L2: Push esi
L3:     lodsb                                   ; we search ending char (first for 'text')
        cmp al LowSigns | ja L3<
          cmp al TextSign     | je L5>          ; Text (first sign, no need of last one)
          cmp al Space        | je L5>          ; data
          cmp al Closebracket | je L5>          ; lasting data
          cmp al meEOI        | je L5>          ; no error if no comma...
          cmp al ColonSign    | je L6>          ; label (last sign)
          cmp al NumSign      | je L7>>
          cmp al addsign      | je L5>
          cmp al subSign      | je L5>

          cmp al memMarker    | je L3<
            error D$BadSeparatorPtr

L5: Pop esi

    Call StoreOneData | jmp L9>>                ; if data

; Case "__:__"
L6:     Mov B$ColonWanted &FALSE
        On B$esi = meEOI, inc esi               ; no '|' betweem ':' and data
        Mov D$AfterLastDataLabel esi
    Pop esi

    Call StoreDataLabel                         ; if label
    On B$LocalLabel = &TRUE, error D$NoDataLocalLabelPtr
    inc D$DataLabelsCounter
    Mov esi D$AfterLastDataLabel | jmp L9>>     ; Called Subs don't change ESI

; Case "__#__"
L7: On B$esi-2 > PartEnds, error D$WhatIsThisPtr
    On B$ColonWanted = &TRUE, error D$NestedLoopPtr
    Pop eax

    cmp B$esi-2 memMarker | je E1>
    cmp B$esi-2 ColonSign | jne E2>

E1:     error D$BadLoopPtr
E2:
    On B$esi < '0', error D$BadLoopNumberPtr
    On B$esi > '9',  error D$BadLoopNumberPtr
    cmp D$DataLoopValue 0 | ja L7>
      If B$esi = '0'
        Call TranslateHexa
      Else
        Call TranslateDecimal
      End_If
      On edx > 0, error D$DataLoopNumberPtr
      On eax > LOOPDATAMAX, error D$DataLoopNumberPtr
      On eax < 2, error D$SmallDataLoopPtr
      Mov D$DataLoopValue eax

L7: dec D$DataLoopValue | cmp D$DataLoopValue 0 | ja L8>      ; full set when edx ...
L7: lodsb
      cmp al LowSigns | ja L7<
        Mov B$ColonWanted &TRUE | jmp L9>

L8: Mov esi D$AfterLastDataLabel | jmp L2<<

L9: If B$esi-1 = Closebracket
       Mov eax D$StatementsPtr, D$eax FLAG_DONE
       jmp L0<<                    ; lasting data
    End_If
    On B$esi  <> Closebracket,  jmp L2<<                      ; lasting label
    Mov eax D$StatementsPtr, D$eax FLAG_DONE
    inc esi | jmp L0<<

_____________________________________________________________________________________

StoreOneVirtualData:
    cmp B$esi+1 MemMarker | jne L0>
        lodsb | Mov B$DefSize al | lodsb

L0: lodsb
        cmp al Separators | ja L0>
            lodsb

L0: cmp al '?' | je L0>
        error D$VirtualDataPtr

L0: .If B$DefSize = 'D'
        Mov eax 4
    .Else_If B$DefSize = 'B'
        Mov eax 1
    .Else_If B$DefSize = 'W'
        Mov eax 2
    .Else_If B$DefSize = 'U'
        Mov eax 2
    .Else_If B$DefSize = 'Q'
        Mov eax 8
    .Else_If B$DefSize = 'R'
        Mov eax 4
    .Else_If B$DefSize = 'H'
        Mov eax 8
    .Else_If B$DefSize = 'F'
        Mov eax 4
    .Else_If B$DefSize = 'T'
        Mov eax 10
    .Else
        error D$UnknownSizePtr
    .End_If

    add D$uVirtualDataSize eax | add D$DataListPtr eax

    On B$esi < Separators, inc esi
ret

;;
 Beware, here, we both read from and copy to 'CodeSourceB'. We strip off at once Brackets
 and Virtual Brackets Declarations. We didn't strip Data Brackets previouly to allow
 error checking of user source Brackets.
;;
[uVirtualDataSize: D$ ?]
[NoVirtualLimit: D$ ?]
[LOOPVDATAMAX 010_0000]

StoreVirtualData:
    Mov esi D$CodeSourceB,  edi D$CodeSourceB
    Mov B$ErrorLevel 0,  D$bracketCounter 0, D$uVirtualDataSize 0

    Move D$StatementsPtr D$StatementsTable | sub D$StatementsPtr 4

; Next 'if' could be reused (???) if we want to speed up "Looping" '?' Data.
; (All of this could be much faster...):
;
L0: ;If B$HeadLenFlag = &TRUE
;      Mov ebx D$HeadLenPtr, eax D$LenOfDataSet, D$ebx eax, B$HeadLenFlag &FALSE
;    End_If

L1: lodsb
      If al = OpenBracket
          While al <> CloseBracket
              lodsb
              cmp al TextSign | jne T9>
          T0: lodsb | cmp al TextSign | jne T0<
          T9:
          End_While
          inc D$bracketCounter | add D$StatementsPtr 4
          jmp L1<
      End_If
      cmp al OpenVirtual | je L1>               ; search for data declaration
      stosb | cmp al EOI | jne L1<
           On B$esi = OpenVirtual, jmp S0>
           On B$esi = Openbracket, jmp S0>
           add D$StatementsPtr 4
S0:  On B$edi-2 = EOI,  dec edi         ; prevents unwished '||', wich occurs for exemple
                                            ; in: ...|[val: 25]|...  after data strip
        cmp B$esi EOI | jne L0<             ; end of source
          stosb
            Mov eax edi | sub eax D$CodeSourceB | Mov D$StripLen eax
            Mov al EOI, ecx 10 | rep stosb      ; ajout recent pour tester un plantage
          ret

L1: inc D$bracketCounter | add D$StatementsPtr 4

    Mov B$DefSize 'D'   ; default size: dWord

  ; Re-Write that shit: Need an 'AlignVirtualDataSet' version, instead.
    Push D$DataListPtr
        Call AlignDataSet
    Pop eax
    If D$DataListPtr > eax
        Mov ebx D$DataListPtr | sub ebx eax | add D$uVirtualDataSize ebx
    End_If

L2: Push esi
L3:   lodsb                                     ; we search ending char (first for 'text')
        cmp al LowSigns | ja L3<
          cmp al TextSign     | je L4>          ; Text (first sign, no need of last one)
          cmp al Space        | je L5>          ; data
          cmp al CloseVirtual | je L5>          ; lasting data
          cmp al meEOI        | je L5>          ; no error if no comma...
          cmp al ColonSign    | je L6>          ; label (last sign)
          cmp al NumSign      | je L7>>
          cmp al addsign      | je L4>
          cmp al subSign      | je L4>
        jmp L3<

L4: error D$VirtualDataPtr

L5: Pop esi | Call StoreOneVirtualData | jmp L9>>   ; if data

L6:   Mov B$ColonWanted &FALSE
      Move D$DataListPtrAtLastColon D$DataListPtr
      On B$esi = meEOI, inc esi                 ; no '|' betweem ':' and data
      Mov D$AfterLastDataLabel esi
    Pop esi
    Call StoreDataLabel                         ; if label
    On B$LocalLabel = &TRUE, error D$NoDataLocalLabelPtr
    inc D$DataLabelsCounter
    Mov esi D$AfterLastDataLabel | jmp L9>>     ; Called Subs don't change ESI

L7: On B$esi-2 > PartEnds, error D$WhatIsThisPtr
    On B$ColonWanted = &TRUE, error D$NestedLoopPtr
    Pop eax
    cmp B$esi-2 memMarker | je E1>
    cmp B$esi-2 ColonSign | jne E2>
E1:     error D$BadLoopPtr

E2: On B$esi < '0', error D$BadLoopNumberPtr
    On B$esi > '9',  error D$BadLoopNumberPtr

    cmp D$DataLoopValue 0 | ja L7>
        If B$esi = '0'
            Call TranslateHexa
        Else
            Call TranslateDecimal
        End_If
        On edx > 0, error D$VDataLoopNumberPtr
        If B$NoVirtualLimit = &FALSE
            On eax > LOOPVDATAMAX, error D$VDataLoopNumberPtr
        End_If
        On eax < 2, error D$SmallDataLoopPtr
        Mov D$DataLoopValue eax

L7: dec D$DataLoopValue | cmp D$DataLoopValue 0 | ja L8>        ; full set when edx ...
L7: lodsb
      cmp al LowSigns | ja L7<
        Mov B$ColonWanted &TRUE | jmp L9>

L8:     If D$DataLoopValue > 1
            Mov eax D$DataListPtr | sub eax D$DataListPtrAtLastColon
            Mov ecx D$DataLoopValue | dec ecx | mul ecx
            add D$DataListPtr eax | add D$uVirtualDataSize eax
            Mov D$DataLoopValue 1
        End_If

        Mov esi D$AfterLastDataLabel | jmp L2<<

L9: If B$esi-1 = CloseVirtual
        Mov eax D$StatementsPtr, D$eax FLAG_DONE | jmp L0<<      ; lasting data
    End_If
    On B$esi <> CloseVirtual,  jmp L2<<                         ; lasting label
        inc esi | Mov eax D$StatementsPtr, D$eax FLAG_DONE | jmp L0<<

_________________________________________________________________________________________
 _________________________________________________________________________________________

; Labels deal

[StartOfLabelName: D$ ?
 LocalLabel: D$ ?]

E0: error D$BadLabelPtr

StoreDataLabel:
    Mov edx D$DataListPtr | Mov cl FLAG_DATA_LABEL | jmp L0>

StoreCodeLabel:
    Mov edx D$CodeListPtr | Mov cl FLAG_CODE_LABEL

L0: Push edi
        Mov edi D$LabelListPtr | Mov ebx 0 | Mov D$StartOfLabelName esi
        and B$esi 00_0111_1111

        On B$esi = ColonSign, error D$OrphanColonPtr

L1:     lodsb | cmp al ColonSign | je L2>               ; esi set by caller
        inc ebx                                         ; ebx < lenght of label name
        cmp al '.' | jb E0<
        cmp al 'Z' | ja E0<
        stosb | jmp L1<                                 ; write to LabelList

L2:     Mov al EOI | stosb | Mov B$LocalLabel &FALSE
        cmp ebx 2 | jne L3>                             ; is it a possible local label?
            Mov ah B$esi-3,  al B$esi-2
            cmp ah 'A' | jb L3>
                cmp ah 'Z' | ja L3>
                    cmp al '0' | jb L3>
                        cmp al '9' | ja L3>
                            Mov B$LocalLabel &TRUE      ; if yes, multiple decs. allowed

L3:   Mov eax edx                                       ; either data or code List Pointer
      stosd                                             ; label offset (code or data)
      Mov al cl | stosb                                 ; code or data flag byte
      Mov al EOI | stosb

    ;  Mov esi D$StartOfLabelName                        ; LabelListPtr > first label letter
      On B$LocalLabel = &FALSE, Call SetQwordCheckSum D$LabelListPtr
    ;  On B$LocalLabel = &FALSE, Call IsItNewDataOrCodeLabel       ; send error message if not new

      Mov D$LabelListPtr edi

      If edi > D$LabelListLimit
        Call ExtendTableMemory LabelList, LabelListPtr, LabelListLimit
      End_If

    Pop edi
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

OpError: Error D$NotAnOpcodePtr
OperandsError: Error D$OperandsTypesPtr
OperandSizeError: Error D$OperandSizePtr
NoFpAssumeError: Error D$FPregNotAssumedPtr

[BadMnemonic | jmp OpError]
[BadOperand | jmp OperandsError]
[BadOperandSize | jmp OperandSizeError]
[NoFpAssume | jmp NoFpAssumeError]

[op1 ah,  op2 al,  op3 bh,  op4 bl,  op5 ch,  op6 cl,  op7 dh,  op8 dl]

[LineStart: D$ 0,  Operands: B$ 0]

[ParametersData: 0  ParametersNumber: 0
 LongRelative: 0  dis32: 0  @imm64: imm32: 0 0   ABSimm32: 0  SignedImm8: 0
 Relative: 0                   ; set with >flag when coding calls or jumps

 LocalSize: B$ 0
 Ereg: 0  SIB: 0
 EregInside: 0  immInside: 0  DisInside: 0   SibInside: 0
 DummyDis: 0                   ; true or false, for SIB without dis and without base

 LabelInside: B$ 0  ExpressedLabels: 0  TrueSize: 0
 FirstParaMem: 0  SecondParaMem: 0
 FirstReg: 0  SecondReg: 0  ThirdReg: 0
 FirstGender: 0  SecondGender: 0  ThirdGender: 0
 FirstRegGender: 0  SecondRegGender: 0  ThirdRegGender: 0

 RMbits: B$ 0  wBit: 0            ; for size encoding 1 or 0
 wBitDisagree: 0  sBit: 0            ; 010B or 0
 @sBitPossible: 0  @sBitWritten: 0
 OneOperandwBit: 0            ; for temporary storage inside One parameter analyze
 FirstOperandwBit: 0            ; These two
 SecondOperandwBit: 0            ; for test of fitting sizes
 ThirdOperandwBit: 0
 ModBits: 0  SIBreg1: 0  SIBreg2: 0
 ScaledIndex: 0  @Base: 0  ScaleFound: 0  Reg1isIndex: 0  Reg2isIndex: 0  TwoRegsFound: 0
 PossibleRmEreg: 0  ExpressedSign: 0

 PossibleImmLabel: B$ 0  PossibleFirstImmLabel: 0

 ParametersDataLen: len]

[relativeFlag  00__10000000_00000000_00000000_00000000]

 _________________________________________________________________________________________
 _________________________________________________________________________________________

; expression deal: ModR/M, SIB and immediate in expressions

[IfEregFound | cmp B$Ereg NA | jne #1]

[IfEregNotFound | cmp B$Ereg NA | je #1]

[IfNotPartEnd | cmp #1 PartEnds | ja #2]

[IfSeparator | cmp #1 Separators | jb #2]

IsitaReg:
     Call Store8cars | On op3 nb Separators,  jmp L5>>      ; a 2 letters reg name?

L0: ifnot op2 'X', L2>
        ifnot op1 'A', L1>
            Mov al REG_AX | jmp L3>
L1:     ifnot op1 'B', L1>
            Mov al REG_BX | jmp L3>
L1:     ifnot op1 'C', L1>
            Mov al REG_CX | jmp L3>
L1:     On op1 <> 'D',  jmp L9>>
            Mov al REG_DX

L3:     Mov W$esi 0 | add esi 3 | Mov ah GENERAL_REG | Mov B$OneOperandwBit WORD_SIZE | ret

L2: ifnot op2 'H', L2>
        ifnot op1 'A', L1>
                Mov al REG_AH | jmp L3>
L1:     ifnot op1 'B', L1>
            Mov al REG_BH | jmp L3>
L1:     ifnot op1 'C', L1>
            Mov al REG_CH | jmp L3>
L1:     On ah <> 'D',  jmp L9>>
            Mov al REG_DH | jmp L3>

L2: ifnot op2 'L', L2>
        ifnot op1 'A', L1>
            Mov al REG_AL | jmp L3>
L1:     ifnot op1 'B', L1>
            Mov al REG_BL | jmp L3>
L1:     ifnot op1 'C', L1>
            Mov al, REG_CL | jmp L3>
L1:     On op1 <> 'D',  jmp L9>>
            Mov al, REG_DL

L3:     Mov W$esi 0 | add esi 3 | Mov ah GENERAL_REG | Mov B$OneOperandwBit BYTE_SIZE | ret

L2: ifnot op2 'P', L2>
        ifnot op1 'B', L1>
            Mov al REG_BP | jmp L3>
L1:     On op1 <> 'S',  jmp L9>>
            Mov al REG_SP | jmp L3>

L2: ifnot op2 'I', L2>
        ifnot op1 'S', L1>
            Mov al REG_SI | jmp L3>
L1:     On op1 <> 'D',  jmp L9>>
            Mov al REG_DI

L3:     Mov W$esi 0 | add esi 3 | Mov ah GENERAL_REG | Mov B$OneOperandwBit WORD_SIZE | ret

L2: ifnot op2 'S', L5>
        ifnot op1 'E', L1>
           Mov al REG_ES | jmp L3>
L1:     ifnot op1 'C', L1>
           Mov al REG_CS | jmp L3>
L1:     ifnot op1 'S', L1>
           Mov al REG_SS | jmp L3>
L1:     ifnot op1 'D', L1>
           Mov al REG_DS | jmp L3>
L1:     ifnot op1 'F', L1>
           Mov al REG_FS | jmp L3>
L1:     On op1 <> 'G',  jmp L9>>
           Mov al REG_GS

L3:     Mov W$esi 0 | add esi 3 | Mov ah SEGMENT_REG | Mov B$OneOperandwBit WORD_SIZE | ret

; Is it a 3 letters MMX register name?

L5: On op4 nb Separators,  jmp L9>>
       IfNot op1, 'M', L5>
         IfNot op2, 'M', L5>
           cmp op3, '0' | jb L5>
           cmp op3, '7' | jg L5>
             sub bh, '0' | Mov al bh | Mov ah REG_MMX
             and D$esi 0FF000000 | add esi 4 | Mov B$OneOperandwBit DWORD_SIZE | ret

; Is it a 3 letters STx register name?

L5: IfNot op1, 'S', L5>
        IfNot op2, 'T', L5>
           cmp op3, '0' | jb L5>
           cmp op3, '7' | jg L5>
             sub bh, '0' | Mov al bh | Mov ah REG_FPU
             and D$esi 0FF000000 | add esi 4 | Mov B$OneOperandwBit DWORD_SIZE | ret

; Is it a 3 letters DRx register name?

L5: IfNot op1, 'D', L5>
        IfNot op2, 'R', L5>
           cmp op3, '0' | jb L5>
           cmp op3, '7' | jg L5>
             sub bh, '0' | Mov al bh | Mov ah DEBUG_REG
             and D$esi 0FF000000 | add esi 4 | Mov B$OneOperandwBit DWORD_SIZE | ret

; Is it a 3 letters CRx register name?

L5: IfNot op1, 'C', L5>
        IfNot op2, 'R', L5>
           cmp op3, '0' | jb L5>
           cmp op3, '4' | jg L5>
             sub bh, '0' | Mov al bh | Mov ah CONTROL_REG
             and D$esi 0FF000000 | add esi 4 | Mov B$OneOperandwBit DWORD_SIZE | ret


;IsItAreg32:

L5: On op1 <> 'E',  jmp L9>
        ifnot op3 'X', L3>
            ifnot op2 'A', L2>
                Mov al REG_EAX | jmp L4>
L2:         ifnot op2 'C', L2>
                Mov al REG_ECX | jmp L4>
L2:         ifnot op2 'D', L2>
                Mov al REG_EDX | jmp L4>
L2:         On op2 <> 'B',  jmp L9>
            Mov al REG_EBX | jmp L4>
L3:     ifnot op3 'P', L3>
            ifnot op2 'S', L2>
                Mov al REG_ESP | jmp L4>
L2:         On op2 <> 'B',  jmp L9>
                Mov al REG_EBP | jmp L4>
L3:     On op3 <> 'I',  jmp L9>
            ifnot op2 'S', L2>
                Mov al REG_ESI | jmp L4>
L2:         On op2 <> 'D',  jmp L9>
                Mov al REG_EDI

L4:     and D$esi 0FF000000 | add esi 4 | Mov ah GENERAL_REG | Mov B$OneOperandwBit DWORD_SIZE | ret

L9: ; 4 Chars Register? > XMM.?

    ifnot op1 'X', L9>
        ifnot op2 'M', L9>
            ifnot op3 'M', L9>
                cmp op4, '0' | jb L9>
                    cmp op4, '7' | jg L9>
                        sub op4, '0' | Mov al op4 | Mov ah REG_XMM
                        Mov D$esi 0 | add esi 5
                        Mov B$OneOperandwBit OWORD_SIZE | ret


L9: Mov eax 0 | ret


; when called 'E' found, esi points to the next letter
; 'IsItAnEreg' doesn't change esi
; 'SearchForEreg' does.

IsItAnEreg:
    Mov B$Ereg NA | Call Store4cars | IfNotPartEnd op3, L9>>

    IfNotPartEnd B$esi-2, L9>>
        ifnot op2 'X', L2>
            ifnot op1 'A', L1>
                Mov B$Ereg REG_EAX | ret
L1:         ifnot op1 'C', L1>
                Mov B$Ereg REG_ECX | ret
L1:         ifnot op1 'D', L1>
                Mov B$Ereg REG_EDX | ret
L1:         ifnot op1 'B', L9>
                Mov B$Ereg REG_EBX | ret
L2:     ifnot op2 'P', L2>
            ifnot op1 'B', L1>
                Mov B$Ereg REG_EBP | ret
L1:         ifnot op1 'S', L9>
                Mov B$Ereg REG_ESP | ret
L2:     ifnot op2 'I', L9>
            ifnot op1 'S', L1>
                Mov B$Ereg REG_ESI | ret
L1:         ifnot op1 'D', L9>
                Mov B$Ereg REG_EDI | ret
L9: ret


SearchForEreg:
    Mov B$Ereg NA                     ; this double declaration is NOT useless
L0: lodsb | cmp al, 0 | je L0<
        cmp al Separators | jb L9>
            cmp al PartEnds | jb L0<
                On al = 'E',  Call IsItAnEreg
                IfEregNotFound L0<

    Mov B$EregInside &TRUE | Mov al B$Ereg,  B$PossibleRmEReg al
    add esi 2                               ; esi >>> next char. after Ereg.
    Mov B$esi-3 0,  B$esi-2 0,  B$esi-1 0   ; clear eReg
    ret

L9: dec esi                                 ; reach end of text word >>> Stay on EOI
ret                                         ; or Space for further possible calls


; SIB byte is [xx xxx xxx] >>> [sf index base]
; in  ECX*4+EDX  , ECX is the index, 4 is the scale factor, EDX is the base.
; when SearchForScale is called , an Ereg has been found. ESI points to possible '*'

SearchForScale:
    Mov B$ScaleFound &FALSE | cmp B$esi MulSign | jne L9>
    IfNotPartEnd B$esi+2,  L8>
    Mov al B$esi+1
    cmp al '2' | jne L1>
        Mov al 00_0100_0000 | jmp L3>
L1: cmp al '4' | jne L2>
        Mov al 00_1000_0000 | jmp L3>
L2: cmp al '8' | jne L8>
        Mov al 00_1100_0000
L3: On B$Ereg = REG_ESP error D$ESPsibPtr              ; ESP can not be an index
    add esi 2 | Mov B$ScaleFound &TRUE
    Mov B$esi-2 0,  B$esi-1 0                      ; clear scale
    Mov bl B$Ereg | shl bl 3 | or bl al            ; store [xx xxx ...]
    Mov B$ScaledIndex bl                           ; in ScaledIndex
L9: ret
L8: error D$ScaleValuePtr


; forbidden use of non extended registers in memory adressing statements:

VerifyNoOtherReg:
    Push esi
L0:   lodsb
      cmp al 0 | je L0<
        cmp al Separators | jb L9>
            cmp al PartEnds | jb L0<
                dec esi | Call IsItAreg | cmp eax 0 | je L1>
                On B$OneOperandwBit <> DWORD_SIZE error D$WishEregPtr
                On ah <> GENERAL_REG error D$WishEregPtr
L1:             inc esi
L2:             cmp B$esi PartEnds | jb L0>         ; strip remaining text
                    inc esi | jmp L2<
L9: Pop esi
ret


SearchForSIB:
    Mov B$SibInside &FALSE, B$Reg1isIndex &FALSE, B$Reg2isIndex &FALSE, B$TwoRegsFound &FALSE
    Push esi
      Call SearchForEreg | IfEregFound L0>
        Pop esi
          Call VerifyNoOtherReg
        ret

L0: Mov al B$Ereg,  B$SIBreg1 al

    Call SearchForScale | Mov al B$ScaleFound, B$Reg1isIndex al   ; true or FALSE
    Call SearchForEreg | IfEregNotFound L1>
        On B$esi-4 <> addSign, error D$ExpressionPtr
        Mov al B$Ereg,  B$SIBreg2 al | Mov B$TwoRegsFound &TRUE

        Call SearchForScale | Mov al B$ScaleFound,  B$Reg2isIndex al
        Call SearchForEreg | On B$Ereg <> NA  error D$expressionPtr    ; 3 regs forbidden

        .If B$ScaleFound = &FALSE
            If B$SIBreg2 = REG_EBP
              ; Exchange the two regs, for saving from having to add the zero Dis:
                Mov al B$SIBreg1, bl B$SIBreg2
                Mov B$SIBreg2 al, B$SIBreg1 bl
            End_If
        .End_If

L1: Mov al B$Reg1isIndex,  ah B$Reg2isIndex                    ; 2 index forbidden
    On ax = 0101,  error D$DoubleIndexPtr
    cmp ax 0 | je L4>                                          ; if no index found >L8

    Mov B$SIBinside &TRUE | cmp ax 1 | je L2>            ; if here: 1 reg / 1 index
        Mov al B$ScaledIndex | or al B$SIBreg1                 ; reg2 is Index and
        Mov B$SIB al | jmp L9>>                                 ; reg1 is base

L2: cmp B$TwoRegsFound &TRUE | je L3>
        Mov B$SibReg2 00101                              ; if no base > base = 00101
        Mov B$DummyDis &TRUE                                    ;

L3: Mov al B$ScaledIndex | or al B$SIBreg2                      ; reg1 is Index
      Mov B$SIB al | jmp L9>

L4: cmp B$TwoRegsFound &TRUE | jne L5>                           ; no index, but
        Mov B$SibInside &TRUE
        If B$SIBreg1 = 00_100
          ; Other way round, because there is no esp Index (only Base)
            Mov al B$SIBreg2 | On al = 00_100, error D$ExpressionPtr
            shl al, 3 | or al B$SIBreg1
        Else
            Mov al B$SIBreg1 | shl al, 3 | or al B$SIBreg2
        End_If

        Mov B$SIB al | jmp L9>

L5: cmp B$SIBreg1 REG_ESP | jne L9>             ; no index found, only one reg found, but
        Mov B$SibInside &TRUE | Mov B$SIB 024     ; if reg = ESP >SIB
L9: Pop esi
    ret


[immSign: D$ ?]

SearchForImm:      ; if yes, return value set in eax by translating routines
                   ; esi incrementations done by translating routine
    Mov B$immSign &FALSE
    Push esi | jmp L1>

L9: Pop esi | ret

L0:     inc esi
L1:     Mov dh B$esi-1,  B$ExpressedSign dh | Mov ah B$esi,  al B$esi+1
        cmp ah textSign | je L7>>
        ifSeparator ah, L9<
        cmp ah '0' | jb L0<
        cmp ah '9' | ja L0<
        cmp dh PartEnds | ja L0<
        Mov B$immInside &TRUE
        Push esi
            IfNot ah, '0', L2>
            IfNot al, '0', L3>
            Call translateBinary | jmp L4>
L2:         Call TranslateDecimal | jmp L4>
L3:         Call TranslateHexa
L4:         On edx > 0, error D$OutOfRangePtr
            cmp B$ExpressedSign Space | je S1>

            cmp B$ExpressedSign addSign | jne S2>
S1:             Mov ebx D$imm32 | add D$imm32 eax
                On D$imm32 < ebx, Mov B$immSign &FALSE
                jmp L5>
S2:         On B$ExpressedSign <> SubSign,  error D$NotYetSignPtr
            On D$imm32 < eax, Mov B$immSign &TRUE
            sub  D$imm32 eax

L5:     Pop esi
L6:     Mov B$esi 0                                         ; clear imm
        inc esi | cmp B$esi PartEnds | ja L6<
        jmp L1<<
;;
  Why the Api calls (that are "Call D$Location" Type...) are routed to 'SearchForImm',
  is because the Text Parameter ('Module.Function') looks like a 'Text' Member, for
  the Parsers of the Instructions Parameters.
;;
L7:     inc esi | Call NewSearchApiName | dec esi
        On B$ApiFound = &TRUE, jmp L9<<

        Push edi
            Mov B$immInside &TRUE | Mov edi imm32 | lodsb   ; read text sign
L7:         Mov B$esi-1 0 | lodsb                           ; clear imm text
            cmp al TextSign | je L8>
            add B$edi al | inc edi
            On edi = imm32+5,  error D$TxtTooMuchPtr             ; max of 4 letters
            jmp L7<
L8:         Mov B$esi-1 0                                   ; clear last text marker sign
        Pop edi
        jmp L1<<

L9: Pop esi
    cmp D$imm32 07F        ; Test for sBit: turn sBit to 0010 if byte sign imm
        ja L9>                   ; max. is 07F for positive values (and  0FF for
        Mov B$sBit 0010               ; negative ones).
        Mov B$immSign &FALSE  ; Because no need for storing SignExtended Bytes in 'StoreImm'
L9:     Mov eax D$imm32
        and eax 0FFFFFF00 | cmp eax 0FFFFFF00 | jne L9>
        Mov B$sBit 0010
        Mov B$immSign &FALSE  ; Because no need for storing SignExtended Bytes in 'StoreImm'
L9: ret

;;
 I don't use upper chunk (from 'L9: Pop esi'), because of the Sign Extensions able
 Opcodes. In case of Byte immediate with a possible immediate Label, we can't know
 here if there will be or not some trailing Label. Example:

 > and D$Label1+020 Label2-4

 Label2 will only be computed and the end of job, *after* other encodages. There is
 a test Routine, 'sim', that does this complicated job at the end of OpCode encodage.
 In cases of negative Sign Extended imm Bytes, the 'B$immSign' is turned &FALSE there
 to solve the problem of overflow tests done in 'StoreImm', for negative Bytes stored
 as dWords for 'non-Sign-Extended' Opcodes.
;;
____________________________________________________________________________________________

; Search for a displacement. If found, return value set by translating routine in eax:

SearchForDis:
    Push esi | jmp L1>
L0:     inc esi
L1:     Mov dh B$esi-1,  B$ExpressedSign dh
        Mov ah B$esi,  al B$esi+1
        cmp ah 0 | je L0<
        ifSeparator ah, L8>>
        cmp ah '0' | jb L0<
        cmp ah '9' | ja L0<
        cmp dh PartEnds | ja L0<
        Mov B$DisInside &TRUE
        Push esi
            IfNot ah, '0', L2>
            IfNot al, '0', L3>
            Call translateBinary | jmp L4>
L2:         Call TranslateDecimal | jmp L4>
L3:         Call TranslateHexa
L4:         On edx > 0, error D$OutOfRangePtr
            Mov bl B$esi-1
            If bl < Separators
            Else_If bl = addSign
            Else_If bl = subSign
            Else_If bl < LowSigns
                Error D$ExpressionPtr
            End_If
            cmp B$ExpressedSign Space | je S1>  ; ... ???? What case ???? ...
            cmp B$ExpressedSign 0 | je S1>
            cmp B$ExpressedSign addSign | jne S2>
                test D$Dis32 0_8000_0000 ZERO S1>
                    neg D$Dis32 | sub D$Dis32 eax | neg D$Dis32 | jmp L6>
S1:                 add D$Dis32 eax | jmp L6>
S2:         On B$ExpressedSign <> SubSign,  error D$NotYetSignPtr
            test D$Dis32 0_8000_0000 ZERO L5>
                neg D$Dis32 | add D$Dis32 eax | neg D$Dis32 | jmp L6>
L5:                 sub D$Dis32 eax
L6:     Pop esi
L7:     Mov B$esi 0
        inc esi | cmp B$esi PartEnds | ja L7<
        jmp L1<<

L8: Pop esi

    Mov eax D$Dis32        ; 080 > -128          //  07F > +127
    If eax > 0FFFF_FF7F    ; 0FFFF_FF80 > -128  //   0FFFF_FF7F > -129
        Mov B$LongRelative &FALSE
    Else_If eax < 080
        Mov B$LongRelative &FALSE
    Else
        Mov B$LongRelative &TRUE
    End_If
ret


SearchForLabel:
    Push esi
        Mov edi D$CodeRefPtr
L0:     lodsb | cmp al 0 | je L0<
                cmp al Separators | jb L9>>
                cmp al 'A' | jb L0<
                cmp al, 'Z' | ja L0<
        On B$esi-2 = AddSign,  Mov B$esi-2 0
        cmp al 'E' | jne L1>
        Push eax
            Call IsItAnEreg                 ; usefull only in case of mem adressing
        Pop eax
        IfEregNotFound L1>
            add esi 2 | jmp L0<             ; (Mod/RM byte done after)

L1:     Mov B$esi-1 0                       ; clear label evocation

      ; Local size is used for Local Labels coding
        .If al = '>'
            add B$LocalSize 4     ; > 00100    >> 001000
            If B$LocalSize = 4
              ; OK.
            Else_If B$LocalSize <> 8
E7:             error D$WhatIsThisPtr
            End_If
            If B$esi = '>'
              ; OK
            Else_If B$esi > Separators
                jmp E7<
            End_If
        .Else_If al = '<'
            add B$LocalSize 1     ; < 001      << 0010
            If B$LocalSize = 1
              ; OK.
            Else_If B$LocalSize <> 2
                jmp E7<
            End_If
            If B$esi = '<'
              ; OK
            Else_If B$esi > Separators
                jmp E7<
            End_If

        .End_If

        .If D$esi-9 = 'LOOP'
            If B$LocalSize = 0
                ; OK.
            Else_If B$LocalSize <> 1
                error D$LongLoopPtr
            End_If
        .End_If

        stosb                               ; write label name in CodeRef
        lodsb | IfNotPartEnd al, L1<<
        Mov eax D$CodeRefPtr | add eax 2 | cmp eax edi | jne L2>  ; local label without '<'?
          Mov ah B$edi-2,  al B$edi-1
          cmp ah 'A' | jb L2>
            cmp ah 'Z' | ja L2>
              cmp al '0' | jb L2>
                cmp al '9' | ja L2>         ; Local label without direction specifier?
                  Mov al '<' | stosb        ; default, for exemple for LOOP L0
                    Mov B$LocalSize 1       ; UpShort
L2:       Mov al EOI | stosb
          inc B$ExpressedLabels
          On B$ExpressedLabels > 2, error D$TooMuchLabelsPtr
          Mov B$LabelInside &TRUE,  B$DisInside &TRUE

L9:     Mov D$CodeRefPtr edi
    Pop esi
ret


SearchForModRMreg:
    Mov cl 32 | cmp B$LabelInside &TRUE | je L0>
    Mov eax D$Dis32

    On B$LongRelative = &FALSE, Mov cl 8
                                      ; for BYTE_SIZE tests on Displacement
                                                ; (080 >>> -128)
L0: Push esi
        cmp B$SIBinside &TRUE | je L0>                      ; no SIB found? >>> no more regs
            cmp B$EregInside &FALSE | je L1>                ; may be, an Ereg?
                Mov al B$PossibleRmEreg | Mov B$RMbits al | jmp L3>>

; no RMreg > choice: simple dis32, dis followed by SIB byte, SIB byte only:

L0:     cmp B$DisInside &TRUE | je L2>
            Mov B$ModBits 0 | Mov B$RMbits 00100 | jmp L9>> ; SIB with no dis

L1:     cmp B$DisInside &TRUE | jne L9>>                    ; nothing at all > exit
            Mov B$ModBits 0 | Mov B$RMbits 00101 | jmp L9>> ; dis32 with no SIB and no reg

L2:     Mov B$RMbits 00100 | cmp cl 32 | je L2>
            cmp B$DummyDis &TRUE | je L2>
            Mov B$ModBits 00_01_000_000 | jmp L9>           ; dis8 + SIB
L2:             If B$TwoRegsFound = &TRUE
                    Mov B$ModBits 00_10_000_000             ; dis32 + SIB
                Else_If B$Sib = 024
                    Mov B$ModBits 00_10_000_000             ; dis32 + esp only SIB
                Else
                    Mov B$ModBits 0                         ; dis32 + SIB with no Base
                End_If
                jmp L9>

; RMreg found > choice: no dis, dis8, dis32 (if reg = EBP and no dis > add zero 8bits dis)

L3:     cmp B$DisInside &FALSE | je L6>
            cmp cl 32 | je L5>
L4:             Mov B$ModBits 00_01_000_000 | jmp L9>       ; dis8 + reg
L5:             Mov B$ModBits 00_10_000_000 | jmp L9>       ; dis32 + reg

L6:     cmp B$RmBits REG_EBP | jne L7>                       ; reg EBP >>> add zero dis
            Mov B$DisInside &TRUE | jmp L4<

L7:     Mov B$ModBits 0                                     ; reg without displacement

L9: Pop esi

  ; This is to force things like "Push D$fs:+0' to be encoded Long, and not short dis form:
    cmp B$DisInside &TRUE | jne L9>
        cmp B$LabelInside &FALSE | jne L9>
            cmp B$EregInside &FALSE | jne L9>
                Mov B$LongRelative &TRUE

L9: ret


SearchForFirstFPUimm:
    Mov B$FirstGender IMM_VALUE | jmp L0>
SearchForSecondFPUimm:
    Mov B$SecondGender IMM_VALUE

L0: Push esi
        Call atof
        On al > CloseBracket, error D$BadRealPtr
        fstp D$imm32
        Mov B$ImmInside &TRUE, B$immSign &FALSE
    Pop esi
L0: Mov B$esi 0                                     ; clear imm
    inc esi | cmp B$esi PartEnds | ja L0<
  ret


FirstParameterAnalyze:
    Mov esi D$LineStart

L0: lodsb                               ; simply increase esi over first space; after this,
    cmp al Space | jne L0<                    ; save esi pointing to parameter (> Push/Pop)

    cmp B$esi+1 memMarker | jne L4>>               ; if mem marker found, store ascii value
      Mov al B$esi | Mov B$FirstParaMem al
      Mov W$esi 0 | add esi 2                     ; (see equ. for BYTE_MEM, WORD_MEM, DWORD_MEM)
      If B$esi = MemMarker
        inc esi
      End_If
      Mov B$FirstGender MEM_LABEL

        On B$esi = EOI, error D$ParameterPtr

        .If al = DWORD_MEM
             Mov B$FirstOperandwbit DWORD_SIZE   ; D$            4 bytes
        .Else_If al = BYTE_MEM
             Mov B$FirstOperandwbit BYTE_SIZE     ; B$            1 byte
        .Else_If al = WORD_MEM
             Mov B$FirstOperandwbit WORD_SIZE     ; W$            2 bytes
        .Else_If al = QWORD_MEM
             Mov B$FirstOperandwbit QWORD_SIZE     ; Q$            8 bytes
        .Else_If al = REEL_MEM
             Mov B$FirstOperandwbit QWORD_SIZE     ; R$ = FPU Q$   8 bytes
      ;  .Else_If al = REEL2_MEM
      ;       error NewHmem
       ;      Mov B$FirstOperandwbit QWORD_SIZE     ; H$ = FPU Q$   8 bytes >>> 16 bytes (!!!)
        .Else_If al = FLOAT_MEM
             If B$esi < 'A'
                 Call SearchForFirstFPUimm | ret     ; exemple: Push F$45.2
             Else
                 Mov B$FirstOperandwbit DWORD_SIZE   ; F$ = FPU D$
             End_If
        .Else_If al = TBYTE_MEM
             Mov B$FirstOperandwbit TBYTE_SIZE      ; T$ = FPU 10 Bytes / 80 bits (m80)
        .Else_If al = XWORD_MEM
            Mov B$FirstOperandwbit USO_SIZE         ; Weird and XMM sizes
        .Else_If al = OWORD_MEM
            Mov B$FirstOperandwbit OWORD_SIZE         ; Weird and XMM sizes
        .Else
            On al = REEL2_MEM error D$NewHmemPtr
            error D$UnknownSizePtr
        .End_If

L3:   Call SearchForSIB
      Call SearchForDis
      Call SearchForLabel
      ...If B$SibInside = &TRUE
        ..If B$DisInside = &FALSE
            .If B$ParametersNumber = 1
                If B$TwoRegsFound = &TRUE
                    Mov al B$SIB | and al 00_111
                    On al = 00_101, Mov B$DisInside &TRUE, B$LongRelative &true
                End_If
            .End_If
        ..End_If
    ...End_If
      Call SearchForModRMreg
        or B$ExpressedLabels 1                           ; we want B$ExpressedLabels < 3
        On B$ExpressedLabels > 2, error D$TooMuchLabelsPtr ; but only one Lab per member
    ret

L4: Call IsItaReg | cmp ah 0 | je L5>
      Mov B$FirstGender GENERAL_REG,  B$FirstReg al,  B$FirstRegGender ah
      Mov al B$OneOperandwbit,  B$FirstOperandwbit al
    ret

L5: Call SearchForImm | cmp B$ImmInside &FALSE | je L6>
      Mov B$FirstGender IMM_VALUE | Mov B$PossibleFirstImmLabel &TRUE
    ret

L6: If B$ApiFound = &TRUE   ; 'NewSearchApiName'
        Mov B$DisInside &TRUE, B$ApiFound &FALSE, B$FirstGender MEM_LABEL
        Mov B$ModBits 0, B$RmBits 00101
        Mov B$FirstOperandwBit DWORD_SIZE
        ret
    End_If

L6: Call SearchForLabel | On B$LabelInside = &FALSE,  error D$UnknownParameterPtr
      Mov B$FirstGender DISPLACEMENT
      or B$ExpressedLabels 1                            ; we want B$ExpressedLabels < 3
      On B$ExpressedLabels > 2, error D$TooMuchLabelsPtr     ; but only one Lab per member
    ret
____________________________________________________________________________________________

SecondParameterAnalyze:
    Mov esi D$LineStart

L0: lodsb                                        ; simply increase esi over second space
    cmp al Space | jne L0<
L1: lodsb | cmp al Space | jne L1<

    cmp B$esi+1 memMarker | jne L5>>             ; if mem marker found, store ascii value
        Mov al B$esi | Mov B$secondParaMem al
        Mov W$esi 0 | add esi 2                  ; (see equ. for BYTE_MEM, WORD_MEM, DWORD_MEM, ...)
        Mov B$secondGender MEM_LABEL

        On B$esi = EOI, error D$ParameterPtr

        .If al = DWORD_MEM
             Mov B$SecondOperandwBit DWORD_SIZE   ; D$
        .Else_If al = BYTE_MEM
             Mov B$SecondOperandwBit BYTE_SIZE     ; B$
        .Else_If al = WORD_MEM
             Mov B$SecondOperandwBit WORD_SIZE     ; W$
        .Else_If al = QWORD_MEM
             Mov B$SecondOperandwBit QWORD_SIZE     ; Q$
        .Else_If al = REEL_MEM
             Mov B$SecondOperandwBit QWORD_SIZE     ; R$ = FPU Q$
        .Else_If al = REEL2_MEM
             error D$NewHmemPtr
       ;      Mov B$SecondOperandwBit QWORD_SIZE     ; H$ = FPU Q$ (!!! > 16 bytes / 128 bits !!!)
        .Else_If al = FLOAT_MEM
             If B$esi < 'A'
                 Call SearchForSecondFPUimm | ret      ; exemple: Mov eax F$45.2
             Else
                 Mov B$SecondOperandwBit DWORD_SIZE   ; F$ = FPU D$
             End_If

        .Else_If al = TBYTE_MEM
             Mov B$SecondOperandwBit TBYTE_SIZE      ; T$ = FPU 10 Bytes
        .Else_If al = XWORD_MEM
            Mov B$SecondOperandwbit USO_SIZE         ; Weird and XMM sizes
        .Else_If al = OWORD_MEM
            Mov B$SecondOperandwbit OWORD_SIZE      ; XMM sizes
        .Else
            On al = REEL2_MEM error D$NewHmemPtr
            error D$UnknownSizePtr
        .End_If

L4:     Call SearchForSIB
        Call SearchForDis
        Call SearchForLabel
        ...If B$SibInside = &TRUE
            ..If B$DisInside = &FALSE
                .If B$FirstGender = GENERAL_REG
                    If B$TwoRegsFound = &TRUE
                        Mov al B$SIB | and al 00_111
                        On al = 00_101, Mov B$DisInside &TRUE, B$LongRelative &FALSE
                    End_If
                .End_If
            ..End_If
        ...End_If
        Call SearchForModRMreg
    ret

L5:   Call IsItaReg | cmp ah 0 | je L6>
      Mov B$secondGender GENERAL_REG,  B$secondReg al,  B$SecondRegGender ah
      Mov al B$OneOperandwbit,  B$secondOperandwbit al

      ...If B$SibInside = &TRUE
        ..If B$DisInside = &FALSE
            .If B$FirstGender = MEM_LABEL
                If B$TwoRegsFound = &TRUE
                    Mov al B$SIB | and al 00_111
                    On al = 00_101, Mov B$DisInside &TRUE, B$LongRelative &FALSE
                    Call SearchForModRMreg
                End_If
            .End_If
        ..End_If
    ...End_If

    ret

L6:   Call SearchForImm
      cmp B$ImmInside &FALSE | je L7>
      Mov B$secondGender IMM_VALUE | Mov B$PossibleImmLabel &TRUE
    ret

L7: If B$ApiFound = &TRUE   ; 'NewSearchApiName'
        Mov B$DisInside &TRUE, B$ApiFound &FALSE, B$SecondGender MEM_LABEL
        Mov B$ModBits 0, B$RmBits 00101
        Mov B$SecondOperandwBit DWORD_SIZE
        ret
    End_If

L7:   cmp D$DisInside &TRUE | jne L8>
      Mov B$secondGender IMM_VALUE | Mov B$PossibleImmLabel &TRUE
    ret

L8:  If B$ExpressedLabels = 0
        Call SearchForLabel
        On B$LabelInside = &FALSE,  error D$UnknownParameterPtr
        Mov B$SecondGender DISPLACEMENT
      Else                                     ; Case of 'Mov D$Lab1 Lab2'
        Mov B$ImmInside &TRUE, B$secondGender IMM_VALUE, B$PossibleImmLabel &TRUE
      End_If                                   ; Lab2 checked by PossibleImmLabel
      Mov B$sBit 0
    ret

FirstParameterLabel:
    Mov esi D$LineStart | jmp L1>

SecondParameterLabel:
    Mov esi D$LineStart
L0: lodsb | cmp al Space | jne L0<
L1: lodsb | cmp al Space | jne L1<
    Push esi
      Mov edi D$CodeRefPtr
L0:   lodsb | cmp al 0 | je L0<
              cmp al Separators | jb L9>>
              cmp al 'A' | jb L0<
              cmp al, 'Z' | ja L0<
      On B$esi-2 = AddSign,  Mov B$esi-2 0
      cmp al 'E' | jne L1>
      Push eax
        Call IsItAnEreg                      ; usefull only in case of mem adressing
      Pop eax
          IfEregNotFound L1>
            add esi 2 | jmp L0<              ; (Mod/RM byte done after)
L1:     cmp al  '>' | je A1>
        cmp al  '<' | jne A2>
A1:       error D$NoLocalPtr
A2:     stosb                                ; write label name in CodeRef
        Mov B$esi-1 0
        lodsb | IfNotPartEnd al, L1<
        Mov eax D$CodeRefPtr | add eax 2 | cmp eax edi | jne L2>  ; no local label here
          Mov ah B$edi-2,  al B$edi-1
          cmp ah 'A' | jb L2>
            cmp ah 'Z' | ja L2>
              cmp al '0' | jb L2>
                cmp al '9' | ja L2>
                  jmp A1<                                          ; no local label here
L2:       Mov al EOI | stosb
          Mov eax D$CodeListPtr
          On B$immInside = &TRUE, sub eax 4
          stosd

          Mov eax D$StatementsPtr, eax D$eax | stosd     ; write pointer to source.
          Mov al EOI | stosb |  Mov D$CodeRefPtr edi

          If B$immInside = &FALSE
             Mov edi D$CodeListPtr, eax 0 | stosd | Mov D$CodeListPtr edi
          End_If

        ; Very stupid. 'FirstParameterLabel' /'SecondParameterLabel' to be re-structured:
          If B$ParametersNumber > 1
            On B$FirstOperandWbit <> DWORD_SIZE error D$MissTypePtr
          End_If
L9: Pop esi
ret
____________________________________________________________________________________________

; Used only in case of SHLD / SHRD. third parameter must be either imm8 or CL

ThirdParameterAnalyze:
    Mov esi D$LineStart
L0: lodsb                            ; Simply increases esi over third space; after this,
    cmp al Space | jne L0<
L1: lodsb | cmp al Space | jne L1<
L2: lodsb | cmp al Space | jne L2<

        Call IsItaReg | cmp ah 0 | je L3>
        Mov B$ThirdGender GENERAL_REG,  B$ThirdReg al,  B$ThirdRegGender ah
        Mov al B$OneOperandwbit,  B$ThirdOperandwbit al
    ret

L3:     Call SearchForImm
        cmp B$ImmInside &FALSE | je L4>
        Mov B$ThirdGender IMM_VALUE
    ret

L4: error D$ParameterPtr
 _________________________________________________________________________________________
 _________________________________________________________________________________________
;;
 Main routine for one assembler line encoding (Data lines have been analyzed before)
 esi points to the first letter of an instruction in CodeSourceB
 we may find a label, one or more prefix(es), a mnemonic and parameters.
 Translates StrippedLine in OpCodes.
 after Data Storage, clean source is in  CodeSourceB as input
 results in:
            - LabelList      (data labels done with storage and now code labels)
            - CodeRef        (labels adresses evocations in codeList -will be used by
                              'fillCodeSymbols', in Main.a-)
            - CodeList       (true code for .code section)
            - Relocation     (for .reloc)

 i Call a 'Line' one set of statements between between '||'.
;;
 _________________________________________________________________________________________
 _________________________________________________________________________________________

StoreSIB:
   Mov edi D$CodeListPtr | Mov al B$SIB | stosb | inc D$CodeListPtr
ret
;;
 Label evocations are fulfill by 'Fill'. In case, for exemple, of
 'Mov EDI, My_Data_Label + 8', we store '8'
 as 'LongRelative' default is true, it is used here for any non short relative. this
 is to say even for not relative at all statements (Intel doc is killing on that point)
;;
StoreDis:
    If B$ApiDis = &TRUE
        Mov B$ApiDis &FALSE
        Mov edi D$CodeRefPtr, eax D$CodeListPtr     ; Store actual code offset in
        stosd                                       ; Coderef for ending 'Fill' routine
        Mov al EOI | stosb
        Mov D$CodeRefPtr edi
;;
  The CodeRef registration of Api calls does not have the Source Pointer Record.
  (No use as all Errors Checking have already been done when collecting the Api
  calls). So, only // 0FF / PointerToCode / EOI //, here, where "0FF" is written
  by 'NewSearchApiName' (called by 'SearchForImm').
  
  Why the Api calls (that are "Call D$Location" Type...) are routed to 'SearchForImm',
  is because the Text Parameter ('Module.Function') looks like a 'Text' Parameter,
  for the Parsers.
;;
        Mov edi D$CodeListPtr
        Mov eax D$Dis32 | stosd
        Mov D$CodeListPtr edi
        ret
    End_If

    cmp B$LabelInside &TRUE | jne L1>
        Mov edi D$CodeRefPtr, eax D$CodeListPtr     ; Store actual code offset in
        or eax D$Relative | stosd                   ; Coderef for ending 'Fill' routine
        Mov eax D$StatementsPtr, eax D$eax | stosd  ; write pointer to source:
        Mov al EOI | stosb
        Mov D$CodeRefPtr edi

L1: Mov edi D$CodeListPtr
    cmp B$LabelInside &TRUE | jne L2>
      cmp B$LocalSize 4 | je L4>
        cmp B$LocalSize 1 | je L4>
          jmp L3>

L2: cmp B$DummyDis &TRUE | je L3>
    cmp B$LongRelative &TRUE | jne L4>              ; default is true

L3:     Mov eax D$Dis32 | stosd                     ; Store displacement in code
        Mov D$CodeListPtr edi
    ret

L4:     Mov al B$Dis32 | stosb
        Mov D$CodeListPtr edi
ret


StoreImm:
    cmp B$immSign &TRUE | jne L0>
        cmp B$TrueSize BYTE_SIZE | jne L1>
            On D$imm32 < 0_FFFF_FF00,  error D$overflowPtr
            and D$imm32 0FF | jmp L0>
L1:     cmp B$TrueSize WORD_SIZE | jne L0>
            On D$imm32 < 0_FFFF_0000,  error D$overflowPtr
            and D$imm32 0FFFF

L0: Mov edi D$CodeListPtr
    cmp B$TrueSize DWORD_SIZE | je L2>
    cmp B$TrueSize BYTE_SIZE | je L3>

L1: On D$imm32 > 0FFFF,  error D$overflowPtr     ; word size
    Mov ax W$imm32 | stosw | jmp L9>

L2: Mov eax D$imm32 | stosd | jmp L9>       ; double size

L3: On D$imm32 > 0FF,  error D$overflowPtr       ; Byte size
    Mov al B$imm32 | stosb

L9: Mov D$CodeListPtr edi
ret

;;
 wBit is used when encoding instruction as 0 or 1, telling if it is byte or full
 size. full size is either 2 or 4 bytes: 32 bits > double word. With operand size
 override prefix, it is turn to word.
 'TrueSize' is used internally to hold lenght of code to write when fixing adresses
 of symbols after encoding (see Main)
;;
Store2Wbit:
    Mov al B$FirstOperandWbit | cmp B$secondOperandWbit al | je L0>
        Mov B$wBitDisagree &TRUE
ret


StoreFirstWbit:
    Mov al B$FirstOperandWbit

StoreWbit:
L0: cmp al WORD_SIZE | jne L1>
        Mov edi D$CodeListPtr
        Mov B$edi 066 | inc D$CodeListPtr        ; write operand size override prefix
L1:     Mov B$TrueSize al | and al 1 | Mov B$wBit al
ret


FixInstructionType:
    Mov edi D$CodeListPtr
    cmp B$FirstGender GENERAL_REG | jne L3>
      cmp B$SecondGender GENERAL_REG | jne L0>
        Mov B$Operands REG_TO_REG | Call Store2Wbit | ret
L0:   cmp B$SecondGender MEM_LABEL | jne L1>
        Mov B$Operands MEM_TO_REG | Call Store2Wbit | ret
L1:   cmp B$SecondGender DISPLACEMENT | je L2>
      cmp B$SecondGender IMM_VALUE | jne L9>>
L2:     Mov B$Operands IMM_TO_REG | Call StoreFirstWbit | ret

L3: cmp B$FirstGender MEM_LABEL | jne L6>
      cmp B$SecondGender GENERAL_REG | jne L4>
        Mov B$Operands REG_TO_MEM | Call Store2Wbit | ret

L4:   cmp B$SecondGender DISPLACEMENT | je L5>
      cmp B$SecondGender IMM_VALUE | jne L9>
L5:
        Mov B$Operands IMM_TO_MEM | Call StoreFirstWbit | ret

L6: cmp B$FirstGender IMM_VALUE | jne L9>
      cmp B$SecondGender GENERAL_REG | jne L7>
        Mov B$Operands REG_TO_IMM | ret
L7:   cmp B$SecondGender IMM_VALUE | jne L9>
        Mov B$Operands IMM_TO_IMM
        Mov esi D$LineStart | lodsb | cmp al, 'E' | jne L9>
             ret           ; exemple: ENTER 8, 2
                           ; exceptions: Job will be done when coding ENTER
L9: error D$MixTypePtr


SearchLineLabel:
L0: lodsb
    cmp al EOI | jbe L2>                        ; case of simple mnemonics, like |AAA|
        cmp al Space | jne L3>
L2:  Mov esi D$LineStart | jmp L9>
L3:     cmp al ColonSign | jne L0<
        Push esi
            Mov esi D$LineStart | Call StoreCodeLabel  ; in 'LabelList'
            inc D$CodeLabelsCounter
        Pop esi
        Mov D$LineStart esi                     ; new instruction's first letter after label
        If B$esi = ColonSign
            inc esi | inc D$LineStart           ; '::' for .export in DLL.
        End_If
    jmp L0<                                     ; Another Label following?:
L9: ret


ClearParameters:                                ;(clear parameters data area)
    Push edi
        Mov al 0,  edi ParametersData,  ecx D$ParametersDataLen | rep stosb
    Pop edi
ret


; Count of spaces = number of parameters (previous componants are cleared if any)

ParametersCount:
    Mov cl 0

    On D$esi = 'ENTE', jmp L9>             ; WordImm / ByteImm Param for Enter...
L0: lodsb | cmp al space | jne L1>
        inc cl                           ; one space >  +1 parameter in cl
        If B$esi-2 = MemMarker
            dec cl | Mov B$esi-1 MemMarker
        End_If
L1: cmp al EOI | ja L0<
L9: Mov B$ParametersNumber cl
ret

 _______________________________________________________________________________________
;;
 encodage of Apis calls is not done in 'Encode' but here with a memory indirect Call:
  1111 1111 : mod 010 r/m
 the 3 routines are linked by jumps when needed (not by calls)
;;

[ApiFound: D$ ?]

; Called with esi pointing to the next Char after 'TextSign'. Called from 'SearchForImm'
; because 'xxxx' may as well be a immediate.


; Previous holding of numbered Api (!!!...):
;
;    Push edi
;        Mov edx D$ebx               ; Table 1 pointers Ptr
;        Mov ebx D$ebx+16            ; table 2 pointers Ptr
;        add edx ecx | add ebx ecx
;
;L0:     Mov edi D$edx               ; pointer to function name
;        test edi 0_8000_0000 | jz L1>
;L5:         lodsb | cmp al TextSign | jne L5<
;                Pop edi | jmp EncodeApiCall

[ApiDis: D$ ?]

NewSearchApiName:
; A Description of .Import is in the Disassembler 'CheckImport'.
    On D$uImportSize = 0, ret

    pushad

    Mov B$ApiFound &FALSE

  ; Adjust esi on the FunctionName first Char. We do not take care of DLL Name,
  ; because this verification has already been done by 'BuildImport'. Instead,
  ; we search along all Functions Chunks.
    While B$esi <> TextSign | inc esi | End_While
    While B$esi <> '.'
        dec esi | On B$esi = TextSign, jmp L0>
    End_While
L0: inc esi                             ; Skip '.' or TextSign >>> FunctionName
    Mov edx D$CodeList | add edx 0400   ; ebx > Import header dll pointers
    Mov ecx edx                         ; to ajust adress, down there.
    sub ecx 01000                       ; Base Of Import.

  ; edx will keep track of the header
  ; ebx will keep track of the Functions Pointers List
L0: Mov ebx D$edx+16

  ; Cases of DLL without .Import:
    If ebx = 0
        popad | ret
    End_If

    add ebx ecx      ; Address Table Pointer

  ; ebx > FunctionName Pointers List
L1: Mov edi D$ebx
  ; ??????????????
  ; Un-resolved problem: What if several Functions in different DLLs having the same
  ; Function number???!!!...
    test edi 0_8000_0000 ZERO L2>
        If B$esi <> '0'
            Push esi | jmp L4>
        End_If

        Mov eax edi | xor eax 0_8000_0000

        Push esi, ebx, eax
            While B$esi = '0' | inc esi | End_While
            Mov ebx 0
H0:         lodsb | sub al '0' | On al > 9, sub al 7
            shl ebx 4 | or bl al
            cmp B$esi TextSign | jne H0<
        Pop eax

        If eax = ebx
            Pop ebx | jmp L5>
        End_If

        Pop ebx | jmp L4>

L2: add edi ecx | add edi 2
  ; edi > Function name (+2 is for the leading word).

L3: Push esi
L3:     Mov al B$esi | Mov ah B$edi | inc esi | inc edi | cmp al ah | je L3<
        cmp al TextSign | jne L4>
        cmp ah 0 | je L5>

  ; Not found:
L4: Pop esi

    add ebx 4
    .If D$ebx = 0
        add edx 20
        If D$edx = 0
            popad | ret
        Else
            jmp L0<<
        End_If
    .Else
        jmp L1<<
    .End_If

  ; Found:
L5: Pop esi
  ; Clear the 'DLL.Function':
    While B$esi <> TextSign | dec esi | End_While
    Do
        Mov B$esi 0 | inc esi
    Loop_Until B$esi = TextSign
    Mov B$esi 0

    Mov eax ebx
    If D$SavingExtension = '.SYS'
        add eax DRIVERDEFAULT | jmp L1>
    Else_If D$FL.RelocsWanted = &TRUE ;D$SavingExtension = '.DLL' ; jE!
        add eax D$LinkerDllDefault
L1:     Push ebx
          ; Comments in 'FillCodeSymbols':
            Mov ebx D$CodeRefPtr, B$ebx 0FF ;, D$ebx+1 edi, B$ebx+5 EOI
            Mov B$ApiDis &TRUE
            add D$CodeRefPtr 1 ;6
          ; The CodeRef thingies are now completed by the 'StoreDis', in order
          ; to assume the Relocations of Api Calls in DLLs.
        Pop ebx
    Else
        add eax LINKERDEFAULT
    End_If
    sub eax ecx | Mov D$Dis32 eax

    Mov B$ApiFound &TRUE

    popad
ret
____________________________________________________________________________________________

;;
 Encodage of an instruction is done. At this time, we control that all parameters
 have been translated (they are supposed to be zeroed)? Reg BL is used to jump
 tests over mnemonic (not zeroed):
;;

PointNextInstruction:
    Mov esi D$LineStart, bl 0
L0: lodsb
    cmp al Space | jne L1>
      Mov bl 1 | jmp L0<
L1: cmp bl 1 | jne L1>
      cmp al '0' | jbe L1>
     ;  Call InternalNextControl  ; (for developpement only)
        error D$UnknownParameterPtr
L1: cmp B$esi EOI | ja L0<
    cmp B$esi 0 | je L0<
  ret


; Private developper control of what exactly is wrong (not zeroed):


; 'DB 0....' encounted:

StoreFlatData:
    Push eax
        If al = 'B'
            ; OK

        Else_If al = 'W'
            ; OK
        Else_If al = 'U'
            ; OK
        Else_If al = 'D'
            ; OK
        Else_If al = 'Q'
            ; OK
        Else_If al = 'F'
            ; OK
        Else_If al = 'R'
            ; OK
        Else_If al = 'T'
            ; OK
        Else_If al = 'X'
            ; OK

        Else
            error D$NotAnOpcodePtr
        End_If

    ;  ; We must have a Label at the beginning of Line:
    ;    Mov ebx esi | While B$ebx > EOI | dec ebx | End_While | inc ebx
    ;  ; Cannot be a True Local Label:
    ;    Call IsTrueLocalLabel ebx | On eax = &TRUE, error D$LocalDefLabelPtr
    ;  ; But must be a Label:
    ;    While B$ebx > LowSigns | inc ebx | End_While
    ;    On B$ebx <> ColonSign, error D$WhatIsThisPtr
    Pop eax

  ; in: al = Size_Type // esi >>> 'DB ' >>> Go to the first Data after 'DB '
    Mov edi D$CodeListPtr
; StoreDatas StoreOneData
L0: .If al = 'B'

        Call StoreDBcode

    .Else_If al = 'W'
        Call StoreDWcode
    .Else_If al = 'U'
        Call StoreDUcode
    .Else_If al = 'D'
        Call StoreDDcode
    .Else_If al = 'Q'
        Call StoreDQcode
    .Else_If al = 'F'
        error D$NotYetMnemoPtr
        ;Call StoreDFcode
    .Else_If al = 'R'
        error D$NotYetMnemoPtr
        ;Call StoreDRcode
    .Else_If al = 'T'
        error D$NotYetMnemoPtr
        ;Call StoreDTcode
    .Else_If al = 'X'
        error D$NotYetMnemoPtr
        ;Call StoreDXcode
    .Else
        error D$UnknownSizePtr
    .End_If

    dec esi
    If B$esi > EOI
        inc esi | jmp L0<<
    End_If

    Mov D$CodeListPtr edi

  ; Arase the Source Line:
    Mov ebx D$LineStart
    While ebx < esi
        Mov B$ebx 0 | inc ebx
    End_While
    dec esi
ret


GetFlatInteger:
    If W$esi = '00'
        Call TranslateBinary
    Else_If B$esi = '0'
        Call TranslateHexa
    Else_If B$esi < '0'
        error D$UnknownDataPtr
    Else
        Call TranslateDecimal
    End_If
ret


StoreDBcode:
L0: If B$esi = TextSign
      ; Cases of Text:
        inc esi | While B$esi <> TextSign | movsb | End_While | inc esi
        On B$esi > Space, error D$MissingSeparatorPtr
    Else
      ; Cases of Numbers:
        Call GetFlatInteger | On eax > 0FF, error D$OverBytePtr
        stosb
    End_If

    On B$esi+2 = memMarker, ret

    If B$esi+3 = Space
        On B$esi+1 = 'D', ret
    End_If

    On B$esi-1 = Space, jmp L0<
ret


StoreDWcode:
L0: Call GetFlatInteger | On eax > 0FFFF, error D$OverWordPtr
    stosw | cmp B$esi-1 Space | je L0<
ret


StoreDUcode:
    .If B$esi = TextSign
        inc esi
        While B$esi <> TextSign
            movsb | Mov B$edi 0 | inc edi
        End_While
        inc esi
        On B$esi > Space, error D$MissingSeparator
        On B$esi+2 = memMarker, ret
        If B$esi+3 = Space
            On B$esi+1 = 'D', ret
        End_If
    .End_If

    Call GetFlatInteger | On eax > 0FFFF, error D$OverWordPtr

    stosw | cmp B$esi-1 Space | je L0<
ret


StoreDDcode:
L0: Call GetFlatInteger | On edx > 0, error D$OverDWordPtr
    stosd | cmp B$esi-1 Space | je L0<
ret


StoreDQcode:
L0: Call GetFlatInteger
    stosd | Mov D$edi edx | add edi 4 | cmp B$esi-1 Space | je L0<
ret

____________________________________________________________________________________________

[InstructionsCounter: D$ ?]

EncodeLines:
    Mov B$ErrorLevel 0, D$CodeLabelsCounter 0
ReCodeLine:
    Mov esi D$CodeSourceB
    Mov D$StatementsCounter 1, D$InstructionsCounter 0

    Move D$StatementsPtr D$StatementsTable | sub D$StatementsPtr 4
L0: lodsb | cmp al 0 | je L0<
    On B$esi <= EOI,  ret                           ; search for end mark '||'

    Mov D$LineStart esi

    If al = EOI
        inc D$StatementsCounter | add D$StatementsPtr 4
        Mov edi D$IpTablePtr, eax D$CodeListPtr
        sub eax D$CodeOrigine                       ; instruction pointers
        stosd | Mov D$IpTablePtr edi                ; List for Debug
    End_If

    Call ClearParameters | Call SearchLineLabel
      cmp B$esi EOI | jbe L0<                       ; case of Label alone
        inc D$InstructionsCounter

   ; Call SearchApiCall | cmp B$esi EOI | jbe L0<
   ; Now done by 'NewSearchApiName' (when computing 'Integers')

    Call StoreSOP | Call Prefix     ; Is There SOP (Segment Prefix Ovewrite) or prefixes?
                                    ; if yes, coding and striping done by called routines
    cmp B$esi EOI | jbe L0<         ; case of prefix alone


    .If B$esi+1 = memMarker
         Mov al B$esi | add esi 2 | Call StoreFlatData | jmp L0<<
    .Else_If B$esi+2 = Space
        If B$esi = 'D'
            Mov al B$esi+1 | add esi 3 | Call StoreFlatData | jmp L0<<
        End_If
    .End_If


L3: Call ParametersCount            ; > cl = ParametersNumber

    Mov B$LongRelative &TRUE        ; will be turn FALSE when needed for short dis.

    cmp cl 0 | je L3>> ; !!!!!!!!!!!!!!! >>
    If cl = 1
      Call FirstParameterAnalyze
      Mov al B$FirstOperandwbit | Call StoreWbit
    Else_If cl = 2
      Call FirstParameterAnalyze | Call SecondParameterAnalyze
      Call FixInstructionType
    Else_If cl = 3                                            ; (SHLD / SHRD > 3 parameters)
      Call FirstParameterAnalyze | Call SecondParameterAnalyze
      Call ThirdParameterAnalyze | Call FixInstructionType
    Else
      Mov B$errorLevel 0 | error D$TooMuchPtr
    End_If

    On B$LockInstruction = &TRUE, Call CheckLockMem

L3: Call Encode | Mov D$CodeListPtr edi

    On B$SIBinside = &TRUE,  Call storeSIB
    cmp B$DisInside &TRUE | jne L4>
        Call StoreDis | jmp L5>                    ; cases of label / displacement

L4: cmp B$DummyDis &TRUE | jne L5>

        Mov eax 0 | Mov edi D$CodeListPtr | stosd
        add D$CodeListPtr 4

L5: On B$immInside = &TRUE,  Call storeImm

    On B$PossibleFirstImmLabel = &TRUE, Call FirstParameterLabel
        On B$PossibleImmLabel = &TRUE, Call SecondParameterLabel

    If B$mm3Dsuffix <> 0
        Mov al B$mm3Dsuffix, B$mm3Dsuffix 0
        Mov edi D$CodeListPtr | stosb
        inc D$CodeListPtr
    End_If

L6: Call PointNextInstruction       ; Includes a developper Message in case of error
                                    ; cases / searches become a problem.
    jmp L0<<

____________________________________________________________________________________________
____________________________________________________________________________________________

; reading and writing chars.
____________________________________________________________________________________________

Store8cars:
    Mov op5 B$esi+4, op6 B$esi+5, op7 B$esi+6, op8 B$esi+7
Store4cars:
    Mov op1 B$esi, op2 B$esi+1, op3 B$esi+2, op4 B$esi+3
ret


[IfNot | cmp #1, #2 | jne #3]
 ________________________________________________________________________________________

; Called when cc conditions needed (Jcc, MOVcc, ...). esi set by caller:

[tttnBits: D$ ?]

SearchFortttnbits:
     On W$esi = 'NN', add esi 2      ; accept double negation ('jnna' = 'ja')
     Call Store4Cars
     ifnot op2 Space, L2>>
       ifnot op1 'E', L1>
         Mov B$tttnBits 00100 | ret        ; e
L1:    ifnot op1 'Z',  L1>
         Mov B$tttnBits 00100 | ret        ; z
L1:    ifnot op1 'A', L1>
         Mov B$tttnBits 00111 | ret        ; a
L1:    ifnot op1 'G', L1>
         Mov B$tttnBits 001111 | ret       ; g
L1:    ifnot op1 'B', L1>
         Mov B$tttnBits 0010 | ret         ; b
L1:    ifnot op1 'C', L1>
         Mov B$tttnBits 0010 | ret         ; c
L1:    ifnot op1 'L', L1>
         Mov B$tttnBits 001100 | ret       ; l
L1:    ifnot op1 'O', L1>
         Mov B$tttnBits 0000 | ret         ; o
L1:    ifnot op1 'S', L1>
         Mov B$tttnBits 001000 | ret       ; s
L1:    ifnot op1 'P', L1>
         Mov B$tttnBits 001010 | ret       ; p
L1:    BadMnemonic

L2:  ifnot op3 Space, L3>>
       ifnot op1 'N', L1>
         ifnot op2 'E', L2>
           Mov B$tttnBits 00101 | ret    ; ne
L2:      ifnot op2 'Z', L2>
           Mov B$tttnBits 00101 | ret    ; nz
L2:      ifnot op2 'O', L2>
           Mov B$tttnBits 0001 | ret     ; no
L2:      ifnot op2 'B', L2>
           Mov B$tttnBits 0011 | ret     ; nb
L2:      ifnot op2 'C', L2>
           Mov B$tttnBits 0011 | ret     ; nc
L2:      ifnot op2 'L', L2>
           Mov B$tttnBits 001101 | ret   ; nl
L2:      ifnot op2 'A', L2>
           Mov B$tttnBits 00110 | ret    ; na
L2:      ifnot op2 'G', L2>
           Mov B$tttnBits 001110 | ret   ; ng
L2:      ifnot op2 'P', L2>
           Mov B$tttnBits 001011 | ret   ; np
L2:      ifnot op2 'S', L2>
           Mov B$tttnBits 001001 | ret   ; ns
L2:      BadMnemonic
L1:    ifnot op2 'E', L2>
         ifnot op1 'A', L1>
           Mov B$tttnBits 0011 | ret     ; ae
L1:      ifnot op1 'B', L1>
           Mov B$tttnBits 00110 | ret    ; be
L1:      ifnot op1 'P', L1>
           Mov B$tttnBits 001010 | ret   ; pe
L1:      ifnot op1 'G', L1>
           Mov B$tttnBits 001101 | ret   ; ge
L1:      ifnot op1 'L', L1>
           Mov B$tttnBits 001110 | ret   ; le
L1:       BadMnemonic
L2:      ifnot op1 'P', L1>
           ifnot op2 'O', L2>
             Mov B$tttnBits 001011 | ret  ; po
L2:       ; BadMnemonic
L1:      BadMnemonic

L3:   ifnot op1 'N', L9>
        ifnot op3 'E', L9>
          ifnot op4 Space, L9>
            ifnot op2 'G', L2>
              Mov B$tttnBits 001100 | ret  ; nge
L2:         ifnot op2 'B', L2>
              Mov B$tttnBits 00111 | ret   ; nbe
L2:         ifnot op2 'A', L2>
              Mov B$tttnBits 0010 | ret    ; nae
L2:         ifnot op2 'L', L2>
              Mov B$tttnBits 001111 | ret  ; nle
L2:
L9: BadMnemonic
 _______________________________________________________________________________________
;;
 search for prefix(es)
 Only one prefix of each group should be allowed > test addition needed
 (to do later if wanted)

 Segment Override Prefix  (SOP)
 When a xS: encounted, the code value is stored and xS: is stripped by ClearSOP
 esi > CodeSourceB  edi > CodeList by CodeListPtr
;;
 _______________________________________________________________________________________

WriteSOP:
    sub esi 3 | lodsb | Mov ah al | lodsb | On al <> 'S', Error D$NotSegmentPtr

    ifnot op1 'C',  L1>
        Mov al 02E | jmp L9>
L1: ifnot op1 'S', L1>
        Mov al 036 | jmp L9>
L1: ifnot op1 'D', L1>
        Mov al 03E | jmp L9>
L1: ifnot op1 'E', L1>
        Mov al 026 | jmp L9>
L1: ifnot op1 'F', L1>
        Mov al 064 | jmp L9>
L1: On op1 <> 'G', error D$NotSegmentPtr
        Mov al 065
L9: Mov edi D$CodeListPtr | stosb | inc D$CodeListPtr
ret
 __________________________________________________________________________________________
;;
 exemple of ClearSOP job: when called, esi point to  ':'

                  |Mov CS:D$EBX 1|
          new esi>>>>>^  ^<<<<<<< old esi > new edi


 after std, lodsb and stosb esi (new line start) point to the first letter of mnemonic:

                  |MOVMOV D$EBX 1|
                      ^<<<<< edi > last new esi  >>> last new LineStart
;;
 __________________________________________________________________________________________

ClearSOP:                   ; esi > ':' sign  >>>  '.xS:'  (this point is a space)
    Push edi
        Mov edi esi | sub esi 3
        std
L0:         lodsb | cmp al EOI | jbe L9>
                    cmp al colonSign | je L9> ; To hold Lines with 'head Labels'.
            stosb | jmp L0<
L9:     cld
        Mov esi edi | inc esi       ; esi > new start of instruction
        Mov D$LineStart esi
    Pop edi
ret

StoreSOP:
    Push esi
L0:     lodsb | cmp al EOI | jbe L9>
        cmp al ColonSign | jne L0<  ; no possible confusion:
            Call WriteSOP           ; labels have been treated before
            Call ClearSOP
        Pop eax                     ; scratch old esi
        Push esi                    ; (re)save new esi
L9: Pop esi
ret

 _______________________________________________________________________________________
 _______________________________________________________________________________________

Prefix:
    Mov edi D$CodeListPtr,  esi D$LineStart
L0: Call Store8cars
    ifnot op1 'R', L6>
      ifnot op2 'E', L9>>
        ifnot op3 'P', L9>>
          cmp op4 Separators | ja L2>                                   ; REP
            Mov B$edi 0F3 | add esi 4 | inc edi | jmp L0<
L2:       cmp op5 Separators | ja L4>
            cmp op4 'E' | je L3>
            ifnot op4 'Z', L9>
L3:           Mov B$edi 0F3 | add esi 5 | inc edi | jmp L0<             ; REPE/REPZ
L4:       ifnot op4 'N', L9>
            cmp op6 Separators | ja L9>
              cmp op5 'E' | je L5>
              ifnot op5 'Z', L9>
L5:             Mov B$edi 0F2 | add esi 6 | inc edi | jmp L0<           ; REPNE/REPNZ
L6: ifnot op1 'U', L6>
      ifnot op2 'T', L9>
        ifnot op3 'J', L9>
            Mov B$esi+3 '_' | jmp L9>
L6: ifnot op1 'L', L9>
      ifnot op2 'T', L6>
        ifnot op3 'J', L9>
            Mov B$esi+3 '_' | jmp L9>
L6:   ifnot op2 'O', L9>
        ifnot op3 'C', L9>
          ifnot op4 'K' L9>
            cmp op5 Separators | ja L9>
              Call CheckLockInstruction
              Mov B$LockInstruction &TRUE
              Mov B$edi 0F0 | add esi, 5 | inc edi | jmp L0<<            ; LOCK
L9: On esi = D$LineStart,  ret                                 ; nothing done > exit
      On B$esi-1 <= EOI,  dec esi
      Mov D$LineStart esi,  D$CodeListPtr edi
ret


LockInstructionError: Mov B$LockInstruction &FALSE | error D$LockErrorPtr


CheckLockMem:
    Mov B$LockInstruction &FALSE

    If B$FirstGender <> MEM_LABEL
        On B$SecondGender <> MEM_LABEL error D$LockMemErrorPtr
    End_If
ret

CheckLockInstruction:
;;
  Edi Points to the next Member of the Instruction.
  
  The Instruction can only be ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC,
  INC, NEG, NOT, OR, SBB, SUB, XADD, XCHG, or XOR
;;

  Push esi
  add esi 5
  ; ADD, ADC, AND:
    ...If B$esi = 'A'
        .If B$esi+1 = 'D'
            If B$esi+2 = 'D'           ; ADD
                ;
            Else_If B$esi+2 = 'C'      ; ADC
                ;
            Else
                jmp LockInstructionError
            End_If

            On B$esi+3 <> Space, jmp LockInstructionError

        .Else_If B$esi+1 = 'N'
            If B$esi+2 = 'D'           ; AND
                On B$esi+3 <> Space, jmp LockInstructionError
            Else
                jmp LockInstructionError
            End_If

        .Else
            jmp LockInstructionError
        .End_If

  ; BTC, BTR, BTS:
    ...Else_If B$esi = 'B'
        .If B$esi+1 = 'T'
            If B$esi+2 = 'C'
                ;
            Else_If B$esi+2 = 'R'
                ;
            Else_If B$esi+2 = 'S'
                ;
            Else
                jmp LockInstructionError
            End_If

            On B$esi+3 <> Space, jmp LockInstructionError

        .Else
            jmp LockInstructionError

        .End_If

  ; DEC
    ...Else_If W$esi = 'DE'
        If B$esi+2 = 'C'
            On B$esi+3 <> Space, jmp LockInstructionError
        Else
            jmp LockInstructionError
        End_If

  ; INC, NEG, NOT, OR, SBB
    ...Else_If W$esi = 'IN'
        If B$esi+2 = 'C'
            On B$esi+3 <> Space, jmp LockInstructionError
        Else
            jmp LockInstructionError
        End_If

    ...Else_If W$esi = 'NE'
        If B$esi+2 = 'G'
            On B$esi+3 <> Space, jmp LockInstructionError
        Else
            jmp LockInstructionError
        End_If

    ...Else_If W$esi = 'NO'
        If B$esi+2 = 'T'
            On B$esi+3 <> Space, jmp LockInstructionError
        Else
            jmp LockInstructionError
        End_If

    ...Else_If W$esi = 'OR'
        On B$esi+2 <> Space, jmp LockInstructionError ; jE!

    ...Else_If W$esi = 'SB'
        If B$esi+2 = 'B'
            On B$esi+3 <> Space, jmp LockInstructionError
        Else
            jmp LockInstructionError
        End_If
  ; SUB, XADD, XCHG, or XOR
    ...Else_If W$esi = 'SU'
        If B$esi+2 = 'B'
            On B$esi+3 <> Space, jmp LockInstructionError
        Else
            jmp LockInstructionError
        End_If

    ...Else_If D$esi = 'XADD'
        On B$esi+4 <> Space, jmp LockInstructionError

    ...Else_If D$esi = 'XCHG'
        On B$esi+4 <> Space, jmp LockInstructionError

    ...Else_If W$esi = 'XO'
        If B$esi+2 = 'R'
            On B$esi+3 <> Space, jmp LockInstructionError
        Else
            jmp LockInstructionError
        End_If

  ; CMPXCHG, CMPXCHG8B:
    ...Else_If D$esi = 'CMPX'
        ..If W$esi+4 = 'CH'
            .If B$esi+6 = 'G'
                If B$esi+7 = Space
                    ;
                Else_If W$esi+7 = '8B'
                    On B$esi+9 <> Space, jmp LockInstructionError
                Else
                    jmp LockInstructionError
                End_If
            .Else
                jmp LockInstructionError
            .End_If
        ..Else
            jmp LockInstructionError
        ..End_If

    ...Else
        jmp LockInstructionError

    ...End_If

    Pop esi
ret

 _________________________________________________________________________________________
 _________________________________________________________________________________________
;;
 When all encoding job is done, we now fill label evocation in code with label adresses
 stored in LabelList. We creat a .reloc section if wanted (DLLs).
;;

[RelocPage: D$ ?
 RelocSectionSize: D$ ?
 FileAlignedRelocationSize: D$ ?]

[StartOfCodeSection: D$ 01000
 StartOfDataSection: D$ 02000] ; redefined any case after encoding

[LastUpSearchLabel: D$ ?]

SearchLocalLabelUp:                     ; EDI >>> LabelList+3 / EDX >>> end of LabelList
L0: Push esi, ecx, ebx                  ; this ESI points to CodeRef <<<<<< ESI >>>>>>
L1:   lodsb                             ; jmp over name in Coderef
      cmp al EOI | ja L1<
        lodsb                           ; strip one '|' ('L1<|..' turn previously 'L1||..')
        On B$LongRelative = &TRUE, lodsb ; idem for long > 'L1>>|'  > 'L1|||'
        lodsd                           ; local label evocation offset in EAX
        and eax 07FFFFFFF   ; 0111111111111111B strip relative flag from offset (if any)
        Mov ecx eax
        lodsd | Mov D$StatementsCounter eax
        Mov esi edi         ; switch ESI to LabelList    <<<<<< ESI >>>>>>
        On D$LastUpSearchLabel > 0, Mov esi D$LastUpSearchLabel
; ESI > start of first name in LabelList. We now search in LabelList a fitting adress
; by comparison with evocation offset stored in ECX: search for a neighbour label
; located after evocation and set EDI to previous one's end

L2:   Mov ebx esi                       ; save start of LabelList name
L3:   lodsb                             ; jmp over name in LabelList
        cmp esi edx | jae L5>           ; reach end of LabelList? (EDX = Max)
        cmp al EOI | ja L3<
        lodsd                           ; read an offset in LabelList
        test B$esi FLAG_CODE_LABEL ZERO L4>
        cmp eax ecx | ja L5>            ; is it about the same offset than the Coderef one?
L4:     lodsb                           ; jump over flag byte
        lodsb                           ; jmp over '|'
      jmp L2<
                                        ;          |PREVIOUSNAME|Dword byte|NAME|
                                        ;                      ^ <<<<<<<<  ^
L5: sub ebx 8 | Mov edi ebx             ; set EDI > end of previous LabelList name
    Mov D$LastUpSearchLabel ebx         ; This Value saves a lot of Search tim!!!
    Pop ebx, ecx, esi                   ; ESI back to CodeRef     <<<<<<< SI >>>>>>
    inc esi                             ; For 'L1' label, ESI was at 'L'. Now, ready for
                                                                  ; backward search
    std                                 ; ready to check backward

    align 32

L6: Push esi ecx
      repe cmpsb                 ;  cmp ESI (CodeRef) to EDI (LabelList) until different
      je L9>                            ;  > found
      cmp B$edi+1 EOI | jbe L7>         ; case of LabelList name shorter than CodeRef's one
      Mov ecx 0FF,  al EOI | repne scasb  ; longer: LabelList Di ptr > after next '|'
L7:   sub edi 6                           ;          |PREVIOUSNAME|Dword byte|NAME|
                                          ;                      ^ <<<<<<< ^
    Pop ecx, esi
    On edi <= D$LabelList, error D$UnknownSymbolPtr esi      ; (we are searching upward)
    jmp L6<

L9: cld                                  ; ESI, EDI > start of identical found label name
    Pop ecx esi                          ; ESI > end of name
    On B$LongRelative = &TRUE,  inc esi   ; strip additionnal '|' (old '<')
    add esi 3                            ; ESI > Dword offset of code evocation
    add edi 5                            ; EDI > Dword offset of code or data label
ret


[LastDownSearchLabel: D$ ?]

SearchLocalLabelDown:
L0: Push esi, ecx, ebx
L1:   lodsb                             ; jmp over name in Coderef
        cmp al EOI | jne L1<
        lodsb                           ; stip one '|' ('L1>|..' turn previously 'L1||..')
        On B$LongRelative = &TRUE,  lodsb
        lodsd                           ; local label evocation offset in eax
        test eax RelativeFlag ZERO L2>
          and eax 00_01111111_11111111_11111111_11111111   ;07FFFFFFF   ; strip flag
L2:   Mov ecx eax
      lodsd | Mov D$StatementsCounter eax | Mov esi edi
      On D$LastDownSearchLabel > 0, Mov esi D$LastDownSearchLabel
L3:   Mov ebx esi                       ; save start of LabelList name
L4:   lodsb                             ; jmp over name in LabelList
        cmp esi edx | jae L7>           ; reach end of LabelList? (EDX = Max)
        cmp al EOI | ja L4<
        lodsd
        test B$esi FLAG_CODE_LABEL ZERO L5>
          cmp eax ecx | jae L6>         ; is it about the same offset?
L5:     lodsb                           ; jump over flag byte
        lodsb                           ; jmp over '|'
      jmp L3<
L6: Mov edi ebx                         ; restore start of LabelList name in DI
    Mov D$LastDownSearchLabel ebx       ; This Value saves lot of search time!!!
    Pop ebx ecx esi           ; edi > First label name's letter with possible adress
    Call SearchRegularLabel
    inc esi                             ; strip '>' for short jump
    On B$LongRelative = &TRUE,  inc esi  ; strip next '>' if long jump
ret

L7: Pop ebx ecx esi
    error D$UnknownSymbolPtr esi


; when called, ESI > start of a label name in CodeRef, ECX lenght of this name
; EDI set to >  LabelList + 5  by FillCodeSymbols (start of first label name in LabelList)

SearchRegularLabel:
    Mov al EOI
L0: Push esi ecx
        repe cmpsb              ;  cmp esi (CodeRef/DataRef) to edi (LabelList) until different
        je L8>                  ;  > found
            cmp B$edi-1 al | jbe L3>      ; case of LabelList name shorter than CodeRef's one
            Mov ecx 0FF | repne scasb     ; longer: LabelList edi ptr > after next '|'
L3:         add edi 6                                 ; |LABELNAME|dword FlagByte|NEXTNAME
                                                    ;        EDI ^ >>>>>>>>     ^
            If edi >= edx                       ; edx = LabelList Max.
                Pop ecx, esi
                error D$UnknownSymbolPtr esi
            End_If
    Pop ecx, esi | jmp L0<

L8: cmp B$Relative &TRUE | je L9>           ; if comming from 'SearchLocalLabeldown', OK
      test D$esi RelativeFlag ZERO L9>           ; if not, possible relative:
        Mov D$Relative &TRUE,  B$LongRelative &TRUE     ; this is for 'JMP label'
L9: Pop eax eax             ; if here, found: dummy stack restore. edi > code adress dWord
    ret


SearchSortedRegularLabel:
;;
    dec ecx
    If D$LabelsPointersBySizes+ecx*4 <> 0
        Mov edi D$LabelsPointersBySizes+ecx*4
    Else
        error UnknownSymbol esi
    End_If
    inc ecx | Mov al EOI
    

L0: Push esi ecx
        repe cmpsb              ;  cmp esi (CodeRef/DataRef) to edi (LabelList) until different
        je L8>                  ;  > found
            cmp B$edi-1 al | jbe L3>      ; case of LabelList name shorter than CodeRef's one
            Mov ecx 0FF | repne scasb     ; longer: LabelList edi ptr > after next '|'
L3:         add edi 6                             ; |LABELNAME|dword FlagByte|NEXTNAME
                                                  ;        EDI ^ >>>>>>>>     ^
            If edi >= edx                       ; edx = LabelList Max.
                Pop ecx, esi
                error UnknownSymbol esi
            End_If
    Pop ecx, esi | jmp L0<
;;

L8: Call GetFromQwordCheckSum esi, D$LabelList, D$LabelListLimit

    If eax = 0
        Push D$esi
            pushad
                Call IsItAreg | On eax <> 0, error D$UnexpectedRegPtr, esi
            popad
        Pop D$esi
        error D$UnknownSymbolPtr, esi
    Else
        While B$eax > LowSigns | inc eax | inc esi | End_While | inc eax | inc esi
        Mov edi eax, ecx 0
    End_If

L8: cmp B$Relative &TRUE | je L9>           ; if comming from 'SearchLocalLabeldown', OK
        test D$esi RelativeFlag ZERO L9>           ; if not, possible relative:
            Mov D$Relative &TRUE,  B$LongRelative &TRUE     ; this is for 'JMP label'

L9: ret


; construction of relocation table. called by FillDataSymbols routine when an uncomputed
; adress is found. EDI > code offset of an evocation.

[CodeOrData: D$ ?]

StoreApiReloc: ; NewSearchApiName PreparePeHeader
  ; eat 0FF found at esi, by 'FillCodeSymbols'
    inc esi | Mov edi D$esi | add esi 5
;jE!
StoreReloc: ; 'RelocComments'
    Push eax, ebx, ecx, edi
L0:
      Mov eax edi
      sub eax D$CodeOrData | and eax PAGE_MASK ;| add eax PAGE_SIZE
     ; cmp eax D$RelocPage | je L3>
      cmp eax 01000 | jb L3>>
     ; if in the same page of code, just write (>L3). if not:
     ; writing of reloc page header. Each section begins by a header of two Dwords.
     ; first one is the virtual adress; exemple, 01000 if begins at 00401000.
     ; second one is the total number of octets of the section.
      add D$CodeOrData 01000

If D$RelocSectionSize = 8 ; if unused RelocSection, reuse it for Next
 add D$RelocPage PAGE_SIZE | Mov eax D$RelocPage |
 Mov ecx D$RelocationPtr | Mov D$ecx-8 eax | jmp L0<
End_If
      Push eax, edi
        Mov eax 0 | Mov edi D$RelocationPtr
L1:     test D$RelocationPtr 0011 ZERO L2>                   ; align on Dword boudary
          stosw                                              ; fill with zeros
          add D$RelocationPtr 2 | add D$RelocSectionSize 2

L2:     Mov ebx D$RelocationPtr | sub ebx D$RelocSectionSize | add ebx 4
        Mov eax D$RelocSectionSize | Mov D$ebx eax     ; set second dWord to section size

        add D$RelocPage PAGE_SIZE | Mov eax D$RelocPage | stosd
        add edi 4 | Mov D$RelocationPtr edi | Mov D$RelocSectionSize 8
      Pop edi, eax
jmp L0<< ; don't continue, becouse can be over NEXT-PAGE

L3:   Mov eax edi | sub eax D$CodeOrData | and eax 0FFF| add eax 03000  ; or! eax 03000, RelocTypeFlag
      Mov edi D$RelocationPtr | stosw

      add D$RelocSectionSize 2 | Mov D$RelocationPtr edi
    Pop edi, ecx, ebx, eax
ret
 ________________________________________________________________________________________
;;
 Filling code label evocations (set to zeros at coding time, fill when coding is over)

 > esi points to label name in CodeRef (fix)
 > edi points to label name in LabelList (moveable)
 ecx = lenght of researched name (count from CodeRef)

 True labels adresses writing in generated code. See full comments down there
 about the tables used in this deal
 esi > CodeRef  ebx = CodeRef End     edi > LabelList  edx = LabelList End
 The job is difficult enough: it may be about:
 uncomputed code or data references,
 computed (+/-) jumps or calls either short (one byte) or long (four bytes)
 Values are turned RVA with 'CodeAjust' an 'DataAjust' set by 'InitRelocation'
;;
 ________________________________________________________________________________________

ErrorShortDisUp:
    neg eax | sub eax 127
    If eax > 1
        Mov ebx {B$ 'Bytes Up' EOS}
    Else
        Mov ebx {B$ 'Byte Up' EOS}
    End_If

    jmp L1>

ErrorShortDisDown:
    sub eax 080
    If eax > 1
        Mov ebx {B$ 'Bytes Down' EOS}
    Else
        Mov ebx {B$ 'Byte Down' EOS}
    End_If

L1: ;error D$ShortDisPtr

    CustomError D$ShortDisPtr,
                '#1',
                'Int',
                 eax,
                 '#2',
                 'Str',
                 ebx

    Mov B$ErrorLevel 2 | error STR.A.Trash

    ;Mov ebx eax | Mov B$ErrorLevel 12 | error D$ShortDisPtr

[ApplyShortenJump: D$ ?]

FillCodeSymbols:
    Mov eax D$CodeRef | add eax 5
    On D$CodeRefPtr = eax,  ret                 ; if no symbol at all (???!!!)
    Mov edx D$LabelList | Mov esi edx | lodsd   ; len of LabelList (-1) > EAX > EDX
    add edx eax | dec edx                       ; last octet of LabelList table (edx=edi max)
    Mov ebx D$CodeRef | Mov esi ebx | lodsd     ; len of CodeRef (-1) > EAX > EBX
    add ebx eax | dec ebx                       ; last octet of CodeRef table (ebx=esi max)
    Mov esi D$CodeRef | add esi 5               ; (+5) > jmp over len and '|'

L0: Mov edi D$LabelList | add edi 5

    Mov B$ApplyShortenJump &FALSE
;;
 For Api calls relocations, the 'EncodeLines' does it directely (> 'NewSearchApiName'): 
 The 'CodeRef' Record for such cases is simply:
 |0FF dWordCodeAddress|. This is done by 'NewSearchApiName' only in case of:
 > If D$SavingExtension = '.DLL'
 Again, The record is irregular: 0FF, 1 dWord, EOI, as there is nothing else to be done
 with this, out of the DLL relocations building:
;;
    If B$esi = 0FF
        Call StoreApiReloc | cmp esi ebx | jb L0<
        ret
    End_If

    Push esi
      Mov ecx 0
L1:   lodsb
        inc ecx                                 ; simple lenght counter of Code symbolics'
        cmp al EOI | ja L1<                     ; lenghts, in CodeRef, including separator
        lodsd | lodsd | Mov D$StatementsCounter eax
    Pop esi                       ; when encoding 'Relative' is either 0 or high bit flag
    Mov D$Relative &FALSE                        ; now on, either true or false
      Mov ah B$esi,  al B$esi+1
      cmp ah 'A' | jb S9>>
        cmp ah 'Z' | ja S9>>
          cmp al '0' | jb S9>>
            cmp al '9' | ja S9>>                 ; is it a local label evocation?

            .If B$esi+2 = '>'
                Mov D$Relative &TRUE
                If B$esi+3 = '>'
                    Mov B$LongRelative &TRUE
                Else_If B$esi+3 = '.'
                    Mov B$LongRelative &TRUE | Mov B$esi+3 '>'
                    Mov B$ApplyShortenJump &TRUE
                Else_If B$esi+3 < Separators
                    Mov B$LongRelative &FALSE
                Else
                    Error D$WhatIsThisPtr
                End_If

                Mov B$esi+2 EOI | Mov ecx 3 | Call SearchLocalLabelDown

            .Else_If B$esi+2 = '<'
                Mov D$Relative &TRUE
                If B$esi+3 = '<'
                    Mov B$LongRelative &TRUE
                Else_If B$esi+3 = '.'
                    Mov B$LongRelative &TRUE | Mov B$esi+3 '<'
                    Mov B$ApplyShortenJump &TRUE
                Else_If B$esi+3 < Separators
                    Mov B$LongRelative &FALSE
                Else
                    Error D$WhatIsThisPtr
                End_If

                Mov B$esi+2 EOI | Mov ecx 3 | Call SearchLocalLabelUp

            .Else
S9:             Push edx
                    Call SearchSortedRegularLabel
                Pop edx

            .End_If
;;
  got here after label search up, down or regular (and found)
  edi points to a LabelList'symbol adress (code or data true adress of label)
  esi points to a Coderef evocation adress (code ... adress needing 'fill job')
  'add esi 9', 4 lines down here set this ptr on Coderef next label name (2 dWords + EOI)
;;
    Mov eax D$edi                              ; true label adress in eax (EDI > LabelList)

    On B$ApplyShortenJump = &TRUE, Mov B$LongRelative &FALSE

  ; write 'done' on LabelList flag byte:
    Mov cl B$edi+4 | or B$edi+4 FLAG_DONE
    Mov edi D$esi | add esi 9
  ; ESI > CodeRef offset of evocation > EDI

    ...If D$Relative = &TRUE
      ; no flag > uncomputed label adress: Strip flag (computed signed displacement);
        and edi 07FFFFFFF | sub eax edi
      ; no signed displacement?
        .If B$LongRelative = &FALSE
            test eax DWORD_HIGH_BIT ZERO L6>
          ; -127 (0FFFF_FF80 = -128) ; short negative value:
          ; -128 (-1) (limit for signed negative byte)
            On eax < 0FFFF_FF81,  jmp ErrorShortDisUp
                jmp L7>

L6:         On eax > 080, jmp ErrorShortDisDown    ; short positive value > 07F + 1
                                                    ; +127 (limit for signed positive byte)
L7:         sub eax 1 | add B$edi al | cmp esi ebx | jb L0<<     ; store on one byte
            ret

        .Else
            On B$ProfilerFlag = &TRUE, Call TimingCalls

L8:         sub eax 4 | add D$edi eax | cmp esi ebx | jb L0<<       ; store on 4 bytes
            ret      ; why ADD and not Mov: exemple: 'ADC ebx MyLabel+2' > '2' previously stored
                ; 'sub ax, 4'  is to jump over storage bytes (L7: idem for one byte storage)
        .End_If
    ...End_If

L9: If D$FL.RelocsWanted = &TRUE ;SavingExtension = '.DLL' ; jE!
        Call StoreReloc
    Else_If D$SavingExtension = '.SYS'
        Call StoreReloc
    End_If

    If cl < FLAG_CODE_LABEL
        add eax D$DataAjust         ; 2 >>> data / 3 >>> data+done
    Else
        add eax D$CodeAjust         ; 4 >>> code / 5 >>> code+done
    End_If

    add D$edi eax                                   ; store on 4 bytes (uncomputed)
    cmp esi ebx | jb L0<<
ret

 ________________________________________________________________________________________
;
; Filling empty rooms left in Data section (same comments as upper ones)
 ________________________________________________________________________________________

FillDataSymbols:
    Mov eax D$DataRef | add eax 5
    On D$DataRefPtr = eax,  ret                 ; if no symbol at all
   ; Mov edx D$PlainLabelList | Mov esi edx | lodsd   ; len of LabelList (-1) > EAX > EDX

   ; add edx eax | dec edx                       ; last octet of LabelList table (edx=edi max)
    Mov ebx D$DataRef | Mov esi ebx | lodsd     ; len of DataRef (-1) > EAX > EBX
    add ebx eax | dec ebx                       ; last octet of DataRef table (ebx=esi max)
    Mov esi D$DataRef | add esi 5               ; (+5) > jmp over len and '|'

L0: ;Mov edi D$PlainLabelList | add edi 5
    Push esi
        Mov ecx 0
L1:     lodsb
            inc ecx                                 ; simple lenght counter of Code symbolics'
            cmp al EOI | ja L1<                     ; lenghts, in DataRef, including separator
            lodsd | Mov D$DataFillPtr eax           ; doublon de DataListPtr
            lodsd | Mov D$bracketCounter eax
            lodsb | Mov B$DataSign al
            lodsb | Mov D$DataRefPtr esi            ; strip lasting EOI
    Pop esi

    Call SearchSortedRegularLabel | Mov eax D$edi | Mov cl B$edi+4

    cmp cl FLAG_CODE_LABEL | jb D1>               ; 'jb' because:
        add eax D$CodeAjust | jmp D2>                 ; 2 > data / 3 > data+done
D1:     add eax D$DataAjust                           ; 4 > code / 5 > code+done
D2:     or B$edi+4 FLAG_DONE

D2: On B$DataSign = &TRUE, neg eax | Mov edi D$DataFillPtr | add D$edi eax

    If D$FL.RelocsWanted = &TRUE ;SavingExtension = '.DLL' ;jE!
        Call StoreReloc
    Else_If D$SavingExtension = '.SYS'
        Call StoreReloc
    End_If

    Mov esi D$DataRefPtr | cmp esi ebx | jb L0<<
  ret


[DataFillPtr: D$ ?
 DataAjust: D$ ?
 CodeAjust: D$ ?]

Proc SetCodeAdjust:
    Argument @Base

        Mov eax D@Base | add eax D$uBaseOfData | sub eax D$Datalist
        Mov D$DataAjust eax
        Mov eax D@Base | add eax D$uBaseOfCode | sub eax D$Codelist
        sub eax D$uStartOfCode | Mov D$CodeAjust eax
EndP


InitRelocationForData:
    Push edi eax

        If D$SavingExtension = '.SYS'
            Call SetCodeAdjust DRIVERDEFAULT
        Else_If D$SavingExtension = '.DLL'
            Call SetCodeAdjust D$LinkerDllDefault
        Else
            Call SetCodeAdjust LINKERDEFAULT
        End_If

        Mov edi D$RelocationPtr

        Mov eax D$uBaseOfImport | add eax D$ImportTrueSize | AlignOn 01000 eax

        If B$NoResources = &FALSE
            add eax D$uRsrcSize | AlignOn 01000 eax
        End_If

        Mov D$RelocPage eax | stosd

        Mov eax 0 | stosd
        Mov D$RelocationPtr edi | Mov D$RelocSectionSize 8

    Pop eax edi
ret


InitRelocationForCode:
    Push edi eax
        Mov edi D$RelocationPtr

        Mov eax D$uBaseOfImport | add eax D$ImportTrueSize | AlignOn 01000 eax

        If B$NoResources = &FALSE
            add eax D$uRsrcSize | AlignOn 01000 eax
        End_If

        ;add eax D$uDataSize | AlignOn 01000 eax
        Mov eax D$uBaseOfCode
        Mov D$RelocPage eax | stosd

        Mov eax 0 | stosd
        Mov D$RelocationPtr edi | Mov D$RelocSectionSize 8
    Pop eax edi
ret


CloseRelocation:
    Mov eax 0 | Mov edi D$RelocationPtr

L1: test D$RelocationPtr 0011 ZERO L2>              ; align on Dword boudary
        stosb                                       ; fill with zeros
        inc D$RelocationPtr | inc D$RelocSectionSize
        jmp L1<

L2: Mov ebx D$RelocationPtr | sub ebx D$RelocSectionSize | add ebx, 4
    Mov eax D$RelocSectionSize | Mov D$ebx eax      ; set second dword to section size
ret

@RelocComments:
;;
 Relocation Section looks like this, for example:

 D$ 02000  ; RVA (Liker Default is to be added to this by the Loader).
 D$ 034    ; Aligned number of Bytes in the coming Chunk (including upper 8 Bytes+Alignement)
 W$ 03004 03010 03058 ....
 ; the chunk is aligned on dWord with zero padding if needed.
 D$ 03000  ; Next chunk header
 ....

 Even the last Chunk must be aligned and the number of bytes in this last Chunk Header
 holds it too.
;;

BuildRelocationAndFillSymbols:                      ; >>> StoreReloc <<<
    Call InitRelocationForData
        Mov B$ErrorLevel 3
        Move D$CodeOrData D$DataList
        Call BuildPlainLabelList

      ; Left for viewing the List of Labels, the Debugger, ...
       Call SortPlainLabelList

       Call FillDataSymbols

        Call CloseRelocation
        If D$RelocSectionSize = 8                   ; Case of no relocation
            sub D$RelocationPtr 8                   ; wanted in Data
        End_If

    Call InitRelocationForCode
        Mov B$ErrorLevel 2
        Mov D$LastDownSearchLabel 0, D$LastUpSearchLabel 0
        Move D$CodeOrData D$DataList
        Mov eax D$uDataSize | AlignOn 0200 eax | add D$CodeOrData eax

        Call FillCodeSymbols

        Call CloseRelocation
        If D$RelocSectionSize = 8                   ; Case of no relocation
            sub D$RelocationPtr 8                   ; wanted in CODE jE!
        Mov eax D$RelocationPtr | and D$eax 0 | and D$eax+4 0 ;kill unused
        End_If

        Mov eax D$RelocationPtr | sub eax D$Relocation
        ; Case of no relocation at ALL, make MINIMUM-RELOC
        If eax = 0
           Mov eax D$Relocation | Mov D$eax 0 | Mov D$eax+4 08
           add D$RelocationPtr 8
        End_If
  ; Reuse 'RelocSectionSize' to hold what it says, as a whole for headers values:
    Mov eax D$RelocationPtr | sub eax D$Relocation | Mov D$RelocSectionSize eax
    AlignOn 0200 eax | Mov D$FileAlignedRelocationSize eax
ret


SortPlainLabelList:
    Mov eax D$PlainLabelList, eax D$eax

    Push eax

        add eax 4

        Call VirtualAlloc SortTempoMemory,
                          eax

    Pop ecx
    Push ecx
        Mov edi D$SortTempoMemory, esi D$PlainLabelList
        shr ecx 2 | inc ecx | rep movsd

        Move D$SortSource D$SortTempoMemory | add D$SortSource 5
        Move D$SortDestination D$PlainLabelList | add D$SortDestination 5

        Mov D$SortStringNumber 0 | Mov esi D$SortDestination

L0:     lodsb | cmp al EOI | jne L0<
        add esi 6
        inc D$SortStringNumber
        cmp esi D$EndOfPlainLabelList | jb L0<

    Pop ecx

    Call SortLabelStringsBySize

    Call VirtualFree SortTempoMemory

L9: ret


SortLabelStringsBySize:
    Mov edi LabelsPointersBySizes, eax 0, ecx 100 | rep stosd

    Mov edi D$SortDestination, edx 1

L0: Mov esi D$SortSource, ecx D$SortStringNumber, B$SortBySizeOver &TRUE

; There is something wrong in this: If i state 'While B$esi <> EOI' instead of
; 'While B$esi > EOI', it doesn't work. It should, and there is no reason for what
; D$esi could be = 0 (this is to say after the end of the Table -i suppose...)...

L1:     lodsb
        .If al = 0FF        ; Done
            While B$esi > EOI | inc esi | End_While
            add esi 7

        .Else
            Push ecx
                Mov eax esi, ecx 1
                While B$eax > EOI | inc ecx | inc eax | End_While
                If ecx = edx
                    Mov al B$esi-1, B$esi-1 0FF
                    On D$LabelsPointersBySizes+edx*4 = 0,
                        Mov D$LabelsPointersBySizes+edx*4 edi
                    stosb
                    dec ecx | jecxz L2>
                        rep movsb
L2:                 movsb  ; |
                    movsd  ; Ptr
                    movsb  ; Flag
                    movsb  ; |

                Else
                    lea esi D$eax+7
                End_If

            Pop ecx
            Mov B$SortBySizeOver &FALSE
        .End_If
    loop L1<

    inc edx | cmp B$SortBySizeOver &FALSE | je L0<<
ret

;;
 When searching Labels for filling Data Sybols, we do not need Meaningless Local
 Labels. So, we can build a List without them to make FillDataSymbols faster (No
 use sorting the list, as all Label are supposed to be found. If not error later):
 The 'PlainLabelList' Table is: ...|Name|Ptr Flag|Name....
                                        ...... .  ..
                                        1 4   1  1
;;

[PlainLabelList: D$ ?
 EndOfPlainLabelList: D$ ?]

BuildPlainLabelList:
    Mov eax D$LabelList, eax D$eax | inc eax

    Call VirtualAlloc PlainLabelList,
                      eax

    Mov edx D$LabelList | add edx D$edx
    Mov edi D$PlainLabelList | add edi 5
    Mov esi D$LabelList | add esi 5

    .While esi < edx
        cmp B$esi+2 EOI | jne L1>
            cmp B$esi 'A' | jb L1>
            cmp B$esi 'Z' | ja L1>
                cmp B$esi+1 '0' | jb L1>
                cmp B$esi+1 '9' | ja L1>
                    ; |L0|dWord Byte| >>> 9
                    add esi 9 | jmp L2>

L1:     While B$esi <> EOI
            movsb
        End_While
        movsb   ; |
        movsd   ; Ptr
        movsb   ; Flag
        movsb   ; |
L2: .End_While

    Mov eax edi | Mov D$EndOfPlainLabelList eax | sub eax D$PlainLabelList
    Mov edi D$PlainLabelList | stosd | Mov al EOI | stosb
ret

 _______________________________________________________________________________________


FixTableSizes:
    Mov eax D$CodeListPtr | AlignOn 0200 eax
    Mov edi D$CodeList | sub eax edi | Mov D$LenOfCode eax

    Mov eax D$CodeRefPtr   | Mov edi D$CodeRef  | sub eax edi  | stosd

    Mov eax D$DataRefPtr   | Mov edi D$DataRef  | sub eax edi  | stosd

   ; Mov eax D$DataListPtr  | Mov edi D$DataList  | sub eax edi | stosd ; no need ???...
    Mov eax D$LabelListPtr | Mov edi D$LabelList | sub eax edi | stosd

    Mov eax D$StartOfCodeSection | add eax D$LenOfCode
    and eax 0FFFFFF00
    add eax 01000 | add eax 0400000
    Mov D$StartOfDataSection eax
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  The Symbolic Names are encoded into a qWord CheckSum. Then, this qWord is encoded
  into one another Word CheckSum. Let's Call them 'CheckSum64' and 'CheckSum16'.
  __________________
  A two Stages Table is declared to hold 010000h (for storing the distributions
  of the Records) plus 010000h Records (for storing the Linked Records in case
  of identical CheckSum16).
  
  The CheckSum16 is used as a Index to point to the Records of the first stage
  of the Table.
  
  _______________
  Each Record is: [CheckSum64, Pointer, LinkedPointer]

  * 'Pointer' points to a Name, in one of the Assembler internal Lists. It is
    nothing but the Pointer transmitted to the 'SetQwordCheckSum' Procedure,
    when called. We do not need to do do any Name String Copy, as it is already
    there, in the concerned List ('LabelList', 'MacroList', 'EquateList').
    
  * If the second half of the Records Table is empty, 'LinkedPointer' points to
    the top of this Second half Table. Otherwise, in case several 'CheckSum64'
    achieve into the same 'CheckSum16', 'LinkedPointer' points to the next same
    'CheckSum16' Record, in the second half of the Table... and so on...
    
  * The first half of the Table is filled 'randomaly-like' (depending on the
    CheckSum16 value. The second half of the Table is filled in order (Top-Down),
    each time a Record of the First Half Table is found to not be empty.
    
  _________
  Routines:
  
  * 'ClearQwordCheckSum' zeroes the Records Table and sets
    'PointerToCheckSumsLinkedRecords' to the Top of the second half Table.
  
  * 'SetQwordCheckSum' is called with a Parameter pointing to the first Char
    of a Name - in its family List - to be recorded. It also Call for:
    
  * 'NoDuplication' to make sure of unique Symbolics Declarations.
  
  * 'GetFromQwordCheckSum' is called with a Parameter pointing to a Name to
     be checked. If found, the Procedure returns the Pointers that was used
     when calling 'SetQwordCheckSum', that are nothing but Pointers to the
     Lists ('MacroList', 'EquateList', 'LabelList'), that hold all infos the
     Assembler needs for doing its job. If not found, it returns zero to the
     caller.
     
  * 'TestRepartition', is just a Dev-test for viewing how all of this goes.
  
  ______________________________
  How the Records Table is used:
  
  When calling 'SetQwordCheckSum', the CheckSum64 is computed from the given
  Name. Then, the CheckSum16 is computed from the given CheckSum64.
  
  CheckSum16 is used as an Indice to the first half of the Records Table.
  For example, if CheckSum16 is 25, we point to the 25th Record, that is
  (CheckSumsRecords + (25*(8+4+4))).
  
  If this record is found empty, it is written: CheckSum64 / Pointer / Link
  
  As long as there is nothing in the second half of the Table, 'Link' points
  to the empty Record at (CheckSumsRecords + (010000h*16) ).
  
  If the first half Table is not found empty, the 'Link' Pointer is read,
  and we jump there,... and so on...
  
  The chances for having two different Symbols achieving into the same CheckSum64
  are, of course, of 1 on 01_0000_0000_0000_0000h, for the second Name, of 1 on
  01_0000_0000_0000_0000h, for the third name, and so on... So, in the very unlikely
  coming out cases when two different Names are computed into the same CheckSum64,
  the new record is linked downward, the same way the Duplications of the CheckSum16
  are Linked.
  
  The reverse case is also theorically possible: For example, you do _not_ implement,
  say, some 'GetPointer' Macro, and you use it in a Statement. It is theorically
  not impossible that some other _declared_ Macro achieves into the same CheckSum64
  as would your non existing 'GetPointer'. In such -very unlikely coming out cases-,
  the 'GetFromQwordCheckSum' would return a pointer, instead of zero. So, when a
  valid CheckSum64 is found, 'GetFromQwordCheckSum' also calls for 'CompareSymbols',
  to make it 100% secure.
;;
____________________________________________________________________________________________

; CheckSum64 / Pointer / Link

[CheckSumsRecords: D$ ? ? ? ? # 010000
 CheckSumsLinkedRecords: D$ ? ? ? ? # 020000
 PointerToCheckSumsLinkedRecords: D$ ?
 CheckSumsEnd:]

ClearQwordCheckSum:
    Mov edi CheckSumsRecords, eax 0
    Mov ecx CheckSumsEnd | sub ecx CheckSumsRecords | shr ecx 2
    rep stosd

    Mov D$PointerToCheckSumsLinkedRecords CheckSumsLinkedRecords
ret

[CheckSumImage: D$ ?]

SaveCheckSumTable:
    pushad
        Mov ecx PointerToCheckSumsLinkedRecords | sub ecx CheckSumsRecords

        Call VirtualAlloc CheckSumImage,
                          ecx

        shr ecx 2

        Mov esi CheckSumsRecords, edi D$CheckSumImage | rep movsd
    popad
ret

RestoreCheckSumTable:

    pushad

        Mov ecx PointerToCheckSumsLinkedRecords | sub ecx CheckSumsRecords | shr ecx 2

        Mov esi D$CheckSumImage, edi CheckSumsRecords | rep movsd


        Call VirtualFree CheckSumImage

    popad

ret

____________________________________________________________________________________________

CheckSum64:
  ; esi -> Name
    Mov eax 0, ebx 0, ecx 0

    While B$esi > SPC ;LowSigns
        rol eax 1 | lodsb | mul eax | xor ebx edx | inc ecx
    End_While
    add ebx ecx
    If eax = 0
        On ebx = 0, Mov eax 1
    End_If
  ; ebx:eax = CheckSum64 // ecx = Length
ret


CheckSum16:
  ; ebx:eax = CheckSum64 (not modified here))
    Mov ecx eax | xor ecx ebx | Mov edx ecx
    rol edx 16 | xor cx dx
    and ecx 0FFFF | shl ecx 4
  ; ecx = CheckSum16, to be used as a Displacement to the matching Record
  ; (To 'CheckSumsRecords' first half part, 16 Bytes per Record)
ret
____________________________________________________________________________________________

Proc SetQwordCheckSum:
    Argument @Pointer

    pushad

        Mov esi D@Pointer

        If B$esi < '0'
            ;
        Else_If B$esi <= '9'
            error D$NumerAsSymbolPtr, D@Pointer
        End_If

        Call CheckSum64 | Call NoDuplication D@Pointer | Call CheckSum16

      ; The List Pointer is used to test empty Records (Lists Pointers can never be zero):
        .If D$CheckSumsRecords+ecx = 0
            On D$CheckSumsRecords+ecx+4 <> 0, jmp L1>
            Mov D$CheckSumsRecords+ecx eax
            Mov D$CheckSumsRecords+ecx+4 ebx
            Move D$CheckSumsRecords+ecx+8 D@Pointer
          ; D$CheckSumsRecords+ecx+12 = 0
        .Else
L1:         If D$CheckSumsRecords+ecx+12 = 0
                Move D$CheckSumsRecords+ecx+12 D$PointerToCheckSumsLinkedRecords
            Else
                Mov edi D$CheckSumsRecords+ecx+12
                While D$edi+12 <> 0 | Mov edi D$edi+12 | End_While
                Move D$edi+12 D$PointerToCheckSumsLinkedRecords
            End_If

            Mov edi D$PointerToCheckSumsLinkedRecords
            Mov D$edi eax
            Mov D$edi+4 ebx
            Move D$edi+8 D@Pointer
            ;Mov eax D$PointerToCheckSumsLinkedRecords | add eax 16
          ; D$edi+12 = 0
            ;Mov D$PointerToCheckSumsLinkedRecords eax
            add D$PointerToCheckSumsLinkedRecords 16
        .End_If

    popad
EndP
____________________________________________________________________________________________

Proc GetFromQwordCheckSum:
    Argument @Pointer, @List, @Limit
    Uses esi, edi, ebx, ecx, edx

        Mov esi D@Pointer

        Call CheckSum64 | Call CheckSum16

        lea esi D$CheckSumsRecords+ecx | Mov ecx &TRUE

L0:     ..If D$esi = eax
            .If D$esi+4 = ebx
                Mov eax D$esi+8
                Mov ebx D@List | On eax < ebx, Mov ecx &FALSE
                Mov ebx D@Limit | On eax > ebx, Mov ecx &FALSE

                On ecx = &TRUE, Call CompareSymbols D@Pointer, eax

                If ecx = &FALSE
                    Push esi
                        Mov esi D@Pointer | Call CheckSum64
                    Pop esi

                    Mov ecx &TRUE | jmp L2>
                End_If

            .Else
                jmp L2>

            .End_If

        ..Else
L2:
            ;inc D$EquatesPasses
            Mov esi D$esi+12 | cmp esi 0 | je L3>

          ; If no List Pointer, this is the first empty Record in the Linked Record Table:
            Mov ecx &TRUE | cmp D$esi+8 0 | ja L0<<

L3:         Mov eax 0

        ..End_If
   ; hexprint D$EquatesPasses
EndP
____________________________________________________________________________________________



Proc NoDuplication:
    Argument @Pointer
    Uses eax, ebx, ecx

      ; ebx:eax = CheckSum64
        Mov ecx eax | xor ecx ebx | Mov edx ecx
        rol edx 16 | xor cx dx
        and ecx 0FFFF | shl ecx 4

        lea esi D$CheckSumsRecords+ecx

L0:     While D$esi+4 <> 0
            If D$esi = eax
                On D$esi+4 = ebx, Call CompareSymbols D@Pointer, D$esi+8
                On ecx = &TRUE, error D$SymbolDupPtr
            End_If

            Mov esi D$esi+12 | On esi = 0, ExitP

        End_While
EndP
____________________________________________________________________________________________

Proc CompareSymbols:
    Argument @Source, @Destination
    Uses eax, esi, edi

        Mov esi D@Source, edi D@Destination

L0:     lodsb | cmp al LowSigns | jb L5>
        inc edi | cmp al B$edi-1 | je L0<

        Mov ecx &FALSE | ExitP

L5:     If B$edi < LowSigns
            Mov ecx &TRUE
        Else
            Mov ecx &FALSE
        End_If
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  This test is for viewing the Records distribution, in the CheckSums Table.
  
  The first Pixels square shows the occupied Records in the first half Part of
  the Table (black Pixels). The occupied Records, in the second half of the
  Table are represented by red Pixels. They, of course, come in the form of
  a red _line_.
  
  The actual distribution seems to be pretty close to a good random one.
;;

[CheckSumsPixelsCount: D$ ?
 CheckSumsLinkedRecordsPixels: D$ ?]

TestRepartition:
    Mov D$CheckSumsPixelsCount 0, D$CheckSumsLinkedRecordsPixels 0

    Call 'USER32.BeginPaint' D$H.EditWindow, PAINTSTRUCT | Mov D$STRUCT.EditData@HDC eax
    Call 'USER32.GetClientRect' D$H.EditWindow, RECT

    Mov esi CheckSumsRecords

L0: Mov eax D$esi | or eax D$esi+4
    If eax <> 0
        Mov eax esi | sub eax CheckSumsRecords | shr eax 4
        Mov ebx eax | shr eax 8 | and ebx 0FF
        inc D$CheckSumsPixelsCount
        Call 'GDI32.SetPixel' D$STRUCT.EditData@HDC, eax, ebx, 0
    End_If

    add esi 16 | cmp esi CheckSumsLinkedRecords | jb L0<

L0: Mov eax D$esi | or eax D$esi+4
    If eax <> 0
        Mov eax esi | sub eax CheckSumsLinkedRecords | shr eax 4
        Mov ebx eax | shr eax 8 | and ebx 0FF | add eax 0100
        inc D$CheckSumsPixelsCount
        inc D$CheckSumsLinkedRecordsPixels
        Call 'GDI32.SetPixel' D$STRUCT.EditData@HDC, ebx, eax, 0FF
    End_If

    add esi 16 | cmp esi PointerToCheckSumsLinkedRecords | jb L0<

    Call 'USER32.ReleaseDC' D$H.EditWindow, D$STRUCT.EditData@HDC
    Call 'USER32.EndPaint' D$H.EditWindow, PAINTSTRUCT

    If D$CheckSumsPixelsCount > 0

        ; Wait for user action
L0:     Call 'USER32.PeekMessageA' STRUC.MSG,
                                   D$H.MainWindow,
                                   &WM_KEYDOWN,
                                   &WM_RBUTTONUP,
                                   &PM_REMOVE

        cmp D$STRUC.MSG@message &WM_LBUTTONUP | je S0>

        cmp D$STRUC.MSG@message &WM_RBUTTONUP | je S0>

        cmp D$STRUC.MSG@message &WM_KEYDOWN | jne L0<

      ; Comment out to have the total number of Pixel and how many Linked Records:
      ; (On RosAsm, for V.1.24e: 64,536 // 313)

      ; Hexprint D$CheckSumsPixelsCount
      ; hexprint D$CheckSumsLinkedRecordsPixels

;;
  __________________________
  Results on RosAsm V.1.25d:
  
  Total = 019D9 = 6617
  Links =  0139 =  313

  Total of available Records in the Table first half = 010000 = 65536

  6617 / 65536 = 10.09 % of the Table is occupied by Records(+Linked Records)

  313 / 6617 = 4.73 % of the Records require a linkage
  
  In short: 5% of the Records are Linked when 10% of the table first half is occupied
;;

    Else
        Call 'USER32.MessageBoxA' D$H.MainWindow,
      {B$ "The Symoblics'CheckSums'Table can be viewed only after a Compilation." EOS},
      {B$ 'Nothing to show' EOS}, &MB_OK

    End_If
S0:
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
  Reuse of the CkeckSum64 Method for computing the Win32 Equates:
  
  The CheckSum64 Method is so fast, that it is now useless to save the computed
  Tables, 'Equates.nam' and 'Equates.num', like we did, before V.2.015c.
  
  So, each time RosAsm is started, it now loads the 'Equates.equ' File, and reuse
  the CheckSum64 Tables, to rebuild the search Table.
  
  The Records are used in different menner. Instead of "CheckSum64 / Pointer / Link",
  the 'CheckSumsRecords' for the Win32 Equates, are, "CheckSum64 / Value / Link",
  so that, - as the integrity is verified before usage of the Equates.equ File -,
  we can retrieve the Value immidiately from the CheckSum64 Table.
  
  Another difference is that the normal 'CheckSumsRecords' is Static, for the Symbols
  Jobs for the Assembler. We use it, as is, for building the Win32 Equates Table, but,
  once done, we copy this Table to a Dynamic Memory Chunk.
  
  'NewBuildWin32Equates':
  
      Build the Win32 Equates Table and saves it in 'NewWinEquatesMem'. This Routine
      includes two commented out calls to verify the conformity of the List:
    
      'VerifyEquatesFileConformity' and 'NoDuplicationOfEquates'
    
  'NewSearchForWinEquate' and 'NewGetEquates' are for retrieving the Value from
  an &EQUATE_NAME, from the Assembler ('ReplaceWin32Equates') and/or from 'RightClick'
  
  At Start-Up, you can see the Win32 Equates Table with
  [Tools] / [RosAsm Devs Tests] / [Show Symbols Repartition]
  
  Depending on the Processor, the speed improvement is between 1.5 and 5 %, compared
  to the previous Method, on an Auto-Compilation of RosAsm. For the Table built, it
  is many times faster (now, one second, on my old 95 Box with a generic Pentium, and
  the Click time on my Celeron 1.3).
;;
____________________________________________________________________________________________
____________________________________________________________________________________________


[NewWinEquatesMem: D$ ?
 dWordsLenOfEquatesList: D$ ?]

; Called from 'Main', each time RosAsm is started:

NewBuildWin32Equates: ; 'CheckSumsRecords' Call OpenEquFiles
    Call OpenEquFiles | On D$FL.Includes = &FALSE ret

    ;Call VerifyEquatesFileConformity

    Call CountEquates ; >>> 'NumberOfEquates'
    ;hexprint D$NumberOfEquates
    Push D$NumberOfEquates

        Mov esi D$EquateIncMemory

        Mov D$PointerToCheckSumsLinkedRecords CheckSumsLinkedRecords

L0:     Mov ebx esi | While B$ebx > SPC | inc ebx | End_While | Mov B$ebx 0

        Call CheckSum64 | Call CheckSum16
    ; ebx:eax = CheckSum64 // ecx = CheckSum16

    ; Get the Hexa Value into edx:
        Push eax
            inc esi  ; skip over the space
            Mov edx 0
L1:         shl edx 4 | Mov al B$esi | sub al '0' | On al > 9, sub al 7
            or dl al
            inc esi | cmp B$esi CR | ja L1<
            add esi 2
        Pop eax

        .If D$CheckSumsRecords+ecx = 0
            On D$CheckSumsRecords+ecx+4 <> 0, jmp L1>
            Mov D$CheckSumsRecords+ecx eax
            Mov D$CheckSumsRecords+ecx+4 ebx
            Move D$CheckSumsRecords+ecx+8 edx
        .Else
L1:         If D$CheckSumsRecords+ecx+12 = 0
                Move D$CheckSumsRecords+ecx+12 D$PointerToCheckSumsLinkedRecords
            Else
                Mov edi D$CheckSumsRecords+ecx+12
                While D$edi+12 <> 0
                    ;Call NoDuplicationOfEquates
                    Mov edi D$edi+12
                End_While
                ;Call NoDuplicationOfEquates
                Move D$edi+12 D$PointerToCheckSumsLinkedRecords
            End_If

            Mov edi D$PointerToCheckSumsLinkedRecords
            Mov D$edi eax
            Mov D$edi+4 ebx
            Move D$edi+8 edx
            add D$PointerToCheckSumsLinkedRecords 16
        .End_If

        dec D$NumberOfEquates | cmp D$NumberOfEquates 0 | jne L0<<

    Pop D$NumberOfEquates

  ; Now, store the Win32 Equates CheckSums Table into Memory:

    Mov ecx D$PointerToCheckSumsLinkedRecords | add ecx 010 | sub ecx CheckSumsRecords

    Call VirtualAlloc NewWinEquatesMem,
                      ecx

    Mov esi CheckSumsRecords, edi D$NewWinEquatesMem | shr ecx 2
    Mov D$dWordsLenOfEquatesList ecx | rep movsd
;;
  Adjust all of the Linked Records Pointer (above, they are pointing for a Base
  of 'CheckSumsRecords'. Now, the Base must be inside 'NewWinEquatesMem'
;;
  ; Adjustement Value:
    Mov eax CheckSumsRecords | sub eax D$NewWinEquatesMem

    Mov ebx CheckSumsRecords | sub ebx eax
  ; edi still points to the End of the fresh copied 'NewWinEquatesMem':
    While ebx < edi
        On D$ebx+12 <> 0, sub D$ebx+12 eax
        add ebx 16
    End_While

    ;Call ClearQwordCheckSum
ret
____________________________________________________________________________________________

[EquateFound: D$ ?]

NewSearchForWinEquate:
    Push esi
        Call NewGetEquates

        If B$EquateFound = &FALSE
            Mov esi STR.A.Trash | error D$BadWinEquPtr ; error8
        End_If

        or D$imm32 eax
    Pop esi

    add esi D$NewWinEquateLenght

    .If B$esi = addSign
        On B$esi+1 <> '&', ret
        add esi 2 | jmp NewSearchForWinEquate
    .Else_If B$esi = '&'
        inc esi | jmp NewSearchForWinEquate
    .Else
        While B$esi = '_'
            inc esi
        End_While
        If B$esi = '&'
            inc esi | jmp NewSearchForWinEquate
        End_If
    .End_If
ret


[NewWinEquateLenght: D$ ?]

; Called from the Assembler and from 'RightClick'

NewGetEquates: ;New GetEquates: RightClick
    Mov edi STR.A.Trash
    While B$esi > SPC
        Mov ax W$esi
        If al = '+'
            jmp L1>
        Else_If al = '-'
            jmp L1>
        Else_If ax = '__'
            jmp L1>
        Else_If al = ','
            jmp L1>
        Else_If al = ';'
            jmp L1>
        Else_If ax = '_&'
            jmp L1>
        Else_If al = '&'
            jmp L1>
        Else_If al = ']'
            jmp L1>
        Else_If al = ')'
            jmp L1>
        Else
            On al >= 'a', sub al 32
            Mov B$edi al | inc esi | inc edi
        End_If
    End_While

L1: Mov B$edi 0 | sub edi STR.A.Trash | Mov D$NewWinEquateLenght edi

  ; Simplified 'GetFromQwordCheckSum':
    Mov esi STR.A.Trash

ReadWin32Equate:
    Call CheckSum64 | Call CheckSum16

    Mov esi D$NewWinEquatesMem | add esi ecx

L0: .If D$esi = eax
        If D$esi+4 = ebx
            Mov eax D$esi+8, B$EquateFound &TRUE | ret
        End_If
    .End_If

    Mov esi D$esi+12 | cmp esi 0 | jne L0<

    Mov B$EquateFound &FALSE
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE EquateResolver  ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
    Nested Equate Resolver - Ludwig Haehne <wkx@gmx.li>
    
    Substitute nested equates by its values in the equate table to reduce compilation time
    and memory requirements.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

[EquateInflation: B$
"Buffer overrun because of equate inflation detected!

Put expressions inside your equates in brackets to
allow the parser to merge them.

e.g. write [B (A+4)] instead of [B A+4]" EOS]

[BackwardNesting: B$
"Maximum equate nesting level exceeded! 
Declare equates *before* you reuse them in other equates!" EOS]

[CyclicDependancy: B$ "Cyclic dependency detected!" EOS]


____________________________________________________________________________________________

; This proc resolves nested equates. It scans all equates texts for other nested equates
; and unfolds these into a new buffer. It uses a mixture of iteration and "fake recursion".
; It makes a linear scan of the equate list and replaces nested equates with its value. If
; a not yet scanned equate is found (e.g. [B A+1, A 1]), it saves the current scan position
; on the stack and proceeds with the nested equate.
; To reduce size and compilation time expressions (which contain '(..)') are merged finally.

; Possible Optimizations:
; * merge expressions without brackets e.g. EBP+4+4+...+4 -> EBP+020
; * faster execution path for plain number equates (no nesting, no operators)

; Buffer where the substituted equate contents are stored
[EquateSubstitutes: D$ ?
 EquateSubstitutesPtr: D$ ?
 EquateSubstitutesLimit: D$ ?]
; Remember in case of relocation
[LastEquateList: D$ ?
 LastEquateListPtr: D$ ?]

; The proc works in this way:
;
; For each equate e in E
;   For each token t in e
;     If IsEquate(t)
;       If IsResolved(t)
;         Substitute t
;       Else
;         Resolve(t)
;       End
;     End
;   Next
;   Merge(e)
; Next

ResolveEquates:

    [@ProcessedLimit:   D$ ? ; address of the last resolved equate (in the iteration !)
     @IsNested:         B$ ? ; equate contains nested equates and/or must be restored
     @NumBrackets:      B$ ? ; number of bracket levels in expression
     @UnpairedBrackets: B$ ? ; non-zero if brackets are unpaired
     @UnknownSymbols:   B$ ? ; number of unresolved symbols (regs, macro emitted equates)
     @ErrorText:        D$ ?]; points at the appropriate error text in case of resolving problems

    ;Call 'KERNEL32.OutputDebugStringA' {B$ 'ResolveEquates' EOS}

  ; Set exception handler
    Push @AbortCompilation
    Push @AVHandler
    Push D$fs:0
    Mov D$fs:0 esp

      ; If table was relocated through memory extension the pointers must be altered
        Mov eax D$LastEquateList, edx D$EquateList
        If eax <> edx
            sub D$LastEquateListPtr eax
            add D$LastEquateListPtr edx
            Mov D$LastEquateList edx
        End_If

        Mov esi D$LastEquateListPtr, edi D$EquateSubstitutesPtr

      ; Empty list marker
        Push 0
____________________________________________________________________________________________

@GetNextEquate: ; Search for next equate to process

      ; Continue with skipped equate (if any)
        On D$esp <> 0, Pop esi

      ; Already dealt with? > Skip
        While B$esi-1 = 04
            Mov B$esi-1 EOI
L0:         inc esi
            cmp B$esi LowSigns | ja L0<
            add esi 11
        EndWhile

        Mov D@ProcessedLimit esi

      ; Check for end of list (when we finish the todo-stack has to be empty)
        If D$esi = 02020202
            add esp 4 ; clear list marker
            Pop D$fs:0 | add esp 8; Clear exception handler

            Mov D$EquateSubstitutesPtr edi
            Move D$LastEquateListPtr D$EquateListPtr
            ret
        End_If
____________________________________________________________________________________________

@EvaluateEquate: ; We start here when a not-yet-processed equate was found

      ; Skip name.
        Mov ebx esi
        SkipName ebx

      ; ebx, esi > Address (D), Size (D), Flag (B)
      ; Scan the equate tokens, copy and unfold but only redirect the pointer
      ; when there were really nested equates.
        Push esi

            Mov D@IsNested 0

          ; esi > equate content,  ecx = size,  edx > substitute
            Mov esi D$ebx
            Mov ecx D$ebx+4
            Mov edx edi

          ; We MUST copy the expression or GetFromQwordCheckSum might fail
          ; when there's no separator between the equate strings.
          ; (e.g. "...SummerWinter...") The expression buffer is abused for this.
            If B$esi+ecx >= SPC
                Push ecx
                    Mov edi D$ExpressionA
                    rep movsb
                    Mov B$edi 0
                    Mov esi D$ExpressionA
                Pop ecx
                Mov edi edx
            End_If

          ; Copy contents and replace nested equates
            .While ecx > 0

L7:             While B$esi <= LowSigns
                    movsb
                    dec ecx | jz L5>>
                    cmp B$esi-1 TextSign | je L4>
                EndWhile

                Mov al B$esi

                cmp al '0' | jb L3> ; ?
                cmp al '9' | jbe L4>

L3:           ; The equate string contains a text token. Check if it is an equate
                Call GetFromQwordCheckSum esi, D$EquateList, D$EquateListLimit
                .If eax <> 0

                  ; Was equate already processed? Either it is among the equates resolved
                  ; by linear table processing (indicated by ProcessedLimit) or was tagged
                  ; as being (forward-)resolved with 04.
                    ..If eax >= D@ProcessedLimit
                        If B$eax-1 <> 04
                            Mov esi eax
                            Mov edi edx
                            Call @CheckCyclicDependency
                            jmp @EvaluateEquate ; leave esi on stack so we can later continue with this
                        End_If
                    ..End_If

                    Mov B@IsNested 1

                  ; Resolved equates contents can be copied.
                    SkipName eax
                    Push esi ecx
                        Mov esi D$eax
                        Mov ecx D$eax+4
                        rep movsb
                    Pop ecx esi

                  ; Skip name in the source buffer
                    While B$esi > LowSigns
                        inc esi
                        dec ecx | jz L5>
                    EndWhile
                .End_If

              ; Copy rest of the token
L4:             While B$esi > LowSigns
                    movsb
                    dec ecx | jz L5>
                EndWhile

            .EndWhile


          ; Finished unfold

L5:       ; Rescan equate contents, count brackets and unresolved symbols.
          ; This is done here to keep the unfold loop simple.
            Mov eax edx
            Push edx
                Mov eax 0
                While edx < edi
                    Mov al B$edx
                    If al = openSign
                        inc B@NumBrackets
                        inc B@UnpairedBrackets
                    Else_If al = closeSign
                        dec B@UnpairedBrackets
                    Else_If al > '9'
                        On ah < LowSigns,
                            inc B@UnknownSymbols
                    End_If
                    Mov ah al
                    inc edx
                EndWhile
            Pop edx

          ; Merge expressions if brackets were found and it is a valid statement
            cmp B@NumBrackets      0 | je L6>
            cmp B@UnpairedBrackets 0 | jne L6>
            cmp B@UnknownSymbols   0 | jne L6>

            Push ebx
                movzx ebx B@NumBrackets ; nr of bracket pairs
                ;Call OutputExp
                    Call @MergeEquate
                ;Call OutputExp
            Pop ebx
            Mov B@IsNested 1

L6:     Pop esi

      ; Mark list entry as forward-resolved so it can be skipped later in the linear
      ; processing of the equatelist (the temporary 04 tag is removed then).
        If D$esp <> 0
            Mov B$esi-1 04
        End_If

      ; If the equate contents have been altered (nested substituted, expression merged)
      ; redirect the content pointer, otherwise ignore the copied contents.
        If B@IsNested = 1
            Mov D$ebx edx ; redirect
            Mov ecx edi
            sub ecx edx
            Mov D$ebx+4 ecx
        Else
            Mov edi edx ; throw away copied substitute
        End_If

        Mov esi ebx
        add esi 10

    jmp @GetNextEquate
____________________________________________________________________________________________

@AbortCompilation: ; Declaration error, reset old SEH & abort
  ; Reset exception handler
    Mov eax D$fs:0
    Mov eax D$eax
    Mov D$fs:0 eax
  ; Abort
    Mov eax D@ErrorText
    Mov B$ErrorLevel 13 ; TODO assign meaningful error level
    jmp OutOnError
____________________________________________________________________________________________

; The exception handler deals with buffer overruns due to equate inflations which are most
; likely programming errors. Therefore the compilation is stopped.
; Another possible exception is a stack overflow when an outragous amount of nested equates
; must be resolved.

Proc @AVHandler:
    Arguments @ExceptionRecord, @Error, @ThreadContext

        Mov ecx D@ExceptionRecord     ; exception record
        test D$ecx+4 1 NOT_ZERO L8>      ; non-continueable exception

      ; Check which type of exception occurred:
      ; We catch access violations that tried to read/write beyond the limit of the
      ; equate substitutes buffer. All other AVs are not dealt with.
        If D$ecx = &EXCEPTION_ACCESS_VIOLATION
            Mov eax D$ecx+24
            Mov edx D$EquateSubstitutesLimit
            sub eax edx
            cmp eax 01000 | ja L8>
            Mov D@ErrorText EquateInflation
            ;Call 'USER32.MessageBoxA' D$H.MainWindow, EquateInflation, CompilationStopped, &MB_ICONEXCLAMATION

      ; Deal with stack overflows (I've never seen this happening here)
        Else_If D$ecx = &EXCEPTION_STACK_OVERFLOW
            Mov D@ErrorText BackwardNesting
            ;Call 'USER32.MessageBoxA' D$H.MainWindow, BackwardNesting, CompilationStopped, &MB_ICONEXCLAMATION

      ; Unhandled exceptions are forwarded to the OS
        Else
L8:         Mov eax 1 | jmp L9>
        End_If

      ; Set the instruction pointer to continue with the cleanup routine
        Mov ecx D@ThreadContext ; get context record in ecx
        Mov edx D@Error         ; get pointer to ERR structure
        Mov eax D$edx+8         ; get safe place given in ERR structure
        Mov D$ecx+0B8 eax       ; replace instruction pointer

        Mov eax 0

L9: Mov esp ebp
    Pop ebp
ret
____________________________________________________________________________________________

; Check if the referenced equate corresponds to an already listed equate in the
; nesting hierarchy.
; Return address is at [esp], therefore we scan from [esp+4] -> [esp+x]=0

@CheckCyclicDependency:
    Mov eax 1
    While D$esp+eax*4 <> 0
        cmp esi D$esp+eax*4 | je L0>
        inc eax
    EndWhile
ret
  ; highlight first equate in the cycle
L0: Mov edx D$esp+eax*4, edi edx
    Mov ecx 0-1, al EOI
    repne scasb
    Mov ebx 0-2 | sub ebx ecx
    Call InternSearch
    Mov D@ErrorText CyclicDependancy

jmp @AbortCompilation
____________________________________________________________________________________________

; Solve expressions inside an equate and replace with the compressed string.
; All registers must be preserved for the calling routine.
;   edx -> Start of expression
;   edi -> End of expression
;   ebx -> Number of bracket pairs '(...)'
;   (1+((2 shl 3)*0010011))
;   ^                      ^
;  edx     ebx=3          edi

@MergeEquate:
    Push eax ecx esi
        Push edx
            inc edx
            Mov D$StartOfSourceExpression edx
            Mov D$StartOfDestinationExpression edi
            Mov esi edi
            Call ComputeExpression
            Mov esi D$ExpressionA
            Mov ecx edi
            sub ecx esi
            dec ecx
        Pop edx

        Mov edi edx
        rep movsb

    Pop esi ecx eax
ret
____________________________________________________________________________________________

[SkipName
    S0: inc #1
        cmp B$#1 LowSigns | ja S0<
        inc #1]
____________________________________________________________________________________________


____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Rsrc            ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
____________________________________________________________________________________________
____________________________________________________________________________________________

       Resources with customized Types and Names and Languages support
       Version 1.0
____________________________________________________________________________________________
____________________________________________________________________________________________
 
 Author name: Diego Fraga
 
 Email: < diegfrag@yahoo.com >
 
 Started: September 2004
 
____________________________________________________________________________________________

;;

; CustomList > Type/Name/Lang/Pointer/Size

[CustomList: D$ ? # MAXRESOURCE]

[RsrcType: D$ ?
 RsrcTypeStringLen: D$ ?
 RsrcTypeString: B$ ? # 33]
[RsrcNameStringLen: D$ ?
 RsrcNameString: B$ ? # 33]

[AviTypeStrLen: D$ 4
 AviTypeStr: B$ 'AVI' EOS]

[WaveTypeStrLen: D$ 5
 WaveTypeStr: B$ 'WAVE' EOS]

ClearCustomList:
    Mov edi CustomList, eax 0, ecx MAXRESOURCE | rep stosd
ret

;;

[CustomList:
 CustomList.Type: D$ 0
 CustomList.Name: D$ 0
 CustomList.Lang: D$ 0
 CustomList.Pointer: D$ 0
 CustomList.Size: D$ 0]
;;

[CustomList.TypeDis 0
 CustomList.NameDis 4
 CustomList.LangDis 8
 CustomList.PointerDis 12
 CustomList.SizeDis 16]

[Size_Of_CustomList 20]

Proc ReadRosAsmResources:

    pushad
        Call ClearCustomList
        Mov D$RsrcType 0
        Call FillCustomListFromResourceTree D$UserPEStartOfResources, CustomList
        Call CopyStandarTypeResources
    popad

EndP

Proc FillCustomListFromResourceTree: ; 'ResourcesStub' For infos.
    Argument @Pointer, @Output
    Local @Array
    Uses esi, ebx, eax

    Mov esi D@Pointer, eax 0, edi D@Output

    Push esi
      ; add ImgResDir.NumberOfNamedEntries to ImgResDir.NumberOfIdEntries
      ; and copy the result to N:
        add esi ImgResDir.NumberOfNamedEntriesDis
        lodsw | Mov D@Array eax
        lodsw | add D@Array eax
    Pop esi

    ; esi and ebx now points to the IMAGE_RESOURCE_DIRECTORY_ENTRY.
    add esi Size_Of_IMAGE_RESOURCE_DIRECTORY
    add ebx Size_Of_IMAGE_RESOURCE_DIRECTORY

          ; We need to see if we have a Unicode String Name or a ID
L0:
            lodsd ; load the name ID to eax
            Mov D$RsrcTypeStringLen 0
            Mov edx eax

            Mov D$edi+CustomList.TypeDis edx
            If D$RsrcType = 0
                Mov D$RsrcType edx
            End_If

            add edi 4

            Test_If eax 08000_0000 ; If it is a named ID, load th resource strings
                Push esi, edi
                    Mov esi eax, edi RsrcTypeString, ebx RsrcTypeStringLen
                    Call LoadRsrcIDString
                Pop edi, esi

            Test_End

            ; Now, load the OffsetToData and save it´s value at eax
            lodsd

            .Test_If eax 08000_0000 ; If the high bit (0x80000000) is set this is a node
                xor eax 08000_0000 | add eax D$UserPEStartOfResources
                Call FillCustomListFromResourceTree eax edi

                .If D@Array > 1
                  ; let´s search from the rest of the array IMAGE_RESOURCE_DIRECTORY_ENTRY.
                  ; point to the previous good datatype
                    add edi 4
                    dec D@Array
                    If D$RsrcType <> 0
                        Move D$edi+CustomList.TypeDis D$RsrcType
                        add edi 4
                    Else
                        Move D$RsrcType D$esi
                        Move D$edi+CustomList.TypeDis D$RsrcType
                    End_If
                    jmp L0<<
                .Else_If D@Array = 1
                    Mov D$RsrcType 0
                .End_If

            .Test_Else ; If the high bit (0x80000000) is not set this is a leaf
                ; Get the size and address of the data
                add eax D$UserPEStartOfResources
                Mov esi eax
                lodsd | sub eax D$ResourcesRVA| add eax D$UserPEStartOfResources
                add edi 4
                Mov ecx D$esi
                Mov D$edi ecx ; copy it to CustomList.SizeDis
                pushad
                    Call ReadResource
                    Mov D$edi-4 eax ; copy the read address to CustomList.PointerDis
                popad
            .Test_End


EndP

____________________________________________________________________________________________
; Copy Standard Type resources from CustomList to each list (AviList, BitmapList,MenuList, etc)

[AviTypeDir: D$ ?
 WaveTypeDir: D$ ?]

Proc CopyStandarTypeResources:

    Mov esi CustomList, edi esi, D$AviTypeDir 0, D$WaveTypeDir 0
L1: cmp D$esi 0 | je l5>>
    lodsd
    Mov D$RsrcTypeStringLen 0
    test eax 08000_0000 ZERO L4>
    Push esi, edi
        Mov esi eax, edi RsrcTypeString, ebx RsrcTypeStringLen
        Call LoadRsrcIDString
    Pop edi, esi

    If D$AviTypeDir = 0
        Push esi, edi, ecx
            Mov esi AviTypeStr, edi RsrcTypeString, ecx D$AviTypeStrLen
            repe cmpsb
        Pop ecx, edi, esi
        je L2>
    End_If

    If D$WaveTypeDir = 0
        Push esi, edi, ecx
            Mov esi WaveTypeStr, edi RsrcTypeString, ecx D$WaveTypeStrLen
            repe cmpsb
        Pop ecx, edi, esi
        je L3>
    End_If

L4: add esi 16 | jmp L1<
L2: Mov D$AviTypeDir eax | jmp L4<
L3: Mov D$WaveTypeDir eax | jmp L4<
L5:

    Call FillResourceTypeList CustomList, AviList, AviListPtr, D$AviTypeDir, MAXAVI
    Call FillResourceTypeList CustomList, WaveList, WaveListPtr, D$WaveTypeDir, MAXWAVE
    Call FillResourceTypeList CustomList, CursorList, CursorListPtr, &RT_CURSOR, MAXCURSOR
    Call FillResourceTypeList CustomList, BitmapList, BitmapListPtr, &RT_BITMAP, MAXBITMAP
    Call FillResourceTypeList CustomList, MenuList, MenuListPtr, &RT_MENU, MAXMENU
    Call FillResourceTypeList CustomList, DialogList, DialogListPtr, &RT_DIALOG, MAXDIALOG
    Call FillResourceTypeList CustomList, StringsList, StringsListPtr, &RT_STRING, MAXSTRINGS
    Call FillResourceTypeList CustomList, RCdataList, RCdataListPtr, &RT_RCDATA, MAXRCDATA
    Call FillResourceTypeList CustomList, GroupCursorList, GroupCursorListPtr, &RT_GROUP_CURSOR, MAXCURSOR
    Call FillResourceTypeList CustomList, IconList, IconListPtr, &RT_ICON, MAXICON
    ; Erase the First Icon, Which is the Main One (elsewhere...)
    If D$IconList = 1

        Call VirtualFree IconList+4

        Mov esi IconList, edi esi, ecx MAXICON-3 | add esi 12 | rep movsd
        On D$IconListPtr > IconList, sub D$IconListPtr 12
    End_If
    Call FillResourceTypeList CustomList, GroupIconList, GroupIconListPtr, &RT_GROUP_ICON, MAXICON
    ; Erase the First GroupIcon, Which is the Main One (elsewhere...)
    If D$GroupIconList = 1

        Call VirtualFree GroupIconList+4

        Mov esi GroupIconList, edi esi, ecx MAXICON-3 | add esi 12 | rep movsd
        On D$GroupIconListPtr > GroupIconList, sub D$GroupIconListPtr 12
    End_If

____________________________________________________________________________________________
; Remove "standard" resources from CustomList:
    Mov esi CustomList, edi esi
L1: cmp D$esi 0 | je L5>>
    lodsd
    Mov D$RsrcTypeStringLen 0
    cmp eax 16 | jg L2>
    test eax 08000_0000 ZERO L3>

    cmp eax D$AviTypeDir | je L4>
    cmp eax D$WaveTypeDir | je L4>

L2: stosd | movsd | movsd | movsd | movsd | jmp L1<

L3: cmp eax &RT_FONTDIR | je L2<
    cmp eax &RT_FONT | je L2<
    cmp eax &RT_ACCELERATOR | je L2<
    cmp eax &RT_MESSAGETABLE | je L2<
    cmp eax 13 | je L2<
    cmp eax 15 | je L2<
    cmp eax &RT_VERSION | je L2<

L4: add esi 16 | jmp L1<<

L5: Mov eax 0, ecx 5 | rep stosd

EndP
____________________________________________________________________________________________

Proc FillResourceTypeList:
    Arguments @InputList, @OutputList, @OutputListPtr, @ResType, @MaxResource

    pushad
    ; Clear the output list
    xor eax eax
    Mov edi D@OutputList, ecx D@MaxResource | rep stosd

    Mov esi D@InputList, edi D@OutputList
    While D$esi <> 0
        Mov edx D@ResType
        If D$esi+CustomList.TypeDis = edx
            Move D$edi D$esi+CustomList.NameDis ; copy Name only
            Move D$edi+4 D$esi+CustomList.PointerDis ; copy Pointer only
            Move D$edi+8 D$esi+CustomList.SizeDis ; copy size only
            add edi 12
        End_If
        add esi Size_Of_CustomList
    End_While

    Mov edx D@OutputListPtr
    Mov D$edx edi

    popad

EndP

____________________________________________________________________________________________
LoadRsrcIDString:
; In esi: source Unicode string entry ptr
; In edi: destination ptr
; In ebx: dest String size ptr (including null)

    Push eax, ecx
        and esi 07ff_ffff | add esi D$UserPEStartOfResources
        Mov eax 0
        lodsw
        Mov ecx eax, D$ebx eax | inc D$ebx
L1:     cmp ecx 0 | je L2>
            lodsw | stosb
            dec ecx
        jmp L1<
L2: Mov eax &NULL | stosb
    Pop ecx, eax

ret

____________________________________________________________________________________________

[MissingResource: D$ ?]

ReadResource:
; In eax: ptr to resource to read
; In ecx: size of data
; Out eax: Pointer to loaded data

    Mov B$MissingResource &FALSE


    If eax < D$UserPeStart
        ;Mov B$MissingResource &TRUE | ret
        jmp DisFail
    Else_If eax > D$UserPeEnd
        ;Mov B$MissingResource &TRUE | ret
        jmp DisFail
    End_If

    Push esi, edi
      ; Allocate space for data+id's strings
        Push eax
            Push ebx, ecx

                add ecx D$RsrcTypeStringLen
                add ecx D$RsrcNameStringLen

                Call VirtualAlloc TempoMemPointer,
                                  ecx

            Pop ecx, ebx
        Pop esi

      ; Copy data
        Mov edi D$TempoMemPointer
        Push edi, ecx
            rep movsb
        Pop ecx, eax

      ; Copy strings
        Mov esi RsrcTypeString, ecx D$RsrcTypeStringLen | rep movsb
        Mov esi RsrcNameString, ecx D$RsrcNameStringLen | rep movsb
    Pop edi, esi

ret

____________________________________________________________________________________________

NewTemporaryFillRsrcList:
  ; All the resources lists are in format Name/Pointer/Size except:
  ; CustomList, wich is Type/Name/Lang/Pointer/Size
  ; Now, we will fill uRsrcList with format Type/Name/Lang/Pointer/Size
  ; and then will sort it.

    Mov edi uRsrcList, D$TypeByName 0

    Mov esi CustomList
    If D$esi > 0
        While D$esi > 0
        Mov ecx 5 | rep movsd
        End_While
    End_If

    Mov esi AviList
    If D$esi > 0
        While D$esi > 0
            Mov eax RT_AVI | stosd | movsd | Mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    Mov esi WaveList
    If D$esi > 0
        While D$esi > 0
            Mov eax RT_WAVE | stosd | movsd | Mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    Mov esi CursorList
    If D$esi > 0
        While D$esi > 0
            Mov eax &RT_CURSOR | stosd | movsd | Mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    Mov esi BitMapList
    If D$esi > 0
        While D$esi > 0
            Mov eax &RT_BITMAP | stosd | movsd | Mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

  ; Store default icon if user didn't edit any (or user defined if any):
    If B$NoMainIcon = &FALSE
        Mov eax &RT_ICON | stosd | Mov eax ID_Icon | stosd | Mov eax Language | stosd
        Mov eax uIcon | stosd | Mov eax uIconEnd | sub eax uIcon | stosd
    End_If

    Mov esi IconList
    If D$esi > 0
        While D$esi > 0
            Mov eax &RT_ICON | stosd | movsd | Mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    Mov esi MenuList
    If D$esi > 0
        While D$esi > 0
            Mov eax &RT_MENU | stosd | movsd | Mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    Mov esi DialogList
    If D$esi > 0
        While D$esi > 0
            Mov eax &RT_DIALOG | stosd | movsd | Mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    Mov esi StringsList
    If D$esi > 0
        While D$esi > 0
            Mov eax &RT_STRING | stosd | movsd | Mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    Mov esi RcDataList
    If D$esi > 0
        While D$esi > 0
            Mov eax &RT_RCDATA | stosd | movsd | Mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    Mov esi GroupCursorList
    If D$esi > 0
        While D$esi > 0
            Mov eax &RT_GROUP_CURSOR | stosd | movsd | Mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    If B$NoMainIcon = &FALSE
        Mov eax &RT_GROUP_ICON | stosd | Mov eax ID_Group_Icon | stosd
        Mov eax Language | stosd
        Mov eax uGroupIcon | stosd
        Mov eax uGroupIconEnd | sub eax uGroupIcon | stosd
    End_If

    Mov esi GroupIconList
    If D$esi > 0
        While D$esi > 0
            Mov eax &RT_GROUP_ICON | stosd | movsd | Mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

  ; Close this List, because, in case user would have deleted some Resources, there
  ; could be old Records here, from a previous [Compile]:
    Mov eax 0, ecx 5 | rep stosd | sub edi (5*4)

  ; -4 > ready for backward read
    sub edi 4 | Mov D$uRsrcListPtr edi
____________________________________________________________________________________________
; Sort uRsrcList Table by Type, then by name and then by lang:
    Mov esi uRsrcList
    Push edi, esi

; First, sort by Type:
L0:     Mov edx &FALSE
        .While D$esi > 0
            Mov eax D$esi | cmp eax D$esi+20 | je L4>>
            test eax BIT31 NOT_ZERO L2>
L1:       ; Type's Id by number:
            cmp eax D$esi+20 | jle L4>>
                jmp L3>
L2:       ; Type's Id by string:
            test D$esi+20 BIT31 ZERO L4>>
            Push esi
                Mov eax esi
                If D$eax = RT_AVI
                    Mov esi AviTypeStr
                Else_If D$eax = RT_WAVE
                    Mov esi WaveTypeStr
                Else
                    Mov esi D$eax+12 | add esi D$eax+16
                End_If
                add eax 20
                If D$eax = RT_AVI
                    Mov edi AviTypeStr
                Else_If D$eax = RT_WAVE
                    Mov edi WaveTypeStr
                Else
                    Mov edi D$eax+12 | add edi D$eax+16
                End_If
                Mov ecx 32 | repe cmpsb
                Mov al B$esi-1
            Pop esi
            cmp al B$edi-1 | jbe L4>
L3:       ; Exchage Resource
            If D$esi+20 <> 0
                Exchange D$esi D$esi+20, D$esi+4 D$esi+24, D$esi+8 D$esi+28,
                    D$esi+12 D$esi+32, D$esi+16 D$esi+36
                Mov edx &TRUE
            End_If
L4:       ; Next Resource
            add esi 20
        .End_While
     Pop esi | Push esi
        cmp edx &TRUE | je L0<<

; Then sort by name:
L0:     Mov edx &FALSE
        .While D$esi > 0
            Mov eax D$esi | cmp eax D$esi+20 | jne L4>>
            Mov eax D$esi+4 | cmp eax D$esi+24 | je L4>>
            test eax BIT31 NOT_ZERO L2>
L1:       ; Name's Id by number:
            cmp eax D$esi+24 | jle L4>>
                jmp L3>
L2:       ; Name's Id by string:
            test D$esi+24 BIT31 ZERO L4>>
            Push esi
                Mov ebx esi, eax 0
                Mov esi D$ebx+12 | add esi D$ebx+16
                Mov edi D$ebx+32 | add edi D$ebx+36
                If D$ebx+20 <s 0
                    Mov ecx 32 | repne scasb | add esi 32 | sub esi ecx
                End_If
                Mov ecx 32 | repe cmpsb
                Mov al B$esi-1
            Pop esi
            cmp al B$edi-1 | jbe L4>
L3:       ; Exchage Resource
            If D$esi+20 <> 0
                Exchange D$esi D$esi+20, D$esi+4 D$esi+24, D$esi+8 D$esi+28,
                    D$esi+12 D$esi+32, D$esi+16 D$esi+36
                Mov edx &TRUE
            End_If
L4:       ; Next Resource
            add esi 20
        .End_While
   Pop esi | Push esi
        cmp edx &TRUE | je L0<<

; And finally, sort by lang:
L0:     Mov edx &FALSE
        .While D$esi > 0
            Mov eax D$esi | cmp eax D$esi+20 | jne L1>
            Mov eax D$esi+4 | cmp eax D$esi+24 | jne L1>
          ; Lang's Id are always by number, so:
            Mov eax d$esi+8 | cmp eax D$esi+28 | jbe L1>
          ; Exchage Resource
            If D$esi+20 <> 0
                Exchange D$esi D$esi+20, D$esi+4 D$esi+24, D$esi+8 D$esi+28,
                    D$esi+12 D$esi+32, D$esi+16 D$esi+36
                Mov edx &TRUE
            End_If
L1:       ; Next Resource
            add esi 20
        .End_While
    Pop esi | Push esi
        cmp edx &TRUE | je L0<

    Pop esi, edi


ret

____________________________________________________________________________________________
[BIT31 0_8000_0000]
; Resources Head Line Macro. In: #1: Entries by ID, #2: Entries by name
[RsrcHeadLine | add edi 2 | Mov eax #1 | stosw | Mov eax #2 | stosw
    sub edi 2 | Mov eax 0 | stosd | stosd | stosd]

NewBuildResourceTree:
  ; Initialisation of tree pointers:
    Mov eax D$CodeListPtr, D$RsrcHeadPtr eax, D$RsrcTypePtr eax,
      D$RsrcLangPtr eax, D$RsrcPtrPtr eax, D$RsrcSectionPtr eax,
      D$RsrcSectionOrigine eax

  ; Search for the tree size (evaluation begins at second record):
    Mov ecx 1                            ; how many resources in ecx
    Mov edx 1                            ; how many different resources types in edx
    Mov ebx 1                            ; how many langage in ebx
    Mov esi uRsrcList+20                 ; start comparisons at second record
L0: Mov eax D$esi | cmp eax 0 | je L3>
        inc ecx                          ; count resources
        cmp eax D$esi-20 | je L1>
            inc edx                      ; count different types
            inc ebx | jmp L2>            ; if new type >>> count language
L1: Mov eax D$esi+4
      On eax <> D$esi-16, inc ebx        ; same type: different name?>>> count language
L2: add esi 20 | jmp L0<
;;
    down > top:
    - as many ptr record as resources records in 'RsrcList' (ecx * 16)
    - as many lang headers as ebx + as many lang records as ptrs ((ebx * 16)+(ecx * 8))
    - as many type headers as edx + as many types records as lang ((edx * 16)+(ebx*8))
    - records in root as types (16 + (edx * 8))
    >>>  (ecx * 16)+(ebx * 16)+(ecx * 8)+(edx * 16)+(ebx*8)+16+(edx * 8)
    >>>  (ecx * (16+8)) + (ebx * (16+8)) + (edx * (16+8)) + 16
    >>>  ((ecx+ebx+edx) * (16+8)) + 16
;;
L3: add ecx ebx | add ecx edx | Mov eax ecx | shl eax 4 | shl ecx 3
    add eax ecx | add eax 16

____________________________________________________________________________________________

    Mov ebx uRsrcList | add ebx 12 | Mov edi D$CodeListPtr

  ; Clear the header (may bee corrupt by previous use of same memory)
    Mov ecx eax, al 0 | rep stosb

   Push edi

____________________________________________________________________________________________
  ; Strings for Types ID's by Name
    [RsrcAVIString: U$ 3 'AVI' RsrcWAVEString: U$ 4 'WAVE']
    Push ebx
      ; Type ID in uRsrcList
        sub ebx 12
        Mov edx 0
        .While D$ebx > 0
          ; If bit 31 = 0 skip resource
            test D$ebx BIT31 ZERO L4>>
                cmp edx D$ebx | jne L1>
                  ; If same Type by name that last one, Copy RVA
                    Move D$ebx D$ebx-20 | jmp L4>>

L1:       ; New type by name
            Mov edx D$ebx

          ; Avi Type
            cmp D$ebx RT_AVI | jne L2>
                Mov eax edi, esi RsrcAVIString, ecx 8 | rep movsb
              ; Change ID in uRsrcList to RVA and set the 'ID by name' flag:
                sub eax D$RsrcSectionOrigine | or eax BIT31 | Mov D$ebx eax
                jmp L4>

          ; Wave Type
L2:         cmp D$ebx RT_WAVE | jne L3>
                Mov eax edi, esi RsrcWAVEString, ecx 10 | rep movsb
              ; Change ID in uRsrcList to RVA and set the 'ID by name' flag:
                sub eax D$RsrcSectionOrigine | or eax BIT31 | Mov D$ebx eax
                jmp L4>

          ; Custom Type
          ; esi points String in uRsrcList
L3:         Mov esi D$ebx+12 | add esi D$ebx+16
          ; skip 'String Size' for now
            Push edi | add edi 2
                Mov eax 0, ecx 0
              ; Put String in Unicode format
                While B$esi <> 0
                    movsb | stosb
                    inc ecx
                End_While
            Pop eax
          ; now put 'String Size'
            Mov W$eax cx
          ; Change ID in uRsrcList to RVA and set the 'ID by name' flag:
            sub eax D$RsrcSectionOrigine | or eax BIT31 | Mov D$ebx eax

L4:         add ebx 20
        .End_While
    Pop ebx

  ; Strings for Name ID's by Name
    Push ebx
        sub ebx 8 ; Name ID in uRsrcList
        Mov edx 0
        .While D$ebx > 0
            test D$ebx BIT31 NOT_ZERO L1>
              ; bit 31 = 0, skip this resource
                Mov edx 0 | jmp L4>
          ; Last Type
L1:         Mov eax D$ebx-24
          ; If not same Type that last one jump
            cmp D$ebx-4 eax | jne L2>
                cmp edx D$ebx | jne L2>
                  ; If same ID by name that last one, Copy RVA
                    Move D$ebx D$ebx-20 | jmp L4>
L2:       ; New id by name
            Mov edx D$ebx
          ; esi points String in uRsrcList
            Mov esi D$ebx+8 | add esi D$ebx+12
            test D$ebx-4 BIT31 ZERO L3>
              ; Type by name, skip Type string:
                xchg edi esi | Mov ecx 32 | Mov al 0 | repne scasb | xchg edi esi
          ; skip 'String Size' for now
L3:         Push edi | add edi 2
                Mov eax 0, ecx 0
              ; Put String in Unicode format
                While B$esi <> 0
                    movsb | stosb
                    inc ecx
                End_While
            Pop eax
          ; Now put 'String Size'
            Mov W$eax cx
          ; Change ID in uRsrcList to RVA and set the 'ID by name' flag:
            sub eax D$RsrcSectionOrigine | or eax BIT31 | Mov D$ebx eax
L4:     add ebx 20
        .End_While
    Pop ebx

    AlignOn 16 edi
____________________________________________________________________________________________
  ; Write all data resources in .rsrc.
  ; Before action, the pointers in 'uRsrcList' point to each resource's raw data in memory
  ; After action, same pointers point to each resource in .rsrc section:
    While D$ebx > 0
      ; This is the ptr
        Mov esi D$ebx
        Mov eax edi | sub eax D$RsrcSectionOrigine
      ; change Ptrs in uRsrcList to RVA
        add eax D$uBaseOfRsrc | Mov D$ebx eax
      ; Size
        Mov ecx D$ebx+4
        rep movsb
        Mov eax edi | AlignOn 010 eax | Mov edi eax
        add ebx 20
    End_While

    Mov eax edi | sub eax D$RsrcSectionOrigine | Mov D$uRsrcSize eax

    Mov eax edi | AlignOn 0200 eax
    Mov D$CodeListPtr eax
    Pop edi | sub edi 4

____________________________________________________________________________________________

  ; Write the tree backward:
____________________________________________________________________________________________
  ; Pointers directory:

  ; end of uRsrcList (> size)
    Mov esi D$uRsrcListPtr
  ; BackWard
    std
    Do
      ; write ptrs records
        Mov eax 0 | stosd | stosd
      ; size / RVA ptr to true data
        movsd | movsd
      ; adress of record start
        Mov eax edi | add eax 4
      ; displacement from start of .rsrc
        sub eax D$RsrcSectionOrigine
      ; ptrs-dir pointer in next level up
        Mov D$esi+4 eax
        sub esi 12
    Loop_until D$esi = 0

____________________________________________________________________________________________
  ; Language directory

    Mov esi D$uRsrcListPtr
  ; Write Languages dirs
    sub esi 4 | Mov ecx 0

    Do
      ; pointers to data Ptrs / Lang
        movsd | movsd
      ; Name
        Mov ebx D$esi
      ; records counter for lang header
        inc ecx
      ; Check if there are more languages (same type and name that next resource):
      ; Compare Names
        Mov eax D$esi | cmp eax D$esi-20 | jne L1>
      ; Compare Types
        Mov eax D$esi-4 | cmp eax D$esi-24 | je L2>
      ; If not equal write headLine
L1:     RsrcHeadLine ecx, 0 | Mov ecx 0
        Mov eax edi | add eax 4
        sub eax D$RsrcSectionOrigine
      ; node flag
        or eax BIT31
      ; ptrs-dir pointer in next level up
        Mov D$esi+8 eax
      ; next ptr record in uRsrcList
L2:     sub esi 12
     Loop_until D$esi = 0

____________________________________________________________________________________________
  ; we do not need any more sizes and Lang values. We do not need any more double
  ; records for Languages. So, we rewrite uRsrcList:
    cld
    Push edi
        Mov esi uRsrcList, edi uRsrcList
        Do
          ; keep Type / keep ID / skip Lang / keep Ptr / skip size
            movsd | movsd | lodsd | movsd | lodsd
        Loop_Until D$esi = 0
        Mov D$edi 0, esi uRsrcList, edi esi
      ; type / ID??? / ptr
L0:     movsd | Lodsd | stosd | movsd
      ; Compare Names
L1:     Mov eax D$esi-8 | cmp eax D$esi+4 | jne L2>
      ; Compare Types
        Mov eax D$esi-12 | cmp eax D$esi | jne L2>
      ; Skip if equal
        add esi 12 | jmp L1<
L2:
        cmp D$esi 0 | jne L0<
      ; > last record ptr
        Mov esi edi | sub esi 4
        Mov eax 0 | stosd | stosd | stosd
    Pop edi

____________________________________________________________________________________________
  ; Types directory
    std
        Mov ecx 0, edx 0
      ; Pointer
L1:     movsd
        lodsd
      ; edx = ID by name count; ecx = ID by number count
        test eax BIT31 ZERO L2>
            inc edx
            jmp L3>
L2:         inc ecx
      ; Name / Type
L3:     stosd | lodsd
        cmp eax D$esi-8 | je L4>

        RsrcHeadLine ecx edx | Mov ecx 0, edx 0
        Mov eax edi | add eax 4
        sub eax D$RsrcSectionOrigine
      ; node flag
        or eax BIT31
      ; ptrs-dir pointer in next level up
        Mov D$esi+12 eax
L4:     cmp D$esi 0 | jne L1<

  ; We do not need any more ID. So, we rewrite uRsrcList:
    cld
    Push edi
        Mov esi uRsrcList, edi uRsrcList
      ; keep Type / skip ID / keep Ptr
L0:     movsd | lodsd | movsd
        cmp D$esi 0 | jne L0<
            Mov D$edi 0, esi uRsrcList, edi esi
      ; type??? / ptr
L0:     Lodsd | stosd | movsd
L1:     cmp D$esi eax | jne L2>
            add esi 8 | jmp L1<
L2:     cmp D$esi 0 | jne L0<
        Mov esi edi | sub esi 4
        Mov eax 0 | stosd | stosd
    Pop edi

____________________________________________________________________________________________
  ; Root Directory:
    std
        Mov ecx 0, edx 0
      ; Ptr
L1:     movsd
        lodsd
      ; edx = ID by name count; ecx = ID by number count
        test eax BIT31 ZERO L2>
            inc edx | jmp L3>
L2:         inc ecx
      ; Type
L3:     stosd
        cmp D$esi 0 | jne L1<
        RsrcHeadLine ecx, edx
    cld

ret


____________________________________________________________________________________________
;[NoResources: D$ ?    NoMainIcon: D$ ?]

BuildRsrc:
    Mov B$NoResources &FALSE, B$NoMainIcon &FALSE

    .If D$SavingExtension = '.DLL'
        Mov B$NoMainIcon &TRUE
    .Else_If D$SavingExtension = '.SYS'
        Mov B$NoMainIcon &TRUE
    .Else_If W$SubSystem = 3             ; Console > no Main Icon
        Mov B$NoMainIcon &TRUE
    .End_If


  ; THIS LINE SHOULD BE COMMENTED FOR TESTING WITH RsrcSTUB:
    Call NewTemporaryFillRsrcList

  ; THIS LINE SHOULD BE UNCOMMENTED FOR TESTING WITH RsrcSTUB:
  ;  Mov esi RsrcStub, edi uRsrcList, ecx D$RsrcStubLen | rep movsd | sub edi 4 | Mov D$uRsrcListPtr edi


    If D$uRsrcList = 0
        Mov B$NoResources &TRUE
    Else
        Call NewBuildResourceTree
    End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE CM              ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
  'NewConditionalMacroSubstitution'


  Conditional Macros
  
  'MacroWithIf', is called from the normal 'ReplaceOneMacro' Routine, before calling
  for the 'ReplaceFromMacroData' Routine, that does all of the Macros Replacements
  jobs. If a "#If something" is found out, 'MacroWithIf' runs that Conditional Macros
  Parser
  
  The Conditional macro parser job is a substitution one: It reads the Body Macro
  and modifed it, depending on the Conditionals, on the Parameters states, and so on.
  
  It calls forst to 'ExpandMacroOnParametersLoop', that, as its name says, expands
  the Macro Body accordingly, for example, to the "#+1" key, so that the Conditions
  of each Parameter could be considered.
  
  The, it Call for 'ConditionalMacroSubstitution' that does all of the Conditional
  stuff, and finaly to the 'CheckUserDefinedError' stuff, if a user defined error
  must be executed.
  
  For this implementation, a new family of Internal Variables was created. Before,
  we had the "&1,... &99" internal Variables ('MacrosVariablesTable') that are 128
  Bytes Tables, where to store any String. The new family is from "&&0" to "&&99",
  and are a set of 100 dWords Internal Counters ('MacroCounters').
  
  Each Macro Counter may hold any dWord and may be tested as such by the Conditional
  Macros Engine. But, for _writing_, the stored _BYTE_ is considered. This feature
  enable with Chars manipulations, in the Macros buildings, and are particulary usefull
  for defining Local Labels, for example, from I0 to I9, when storing '0' (Ascii 48),
  into an Internal Counter, that can be incremented / decremented, in complex macros
  Sets, for HLL Constructs.
  
  Plus, these Internal Counters, that are now set up by the normal macros, at
  'ReplaceFromMacroData' >>> 'StoreMacroVariableByNumber', can also hold a special
  record, for example, by "&&2=Pos", to the actual Source Pointer, that is used
  by the Errors Manager when pointing out to an error, inside the Source. This
  feature can be used by the Conditional Macros Parser, in case of "User Defined
  Macro Error", so that the Source Pointing Location could be defined at another
  location that the one of the actual error Detection.
  
  This is usefull for unpaired HLL Construct: Instead of pointing to the Statement
  where the error has been detected (say, an "If" / "While"...), it can point to the
  _previous_ "If" / "While", that was the real unpaired Construct.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________


[CmStart: D$ ?
 UserMacroEnd: D$ ?]

;;
  Here, we just parse the original macro Body. If some #If construct is found,
  we Call for the creation of the Macro Body substitute, depending on the
  matching, between the Conditions and the Macro Statement parameters.
;;

[UserDefinedError: D$ ?
 UserMacroLength: D$ ?]

InitMacroWithIf:
  ; '#IF' found. Take a work Copy into Trash1:
    Mov D$Trash1 0, D$Trash2 0
    Mov D$Trash1ptr, Trash1, D$Trash2Ptr Trash2
    Mov esi D$CmStart, edi D$Trash1ptr, ecx D$UserMacroLength
    rep movsb | Mov D$edi 0

    Mov B$UserDefinedError &FALSE, B$ErrorWhileUnfoldingCM &FALSE
ret

MacroWithIf:
    Push esi, edi, ecx

        Mov D$CmStart esi | Mov D$UserMacroEnd esi | add D$UserMacroEnd ecx
        Mov D$UserMacroLength ecx
      ; Cooked '#' ?
L0:     cmp B$esi numSign | jne L1>>
            cmp W$esi+1 'IF' | jne L1>
                cmp B$esi+3 Space | ja L1>
                    Call InitMacroWithIf

                    Call ExpandMacroOnParametersLoop

                    Call ConditionalMacroSubstitution

                    On B$UserDefinedError = &TRUE, Call CheckUserDefinedError

                  ; Do the final substitution:
                  ; esi will point to a Trash Table and ecx will be the new length.
                    Mov esi D$Trash1Ptr | Pop eax, edi, eax | ret

L1:     inc esi | loop L0<
    Pop ecx, edi, esi
ret
____________________________________________________________________________________________

;;
  If a Macro ends, for example, with some '#+2' loop, we unfold the Macro Loop to
  reflect the Parameters in the Macro definition, by doing a substitution of the
  Declaration.
  
  Why, is because, if the '#If' are inside a loop, the Parameters checking must
  be made fiting with each case of the Conditional job.
;;

[EvocationParametersNumber: D$ ?
 GoExpandLoop: D$ ?
 InsideCondition: D$ ?
 LoopIndice: D$ ?]

ExpandMacroOnParametersLoop:
    Mov B$GoExpandLoop &FALSE, B$InsideCondition &FALSE, D$LoopIndice 0

    Call CmParametersCount

    If ecx = 0
        Mov D$EvocationParametersNumber 0 | ret
    Else_If ecx > 100
        error TooMuchCMParam
    Else
        Mov D$EvocationParametersNumber ecx
        Call AnalyzeOfAllParameters
    End_If

    Mov esi D$Trash1ptr

  ; Is there any '#+x' Macro Loop?
    .While B$esi <> 0
        ...If B$esi = NumSign
            ..If B$esi+1 = AddSign
                On B$GoExpandLoop = &TRUE, Call CMerror D$NestedMacroLoopPtr, esi, D$Trash1ptr
                On B$InsideCondition = &TRUE, Call CMerror D$ConditionalLoopPtr, esi, D$Trash1ptr

                Mov B$GoExpandLoop &TRUE

                add esi 2 | Call GetIndice1_99 | Mov ecx ebx
                Mov eax D$EvocationParametersNumber
              ; ecx = #+x Num // eax = Number of Parameters in the Macro Evocation
                .If eax > ecx
                  ; Does the number match with the Evocation Number of Parameters?
                    Mov edx 0 | div ecx
                    On edx <> 0, Call CMerror D$MacParaPtr, esi, D$Trash1ptr

                .Else_If eax < ecx
                    Call CMerror D$MacParaPtr, esi, D$Trash1ptr

                .Else
                ; If eax = ecx + End of MacroBody: No neeed to expand, but strip the '#+X'
                    If B$esi = 0
                        While B$esi <> NumSign | dec esi | End_While
                        Mov B$esi 0 | ret
                    End_If

                .End_If

            ..Else_If W$esi+1 = 'IF'
                Mov B$InsideCondition &TRUE

            ..Else_If D$esi+1 = 'ENDI'
                Mov B$InsideCondition &FALSE

            ..End_If
        ...End_If

L5:     inc esi
    .End_While

    Mov D$LoopIndice ecx

    ...If B$GoExpandLoop = &TRUE
      ; ecx = Loop Step to be added to the Parameters:
        Mov edi D$Trash2ptr

L0:     Mov esi D$Trash1ptr

        .While B$esi <> 0
            lodsb
            .If al = NumSign
                If B$esi = AddSign
                  ; #+x found: Add x to the ecx to be add to the expressed Parameters, and loop:
                    inc esi | Call GetIndice1_99
                    add ecx ebx | cmp ecx D$EvocationParametersNumber | jbe L0<
                      ; esi >>> Next Char after '#+x'. Remove the remaining '|', if any:
                        On B$esi < Separators, inc esi
                        On B$edi-1 < Separators, dec edi

                Else_If B$esi < '1'
                    stosb

                Else_If B$esi <= '9'
                  ; Write '#':
                    stosb
                  ; Make the (Parameter '#x') Text Number, a Number, in ebx:
                    Call GetIndice1_99 | dec esi | Mov eax ebx
                    add eax ecx | sub eax D$LoopIndice
                    Call WriteEaxDecimal

                Else
                   stosb
                End_If

            .Else
                stosb

            .End_If
        .End_While

        Mov D$edi 0

        Exchange D$Trash1ptr D$Trash2ptr
    ...End_If
ret
____________________________________________________________________________________________

WriteEaxDecimal:
    Push ecx, edx
        Mov dl 0FF | Push edx
        Mov ecx 10
L0:     Mov edx 0
        div ecx | Push edx | cmp eax 0 | ja L0<
L2:     Pop eax
        cmp al 0FF | je L9>
        add al '0' | stosb | jmp L2<
L9: Pop edx, ecx
ret
__________________________________________________________________________________________

[Trash1ptr: D$ ?
 Trash2Ptr: D$ ?]

;;
  To parse all of the possible #If Constructs, with possible nested levels, and so on...
  we use _TWO_ Tables. One is the Source, the other the Destination. When one Pass
  is finished, we 'Exchange' the Tables Pointer, and loop it all, until no more '#If'
  could be found out.
;;

ConditionalMacroSubstitution:
    Call FlagConditionals
    Call ParseTheConditionals
    Call Remove0FFs
ret


Remove0FFs:
    Mov esi D$Trash1ptr, edi esi

    While B$esi <> 0
        ..If B$esi = 0FF
L0:         inc esi | cmp B$esi 0FF | je L0<
                .If B$esi = 0
                  ; End
                    If edi = D$Trash1ptr
                        Mov D$edi 'NOPE', B$edi+4 0, ecx 4 | ret
                    Else
                        On B$edi-1 =< EOI, dec edi
                    End_If
                .Else_If B$edi-1 <= EOI
                  ; Don't output two EOI/meEOI:
                    cmp B$esi EOI | jbe L0<
                .Else_If B$esi > EOI
                  ; Ensure, at least, one meEOI:
                    Mov B$edi meEOI | inc edi
                .Else
                    movsb
                .End_If
        ..Else
            movsb
        ..End_If
    End_While

    While B$edi-1 =< EOI | dec edi | End_While

    Mov B$edi 0

    Mov ecx edi | sub ecx D$Trash1ptr
ret
____________________________________________________________________________________________

Proc ParseOneIf:
    Argument @Base, @Indice
    Uses ecx

      ; esi points  at"#IF ":
        Mov esi D@Base | add esi 4

L0:     Call GetIfCondition

        Mov cl B@Indice

        .If B$CmCondition = &TRUE
          ; Arase the #If Statement:

            Mov ebx D@Base
L1:         Mov B$ebx 0FF | inc ebx | cmp ebx esi | jb L1<
            dec esi
          ; Keep the wanted Statements:
L2:         inc esi | cmp B$esi IfNumSign | jne L2<
                      If B$esi+1 = IF_FLAG
                          Mov eax D@Indice | inc eax
                          Call ParseOneIf esi, eax
                      End_If
                      cmp B$esi+2 cl | jne L2<
          ; Arase everything down to the matching #ENDIF:
L3:         Mov B$esi 0FF | inc esi
            cmp B$esi ENDIF_FLAG | jne L3<
            cmp B$esi+1 cl | jne L3<
          ; Arase the #ENDIF Statement:
            Mov W$esi 0FFFF | add esi 2
L4:         Mov B$esi 0FF | inc esi | cmp B$esi EOI | ja L4<


        .Else
          ; Arase the #If Statement:

            Mov ebx D@Base
L5:         Mov B$ebx 0FF | inc ebx | cmp ebx esi | jb L5<

          ; Arase the whole #IF Block down to the matching #ENDIF // #ELSEIF // #ELSE:
L6:         Mov B$esi 0FF | inc esi
            cmp B$esi IfNumSign | jne L6<
            cmp B$esi+2 cl | jne L6<
            If B$esi+1 = ELSEIF_FLAG  ; "#ELSEIF "
                Mov D@Base esi | add esi 8 | jmp L0<<
            Else_If B$esi+1 = ELSE_FLAG ; "#ELSE"
                Mov ebx esi | add esi 5 | jmp L1<<
            End_If
          ; Arase the #ENDIF Statement:
            Mov W$esi 0FFFF | add esi 2
L7:         Mov B$esi 0FF | inc esi | cmp B$esi EOI | ja L7<
            Mov B$esi 0FF

        .End_If
EndP
____________________________________________________________________________________________

ParseTheConditionals:
    Mov esi D$Trash1ptr

    While B$esi <> 0
        ..If B$esi = IfNumSign
            If B$esi+1 = IF_FLAG
                Call ParseOneIf esi, 1
            End_If
        ..End_If

        inc esi
    End_While
    Mov esi D$Trash1ptr
ret
____________________________________________________________________________________________
;;
  Flaging:
  
  The 'NumSign' Char of #If and friends are replaced by a dedicated 'IfNumSign',
  that makes further parsing easier. The first Char after # is replace by 1, 2,
  3, 4, respectively, for 'IF', 'ELSEIF', 'ELSE' and 'ENDIF, and the third Char
  is replaced by the nesting indice (1,... 0FF).
  
  Example: Level 4 "#IF" >>> Bytes: IfNumSign(01B), IF_FLAG(1), 4
;;

[IF_FLAG 1, ELSEIF_FLAG 2, ELSE_FLAG 3, ENDIF_FLAG 4]

FlagConditionals:
    Mov esi D$Trash1ptr, ecx 0

    .While B$esi <> 0
        ...If B$esi = NumSign
            ..If W$esi+1 = 'IF'
                Mov B$esi IfNumSign
                inc cl | Mov B$esi+1 IF_FLAG, B$esi+2 cl

            ..Else_If D$esi+1 = 'ELSE'
                Mov B$esi IfNumSign
                Mov B$esi+2 cl
                If B$esi+5 < Separators
                    Mov B$esi+1 ELSE_FLAG
                Else
                    Mov B$esi+1 ELSEIF_FLAG
                End_If

            ..Else_If D$esi+1 = 'ENDI'
                Mov B$esi IfNumSign
                Mov B$esi+1 ENDIF_FLAG, B$esi+2 cl | dec cl
                On ecx = 0FF, error D$UnpairedMacroIfPtr

           ..Else_If D$esi+1 = 'ERRO'
                Mov B$UserDefinedError &TRUE

            ..End_If

        ...End_If

        inc esi
    .End_While

    On ecx <> 0, error D$UnpairedMacroIfPtr
ret
____________________________________________________________________________________________
;;
  Some '#Error' has been found out inside the initial macro Declaration.
  If it is still in the Conditional substitution, we run the Usr Error Message
;;

[ConditionalErrorString: B$ '#Error Syntax is: #Error "My error message"' EOS]
[ConditionalErrorPosString: B$ '#Error Syntax is: #Error &&24 "My error message"' EOS]
[BadStatementCounter: B$ 'Bad Statement Counter in the Macro internal Counter' EOS]

[ErrorWhileUnfoldingCM: D$ ?]

CheckUserDefinedError:
    Mov esi D$Trash1Ptr

    .While B$esi > 0
        ...If B$esi = numSign
            ..If D$esi+1 = 'ERRO'
                .If D$esi+5 = 'RPOS'
                    While W$esi <> '&&'
                        inc esi
                        On B$esi = TextSign, error ConditionalErrorPosString
                        On B$esi = 0, error ConditionalErrorPosString
                    End_While

                    add esi 2
                    Mov ebx 0, eax 0
L0:                 lodsb
                    cmp al '9' | ja L9>
                    cmp al '0' | jb L9>
                    cmp al LowSigns | jb L9>
                        sub al '0'
                        lea ebx D$ebx+ebx*4
                        lea ebx D$eax+ebx*2
                    jmp L0<

                  ; Set in 'SaveStatementCounter':
L9:                ; lea ebx D$MacroCounters+ebx*4

                    If ebx = 0
                        jmp L7>
                    Else_If ebx > 100
                        jmp L7>
                    Else
                        Mov ebx D$MacroCounters+ebx*4
                        On ebx < D$StatementsTable, jmp L7>
                        Mov eax D$ebx
                    End_If

                    If eax < D$CodeSource
                        jmp L7>
                    Else_If eax > D$STRUCT.EditData@SourceEnd
L7:                     error BadStatementCounter
                    Else
                        Mov D$StatementsPtr ebx
                    End_If

                .End_If

              ; Scan for first TextSign:
                While B$esi <> TextSign
                    inc esi | On B$esi = 0, error ConditionalErrorString
                End_While
                inc esi | Mov edi STR.A.Trash

              ; Scan for second TextSign:
                While B$esi <> TextSign
                    movsb | On B$esi = 0, error ConditionalErrorString
                End_While
                Mov B$edi 0

                Mov B$ErrorWhileUnfoldingCM &TRUE | error STR.A.Trash
            ..End_If

        ...End_If

        inc esi
    .End_While
ret
____________________________________________________________________________________________

[CmCondition: D$ ?]

GetIfCondition:
; esi point to the Condition, right after the '#If ". Example: '#1<>', '#N=', '&55=',...

    lodsb
    ...If al = NumSign
        lodsb
        ..If al = 'N'
          ; Found: '#If #N'
            Call GetNCondition

        ..Else_If al = 'L'
            ; Found: '#If #L'
                Mov ebx D$EvocationParametersNumber | Call GetParamCondition

        ..Else_If al = 'F'
                Mov ebx 1 | Call GetParamCondition

        ..Else_If al >= '1'
            If al =< '9'
              ; Found: '#If #1' ... '#If #99'
                dec esi
                Call GetIndice1_99 | Call GetParamCondition

            Else
                Call CMerror D$BadConditionalmacroPtr, esi, D$Trash1ptr

            End_If

        ..End_If

    ...Else_If al = '&'
        If B$esi = '&'
            inc esi
            Call GetIndice0_99 | dec esi
            Call GetInternalCounterCondition

        Else
            Call GetIndice1_99 | dec esi
            Call GetInternalVariableCondition
        End_If

    ...Else
        Call CMerror D$BadConditionalmacroPtr, esi, D$Trash1ptr

    ...End_If
ret


GetNCondition:
;;
  '#If #n' found. 'n' means 'Number of Parameters. This Number will be computed by the Macros Parser,
  again, but, as we need to know it now, we compute it 'privately', here, for this specific purpose.
  No matter if stupid: Simpler.
;;
    Mov ecx D$EvocationParametersNumber
  ; Parameters Number in ecx. Take the condition Char:
    ;lodsb
    Mov ax W$esi | inc esi

    ..If ax = '<='
        inc esi
        Call GetIndice0_99
        If ecx <= ebx
            Mov B$CmCondition &TRUE
        Else
            Mov B$CmCondition &FALSE
        End_If

    ..Else_If ax = '=<'
        inc esi
        Call GetIndice0_99
        If ecx =< ebx
            Mov B$CmCondition &TRUE
        Else
            Mov B$CmCondition &FALSE
        End_If

    ..Else_If ax = '>='
        inc esi
        Call GetIndice0_99
        If ecx >= ebx
            Mov B$CmCondition &TRUE
        Else
            Mov B$CmCondition &FALSE
        End_If

    ..Else_If ax = '=>'
        inc esi
        Call GetIndice0_99
        If ecx => ebx
            Mov B$CmCondition &TRUE
        Else
            Mov B$CmCondition &FALSE
        End_If

    ..Else_If ax = '<>'
        inc esi
        Call GetIndice0_99

        If ecx <> ebx
            Mov B$CmCondition &TRUE
        Else
            Mov B$CmCondition &FALSE
        End_If

    ..Else_If al = '='
      ; compute the expected Decimal into Binary:
        Call GetIndice0_99

        If ecx = ebx
            Mov B$CmCondition &TRUE
        Else
            Mov B$CmCondition &FALSE
        End_If

    ..Else_If al = '<'
        Call GetIndice0_99

        If ecx < ebx
            Mov B$CmCondition &TRUE
        Else
            Mov B$CmCondition &FALSE
        End_If

    ..Else_If al = '>'
        Call GetIndice0_99

        If ecx > ebx
            Mov B$CmCondition &TRUE
        Else
            Mov B$CmCondition &FALSE
        End_If

    ..Else
        Call CMerror D$BadConditionalmacroPtr, esi, D$Trash1ptr

    ..End_If
ret
____________________________________________________________________________________________

[Over100CmIndice:
'A Condition is testing a Parameter indice bigger than the parameters Number' EOS]

GetParamCondition:
  ; Parameter number in ebx ('AnalyzeOfAllParameters')
    dec ebx
    On ebx > D$EvocationParametersNumber, error Over100CmIndice
    Move D$CmParamType D$AllParametersTypesAnsSizes+ebx*8
    Move D$CmParamSize D$AllParametersTypesAnsSizes+ebx*8+4
    ;Call AnalyzeOfCmParameter

    Call AnalyzeOfIfExpectation
  ; >>> ebx = D$CmParamType or D$CmParamSize // eax = 'MEM', 'REG,... , 'D', 'W',...

    .If B$esi-1 = '='
        If eax = ebx
            Mov B$CmCondition &TRUE
        Else
            Mov B$CmCondition &FALSE
        End_If

    .Else_If W$esi-1 = '<>'
        If eax <> ebx
            Mov B$CmCondition &TRUE
        Else
            Mov B$CmCondition &FALSE
        End_If

    .End_If

    While B$esi > LowSigns | inc esi | End_While | inc esi
ret
____________________________________________________________________________________________

GetInternalCounterCondition:
  ; Internal Counter Indice in ebx
    On ebx > MACRO_VARIABLES, error D$MacroVariableIndicePtr
    Mov ecx D$MacroCounters+ebx*4

    Mov B$CmCondition &FALSE

  ; Take the Condition case:
    .If B$esi = '='
        inc esi | Mov edx '='
        If B$esi = '<'
            inc esi | Mov edx '<='
        Else_If B$esi = '>'
            inc esi | Mov edx '>='
        End_If
    .Else_If W$esi = '<>'
        add esi 2 | Mov edx '<>'
    .Else_If B$esi = '<'
        inc esi | Mov edx '<'
        If B$esi = '='
            inc esi | Mov edx '<='
        End_If
    .Else_If B$esi = '>'
        inc esi | Mov edx '>'
        If B$esi = '='
            inc esi | Mov edx '>='
        End_If
    .Else
        error UnexpectedCondition
    .End_If

    On B$esi = Space, inc esi

  ; Read the Number >>> ebx will be, for example, the "39" in "#If &&1>39":
    Push ecx, edx
        If B$esi = TextSign
            inc esi | Call GetAttributionChar | inc esi
        Else
          ; The 'GetAttributionNumber' of the old Macro Engine makes stupid use of ecx:
            Mov ecx 0FF
            Call GetAttributionNumber
        End_If
    Pop edx, ecx

  ; Compare. ecx = Internal Counter // ebx = Wished Condition:
    If edx = '='
        On ecx = ebx, Mov B$CmCondition &TRUE
    Else_If edx = '<>'
        On ecx <> ebx, Mov B$CmCondition &TRUE
    Else_If edx = '<'
        On ecx < ebx, Mov B$CmCondition &TRUE
    Else_If edx = '>'
        On ecx > ebx, Mov B$CmCondition &TRUE
    Else_If edx = '<='
        On ecx <= ebx, Mov B$CmCondition &TRUE
    Else_If edx = '>='

        On ecx >= ebx, Mov B$CmCondition &TRUE
    End_If
ret
____________________________________________________________________________________________

[UnexpectedCondition: B$ 'Unexpected Condition in Macro Declaration' EOS]

GetInternalVariableCondition:
  ; Internal Variable Indice in ebx
    On ebx > MACRO_VARIABLES, error D$MacroVariableIndicePtr

  ; WriteMacroVariable // MacrosVariablesTable >>> 128 Bytes for each Variable
    shl ebx 7 | add ebx MacrosVariablesTable

    Mov B$CmCondition &FALSE

    .If B$esi = '='
        inc esi
        If B$esi = '0'
            On B$ebx = 0, Mov B$CmCondition &TRUE
        Else
            error UnexpectedCondition
        End_If

    .Else_If W$esi = '<>'
        add esi 2
        If B$esi = '0'
            inc esi
            ; jE! correction!
            On B$ebx <> 0, Mov B$CmCondition &TRUE
        Else
            error UnexpectedCondition
        End_If

    .Else
        error UnexpectedCondition

    .End_If
ret
____________________________________________________________________________________________

[CmParamType: D$ ?
 CmParamSize: D$ ?]

L7: ;showme D$Trash1ptr
    error BadConditionalmacro

AnalyzeOfCmParameter:
  ; Param Number in ebx
    Push esi
    Mov esi D$InstructionAptr, ecx 0

L0: inc esi | cmp B$esi EOI | jbe L7<
              cmp B$esi Space | jne L0<
              inc ecx | cmp ecx ebx | jb L0<

    inc esi ; >>> Firt Param Char.

    Mov D$CmParamType 0, D$CmParamSize 0
;;
  esi point to the 'ebx' Parameter? What is it?
  register, memory, immediate, WinEquate, Symbol, string
  Byte, Word, dWord, qWord, xWord, FPU4, FPU8, FPU10
;;

    ...If B$esi = TextSign
        Mov D$CmParamType 'STR'

    ...Else_If B$esi+1 = memMarker
        Mov D$CmParamType 'MEM', al B$esi | and al 00_01111111 | Mov B$CmParamSize al

    ...Else
      ; Rip the 'High Bit Done Flag' if any:
        Push D$esi, esi
            and B$esi 00_01111111
            Call IsItAreg


        ..If ah <> 0
          ; The Parameter is a reg
            Mov al B$OneOperandwBit

            .If al = BYTE_SIZE
                    Mov al 'B'

            .Else_If al = WORD_SIZE
                    Mov al 'W'

            .Else_If al = DWORD_SIZE
                If ah = REG_FPU
                    Mov al 'F'
                Else
                    Mov al 'D'
                End_If

            .Else_If al = QWORD_SIZE
                If al = REG_FPU
                    Mov al 'R'
                Else
                    Mov al 'Q'
                End_If

            .Else_If al = TBYTE_SIZE
                Mov al 'T'

            .Else  ;_If al = USO_SIZE
                Mov al 'X'

            .End_If

            Mov D$CmParamType 'REG', B$CmParamSize al

        ..Else_If B$esi < '0'
          ; Might be a Win32 Equate or an error
            Mov D$CmParamType 'SYM', B$CmParamSize 'D'

        ..Else_If B$esi <= '9'
            Mov D$CmParamType 'IMM', B$CmParamSize 'D'

        ..Else
          ; Anything else is condidered a Symbol (Equate, Label, Win32 Equate)
            Mov D$CmParamType 'SYM', B$CmParamSize 'D'

        ..End_If

        Pop esi, D$esi

    ...End_If

L9: Pop esi
ret
____________________________________________________________________________________________

[AllParametersTypesAnsSizes: D$ ? ? # 100]

[TooMuchCMParam: B$ 'More than 100 Parameters with this macro Evocation' EOS]

AnalyzeOfAllParameters:
    Mov edi AllParametersTypesAnsSizes, ebx 1
  ; ecx is previously set by 'CmParametersCount'
L0: Push edi, ebx, ecx
        Call AnalyzeOfCmParameter
    Pop ecx, ebx, edi
    Mov eax D$CmParamType | stosd
    Mov eax D$CmParamSize | stosd

    inc ebx | loop L0<
ret
____________________________________________________________________________________________

;;
  esi point after '#If #1=' // '#If #L<' // ...
  
  this should be, for example: '#If #1=D' or '#If #1=str'
  
  Here, we do nothing but load, in eax, the #If= Condition. If the Condition is a Type, we
  load the CmParamType, given by the previous Call to 'AnalyzeOfCmParameter', in ebx, for
  comparison? If the Consition is a Size, we set ebx to CmParamSize, as well.
;;

AnalyzeOfIfExpectation:
    Mov eax D$esi | and eax 0FFFFFF

    .If eax = 'STR'
        Mov ebx D$CmParamType
    .Else_If eax = 'MEM'
        Mov ebx D$CmParamType
    .Else_If eax = 'REG'
        Mov ebx D$CmParamType
    .Else_If eax = 'IMM'
        Mov ebx D$CmParamType
    .Else_If eax = 'SYM'
        Mov ebx D$CmParamType
    .Else
        On B$esi+1 > EOI, Call CMerror, D$BadConditionalmacroPtr, esi, D$Trash1ptr
      ; If ' D', and so on:
        and eax 0FF | movzx ebx B$CmParamSize

        If al = 'D'
        Else_If al = 'W'
        Else_If al = 'B'
        Else_If al = 'Q'
        Else_If al = 'F'
        Else_If al = 'R'
        Else_If al = 'T'
        Else_If al = 'X'
        Else
            Call CMerror, D$BadConditionalmacroPtr, esi, D$Trash1ptr
        End_If

    .End_If
ret
____________________________________________________________________________________________

GetIndice1_99:
    On B$esi >= '1', jmp L0>
        Call CMerror BadCMIndice, esi, D$Trash1ptr

GetIndice0_99:
    On B$esi < '0', error BadCMIndice
L0: On B$esi > '9', error BadCMIndice

    Mov ebx 0, eax 0
L0: lodsb
    cmp al '9' | ja L9>
    cmp al '0' | jb L9>
    cmp al LowSigns | jb L9>
        sub al '0'
        lea ebx D$ebx+ebx*4
        lea ebx D$eax+ebx*2
    jmp L0<

L9: ; Number in ebx
    On ebx > 99, error BadCMIndice
ret
____________________________________________________________________________________________

;;
  How many Parameters in the User Statement (the Macro Evocation), for the '#n=x'
  Condition.
;;

CmParametersCount:
    Push esi
        Mov esi D$InstructionAptr, ecx 0

L0:     inc esi | Mov al B$esi
            cmp al EOI | je L9>
            cmp al meEOI | je L9>
            cmp al Space | jne L0<
                inc ecx | jmp L0<
L9: Pop esi
ret
____________________________________________________________________________________________

Proc CMerror:
    Arguments @error, @Source, @Base

        If D@Source <> &NULL
            Mov esi D@Source, ebx esi | On esi = D@Base, jmp L2>
            While B$esi > EOI
                dec esi | On esi = D@Base, jmp L2>
            End_While

L2:         While B$ebx > EOI | inc ebx | End_While
            Mov B$ebx 0

            error D@Error, esi

        Else
            error D@Error

        End_If
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Equal           ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
 Author name: Scarmatil (Julien OTELE MANDA)

 eMail: < scarmatil@gmail.com>
 
 Last Update: 27-07-2005      
____________________________________________________________________________________________

 ProcessEqual  EqualParser  WriteOperationCode  IntegratedFunctionManagement
 EvalOneEquation   GetStringType  ProcessarrayDestination  ComputeOperationsIn_EPPSourceEquation
 
 
 EPP_All_Data    
 
____________________________________________________________________________________________
HOW TO USE THE EQUAL PREPARSER: 

This pre-parser actually groups three differents parsers :


=> Evaluation parser:  (Expression1 OP Expression2) 

- Expression1 and Expression2 are the two expression you want to compare, 
  SourceExpression can be a single register (Common or FPU), memory data or an equation combining the 
  operators below with any memory data, register or constant.

- OP is the comparison operator, it can be one of the following:  =  <  >

- The whole expression (including the parentheses are replaced by a boolean DWord value containing 
  the result of the evaluation of this expression.


=> String maker:  str(Destination) = Source

- Destination can be a 32 bits register, a Data Label (i.e a constant) or a Memory DWord. 

- Source can be a string, a 32 bits register, a Data Label or a Memory DWord. 
 
- /!\ The destination is a pointer, you have to make sure there is enough space to write the string /!\

- /!\ Each source value is a null-terminated string, make sure that the trailing null character is not missing. /!\ 

example :
[CRLF: W$ 0D0A 0] [strbuf:B$ ? #128] [strbuf2:B$ ? #128]
 > ecx = strbuf2
 > str(ecx) = 'Scarmatil'
 > str(strbuf) = 'hop !' CRLF ecx ' et ' ecx ' sont sur un bateau. ' ecx " tombe a l'eau? " CRLF "Qui reste-t-il ?"
 


=> Equation Parser:   Destination = SourceExpression 

- Destination can be a register (Common or FPU) or memory Data (including array, see below for the syntax).

- SourceExpression can be a single register (Common or FPU), memory data or an equation combining the 
  operators below with any memory data, register or constant.
  It can also be a Call, providing that the return value is in EAX.
    
- You can use parentheses with no limit of nesting (except your time while compiling)

- To display the code output by the preparser inside RosAsm, simply double-click on the Destination 
  operand and choose 'unfold' in the menu.

* Operator list : 
    => ^       ; power operator, the first operand has to be strictly positive 
    => * / + - : common operator
    => // **   ; signed operators 

* Available functions : 
  - cos(), sin(), abs(), tan(), sqrt(), ln(), log10(), log2(), exp() and atan().  

* Conversions :
 The parser can perform any conversion as long as they are not impossible (store a DWord in a byte !?):
  > ST0 = (D$a+D$b)/6+(D$c*7)       ; integer result stored in a FPU register
  > Q$MyQValue = B$MyByteVal  
  > ...
    
* Signed operations:
  To force signed integer division and multiplication you can use '//' and '**' operators .
  Notice that if one of the operand is a floating point value (6.2,T$MyVal,...) the operation
  will be signed even with '*' and '/' operators.

* Addressing support
    - X$(expression)  : this will be interpreded as : X$expression (like in basic RosAsm syntax)
    - Without parentheses if the writing is the same that in basic RosAsm syntax when it is possible
      and the operation otherwise.
ex:
(1) - edx = D$(eax+3)     ; Mov edx D$eax+3
(2) - edx = (D$eax)+3     ; Mov edx D$eax | add edx 3 
(3) - edx = D$eax+3       ; Mov edx D$eax+3
(3) - edx = D$eax+D$ebx   ; Mov edx D$eax | add edx D$ebx  
(4) - edx = D$(eax+D$ebx) ; add eax D$ebx | Mov edx D$eax 

* Array support:    
    - X$Array(index)  : this will be interpreded as : X$Array+index*(X_size)

ex:- [MyTable: D$ 'ZERO' 'ONE ' 'TWO ' 'THRE' 'FOUR' 'FIVE']
     eax = D$MyTable(4)  ; eax = 'FOUR'
                 
                        
* Supported data size (both in source and destination): B$, W$, D$, Q$, F$, R$ and T$    


/!\  No FINIT is written by the parser, write it yourself at the beginning of       /!\
     the code if you use expressions containing reals .
    
examples :

 > eax = 1
 > edx = &TRUE+(2*2)
 > D$Value1 = D$Value2
 > W$Value1+2 = W$Value2+2
 > D$Handle = Call 'DLLNAME.DllFunction', Para1, ...    
 > ST2 = (tan(45)/sqrt(3.5+9)-1/T$MyReal)               
 > eax = (D$a+D$b)/6+(D$c*7)
 > D$Val3 = (3 * D$a + 12) / (24 * D$b) - D$c * D$c * 18 / (13 + D$z) 
 > ebx = sin(45) 
 > T$FloatNumber = sqrt(abs(7+-3*ebx)+R$FpVal)
 > eax = F$MyArrayName(eax)
 > D$DestArray(ecx) = W$SourceArray(eax)   

        ____________________________________________________________________________________________
 
  Basically this parser works as follow :
  It first copies the equation into EPP_SourceEquation and the destination operand into 
  EPP_DestOperand 
  Then the equation is formated to ease the parsing.

  The parsing begins and the first closing parenthesis is searched. Each time the parser meets an 
  opening parenthesis, it keeps its position.
  Once the first closing parenthesis is found, the operations in these parentheses are processed
  in this order: ^ then * and / and finally + and - (to keep prority).  
  
  Then each operation type is processed and the corresponding code is written thanks to 
  the macro EPP_Code                                                          
;;
____________________________________________________________________________________________
EqualParser:
    Mov esi D$CodeSourceA, edi D$CodeSourceB | Mov ecx esi | add ecx D$StripLen
    Mov B$ErrorLevel 0, D$bracketCounter 0      ; error0
   ; Mov D$StatementsCounter 1, D$InstructionsCounter 0
    Move D$StatementsPtr D$StatementsTable | sub D$StatementsPtr 4

    .While esi < ecx
        ..If B$esi = TextSign
            movsb | While B$esi <> TextSign | movsb | End_While
        ..Else_If_And B$esi+1 = '=', B$esi = Space, B$esi+2 = Space
            Call ParseOneEqualLine
        ..Else_If B$esi = openSign
            Call EvaluateEquation
        ..End_If

        If B$esi = EOI
            add D$StatementsPtr 4
        Else_If B$esi = OpenBracket
            add D$StatementsPtr 4
        Else_If B$esi = OpenVirtual
            add D$StatementsPtr 4
        End_If

        movsb
    .End_While

; post-parsing optimization :

    jmp L1>
    While ebx <> CODE_NOT_FOUND
        Call DeleteFinalCodeLine ebx edi | sub edi eax

L1:     EPP_FindCodePos 'end_equal||' D$CodeSourceB edi
        Mov ebx eax
    End_While
    Mov B$edi-1 EOI, B$edi 0

L2:
    sub edi D$CodeSourceB | Mov D$StripLen edi
    Exchange D$CodeSourceA D$CodeSourceB

ret
____________________________________________________________________________________________
EvaluateEquation:
    ; Look for Equation between parentheses which can be evualuated
    ; There three possibles comparison operators (=,<,>)
    ; ex: (eax*7=F$a/2)  ;  (D$Array(ecx)<exp(ecx))
    Mov eax INITIAL_STATE
    lea edx D$esi+1

    While B$edx > EOI
        If_And B$edx = closeSign, eax = FOUND_EQUATION_TEST
            jmp L1>
        End_If
        On B$edx = openSign, inc eax
        On B$edx = closeSign, dec eax

        .If_Or B$edx = '=', B$edx = '<', B$edx = '>'
            If eax = INITIAL_STATE
                Mov ebx edx
                Mov eax FOUND_EQUATION_TEST
            Else
                Mov eax 0 ; unpaired parenthesis
            End_If
        .End_If
        inc edx
    End_While
L1:
    If eax = FOUND_EQUATION_TEST
        Call EvalOneEquation esi edx ebx edi
    End_If
ret
____________________________________________________________________________________________
Proc EvalOneEquation:
    ; This routine evaluates each member of the Equation between D@openSign and D@closeSign,
    ; then compare them using de D@CompPos operator (=,<,>) and replace the whole expression
    ; by a boolean value stored in a DWord (&TRUE if the comparison is true &FALSE otherwise)
    Arguments @openSign @closeSign @CompPos @ProducedCode
    Uses ebx, ecx

    ; debug Data
    Move D$LastEqualLine   D@ProducedCode

    ; init EPP_Code
    Move D$EPP_WrittenCode    D@ProducedCode
    Move D$EPP_CodeBegining   D@ProducedCode

    EPP_Code 'Push ESI|Mov ESI ESP|'

    Push D$EPP_WrittenCode
        Mov D$EPP_WrittenCode EPP_DestOperand
        EPP_Code 'T$&8 '
    Pop D$EPP_WrittenCode
    EPP_Code 'SUB ESP 0A|{!8 ESI-0A}|'

    Mov esi D@openSign | inc esi
    Mov edi EPP_SourceEquation
    Mov ebx D@CompPos
    While esi < ebx | movsb | End_While | Mov B$edi EOI

    Push D$EPP_CodeBegining
        Move D$EPP_CodeBegining D$EPP_WrittenCode
        Call ComputeOperationsIn_EPPSourceEquation &FALSE
        Call StoreResultInFirstOperand
        Call OptimizeEqualPreparserCode EPP_CODE_BEGIN EPP_CODE_END
        Call UpdateLocalDataShift
    Pop D$EPP_CodeBegining

    Push D$EPP_WrittenCode
        Mov D$EPP_WrittenCode EPP_DestOperand
        EPP_Code 'T$&9 '
    Pop D$EPP_WrittenCode
    EPP_Code 'SUB ESP 0A|{!9 ESI-014}|'

    Mov esi D@CompPos | inc esi
    Mov edi EPP_SourceEquation
    Mov ebx D@closeSign
    While esi < ebx | movsb | End_While | Mov B$edi EOI

    Push D$EPP_CodeBegining
        Move D$EPP_CodeBegining D$EPP_WrittenCode
        Call ComputeOperationsIn_EPPSourceEquation &FALSE
        Call StoreResultInFirstOperand
        Call OptimizeEqualPreparserCode EPP_CODE_BEGIN EPP_CODE_END
        Call UpdateLocalDataShift
    Pop D$EPP_CodeBegining

    EPP_Code 'FLD T$!9|FLD T$!8|'

    Mov ebx D@CompPos
    If B$ebx = '='
        EPP_Code 'FCOMP ST1|FSTSW AX|AND AX 04400|CMP AX 04000|JNE &1|Mov EAX 1|JMP &3|!1:|Mov EAX 0|!3:|'
    Else_If B$ebx = '<'
        EPP_Code 'FCOMP ST1|FSTSW AX|AND AX 0500|CMP AX 0100|JNE &1|Mov EAX 1|JMP &3|!1:|Mov EAX 0|!3:|'
    Else_If B$ebx = '>'
        EPP_Code 'FCOMP ST1|FSTSW AX|AND AX 04500|TEST AX AX|JNE &1|Mov EAX 1|JMP &3|!1:|Mov EAX 0|!3:|'
    End_If
    EPP_Code 'SUB ESP 04|{?? ESI-000}|Mov D$? EAX|'

    ; Replaces the two expressions and the comparison operator by the DWord result
    Mov esi D@openSign | While B$esi > EOI | dec esi | End_While | inc esi
    Mov ebx D@openSign
    Mov edi D$EPP_WrittenCode
        While esi < ebx | movsb | End_While
    Mov D$EPP_WrittenCode edi
    EPP_Code 'D$?'
    Mov esi D@closeSign | inc esi |While B$esi > EOI | inc esi | End_While | Mov ebx esi
    Mov esi D@closeSign | inc esi
    Mov edi D$EPP_WrittenCode
        While esi <= ebx | movsb | End_While
    Mov D$EPP_WrittenCode edi
    Mov B$edi meEOI
    EPP_Code 'Mov ESP ESI|Pop ESI||'

    ; remove what was written before D$EPP_CodeBegining (which was initially before the expression)
    Mov edi D$EPP_CodeBegining
    Mov eax 0
    If B$edi-1 <> EOI
        Mov B$edi-1 EOI
        sub edi 2 | While B$edi > EOI | dec edi | End_While | inc edi
        Call DeleteFinalCodeLine edi D$EPP_WrittenCode
    End_If

    ; Updates edi
    Mov edi D$EPP_WrittenCode | sub edi eax

    Call TranslateExpressions
EndP
____________________________________________________________________________________________
ParseOneEqualLine:
    Mov ebx esi, edx edi   ; D$esi = ' = '  ; eax = 1  (keep ebx at ' = ')

  ; Go to start of Instruction, and abort if, for example "If eax = 1" is encounted
  ; because of such user Defined Equates. In such Cases, we will have either one more
  ; Space backward, or, maybe, '[', if encounted inside a Declaration:
    While B$esi-1 > EOI
        On B$esi-1 = ColonSign, jmp L2>
        dec esi | dec edi
        .If B$esi <= OpenVirtual
            If B$esi = Space
                jmp L1>
            Else_If B$esi = OpenBracket
                jmp L1>
            Else_If B$esi = OpenVirtual
L1:             Mov esi ebx, edi edx | ret
            End_If
        .End_If
    End_While

L2: Call ProcessEqual ebx edi

    ;Sets esi (in CodeSourceA) and edi (in CodeSourceB) on the end of Line (EOI)
    Mov esi ebx
    While B$esi <> EOI | inc esi | End_While

    Mov edi edx
    While B$edi <> EOI | inc edi | End_While
    On B$edi-1 = meEOI, Mov B$edi-1 EOI     ;The code mustn't end with 0102 (meEOI,EOI) (or RosAsm hangs when unfolding)
ret
____________________________________________________________________________________________
Proc ProcessEqual:
    ; D@EqualPos is the position of ' = '
    Arguments @EqualPos @ProducedCode
    pushad

    ; debug Data
    Move D$LastEqualLine   D@ProducedCode
    On D$FirstEqualLine = &TRUE, Move D$FirstEqualLine D@ProducedCode

    ; init EPP_Code
    Move D$EPP_WrittenCode D@ProducedCode
    Move D$EPP_CodeBegining   D@ProducedCode

    ; copies the Destination operand in EPP_DestOperand
    Mov esi D@EqualPos
    While B$esi <> EOI | dec esi | End_While | inc esi
    Mov edi EPP_DestOperand
    While B$esi > Space | movsb | End_While | Mov B$edi Space

    ; copies the line into EPP_SourceEquation
    Mov esi D@EqualPos | add esi 3
    Mov edi EPP_SourceEquation
    While B$esi > EOI | movsb | End_While | Mov B$edi EOI

    Call IsStringMaker | If eax = &TRUE | popad | ExitP | End_If

    Call IsItaCall | If eax = &TRUE | popad | ExitP | End_If

    Call ReserveGlobalFunctionAdress

    Call ComputeOperationsIn_EPPSourceEquation &FALSE

    Call ProcessArrayDestination

    Call StoreResultInFirstOperand

    EPP_Code 'end_equal||'

    Call OptimizeEqualPreparserCode EPP_CODE_BEGIN EPP_CODE_END

    Call UpdateLocalDataShift

    Call TranslateExpressions

    ;Call ShowSource 0 7

    popad
EndP
____________________________________________________________________________________________
IsStringMaker:

    If_Or W$EPP_DestOperand <> 'ST', B$EPP_DestOperand+2 <> 'R', B$EPP_DestOperand+3 <> openSign
        Mov eax &FALSE | ret
    End_If

    EPP_Code 'Push ESI|Push EDI|'

    lea esi D$EPP_DestOperand+4 | Mov D$EPP_Operand1 esi
    If_And B$esi+1 = memMarker, B$esi <> 'D'
        error EqualPreparser_InvalidStringDest_Type
    Else_If_And B$esi >= '0', B$esi <= '9'
        error EqualPreparser_InvalidStringDest_Numeric
    End_If

    While B$esi > openSign | inc esi | End_While | Mov B$esi Space

    EPP_Code 'Mov EDI #1|'
    Mov ecx EPP_SourceEquation
    .While B$ecx > EOI
        If B$ecx = TextSign
            Mov D$EPP_TextPointer ecx
            EPP_Code '{&1:B$ #text 0}|Mov ESI !1|&2:|CMP B$ESI 0|JZ &3|MOVSB|JMP !2|!3:|'
            inc ecx | While B$ecx > TextSign | inc ecx | End_While
            On B$ecx = TextSign, inc ecx

        Else
            Mov D$EPP_Operand2 ecx
            EPP_Code 'Mov ESI #2|&2:|CMP B$ESI 0|JZ &3|MOVSB|JMP !2|!3:|'
            While B$ecx <> Space | inc ecx | End_While
        End_If
        While B$ecx = Space | inc ecx | End_While
    .End_While

    EPP_Code 'Mov B$EDI 0|Pop EDI|Pop ESI||'
    Mov eax &TRUE

ret
____________________________________________________________________________________________
ReserveGlobalFunctionAdress:
    ; Initialize labels to be used later for global functions declaration and call. (not used)

    Call CreateNoMeanlabel
    Mov edi EPP_atofAddress | Mov B$edi+8 0
    Call CreateNoMeanlabel
    Mov edi EPP_ftoaAddress | Mov B$edi+8 0
ret
____________________________________________________________________________________________
Proc ComputeOperationsIn_EPPSourceEquation:
    ; Writes code from the most nested parenthesis to the least one.
    ; The parser search for the first couple of parentheses with no nested parenthesis inside and then
    ; computes the operations in the operator's priority order.
    ; When an operation immediately computable is found while searching for theses couples of parentheses, this
    ; operation is computed first. (See TestIfThisOperationIsComputable)
    ;
    ; This allows keep the very last results on the top of the FPU Stack, so that no Move is needed.
    ; For instance with this equation:
    ; > T$res = (T$a-T$b)*T$e+(T$b+T$c)
    ;
    ; - if the operations between parentheses were computed first this would lead to
    ;       > T$res = ST1*T$e+ST0    ;with ST0=T$b+T$c ; ST1=T$a-T$b
    ;       > T$res = ST2*ST0+ST1    ;with ST0=T$e     ; ST1=T$b+T$c ; ST2=T$a-T$b
    ;   The first operation to compute is ST2*ST0, then ST2 must be copied on TOS with 'FLD ST2'
    ;
    ; - On the other hand, if we compute an operation as soon as is it possible, we have:
    ;       > T$res = ST0*T$e+(T$b+T$c)     ; with ST0=T$a-T$b
    ;       > T$res = ST0+(T$b+T$c)         ; with ST0=(T$a-T$b)*T$e
    ;   Here the '+' operation is not immediately computable, so the parsing continues to
    ;       > T$res = ST1+ST0               ; with ST1=(T$a-T$b)*T$e  ; ST0=T$b+T$c
    ;       > T$res = ST0                   ; with ST0=(T$a-T$b)*T$e+(T$b+T$c)
    ;   All the operations have been made on TOS :)
    Arguments @SecondPass
    Uses esi, edi

    ; add rounding parentheses
    Mov edi EPP_SourceEquation
    Call ShiftLineRight 1 | Mov B$edi openSign
    While B$edi > EOI | inc edi | End_While | Mov B$edi closeSign | Mov B$edi+1 EOI

    Mov eax &FALSE

    ; Checks the parentheses number.
    Mov eax 0
    Mov esi EPP_SourceEquation
    While B$esi > EOI
        On B$esi = openSign, inc eax
        On B$esi = closeSign, dec eax
        inc esi
    End_While
    On eax <> 0, error Parenthesis

    Call FormatEqualLine
    On B$UseCommonAddressingSyntax = &TRUE, Call SetCommonAddressingSyntax
    Call EqualFirstScan D@SecondPass

    Mov D$FPUStackNumber 0
    Mov B$ParsingInsideArray &FALSE
    Mov esi EPP_SourceEquation
    .While B$esi > EOI
        .If B$esi = openSign
            Call CheckIfArray
            Mov ebx esi | inc esi

        .Else_If B$esi = closeSign
            Call WriteCodeForTheseParentheses ebx
            On eax = &FALSE, error EqualPreparser_UnexpectedError
            Call IntegratedFunctionManagement ebx eax
            Mov esi EPP_SourceEquation
            Mov B$ParsingInsideArray &FALSE

        .Else_If B$esi = Space
            inc esi

        .Else_If_Or B$esi < OperatorSigns, B$esi = SignedMulSign, B$esi = SignedDivSign
            Call TestIfThisOperationIsComputable esi
            If eax <> &FALSE
                Call GetOperandTypeAndPos esi
                Call WriteOperationCode eax ecx
                Mov esi EPP_SourceEquation
                Mov B$ParsingInsideArray &FALSE

            Else
                inc esi
            End_If
        .Else
            inc esi
        .End_If
    .End_While

EndP
____________________________________________________________________________________________
SetCommonAddressingSyntax:
; Look for memory data followed by an expression which can be an address
; [i.e. : Memory+register(+,*)constant+(register,constant)+constant)  ]
; and surround the expression with parentheses.

    Mov esi EPP_SourceEquation
    .While B$esi > EOI
L1:     If_Or B$esi <= LowSigns, B$esi = SignedMulSign, B$esi = SignedDivSign
            inc esi
            jmp L1<
        End_If

        Call GetStringType esi
        While B$esi > Space | inc esi | End_While | inc esi
        ...Test_If ax MemoryOperand
            ...If B$esi = addSign
                ..If_And B$esi+2 > LowSigns, B$esi+2 <> SignedMulSign, B$esi+2 <> SignedDivSign
                    add esi 2 | Call GetStringType esi
                    ..Test_If ax constantOperand
                        ReplaceByAddressingOperator plusSign   ; Memory+constant

                    ..Test_Else_If ax registerOperand
                        ReplaceByAddressingOperator plusSign   ; Memory+register

                        While B$esi > Space | inc esi | End_While | inc esi
                        .If_Or B$esi = mulSign, B$esi = SignedMulSign
                            add esi 2 | Call GetStringType esi
                            .Test_If ax ConstantOperand
                                ReplaceByAddressingOperator addressSign   ; Memory+register*constant

                                While B$esi > Space | inc esi | End_While | inc esi
                                If B$esi = addSign
                                    add esi 2 | Call GetStringType esi
                                    Test_If ax ConstantOperand
                                        ReplaceByAddressingOperator plusSign   ; Memory+register*constant+constant
                                    Test_End
                                Else_If B$esi = subSign
                                    add esi 2 | Call GetStringType esi
                                    Test_If ax ConstantOperand
                                        ReplaceByAddressingOperator minusSign   ; Memory+register*constant-constant
                                    Test_End
                                End_If
                            .Test_End

                        .Else_If B$esi = addSign
                            add esi 2 | Call GetStringType esi
                            Test_If ax ConstantOperand
                                ReplaceByAddressingOperator plusSign    ; Memory+register+constant
                            Test_End
                        .Else_If B$esi = subSign
                            add esi 2 | Call GetStringType esi
                            Test_If ax ConstantOperand
                                ReplaceByAddressingOperator minusSign    ; Memory+register-constant
                            Test_End
                        .End_If
                    ..Test_End
                ..End_If
            ...End_If
        ...Test_End
    .End_While

ret
____________________________________________________________________________________________
Proc GetStringType:
    ; D@StringPos points on the string whose type is to be found. (it can be terminated by EOI,meEOI,Space or &NULL)
    Arguments @StringPos
    Uses esi, ecx

    Mov esi D@StringPos
    Call IsARegister D@StringPos
    ..If eax = &FALSE
        .If B$esi+1 = memMarker
            or ax MemoryOperand
            If B$esi = 'T'
                or ax (FloatingPointOperand or TByteValue)
            Else_If B$esi = 'R'
                or ax (FloatingPointOperand or RealValue)
            Else_If B$esi = 'F'
                or ax (FloatingPointOperand or FloatValue)
            Else_If B$esi = 'Q'
                or ax QWordValue
            Else_If B$esi = 'D'
                or ax DWordValue
            Else_If B$esi = 'W'
                or ax WordValue
            Else_If B$esi = 'B'
                or ax ByteValue
            End_If
        .Else_If_And B$esi >= '0', B$esi <= '9'
            Mov ecx esi
            While B$ecx > Space
                If B$ecx = pointSign
                    or ax FloatingPointOperand
                    jmp L1>
                Else
                    inc ecx
                End_If
            End_While
L1:         or ax (ConstantOperand or NumericOperand)
        .Else_If_And B$esi = minusSign, B$esi+1 >= '0', B$esi+1 <= '9'
            or ax (ConstantOperand or NumericOperand)
        .Else
            While B$esi > Space | inc esi | End_While | inc esi
            If B$esi = openSign
                or ax FunctionOperand
            Else
                or ax ConstantOperand
            End_If
        .End_If
    ..End_If

EndP
____________________________________________________________________________________________
Proc ProcessArrayDestination:
    ; If the destination operand is an array (ex: F$Array(ecx+3) ) The current state is saved and
    ; the address of the array is computed and stored in EDI (resp. ECX). Then the state of the current operation is
    ; restored with X$EDI (resp. X$ECX) as new destination operand (with X the size of array's elements)
    Local @AddressRegister

    Mov D$DestinationArrayRegister &FALSE
    Mov esi EPP_DestOperand
    .While B$esi > Space
        .If B$esi = openSign
            or B$UsedRegisters (EPP_EDI or EPP_ECX)
            Call BackupFirstResults

            ; Copy address in EPP_SourceEquation
            Mov edi EPP_SourceEquation | Mov B$edi openSign | inc edi
            While B$esi > Space | movsb | End_While | Mov B$edi closeSign | inc edi
            If B$EPP_DestOperand+2 <> openSign
                Mov B$edi mulSign | inc edi | Call GetAddressingCoef EPP_DestOperand | Mov B$edi al | inc edi
                Mov B$edi addSign | inc edi
                lea esi D$EPP_DestOperand+2 | While B$esi <> openSign | movsb | End_While
            End_If
            Mov B$edi EOI

            ; defines addressing register
            If_Or W$EPP_SourceEquation_Backup+1 = 'CX', W$EPP_SourceEquation_Backup+1 = 'CH',
                                                        W$EPP_SourceEquation_Backup+1 = 'CL'
                jmp L1>
            Else_If_And W$EPP_SourceEquation_Backup+2 = 'CX', B$EPP_SourceEquation_Backup+1 = 'E'
                jmp L1>
            Else_If_And W$EPP_SourceEquation_Backup+4 = 'CX', B$EPP_SourceEquation_Backup+3 = 'E',
                                                              B$EPP_SourceEquation_Backup+2 = memMarker
L1:             Mov D@AddressRegister 'EDI'
                Mov D$DestinationArrayRegister EPP_EDI
            Else
                Mov D@AddressRegister 'ECX'
                Mov D$DestinationArrayRegister EPP_ECX
            End_If
            Move D$EPP_DestOperand D@AddressRegister | Mov B$EPP_DestOperand+3 Space

            Mov al B$UsedRegisters_Backup | Mov B$UsedRegisters al
            Call WriteRestoringCodeForUsedRegisters

            Call ComputeOperationsIn_EPPSourceEquation &TRUE

            ; Stores result in EDI/ECX
            Mov D$EPP_LastStorageStatement_InMemory StrNull
            Mov D$EPP_LastStorageStatement          StrNull
            Mov D$EPP_Operand1 EPP_SourceEquation | inc D$EPP_Operand1
            Mov D$EPP_Operand2 EPP_DestOperand
            Mov edi EPP_SourceEquation | Call StoreIn32BitsRegister
            Call ImmediateCodeParser D$EPP_LastStorageStatement_InMemory
            Call ImmediateCodeParser D$EPP_LastStorageStatement

            Call RestoreFirstResults
            Move D$EPP_DestOperand+2 D@AddressRegister | Mov B$EPP_DestOperand+5 Space

            ExitP
        .End_If

        inc esi
    .End_While

EndP
____________________________________________________________________________________________
WriteRestoringCodeForUsedRegisters:
    ; This writes the code which restores from the stack the registers which have been used
    ; during the computation of the equation.

    Mov cl minusSign
    Mov bx '04'

    Test_If B$UsedRegisters EPP_EDI
        EPP_Code 'Mov EDI D$ESI' cl bx '|'
        add bh 4
    Test_End

    Test_If B$UsedRegisters EPP_ECX
        EPP_Code 'Mov ECX D$ESI' cl bx '|'
        add bh 4
    Test_End

    Test_If B$UsedRegisters EPP_EAX
        On bh > '9', add bh 7
        EPP_Code 'Mov EAX D$ESI' cl bx '|'
        add bh 4
    Test_End

    Test_If B$UsedRegisters EPP_EBX
        On bh = 010, Mov bl '1', bh '0'
        EPP_Code 'Mov EBX D$ESI' cl bx '|'
        add bh 4
    Test_End

    Test_If B$UsedRegisters EPP_EDX
        On bh = 010, Mov bl '1', bh '0'
        On bh > '9', add bh 7
        EPP_Code 'Mov EDX D$ESI' cl bx '|'
    Test_End


ret
____________________________________________________________________________________________
Proc BackupFirstResults:
    Uses esi, edi

    Mov esi EPP_DestOperand
    Mov edi EPP_DestOperand_Backup
    While B$esi > Space | movsb | End_While

    Mov esi EPP_SourceEquation
    Mov edi EPP_SourceEquation_Backup
    While B$esi > EOI | movsb | End_While | Mov B$edi EOI

    Mov al B$UsedRegisters | Mov B$UsedRegisters_Backup al
EndP
____________________________________________________________________________________________
Proc RestoreFirstResults:
    Uses esi, edi

    Mov esi EPP_DestOperand_Backup
    Mov edi EPP_DestOperand
    While B$esi > Space | movsb | End_While

    Mov esi EPP_SourceEquation_Backup
    Mov edi EPP_SourceEquation
    While B$esi > EOI | movsb | End_While | Mov B$edi EOI

    Mov al B$UsedRegisters_Backup | Mov B$UsedRegisters al
EndP
____________________________________________________________________________________________
Proc CheckIfArray:
    ; Sets B$ParsingInsideArray to &TRUE, if the last parenthesis is after an array.
    Uses esi

    dec esi
    If_And esi <> EPP_SourceEquation, B$esi-1 > openSign
        dec esi | While B$esi > Space | dec esi | End_While
        On B$esi+2 = memMarker, Mov B$ParsingInsideArray &TRUE
    End_If

EndP
____________________________________________________________________________________________
Proc TestIfThisOperationIsComputable:
    ; return &FALSE if the operation at D@OperatorPos has NOT the priority to the next one.
    ; otherwise the operator is returned in eax and its sign in ecx.
    ; ex: eax = 8+3*eax+(7-D$a)/2
    ; - if D@OperatorPos points on '*', the function returns '*' (i.e. mulSign) and &FALSE in ecx (unsigned operation)
    ; - if D@OperatorPos points on the first '+', the function returns &FALSE
    ;
    Arguments @OperatorPos
    Uses ebx, esi

    Mov esi D@OperatorPos
    Call GetSignPriority D$esi | Mov bl al

    add esi 2 | While B$esi <> Space | inc esi | End_While | inc esi
    Call GetSignPriority D$esi

    Mov esi D@OperatorPos
    .If bl >= al
        If B$esi = SignedMulSign
            Mov ecx &TRUE
            Mov eax mulSign
        Else_If B$esi = SignedDivSign
            Mov ecx &TRUE
            Mov eax divSign
        Else
            Mov ecx &FALSE
            movzx eax B$esi
        End_If
    .Else
        Mov eax &FALSE
    .End_If

EndP
____________________________________________________________________________________________
Proc GetSignPriority:
    Argument @Sign

    If B@Sign = closeSign
        Mov al 0
    Else_If_Or B@Sign = addSign, B@Sign = subSign
        Mov al 1
    Else_If_Or B@Sign = mulSign, B@Sign = divSign, B@Sign = SignedMulSign, B@Sign = SignedDivSign
        Mov al 2
    Else_If_Or B@Sign = expSign
        Mov al 3
    Else
        Mov al 255
    End_If
EndP
____________________________________________________________________________________________
IsItaCall:
; if the equation is a Call, the result (EAX) is stored in memory and then written in the Destination operand.
    Mov esi EPP_SourceEquation
    .If D$esi = 'Call'
        EPP_Code 'Push ESI|Mov ESI ESP|'

        Mov edi D$EPP_WrittenCode
        While B$esi > EOI | movsb | End_While | Mov B$edi meEOI | inc edi
        Mov D$EPP_WrittenCode edi

        EPP_Code 'SUB ESP 04|{?? ESI-04}|Mov D$? EAX|'
        Mov B$EPP_SourceEquation Space | Mov B$EPP_SourceEquation+1 'D' | Mov B$EPP_SourceEquation+2 memMarker
        lea edi D$EPP_SourceEquation+3 | Call WriteNoMeanLabel | Mov B$edi Space | Mov B$edi+1 EOI

        Call ProcessArrayDestination
        Call StoreResultInFirstOperand

        Mov B$UsedRegisters EPP_ESI
        EPP_FindCodePos 'Call' EPP_CODE_BEGIN EPP_CODE_END
        Call OptimizeEqualPreparserCode eax EPP_CODE_END

        Call TranslateExpressions
        Mov eax &TRUE
    .Else
        Mov eax &FALSE
    .End_If
ret
____________________________________________________________________________________________
Proc ImmediateCodeParser:
    ; Writes the given code at edi.
    ; special chars:
    ;  '||'    => EOI
    ;  '??'    => Writes a new meaningless label
    ;  '?'     => Writes the current meaningless label
    ;  '#n'    => Writes the operand n (1 or 2)
    ;  '#atof' => Writes the address of the AsciiToFloat conversion function (not used)
    ;  '#ftoa' => Writes the address of the FloatToAscii conversion function (not used)
    ;  '#text' => Writes the text pointed by D$EPP_TextPointer (D$EPP_TextPointer points on the opening TextSign)
    ;  '&n'    => Writes a new meaningless label and store it the n-th internal variable
    ;             (0 to 7, See EPP_InternalMeaninglessLabels)
    ;             &7 is used for FPU state adresss (See EqualFirstScan)
    ;  '!n'    => Writes the n-th meaningless label
    ;
    ;
    ;  - the character erased by the security-EOI at the end of the string is
    ;    returned in AL (in case it must be rewritten)
    Arguments @Content
    Uses ecx, esi, edi, ebx

    Mov esi D@Content
    Mov edi D$EPP_WrittenCode
    .While B$esi <> 0
        ...If B$esi = SPC
            Mov B$edi Space | inc edi, esi
        ...Else_If W$esi = '||'
            Mov B$edi EOI | inc edi | add esi 2
        ...Else_If B$esi = '+'
            Mov B$edi plusSign | inc esi,edi
        ...Else_If B$esi = '-'
            Mov B$edi minusSign | inc esi,edi
        ...Else_If B$esi = '|'
            Mov B$edi meEOI | inc edi, esi
        ...Else_If B$esi = ':'
            Mov B$edi colonSign | inc edi, esi
        ...Else_If B$esi = '$'
            Mov B$edi memMarker | inc edi, esi
        ...Else_If B$esi = '&'
            Call CreateNoMeanLabel
            Push edi
                movzx eax B$esi+1 | sub eax '0' | Mov ebx 9 | mul ebx
                lea edi D$EPP_InternalMeaninglessLabels+eax
                Mov B$edi+8 0
                Call WriteNoMeanLabel
            Pop edi
            Call WriteNoMeanLabel
            add esi 2
        ...Else_If B$esi = '!'
            Push esi
                movzx eax B$esi+1 | sub eax '0' | Mov ebx 9 | mul ebx
                lea esi D$EPP_InternalMeaninglessLabels+eax
                While B$esi <> 0 | movsb | End_While
            Pop esi
            add esi 2
        ...Else_If B$esi = '?'
            If B$esi+1 = '?' | Call CreateNoMeanLabel  | inc esi | End_If
            Call WriteNoMeanLabel
            inc esi
        ...Else_If B$esi = '#'
            ..If B$esi+1 <> '#'
                .If D$esi+1 <> 'text'
                    If B$esi+1 = '1'
                        Mov ecx D$EPP_Operand1 | add esi 2
                    Else_If B$esi+1 = '2'
                        Mov ecx D$EPP_Operand2 | add esi 2
                    Else_If D$esi+1 = 'atof'
                        Mov ecx D$EPP_atofAddress  | add esi 5
                    Else_If D$esi+1 = 'ftoa'
                        Mov ecx D$EPP_ftoaAddress  | add esi 5
                    End_If
                    While B$ecx > Space | Mov al B$ecx | Mov B$edi al | inc ecx, edi | End_While
                .Else
                    Mov ecx D$EPP_TextPointer | Mov B$edi TextSign | inc ecx, edi
                    While B$ecx > TextSign | Mov al B$ecx | Mov B$edi al | inc ecx, edi | End_While
                    Mov B$edi TextSign | inc ecx, edi
                    add esi 5
                .End_If
            ..Else
                Mov B$edi numSign | inc edi
                add esi 2
            ..End_If
        ...Else
            movsb
        ...End_If
    .End_While

    Mov al B$edi
    Mov B$edi EOI
    Mov D$EPP_WrittenCode edi

EndP
____________________________________________________________________________________________
Proc ReplaceOperand:
    ; Replaces the given operand by
    ;   - the current meaningless label if D@Replacement = 0
    ;   - the content of D@Replacement if D@Replacement <> 0  (a string of 1,2,3 or 4 characters)
    ; When D@Datatype = 'X', the new operand is prefixed by 'X$' (0 for no prefix)
    ; When D@operand = 0, both operands and their operator will be deleted.
    ; If the position of the second operand has changed and if both operands points into EPP_SourceEquation
    ; then D$EPP_Operand2 is updated.
    ;
    ; ex:  - ReplaceOperand 0 'B' 'ECX' ; => replaces both operands by 'B$ECX'
    ;      - ReplaceOperand 1 'W' 0     ; => replaces the first operand by 'W$AAAAAAAA'
    ;      - ReplaceOperand 2 0 'EDI'   ; => replaces the second operand by 'EDI'
    ;
    Arguments  @operand @DataType @Replacement
    Local @UpdateOperand2
    Uses edi, ecx, esi

    .If D@operand = 2
        Mov edi D$EPP_Operand2
        Mov D@UpdateOperand2 &FALSE
    .Else
        Mov edi D$EPP_Operand1
        Mov ecx D$EPP_Operand2
        If_Or edi < EPP_SourceEquation, edi > EPP_SourceEquation_End,
              ecx < EPP_SourceEquation, ecx > EPP_SourceEquation_End
            Mov D@UpdateOperand2 &FALSE
        Else
            Mov D@UpdateOperand2 &TRUE
        End_If
    .End_If

    Mov ecx 0
    While B$edi > Space | inc edi, ecx | End_While
    If D@operand = 0
        add edi 3 | add ecx 3
        While B$edi > Space | inc edi, ecx | End_While
    End_If

    Call ShiftLineLeft ecx
    sub edi ecx
    On D@UpdateOperand2 = &TRUE, sub D$EPP_Operand2 ecx

    ..If D@Replacement = 0
        If D@DataType <> 0
            On D@UpdateOperand2 = &TRUE, add D$EPP_Operand2 10
            Call ShiftLineRight 10
            Move D$edi D@DataType | Mov B$edi+1 memMarker | add edi 2
            Call WriteNoMeanLabel
        Else
            On D@UpdateOperand2 = &TRUE, add D$EPP_Operand2 8
            Call ShiftLineRight 8
            Call WriteNoMeanLabel
        End_If
    ..Else
        Mov ecx 0 | lea esi D@Replacement
        While B$esi <> 0
            On ecx = 4, jmp L1>
            inc ecx, esi
        End_While
L1:     .If D@DataType <> 0
            add ecx 2
            Call ShiftLineRight ecx
            On D@UpdateOperand2 = &TRUE, add D$EPP_Operand2 ecx
            Mov al B@DataType | Mov B$edi al | Mov B$edi+1 memMarker | add edi 2
        .Else
            Call ShiftLineRight ecx
            On D@UpdateOperand2 = &TRUE, add D$EPP_Operand2 ecx
        .End_If

        lea esi D@Replacement
        Mov ecx 0
        While B$esi <> 0
            On ecx = 4, jmp L1>
            movsb | inc ecx
        End_While
L1:
   ..End_If
EndP
____________________________________________________________________________________________
Proc WriteCodeForTheseParentheses:
    ; ^ then is first searched between the parentheses then * and / and finally + and - (to keep priority)
    ; if nothing is found, we check if there is no space between the parentheses (i.e there is either
    ; an equate or an immediate number (integer or not), and when no space is found the
    ; parentheses are removed, otherwise : error)
    Argument @OpeningParenthesis
    Uses ebx

    Mov eax 0
    Mov ecx D@OpeningParenthesis
    .While B$ecx <> closeSign
        If B$ecx = expSign
            Call GetOperandTypeAndPos ecx
            Call WriteOperationCode expsign &FALSE
            On eax = &TRUE, Call RemoveParentheses
            Mov ecx D@OpeningParenthesis
        End_If
        On eax = &TRUE EndP
        inc ecx
    .End_While

    Mov eax 0
    Mov ecx D@OpeningParenthesis
    .While B$ecx <> closeSign
        If B$ecx = mulSign
            Mov eax &FALSE
            jmp L1>
        Else_If B$ecx = SignedMulSign
            Mov eax &TRUE
L1:         Call GetOperandTypeAndPos ecx
            Call WriteOperationCode mulSign eax
            On eax = &TRUE, Call RemoveParentheses
            Mov ecx D@OpeningParenthesis
        Else_If B$ecx = divSign
            Mov eax &FALSE
            jmp L1>
        Else_If B$ecx = SignedDivSign
            Mov eax &TRUE
L1:         Call GetOperandTypeAndPos ecx
            Call WriteOperationCode divSign eax
            On eax = &TRUE, Call RemoveParentheses
            Mov ecx D@OpeningParenthesis
        End_If
        On eax = &TRUE EndP
        inc ecx
    .End_While


    Mov eax 0
    Mov ecx D@OpeningParenthesis
    .While B$ecx <> closeSign
        If B$ecx = addSign
            Call GetOperandTypeAndPos ecx
            Call WriteOperationCode addsign &FALSE
            On eax = &TRUE, Call RemoveParentheses
            Mov ecx D@OpeningParenthesis
        Else_If B$ecx = subSign
            Call GetOperandTypeAndPos ecx
            Call WriteOperationCode subSign &FALSE
            On eax = &TRUE, Call RemoveParentheses
            Mov ecx D@OpeningParenthesis
        End_If
        On eax = &TRUE, ExitP
        inc ecx
    .End_While


    Mov ecx D@OpeningParenthesis | add ecx 2
    Mov D$EPP_Operand1 ecx
    Mov eax 0

    While B$ecx <> closeSign
        If B$ecx = Space
            On B$ecx+1 <> closeSign, jmp L9>        ; space found => error
        End_If

        On B$ecx = pointSign, Mov eax &TRUE       ; Is this a floating point number

        inc ecx
    End_While

    .If eax = &TRUE
        dec D@OpeningParenthesis
        If D@OpeningParenthesis = EPP_SourceEquation  ; saves the FP number in memory only if there is no more operation.
            EPP_Code '{??:R$ #1}|'
            Call ReplaceOperand 1 'R' 0
        End_If
    .End_If

    Call RemoveParentheses
    If eax = &TRUE
        Mov eax EPP_NO_OPERATION
        ExitP
    End_If

L9:
    Mov eax &FALSE

EndP
____________________________________________________________________________________________
ShiftLineRight:
    ; shift right the line (until EOI) pointed by edi of X bytes.
    Push esi edi ecx
        Mov ecx 1
        While B$edi <> EOI | inc edi ecx | End_While
        Mov esi edi
        Push ecx edi
            add edi D$esp+24
            std
                rep movsb
            cld
        Pop edi ecx
        If ecx <= D$esp+16   ; erase the last EOI(s) if it was not previously overwritten by the shift.
            Mov esi D$esp+16 | sub esi ecx
            Mov ecx 0
            While ecx <= esi | Mov B$edi+ecx Space | inc ecx | End_While
        End_If
    Pop ecx edi esi
ret 4
____________________________________________________________________________________________
Proc ShiftLineLeft:
    ; shift left the line (until EOI) pointed by edi of D@shift bytes.
    Argument @shift
    Local @EndOfLine
    Uses esi edi ecx

    Mov ecx 1
    Mov esi edi
    While B$edi <> EOI | inc edi ecx | End_While | Mov D@EndOfLine edi
    Mov edi esi | sub edi D@shift
    rep movsb

    Mov esi D@EndOfLine | sub esi D@shift | inc esi
    While esi <= D@EndOfLine | Mov B$esi 0 | inc esi | End_While
EndP
____________________________________________________________________________________________
Proc GetOperandTypeAndPos:
    ;The type of each operand is identified and stored in as flags. (See EPP_Types)
    ;BX contains the type of the first operand and DX contains the type of the second one.
    ;The position of the first character of each operand is stored in D$EPP_Operand1 and D$EPP_Operand1
    Argument @OperatorPos
    Uses eax

    Mov ebx 0
    Mov edx 0

    Mov eax D@OperatorPos | sub eax 2
    While B$eax > Space | dec eax | End_While | inc eax | Mov D$EPP_Operand1 eax
    Call GetStringType eax
    Mov bx ax

    Mov eax D@OperatorPos | add eax 2 | Mov D$EPP_Operand2 eax
    Call GetStringType eax
    Mov dx ax

EndP
____________________________________________________________________________________________
Proc WriteOperationCode:
  ; D@OperationType can be divSign,mulSign,addSign or subSign
  ; BX contains the type of the first operand and DX contains the type of the second one. (See GetOperandTypeAndPos)
  ; return &TRUE if code has been written.
  Arguments @OperationType @Signed
  Uses D$DestinationType

    If B$ParsingInsideArray = &TRUE
        Mov D$DestinationType (MemoryOperand or DWordValue)
    End_If

    Test_If_And bx NumericOperand, dx NumericOperand
        Call ComputeImmediateExpression D@OperationType
        Mov eax &FALSE

    Test_Else_If_Not_And bx FloatingPointOperand, dx FloatingPointOperand, D$DestinationType FloatingPointOperand
        Call ReplaceIndirectAddressing
        Call WriteIntegerOperationCode D@OperationType D@Signed
        Mov eax &TRUE

    Test_Else ; at least one operand non-integer
        Call ReplaceIndirectAddressing
        Call WriteFloatingPointOperationCode D@OperationType
        Call StoreFPUResult 0
        Mov eax &TRUE

    Test_End

EndP
____________________________________________________________________________________________
Proc StoreFPUResult:
; The result of the FP operation is either left on the FPU Stack or stored in memory.
; In the first case, the operand is replaced by 'st0' (in lowercase so as to be locatable
; afterwards (see incFPUStackNumber)) otherwise it is replaced by a meaningless label.
    Argument @operand

    If D$FPUStackNumber < 6
        Call ReplaceOperand D@operand 0 'st0'
    Else
        EPP_Code 'SUB ESP 0A|{?? ESI-000}|FSTP T$?|'

        Call ReplaceOperand D@operand 'T' 0
        Call decFPUStackNumber
    End_If

EndP
____________________________________________________________________________________________
; As the temporary FP result are stored in the FPU Stack (ST0-ST6), each time a new result is stored the
; last ones are pushed on the stack. Theses two functions update the temporary FP result on the stack
; by incrementing or decrementing the register number.
; The registers to be updated are identified by the 'st' prefix (instead of 'ST').
Proc incFPUStackNumber:
    Uses ecx

    Mov ecx EPP_SOURCE_BEGIN
    jmp L1>
    While eax <> CODE_NOT_FOUND
        inc B$eax+2 | lea ecx D$eax+1
L1:     EPP_FindCodePos 'st' ecx EPP_SOURCE_END
    End_While
    inc D$FPUStackNumber

EndP
                            __________________________________________________
Proc decFPUStackNumber:
    Uses ecx

    Mov ecx EPP_SOURCE_BEGIN
    jmp L1>
    While eax <> CODE_NOT_FOUND
        dec B$eax+2 | lea ecx D$eax+1
L1:     EPP_FindCodePos 'st' ecx EPP_SOURCE_END
    End_While
    dec D$FPUStackNumber

EndP
____________________________________________________________________________________________
Proc ReplaceIndirectAddressing:
    ; Replaces in EPP_SourceEquation, the operand of this type: 'F$D$AAAAAAA' (which are written when an array is met)
    ; by 'F$ECX' , then the code to Move 'Mov ECX D$AAAAAAAA' is written

    Call ExtractIndirectAddress 1 EPP_ECX
    If eax = &TRUE
        Call ExtractIndirectAddress 2 EPP_EDI
    Else
        Call ExtractIndirectAddress 2 EPP_ECX
    End_If

EndP

____________________________________________________________________________________________
Proc ExtractIndirectAddress:
    ; Extracts the address (which is stored in a memory DWord) of the given operand (1 or 2),
    ; Move it into the given register and then replace the operand.
    ; D@register can be (EPP_EAX,EPP_EBX,EPP_ECX,EPP_EDX,EPP_ESI,EPP_EDI)
    ;
    ; return &FALSE if no extraction was done on the given operand, &TRUE otherwise.
    Argument @Operand @register
    Uses esi, edi, edx

    If D@Operand = 1
        Mov esi D$EPP_Operand1
    Else
        Mov esi D$EPP_Operand2
    End_If

    .If_And B$esi+1 = memMarker, B$esi+2 = 'D', B$esi+3 = memMarker
        EPP_Code 'Mov ' | Call WriteRegister D@Register | Mov edx eax
        Push D$EPP_Operand1
            Mov D$EPP_Operand1 esi | add D$EPP_Operand1 2
            EPP_Code ' #1|'
        Pop D$EPP_Operand1

        Call ReplaceOperand D@Operand D$esi edx
        Mov eax &TRUE
    .Else
        Mov eax &FALSE
    .End_If

EndP
____________________________________________________________________________________________
Proc WriteRegister:
    Argument @register

    If D@register = EPP_EAX
        EPP_CODE 'EAX'
        Mov eax 'EAX'
    Else_If D@register = EPP_EBX
        EPP_CODE 'EBX'
        Mov eax 'EBX'
    Else_If D@register = EPP_ECX
        EPP_CODE 'ECX'
        Mov eax 'ECX'
    Else_If D@register = EPP_EDX
        EPP_CODE 'EDX'
        Mov eax 'EDX'
    Else_If D@register = EPP_ESI
        EPP_CODE 'ESI'
        Mov eax 'ESI'
    Else_If D@register = EPP_EDI
        EPP_CODE 'EDI'
        Mov eax 'EDI'
    End_If
EndP
____________________________________________________________________________________________
Proc WriteAddressingCode:
    ; Writes the code which is before an array. Basically this translate F$Array(6) to F$Array+6*4
    Argument @DataType


    .If B@DataType = 'T'
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EAX #1|Mov EBX 10|MUL EBX|SUB ESP 04|{?? ESI-000}|Mov D$? EAX|'
    .Else_If B@DataType = 'R'
        EPP_Code 'Mov EAX #1|SHL EAX 3|SUB ESP 04|{?? ESI-000}|Mov D$? EAX|'
    .Else_If B@DataType = 'F'
        EPP_Code 'Mov EAX #1|SHL EAX 2|SUB ESP 04|{?? ESI-000}|Mov D$? EAX|'
    .Else_If B@DataType = 'B'
        EPP_Code 'Mov EAX #1|SUB ESP 04|{?? ESI-000}|Mov D$? EAX|'
    .Else_If B@DataType = 'D'
        EPP_Code 'Mov EAX #1|SHL EAX 2|SUB ESP 04|{?? ESI-000}|Mov D$? EAX|'
    .Else_If B@DataType = 'W'
        EPP_Code 'Mov EAX #1|SHL EAX 1|SUB ESP 04|{?? ESI-000}|Mov D$? EAX|'
    .Else_If B@DataType = 'Q'
        EPP_Code 'Mov EAX #1|SHL EAX 3|SUB ESP 04|{?? ESI-000}|Mov D$? EAX|'
    .End_If

    add D$EPP_Operand2 2 | EPP_Code 'ADD D$? #2|' | sub D$EPP_Operand2 2
    Call ReplaceOperand 1 'D' 0
EndP
____________________________________________________________________________________________
Proc RemoveParentheses:
    ; Return &TRUE if the two parentheses surrounding EPP_Operand1 have been removed from EPP_SourceEquation,
    ; &FALSE otherwise.
    Uses edi, ecx

    Mov eax &FALSE
    Mov edi D$EPP_Operand1

    .If B$edi-2 = openSign
        Mov ecx 0
        While B$edi+ecx > Space | inc ecx | End_While | dec ecx
        If B$edi+ecx+2 = closeSign
            Call ShiftLineLeft 2
            lea edi D$edi+ecx+(3-2)
            Call ShiftLineLeft 2
            Mov eax &TRUE    ; the parentheses have been removed
        End_If
    .End_If

EndP
____________________________________________________________________________________________
TranslateExpressions:
    ; This part converts characters used by the preparser to RosAsm characters.
    ; It is called once all modifications of the code have been performed.
    Mov ecx D$EPP_CodeBegining
    .While B$ecx <> EOI
        If B$ecx = plusSign
            Mov B$ecx addSign
        Else_If B$ecx = minusSign
            Mov B$ecx subSign
        Else_If B$ecx = pointSign
            Mov B$ecx '.'
        Else_If B$ecx =  addressSign
            Mov B$ecx mulSign
        Else_If W$ecx = 'st'
            Mov W$ecx 'ST'
        Else_If B$ecx = TextSign
            inc ecx | While B$ecx <> TextSign | inc ecx | End_While
        End_If
        inc ecx
    .End_While

ret
____________________________________________________________________________________________
Proc IntegerDivisionCode_DWORD_Destination:
    Arguments @Symb_S @Symb_I

    ; >> DWORD Destination
    or B$UsedRegisters EPP_EDX
    .Test_If_And bx ConstantOperand, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EDX 0|Mov EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And bx ConstantOperand, dx WordValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EDX 0|Mov EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And bx ConstantOperand, dx DWordValue
        EPP_Code 'Mov EDX 0|Mov EAX #1|' D@Symb_I 'DIV #2|'
    .Test_Else_If_And bx Word, dx DWordValue
        EPP_Code 'Mov EDX 0|Mov' D@Symb_S 'X EAX #1|' D@Symb_I 'DIV #2|'
    .Test_Else_If_And bx Word, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EDX 0|Mov' D@Symb_S 'X EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And bx DWord, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EDX 0|Mov EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'

    .Test_Else_If_And bx ByteValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EDX 0|Mov' D@Symb_S 'X EAX #1|Mov EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And bx WordValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EDX 0|Mov' D@Symb_S 'X EAX #1|Mov EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And  bx DWordValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EDX 0|Mov EAX #1|Mov EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And  bx DWordValue, dx Word
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EDX 0|Mov EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And  bx ByteValue, dx Word
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EDX 0|Mov' D@Symb_S 'X EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And  bx ByteValue, dx DWord
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EDX 0|Mov' D@Symb_S 'X EAX #1|' D@Symb_I 'DIV #2|'

    .Test_Else_If_And bx ByteValue, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EDX 0|Mov' D@Symb_S 'X EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And bx WordValue, dx WordValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EDX 0|Mov' D@Symb_S 'X EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And bx DWordValue, dx DWordValue
        EPP_Code 'Mov EDX 0|Mov EAX #1|' D@Symb_I 'DIV #2|'
    .Test_End
    Mov eax DWordValue
EndP
____________________________________________________________________________________________
Proc IntegerMultiplicationCode_DWORD_Destination:
    Arguments @Symb_S @Symb_I

    ; >> DWORD Destination
    or B$UsedRegisters EPP_EDX
    .Test_If_And bx ConstantOperand, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And bx ConstantOperand, dx WordValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And bx ConstantOperand, dx DWordValue
        EPP_Code 'Mov EAX #1|' D@Symb_I 'MUL #2|'
    .Test_Else_If_And bx Word, dx DWordValue
        EPP_Code 'Mov' D@Symb_S 'X EAX #1|' D@Symb_I 'MUL #2|'
    .Test_Else_If_And bx Word, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov' D@Symb_S 'X EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And bx DWord, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'

    .Test_Else_If_And bx ByteValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov' D@Symb_S 'X EAX #1|Mov EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And bx WordValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov' D@Symb_S 'X EAX #1|Mov EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And  bx DWordValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EAX #1|Mov EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And  bx DWordValue, dx Word
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And  bx ByteValue, dx Word
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov' D@Symb_S 'X EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And  bx ByteValue, dx DWord
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov' D@Symb_S 'X EAX #1|' D@Symb_I 'MUL #2|'

    .Test_Else_If_And bx ByteValue, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov' D@Symb_S 'X EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And bx WordValue, dx WordValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov' D@Symb_S 'X EAX #1|Mov' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And bx DWordValue, dx DWordValue
        EPP_Code 'Mov EAX #1|' D@Symb_I 'MUL #2|'
    .Test_End
    Mov eax DWordValue
EndP
____________________________________________________________________________________________
Proc IntegerDivisionCode_WORD_Destination:
    Arguments @Symb_S @Symb_I

    ; >> WORD Destination
    .Test_If_And bx ConstantOperand, dx ByteValue
        EPP_Code 'Mov AX #1|' D@Symb_I 'DIV #2|'
        Mov eax ByteValue
    .Test_Else_If_And bx ConstantOperand, dx WordValue
        or B$UsedRegisters EPP_EDX
        EPP_Code 'Mov EDX 0|Mov AX #1|' D@Symb_I 'DIV #2|'
        Mov eax WordValue
    .Test_Else_If_And bx ConstantOperand, dx DWordValue
        ; error
    .Test_Else_If_And bx Word, dx DWordValue
        ; error
    .Test_Else_If_And bx Word, dx ByteValue
        EPP_Code 'Mov AX #1|' D@Symb_I 'DIV #2|'
        Mov eax ByteValue
    .Test_Else_If_And bx DWord, dx ByteValue
        ; error

    .Test_Else_If_And bx ByteValue, dx ConstantOperand
        or B$UsedRegisters (EPP_EBX or EPP_EDX)
        EPP_Code 'Mov EDX 0|Mov' D@Symb_S 'X AX #1|Mov BX #2|' D@Symb_I 'DIV BX|'
        Mov eax WordValue
    .Test_Else_If_And bx WordValue, dx ConstantOperand
        or B$UsedRegisters (EPP_EBX or EPP_EDX)
        EPP_Code 'Mov EDX 0|Mov AX #1|Mov BX #2|' D@Symb_I 'DIV BX|'
        Mov eax WordValue
    .Test_Else_If_And  bx DWordValue, dx ConstantOperand
        ; error
    .Test_Else_If_And  bx DWordValue, dx Word
        or B$UsedRegisters (EPP_EBX or EPP_EDX)
        EPP_Code 'LEA EAX #1|Mov DX W$EAX+2|Mov AX W$EAX|' D@Symb_I 'DIV #2|'
        Mov eax WordValue
    .Test_Else_If_And  bx ByteValue, dx Word
        or B$UsedRegisters EPP_EDX
        EPP_Code 'Mov EDX 0|Mov' D@Symb_S 'X AX #1|' D@Symb_I 'DIV #2|'
        Mov eax WordValue
    .Test_Else_If_And  bx ByteValue, dx DWord
        ; error

    .Test_Else_If_And bx ByteValue, dx ByteValue
        EPP_Code 'Mov' D@Symb_S 'X AX #1|' D@Symb_I 'DIV #2|'
        Mov eax ByteValue
    .Test_Else_If_And bx WordValue, dx WordValue
        or B$UsedRegisters EPP_EDX
        EPP_Code 'Mov EDX 0|Mov AX #1|' D@Symb_I 'DIV #2|'
        Mov eax WordValue
    .Test_Else_If_And bx DWordValue, dx DWordValue
        ; error
    .Test_End

EndP
____________________________________________________________________________________________
Proc IntegerMultiplicationCode_WORD_Destination:
    Arguments @Symb_S @Symb_I

    ; >> WORD Destination
    .Test_If_And bx ConstantOperand, dx ByteValue
        EPP_Code 'Mov AL #1|' D@Symb_I 'MUL #2|'
        Mov eax WordValue
    .Test_Else_If_And bx ConstantOperand, dx WordValue
        or B$UsedRegisters EPP_EDX
        EPP_Code 'Mov AX #1|' D@Symb_I 'MUL #2|'
        Mov eax WordValue
    .Test_Else_If_And bx ConstantOperand, dx DWordValue
        ; error
    .Test_Else_If_And bx Word, dx DWordValue
        ; error
    .Test_Else_If_And bx Word, dx ByteValue
        or B$UsedRegisters EPP_EDX
        EPP_Code 'Mov' D@Symb_S 'X AX #2|' D@Symb_I 'MUL #1|'
        Mov eax WordValue
    .Test_Else_If_And bx DWord, dx ByteValue
        ; error

    .Test_Else_If_And bx ByteValue, dx ConstantOperand
        EPP_Code 'Mov AL #2|' D@Symb_I 'MUL #1|'
        Mov eax WordValue
    .Test_Else_If_And bx WordValue, dx ConstantOperand
        or B$UsedRegisters EPP_EDX
        EPP_Code 'Mov AX #2|' D@Symb_I 'MUL #1|'
        Mov eax WordValue
    .Test_Else_If_And  bx DWordValue, dx ConstantOperand
        ; error
    .Test_Else_If_And  bx DWordValue, dx Word
        ; error
    .Test_Else_If_And  bx ByteValue, dx Word
        or B$UsedRegisters EPP_EDX
        EPP_Code 'Mov' D@Symb_S 'X AX #1|' D@Symb_I 'MUL #2|'
        Mov eax WordValue
    .Test_Else_If_And  bx ByteValue, dx DWord
        ; error

    .Test_Else_If_And bx ByteValue, dx ByteValue
        EPP_Code 'Mov AL #1|' D@Symb_I 'MUL #2|'
        Mov eax WordValue
    .Test_Else_If_And bx WordValue, dx WordValue
        or B$UsedRegisters EPP_EDX
        EPP_Code 'Mov AX #1|' D@Symb_I 'MUL #2|'
        Mov eax WordValue
    .Test_Else_If_And bx DWordValue, dx DWordValue
        ; error
    .Test_End

EndP
____________________________________________________________________________________________
Proc IntegerDivisionCode_BYTE_Destination:
    Arguments @Symb_S @Symb_I

    ; >> BYTE Destination
    .Test_If_And bx ConstantOperand, dx ByteValue
        EPP_Code 'Mov AX #1|' D@Symb_I 'DIV #2|'
        Mov eax ByteValue
    .Test_Else_If_And bx ConstantOperand, dx WordValue
        ; error
    .Test_Else_If_And bx ConstantOperand, dx DWordValue
                                                                                                                                                                                                                                                                                                                                                                                                                                        ; error
    .Test_Else_If_And bx Word, dx DWordValue
        ; error
    .Test_Else_If_And bx Word, dx ByteValue
        EPP_Code 'Mov AX #1|' D@Symb_I 'DIV #2|'
        Mov eax ByteValue
    .Test_Else_If_And bx DWord, dx ByteValue
        ; error

    .Test_Else_If_And bx ByteValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov' D@Symb_S 'X AX #1|Mov BL #2|' D@Symb_I 'DIV BL|'
        Mov eax ByteValue
    .Test_Else_If_And bx WordValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov AX #1|Mov BL #2|' D@Symb_I 'DIV BL|'
        Mov eax ByteValue
    .Test_Else_If_And  bx DWordValue, dx ConstantOperand
        ; error
    .Test_Else_If_And  bx DWordValue, dx Word
        ; error
    .Test_Else_If_And  bx ByteValue, dx Word
        ; error
    .Test_Else_If_And  bx ByteValue, dx DWord
        ; error

    .Test_Else_If_And bx ByteValue, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'Mov' D@Symb_S 'X AX #1||' D@Symb_I 'DIV #2|'
        Mov eax ByteValue
    .Test_Else_If_And bx WordValue, dx WordValue
        ; error '
    .Test_Else_If_And bx DWordValue, dx DWordValue
        ; error
    .Test_End

EndP
____________________________________________________________________________________________
Proc WriteIntegerOperationCode:
    ; BX contains the type of the first operand and DX contains the type of the second one.
    ; D@Symb_I and D@Symb_S contain the letters which changes in mnemonics from a signed to
    ; an unsigned operation. This way, no further test of the sign is needed.
    Arguments @OperationType @Signed
    Local @Symb_I @Symb_S @OperationString
    Uses ecx, esi

    If D@Signed = &TRUE
        Mov D@Symb_I 'I'
        Mov D@Symb_S 'S'
    Else
        Mov D@Symb_I ''
        Mov D@Symb_S 'Z'
    End_If

    Mov eax 0_FF00_0000 ; error check

    .If D@OperationType = divSign
        or B$UsedRegisters EPP_EAX
        Test_If D$DestinationType DWordValue
            Call IntegerDivisionCode_DWORD_Destination D@Symb_S D@Symb_I

        Test_Else_If D$DestinationType WordValue
            Call IntegerDivisionCode_WORD_Destination D@Symb_S D@Symb_I

        Test_Else D$DestinationType ByteValue
            Call IntegerDivisionCode_BYTE_Destination D@Symb_S D@Symb_I

        Test_End

    ; >> MULTIPLICATION
    .Else_If D@OperationType = mulSign
        or B$UsedRegisters EPP_EAX
        Test_If D$DestinationType DWordValue
            Call IntegerMultiplicationCode_DWORD_Destination D@Symb_S D@Symb_I

        Test_Else_If D$DestinationType WordValue
            Call IntegerMultiplicationCode_WORD_Destination D@Symb_S D@Symb_I

        Test_Else D$DestinationType ByteValue
            ; error

        Test_End

    ; >> POWER
    .Else_If D@OperationType = expSign
        or B$UsedRegisters (EPP_EAX or EPP_EBX or EPP_ECX)
        Mov cx 0 | Test_If_Not_And bx DWordValue, bx ConstantOperand | Mov cl B@Symb_S | Mov ch 'X' | Test_End
        Test_If dx DWordValue
            Mov esi 'ECX'
        Test_Else_If dx WordValue
            Mov esi 'CX'
        Test_Else_If dx WordValue
            Mov esi 'CL'
        Test_Else ; constant
            Mov esi 'ECX'
        Test_End

        EPP_Code 'Mov ECX 0|Mov EAX 1|Mov' cx ' EBX #1|&1:|CMP ' esi ' #2|JE &2|'
        EPP_Code  D@Symb_I 'MUL EBX|INC ECX|JMP !1|!2:|'

        Mov eax DWordValue

    ; >> ADDITION AND SUBSTRACTION
    .Else_If_Or D@OperationType = addSign, D@OperationType = subSign
        or B$UsedRegisters EPP_EAX
        If D@OperationType = addSign
            Mov D@OperationString 'ADD'
        Else
            Mov D@OperationString 'SUB'
        End_If
        Mov cx 0
        .Test_If D$DestinationType DWordValue
            Test_If_Not_And bx DWordValue, bx ConstantOperand | Mov cl B@Symb_S | Mov ch 'X' | Test_End
            EPP_Code 'Mov' cx ' EAX #1|' D@OperationString ' EAX #2|'
            Mov eax DWordValue

        .Test_Else_If D$DestinationType WordValue
            Test_If_Not_And  bx WordValue, bx ConstantOperand | Mov cl B@Symb_S | Mov ch 'X' | Test_End
            EPP_Code 'Mov' cx ' AX #1|' D@OperationString ' AX #2|'
            Mov eax WordValue

        .Test_Else_If D$DestinationType ByteValue
            EPP_Code 'Mov AL #1|' D@OperationString ' AL #2|'
            Mov eax ByteValue

        .Test_End

    .End_If

    ; stores result in memory
    .If eax = DWordValue
        EPP_Code 'SUB ESP 04|{?? ESI-000}|Mov D$? EAX|'
        Call ReplaceOperand 0 'D' 0
    .Else_If eax = WordValue
        EPP_Code 'SUB ESP 02|{?? ESI-000}|Mov W$? AX|'
        Call ReplaceOperand 0 'W' 0
    .Else_If eax = ByteValue
        EPP_Code 'SUB ESP 01|{?? ESI-000}|Mov B$? AL|'
        Call ReplaceOperand 0 'B' 0
    .Else
        error EqualPreparser_SourceInvalid
    .End_If

EndP
____________________________________________________________________________________________
Proc WriteFloatingPointOperationCode:
    ; Writing of data loading according to its type.
    ; BX contains the type of the first operand and DX contains the type of the second one.
    Arguments @OperationType

    ; copy integers registers into memory and change the operand type to MemoryOperand
    ..Test_If bx RegisterOperand
        .Test_If_Not bx FloatingPointOperand
            and bx ((not RegisterOperand) and 0_FFFF)
            or bx MemoryOperand
            Test_If_Not bx DWordValue
                Call ExtendOperandToDWord 1 MemoryOperand
            Test_Else
                EPP_Code 'SUB ESP 04|{?? ESI-000}|Mov D$? #1|'
                Call ReplaceOperand 1 'D' 0
            Test_End
        .Test_End
    ..Test_End

    ..Test_If dx RegisterOperand
        .Test_If_Not dx FloatingPointOperand
            and dx ((not RegisterOperand) and 0_FFFF)
            or dx MemoryOperand
            Test_If_Not dx DWordValue
                Call ExtendOperandToDWord 1 MemoryOperand
            Test_Else
                EPP_Code 'SUB ESP 04|{?? ESI-000}|Mov D$? #2|'
                Call ReplaceOperand 2 'D' 0
            Test_End
        .Test_End
    ..Test_End


    ...Test_If_Not_And bx FloatingPointOperand, dx FloatingPointOperand
        ; only when the result is FP
        ..Test_If_Not_And bx ConstantOperand, dx ConstantOperand
            EPP_Code 'FILD #1|' | Call incFPUStackNumber
            Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_IntegerOperand
        ..Test_Else_If_And bx ConstantOperand, dx ConstantOperand
            EPP_Code '{??:R$ #1}|FLD R$?|{??:R$ #2}|FLD R$?|' | Call incFPUStackNumber
            Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST1_ST0
        ..Test_Else_If bx ConstantOperand
            EPP_Code '{??:R$ #1}|FLD R$?|' | Call incFPUStackNumber
            Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_IntegerOperand
        ..Test_Else
            EPP_Code '{??:R$ #2}|FLD R$?|' | Call incFPUStackNumber
            Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_IntegerOperand_ST0
        ..Test_End

    ...Test_Else_If bx ConstantOperand
        ..Test_If dx FloatingPointOperand
            ; #1 constant / #2 Floating Point
            ; ex: ( 51 - R$float1 )
            EPP_Code '{??:R$ #1}|'

            .Test_If dx TByteValue
                Test_If_Not dx RegisterOperand | EPP_Code 'FLD #2|' | Test_End
                Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ConstantOperand_ST0
            .Test_Else
                EPP_Code 'FLD R$?|' | Call incFPUStackNumber
                Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_FloatingPointOperand
            .Test_End
        ..Test_Else
            ; #1 constant / #2 integer
            ; ex: ( 7.4 + D$val1 )
            EPP_Code '{??:R$ #1}|FLD R$?|' | Call incFPUStackNumber
            Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_IntegerOperand
        ..Test_End

    ...Test_Else_If dx ConstantOperand
        ..Test_If bx FloatingPointOperand
            ; #1 Floating Point / #2 constant
            ; ex: ( T$float2 / 8 )
            EPP_Code '{??:R$ #2}|'

            .Test_If bx TByteValue
                Test_If_Not bx RegisterOperand | EPP_Code 'FLD #1|' | Test_End
                Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_ConstantOperand
            .Test_Else
                EPP_Code 'FLD R$?|' | Call incFPUStackNumber
                Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_FloatingPointOperand_ST0
            .Test_End
        ..Test_Else
            ; #1 integer / #2 constant
            ; ex: ( D$val1 + 7.4 )
            EPP_Code '{??:R$ #2}|FLD R$?|' | Call incFPUStackNumber
            Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_IntegerOperand_ST0
        ..Test_End

    ...Test_Else ; Both operand non-constant :
        ..Test_If_Not bx FloatingPointOperand
            ; #1 integer / #2 Floating Point
            ; ex: ( D$val2 * F$float2 )
            Test_If_Not dx RegisterOperand | EPP_Code 'FLD #2|' | Call incFPUStackNumber | Test_End
            Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_IntegerOperand_ST0

        ..Test_Else_If_Not dx FloatingPointOperand
            ; #1 Floating Point / #2 integer
            ; ex: ( R$float1 - W$val3 )
            Test_If_Not bx RegisterOperand | EPP_Code 'FLD #1|' | Call incFPUStackNumber | Test_End
            Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_IntegerOperand

        ..Test_Else
            ; #1 Floating Point / #2 Floating Point
            ; ex: ( R$float2 + F$float5 )

            .Test_If_And bx TByteValue, dx TByteValue
                Test_If_And bx RegisterOperand, dx RegisterOperand
                    Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST1_ST0
                Test_Else_If dx RegisterOperand
                    EPP_Code 'FLD #1|' | Call incFPUStackNumber
                    Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_ST1
                Test_Else_If bx RegisterOperand
                    EPP_Code 'FLD #2|' | Call incFPUStackNumber
                    Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST1_ST0
                Test_Else
                    EPP_Code 'FLD #1|FLD #2|' | Call incFPUStackNumber
                    Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST1_ST0
                Test_End

            .Test_Else_If bx TByteValue
                Test_If_Not bx RegisterOperand | EPP_Code 'FLD #1|' | Call incFPUStackNumber | Test_End
                Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_FloatingPointOperand

            .Test_Else_If dx TByteValue
                Test_If_Not dx RegisterOperand | EPP_Code 'FLD #2|' | Call incFPUStackNumber | Test_End
                Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_FloatingPointOperand_ST0

            .Test_Else
                EPP_Code 'FLD #1|' | Call incFPUStackNumber
                Call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_FloatingPointOperand

            .Test_End

        ..Test_End
    ...Test_End

EndP
____________________________________________________________________________________________
Proc StoreResultInFirstOperand:
  ; This function store the result of the operations in the destination operand.
    Uses edx, esi, edi

    Mov edi EPP_SourceEquation
    Mov ebx EPP_DestOperand
    Mov D$EPP_Operand1 EPP_SourceEquation | inc D$EPP_Operand1
    Mov D$EPP_Operand2 EPP_DestOperand

    If D$DestinationArrayRegister = EPP_ECX
        Mov edx EPP_EDI
    Else_If D$DestinationArrayRegister = EPP_EDI
        Mov edx EPP_ECX
    Else
        Mov edx EPP_EDI
    End_If
    Call ExtractIndirectAddress 1 edx
    If eax = &TRUE
        or B$UsedRegisters dl
    End_If

    If_And W$ebx = 'SI', B$ebx+2 < Separators
        Mov D$ebx 'W$ES', B$ebx+1 memMarker, B$ebx+4 'I', B$ebx+5 plusSign, B$ebx+6 '4', B$ebx+7 Space
    Else_If_And W$ebx = 'ES', B$ebx+2 = 'I', B$ebx+3 < Separators
        Mov D$ebx 'D$ES', B$ebx+1 memMarker, B$ebx+4 'I', B$ebx+5 plusSign, B$ebx+6 '4', B$ebx+7 Space
    End_If

    Mov D$EPP_LastStorageStatement_InMemory StrNull
    Mov D$EPP_LastStorageStatement          StrNull

    .If B$ebx+1 = memMarker
        Call StoreInMemory
    .Else_If B$ebx+2 = Space
        ; 2 characters destination
        If B$ebx+1 = 'H'
            jmp L1>
        Else_If B$ebx+1 = 'L'
L1:         Call StoreIn8BitsRegister
        Else
            Call StoreIn16BitsRegister
        End_If
        Call GetRegister ebx | not al | and B$UsedRegisters al
    .Else_If B$ebx+3 = Space
        ; 3 characters destination
        If B$ebx = 'E'
            Call StoreIn32BitsRegister
            Call GetRegister ebx | not al | and B$UsedRegisters al
        Else_If W$ebx = 'ST'
            Call StoreInFPURegister
        End_If
    .Else
        error EqualPreparser_DestInvalid
    .End_If

    EPP_Code 'Pop EDX|Pop EBX|Pop EAX|Pop ECX|Pop EDI|'
    Call ImmediateCodeParser D$EPP_LastStorageStatement_InMemory
    EPP_Code  'Mov ESP ESI|Pop ESI|'
    Call ImmediateCodeParser D$EPP_LastStorageStatement
EndP
____________________________________________________________________________________________
Proc GetRegister:
    Argument @RegisterPos
    Uses esi

    Mov esi D@RegisterPos
    On B$esi = 'E', inc esi

    If B$esi = 'A'
        Mov eax EPP_EAX
    Else_If B$esi = 'B'
        Mov eax EPP_EBX
    Else_If B$esi = 'C'
        Mov eax EPP_ECX
    Else_If W$esi = 'DI'
        Mov eax EPP_EDI
    Else_If W$esi = 'SI'
        Mov eax EPP_ESI
    Else_If B$esi = 'D'
        Mov eax EPP_EDX
    End_If

EndP
____________________________________________________________________________________________
Proc ExtendOperandToDWord:
    Argument @Operand @type
    or B$UsedRegisters EPP_EAX

    .If D@Operand = 1
        If D@type = MemoryOperand
            EPP_Code 'SUB ESP 04|{?? ESI-000}|MOVZX EAX #1|Mov D$? EAX|'
            Call ReplaceOperand 1 'D' 0
        Else
            EPP_Code 'MOVZX EAX #1|' | Call ReplaceOperand 1 0 'EAX'
        End_If
    .Else
        If D@type = MemoryOperand
            EPP_Code 'SUB ESP 04|{?? ESI-000}|MOVZX EAX #2|Mov D$? EAX|'
            Call ReplaceOperand 2 'D' 0
        Else
            EPP_Code 'MOVZX EAX #2|' | Call ReplaceOperand 2 0 'EAX'
        End_If
    .End_If

EndP
____________________________________________________________________________________________
Proc WriteFloatingOperationInstruction:
    Arguments @OperationType @OperandsType

    .Test_If D@OperandsType EqualPreparser_ST1_ST0
        .If D@OperationType = addSign
            EPP_Code 'FADDP ST1 ST0|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FSUBP ST1 ST0|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FMULP ST1 ST0|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FDIVP ST1 ST0|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FXCH|'
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else_If D@OperandsType EqualPreparser_ST0_ST1
        .If D@OperationType = addSign
            EPP_Code 'FADDP ST1 ST0|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FSUBRP ST1 ST0|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FMULP ST1 ST0|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FDIVRP ST1 ST0|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else_If D@OperandsType EqualPreparser_IntegerOperand_ST0
        .If D@OperationType = addSign
            EPP_Code 'FIADD #1|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FISUBR #1|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FIMUL #1|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FIDIVR #1|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FILD #1|'
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else_If D@OperandsType EqualPreparser_ST0_IntegerOperand
        .If D@OperationType = addSign
            EPP_Code 'FIADD #2|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FISUB #2|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FIMUL #2|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FIDIV #2|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FILD #2|FXCH|'
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else_If D@OperandsType EqualPreparser_FloatingPointOperand_ST0
        .If D@OperationType = addSign
            EPP_Code 'FADD #1|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FSUBR #1|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FMUL #1|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FDIVR #1|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FLD #1|'
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else_If D@OperandsType EqualPreparser_ST0_FloatingPointOperand
        .If D@OperationType = addSign
            EPP_Code 'FADD #2|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FSUB #2|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FMUL #2|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FDIV #2|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FLD #2|FXCH|'
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else_If D@OperandsType EqualPreparser_ConstantOperand_ST0
        .If D@OperationType = addSign
            EPP_Code 'FADD R$?|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FSUBR R$?|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FMUL R$?|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FDIVR R$?|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FLD R$?|'
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else_If D@OperandsType EqualPreparser_ST0_ConstantOperand
        .If D@OperationType = addSign
            EPP_Code 'FADD R$?|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FSUB R$?|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FMUL R$?|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FDIV R$?|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FLD R$?|FXCH|'
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else
        error EqualPreParser_UnexpectedError
    .Test_End

EndP
____________________________________________________________________________________________
Proc IntegratedFunctionManagement:
    ; This handle Arrays and functions, respectively manged by WriteArrayCode and WriteFunctionCode
    ; At this point, if we have: _FUNCTION_PARAMETER_
    ; D@OpeningParenthesis points on PARAMETER.
    ; #1 is set on PARAMETER and #2 is set on FUNCTION
    Argument @OpeningParenthesis
    Local @FunctionNamePos @ParameterNamePos @FunctionNameLength
    Uses ebx, ecx, edi

    Mov ebx D@OpeningParenthesis
    Mov D$EPP_Operand1 ebx
    Mov D@ParameterNamePos ebx

    dec ebx | On ebx = EPP_SourceEquation, ExitP   ; Exit if no function name in front of the parenthesis
    On B$ebx-1 <= openSign, ExitP                  ;

    Mov D@FunctionNameLength 0
    lea ecx D$ebx-1 | While B$ecx > Space | dec ecx | inc D@FunctionNameLength | End_While
    inc ecx | Mov D@FunctionNamePos ecx | inc D@FunctionNameLength

    Mov D$EPP_Operand2 ecx
    If B$ecx+1 = memMarker ; Arrays
        Call WriteArrayCode D@FunctionNamePos D@ParameterNamePos D@FunctionNameLength

    Else ; ex: _COS_F$VAL1_
        Call WriteFunctionCode D@FunctionNamePos D@FunctionNameLength

    End_If

EndP
____________________________________________________________________________________________
Proc WriteArrayCode:
    Arguments @ArrayNamePos @ParameterNamePos @FunctionNameLength
    ; we have: _X$ARRAY_PARAMETER_
    ; #1 points on PARAMETER and #2 points on X$ARRAY

    Mov ecx D@ArrayNamePos
    Mov ebx D@ParameterNamePos

    Call GetStringType D$EPP_Operand1
    ..Test_If ax MemoryOperand ; _F$TBL_D$AAAAAAAA_ ;  _F$_D$MyVal
        If_Or B$ebx = 'B', B$ebx = 'W'
            Call ExtendOperandToDWord 1 RegisterOperand | jmp L1>
        Else_If B$ebx = 'D'
L1:         On B$ecx+2 <> Space, Call WriteAddressingCode D$ecx
            Call EraseArrayName D@FunctionNameLength

        Else ; index is not an integer
             error EqualPreparser_InvalidIndex
        End_If

    ..Test_Else_If ax RegisterOperand  ; _F$ARRAY_ECX_
        If B$ecx+2 <> Space ; if not an expression
            On B$ecx = 'T', jmp L1<<
            Mov B$ebx-1 plusSign
            Test_If ax DWordValue
                lea edi D$ebx+3 | Call shiftLineRight 2         ; _F$ARRAY_ECX_  => _F$ARRAY+ECX*4_
                Mov B$ebx+3 addressSign
                Call GetAddressingCoef ecx | Mov B$ebx+4 al
            Test_Else
                lea edi D$ebx+2 | Call shiftLineRight 2         ; _W$ARRAY_CL_   => _W$ARRAY+CL*2_
                Mov B$ebx+2 addressSign
                Call GetAddressingCoef ecx | Mov B$ebx+3 al
            Test_End
        Else ; F$_ECX  ; D$_EDI
            Mov edi ebx | Call shiftLineLeft 1
        End_If

    ..Test_Else_If ax NumericOperand  ; _F$ARRAY_2_
        .If B$ecx+2 <> Space ; if not an expression
            On B$ecx = 'T', jmp L1<<
            If B$ebx-2 <> plusSign                     ; first step  : _F$ARRAY_13_ => _F$ARRAY+_(_13_*_4_)_
                Mov B$ebx-1 plusSign
                Mov edi ebx | Call shiftLineRight 3
                Mov B$ebx Space | Mov B$ebx+1 openSign | Mov B$ebx+2 Space

                add ebx 3 | While B$ebx > Space | inc ebx | End_While | inc ebx

                Mov edi ebx | Call shiftLineRight 6

                Mov B$ebx mulSign | Mov B$ebx+1 Space | Call GetAddressingCoef ecx | Mov B$ebx+2 al
                Mov B$ebx+3 Space | Mov B$ebx+4 closeSign | Mov B$ebx+5 Space

            Else                                       ; second step : _F$ARRAY+_52_ => _F$ARRAY+52_
                Mov edi ebx | Call shiftLineLeft 1
            End_If
        .Else ; F$_1  ; D$_2254
            error EqualPreparser_InvalidAddress
        .End_If

    ..Test_Else
        error EqualPreparser_InvalidIndex

    ..Test_End

EndP
____________________________________________________________________________________________
Proc EraseArrayName:
    Argument @FunctionNameLength

    Mov edi D$EPP_Operand1
    Mov ecx D@FunctionNameLength | sub ecx 2
    Call ShiftLineLeft ecx

EndP
____________________________________________________________________________________________
Proc LoadOperandOnTOS:
    ;This writes the code which load the D@Operand (1 or 2) on the Top of the FPU Stack.
    Arguments @Operand
    Uses ebx, ecx

    If D@Operand = 1
        Mov ebx D$EPP_Operand1
        Mov cx '#1'
    Else
        Mov ebx D$EPP_Operand2
        Mov cx '#2'
    End_If

    .If B$ebx+1 = memMarker
        If_Or B$ebx = 'T', B$ebx = 'F', B$ebx = 'R'
            EPP_Code 'FLD ' cx '|' | Call incFPUStackNumber
        Else_If B$ebx = 'B'
            Call ExtendOperandToDWord 1 MemoryOperand
            EPP_Code 'FILD ' cx '|' | Call incFPUStackNumber
        Else  ;  others integer
            EPP_Code 'FILD ' cx '|' | Call incFPUStackNumber
        End_If
    .Else_If W$ebx = 'st'
        ; result is already on TOS

    .Else ; constant
        Call IsARegister ebx
        Test_If ax (ByteValue or WordValue)
            Call ExtendOperandToDWord 1 MemoryOperand
            EPP_Code 'FILD ' cx '|'
        Test_Else_If ax DWordValue
            EPP_Code 'SUB ESP 04|{?? ESI-000}|Mov D$? ' cx '|FILD D$?|'
        Test_Else
            EPP_Code '{??:R$ ' cx '}|FLD R$?|' | Call incFPUStackNumber
        Test_End

    .End_If

EndP
____________________________________________________________________________________________
Proc IsARegister:
    ; Returns &FALSE if D@pos does NOT points on a register (it can be terminated by EOI,meEOI,Space or &NULL)
    ; Otherwise returns '(RegisterOperand OR SizeOp)' with SizeOp, the size of the register.
    ; (which can be ByteValue,WordValue,DWordValue,FloatingPointOperand+TByteValue)
    Argument @pos
    Uses esi

    Mov eax &FALSE
    Mov esi D@pos
    ..If B$esi+2 <= Space
        .If_Or B$esi+1 = 'H', B$esi+1 = 'L'
            If_And B$esi >= 'A', B$esi <= 'D'
                Mov eax (RegisterOperand or ByteValue)
            End_If

        .Else_If_Or W$esi = 'AX', W$esi = 'BX', W$esi = 'CX', W$esi = 'DX',
                    W$esi = 'BP', W$esi = 'DI', W$esi = 'SI'
            Mov eax (RegisterOperand or WordValue)
        .End_If

    ..Else_If B$esi+3 <= Space
        .If B$esi = 'E'
            If_Or W$esi+1 = 'AX', W$esi+1 = 'BX', W$esi+1 = 'CX', W$esi+1 = 'DX',
                  W$esi+1 = 'BP', W$esi+1 = 'DI', W$esi+1 = 'SI'
                Mov eax (RegisterOperand or DWordValue)
            End_If
        .Else_If_Or W$esi = 'ST', W$esi = 'st'
            ; 'st' is for temporary results stored on the FPU Stack (See incFPUStackNumber)
            If_And B$esi+2 >= '0', B$esi+2 <= '7'
                Mov eax (RegisterOperand or FloatingPointOperand or TByteValue)
            End_If
        .End_If
    ..End_If

EndP
____________________________________________________________________________________________
Proc GetAddressingCoef:
    ; returns in al the corresponding size of D@SizeMarkerPos
    Argument @SizeMarkerPos
    Uses ecx

    Mov ecx D@SizeMarkerPos
    .If B$ecx = 'B'
        Mov al '1'
    .Else_If B$ecx = 'R'
        Mov al '8'
    .Else_If B$ecx = 'F'
        Mov al '4'
    .Else_If B$ecx = 'D'
        Mov al '4'
    .Else_If B$ecx = 'W'
        Mov al '2'
    .Else_If B$ecx = 'Q'
        Mov al '8'
    .End_If
EndP
____________________________________________________________________________________________
Proc WriteFunctionCode:
    ;Set the result of the operations on the FPU Stack and compute the function
    ; we have: _FUNCTION_PARAMETER_
    ; #1 points on PARAMETER and #2 points on FUNCTION
    Arguments @FunctionNamePos @FunctionNameLength

    .If_str D@FunctionNamePos = 'COS'
        Call LoadOperandOnTOS 1
        EPP_Code 'FCOS|'
        Call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'SIN'
        Call LoadOperandOnTOS 1
        EPP_Code 'FSIN|'
        Call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'TAN'
        Call LoadOperandOnTOS 1
        EPP_Code 'FPTAN|FINCSTP|FFREE ST7|'
        Call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'ABS'
        Call LoadOperandOnTOS 1
        EPP_Code 'FABS|'
        Call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'SQRT'
        Call LoadOperandOnTOS 1
        EPP_Code 'FSQRT|'
        Call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'LOG10'
        EPP_Code 'FLDLG2|' | Call incFPUStackNumber
        Call LoadOperandOnTOS 1
        EPP_Code 'FYL2X|' | Call decFPUStackNumber
        Call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'LOG2'
        EPP_Code 'FLD1|' | Call incFPUStackNumber
        Call LoadOperandOnTOS 1
        EPP_Code 'FYL2X|' | Call decFPUStackNumber
        Call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'LN'
        EPP_Code 'FLDLN2|' | Call incFPUStackNumber
        Call LoadOperandOnTOS 1
        EPP_Code 'FYL2X|' | Call decFPUStackNumber
        Call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'ATAN'
        Call LoadOperandOnTOS 1
        EPP_Code 'FLD1|'
        EPP_Code 'FPATAN|'
        Call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'EXP'
        Call LoadOperandOnTOS 1
        EPP_Code 'FLDL2E|FMULP ST1 ST0|FLD ST0|FRNDINT|FSUB ST1 ST0|FLD1|'
        EPP_Code 'FSCALE|FSTP ST1|FXCH|F2XM1|FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        Call StoreFPUResult 1

    .Else
        error EqualPreparser_InvalidFunction
    .End_If


    Mov edi D$EPP_Operand1 | Call ShiftLineLeft D@FunctionNameLength ; erase function name

EndP
____________________________________________________________________________________________
Proc UpdateLocalDataShift:
    Local @LocalDataShift @RegisterLetter

    Mov D@LocalDataShift 0
    Mov ecx D$EPP_CodeBegining
    Mov ebx &FALSE


    EPP_FindCodePos 'Mov ESI ESP'  EPP_CODE_BEGIN EPP_CODE_END
    jmp L1>
    .While eax <> CODE_NOT_FOUND
        add D@LocalDataShift 4 | inc eax

L1:     EPP_FindCodePos 'Push' eax EPP_CODE_BEGIN EPP_CODE_END
    .End_While

    jmp L1>>
    .While eax <> CODE_NOT_FOUND
        Mov ebx &TRUE
        Mov esi D$EPP_SearchedStringAddress
        If B$esi+2 < Separators
            Mov al B$esi+1 | sub al '0' | On al > 9 , sub al 7
        Else
            Mov al B$esi+1 | sub al '0' | On al > 9 , sub al 7 | shl al 4
            Mov ah B$esi+2 | sub ah '0' | On ah > 9 , sub ah 7
            add al ah
        End_If
        movzx edx al | add D@LocalDataShift edx

        EPP_FindCodePos 'ESI-' ecx EPP_CODE_END | add eax 5 | Mov ecx eax
        ; We always have 'SUB ESP &0|{&1 ESI-0xx}|'
        If D@LocalDataShift < 010
            Mov al B@LocalDataShift | add al '0' | On al > '9', add al 7
            Mov B$ecx al
            lea edi D$ecx+2 | Call ShiftLineLeft 1
        Else_If D@LocalDataShift > 0FF
            error EqualPreparser_LocalStackOverflow
        Else
            Mov al B@LocalDataShift
            Mov ah al | and ah 0F | shr al 4
            add ah '0' | On ah > '9', add ah 7 | Mov B$ecx+1 ah
            add al '0' | On al > '9', add al 7 | Mov B$ecx   al
        End_If


L1:     EPP_FindCodePos 'SUB ESP &0' ecx EPP_CODE_END | Mov ecx eax
    .End_While

    .If ebx = &FALSE
        EPP_ReplaceCode 'Push ESI|Mov ESI ESP'  EOS          EPP_CODE_BEGIN EPP_CODE_END
        EPP_ReplaceCode 'Mov ESP ESI|Pop ESI'   EOS          EPP_CODE_BEGIN EPP_CODE_END
        EPP_ReplaceCode 'D$ESI+4'               'ESI'        EPP_CODE_BEGIN EPP_CODE_END
        EPP_ReplaceCode 'Mov &1 D$ESI-??'       EOS          EPP_CODE_BEGIN EPP_CODE_END

    .End_If

EndP
____________________________________________________________________________________________
Proc ReplaceCodeMacroProc:
    Arguments @CodeToReplace @CodeReplacement @Begin @End
    Uses ebx

    jmp L1>
    While eax <> CODE_NOT_FOUND
        Call ReplaceCodeProc eax D@CodeReplacement ebx

L1:     Call FindCodePosProc D@CodeToReplace D@Begin D@End
    End_While

EndP
____________________________________________________________________________________________
Proc ReplaceCodeProc:
    ; This procedure replaces the code at D@CodeToReplacePos by D@CodeReplacement.
    ; D@CodeLength is the length of the code to be replaced.
    ; In D@CodeReplacement two specials characters can be used :
    ;   - '!n' which is replaced by the a single characters and '&n' by an instruction/operand
    ;       (with n a digit between 1 and 9)
    ;       See FindCodePosProc for more information about theses internal variables.
    Arguments @CodeToReplacePos @CodeReplacement @CodeLength
    USes esi edi ecx

    Mov edi EPP_ReplacementBuffer
    Mov esi D@CodeReplacement

    Mov ecx 0
    lodsb
    ..While al <> 0
        inc ecx
        .If al = '!'
            movzx edx B$esi | sub edx '0' | inc esi
            Mov al B$EPP_SearchedSingleCharacter+edx

        .Else_If al = '&'
            movzx edx B$esi | sub edx '0' | inc esi | shl edx 2
            Push esi
                Mov esi D$EPP_SearchedStringAddress+edx
                .While B$esi > LowSigns
                    movsb  | inc ecx
                    While B$esi = memMarker | movsb | End_While
                    On B$esi = '}', jmp L2>
                .End_While
                dec ecx
L2:         Pop esi
            dec edi | Mov al B$edi
        .Else_If al = SPC
            Mov al Space
        .Else_If al = '$'
            Mov al memMarker
        .Else_If al = '|'
            If B$esi = '|'
                Mov al EOI | inc esi
            Else
                Mov al meEOI
            End_If
        .End_If
        stosb

        lodsb
    ..End_While
    Mov B$edi 0

    On ecx = 0, inc D@CodeLength
    Mov edi D@CodeToReplacePos | add edi D@CodeLength
    Call ShiftLineLeft D@CodeLength
    Mov eax D@CodeLength | sub D$EPP_WrittenCode eax
    Mov edi D@CodeToReplacePos
    Call ShiftLineRight ecx
    add D$EPP_WrittenCode ecx

    Mov esi EPP_ReplacementBuffer
    While B$esi <> 0 | movsb | End_While

EndP
____________________________________________________________________________________________
Proc FindCodePosProc:
    ; Returns: - in eax the position of D@CodeToFind between D@Begin and D@End
    ;          - in ebx the length of the code found.
    ; and CODE_NOT_FOUND otherwise.
    ; In D@CodeToFind the following specials characters are used :
    ;   - '?'  means 'any character'
    ;   - '!n' represents a single character which must be the same each timle it appears.
    ;          (n is a number between 0 and 9)
    ;   - '&n' represents a mnemonic or an operand '}'/Space/meEOI/EOI-terminated which must be the same
    ;          each time it appears. (n is a number between 0 and 9)
    ;   '&n' and '!n' internal variables are re-initialized each time this procedure is called, so that
    ;   they can be used by a Call to ReplaceCodeProc right after this procedure.
    ;
    ; - D@Begin can be:
    ;   * EPP_CODE_BEGIN   : to search up from the beginning of the produced code(in one Equal line).
    ;   * EPP_SOURCE_BEGIN : to search up from the beginning of the produced code(in one Equal line).
    ;
    ; - D@End can be:
    ;   * EPP_CODE_END   : to search up to the end of the produced code(in one Equal line).
    ;   * EPP_SOURCE_END : to search up to the end of the produced code(in one Equal line).
    ;
    ; This function must be called BEFORE TranslateExpressions
    Arguments  @CodeToFind @Begin @End
    Local @FirstCharPos @result
    Uses ecx, esi, edi, edx

    On D@Begin = EPP_CODE_BEGIN, Move D@Begin D$EPP_CodeBegining
    On D@End   = EPP_CODE_END  , Move D@End   D$EPP_WrittenCode
    On D@Begin = EPP_SOURCE_BEGIN, Move D@Begin EPP_SourceEquation
    If D@End   = EPP_SOURCE_END
        Mov ecx EPP_SourceEquation
        While B$ecx <> EOI | inc ecx | End_While
        Mov D@End ecx
    End_If

    Mov ecx D@End | sub ecx D@Begin
    Test_If ecx 0_8000_0000  ; (D$EPP_WrittenCode - D@From) < 0   ==>   ExitP
        Mov eax CODE_NOT_FOUND
EndP
    Test_End

    Mov D@FirstCharPos &FALSE
    Mov D@result CODE_NOT_FOUND
    Mov esi D@CodeToFind
    Mov edi D@Begin
    Mov ebx 0
    Call InitSearchVariables

    ..While ecx >s 0
        lodsb | inc ebx
        ..If al = SPC
            Mov al Space
        ..Else_If al = '?'
            Mov al B$edi
        ..Else_If al = '$'
            Mov al memMarker
        ..Else_If al = ':'
            Mov al colonSign
        ..Else_If al = '-'
            Mov al minusSign
        ..Else_If al = '+'
            Mov al plusSign
        ..Else_If al = '*'
            Mov al addressSign
        ..Else_If al = '|'
            If B$esi = '|'
                Mov al EOI | inc esi
            Else
                Mov al meEOI
            End_If
        ..Else_If al = '!'
            movzx edx B$esi | sub edx '0' | inc esi
            If B$EPP_SearchedSingleCharacter+edx = 0
                Mov al B$edi
                Mov B$EPP_SearchedSingleCharacter+edx al
            Else
                Mov al B$EPP_SearchedSingleCharacter+edx
            End_If
        ..Else_If al = '&'
            movzx edx B$esi | sub edx '0' | inc esi | shl edx 2
            .If D$EPP_SearchedStringAddress+edx = 0
                Mov D$EPP_SearchedStringAddress+edx edi
                .While B$edi > LowSigns
                    inc edi | inc ebx
                    While B$edi = memMarker | inc edi | inc ebx | End_While
                    On B$edi = '}', jmp L2>
                .End_While
L2:             dec edi ebx | Mov al B$edi
            .Else
                Call CompareCode edi D$EPP_SearchedStringAddress+edx
                If eax = &TRUE
                    .While B$edi > LowSigns
                        inc edi | inc ebx
                        While B$edi = memMarker | inc edi | inc ebx | End_While
                        On B$edi = '}', jmp L2>
                    .End_While
L2:                 dec edi ebx | Mov al B$edi
                Else
                    Mov D@FirstCharPos &TRUE
                    Mov al 0
                End_If
            .End_If

        ..Else_If al = 0
            Move D@result D@FirstCharPos
            jmp L5>
        ..End_If

        .If D@FirstCharPos <> &FALSE
            If B$edi <> al
                Mov D@FirstCharPos &FALSE
                Mov esi D@CodeToFind
                Call InitSearchVariables
            Else
                inc edi
            End_If
        .Else
            repne scasb
            Mov D@FirstCharPos edi | dec D@FirstCharPos
            Mov ebx 0
        .End_If

    ..End_While
L5: Mov eax D@result

EndP
____________________________________________________________________________________________
Proc CompareCode:
    ; returns &TRUE if D@Code1 and D@Code2 points on identicals mnemonics or operands ('}'/Space/meEOI/EOI-terminated)
    Arguments @Code1 @Code2
    Uses esi edi

    Mov esi D@Code1
    Mov edi D@Code2

    lodsb
    While al = B$edi
        inc edi
        If_And B$esi < LowSigns, B$edi < LowSigns, B$esi <> memMarker, B$edi <> memMarker
            Mov eax &TRUE  | EndP
        Else_If_And  B$esi = 125 , B$edi = 125 ; 125 = '}'
            Mov eax &TRUE | ExitP
        Else_If_And  B$esi < LowSigns, B$edi = 125, B$esi <> memMarker
            Mov eax &TRUE | ExitP
        Else_If_And  B$edi < LowSigns, B$esi = 125, B$edi <> memMarker
            Mov eax &TRUE | ExitP
        Else_If_Or  B$esi = 125 , B$edi = 125
            Mov eax &FALSE | ExitP
        Else_If_And B$esi < LowSigns, B$esi <> memMarker
            Mov eax &FALSE | ExitP
        Else_If_And  B$edi < LowSigns, B$edi <> memMarker
            Mov eax &FALSE | ExitP
        End_If
        lodsb
    End_While
    Mov eax &FALSE

EndP
____________________________________________________________________________________________
InitSearchVariables:
    Push ecx
        Mov ecx 0
        While ecx < SEARCH_VARIABLE_NUMBER
            Mov B$EPP_SearchedSingleCharacter+ecx 0
            Mov D$EPP_SearchedStringAddress+ecx*4   0
            inc ecx
        End_While
    Pop ecx
ret
____________________________________________________________________________________________
Proc DeleteFinalCodeLine:
    ; LinePos point on the beginning of a code line (after meEOI or EOI)
    ; returns the number of characters deleted.
    Arguments @LinePos @EndOfSource
    Uses ecx, esi, edi

    Mov edi D@LinePos
    Mov esi D@LinePos | While B$esi > EOI | inc esi | End_While
    Mov eax esi | sub eax D@LinePos | inc eax
    Mov ecx D@EndOfSource
    If_And B$esi = EOI, B$edi-1 = meEOI
        dec edi | dec ecx
    Else
        inc esi
    End_If
    sub ecx esi
    rep movsb

    ; reset to 0 the end of the source (needed for the macros unfolding)
    Mov ecx D@EndOfSource | sub ecx eax
    While ecx < D@EndOfSource | Mov B$ecx 0 | inc ecx | End_While

EndP
____________________________________________________________________________________________
Proc OptimizeEqualPreparserCode:
    Arguments @From @To

    Test_If_Not B$UsedRegisters EPP_EAX
        EPP_ReplaceCode 'Push EAX' EOS D@From  D@To
        EPP_ReplaceCode 'Pop EAX'  EOS D@From  D@To
    Test_End

    Test_If_Not B$UsedRegisters EPP_EBX
        EPP_ReplaceCode 'Push EBX' EOS D@From  D@To
        EPP_ReplaceCode 'Pop EBX'  EOS D@From  D@To
    Test_End

    Test_If_Not B$UsedRegisters EPP_ECX
        EPP_ReplaceCode 'Push ECX' EOS D@From  D@To
        EPP_ReplaceCode 'Pop ECX'  EOS D@From  D@To
    Test_End

    Test_If_Not B$UsedRegisters EPP_EDX
        EPP_ReplaceCode 'Push EDX' EOS D@From  D@To
        EPP_ReplaceCode 'Pop EDX'  EOS D@From  D@To
    Test_End

    Test_If_Not B$UsedRegisters EPP_ESI
        EPP_ReplaceCode 'Push ESI' EOS D@From  D@To
        EPP_ReplaceCode 'Pop ESI'  EOS D@From  D@To
    Test_End

    Test_If_Not B$UsedRegisters EPP_EDI
        EPP_ReplaceCode 'Push EDI' EOS D@From  D@To
        EPP_ReplaceCode 'Pop EDI'  EOS D@From  D@To
    Test_End


    EPP_ReplaceCode 'SUB ESP &0|{&1 ESI?&2}|Mov ?$&1 &3|Mov &4 ?$&1',
                    'Mov &4 &3',
                    D@From D@To


    EPP_ReplaceCode 'SUB ESP &0|{&1 ESI?&2}|Mov ?$&1 &3|Push ?$&1',
                    'Push &3',
                    D@From D@To


    EPP_ReplaceCode 'SUB ESP &0|{&1 ESI-&2}|Mov D$&1 &3|Pop &4|Mov &5 D$&1',
                    'Mov &5 &3|Pop &4',
                    D@From D@To

    EPP_ReplaceCode 'Mov &1 &1',
                    0,
                    D@From D@To

    EPP_ReplaceCode 'SUB ESP &0|{&1 ESI?&2}|FSTP ?$&1|FLD ?$&1',
                    0,
                    D@From D@To


EndP
____________________________________________________________________________________________
Proc EqualFirstScan:
    ; Replaces each register by a meaningless label and writes the code that copies its value in the memory.
    ; D@SecondPass is true when we are computing the address of an array.
    Argument @SecondPass

    Mov B$FPUInSourceExpression &FALSE
    Mov B$UsedRegisters  EPP_ESI

    ; identify destination type
    Call GetStringType EPP_DestOperand
    Mov D$DestinationType eax

    If D@SecondPass = &FALSE
        EPP_Code 'Push ESI|Mov ESI ESP|Push EDI|Push ECX|Push EAX|Push EBX|Push EDX|'
    Else
        ;...
    End_If

    Test_If_And D$DestinationType RegisterOperand, D$DestinationType FloatingPointOperand
        EPP_Code 'SUB ESP 06C|{&7 ESI-000}|FSAVE X$!7|FINIT|'
    Test_End

    Mov esi EPP_SourceEquation
    .While B$esi > EOI
        Mov D$EPP_Operand1 esi
        Call GetStringType esi
        ...Test_If eax RegisterOperand
            ..Test_If_Not D$NoOperation &TRUE
                .Test_If eax ByteValue
                    EPP_Code 'SUB ESP 01|{?? ESI-000}|Mov B$? #1|'
                    Call ReplaceOperand 1 'B' 0
                .Test_Else_If eax WordValue
                    If W$esi = 'SI'
                        EPP_Code '{?? ESI}|'
                        Call ReplaceOperand 1 'W' 0
                    Else
                        EPP_Code 'SUB ESP 02|{?? ESI-000}|Mov W$? #1|'
                        Call ReplaceOperand 1 'W' 0
                    End_If
                .Test_Else_If eax DWordValue
                    If_And W$esi = 'ES', B$esi+2 = 'I'
                        EPP_Code '{?? ESI}|'
                        Call ReplaceOperand 1 'D' 0
                    Else
                        EPP_Code 'SUB ESP 04|{?? ESI-000}|Mov D$? #1|'
                        Call ReplaceOperand 1 'D' 0
                    End_If
                .Test_End
            ..Test_Else
                Test_If eax FloatingPointOperand
                    EPP_Code 'SUB ESP 0A|{?? ESI-000}|FLD #1|FSTP T$?|'
                    Call ReplaceOperand 1 'T' 0
                    Mov B$FPUInSourceExpression &TRUE
                Test_End
            ..Test_End
        ...Test_End
        While B$esi > Space | inc esi | End_While | inc esi ; jump to next space
    .End_While


EndP
____________________________________________________________________________________________
FormatEqualLine:
; - Surrounds each parenthesis and operator by two spaces and performs a slight error processing.
; - Minus signs in front of numeric operands are replaced by minusSign
; - When '.' is a floating point (i.e not in a user-label) then it is replaced by pointSign
; - if an operator is doubled (**,//), it is replaced by its signed equivalent (SignedMulSign,SignedDivSign)

    Mov B$NoOperation &TRUE
    Mov esi EPP_SourceEquation
    .While B$esi > EOI
        ..If B$esi = openSign
            .If B$esi+1 = subSign   ; '(-9', '(-1'   OK
                If_And B$esi+2 >= '0', B$esi+2 <= '9'
                    Mov B$esi+1 minusSign
                    Call SourroundCurrentSign
                    inc esi
                Else
                    error EqualPreparser_OperatorsInvalid
                End_If
            .Else_If_And B$esi+1 < openSign, B$esi+1 <> Space
                error EqualPreparser_OperatorsInvalid
            .Else
                Call SourroundCurrentSign
            .End_If

        ..Else_If B$esi =  closeSign   ; ')+',')/', etc..   OK
            If B$esi+1 > closeSign
                error EqualPreparser_OperatorsInvalid
            Else
                Call SourroundCurrentSign
            End_If

        ..Else_If_And B$esi < OperatorSigns, B$esi > Separators
            Mov B$NoOperation &FALSE
            Mov al B$esi
            .If B$esi+1 = subSign          ; ...  +-7 ...  OK
                If_And B$esi+2 >= '0', B$esi+2 <= '9'
                    Mov B$esi+1 minusSign
                    Call SourroundCurrentSign
                    inc esi
                Else
                    error EqualPreparser_OperatorsInvalid
                End_If
            .Else_If B$esi+1 = al
                lea edi D$esi+1  | Call ShiftLineLeft 1       ; delete the doubled operator
                On al = mulSign, Mov B$esi SignedMulSign
                On al = divSign, Mov B$esi SignedDivSign
                Call SourroundCurrentSign

            .Else_If B$esi+1 < openSign
                error EqualPreparser_OperatorsInvalid
            .Else
                Call SourroundCurrentSign
            .End_If

        ..Else_If B$esi = '.'
            If_And B$esi+1 >= '0', B$esi+1 <= '9', B$esi-1 >= '0', B$esi-1 <= '9'
                Mov B$esi pointSign
            End_If
            inc esi

        ..Else
            inc esi
        ..End_If
    .End_While

ret
                                                ____________________________
SourroundCurrentSign:
    Mov edi esi
    Mov al B$esi
    .If B$esi-1 = Space
        If B$esi+1 <> Space     ; adds one space after the operator
            Call ShiftLineRight 1
            Mov B$esi+1 Space
        End_If
        add esi 2
    .Else_If B$esi+1 = Space    ; adds one space before the operator
        Call ShiftLineRight 1
        Mov B$esi   Space
        add esi 3
    .Else                       ; adds two spaces
        Call ShiftLineRight 2
        Mov B$esi     Space
        Mov B$esi+1   al
        Mov B$esi+2   Space
        add esi 3
    .End_If

ret
____________________________________________________________________________________________
____________________________________________________________________________________________
Proc ComputeImmediateExpression:
; This function computes immediates operations between constants.
; D@OperationType may be one of these (addSign,subSign,mulSign,divSign,expSign)
    Argument @OperationType
    Local @ValueExponent @temp
    Uses ecx, esi, edi
    finit
    Call AsciiToFloat D$EPP_Operand1 0    | On eax = &FALSE, error EqualPreparser_InvalidFPValue
    Call AsciiToFloat D$EPP_Operand2 0    | On eax = &FALSE, error EqualPreparser_InvalidFPValue

    On D@OperationType = addSign, fadd  ST0 ST1
    On D@OperationType = subSign, fsubr ST0 ST1
    On D@OperationType = mulSign, fmul  ST0 ST1
    On D@OperationType = divSign, fdivr ST0 ST1
    If D@OperationType = expSign
        fxch | fyl2x | fld ST0 | frndint | fsub ST1 ST0
        fld1 | fscale | fstp ST1 | fxch | f2xm1
        fld1 | faddp ST1 ST0 | fmulp ST1 ST0
    End_If

    fstp T$EPP_ImmediateResult
    Call FloatToUString EPP_ImmediateResult EPP_ImmediateResultString

    .If_str EPP_ImmediateResultString = 'INF'
        jmp L1>>
    .Else_If_str EPP_ImmediateResultString = 'SNaN'
        jmp L1>>
    .Else_If_str EPP_ImmediateResultString = 'QNaN'
        jmp L1>
    .Else_If_str EPP_ImmediateResultString = '-SNaN'
        jmp L1>
    .Else_If_str EPP_ImmediateResultString = '-QNaN'
        jmp L1>
    .Else_If_str EPP_ImmediateResultString = '-INF'
L1:     error EqualPreparser_InvalidImmVal
    .Else
        Mov esi EPP_ImmediateResultString
        Mov ecx 0
        While B$esi <> 0
            If B$esi = '.'
                Mov B$esi pointSign
            Else_If B$esi = 'e'
                Mov B$esi 'E'
            Else_If B$esi = '+'
                Mov B$esi plusSign
            Else_If B$esi = '-'
                Mov B$esi minusSign
            End_If
            inc esi, ecx
        End_While
        Call ReplaceOperand 0 0 SPC
        Mov edi D$EPP_Operand1 | inc edi | dec ecx
        Call ShiftLineRight ecx
        Mov esi EPP_ImmediateResultString
        Mov edi D$EPP_Operand1
        While B$esi <> 0 | movsb | End_While
    .End_If

EndP
____________________________________________________________________________________________
StoreInMemory:

    ...If_Or B$ebx = 'T', B$ebx = 'R', B$ebx = 'F'
    ;
    ; -> FIRST OPERAND IS FLOATING POINT (T$,R$ or F$):
    ;
        ..If B$edi+2 = memMarker
        ; second operand is memory data
            .If B$edi+1 = 'B'
                Call ExtendOperandToDWord 1 MemoryOperand
                jmp L1>
            .Else_If_Or B$edi+1 = 'D', B$edi+1 = 'Q', B$edi+1 = 'W'
L1:             EPP_Code 'FILD #1|FSTP #2|'

            .Else_If_Or B$edi+1 = 'T', B$edi+1 = 'R', B$edi+1 = 'F'
                EPP_Code 'FLD #1|FSTP #2|'
            .End_If

        ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
            EPP_Code 'FSTP #2|'

        ..Else
        ; second operand is a single register, an integer number or an Equate
            lea eax D$edi+1 | Call IsARegister eax
            Test_If ax (ByteValue or WordValue)
                EPP_Code 'SUB ESP 04|{?? ESI-000}|MOVZX EAX #1|Mov D$? EAX|FILD D$?|FSTP #2|'
            Test_Else_If ax DWordValue
                EPP_Code 'SUB ESP 04|{?? ESI-000}|Mov D$? #1|FILD D$?|FSTP #2|'
            Test_Else
                EPP_Code '{??:R$ #1}|FLD R$?|FSTP #2|'
            Test_End
        ..End_If
    ;
    ; -> FIRST OPERAND IS INTEGER :
    ;
    ...Else_If B$ebx = 'B'
    ; BYTE
        ..If B$edi+2 = memMarker
            .If B$edi+1 = 'B'
                EPP_Code 'Mov AL #1|Mov #2 AL|' | or B$UsedRegisters EPP_EAX
            .Else
                error EqualPreparser_SourceInvalid
            .End_If

        ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
            error EqualPreparser_SourceInvalid

        ..Else
        ; second operand is a single register, an integer number or an Equate
            lea eax D$edi+1 | Call IsARegister eax
            If ax <> &FALSE
                Test_If_Not ax ByteValue | error EqualPreparser_SourceInvalid | Test_End
            End_If
            EPP_Code 'Mov #2 #1|'
        ..End_If

    ...Else_If B$ebx = 'W'
    ; WORD
        ..If B$edi+2 = memMarker
            .If B$edi+1 = 'B'
                EPP_Code 'MOVZX AX #1|Mov #2 AX|' | or B$UsedRegisters EPP_EAX
            .Else_If B$edi+1 = 'W'
                EPP_Code 'Mov AX #1|Mov #2 AX|' | or B$UsedRegisters EPP_EAX
            .Else_If_Or B$edi+1 = 'T', B$edi+1 = 'R', B$edi+1 = 'F'
                EPP_Code 'FLD #1|FISTP #2|'
            .Else
                error EqualPreparser_SourceInvalid
            .End_If

        ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
            EPP_Code 'FISTP #2|'

        ..Else
        ; second operand is a single register, an integer number or an Equate
            lea eax D$edi+1 | Call IsARegister eax
            If ax <> &FALSE
                Test_If_Not ax (ByteValue or WordValue) | error EqualPreparser_SourceInvalid | Test_End
            End_If
            Test_If ax ByteValue
                EPP_Code 'MOVZX #2 #1|'
            Test_Else
                EPP_Code 'Mov #2 #1|'
            Test_End
        ..End_If

    ...Else_If B$ebx = 'Q'
    ; QWORD
        ..If B$edi+2 = memMarker
            .If B$edi+1 = 'Q'
                Mov B$edi+1 'D'  ; the QWORD is moved in two steps, DWord by DWord
                Mov B$ebx   'D'
                EPP_Code 'Push #1|Pop #2|Push #1+4|Pop #2+4|'

            .Else_If_Or B$edi+1 = 'B', B$edi+1 = 'W'
                Call ExtendOperandToDWord 1 RegisterOperand
                jmp L1>
            .Else_If B$edi+1 = 'D'
L1:             Mov B$ebx 'D'
                EPP_Code 'Push #1|Pop #2|Mov #2+4 0|'

            .Else_If_Or B$edi+1 = 'T', B$edi+1 = 'R', B$edi+1 = 'F'
                EPP_Code 'FLD #1|FISTP #2|'

            .Else
                error EqualPreparser_SourceInvalid
            .End_If

        ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
            EPP_Code 'FISTP #2|'

        ..Else
        ; second operand is a single register, an integer number or an Equate
            lea eax D$edi+1 | Call IsARegister eax
            Test_If ax ByteValue
                Mov B$ebx 'B'
            Test_Else_If ax WordValue
                Mov B$ebx 'W'
            Test_Else
                Mov B$ebx 'D'
            Test_End
            EPP_Code 'Mov #2 #1|Mov #2+4 0|'
        ..End_If

    ...Else_If B$ebx = 'D'
    ; DWORD
        ..If B$edi+2 = memMarker
        ; second operand is memory data
            .If_Or B$edi+1 = 'B', B$edi+1 = 'W'
                Call ExtendOperandToDWord 1 RegisterOperand
                jmp L1>
            .Else_If B$edi+1 = 'D'
L1:             EPP_Code 'Push #1|Pop #2|'
            .Else_If_Or B$edi+1 = 'T', B$edi+1 = 'R', B$edi+1 = 'F'
                EPP_Code 'FLD #1|FISTP #2|'
            .Else
                error EqualPreparser_SourceInvalid
            .End_If

        ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
            EPP_Code 'FISTP #2|'

        ..Else
        ; second operand is a single register, an integer number or an Equate
            lea eax D$edi+1 | Call IsARegister eax
            Test_If ax (ByteValue or WordValue)
                EPP_Code 'MOVZX #2 #1|'
            Test_Else
                EPP_Code 'Mov #2 #1|'
            Test_End
        ..End_If

    ...Else
    ; Invalid data identifier
        error EqualPreparser_DestInvalid
    ...End_If

ret
____________________________________________________________________________________________
Proc StoreIn32BitsRegister:

    ..If B$edi+2 = memMarker
        ; second operand is memory data
        .If_Or B$edi+1 = 'B', B$edi+1 = 'W'
            Mov D$EPP_LastStorageStatement_InMemory {B$ 'MOVZX #2 #1|' EOS}
        .Else_If B$edi+1 = 'D'
            Mov D$EPP_LastStorageStatement_InMemory {B$ 'Mov #2 #1|' EOS}
        .Else_If_Or B$edi+1 = 'F', B$edi+1 = 'R', B$edi+1 = 'T'
            EPP_Code 'SUB ESP 04|{?? ESI-000}|FLD #1|FISTP D$?|'
            Mov D$EPP_LastStorageStatement_InMemory {B$ 'Mov #2 D$?|' EOS}
        .Else
            error EqualPreparser_SourceInvalid
        .End_If

    ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
        EPP_Code 'SUB ESP 04|{?? ESI-000}|FISTP D$?|'
        Mov D$EPP_LastStorageStatement_InMemory {B$ 'Mov #2 D$?|' EOS}

    ..Else
    ; second operand is an integer number or a register or an equate
        lea eax D$edi+1 | Call IsARegister eax
        Test_If ax (ByteValue or WordValue)
            Mov D$EPP_LastStorageStatement {B$ 'MOVZX #2 #1|' EOS}
        Test_Else
            Mov D$EPP_LastStorageStatement {B$ 'Mov #2 #1|' EOS}
        Test_End
    ..End_If

EndP
____________________________________________________________________________________________
StoreInFPURegister:

    ..If B$edi+2 = memMarker
    ; second operand is memory data
        EPP_Code 'FRSTOR X$!7|'
        .If_Or B$edi+1 = 'B'
            Call ExtendOperandToDWord 1 MemoryOperand
            jmp L1>
        .Else_If_Or B$edi+1 = 'W', B$edi+1 = 'D', B$edi+1 = 'Q'
L1:         If W$EPP_DestOperand+1 = 'T7'
                EPP_Code 'FFREE ST7|FILD #1|FINCSTP|'
            Else
                inc B$EPP_DestOperand+2
                EPP_Code 'FILD #1|FSTP #2|'
            End_If
        .Else_If_Or B$edi+1 = 'R', B$edi+1 = 'F', B$edi+1 = 'T'
            If W$EPP_DestOperand+1 = 'T7'
                EPP_Code 'FFREE ST7|FLD #1|FINCSTP|'
            Else
                inc B$EPP_DestOperand+2
                EPP_Code 'FLD #1|FSTP #2|'
            End_If

        .Else
            error EqualPreparser_SourceInvalid
        .End_If

    ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
        EPP_Code 'SUB ESP 0A|{?? ESI-000}|FSTP T$?|'
        Call ReplaceOperand 1 'T' 0
        Mov D$EPP_Operand2 EPP_DestOperand
        EPP_Code 'FRSTOR X$!7|'
        If W$EPP_DestOperand+1 = 'T7'
            EPP_Code 'FFREE ST7|FLD #1|FINCSTP|'
        Else
            inc B$EPP_DestOperand+2
            EPP_Code 'FLD #1|FSTP #2|'
        End_If

    ..Else
        ; second operand is a register, an integer number or an equate
        EPP_Code 'FRSTOR X$!7|'
        On W$EPP_DestOperand+1 = 'T7', EPP_Code 'FFREE ST7|'
        lea eax D$edi+1 | Call IsARegister eax
        Test_If ax (ByteValue or WordValue)
            EPP_Code 'SUB ESP 04|{?? ESI-000}|MOVZX EAX #1|Mov D$? EAX|FILD D$?|'
        Test_Else_If ax DWordValue
            EPP_Code 'SUB ESP 04|{?? ESI-000}|Mov D$? #1|FILD D$?|'
        Test_Else
            EPP_Code '{??:R$ #1}|FLD R$?|'
        Test_End

        If W$EPP_DestOperand+1 = 'T7'
            EPP_Code 'FINCSTP|'
        Else
            inc B$EPP_DestOperand+2
            EPP_Code 'FSTP #2|'
        End_If
    ..End_If

ret
____________________________________________________________________________________________
StoreIn16BitsRegister:

    ..If B$edi+2 = memMarker
    ; second operand is memory data
        .If B$edi+1 = 'B'
            Mov D$EPP_LastStorageStatement_InMemory {B$ 'MOVZX #2 #1|' EOS}
        .Else_If B$edi+1 = 'W'
            Mov D$EPP_LastStorageStatement_InMemory {B$ 'Mov #2 #1|' EOS}
        .Else_If_Or B$edi+1 = 'F', B$edi+1 = 'R', B$edi+1 = 'T'
            EPP_Code 'SUB ESP 02|{?? ESI-000}|FLD #1|FISTP W$?|'
            Mov D$EPP_LastStorageStatement_InMemory {B$ 'Mov #2 W$?|' EOS}
        .Else
            error EqualPreparser_SourceInvalid
        .End_If

    ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
        EPP_Code 'SUB ESP 02|{?? ESI-000}|FISTP W$?|'
        Mov D$EPP_LastStorageStatement_InMemory {B$ 'Mov #2 W$?|' EOS}

    ..Else
    ; second operand is an integer number, a register or an equate
        lea eax D$edi+1 | Call IsARegister eax
        Test_If ax ByteValue
            Mov D$EPP_LastStorageStatement {B$ 'MOVZX #2 #1|' EOS}
        Test_Else_If_Not ax DWord
            Mov D$EPP_LastStorageStatement {B$ 'Mov #2 #1|' EOS}
        Test_Else
            error EqualPreparser_SourceInvalid
        Test_End
    ..End_If

ret
____________________________________________________________________________________________
StoreIn8BitsRegister:

    .If B$edi+2 = memMarker
    ; second operand is memory data
        If B$edi+1 = 'B'
            Mov D$EPP_LastStorageStatement_InMemory {B$ 'Mov #2 #1|' EOS}
        Else
            error EqualPreparser_SourceInvalid
        End_If
    .Else
    ; second operand is an integer number, a register or an equate
        On W$edi+1 = 'st', error EqualPreparser_SourceInvalid
        lea eax D$edi+1 | Call IsARegister eax
        If ax <> &FALSE
            Test_If_Not ax ByteValue | error EqualPreparser_SourceInvalid | Test_End
        End_If
        Mov D$EPP_LastStorageStatement {B$ 'Mov #2 #1|' EOS}
    .End_If

ret
____________________________________________________________________________________________








____________________________________________________________________________________________
; EPP Macros:
[EPP_Code
#If #1=str
    EPP_CodeDirect #1
#Else_If #1=mem
    EPP_CodePtr #1
#Else_If #1=reg
    #If #1=D
        EPP_CodeReg #1 D
    #Else_If #1=W
        EPP_CodeReg #1 W
    #Else_If #1=B
        EPP_CodeReg #1 B
    #End_If
#End_If
#+1]

[EPP_CodeReg | {&0: 0} | Mov #2$&0 #1 | Call ImmediateCodeParser &0]
[EPP_CodePtr | lea eax #1 | Call ImmediateCodeParser eax]
[EPP_CodeDirect | {&0:B$ #1,0} | Call ImmediateCodeParser &0]

; returns in fourth parameter (if it exists) the length of string
[EPP_FindCodePos | {&0:B$ #1,0} | Push ebx | Call FindCodePosProc &0 #2 #3 | Pop ebx ]

[EPP_ReplaceCode | {&0:B$ #2,0} | Call ReplaceCodeMacroProc {#1,0} &0 #3 #4 ]

[ReplaceByAddressingOperator
Mov B$esi-2 #1
lea edi D$esi   | Call ShiftLineLeft 1
lea edi D$esi-2 | Call ShiftLineLeft 1
sub esi 2]


[Test_If    |#=2| test #1 #2 ZERO T0> ]
[.Test_If   |#=2| test #1 #2 ZERO T1>>]
[..Test_If  |#=2| test #1 #2 ZERO T2>>]
[...Test_If |#=2| test #1 #2 ZERO T3>>]

[Test_If_Not     |#=2| test #1 #2 NOT_ZERO T0> ]
[.Test_If_Not    |#=2| test #1 #2 NOT_ZERO T1>>]
[..Test_If_Not   |#=2| test #1 #2 NOT_ZERO T2>>]
[...Test_If_Not  |#=2| test #1 #2 NOT_ZERO T3>>]


[Test_Else    | jmp T5>  | T0: ]
[.Test_Else   | jmp T6>> | T1: ]
[..Test_Else  | jmp T7>> | T2: ]
[...Test_Else | jmp T8>> | T3: ]

[Test_End    | T0: | T5:]
[.Test_End   | T1: | T6:]
[..Test_End  | T2: | T7:]
[...Test_End | T3: | T8:]



[Test_If_And    | Test_If    #1 #2 | #+2]
[.Test_If_And   | .Test_If   #1 #2 | #+2]
[..Test_If_And  | ..Test_If  #1 #2 | #+2]
[...Test_If_And | ...Test_If #1 #2 | #+2]

[Test_If_Not_And    | Test_If_Not    #1 #2 | #+2]
[.Test_If_Not_And   | .Test_If_Not   #1 #2 | #+2]
[..Test_If_Not_And  | ..Test_If_Not  #1 #2 | #+2]
[...Test_If_Not_And | ...Test_If_Not #1 #2 | #+2]


[Test_Else_If    | Test_Else    | Test_If    #1 #2]
[.Test_Else_If   | .Test_Else   | .Test_If   #1 #2]
[..Test_Else_If  | ..Test_Else  | ..Test_If  #1 #2]
[...Test_Else_If | ...Test_Else | ...Test_If #1 #2]

[Test_Else_If_Not    | Test_Else    | Test_If_Not    #1 #2]
[.Test_Else_If_Not   | .Test_Else   | .Test_If_Not   #1 #2]
[..Test_Else_If_Not  | ..Test_Else  | ..Test_If_Not  #1 #2]
[...Test_Else_If_Not | ...Test_Else | ...Test_If_Not #1 #2]


[Test_Else_If_And    | Test_Else    | Test_If_And    #F>L ]
[.Test_Else_If_And   | .Test_Else   | .Test_If_And   #F>L ]
[..Test_Else_If_And  | ..Test_Else  | ..Test_If_And  #F>L ]
[...Test_Else_If_And | ...Test_Else | ...Test_If_And #F>L ]

[Test_Else_If_Not_And    | Test_Else    | Test_If_Not_And    #F>L ]
[.Test_Else_If_Not_And   | .Test_Else   | .Test_If_Not_And   #F>L ]
[..Test_Else_If_Not_And  | ..Test_Else  | ..Test_If_Not_And  #F>L ]
[...Test_Else_If_Not_And | ...Test_Else | ...Test_If_Not_And #F>L ]



[If_Or    | cmp #1 #3 | j#2 O0>  | #+3 | jmp I1>  | O0:]
[.If_Or   | cmp #1 #3 | j#2 O1>> | #+3 | jmp J1>> | O1:]
[..If_Or  | cmp #1 #3 | j#2 O2>> | #+3 | jmp K1>> | O2:]
[...If_Or | cmp #1 #3 | j#2 O3>> | #+3 | jmp Z1>> | O3:]

[Else_If_Or    | Else    | If_Or    #F>L]
[.Else_If_Or   | .Else   | .If_Or   #F>L]
[..Else_If_Or  | ..Else  | ..If_Or  #F>L]
[...Else_If_Or | ...Else | ...If_Or #F>L]


[If_And    | If #1 #2 #3    | #+3]
[.If_And   | .If #1 #2 #3   | #+3]
[..If_And  | ..If #1 #2 #3  | #+3]
[...If_And | ...If #1 #2 #3 | #+3]

[Else_If_And    | Else    | If_And    #F>L]
[.Else_If_And   | .Else   | .If_And   #F>L]
[..Else_If_And  | ..Else  | ..If_And  #F>L]
[...Else_If_And | ...Else | ...If_And #F>L]




; * max string length = 10
; * OK if #3 is included in #1, jump to next 'If' otherwise
;
; ex:
;   If_str eax = 'glouglou'
;       ;...
;   Else
;       ;...
;   End_If

[.If_str | {&0: #3,0} | Mov esi &0 | Mov edi #1 | Mov ecx 10 | repe cmpsb
         On ecx = 0, jmp J1>  | On B$esi-1 <> 0, jmp J1> ]

[.Else_If_str| .Else | .If_str #1 #2 #3]


____________________________________________________________________________________________
@EPP_All_Data:
[EPP_SourceEquation: B$ ? # 256   EPP_SourceEquation_End: B$ ?]  ; last char is EOI
[EPP_DestOperand: B$ ? # 64]     ; last char is Space

[EPP_SourceEquation_Backup: B$ ? # 256 ]
[EPP_DestOperand_Backup: B$? # 64]
[EPP_atofAddress: B$ ? # 9] ; null-terminated
[EPP_ftoaAddress: B$ ? # 9] ; null-terminated
[EPP_ImmediateResultString: B$ ? # 32]

[EPP_InternalMeaninglessLabels: B$ ? # (9*10)]   ; 8 and 9 are reserved for Evaluation parser


[EPP_SearchedSingleCharacter: B$ ? # SEARCH_VARIABLE_NUMBER]
[EPP_SearchedStringAddress:   D$ ? # SEARCH_VARIABLE_NUMBER]
[EPP_ReplacementBuffer: B$ ? # 128]

[EqualPreparser_DestInvalid: B$ 'Destination operand is invalid.' EOS]
[EqualPreparser_SourceInvalid: B$ 'Source expression is invalid.' EOS]
[EqualPreparser_UnexpectedError: B$ 'Unexpected preparsing error.' EOS]
[EqualPreparser_InvalidIndex: B$ 'Invalid index type.' EOS]
[EqualPreparser_InvalidAddress: B$ 'Invalid address.' EOS]
[EqualPreparser_OperatorsInvalid: B$ 'Two operators are following each other.' EOS]

[EqualPreparser_InvalidFPValue: B$ 'Invalid floating point value.' EOS]
[EqualPreparser_InvalidFunction: B$ 'No such function implemented.' EOS]
[EqualPreparser_InvalidStringDest_Type: B$ 'A string pointer MUST be a DWord .' EOS]
[EqualPreparser_InvalidStringDest_Numeric: B$ 'You cannot write at a numeric address.' EOS]

[EqualPreparser_InvalidImmVal: B$ 'Invalid immediate expression.' EOS]
[EqualPreparser_LocalStackOverflow: B$ 'Local stack overflow !' EOS]

[FPUInSourceExpression: B$ 0 ; !!! Taille B$ à vérifier
 UsedRegisters_Backup: 0 ; !!! Taille B$ à vérifier etc.
 UsedRegisters: 0
 NoOperation: 0
 ParsingInsideArray: 0
 DestinationArrayRegister: 0
 UseCommonAddressingSyntax: &TRUE
 StrNull: 0]

[EPP_ImmediateResult: T$ ?]

[EPP_CodeBegining: D$ ?
 EPP_Operand1: D$ ?
 EPP_Operand2: D$ ?
 EPP_WrittenCode: D$ ?
 FPUStackNumber: D$ ?
 DestinationType: D$ ?
 EPP_TextPointer: D$ ?
 EPP_LastStorageStatement: D$ ?
 EPP_LastStorageStatement_InMemory: D$ ?]

 [INITIAL_STATE 07FFFFFFF
  FOUND_EQUATION_TEST 0FFFFFF
  SEARCH_VARIABLE_NUMBER  9

  EPP_EAX 00______1
  EPP_EBX 00_____10
  EPP_ECX 00____100
  EPP_EDX 00___1000
  EPP_ESI 00__10000
  EPP_EDI 00_100000

  EPP_NO_OPERATION        2
  CODE_NOT_FOUND          0_FFFF_FFFF
  EPP_CODE_BEGIN              0
  EPP_CODE_END                0
  EPP_SOURCE_BEGIN            1
  EPP_SOURCE_END              1

  SignedMulSign  '*'
  SignedDivSign  '/'

  pointSign      'o'
  concatSign     '&'

  ; +,- and * used for addressing in RosAsm syntax
  minusSign      'm'
  plusSign       'p'
  addressSign    'x'

  ; All data types used in this TITLE are below
  EPP_Types 0

        FunctionOperand      00__0000_1000__0000_0000
        NumericOperand       00__0100_0000__0000_0000
        RegisterOperand      00__0010_0000__0000_0000
        ConstantOperand      00__0001_0000__0000_0000

        MemoryOperand        00__0000_0001__0000_0000
                QWordValue   00_____________0000_1000
                DWordValue   00_____________0000_0100
                WordValue    00_____________0000_0010
                ByteValue    00_____________0000_0001

        FloatingPointOperand 00_____________1000_0000
                  TByteValue 00_____________0001_0000
                  RealValue  00_____________0000_1000
                  FloatValue 00_____________0000_0100





  EqualPreparser_IntegerOperand_ST0            00________1
  EqualPreparser_ST0_IntegerOperand            00_______10
  EqualPreparser_FloatingPointOperand_ST0      00______100
  EqualPreparser_ST0_FloatingPointOperand      00_____1000
  EqualPreparser_ST1_ST0                       00____10000
  EqualPreparser_ST0_ST1                       00___100000
  EqualPreparser_ST0_ConstantOperand           00__1000000
  EqualPreparser_ConstantOperand_ST0           00_10000000]
____________________________________________________________________________________________




____________________________________________________________________________________________
____________________________________________________________________________________________
;DEBUG

[FirstEqualLine: D$ &TRUE
 LastEqualLine: D$ 0]

; Call ShowSource edi 1    ; show from edi and diplay 1 in the title
; Call ShowSource 0 7      ; show the whole written code and diplay 7 in the title
; Call ShowSource ebx 0    ; show the line where ebx points on

____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE FPU             ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
  'UsedByTheAssembler' (very old traditional Routines for Ascii to Float on Stack)
  
  'UsedBytheEqualParser' 
  
  'UsedByTheDebugger' (and by the Disassembler for 'FloatToUString')
  
  'UsedForStudy' (Under developements)
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

@UsedByTheAssembler:

[Int10: 10   CurrentConvertedDigit: 0   NumberOfDecimalPlaces: 0   FaultCharAndPos: 0]

atof:
    finit | Mov D$FaultCharAndPos 0
    Push edi, esi
      Call convert                  ; convert mantissa (returns with 'E' if exponent present)

      neg edx                                ; save -1 * decimal places
      Mov D$NumberOfDecimalPlaces edx

      IF al <> 'E'
        Mov B$FaultCharAndPos al             ; faulty char present in mantissa
        Pop ecx | Mov edi esi | sub edi ecx  ; fault char pos
        fldz                                 ; assume zero exponent
      Else_If al = 'E'
        Call convert                         ; convert exponent
        Mov B$FaultCharAndPos al      ; Save faulty character present in exponent
        Pop ecx | Mov edi esi | sub edi ecx  ; fault char pos
      End_If

      fiadd D$NumberOfDecimalPlaces          ; adjust exponent for dec. places in mantissa
      Call falog                             ; raise 10 to power
      fmul                                   ; exponent * mantissa

      ; Provide information about faulty character and its position

      Mov eax edi                            ; Get possible fault position
      shl eax 8                              ; shift to high word
      or eax D$FaultCharAndPos               ; OR faults togeter
    Pop edi
ret                                      ; return ST(0) = result

_________________________________________________________________
;;
 CONVERT:      Called by ATOF to convert ASCII number with possible sign and/or decimal point
 Call with:    ESI = address of string
 Returns:      ST(0) = result
               AL    = first unconvertable character
               EDX    = number of digits after decimal point
               ESI = address+1 of character in AL
 Uses:         AH, CX
;;
_________________________________________________________________        ;

convert:                                ; convert numeric field
    fldz | Mov ecx 0, edx 0-1           ; initialize result, sign, decimal count

   lodsb
        cmp al AddSign | je L2>         ; if + sign proceed
        cmp al SubSign | jne L3>        ; is it - sign? no > test if numeric
          dec ecx                       ; yes, set sign flag

L2: lodsb                               ; get next character

L3: cmp al '0' | jb L4>                 ; is character valid?
      cmp al,'9' | ja L4>
        and eax 0f                      ; isolate lower four bits
        Mov D$CurrentConvertedDigit eax ; and save digit value
        fimul D$int10                   ; previous value * 10
        fiadd D$CurrentConvertedDigit   ; accumulate new digit

        or edx edx | js L2<             ; past decimal point? no > convert next digit
          inc edx | jmp L2<             ; yes > count digits / convert next digit

L4: cmp al '.' | jne L5>                ; no point > proceed
      inc edx | jmp L2<                 ; indicate decimal found > convert more digits
L5:    jcxz L6>                         ; jump if result pos.
        fchs                            ; make result negative

L6: or edx edx | jns L7>                ; decimal point found? yes > jump
      Mov edx 0                         ; no, return zero places

L7: ret                                 ; return ST(0) = result


_____________________________________________________________________________________
;;
-------------------------------------------------------;
 Calculate Common Antilog on 80x87   ;
       ;
 Call  :    st(0)     = logarithm (base 10)  ;
       ;
 Return:    st(0)     = antilog to base 10  ;
       ;
 Coprocessor should be initialised before Call  ;
-------------------------------------------------------;
;;
; FWAIT doesn't seam to be of any use (works the same without on my computer).

falog:
        fldl2t                          ; st= log2(10), st(1)=argument
        fmulp   st1 st0                 ; st= log2(10) * argument
        fld     st0                     ; take copy
     ;   fwait
     ;   fstcw   W$Falogoldcw            ; store old control word
     ;   fwait                           ; wait 'till it arrives
     ;   Mov     ax W$Falogoldcw         ; Load control word
     ;   and     ax 0f3ff                ; Field to "round down"
     ;   or      ax 0400                 ; Set precision to 53 bit mantissa
     ;   Mov     W$Falognewcw ax         ; Got new control word
     ;   fldcw   W$Falognewcw            ; Force rounding mode
        frndint                         ; Round from real to integer
     ;   fldcw   W$Falogoldcw            ; Restore old rounding mode
        fld     st0                     ; take copy
        fxch    st2                     ; Get original product
        fsubrp  st1 st0                 ; Get fractional part
        fld1
        fchs
        fxch    st1                     ; Scale fractional part
        fscale    ;
        fstp    st1                     ; Discard coprocessor junk
        f2xm1                           ; Raise 2 to power-1
        fld1                            ; Push 1 onto stack
        faddp   st1 st0                 ; Correct for the -1
        fmul    st0 st0                 ; Square result
        fscale                          ; Scale by integer part
        fstp    st1                     ; Return with result in st(0)
      ret

____________________________________________________________________________________________
____________________________________________________________________________________________

@UsedBytheEqualParser:


____________________________________________________________________________________________
Proc AsciitoFloat:
;;
  This procedure was written by Raymond Filiatreault, December 2002
  Modified Betov, December 2002
  (Slightly modified by Scarmatil to fit upon RosAsm's signs, December 2003)
  
  This AsciitoFloat function converts a decimal number from a zero terminated
  alphanumeric string format (Src) to an 80-bit REAL number and returns
  the result as an 80-bit REAL number at the specified destination (either
  the FPU top or a memory location), unless an invalid operation is
  reported by the FPU.
 
  The source can be a string in regular numeric format or in scientific
  notation. The number of digits (including leading 0's) must not exceed
  18. If in scientific format, the exponent must be within +/-4931
 
  The source is checked for validity. The procedure returns an error if
  a character other than those acceptable is detected prior to the
  terminating zero or the above limits are exceeded.
 
  This procedure is based on converting the digits into a specific packed
  decimal format which can be used by the FPU and then adjusted for an
  exponent of 10.
 
  Only EAX is used to return error or success. All other registers are
  preserved.
____________________________________________________________________________________________

  Calling:     > Call AsciitoFloat Source, Destination
  
  Source: Pointer to a Floating Point String (either regular or scientific 
          notation).
  
  Destination: Either a Pointer to a [T$FPValue: ...] or &NULL.

  In case of &NULL Destination, the result is left on the FPU Stack, and
  you have to you have to Pop the result by yourself. Usefull in cases when
  you want Real8 or Real4, or when you want to go on computing with the result.
____________________________________________________________________________________________
;;
    Arguments @lpSrc, @lpDest
    Local @stword, @ten
    Structure @BCD 12, @bcdstr 0
    Uses ebx, ecx, edx, esi, edi

        Mov eax 0, ebx 0, edx 0, ecx 19, D@ten 10
        lea edi D@bcdstr | Mov D$edi 0, D$edi+4 0, D$edi+8 0 | add edi 8

        Mov esi D@lpSrc
        Mov al B$esi
        If al = Space       ; string empty?
            jmp E7>>
        Else_If al = minusSign
            Mov B$edi+1 080
            inc esi
        End_If

        ; Strip pointless 0
        While B$esi = '0'
            If B$esi+1 = pointSign | inc esi | jmp L2> | End_If
            On B$esi+1 < '0', jmp L2>
            On B$esi+1 > '9', jmp L2>
            inc esi
        End_While

      ; Convert the digits to packed decimal:
L2:     lodsb | On al = 'e', Mov al 'E'

      ; bh used to set the decimal point flag (one point only):
        ...If al = pointSign
            If bh = 0
                or bh 1 | jmp L2<
            End_If
        ...Else_If al = 'E'
            On cl < 19, jmp L6>>        ;error if no digit before E
        ...Else_If al = Space
            If cl < 19                  ;error if no digit before terminating Space
                xor al al | rol al 4 | ror ax 4 | Mov B$edi al | jmp L5>>
            End_If
        ...Else
            ..If al >= '0'
                .If al <= '9'           ;error if bad Char.
                    dec ecx
                    If ecx > 0          ;error if more than 18 digits in number
                        sub al '0' | On bh = 0, inc bl
                        test ah 040 ZERO L1>
                            rol al 4 | ror ax 4 | Mov B$edi al | dec edi | xor eax eax  | jmp L2<<
L1:                     Mov ah al | or ah 040 | jmp L2<<
                    End_If
                .End_If
            ..End_If
        ...End_If

        jmp E7>>                        ; Error case if falling here.

      ; Output:
L5:     fbld T@bcdstr
        Mov eax 18 | sub al bl | sub edx eax | Call XexpY edx
        fmulp ST1 ST0
        fstsw W@stword                      ;retrieve exception flags from FPU
        wait | test W@stword 1 NOT_ZERO E7>>   ;test for invalid operation
        Mov eax D@lpDest
        If D@lpDest <> &NULL
            Mov eax D@lpDest |  fstp T$eax      ;store result at specified address
        End_If
        jmp E8>>

      ; Scientific notation (exponent in edx):
L6:     movzx eax B$esi | inc esi
        cmp al plusSign | je L0>
            cmp al minusSign | jne L6>
            stc | rcr eax 1         ;keep sign of exponent in most significant bit of EAX
L0:     lodsb                               ;get next digit after sign

L6:     Push eax |
            and eax 0FF | jnz L0>           ;continue if 1st byte of exponent is not terminating 0
L6:             Pop eax | jmp E7>>          ;no exponent
L0:         sub al '0' | jc L6<             ;unacceptable character
            cmp al 9 | ja L6<               ;unacceptable character
            Push eax
                Mov eax edx | mul D@ten | Mov edx eax
            Pop eax
            add edx eax | cmp edx 4931 | ja L6<     ;exponent too large
            lodsb
            cmp al Space | jne L0<
        Pop eax                             ;retrieve exponent sign flag
        rcl eax 1 | jnc L0>                 ;is most significant bit set?
            neg edx
L0:     jmp L5<<

E7:     Mov eax &FALSE | finit | jmp E9>
E8:     Mov eax &TRUE
E9: EndP


;put 10 to the proper exponent (value in EDX) on the FPU

Proc XexpY:
    Argument @Tempdw

        fild D@tempdw           ;load the exponent
        fldl2t                  ;load log2(10)
        fmulp ST1 ST0           ;->log2(10)*exponent

;at this point, only the log base 2 of the 10^exponent is on the FPU
;the FPU can compute the antilog only with the mantissa
;the characteristic of the logarithm must thus be removed

        fld ST0                 ;copy the logarithm
        frndint                 ;keep only the characteristic
        fsub ST1 ST0            ;keeps only the mantissa
        fxch                    ;get the mantissa on top

        f2xm1                   ;->2^(mantissa)-1
        fld1
        faddp ST1 ST0           ;add 1 back

;the number must now be readjusted for the characteristic of the logarithm

        fscale                  ;scale it with the characteristic

;the characteristic is still on the FPU and must be removed

        fxch                    ;bring it back on top
        fstp ST0                ;clean-up the register
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

@UsedByTheDebugger:

; From FPU to Ascii
;
; Procedures Originaly written by Tim Roberts.

[TempoAsciiFpu: D$ ? # 5] [BCDtempo: T$ ?]

[ten: R$ 10.0    ten7: 1.0e6
 ten_1: T$ 1.0e1  ,    1.0e2,    1.0e3,    1.0e4,    1.0e5,    1.0e6,    1.0e7,   1.0e8
           1.0e9,    1.0e10,   1.0e11,   1.0e12,   1.0e13,   1.0e14,   1.0e15
 ten_16:   1.0e16,   1.0e32,   1.0e48,   1.0e64,   1.0e80,   1.0e96,   1.0e112, 1.0e128
           1.0e144,  1.0e160,  1.0e176,  1.0e192,  1.0e208,  1.0e224,  1.0e240
 ten_256:  1.0e256,  1.0e512,  1.0e768,  1.0e1024, 1.0e1280, 1.0e1536, 1.0e1792
           1.0e2048, 1.0e2304, 1.0e2560, 1.0e2816, 1.0e3072, 1.0e3328, 1.0e3584, 1.0e3840
           1.0e4096, 1.0e4352, 1.0e4608, 1.0e4864]

Proc PowerOf10:
    Mov ecx, eax
    test eax 0_8000_0000 ZERO L1>
        neg eax

L1: fld1

    Mov dl al | and edx 0f
    If edx > 0
        lea edx D$edx+edx*4 | fld T$ten_1+edx*2-10 | fmulp st1 st0
    End_If

    Mov dl al | shr dl 4 | and edx 0F
    If edx > 0
        lea edx D$edx+edx*4 | fld T$ten_16+edx*2-10 | fmulp st1 st0
    End_If

    Mov dl ah | and edx 01F
    If edx > 0
        lea edx D$edx+edx*4 | fld T$ten_256+edx*2-10 | fmulp st1 st0
    End_If

    test ecx 0_8000_0000 ZERO L1>
        fdivp st1 st0 | ExitP
L1:     fmulp st1 st0
EndP

Proc FloatToBCD:
    Uses esi, edi, ecx

        fbstp T$BCDtempo

        lea esi D$BCDtempo+8 | Mov edi TempoAsciiFpu
        Mov ecx, 9

L0:     Mov al B$esi | dec esi | rol ax 12 | rol ah 4
        and ax 0f0f | add ax 03030 | stosw | loop L0<
EndP

[NegatedReg: D$ ?]

Proc FloatToUString:
    Arguments @Float80Pointer, @DestinationPointer
    Local @iExp, @ControlWord, @MyControlWord
    Uses esi, edi, edx, ecx

        Mov edi D@DestinationPointer, eax D@Float80Pointer

        ..If D$eax = 0
            .If D$eax+4 = 0
                If W$eax+8 = 0
                    Mov B$edi '0', B$edi+1 0

EndP

                End_If
            .End_If
        ..End_If

        Mov B$NegatedReg &FALSE
        Test B$eax+9 0_80 ZERO L1>
          xor D$eax+9 0_80 | Mov B$NegatedReg &TRUE | Mov B$edi '-' | inc edi

L1:     ;  _______________________________________________________
        ; |        |                 |             |              |
        ; | Bit 79 | Bit 78 ... 64   | Bit 63      | Bit 62 ... 0 |
        ; | Sign   | Biased Exponent | Integer Bit | Fraction     |
        ; |________|_________________|_____________|______________|
        ;
        ; SNaN  : S=0  E=7FFF  I=1  F=1..3FFF_FFFF_FFFF_FFFF
        ; QNaN  : S=0  E=7FFF  I=1  F=4000_0000_0000_0000..7FFF_FFFF_FFFF_FFFF
        ; INF   : S=0  E=7FFF  I=1  F=0
        ; -SNaN : S=1  E=7FFF  I=1  F=1..3FFF_FFFF_FFFF_FFFF
        ; -QNaN : S=1  E=7FFF  I=1  F=4000_0000_0000_0000..7FFF_FFFF_FFFF_FFFF
        ; -INF  : S=1  E=7FFF  I=1  F=0

        ; Add: Tiny : S=x  E=0     I=0  F<>0


        movzx edx W$eax+8 | and edx 07FFF ; edx = E

        If edx = 07FFF
            On B$NegatedReg = &TRUE, xor B$eax+9 0_80
            ; test lower 32 bits of fraction
            test D$eax 0 NOT_ZERO L1>
            ; test upper 31 bits of fraction
            Mov edx D$eax+4 | and edx 0_7FFF_FFFF | jnz L1>
            Mov D$edi 'INF'

EndP

L1:         ; test most significant fraction bit
            test B$eax+7 040 ZERO L1>
            Mov D$edi 'QNaN', B$edi+4 0

EndP

L1:         Mov D$edi 'SNaN', B$edi+4 0

EndP

        End_If

        fclex | fstcw W@ControlWord | Mov W@MyControlWord 027F | fldcw W@MyControlWord

        fld T$eax | fld st0

        fxtract | fstp st0 | fldlg2 | fmulp st1 st0 | fistp D@iExp

        .If D@iExp L 16
            fld st0 | frndint | fcomp st1 | fstsw ax
            Test ax 040 ZERO L1>
                Call FloatToBCD

                Mov eax 17 | Mov ecx D@iExp | sub eax ecx | inc ecx
                lea esi D$TempoAsciiFpu+eax

                If B$esi = '0'
                    inc esi | dec ecx
                End_If

                Mov eax 0
                rep movsb | jmp L9>>

        .End_If

L1:     Mov eax, 6 | sub eax D@iExp

        Call PowerOf10

        fcom Q$ten7 | fstsw ax | Test ah 1 ZERO L1>
            fmul Q$ten | dec D@iExp

L1:     Call FloatToBCD

        lea esi D$TempoAsciiFpu+11 | Mov ecx D@iExp

        If ecx = 0-1
            Mov B$edi '0' | inc edi
        End_If

        inc ecx

        If ecx <= 7
            Mov eax 0
            rep movsb | Mov B$edi '.' | inc edi
            Mov ecx 6 | sub ecx D@iExp | rep movsb

            While B$edi-1 = '0' | dec edi | End_While
            On B$edi-1 = '.', dec edi

            jmp L9>>
        Else
            movsb | Mov B$edi '.' | inc edi | movsd | movsw

            Mov B$edi 'e' | Mov eax D@iExp
            Mov B$edi+1 '+'
            Test eax 0_8000_0000 ZERO L1>
                neg eax | Mov B$edi+1 '-'

L1:         Mov ecx 10, edx 0 | div ecx | add dl '0' | Mov B$edi+4 dl
            Mov edx 0 | div ecx | add dl '0' | Mov B$edi+3 dl
            Mov edx 0 | div ecx | add dl, '0' | Mov B$edi+2 dl
            add edi 5
        End_If

L9:     Mov B$edi 0 | fldcw W@ControlWord | fwait

        If B$NegatedReg = &TRUE
            Mov eax D@Float80Pointer | xor D$eax+9 0_80
        End_If
EndP


[SpecialFPU: D$ ?]

Proc DisassemblerFloatToUString:
    Arguments @Float80Pointer, @DestinationPointer
    Local @iExp, @ControlWord, @MyControlWord
    Uses esi, edi, edx, ecx

        Mov B$SpecialFPU &FALSE
        Mov edi D@DestinationPointer, eax D@Float80Pointer

        ..If D$eax = 0
            .If D$eax+4 = 0
                If W$eax+8 = 0
                    Mov B$edi '0', B$edi+1 0

EndP

                End_If
            .End_If
        ..End_If

        Mov B$NegatedReg &FALSE
        Test B$eax+9 0_80 ZERO L1>
          xor D$eax+9 0_80 | Mov B$NegatedReg &TRUE | Mov B$edi '-' | inc edi

L1:     ;  _______________________________________________________
        ; |        |                 |             |              |
        ; | Bit 79 | Bit 78 ... 64   | Bit 63      | Bit 62 ... 0 |
        ; | Sign   | Biased Exponent | Integer Bit | Fraction     |
        ; |________|_________________|_____________|______________|
        ;
        ; SNaN  : S=0  E=7FFF  I=1  F=1..3FFF_FFFF_FFFF_FFFF
        ; QNaN  : S=0  E=7FFF  I=1  F=4000_0000_0000_0000..7FFF_FFFF_FFFF_FFFF
        ; INF   : S=0  E=7FFF  I=1  F=0
        ; -SNaN : S=1  E=7FFF  I=1  F=1..3FFF_FFFF_FFFF_FFFF
        ; -QNaN : S=1  E=7FFF  I=1  F=4000_0000_0000_0000..7FFF_FFFF_FFFF_FFFF
        ; -INF  : S=1  E=7FFF  I=1  F=0

        ; Add: Tiny : S=x  E=0     I=0  F<>0

        movzx edx W$eax+8 | and edx 07FFF ; edx = E

        If edx = 07FFF
            Mov B$SpecialFPU &TRUE

EndP

        End_If

        fclex | fstcw W@ControlWord | Mov W@MyControlWord 027F | fldcw W@MyControlWord

        fld T$eax | fld st0

        fxtract | fstp st0 | fldlg2 | fmulp st1 st0 | fistp D@iExp

        .If D@iExp L 16
            fld st0 | frndint | fcomp st1 | fstsw ax
            Test ax 040 ZERO L1>
                Call FloatToBCD

                Mov eax 17 | Mov ecx D@iExp | sub eax ecx | inc ecx
                lea esi D$TempoAsciiFpu+eax

                If B$esi = '0'
                    inc esi | dec ecx
                End_If

                Mov eax 0
                rep movsb | jmp L9>>

        .End_If

L1:     Mov eax, 6 | sub eax D@iExp

        Call PowerOf10

        fcom Q$ten7 | fstsw ax | Test ah 1 ZERO L1>
            fmul Q$ten | dec D@iExp

L1:     Call FloatToBCD

        lea esi D$TempoAsciiFpu+11 | Mov ecx D@iExp

        If ecx = 0-1
            Mov B$edi '0' | inc edi
        End_If

        inc ecx

        If ecx <= 7
            Mov eax 0
            rep movsb | Mov B$edi '.' | inc edi
            Mov ecx 6 | sub ecx D@iExp | rep movsb

            While B$edi-1 = '0' | dec edi | End_While
            On B$edi-1 = '.', dec edi

            jmp L9>>
        Else
            movsb | Mov B$edi '.' | inc edi | movsd | movsw

            Mov B$edi 'e' | Mov eax D@iExp
            Mov B$edi+1 '+'
            Test eax 0_8000_0000 ZERO L1>
                neg eax | Mov B$edi+1 '-'

L1:         Mov ecx 10, edx 0 | div ecx | add dl '0' | Mov B$edi+4 dl
            Mov edx 0 | div ecx | add dl '0' | Mov B$edi+3 dl
            Mov edx 0 | div ecx | add dl, '0' | Mov B$edi+2 dl
            add edi 5
        End_If

L9:     Mov B$edi 0 | fldcw W@ControlWord | fwait

        If B$NegatedReg = &TRUE
            Mov eax D@Float80Pointer | xor D$eax+9 0_80
        End_If
EndP
____________________________________________________________________________________________
; EOT
TITLE IncInc          ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
  Purpose: Modifying at once a TITLE for several RosAsm PEs. This Title must have
  an identical .inc Version on the Disk. Modifying the File.inc will automatically
  modify the Title(s) in all concerned PEs when re-Compiling them.

  When reading:

  >PREPARSE IncInclude

  the Parser parses, for example, the:

  >INCINCLUDE E:\RosAsm\Macros.inc

  Statement, opens the indicated File and compares it with the actual
  
  TITLE Macros

  If identical, it does nothing. If different, it replaces the concerned Title, both
  in the user Source, and in the actually computed 'Cooked Source'.
;;


;;
    Added by /\\o//\(Half). updated 01/10
    
    Add resource 10, a dialog, that shows all includes, as a checklist for inclusion
    (if incincludes are present)
    
    Wanted really a CHECKLIST instead of a ListBox, 
    but added a list box, and fills it with yes no, when clicked instead.
    --Plus one list saying MOD for the files that differs from current source
    A button toggles between yes and no to include everything.
    
;;

[IncludeListBox                     101
 IncludeCheckListBox                102
 IncludeChangedCheckListBox         103
 SelectAllButton                    10
 id_IncludeListCompilationDialog    30]

[IncludeUncheckedString:"No  " EOS
 IncludeCheckedString:  "Yes " EOS
 IncludeChangedString:  "Mod" EOS
 IncludeUnChangedString:" " EOS]

[IncInc_MaxFiles 100]

[H.IncludeListCompilationDialog:  D$ ?

 Incinc.FileList: D$ ?
;;
   The file list is formated as :
   Count, SizeString1, String1, SizeString2, String2 ....ect... (Temp virtual mem)
   where SizeString is a "packed" dword, where the upper word is 0FF00 before
   the dialog is shown, to indicate MODIFIED titles. And it is 0FFFF on exit
   to tell which file has been selected. The lower word is the Length of the
   string.
;;

 EnableSubstitution: D$ ?
;;
 This is a boolean variable that when TRUE, will include changed files and when 
 false will only evaluate state.
;;

 IncInc.TitleChanged: D$ ?
 ; Set to true per file, when the file differs from source

 IncInc.SomeTitleHasChanged: D$ ?]
;;
    Set to true if ANY of the titles has changed
    and skips showing the dialog if no titles 
    changed.
;;

;;
   Uses the Incinc.FileList memory
   to display 3 lists [FILENAME, SELECTSTATUS, CHANGEDSTATUS]
;;
FillIncludeListBox:
    Mov ebx D$Incinc.FileList
    Mov edx D$Incinc.FileList
    Push D$edx
        add ebx 4
      L0:
        add ebx 4
        Push ebx edx
            Push ebx
                Mov eax D$ebx-4
                movzx eax ax
                add ebx eax
                while b$ebx <> '\' | dec ebx | end_while
                Call 'USER32.SendDlgItemMessageA',
                    D$H.IncludeListCompilationDialog,
                    IncludeListBox,
                    &LB_ADDSTRING,
                    0,
                    ebx
                Call 'USER32.SendDlgItemMessageA',
                    D$H.IncludeListCompilationDialog,
                    IncludeCheckListBox,
                    &LB_ADDSTRING,
                    0,
                    IncludeUncheckedString
            Pop ebx
            Mov eax D$ebx-4 | shr eax 16 | cmp ax 0ff00 | jne L1>
                Call 'USER32.SendDlgItemMessageA',
                    D$H.IncludeListCompilationDialog,
                    IncludeChangedCheckListBox,
                    &LB_ADDSTRING,
                    0,
                    IncludeChangedString

                jmp L2>
            L1:
                Call 'USER32.SendDlgItemMessageA',
                    D$H.IncludeListCompilationDialog,
                    IncludeChangedCheckListBox,
                    &LB_ADDSTRING,
                    0,
                    IncludeUnChangedString
            L2:
        Pop edx ebx
        Mov eax D$ebx-4





        movzx eax ax
        add ebx eax
        dec D$edx | jnz L0<<
    Pop D$edx

ret

[SelItem: D$ ?]

;;
   Retrive the current selected listbox item, 
   and mark the corresponding file as selected in the Incinc.FileList
;;

ToggleIncludeFileList:
  Call 'USER32.SendDlgItemMessageA',
    D$H.IncludeListCompilationDialog,
    IncludeListBox,
    &LB_GETCURSEL,
    0,
    0

  Mov D$SelItem eax

  ;*bininc.filename* is available, because we will rewrite it later, so we borrow it
  Call 'USER32.SendDlgItemMessageA',
        D$H.IncludeListCompilationDialog,
        IncludeCheckListBox,
        &LB_GETTEXT,
        eax,
        bininc.Filename

  Mov ebx bininc.Filename

  cmp D$ebx 'Yes ' | je L0>
    Call SetIncludeCheckList IncludeCheckedString
    jmp L1>
  L0:
    Call SetIncludeCheckList IncludeUnCheckedString
  L1:

ret

;;
    Marks the selected file as included, exludes and
    updates the list. 
;;

Proc SetIncludeCheckList:
Argument @Value

  Mov ecx D$SelItem
  Mov edx D$Incinc.FileList
  add edx 4
  while ecx > 0
      Mov eax D$edx
      and eax 0_FFFF
      add edx eax
      add edx 4
      dec ecx
  end_while

  If D@Value = IncludeCheckedString
    or D$edx 0_FFFF_0000
  Else
    and D$edx 0_FFFF
  End_If

  Call 'USER32.SendDlgItemMessageA' D$H.IncludeListCompilationDialog,

                                    IncludeCheckListBox, &LB_INSERTSTRING D$SelItem, D@Value
  inc D$SelItem
  Call 'USER32.SendDlgItemMessageA' D$H.IncludeListCompilationDialog,

                                    IncludeCheckListBox, &LB_DELETESTRING D$SelItem, 0
EndP

;;
    Tests the first listbox item and sets all item to the oposite value
;;
ToggleAll:
  Call 'USER32.SendDlgItemMessageA' D$H.IncludeListCompilationDialog,
                                      IncludeCheckListBox, &LB_GETTEXT 0, bininc.Filename
  Mov ebx bininc.Filename
  cmp D$ebx 'Yes ' | je L0>

  Call 'USER32.SendDlgItemMessageA' D$H.IncludeListCompilationDialog,
                                    IncludeCheckListBox, &LB_GETCOUNT 0, 0
  Mov D$SelItem 0
  While D$SelItem < eax
     Push eax | Call SetIncludeCheckList IncludeCheckedString | Pop eax
  End_While
ret
  L0:

  Call 'USER32.SendDlgItemMessageA' D$H.IncludeListCompilationDialog,
                                    IncludeCheckListBox, &LB_GETCOUNT 0, 0
  Mov D$SelItem 0
  While D$SelItem < eax
     Push eax | Call SetIncludeCheckList IncludeUnCheckedString | Pop eax
  End_While
ret

;;
    Callback for the dialog.
;;
Proc IncludeListCompilationDialogCallBack:
    Arguments @hwnd, @msg, @wParam, @lParam

        pushad

        Mov eax &FALSE
        ..If D@msg = &WM_COMMAND
            Mov eax D@wParam
            If D@wParam = &IDCANCEL
                Call 'USER32.EndDialog' D@hwnd, 0
            Else_if,
               ax = IncludeListBox
               shr eax 16
               cmp ax &LBN_DBLCLK | jne L0>
                  Call ToggleIncludeFileList
               L0:
            Else_if,
               ax = SelectAllButton
                  Call ToggleAll
            End_If

            On D@wParam = &IDOK, Call 'USER32.EndDialog',
                                      D$H.IncludeListCompilationDialog,
                                      1



        ..Else_If D@msg = &WM_INITDIALOG
            Mov eax D@hwnd | Mov D$H.IncludeListCompilationDialog eax
            Call FillIncludeListBox

        ..Else

            popad | Mov     eax &FALSE | ExitP
        ..End_If

        popad | Mov eax &TRUE
EndP


;;
    called to display the dialog
    the  Incinc.FileList must be initialized.
;;
DisplayIncludeListCompilationDialog:
  Call 'USER32.DialogBoxParamA',
   D$H.Instance,
   id_IncludeListCompilationDialog ,
   0,
   IncludeListCompilationDialogCallBack,
   0
ret
____________________________________________________________________________________________

[incinc.errornotfound: B$ 'IncIncluder: File not found!' EOS]


;;
    This is the original code. Basically locates and
    compares the TITLE in this app, against the loaded title
    (loaded at D$bininc.mem)
    
    
    My additions is just to compile a list of the changed and unchanged files
    and show to the user so he can select the once to update.
;;

UpdateTitlesFromIncludeFiles:
    Mov D$OldStackPointer esp

    Call GetResourcesSize
    add eax D$SourceLen | add eax 1_000_000 | add eax D$MemReservation
    Mov D$AsmTablesLength eax

    Call VirtualAlloc CodeSourceA,
                      eax

    add D$CodeSourceA 010

    Call NewCopyToCodeSourceA D$CodeSource, D$SourceLen

    Call CheckTextDelimitersPairing
    Call KillMultiLineComments ; and Comments
   ; Call KillSingleLineComments
    Call NewKillVirtualCRLF
    Call KillMeaninglessCommas
    Call CheckandKillPreParsers


    Mov B$ErrorLevel 9
    Mov D$IncInc.SomeTitleHasChanged &FALSE
    Mov D$EnableSubstitution &FALSE

    Call VirtualAlloc Incinc.FileList,
                      (&MAX_PATH*IncInc_MaxFiles)

    Mov esi D$CodeSourceA
    Mov ecx esi | add ecx D$StripLen | Mov D$EcxSave ecx

    .While esi < D$EcxSave
        cmp D$esi   'INCI' | jne L8>>
        cmp D$esi+4 'NCLU' | jne L8>>
        cmp W$esi+8 'DE'   | jne L8>>
        cmp B$esi-1 LF | jne L8>>
        cmp B$esi+10 SPC | ja L8>>

        add esi 10
L3:     inc esi | cmp B$esi SPC | jbe L3<

        Mov edx bininc.filename
L3:         Mov al B$esi | Mov B$edx al
            inc esi | inc edx
        cmp B$esi SPC | ja L3<
        Mov B$edx 0

      ; Clear the 'INCLUDE xxxxxxx' Statement:
        Mov ebx esi | While D$esi <> 'INCI' | dec esi | End_While
        While esi < ebx | Mov B$esi SPC | inc esi | End_While

____________________________________________________________________________________________
;;
    Generate a file list, and show to user before including any of those
;;
        Mov ebx D$Incinc.FileList | inc D$ebx | add ebx 4

        While D$ebx <> 0
            Mov eax D$ebx | and eax 0_FFFF
            add ebx eax | add ebx 4 |
        End_While

        add ebx 4
        Mov edx bininc.filename
        Push ebx
            While b$edx <> 0
                Push w$edx | Pop w$ebx
                cmp b$edx+1 0 | add edx 2
                add ebx 2 | je L0> |
            End_While
            inc ebx
            jmp L1>
            L0:

            L1:
        Pop ecx
____________________________________________________________________________________________

        pushad

            Call ReadIncFile

            If eax = &TRUE

                Mov D$IncInc.TitleChanged &FALSE

                Call CompareIncToTitle

                Call VirtualFree bininc.mem

            Else

            End_If

        popad
____________________________________________________________________________________________

        sub ebx ecx | xchg ebx ecx
        Mov D$ebx-4 ecx
        If D$IncInc.TitleChanged = &TRUE
           or D$ebx-4 0_ff00_0000
           Mov D$IncInc.SomeTitleHasChanged &TRUE
        End_If


L8:     inc esi
    .End_While

    Mov edx D$Incinc.FileList
    cmp D$edx 0 | je L9>>


    cmp D$IncInc.SomeTitleHasChanged &TRUE | jne L9>>

    Call DisplayIncludeListCompilationDialog

    ..If eax = &IDOK


       Mov edx D$Incinc.FileList
       Mov ecx D$edx
       add edx 4
       .while ecx > 0
            Mov eax D$edx
            and D$edx 0_FFFF
            shr eax 16
            add edx 4
            .If ax = 0FFFF
              pushad

                Call ClearPATH bininc.filename

                Mov eax bininc.filename
                while B$edx <> EOS
                      Push W$edx | Pop W$eax
                      cmp B$edx+(1*ASCII) EOS | je L0>
                      add edx (2*ASCII) | add eax (2*ASCII)
                End_While
                L0:
                Call ReadIncFile
                If eax = &TRUE
                    Mov D$EnableSubstitution &TRUE
                    Mov D$IncInc.TitleChanged &FALSE
                    Call CompareIncToTitle

                    Call VirtualFree bininc.mem

                Else
                End_If
              popad

            .End_If
            add edx D$edx-4
            dec ecx
       .end_while




    ..End_If


L9:

    Call VirtualFree Incinc.FileList

    Call VirtualFree CodeSourceA

ret

ClearIncludeStateMentsFromSource:
 Mov esi D$CodeSourceA
 Mov ecx esi | add ecx D$StripLen | Mov D$EcxSave ecx
 .While esi < D$EcxSave
        cmp D$esi   'INCI' | jne L8>>
        cmp D$esi+4 'NCLU' | jne L8>>
        cmp W$esi+8 'DE'   | jne L8>>

        add esi 10

L3:     inc esi | cmp B$esi SPC | jbe L3<

        Mov edx bininc.filename
L3:         Mov al B$esi | Mov B$edx al
            inc esi | inc edx
        cmp B$esi SPC | ja L3<
        Mov B$edx 0

        Mov ebx esi | While D$esi <> 'INCI' | dec esi | End_While
        While esi < ebx | Mov B$esi SPC | inc esi | End_While

L8:     inc esi
 .End_While


ret
____________________________________________________________________________________________

ReadIncFile:
    pushad
        Call 'KERNEL32.CreateFileA' bininc.filename,
                                    &GENERIC_READ,
                                    &FILE_SHARE_READ__&FILE_SHARE_WRITE,
                                    &NULL,
                                    &OPEN_EXISTING,
                                    &FILE_ATTRIBUTE_NORMAL,
                                    &NULL
        Mov D$H.bininc.file eax

        .If eax = &INVALID_HANDLE_VALUE

            Call MessageBox incinc.errornotfound

    popad

    Mov eax &FALSE

ret

        .End_If

        Call 'KERNEL32.GetFileSize' eax, 0 | Mov D$bininc.filesize eax | add eax 4
;;
        .If eax > (1024*1024*2) ; 1MB
            Call MessageBox incinc.errorsize
            Call 'KERNEL32.CloseHandle' D$H.bininc.file
            popad
            jmp L8>>
        .End_If
;;
        Call VirtualAlloc bininc.mem,
                          eax

        Mov eax D$bininc.mem, D$eax CRLF2 | add D$bininc.mem (4*BYTE)

        Call 'KERNEL32.ReadFile' D$H.bininc.file, D$bininc.mem, D$bininc.filesize,
                                 NumberOfReadBytes, 0
        Call 'KERNEL32.CloseHandle' D$H.bininc.file

    popad

    Mov eax &TRUE
ret
____________________________________________________________________________________________

[INcSuccess: D$ ?
 IncTitleName: D$ ?
 StartOfChunk: D$ ?
  EndOfChunk: D$ ?]

CompareIncToTitle:
    Mov B$IncSuccess &FALSE

    Call CoolParsersOnInc

    Mov edi bininc.filename
    While B$edi <> 0 | inc edi | End_While
    While B$edi <> '\'
        dec edi | On edi = bininc.filename, jmp L1>
        On B$edi = '.', Mov B$edi 0
    End_While
    inc edi

L1: Mov D$IncTitleName edi

L1: Mov esi D$CodeSourceA, edx D$StripLen | add edx esi

    .While esi < edx
        ...If B$esi = '"'
            Do | inc esi | Loop_Until B$esi = '"'
        ...Else_If B$esi = "'"
            Do | inc esi | Loop_Until B$esi = "'"
        ...Else_If D$esi = 'TITL'
            ..If B$esi-1 = LF
                On W$esi+4 <> 'E ', jmp L0>>
                    Mov D$StartOfChunk esi | add esi 5
                    While B$esi = SPC | inc esi | End_While
                    Push edi
                        Mov ecx 0FF | repe cmpsb
                        .If B$edi-1 = 0
                            Push esi, edi
                                Mov edi D$bininc.mem,  ecx D$bininc.filesize
                                While D$esi <> 'TITL' | dec esi | End_While

                                L5: repe cmpsb
                                cmp b$esi-1 '$' | je L5<

                                While D$esi  <> 'TITL'
                                    On esi = edx, jmp L1>
                                    On B$esi > SPC, inc ecx
                                    inc esi
                                End_While
L1:                             Mov D$EndOfChunk esi
                            Pop edi, esi

@ininc_ChangesBegin:
______________________________________________
                            If ecx <> 0
;;
  This was used as a small security against overwriting NEW code
  earlier. It still works, but isnt needed.
  
  
                                Push ecx
                                  Call 'USER32.MessageBoxA' D$H.MainWindow, D$IncTitleName,
                                  IncDoneTitle, 
                                  &MB_SYSTEMMODAL + &MB_YESNOCANCEL + &MB_ICONQUESTION
                                Pop ecx
                                cmp eax &IDYES|jne @SkipIncludingFile
                                cmp eax &IDCANCEL|jne @IncludeIt

                                Mov B$INcSuccess &FALSE| Pop edi | jmp L9>
;;
                               @IncludeIt:
                                Mov D$IncInc.TitleChanged &TRUE
                                cmp D$EnableSubstitution &TRUE | jne @SkipIncludingFile
                                Call SubstituteTitleByCookedInc
                                Call SubstituteUserTitleByInc
                                Mov esi D$IncTitleName, edi IncDoneTitle | add edi 22
                                While B$esi <> 0 | movsb | End_While | Mov B$edi 0


                            End_If
 ______________________________________________


                            @SkipIncludingFile:

                            Mov B$INcSuccess &TRUE| Pop edi | jmp L9>


                        .End_If
                    Pop edi
            ..End_If
        ...End_If

L0:     inc esi
    .End_While


[NoIncTitle: B$ 'Include File.inc without the required TITLE                           ' EOS]
[IncDoneTitle: B$ "You current include file is diffrent from shared source." ,
                  " Overwrite current TITLE ???? " EOS]

L9: If B$INcSuccess = &FALSE
        Mov esi D$IncTitleName, edi NoIncTitle | add edi 44
        While B$esi <> 0 | movsb | End_While | Mov B$edi 0

        error NoIncTitle
    End_If
ret
____________________________________________________________________________________________

[ModifiedSourceSize: D$ ?]

SubstituteTitleByCookedInc:  ; ControlD asmmain
    Mov ebx D$CodeSourceA | add ebx D$StripLen
    Mov edx D$CodeSourceA | add edx D$SourceLen | add edx 1_000_000
    Mov ecx D$bininc.mem | add ecx D$bininc.filesize

    Mov eax D$EndOfChunk | sub eax D$StartOfChunk
    sub eax ecx | add eax D$bininc.mem
    neg eax | Mov D$ModifiedSourceSize eax

    Call ChunkReplace D$StartOfChunk, D$EndOfChunk, ebx, edx, D$bininc.mem, ecx

    Mov eax D$ModifiedSourceSize | add D$StripLen eax
ret


SubstituteUserTitleByInc:

    Call VirtualFree bininc.mem

  ; Restore the File.inc extension:
    Mov esi bininc.filename | While B$esi <> 0 | inc esi | End_While | Mov B$esi '.'
    Call ReadIncFile

    Mov eax D$bininc.mem | add eax D$bininc.filesize | Mov ecx eax

    Mov eax D$StartOfChunk | sub eax D$CodeSourceA | add eax D$CodeSource
    Mov D$StartOfChunk eax

    Mov ebx D$EndOfChunk | sub ebx D$CodeSourceA | add ebx D$CodeSource
    Mov D$EndOfChunk ebx

    Call ChunkReplace D$StartOfChunk, D$EndOfChunk, D$STRUCT.EditData@SourceEnd, D$EndOfSourceMemory,
                      D$bininc.mem, ecx

    Mov eax D$ModifiedSourceSize | add D$STRUCT.EditData@SourceEnd eax | add D$SourceLen eax

    Mov edi D$STRUCT.EditData@SourceEnd, D$edi CRLF2
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE BinInc          ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
____________________________________________________________________________________________
____________________________________________________________________________________________

                    Binary File Includer. Author: Kenny.
                    
____________________________________________________________________________________________

I did several minor modification to the original version:

* Write the Bytes Values in Hexa Format (faster than Decimal).

* Replace the Equate form for the Data Length by a usual 'len' in Data.

This small Pre-Parser seems to me a good idea. Something like RcData, directely into
.Data section, and, so forth more flexible, and without the .rsrc size problem and
usual complications.


Betov.
____________________________________________________________________________________________
____________________________________________________________________________________________

This is a preparser that adds a file to the source at compile time. The syntax is as follows

PREPARSE BinIncluder ; <- this enables the preparser to look for the keyword 'bininclude'
[bininclude myfile.xxx:] ; <- this tells the parser what file to include...

the preparser opens the file, and inputs the file as binary into the data section by creating
something that looks like this:

   [myfile.xxx: B$ 01E 026 085 ... 05 028 08F ... myfile.xxx_Len: len]

You will never actually see the above, but you can use it like it's there:

 > Mov al B$myfile.xxx      ; al = 010
 > Mov eax myfile.xxx       ; eax = pointer to the file contents
 > Mov eax myfile.xxx_len   ; eax = size of file

Enjoy!...
;;

[bininc.filename: B$ ? # &MAX_PATH]
[H.bininc.file: D$ ?
 bininc.filesize: D$ ?
 bininc.mem: D$ ?
 EcxSave: D$ ?]

[bininc.errornotfound: B$ 'BinIncluder: File not found!' EOS]
[bininc.errorSyntax: B$ 'Bad BININCLUDE syntax' EOS]

BinIncluderParser:
    Call ExtendMemForBinIncluder

    Mov esi D$CodeSourceA, edi D$CodeSourceB
    Mov ecx esi | add ecx D$StripLen | Mov D$EcxSave ecx


    .While esi < D$EcxSave
        cmp D$esi   'BINI' | jne L8>>
        cmp D$esi+4 'NCLU' | jne L8>>
        cmp W$esi+8 'DE'   | jne L8>>
        cmp B$esi-1 Openbracket | jne L8>>

        add esi 10
L3:     inc esi | cmp B$esi SPC | jbe L3<

        Mov edx bininc.filename
L3:         Mov al B$esi | Mov B$edx al
            inc esi | inc edx
        cmp B$esi SPC | ja L3<
        Mov B$edx 0

        pushad
            Call 'KERNEL32.CreateFileA' bininc.filename,
                                        &GENERIC_READ,
                                        &FILE_SHARE_READ__&FILE_SHARE_WRITE,
                                        &NULL,
                                        &OPEN_EXISTING,
                                        &FILE_ATTRIBUTE_NORMAL,
                                        &NULL
            Mov D$H.bininc.file eax

            Call 'KERNEL32.GetFileSize' eax, 0 | Mov D$bininc.filesize eax

            Call VirtualAlloc bininc.mem,
                              eax

            Call 'KERNEL32.ReadFile' D$H.bininc.file, D$bininc.mem, D$bininc.filesize,
                                     NumberOfReadBytes 0
            Call 'KERNEL32.CloseHandle' D$H.bininc.file
        popad

        Push esi
            Mov esi bininc.filename
L3:         movsb | cmp D$esi 0 | jne L3<
        Pop esi

        movsb ; store the colonsign

        Mov al 'B' | stosb | Mov al memMarker | stosb

        Push esi
            Mov esi D$bininc.mem
            Mov ecx D$bininc.filesize
L3:         movzx eax B$esi | inc esi | Call WriteEax
            Mov al Space | stosb | loop L3<

            Mov esi bininc.filename
            While B$esi > 0 | movsb | End_While
            Mov D$edi 'LEN:' | Mov B$edi+3 ColonSign | add edi 4
            Mov D$edi 'LEN]' | add edi 3

            Call VirtualFree bininc.mem

        Pop esi

L8:     movsb
    .End_While

    sub edi D$CodeSourceB | Mov D$StripLen edi
    Exchange D$CodeSourceA D$CodeSourceB
ret


[InIncludeSize: D$ ?
 CopyOfCodeSourceA: D$ ?
 CopyOfCodeSourceB: D$ ?]

ExtendMemForBinIncluder:
    Mov B$ErrorLevel 9
    Mov esi D$CodeSourceA, D$InIncludeSize 0
    Mov ecx esi | add ecx D$StripLen | Mov D$EcxSave ecx

    .While esi < D$EcxSave
        cmp D$esi   'BINI' | jne L8>>
        cmp D$esi+4 'NCLU' | jne L8>>
        cmp W$esi+8 'DE'   | jne L8>>
        cmp B$esi-1 Openbracket | jne L8>>

        add esi 10
L3:     inc esi | cmp B$esi SPC | jbe L3<

        Mov edx bininc.filename
L3:         Mov al B$esi | Mov B$edx al
            inc esi | inc edx
        cmp B$esi SPC | ja L3<
        Mov B$edx 0

        If B$esi <> ColonSign
            error bininc.errorSyntax
        Else_If B$esi+1 <> CloseBracket
            error bininc.errorSyntax
        End_If

        pushad
            Call 'KERNEL32.CreateFileA' bininc.filename,
                                        &GENERIC_READ,
                                        &FILE_SHARE_READ__&FILE_SHARE_WRITE,
                                        &NULL,
                                        &OPEN_EXISTING,
                                        &FILE_ATTRIBUTE_NORMAL,
                                        &NULL
                Mov D$H.bininc.file eax

            On eax = &INVALID_HANDLE_VALUE, error bininc.errornotfound

            Call 'KERNEL32.GetFileSize' eax, 0 | add D$InIncludeSize eax

            Call 'KERNEL32.CloseHandle' D$H.bininc.file
        popad

L8:     inc esi
    .End_While

  ; Fo 1 Byte from File we will have, at most 0FF + Space > 4 Bytes added in Source:
    shl D$InIncludeSize 2

    .If D$InIncludeSize > 500_000
        Mov eax D$SourceLen | add eax 1_000_000 | add eax D$InIncludeSize

        Call VirtualAlloc CopyOfCodeSourceA,
                          eax

        add D$CopyOfCodeSourceA 010

        Call VirtualAlloc CopyOfCodeSourceB,
                          eax

        add D$CopyOfCodeSourceB 010

        Mov ecx D$SourceLen | AlignOn 4 ecx | shr ecx 2
        Push ecx
            Mov esi D$CodeSourceA, edi D$CopyOfCodeSourceA | rep movsd
        Pop ecx
        Mov esi D$CodeSourceB, edi D$CopyOfCodeSourceB | rep movsd

        Exchange D$CodeSourceA D$CopyOfCodeSourceA, D$CodeSourceB D$CopyOfCodeSourceB

        Call VirtualFree CopyOfCodeSourceA

        Call VirtualFree CopyOfCodeSourceB

    .End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE NewParser       ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;;

 If you want to write a new RosAsm Pre-Parser, this is the room where to start:

 Author name: ...

 eMail: ...

 Home Page, if any: ...
____________________________________________________________________________________________

 Description (Purpose / Syntaxe(s) / ...).
 
    This has to be a text, ready to be included inside the B_U_Asm File, and you should
    first write this before writing any Instruction. If you are not able to provide the
    user Manual, at least partially and temporary, *before* writing the Implementation,
    you have a real problem...
    
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
 This is the room where volunteers will start the developement of a new PREPARSE Parser.
 Everything is ready to run. If you write a Source with:
 
 > PREPARSE New
 
 at the Top of Source, 'NewParser', down there, will be run.
 
 'New' is the temporary name of your new Pre-Parser (i will update it when ready for
 release).
 
 The job of a Pre-Parser is nothing but the front-end job of any Compiler, wich is
 nothing but replacing a Statement by another one, or by a flow of other ones, and
 ready to be assembled the regular way. So, this all should remain a "simple" (...)
 substitutions work.
 
 ____________________________________________________________________________________________

 Here is now what you have to know, in order to implement a New Pre-Parser:
 
 At this level of the Compile Process, the user Source, that you read from 'CodeSourceA'
 and have to rewrite into 'CodeSourceB', is no longer simple Ascii, but, instead a
 'coocked Ascii' Source.
 
 Before coming here, the Compile Process has already run the 'SourceCleaner', which does
 a lot of clean-up and replacements works. Generaly speacking, all of the particular
 Chars that we have to take care of -when parsing a Source-, have been replaced by lower
 Ascii Chars. To see this list of 'particular' Char, Right-Click upon 'MyAsciiTable' 
 and/or the upper 'LowSigns' Table.
 
 The Source you will have to work with has the following characteristics:
 
 * All is upper case
 * SPC is turned 'Space'
 * '|' and CR/LF are turned 'EOI'
 * ',' are stripped of, as well as the next CR/LF if any,... and so on.
 
 Try to memorise all of these substitutions, first, as, for example, you will search
 in vain for any ':' inside the Source (as it now is 'ColonSign' -Ascii 14-...).

____________________________________________________________________________________________

 One important thing to know and respect:
 
 In order to keep track of the real user Source Instructions, all along the Compilation
 processes (up to the Debugger run time stage -!!!...-), when adding new instructions 
 with your new Parser, you have to add a new Separator. The normal separator, inside the 
 'coocked' Source is 'EOI' (Ascii 2), which replaces '|' and CR/LF). When you have
 to introduce a new added intruction (an Instruction that is *not* inside the real user
 Source), you have to add a new separator. This new separator is *not* 'EOI' (Ascii 2), 
 but 'meEOI' (Ascii 1). If this rule is broken, the error manager will point to the wrong
 statement, in the user Source, in error case, in all downward computations (!!!...).
 
____________________________________________________________________________________________
 
 If you need to insert some Labels of yours when Parsing, you may :
 
 > Call CreateNoMeanLabel
 > Call WriteNoMeanLabel
 
 Then, at 'NoMeanLabel', you have a String that you may copy in your output. In case
 of problem, first see how they are used in 'ParaMacrosParser', for example...
 
 The Data Declarations Separators, in that case, are neither 'OpenBracket', 'Closebracket',
 'OpenVirtual', 'CloseVirtual', but simply: '{' and '}'. These Chars are translated into
 the required LowSigns by the donward Computations of the Macros Parser.
 
 Not respecting this point, and the EOI vs meEOI thingies, will foolish the Error
 Manager. To verify that your work respect these constraints, when you have finished
 a working Pre-Parser, just test some Statement(s) making use of it, and, on the next 
 Instruction, produce some on-purpose error. If the error Manager wrongly points to
 a downward Statement, this is because you did an error when insterting a Separator.
 
____________________________________________________________________________________________

  If your Pre-Parser is simple enough, you do not need any Error Management. If something
  is wrong is encounted along your own computation, just abort, and let it go. Downward
  Computations will point out the error and will save you of this complication. If your
  Parser is complex enough and absolutely requires an Errors management, ask me, and i
  will write your Errors Management. (I don't release this, here, by default, in order to
  incitate you to do without, as long as possible).
 
____________________________________________________________________________________________

 Good work. Betov.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________


; Your new Pre-Parser Squeleton:

NewParser: RET  ; <<<<<<<<<<<<<<<<<!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    Mov esi D$CodeSourceA, edi D$CodeSourceB | Mov ecx esi | add ecx D$StripLen

    .While esi < ecx
        ;
        ; Your job...
        ;

        movsb

    .End_While

    sub edi D$CodeSourceB | Mov D$StripLen edi
    Exchange D$CodeSourceA D$CodeSourceB
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Encoder         ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;;
 After prefix(es), encoding opcode, modR/M byte.
 
 SIB, displacement and immediate temporary stored before in parameters analyzes
 will be written after returning from here.

 This might be the more surprising part of RosAsm: The Assembler is *not* Table(s)
 driven (zero Table). More Code / Less Data. But also, much much faster, because
 all this no end Cases selection works in fact a bit like a tree search. Some Cases
 have their specific treatements. The first Checking apply upon the number of Chars.
 After this, the chars Cases parsing works like a Tree.

 This organisation advantages, once the killing typing work is done, are: Speed,
 flexibility in holding any weird coding case, ease of maintainance, even with
 few knowledge.
;;
 _______________________________________________________________________________________


[Absolute | test #1 0_8000_0000 ZERO M0> | neg #1 | M0:]


Encode:
    Mov eax D$imm32, D$ABSimm32 eax ;| Absolute eax | Mov D$ABSimm32 eax
; sIm
    and eax 0_FFFF_FF80
    If eax = 0_FFFF_FF80
        and D$ABSimm32 0_FF | Mov B$SignedImm8 &TRUE
    Else_If D$imm32 < 080
        Mov B$SignedImm8 &TRUE
    Else
        Mov B$SignedImm8 &FALSE
    End_If

    Mov esi D$LineStart,  edi D$CodeListPtr

    Call Store8cars

    ; First, check for special encodings (send down here)

    On ah = 'J',  jmp Letter_J

    On B$esi+3 = '_', jmp J_Branching

    ifnot op1 'M',  L1>
      ifnot op2 'O', L1>
        ifnot op3 'V', L1>
          jmp MOVinstructions

L1: ifnot op1 'S', L1>
      ifnot op2 'E', L1>
        ifnot op3 'T',  L1>
          jmp SETinstructions

L1: ifnot op1 'C', L1>>
      ifnot op2 'M', L1>>
        ifnot op3 'O', L3>
          ifnot op4 'V', L1>
            jmp CMOVinstructions

L3:     cmp op6 Separators | jb L1>   ; CMPXCHG / CMPXCHG8B

        On op4 = 'X', jmp L1>

        Ifnot op3 'P', L1>
          ifnot op4 'P', L4>
            ifnot op5 'S', L5>        ; CMPPS... with given Condition (ex: CMP_SS_LT)
              jmp XMMcomparePS
L5:         ifnot op5 'D', L1>        ; CMPPD...
              jmp XMMcomparePD
L4:       ifnot op4 'S', L4>
            ifnot op5 'S', L5>        ; CMPSS...
              jmp XMMcompareSS
L5:         ifnot op5 'D', L1>        ; CMPSD...
              jmp XMMcompareSD        ; CMPSD with trailing imm is hold by (REP) CMPSD

L4:       ifnot op4 'E', L4>
            jmp TrySSE2
L4:       ifnot op4 'L', L4>
            jmp TrySSE2
L4:       ifnot op4 'N', L4>
            jmp TrySSE2
L4:       ifnot op4 'O', L4>
            jmp TrySSE2
L4:       ifnot op4 'U', L1>
            jmp TrySSE2


L1: ifnot op1 'F', L1>
      jmp Math

L1:    On op3 > Separators,  jmp TreeLetters

L1: ; Two Letters mnemonics:

      ifnot op1 'B', L1>
        ifnot op2 'T', L2>                       ; BT
          Mov op1 001111
          ifnot B$Operands IMM_TO_REG L3>
            Mov op2 00_1011_1010,  op3 00_1110_0000 | jmp op_op_reg1_imm8
L3:       ifnot B$Operands IMM_TO_MEM L3>
            Mov op2 00_1011_1010,  op3 00_0010_0000 | jmp op_op_modRm_imm8
L3:       ifnot B$Operands REG_TO_REG L3>
            Mov op2 00_1010_0011,  op3 00_1100_0000 | jmp op_op_reg2reg1
L3:       ifnot B$Operands REG_TO_MEM L3>
            Mov op2 00_1010_0011 | jmp op_op_modReg2Rm
L3:       BadOperand
L2:     BadMnemonic
L1:   ifnot op1 'I', L1>
        ifnot op2 'N', L2>                        ; IN
          ifnot B$FirstGender GENERAL_REG L4>
            ifnot B$FirstReg 0, L4>           ; reg = 0  for eax, ax, al
          ifnot B$SecondGender IMM_VALUE L3>
            Mov op1 00_1110_0100 | jmp w_imm8
L3:       ifnot B$SecondGender GENERAL_REG L4>
            ifnot B$SecondReg REG_DX L4>
              ifnot B$SecondOperandwBit WORD_SIZE L4>
                If B$FirstOperandwBit = BYTE_SIZE
                    LastOpCode 0EC
                Else                 ; Direct output because of "in al/eax DX".
                    LastOpcode 0ED
                End_If
L4:       BadOperand
L2:     BadMnemonic
L1:   ifnot op1 'O', L1>>
        ifnot op2 'R', L2>>                                 ; OR
          ifnot B$Operands REG_TO_REG L3>
            Mov op1 00_1010,  op2 00_1100_0000 | jmp w_reg1reg2
L3:       ifnot B$Operands MEM_TO_REG L3>
            Mov op1 00_1010 | jmp w_modReg1Rm
L3:       ifnot B$Operands REG_TO_MEM L3>
            Mov op1 00_1000 | jmp w_modReg2Rm
L3:       ifnot B$Operands IMM_TO_REG L3>
            ifnot B$FirstReg REG_EAX L4>
              If B$FirstOperandwBit > BYTE_SIZE
                cmp B$LabelInside &TRUE | je L5>
                cmp B$SignedImm8 &TRUE | je L4>
                ;cmp D$ABSimm32 080 | jb L4>
              End_If
L5:           Mov op1 00_1100 | jmp w_imm
L4:         Mov op1 00_1000_0000,  op2 00_1100_1000 | jmp sw_reg1_imm
L3:       ifnot B$Operands IMM_TO_MEM L3>
            Mov op1 00_1000_0000,  op2 00_1000 | jmp sw_modRm_imm
L3:       BadOperand
L2:     ;BadMnemonic
L1:   BadMnemonic

TreeLetters:  On op4 > Separators,  jmp FourLetters

        ifnot op1 'A', L1>>
          ifnot op2 'A', L2>>
            ifnot op3 'A', L3>
              Mov op1 0011_0111 | jmp OP                             ; AAA
L3:         ifnot op3 'D', L3>
                Mov op1 00_1101_0101
                If B$ParametersNumber = 1
                    jmp Op_imm8
                Else
                    Mov op2 00_1010 | jmp OP_OP    ; AAD
                End_If
L3:         ifnot op3 'M', L3>
                Mov op1 00_1101_0100
                If B$ParametersNumber = 1
                    jmp Op_imm8
                Else
                    Mov op2 00_1010 | jmp OP_OP    ; AAM
                End_If
L3:         ifnot op3 'S', L3>
               Mov op1 0011_1111 | jmp OP                            ; AAS
L3:         BadMnemonic
L2:       ifnot op2 'D', L2>>
            ifnot op3 'C', L3>>  ; >                                  ; ADC
              ifnot B$Operands REG_TO_REG L4>
                Mov op1 0001_0010,  op2 00_1100_0000 | jmp w_reg1reg2
L4:           ifnot B$Operands MEM_TO_REG L4>
                Mov op1 0001_0010 | jmp w_modReg1Rm
L4:           ifnot B$Operands REG_TO_MEM L4>
                Mov op1 0001_0000 | jmp w_modReg2Rm
L4:           ifnot B$Operands IMM_TO_REG L4>
                ifnot B$FirstReg REG_EAX L5>
                  If B$FirstOperandwBit > BYTE_SIZE
                    cmp B$LabelInside &TRUE | je L6>
                    cmp B$SignedImm8 &TRUE | je L5>
                    ;cmp D$ABSimm32 080 | jb L5>
                  End_If
L6:               Mov op1 0001_0100 | jmp w_imm
L5:             Mov op1 00_1000_0000,  op2 00_1101_0000 | jmp sw_reg1_imm
L4:           ifnot B$Operands IMM_TO_MEM L4>
                Mov op1 00_1000_0000,  op2 0001_0000 | jmp sw_modRm_imm
L4:           BadOperand

L3:         ifnot op3 'D', L3>>                               ; ADD  ; sub
              ifnot B$Operands REG_TO_REG L4>
                Mov op1 0010,  op2 00_1100_0000 | jmp w_reg1reg2
L4:           ifnot B$Operands MEM_TO_REG L4>
                Mov op1 0010 | jmp w_modReg1Rm
L4:           ifnot B$Operands REG_TO_MEM L4>
                Mov op1 0 | jmp w_modReg2Rm
L4:           ifnot B$Operands IMM_TO_REG L4>
                ifnot B$FirstReg REG_EAX L5>
                  If B$FirstOperandwBit > BYTE_SIZE
                    cmp B$LabelInside &TRUE | je L6>
                    cmp B$SignedImm8 &TRUE | je L5>
                    ;cmp D$ABSimm32 080 | jb L5>
                  End_If
L6:               Mov op1 00_0100 | jmp w_imm

L5:             Mov op1 00_1000_0000,  op2 00_1100_0000 | jmp sw_reg1_imm

L4:           ifnot B$Operands IMM_TO_MEM L4>
                Mov op1 00_1000_0000,  op2 0 | jmp sw_modRm_imm
L4:           BadOperand
L3:         BadMnemonic
L2:       ifnot op2 'N', L2>>
            ifnot op3 'D', L3>>                        ; AND
              ifnot B$Operands REG_TO_REG L4>
                Mov op1 0010_0010,  op2 00_1100_0000 | jmp w_reg1reg2
L4:           ifnot B$Operands MEM_TO_REG L4>
                Mov op1 0010_0010 | jmp w_modReg1Rm
L4:           ifnot B$Operands REG_TO_MEM L4>
                Mov op1 0010_0000 | jmp w_modReg2Rm
L4:           ifnot B$Operands IMM_TO_REG L4>
                ifnot B$FirstReg REG_EAX L5>
                  If B$FirstOperandwBit > BYTE_SIZE
                    cmp B$LabelInside &TRUE | je L6>
                    cmp B$SignedImm8 &TRUE | je L5>
                    ;cmp D$ABSimm32 080 | jb L5>
                  End_If
L6:               Mov op1 0010_0100 | jmp w_imm
                ; IMM_TO_REG missing in intel doc > verify:
L5:             Mov op1 00_1000_0000,  op2 00_1110_0000 | jmp sw_Reg1_imm
L4:           ifnot B$Operands IMM_TO_MEM L4>
                Mov op1 00_1000_0000,  op2 0010_0000 | jmp sw_modRm_imm
L4:           BadOperand
L3:         BadMnemonic
L2:       BadMnemonic

L1:     ifnot op1 'B', L1>>
          ifnot op2 'S', L2>>
            ifnot op3 'F', L3>                         ; BSF
              ifnot B$Operands REG_TO_REG L4>
                Mov op1 00_1111,  op2 00_1011_1100,  op3 00_1100_0000
                jmp op_op_reg1reg2                         ; intel doc: reverse order (???)
L4:           ifnot B$Operands MEM_TO_REG L4>
                Mov op1 00_1111,  op2 00_1011_1100 | jmp op_op_modreg1Rm
L4:           BadOperand
L3:         ifnot op3 'R', L3>                                     ; BSR
              ifnot B$Operands REG_TO_REG L4>
                Mov op1 00_1111,  op2 00_1011_1101,  op3 00_1100_0000
                jmp op_op_reg1reg2                         ; intel doc: reverse order (???)
L4:           ifnot B$Operands MEM_TO_REG L4>
                Mov op1 00_1111,  op2 00_1011_1101 | jmp op_op_modReg1Rm
L4:           BadOperand
L3:         BadMnemonic
L2:       ifnot op2 'T', L2>>
            ifnot op3 'C', L3>                          ; BTC
              Mov op1 00_1111,  op2 00_1011_1010
              ifnot B$Operands IMM_TO_REG L4>
                Mov op3 00_1111_1000 | jmp op_op_reg1_imm8
L4:           ifnot B$Operands IMM_TO_MEM L4>
                Mov op3 0011_1000 | jmp op_op_modRm_imm8
L4:           Mov op2 00_1011_1011
              ifnot B$Operands REG_TO_REG L4>
                Mov op3 00_1100_0000 | jmp op_op_reg2reg1
L4:           ifnot B$Operands REG_TO_MEM L4>
                jmp op_op_modReg2Rm
L4:           BadOperand
L3:         ifnot op3 'R', L3>                          ; BTR
              Mov op1 00_1111
              ifnot B$Operands IMM_TO_REG L4>
                Mov op2 00_1011_1010,  op3 00_1111_0000 | jmp op_op_reg1_imm8
L4:           ifnot B$Operands IMM_TO_MEM L4>
                Mov op2 00_1011_1010,  op3 0011_0000 | jmp op_op_modRm_imm8
L4:           ifnot B$Operands REG_TO_REG L4>
                Mov op2 00_1011_0011,  op3 00_1100_0000 | jmp op_op_reg2reg1
L4:           ifnot B$Operands REG_TO_MEM L4>
                Mov op2 00_1011_0011 | jmp op_op_modReg2Rm
L4:           BadOperand
L3:         ifnot op3 'S', L3>                          ; BTS
              Mov op1 00_1111
              ifnot B$Operands IMM_TO_REG L4>
                Mov op2 00_1011_1010,  op3 00_1110_1000 | jmp op_op_reg1_imm8
L4:           ifnot B$Operands IMM_TO_MEM L4>
                Mov op2 00_1011_1010,  op3 0010_1000 | jmp op_op_modRm_imm8
L4:           ifnot B$Operands REG_TO_REG L4>
                Mov op2 00_1010_1011,  op3 00_1100_0000 | jmp op_op_reg2reg1
L4:           ifnot B$Operands REG_TO_MEM L4>
                Mov op2 00_1010_1011 | jmp op_op_modReg2Rm
L4:           BadOperand
L3:         ;BadMnemonic
L2:       BadMnemonic

L1:     ifnot op1 'C', L1>>
          ifnot op2 'B', L2>
            ifnot op3 'W', L3>                 ; CBW
              Mov op1 066,  op2 00_1001_1000 | jmp op_op
L3:         BadMnemonic
L2:       ifnot op2 'D', L2>
            ifnot op3 'Q', L3>                 ; CDQ
              Mov op1 00_1001_1001 | jmp op
L3:         BadMnemonic
L2:       ifnot op2 'L', L2>
            ifnot op3 'C', L3>                 ; CLC
              Mov op1 00_1111_1000 | jmp op
L3:         ifnot op3 'D',  L3>                 ; CLD
              Mov op1 00_1111_1100 | jmp op
L3:         ifnot op3 'I', L3>                 ; CLI
              Mov op1 00_1111_1010 | jmp op
L3:         BadMnemonic
L2:       ifnot op2 'M', L2>>
            ifnot op3 'C', L3>                 ; CMC
              Mov op1 00_1111_0101 | jmp op
L3:         ifnot op3 'P',  L3>>                 ; CMP
              ifnot B$Operands REG_TO_REG L4>
                Mov op1 0011_1010,  op2 00_1100_0000 | jmp w_reg1reg2
L4:           ifnot B$Operands MEM_TO_REG L4>
                Mov op1 0011_1010 | jmp w_modReg1Rm
L4:           ifnot B$Operands REG_TO_MEM L4>
                Mov op1 0011_1000 | jmp w_modReg2Rm
L4:           ifnot B$Operands IMM_TO_REG L4>

                ifnot B$FirstReg REG_EAX L5>
                  If B$FirstOperandwBit = BYTE_SIZE
                     Mov op1 03C
                  Else
                      cmp B$LabelInside &TRUE | je L6>
                      cmp B$SignedImm8 &TRUE | je L5>
                      ;cmp D$ABSimm32 080 | jb L5>
L6:                   Mov op1 03D
                  End_If
                  jmp w_imm

L5:             Mov op1 00_1000_0000,  op2 00_1111_1000 | jmp sw_reg1_imm
L4:           ifnot B$Operands IMM_TO_MEM L4>
                Mov op1 00_1000_0000,  op2 0011_1000 | jmp sw_modRm_imm
L4:           BadOperand
L3:         BadMnemonic
L2:       ifnot op2 'W', L2>
            ifnot op3 'D', L3>                ; CWD
              Mov op1 066,  op2 00_1001_1001 | jmp op_op
L3:         ;BadMnemonic
L2:       BadMnemonic
L1:     ifnot op1 'D', L1>>
          ifnot op2 'A', L2>
            ifnot op3 'A', L3>               ; DAA
              Mov op1 0010_0111 | jmp op
L3:         ifnot op3 'S', L3>
              Mov op1 0010_1111 | jmp op
L3:         BadMnemonic
L2:     ifnot op2 'E', L2>
          ifnot op3 'C', L3>                  ; DEC
            ifnot B$FirstGender GENERAL_REG L4>
              cmp B$wBit BYTE_SIZE | jne L5>
              Mov op1 00_1111_1110,  op2 00_1100_1000 | jmp w_reg1    ; alternate shorter >
L5:           Mov op1 0_0100_1000 | jmp reg1_in_op                     ; only full size
L4:         ifnot B$FirstGender MEM_LABEL L4>
              Mov op1 00_1111_1110,  op2 00_1000 | jmp w_modRm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'I', L2>
          ifnot op3 'V', L3>                  ; DIV
            Mov op1 00_1111_0110
            ifnot B$FirstGender GENERAL_REG L4>
              Mov op2 00_1111_0000 | jmp w_reg1
L4:         ifnot B$FirstGender MEM_LABEL L4>
              Mov op2 0011_0000 | jmp w_modRm
L4:         BadOperand
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'H', L1>
        ifnot op2 'L', L2>
          ifnot op3 'T', L3>                  ; HLT
            Mov op1 00_1111_0100 | jmp op
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'I', L1>
        ifnot op2 'N', L2>
          ifnot op3 'C', L3>                 ; INC
            ifnot B$FirstGender GENERAL_REG L4>
              cmp B$wBit BYTE_SIZE | jne L5>
              Mov op1 00_1111_1110 | Mov op2 00_1100_0000 | jmp w_reg1 ; alternate shorter >
L5:           Mov op1 0_0100_0000 | jmp reg1_in_op                      ; only full size
L4:         ifnot B$FirstGender MEM_LABEL L4>
              Mov op1 00_1111_1110 | Mov op2 0 | jmp w_modRm
L4:         BadOperand
;L3:       ifnot op3 'S', L3>                  ; INS
;            Mov op1 00_0110_1100 | jmp OPw
L3:       ifnot op3 'T', L3>                  ; INT
            ifnot D$imm32 3, L4>
              Mov B$immInside &False
              Mov op1 00_1100_1100 | jmp op_P1          ; INT 3
L4:         Mov op1 00_1100_1101 | jmp op_imm8     ; INT n
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'L', L1>>
        ifnot op2 'A', L2>
          ifnot op3 'R', L3>                  ; LAR
            Mov op1 00_1111,  op2 0010
            ifnot B$Operands REG_TO_REG L4>
              Mov op3 00_1100_0000 | jmp op_op_reg1reg2
L4:         ifnot B$Operands MEM_TO_REG L4>
              jmp op_op_modReg1Rm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'D', L2>
          ifnot op3 'S', L3>                     ; LDS
            ifnot B$Operands MEM_TO_REG L4>
              Mov op1 00_1100_0101 | jmp op_modReg1Rm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'E', L2>
          ifnot op3 'A', L3>                       ; LEA
            ifnot B$Operands MEM_TO_REG L4>
            On B$FirstOperandwBit = BYTE_SIZE error D$LeaSizePtr
              Mov op1 00_1000_1101 | jmp op_modReg1Rm
L4:         Error D$LeaTypesPtr
L3:       ifnot op3 'S', L3>                       ; LES
            ifnot B$Operands MEM_TO_REG L4>
              Mov op1 00_1100_0100 | jmp op_modReg1Rm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'F', L2>
          ifnot op3 'S', L3>                       ; LFS
            ifnot B$Operands MEM_TO_REG L4>
              Mov op1 00_1111
               Mov op2 00_1011_0100 | jmp op_op_modReg1Rm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'G', L2>
          ifnot op3 'S', L3>                       ; LGS
            ifnot B$Operands MEM_TO_REG L4>
              Mov op1 00_1111
               Mov op2 00_1011_0101 | jmp op_op_modReg1Rm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'S', L2>
          ifnot op3 'L', L3>
            Mov op1 00_1111,  op2 0011
            ifnot B$Operands REG_TO_REG L4>             ; LSL
              Mov op3 00_1100_0000 | jmp op_op_reg1reg2
L4:         ifnot B$Operands MEM_TO_REG L4>
              jmp op_op_modreg1Rm
L4:         BadOperand
L3:       ifnot op3 'S', L3>                          ; LSS
            ifnot B$Operands MEM_TO_REG L4>
            Mov op1 00_1111, op2 00_1011_0010 | jmp op_op_modReg1Rm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'T', L2>
          ifnot op3 'R', L3>                        ; LTR
            Mov op1 00_1111,  op2 0
            ifnot B$FirstGender GENERAL_REG L4>
              Mov op3 00_1101_1000 | jmp op_op_reg16
L4:         ifnot B$FirstGender MEM_LABEL L4>
              Mov op3 0001_1000 | jmp op_op_modRm16
L4:         BadOperand
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'M', L1>
        ifnot op2 'U', L2>
          ifnot op3 'L', L3>                     ; MUL
            Mov op1 00_1111_0110
            ifnot B$FirstGender GENERAL_REG L4>
              Mov op2 00_1110_0000 | jmp w_reg1
L4:         ifnot B$FirstGender MEM_LABEL L4>
              Mov op2 0010_0000 | jmp w_modRm
L4:         BadOperand
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'N', L1>>
        ifnot op2 'E', L2>
          ifnot op3 'G', L3>                   ; NEG
            Mov op1 00_1111_0110
            ifnot B$FirstGender GENERAL_REG L4>
              Mov op2 00_1101_1000 | jmp w_reg1
L4:         ifnot B$FirstGender MEM_LABEL L4>
              Mov op2 0001_1000 | jmp w_modRm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'O', L2>
          ifnot op3 'P', L3>                   ; NOP
            Mov op1 00_1001_0000 | jmp op
L3:       ifnot op3 'T', L3>                   ; NOT
            Mov op1 00_1111_0110
            ifnot B$FirstGender GENERAL_REG L4>
              Mov op2 00_1101_0000 | jmp w_reg1
L4:         ifnot B$FirstGender MEM_LABEL L4>
              Mov op2 0001_0000 | jmp w_modRm
L4:         BadOperand
L3:       ;BadMnemonic
L2:     BadMnemonic

L1:   ifnot op1 'O', L1>
        ifnot op2 'U', L2>
          ifnot op3 'T', L3>                   ; OUT
            ifnot B$Operands REG_TO_IMM L4>
              Mov op1 0E6
              If B$SecondOperandwBit > BYTE_SIZE
                inc op1
                On B$SecondOperandwBit = WORD_SIZE ToOpcode 066
              End_If
              jmp w_imm8
L4:         ifnot B$Operands REG_TO_REG L4>
              Ifnot B$secondReg REG_EAX L5>
              Ifnot B$FirstReg REG_DX L5>
              Mov op1 0EE
              If B$SecondOperandwBit > BYTE_SIZE
                inc op1
                On B$SecondOperandwBit = WORD_SIZE ToOpcode 066
              End_If
              jmp w_P2
L5:
L4:         BadOperand
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'P', L1>>
        ifnot op2 'O', L2>
          ifnot op3 'P', L3>                     ; Pop
            ifnot B$FirstGender GENERAL_REG L4>
              On B$wBit = BYTE_SIZE BadOperand
              ifnot B$FirstRegGender SEGMENT_REG L5>             ; max. G.P.regs = 00111
                cmp B$FirstReg 0010_0000 | jae L6>         ; REG_FS is 00100000; GS, 00101000
                  Mov op1 00_0111 | jmp sReg2                         ; CS / DS / ES / SS
L6:             Mov op1 00_1111, op2 00_1000_0001 | jmp op_sreg3      ; FS / GS
L5:          ; Mov op1 00_1000_1111,  op2 00_1100_0000 | jmp op_reg1   ; G.P.
              Mov op1 0_0101_1000 | jmp reg1_in_op                      ; register alternate
L4:         ifnot B$FirstGender MEM_LABEL L4>
              On B$wBit = BYTE_SIZE BadOperand
              Mov op1 00_1000_1111,  op2 0 | jmp op_modRm
L4:         BadOperand
L3:       ifnot op3 'R', L3>                       ; POR - Bitwise Or N N N Y
              Mov op1 00_1110_1011 | jmp OQRegMemToReg
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'R', L1>>
        ifnot op2 'C', L2>>
          ifnot op3 'L', L3>>                      ; RCL
              ifnot B$Operands REG_TO_REG L4>
                ifnot B$SecondReg REG_CL L5>
                  Mov op1 00_1101_0010,  op2 00_1101_0000 | jmp w_reg1_P2cl
L4:           ifnot B$Operands REG_TO_MEM L4>
                ifnot B$SecondReg REG_CL L5>
                  Mov op1 00_1101_0010,  op2 0001_0000 | jmp w_modRm_P2cl
L5:           BadOperand
L4:         ifnot B$SecondGender IMM_VALUE L4>
              ifnot D$imm32 1, L5>
                ifnot B$Operands IMM_TO_REG L6>
                  Mov op1 00_1101_0000, op2 00_1101_0000 | jmp w_reg1_P2
L6:             ifnot B$Operands IMM_TO_MEM L6>
                  Mov op1 00_1101_0000, op2 0001_0000 | jmp w_modRm_P2
L6:             BadOperand
L5:           ifnot B$Operands IMM_TO_REG L5>
                Mov op1 00_1100_0000, op2 00_1101_0000 | jmp w_reg1_imm8
L5:           ifnot B$Operands IMM_TO_MEM L5>
                Mov op1 00_1100_0000,  op2 0001_0000 | jmp w_modRm_imm8
L5:           ;BadOperand
L4:         BadOperand

L3:       ifnot op3 'R', L3>>                            ; RCR
              ifnot B$Operands REG_TO_REG L4>
                ifnot B$SecondReg REG_CL L5>
                  Mov op1 00_1101_0010,  op2 00_1101_1000 | jmp w_reg1_P2cl
L4:           ifnot B$Operands REG_TO_MEM L4>
                ifnot B$SecondReg REG_CL L5>
                  Mov op1 00_1101_0010,  op2 0001_1000 | jmp w_modRm_P2cl
L5:           BadOperand
L4:         ifnot B$SecondGender IMM_VALUE L4>
              ifnot D$imm32 1, L5>
                ifnot B$Operands IMM_TO_REG L6>
                  Mov op1 00_1101_0000,  op2 00_1101_1000 | jmp w_reg1_P2
L6:             ifnot B$Operands IMM_TO_MEM L6>
                  Mov op1 00_1101_0000,  op2 0001_1000 | jmp w_modRm_P2
L6:             BadOperand
L5:           ifnot B$Operands IMM_TO_REG L5>
                Mov op1 00_1100_0000,  op2 00_1101_1000 | jmp w_reg1_imm8
L5:           ifnot B$Operands IMM_TO_MEM L5>
                Mov op1 00_1100_0000,  op2 0001_1000 | jmp w_modRm_imm8
L5:           ;BadOperand
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'E', L2>
          ifnot op3 'T', L3>                    ; RET same segment only
            ifnot B$ParametersNumber 0, L5>
L6:           Mov op1 00_1100_0011 | jmp op
L5:         ifnot B$FirstGender IMM_VALUE L4>
              If D$imm32 = 0
                  Mov B$DisInside &False
                  Mov B$ParametersNumber 0
                  Mov B$immInside &FALSE | jmp L6<
              End_If
              Mov op1 00_1100_0010 | jmp op_imm16
L4:         BadOperand
L3:       BadMnemonic

L2:     ifnot op2 'O', L2>>
          ifnot op3 'L', L3>>                    ; ROL
              ifnot B$Operands REG_TO_REG L4>
                ifnot B$SecondReg REG_CL L5>
                  Mov op1 00_1101_0010,  op2 00_1100_0000 | jmp w_reg1_P2cl
L4:           ifnot B$Operands REG_TO_MEM L4>
                ifnot B$SecondReg REG_CL L5>
                  Mov op1 00_1101_0010,  op2 0 | jmp w_modRm_P2cl
L5:           BadOperand
L4:         ifnot B$SecondGender IMM_VALUE L4>
              ifnot B$imm32 1,  L5>
                ifnot B$Operands IMM_TO_REG L6>
                  Mov op1 00_1101_0000,  op2 00_1100_0000 | jmp w_reg1_P2
L6:             ifnot B$Operands IMM_TO_MEM L6>
                  Mov op1 00_1101_0000,  op2 0 | jmp w_modRm_P2
L6:             BadOperand
L5:           ifnot B$Operands IMM_TO_REG L5>
                Mov op1 00_1100_0000,  op2 00_1100_0000 | jmp w_reg1_imm8
L5:           ifnot B$Operands IMM_TO_MEM L5>
                Mov op1 00_1100_0000,  op2 0 | jmp w_modRm_imm8
L5:           ;BadOperand
L4:         BadOperand


L3:       ifnot op3 'R', L3>>                   ; ROR
              ifnot B$Operands REG_TO_REG L4>
                ifnot B$SecondReg REG_CL L5>
                  Mov op1 00_1101_0010,  op2 00_1100_1000 | jmp w_reg1_P2cl
L4:           ifnot B$Operands REG_TO_MEM L4>
                ifnot B$SecondReg REG_CL L5>
                  Mov op1 00_1101_0010,  op2 00_1000 | jmp w_modRm_P2cl
L5:           BadOperand
L4:         ifnot B$SecondGender IMM_VALUE L4>
              ifnot D$imm32 1, L5>
                ifnot B$Operands IMM_TO_REG L6>
                  Mov op1 00_1101_0000,  op2 00_1100_1000 | jmp w_reg1_P2
L6:             ifnot B$Operands IMM_TO_MEM L6>
                  Mov op1 00_1101_0000,  op2 00_1000 | jmp w_modRm_P2
L6:             BadOperand
L5:           ifnot B$Operands IMM_TO_REG L5>
                Mov op1 00_1100_0000, op2 00_1100_1000 | jmp w_reg1_imm8
L5:           ifnot B$Operands IMM_TO_MEM L5>
                Mov op1 00_1100_0000,  op2 00_1000 | jmp w_modRm_imm8
L5:           ;BadOperand
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'S', L2>
          ifnot op3 'M', L3>                         ; RSM
            Mov op1 00_1111,  op2 00_1010_1010 | jmp op_op
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'S', L1>>
        ifnot op2 'A', L2>>
          ifnot op3 'L', L3>
            Mov op2 'H'
               jmp SHL2              ; SAL same instruction as SHL
L3:       ifnot op3 'R', L3>>                ; SAR
              ifnot B$Operands REG_TO_REG L4>
                ifnot B$SecondReg REG_CL L5>
                  Mov op1 00_1101_0010,  op2 00_1111_1000 | jmp w_reg1_P2cl
L4:           ifnot B$Operands REG_TO_MEM L4>
                ifnot B$SecondReg REG_CL L5>
                  Mov op1 00_1101_0010, op2 0011_1000 | jmp w_modRm_P2cl
L5:           BadOperand
L4:         ifnot B$SecondGender IMM_VALUE L4>
              ifnot D$imm32 1, L5>
                ifnot B$Operands IMM_TO_REG L6>
                  Mov op1 00_1101_0000,  op2 00_1111_1000 | jmp w_reg1_P2
L6:             ifnot B$Operands IMM_TO_MEM L6>
                  Mov op1 00_1101_0000,  op2 0011_1000 | jmp w_modRm_P2
L6:             BadOperand
L5:           ifnot B$Operands IMM_TO_REG L5>
                Mov op1 00_1100_0000,  op2 00_1111_1000 | jmp w_reg1_imm8
L5:           ifnot B$Operands IMM_TO_MEM L5>
                Mov op1 00_1100_0000,  op2 0011_1000 | jmp w_modRm_imm8
L5:           ;BadOperand
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'B', L2>>
          ifnot op3 'B', L3>>             ; SBB
            ifnot B$Operands REG_TO_REG L4>
              Mov op1 0001_1010,  op2 00_1100_0000 | jmp w_Reg1Reg2
L4:         ifnot B$Operands MEM_TO_REG L4>
              Mov op1 0001_1010 | jmp w_modReg1Rm
L4:         ifnot B$Operands REG_TO_MEM L4>
              Mov op1 0001_1000 | jmp w_modReg2Rm
L4:         ifnot B$Operands IMM_TO_REG L4>
              ifnot B$FirstReg REG_EAX L5>
                If B$FirstOperandwBit > BYTE_SIZE
                    cmp D$ABSimm32 080 | jb L5>
                End_If
                Mov op1 0001_1100 | jmp w_imm
L5:           Mov op1 00_1000_0000,  op2 00_1101_1000 | jmp sw_reg1_imm
L4:         ifnot B$Operands IMM_TO_MEM L4>
              Mov op1 00_1000_0000,  op2 0001_1000 | jmp sw_modRm_imm
L4:         BadOperand
L3:       BadMnemonic

L2:     ifnot op2 'H', L2>>
          ifnot op3 'L', L3>>                             ; SHL/SAL
SHL2:         ifnot B$Operands REG_TO_REG L4>
                ifnot B$SecondReg REG_CL L5>
                  Mov op1 00_1101_0010,  op2 00_1110_0000 | jmp w_reg1_P2cl
L4:           ifnot B$Operands REG_TO_MEM L4>
                ifnot B$SecondReg REG_CL L5>
                  Mov op1 00_1101_0010,  op2 0010_0000 | jmp w_modRm_P2cl
L5:           BadOperand
L4:         ifnot B$SecondGender IMM_VALUE L4>
              ifnot D$imm32 1, L5>
                ifnot B$Operands IMM_TO_REG L6>
                  Mov op1 00_1101_0000,  op2 00_1110_0000 | jmp w_reg1_P2
L6:             ifnot B$Operands IMM_TO_MEM L6>
                  Mov op1 00_1101_0000,  op2 0010_0000 | jmp w_modRm_P2
L6:             BadOperand
L5:           ifnot B$Operands IMM_TO_REG L5>
                Mov op1 00_1100_0000,  op2 00_1110_0000 | jmp w_reg1_imm8
L5:           ifnot B$Operands IMM_TO_MEM L5>
                Mov op1 00_1100_0000,  op2 0010_0000 | jmp w_modRm_imm8
L5:           ;BadOperand
L4:         BadOperand
L3:       ifnot op3 'R', L3>>                                 ; SHR
            ifnot B$Operands REG_TO_REG L4>
              ifnot B$SecondReg REG_CL L5>
                Mov op1 00_1101_0010,  op2 00_1110_1000 | jmp w_reg1_P2cl
L4:         ifnot B$Operands REG_TO_MEM L4>
              ifnot B$SecondReg REG_CL L5>
                Mov op1 00_1101_0010,  op2 0010_1000 | jmp w_modRm_P2cl
L5:           BadOperand
L4:         ifnot B$SecondGender IMM_VALUE L4>
              ifnot B$imm32 1, L5>
                ifnot B$Operands IMM_TO_REG L6>
                  Mov op1 00_1101_0000,  op2 00_1110_1000 | jmp w_reg1_P2
L6:             ifnot B$Operands IMM_TO_MEM  L6>
                  Mov op1 00_1101_0000,  op2 0010_1000 | jmp w_modRm_P2
L6:             BadOperand
L5:           ifnot B$Operands IMM_TO_REG L5>
                Mov op1 00_1100_0000,  op2 00_1110_1000 | jmp w_reg1_imm8
L5:           ifnot B$Operands IMM_TO_MEM L5>
                Mov op1 00_1100_0000,  op2 0010_1000 | jmp w_modRm_imm8
L5:           ;BadOperand
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'T', L2>
          ifnot op3 'C', L3>              ; STC
            Mov op1 00_1111_1001 | jmp op
L3:       ifnot op3 'D', L3>              ; STD
            Mov op1 00_1111_1101 | jmp op
L3:       ifnot op3 'I', L3>              ; STI
            Mov op1 00_1111_1011 | jmp op
L3:       ifnot op3 'R', L3>              ; STR ("ax" or "W$edi")
              dec edi ; Because there is no need of 066 override here
              On B$FirstOperandwbit <> WORD_SIZE BadOperandSize
              Mov op1 0F, Op2 0
            ifnot B$FirstGender GENERAL_REG L4>
              Mov op3 00_1100_1000 | jmp op_op_reg1
L4:         ifnot B$FirstGender MEM_LABEL L4>
              Mov op3 00_1000 | jmp op_op_modRm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'U', L2>>
          ifnot op3 'B', L3>>                         ; SUB
            ifnot B$Operands REG_TO_REG L4>
              Mov op1 0010_1010,  op2 00_1100_0000 | jmp w_reg1reg2
L4:         ifnot B$Operands MEM_TO_REG L4>
              Mov op1 0010_1010 | jmp w_modReg1Rm
L4:         ifnot B$Operands REG_TO_MEM L4>
              Mov op1 0010_1000 | jmp w_modReg2Rm
L4:         ifnot B$Operands IMM_TO_REG L4>
              ifnot B$FirstReg REG_EAX L5>
                If B$FirstOperandwBit > BYTE_SIZE
                    cmp D$ABSimm32 080 | jb L5>
                End_If
                Mov op1 0010_1100 | jmp w_imm
L5:           Mov op1 00_1000_0000,  op2 00_1110_1000 | jmp sw_reg1_imm
L4:         ifnot B$Operands IMM_TO_MEM L4>
              Mov op1 00_1000_0000,  op2 0010_1000 | jmp sw_modRm_imm
L4:         BadOperand
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'U', L1>
        ifnot op2 'D', L2>
          ifnot op3 '2', L3>           ; UD2 ;;; may add UD0 / UD1 (???....)
            Mov op1 0F,  op2 0B | jmp op_op
               ;UD2  Undefined instruction 0000 FFFF : 0000 1011
               ; used for sofware tests: generates opcode exception
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'X', L1>>
        ifnot op2 'O', L2>>
          ifnot op3 'R', L3>>             ; XOR
            ifnot B$Operands REG_TO_REG L4>
              Mov op1 0011_0010,  op2 00_1100_0000 | jmp w_reg1reg2
L4:         ifnot B$Operands MEM_TO_REG L4>
              Mov op1 0011_0010 | jmp w_modReg1Rm
L4:         ifnot B$Operands REG_TO_MEM L4>
              Mov op1 0011_0000 | jmp w_modReg2Rm
L4:         ifnot B$Operands IMM_TO_REG L4>
              ifnot B$FirstReg REG_EAX L5>
                If B$FirstOperandwBit > BYTE_SIZE
                    cmp D$ABSimm32 080 | jb L5>
                End_If
                Mov op1 0011_0100 | jmp w_imm
L5:           Mov op1 00_1000_0000
                    Mov op2 00_1111_0000 | jmp sw_reg1_imm
L4:         ifnot B$Operands IMM_TO_MEM L4>
              Mov op1 00_1000_0000,  op2 0011_0000 | jmp sw_modRm_imm
L4:         BadOperand
L3:       ;BadMnemonic
L2:     ;BadMnemonic
L1:   BadMnemonic

 ______________________________________________________________________________________

FourLetters:    On op5 > Separators,  jmp FiveLetters

        ifnot op1 'A', L1>
          ifnot op2 'R', L2>
            ifnot op3 'P', L3>
              ifnot op4 'L', L4>          ; ARPL  ; BadOperandSize
                On B$FirstOperandwbit <> WORD_SIZE BadOperandSize
               ; dec edi ; Kill 066 or not ??? Should work the same in both cases...
                Mov op1 00_0110_0011
                ifnot B$Operands REG_TO_REG L5>
                  Mov op2 00_1100_0000 | jmp op_reg2reg1
L5:             ifnot B$Operands REG_TO_MEM L5>
                  jmp op_modReg2Rm
L5:             BadOperand
L4:           ;BadMnemonic
L3:         ;BadMnemonic
L2:       BadMnemonic

L1:     ifnot op1 'C', L1>>
          ifnot op2 'A', L2>
            ifnot op3 'L', L3>
              ifnot op4 'L', L4>           ; Call
                ifnot B$FirstGender DISPLACEMENT L5>
                  On B$LocalSize <> 0, error D$NoLocalCallPtr
                  Mov D$Relative RelativeFlag
                  Mov op1 00_1110_1000
                  jmp op_dis
L5:             ifnot B$FirstGender GENERAL_REG L5>
                  Mov op1 00_1111_1111,  op2 00_1101_0000 | jmp op_reg1
L5:             ifnot B$FirstGender MEM_LABEL L5>
                  Mov op1 00_1111_1111,  op2 0001_0000 | jmp op_modRm
                                         ; 015 > 10101
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic

     ;Call   Call Procedure (in other segment)
     ;direct                1001 1010 : unsigned full offset, selector
     ;indirect              1111 1111 : mod 011 r/m


L2:       ifnot op2 'L', L2>
            ifnot op3 'T', L3>
              ifnot op4 'S', L4>                    ; CLTS
                Mov op1 00_1111,  op2 00_0110 | jmp op_op
L4:           ;BadMnemonic
L3:         BadMnemonic

L2:       ifnot op2 'M', L2>
            ifnot op3 'P', L3>
              ifnot op4 'S', L4>                     ; CMPS
                ; CMPS  Compare String B[Operands]   1010 011w
                error D$NotYetMnemoPtr
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'W', L2>
            ifnot op3 'D', L3>
              ifnot op4 'E', L4>                     ; CWDE
                Mov op1 00_1001_1000 | jmp op
L4:           ;BadMnemonic
L3:         ;BadMnemonic
L2:       BadMnemonic

L1:     ifnot op1 'E', L1>
          ifnot op2 'M', L2>
            ifnot op3 'M', L3>
              ifnot op4 'S', L4>                    ; EMMS
                cmp B$ParametersNumber 0 | jne L5>
                  Mov op1 00_1111, op2 00_01110111 | jmp op_op
L5:             BadOperand
L4:           ;BadMnemonic
L3:         ;BadMnemonic
L2:       BadMnemonic

L1:     ifnot op1 'I', L1>>
          ifnot op2 'D', L2>
            ifnot op3 'I', L3>
              ifnot op4 'V', L4>               ; IDIV
                Mov op1 00_1111_0110
                ifnot B$FirstGender GENERAL_REG L5>
                  Mov op2 00_1111_1000 | jmp w_reg1
L5:             ifnot B$FirstGender MEM_LABEL L5>
                  Mov op2 0011_1000 | jmp w_modRm
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic

L2:       ifnot op2 'M', L2>>
            ifnot op3 'U', L3>>
              ifnot op4 'L', L4>>                  ; IMUL
                cmp B$ParametersNumber 2 | je L6>
                cmp B$ParametersNumber 3 | je L7>

                  ifnot B$FirstGender GENERAL_REG L5>
                    Mov op1 00_1111_0110,  op2 00_0111_01000 | jmp w_reg1
L5:               ifnot B$FirstGender MEM_LABEL L5>
                    Mov op1 00_1111_0110,  op2 0010_1000 | jmp w_modRm
L5:               BadOperand

L6:             cmp B$wBit BYTE_SIZE | je L5>
                ifnot B$Operands REG_TO_REG L6>
                    Mov op1 00_1111,  op2 00_1010_1111,  op3 00_1100_0000 | jmp op_op_reg1reg2
; 3 Parameters:
L7:             On B$ThirdGender <> IMM_VALUE jmp L5>
                cmp B$wBit BYTE_SIZE | je L5>
                IfNot B$Operands REG_TO_REG L6> ; imul eax ebx 0-1
L8:               Mov op1 00_0110_1001,  op2 00_1100_0000 | jmp s_reg1reg2_imm
L6:             ifnot B$Operands MEM_TO_REG L6>

                  cmp B$immInside &TRUE | je L7>
                  Mov op1 00_1111,  op2 00_1010_1111 | jmp op_op_modReg1Rm
                  ; 069 (ou 06B)
L7:               Mov op1 00_0110_1001 | jmp s_modReg1Rm_imm
L6:             ifnot B$Operands IMM_TO_REG L6>
                  Mov B$ParametersNumber 3
                  Mov dh, B$FirstReg, B$SecondReg dh | jmp L8<  ; add: "> imul eax 213"
L6:             ;BadOperand
L5:           BadOperand
L4:         ;BadMnemonic
L3:       BadMnemonic

L2:     ifnot op2 'N', L2>
          ifnot op3 'T', L3>
            ifnot op4 '3', L4>
                LastOpcode 0CC          ; INT3

L4:         ifnot op4 '4', L4> ; INT4
                LastOpcode 0CC ; INT3 substitution (user really wrote 'int3' _by hand_)

L4:         ifnot op4 'O', L4>            ; INTO
              Mov op1 00_1100_1110 | jmp op

L4:         BadMnemonic

L3:       ifnot op3 'S', L3>
            ifnot op4 'B', L4>                  ; INSB
              LastOpcode 00_0110_1100
L4:         ifnot op4 'W', L4>                  ; INSW
              ToOpcode 066
              LastOpcode 0011_01101
L4:         ifnot op4 'D', L4>                  ; INSD
              LastOpcode 00_0110_1101

L4:         BadMnemonic

L3:       ifnot op3 'V', L3>
            ifnot op4 'D', L4>            ; INVD
              Mov op1 00_1111,  op2 00_1000 | jmp op_op
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'R', L2>
          ifnot op3 'E', L3>
            ifnot op4 'T', L4>            ; IRET
              Mov op1 00_1100_1111 | jmp op
L4:         ;BadMnemonic
L3:       ;BadMnemonic
L2:     BadMnemonic

L1:     ifnot op1 'L', L1>>
          ifnot op2 'A', L2>
            ifnot op3 'H', L3>
              ifnot op4 'F', L4>                ; LAHF
                Mov op1 00_1001_1111 | jmp op
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'G', L2>
            ifnot op3 'D', L3>
              ifnot op4 'T', L4>                 ; LGDT
                ifnot B$FirstGender MEM_LABEL L5>
                  Mov op1 00_1111,  op2 1,  op3 0001_0000 | jmp op_op_modRm
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'I', L2>
            ifnot op3 'D', L3>
              ifnot op4 'T', L4>                       ; LIDT
                ifnot B$FirstGender MEM_LABEL L5>
                Mov op1 00_1111,  op2 1,  op3 0001_1000 | jmp op_op_modRm
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'L', L2>
            ifnot op3 'D', L3>
              ifnot op4 'T', L4>                      ; LLDT
                ifnot B$FirstGender MEM_LABEL L4>
                Mov op1 00_1111,  op2 0,  op3 0001_0000 | jmp op_op_modRm16
L4:             ifnot B$FirstGender GENERAL_REG L5>
                Mov op1 00_1111,  op2 0,  op3 001101_0000 | jmp op_op_reg16
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'D', L2>
            ifnot op3 'T', L3>
              ifnot op4 'R', L4>                      ; LDTR
                ifnot B$FirstGender GENERAL_REG L5>
                  Mov op1 00_1111,  op2 0,  op3 00_1101_0000 | jmp op_op_reg16
L5:              ifnot B$FirstGender MEM_LABEL L5>
                  Mov op1 00_1111,  op2 0,  op3 0001_0000 | jmp op_op_modRm16
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'M', L2>
            ifnot op3 'S', L3>
              ifnot op4 'W',  L4>
                ifnot B$FirstGender GENERAL_REG L5>               ; LMSW
                  Mov op1 00_1111,  op2 1,  op3 00_1111_0000 | jmp op_op_reg1
L5:             ifnot B$FirstGender MEM_LABEL L5>
                  Mov op1 00_1111,  op2 1,  op3 0011_0000 | jmp op_op_modRm
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'O', L4>
            ifnot op3 'D', L3>
              ifnot op4 'S', L4>
                ; LODS   Load String Operand  1010 110w    ??????????????????
                error D$NotYetMnemoPtr
L4:           BadMnemonic
L3:         ifnot op3 'O', L3>
              ifnot op4 'P', L4>                     ; LOOP
                ;On B$LocalSize <> JMP_UP_SHORT error D$NoPlainLabelForLoopPtr
                cmp B$LocalSize JMP_UP_SHORT | je L7> | cmp B$LocalSize JMP_DOWN_SHORT | je L7> ; jE! allowed down loop!
                error D$NoPlainLabelForLoopPtr
          L7:   Mov op1 00_1110_0010 | jmp op_dis8
L4:           ;BadMnemonic
L3:         ;BadMnemonic
L2:       BadMnemonic

L1:     ifnot op1 'N', L1>                           ; NOPE
          ifnot op2 'O', L4>
            ifnot op3 'P', L4>
              ifnot op4 'E', L4>                     ; Empty Macro trick.
                Mov B$SIBinside &FALSE, B$DisInside &FALSE, B$DummyDis &FALSE,
                    B$immInside &FALSE, B$PossibleFirstImmLabel &FALSE,
                    B$PossibleImmLabel &FALSE, B$mm3Dsuffix 0
                ret

L1:     ifnot op1 'O', L1>
          ifnot op2 'U', L2>
            ifnot op3 'T', L3>
              ifnot op4 'S', L4>                     ; OUTS
                error D$NotYetMnemoPtr
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'R', L2>
            ifnot op3 'P', L3>
              ifnot op4 'D', L4>                     ; ORPD
                 ToOpcode 001100110 | jmp L5>
L4:           ifnot op4 'S', L4>                     ; ORPS
L5:              Mov op1 001010110 | jmp XMMmemXMM
L4:           ;BadMnemonic
L3:         ;BadMnemonic
L2:       BadMnemonic
L1:     ifnot op1 'P', L1>>
          ifnot op2 'A', L2>
            ifnot op3 'D', L3>
              ifnot op4 'D', L4>                   ; PADD > PADDB
                Mov cl 'B' | Mov op1 00_11111100
                    jmp gg2
L4:           BadMnemonic
L3:        ifnot op3 'N', L3>
              ifnot op4 'D', L4>                   ; PAND
                Mov op1 00_11011011
                If B$FirstRegGender = REG_XMM
                    ToOpcode 066 | jmp XmmMemXmm
                Else_If B$FirstRegGender = REG_MMX
                    jmp mmTwo
                End_If
                BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic

L2:       ifnot op2 'S', L2>>
            ifnot op3 'L', L3>
              ifnot op4 'L', L4>                            ; PSLL
                Mov cl 'W' | Mov op1 00_11110000, op2 0011_110_000 | jmp gg3
L4:           BadMnemonic
L3:         ifnot op3 'R', L3>
              ifnot op4 'A', L4>                            ; PSRA
                Mov cl 'W' | Mov op1 00_11100000, op2 0011_100_000 | jmp gg3
L4:           ifnot op4 'L', L4>                            ; PSRL
                Mov cl, 'W' | Mov op1 00_11010000, op2 0011_010_000 | jmp gg3
L4:           BadMnemonic
L3:         ifnot op3 'U', L3>
              ifnot op4 'B', L4>                            ; PSUB
                Mov cl 'B' | Mov op1 00_11111000 | jmp gg2
L4:           BadMnemonic
L3:         BadMnemonic

L2:       ifnot op2 'O', L2>
            ifnot op3 'P', L3>
              ifnot op4 'A', L4>                       ; POPA
                Mov op1 00_0110_0001 | jmp op
L4:           ifnot op4 'F', L4>                       ; POPF
                Mov op1 00_1001_1101 | jmp op
L4:           ;BadMnemonic
L3:         BadMnemonic

L2:       ifnot op2 'U', L2>>
            ifnot op3 'S', L3>>
              ifnot op4 'H', L4>>                         ; Push
                ifnot B$FirstGender GENERAL_REG L5>
                  On B$wBit = BYTE_SIZE BadOperand
                  ifnot B$FirstRegGender SEGMENT_REG L6>       ; max. G.P.regs = 00111
                    cmp B$FirstReg 0010_0000 | jae L7>   ; REG_FS is 00100000; GS, 00101000
                      Mov op1 00_0110 | jmp sReg2                        ; CS / DS / ES / SS
L7:                 Mov op1 00_1111,  op2 00_1000_0000 | jmp op_sreg3    ; FS / GS
L6:              ;Mov op1 00_1111_1111,  op2 00_1111_0000 | jmp op_reg1  ; G.P.
                  Mov op1 0_0101_0000 | jmp reg1_in_op                    ; register alternate
L5:             ifnot B$FirstGender MEM_LABEL L5>
                  On B$wBit = BYTE_SIZE BadOperand
                    Mov op1 00_1111_1111,  op2 0011_0000 | jmp op_modRm
L5:             ifnot B$FirstGender IMM_VALUE L5>
                  Mov op1 00_0110_1000 | jmp s_imm
L5:             ifnot B$FirstGender DISPLACEMENT L5>
                   Mov op1 00_0110_1000 | jmp op_P1
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'X', L2>
            ifnot op3 'O', L3>
              ifnot op4 'R', L4>                       ; PXOR
                Mov op1 00_11101111 | jmp OQregMemToReg
L4:           BadMnemonic
L3:         BadMnemonic
L2:       BadMnemonic

L1: ifnot op1 'R', L1>
      ifnot op2 'E', L2>
        ifnot op3 'T', L2>
          ifnot op4 'F', L2>                    ; RETF
            ifnot B$ParametersNumber 0, L5>
L6:           Mov op1 00_1100_1011 | jmp op
L5:         ifnot B$FirstGender IMM_VALUE L4>
              If D$imm32 = 0
                  Mov B$DisInside &False
                  Mov B$ParametersNumber 0
                  Mov B$immInside &FALSE | jmp L6<
              End_If
              Mov op1 00_1100_1010 | jmp op_imm16
L4:         BadOperand
L2:      BadMnemonic

L1:     ifnot op1 'S', L1>>
          ifnot op2 'A', L2>
            ifnot op3 'H', L3>
              ifnot op4 'F', L4>               ; SAHF
                Mov op1 00_1001_1110 | jmp op
L4:           BadMnemonic
L3:         ifnot op3 'L', L3>
              ifnot op4 'C', L4>               ; SALC
                Mov op1 0D6 | jmp op
L4:           BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'C', L2>
            ifnot op3 'A', L3>
              ifnot op4 'S', L4>               ; SCAS
                error D$NotYetMnemoPtr
                ; SCAS  Scan String 1101 111w
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'G', L2>
            ifnot op3 'D', L3>
              ifnot op4 'T', L4>                ; SGDT
                ifnot B$FirstGender MEM_LABEL L5>
                  Mov op1 00_1111,  op2 1,  op3 0 | jmp op_op_modRm
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'H', L2>>
            Mov op1 00_1111
            cmp op3 'L' | je L7>
            cmp op3 'R' | je L6>
L9:           BadMnemonic
L7:           Mov op2 00_1010_0100 | jmp L5>
L6:           Mov op2 00_1010_1100
L5:           ifnot op4 'D', L9<                 ; SHLD / SHRD
                ifnot B$Operands REG_TO_REG L3>
                  Mov op3 00_1100_0000
                  ifnot B$ThirdGender IMM_VALUE L4>
                    jmp op_op_reg2reg1_imm8
L4:               ifnot B$ThirdGender GENERAL_REG L9<
                    ifnot B$ThirdReg REG_CL L9<
                      or op2 1 | jmp op_op_reg2reg1_cl
L3:             ifnot B$Operands REG_TO_MEM L9<
                  ifnot B$ThirdGender IMM_VALUE L4>
                    jmp op_op_ModReg2Rm_imm8
L4:               ifnot B$ThirdGender GENERAL_REG L9<
                    ifnot B$ThirdReg REG_CL L9<
                    or op2 1 | jmp op_op_modReg2Rm_cl

L2:      ifnot op2 'I', L2>
           ifnot op3 'D', L3>
             ifnot op4 'T', L4>                      ; SIDT
               ifnot B$FirstGender MEM_LABEL L5>
                 Mov op1 00_1111,  op2 1, op3 00_1_000 | jmp op_op_modRm
L5:            BadOperand
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'L', L2>
           ifnot op3 'D', L3>
             ifnot op4 'T', L4>                      ; SLDT
               Mov op1 00_1111,  op2 0
               ifnot B$FirstGender GENERAL_REG L5>
                 Mov op3 00_1100_0000 | jmp op_op_reg1
L5:            ifnot B$FirstGender MEM_LABEL L5>
                 Mov op3 0 | jmp op_op_modRm
L5:            ;BadOperand
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'M', L2>
           ifnot op3 'S', L3>
             ifnot op4 'W', L4>                 ; SMSW
               Mov op1 00_1111,  op2 1
               ifnot B$FirstGender GENERAL_REG L5>
                 Mov op3 00_1110_0000 | jmp op_op_reg1
L5:            ifnot B$FirstGender MEM_LABEL L5>
                 Mov op3 0010_0000 | jmp op_op_modRm
L5:            BadOperand
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'T', L2>
           ifnot op3 'O', L3>
             ifnot op4 'S', L4>
               error D$NotYetMnemoPtr
               ; STOS  Store String Data 1010 101w
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'T', L1>
         ifnot op2 'E', L2>
           ifnot op3 'S', L3>
             ifnot op4 'T', L4>                      ; TEST
               ifnot B$Operands REG_TO_REG L5>
                 Mov op1 00_1000_0100,  op2 00_1100_0000 | jmp w_reg2reg1
L5:            ifnot B$Operands MEM_TO_REG L5>
                 Mov op1 00_1000_0100 | jmp w_modReg1Rm
L5:            ifnot B$Operands REG_TO_MEM L5>
                 Mov op1 00_1000_0100 | jmp w_modReg2Rm
L5:            ifnot B$Operands IMM_TO_REG L5>
                 ifnot B$FirstReg REG_EAX L6>
                   Mov op1 00_1010_1000 | jmp w_imm
L6:                Mov op1 00_1111_0110,  op2 00_1100_0000 | jmp w_reg1_imm
L5:            ifnot B$Operands IMM_TO_MEM L5>
                   Mov op1 00_1111_0110,  op2 0 | jmp w_modRm_imm
L5:            BadOperand
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'V', L1>
         ifnot op2 'E', L2>
           ifnot op3 'R', L3>
             ifnot op4 'R', L4>                    ; VERR
               Mov op1 00_1111,  op2 0
               ifnot B$FirstGender GENERAL_REG L5>
                 Mov op3 00_1110_0000 | jmp op_op_reg16
L5:            ifnot B$FirstGender MEM_LABEL L5>
                 Mov op3 0010_0000 | jmp op_op_modRm16
L5:            BadOperand
L4:          ifnot op4 'W', L4>                     ; VERW
               Mov op1 00_1111,  al 0
               ifnot B$FirstGender GENERAL_REG L5>
                 Mov op3 00_1110_1000 | jmp op_op_reg16
L5:            ifnot B$FirstGender MEM_LABEL L5>
                 Mov op3 0010_1000 | jmp op_op_modRm16
L5:            BadOperand
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'W', L1>
         ifnot op2 'A', L2>
           ifnot op3 'I', L3>
             ifnot op4 'T', L4>                      ; WAIT
               Mov op1 00_1001_1011 | jmp op
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'X', L1>>
         ifnot op2 'A', L2>
           ifnot op3 'D', L3>
             ifnot op4 'D', L4>                        ; XADD
               Mov op1 00_1111,  op2 00_1100_0000
               ifnot B$Operands REG_TO_REG L5>
                 Mov op3 00_1100_0000 | jmp op_w_reg2reg1
L5:            ifnot B$Operands REG_TO_MEM L5>
                 jmp op_w_modReg2Rm
L5:            BadOperand
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'C', L2>>
           ifnot op3 'H', L3>>
             ifnot op4 'G', L4>>                   ; XCHG
               ifnot B$Operands REG_TO_REG L5>
                 ifnot B$FirstReg REG_EAX L6>
                   Mov op2 B$FirstReg,  op1 B$SecondReg
                   Mov B$FirstReg op1,  B$SecondReg op2  ; exchange the regs order
L6:              ifnot B$SecondReg REG_EAX L6>
                   cmp B$SecondOperandwBit BYTE_SIZE | jne L7>
                      Mov op1 086, op2 00_11_000_000 | jmp op_reg2reg1
L7:                Mov op1 00_1001_0000 | jmp XOPreg1
L6:                Mov op1 00_1000_0110,  op2 00_1100_0000 | jmp w_reg1reg2
L5:            ifnot B$Operands MEM_TO_REG L5>
                   Mov op1 00_1000_0110 | jmp w_modReg1Rm
L5:            ifnot B$Operands REG_TO_MEM L5>
                   Mov op1 00_1000_0110 | jmp w_modReg2Rm
L5:            BadOperand
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'L', L2>
           ifnot op3 'A', L3>
             ifnot op4 'T', L4>                   ; XLAT
               Mov op1 00_1101_0111 | jmp op
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      ;BadMnemonic
L1:    BadMnemonic

 _______________________________________________________________________________________


FiveLetters:     On op6 > Separators,  jmp SixLetters



; Align: One IMM_VALUE parameter. Here, i just fill with NOPs up to whished adress.
; I disagree with alignment use. Do what you want here, according your own
; whishes:

       Ifnot op1 'A', L1>>
         ifnot op2 'L', L2>>
           ifnot op3 'I', L3>>
             ifnot op4 'G', L3>>
               ifnot op5 'N', L3>>                    ; ALIGN
                 cmp B$ParametersNumber 1 | jne L6>
                 cmp B$FirstGender IMM_VALUE | jne L6>
                    cmp D$imm32 4 | jl L6>
                    cmp D$imm32 0100 | ja L6>
                    Mov ecx D$imm32 | bsr eax ecx | bsf ebx ecx
                    On eax <> ebx, error D$BadAlignPtr
                    dec ecx | test edi ecx ZERO L9>
                    Mov eax edi | and eax ecx | sub ecx eax | inc ecx
                    cmp ecx 5 | jb L7>
                    Mov al 0EB | stosb | Mov al cl | sub al 2 | stosb
                    sub ecx 2
L7:                 Mov al 090 | rep stosb
                    Call SetAlignFlag
L9:                 Mov D$imm32 0, B$immInside &FALSE
                 ret
L6:              BadOperand
L3:        BadMnemonic
L2:      ifnot op2 'D', L2>
           ifnot op3 'D', L3>
             ifnot op4 'P', L4>
               ifnot op5 'D', L5>                    ; ADDPD
                  ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>                    ; ADDPS
L6:               Mov op1 001011000 | jmp XMMmemXMM
L5:            BadMnemonic
L4:          ifnot op4 'S', L4>
               ifnot op5 'D', L5>                    ; ADDSD
                  ToOpcode 0011110010 | jmp L6>
L5:            ifnot op5 'S', L5>                    ; ADDSS
                  ToOpcode 0011110011                ; additional frefix for ADDSS
L6:               Mov op1 001011000 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'N', L2>
           ifnot op3 'D', L3>
             ifnot op4 'P', L4>
               ifnot op5 'D', L5>                    ; ANDPD
                  ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>                    ; ANDPS
L6:               Mov op1 001010100 | jmp XMMmemXMM
L5:            BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'B', L1>
         ifnot op2 'O', L2>
           ifnot op3 'U', L3>
             ifnot op4 'N', L4>
               ifnot op5 'D', L5>                     ; BOUND
                 ifnot B$Operands MEM_TO_REG L6>
                   Mov op1 00_0110_0010 | jmp op_modReg1Rm
L6:              BadOperand
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'S', L2>
           ifnot op3 'W', L3>
             ifnot op4 'A', L4>
               ifnot op5 'P', L5>                        ; BSWAP
                 ifnot B$FirstGender GENERAL_REG L6>
                   Mov op1 00_1111,  op2 00_1100_1000 | jmp op_reg1
L6:              BadOperand
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic

L1:     ifnot op1 'C', L1>>
          ifnot op2 'A', L1>>
            ifnot op3 'L', L3>>
              ifnot op4 'L', L3>>
               ifnot op5 'F', L3>>
L5:             ifnot B$FirstGender MEM_LABEL L4>
                ifnot B$ParametersNumber 2, L5>             ; CALLF jE! added
                ifnot B$SecondGender IMM_VALUE L4>
                cmp B$EregInside 0 | jne L4>
                ToOpcode  09A
                cmp B$FirstParaMem 'W' | je L2>
                cmp B$FirstParaMem 'D' | jne L4>
                cmp B$PossibleImmLabel 0 | je L8>; | int 3
                Mov D$CodeListPtr edi | pushad | Call SecondParameterLabel | popad
            L8:
                Mov eax D$imm32 | stosd | jmp L6>
            L2: Mov eax D$imm32 | stosw | test eax 0FFFF0000 NOT_ZERO L7>
            L6: Mov eax D$dis32 | stosw | test eax 0FFFF0000 NOT_ZERO L7>
                Call ClearParameters
                ret
L5:           Mov op1 00_1111_1111,  op2 0001_1000 | jmp op_modRm
L4:          BadOperand
L3:         BadMnemonic
L7:       error D$OverWordPtr

L1:    ifnot op1 'C', L1>>
         ifnot op2 'M', L2>>
           ifnot op3 'P', L3>
             ifnot op4 'P', L4>
               ifnot op5 'D', L5>                 ; CMPPD SSE2
                  ToOpcode 066 | Mov op1 0C2 | jmp XmmMemXmmImm7
L5:            ifnot op5 'S', L5>                 ; CMPPS SSE2
                 Mov op1 0011000010 | jmp XmmMemXmmImm7
L5:            BadMnemonic
L4:          ifnot op4 'S', L4>
               ifnot op5 'B', L5>                 ; CMPSB / W / D
                 Mov op1 00_1010_0110 | jmp op
L5:            ifnot op5 'W', L5>
                 ToOpcode 066
                 Mov op1 00_1010_0111 | jmp op
L5:            ifnot op5 'D', L5>
                 If B$FirstRegGender = REG_XMM     ; CMPSD SSE2
                    ; Alternate
                    ToOpcode 0011110010 | Mov op1 0011000010 | jmp XmmMemXmmImm7
                 End_If
                 Mov op1 00_1010_0111 | jmp op

L5:            ifnot op5 'S', L5>                  ; CMPSS SSE2
                 ToOpcode 0F3 | Mov op1 0011000010 | jmp XmmMemXmmImm7

L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'P', L2>
           ifnot op3 'U', L3>
             ifnot op4 'I', L4>
               ifnot op5 'D', L5>                    ; CPUID
                 Mov op1 00_1111,  op2 00_1010_0010 | jmp op_op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'D', L1>>
         ifnot op2 'I', L2>>
           ifnot op3 'V', L3>>
             ifnot op4 'P', L4>>
               ifnot op5 'D', L5>>                        ; DIVPD
                 ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>>                        ; DIVPS
L6:              Mov op1 001011110 | jmp XMMmemXMM
L5:            BadMnemonic
L4:          ifnot op4 'S', L4>>
               ifnot op5 'D', L5>>                        ;DIVSD
                   ToOpcode 0011110010 | jmp L6>
L5:            ifnot op5 'S', L5>>                        ;DIVSS
                   ToOpcode 0011110011
L6:                Mov op1 001011110 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'E', L1>>
         ifnot op2 'N', L2>>
           ifnot op3 'T', L3>>
             ifnot op4 'E', L4>>
               ifnot op5 'R', L5>>                        ; ENTER

                ToOpcode 0C8

                Mov esi D$LineStart
L6:             lodsb
                    If al be EOI
                        Mov eax NotEnough | jmp EnterError
                    End_If
                    ifnot al Space,  L6<

                    Call TranslateAny

                    If eax > 0FFFC
                        Mov eax EnterStack | jmp EnterError
                    End_If
                    test eax 0011 ZERO S0>
                        Mov eax EnterStack | jmp EnterError

S0:                 ToOpcode al, ah        ; 16-bit >>> displacement

                    .If B$esi-1 = Space
                        Call TranslateAny   ; test both numbers at once
                        If eax > 31
                            Mov eax EnterLevel | jmp EnterError    ; 8-bit level (L)
                        End_If
                        ToOpcode al
                    .Else
                        ToOpcode  0
                    .End_If

                    Mov esi D$LineStart
                    While B$esi > EOI
                        Mov B$esi 0 | inc esi
                    End_While

                    ret

EnterError: Mov esi D$LineStart
            While B$esi > EOI
                Mov B$esi 0 | inc esi
            End_While
            jmp OutOnError

L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'I', L1>
         ifnot op2 'R', L2>
           ifnot op3 'E', L3>
             ifnot op4 'T', L4>
               ifnot op5 'D', L5>               ; IRETD
                 Mov op1 00_1100_1111 | jmp op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'L', L1>>
         ifnot op2 'D', L2>
           ifnot op3 'D', L3>
             ifnot op4 'Q', L4>
               ifnot op5 'U', L5>       ; LDDQU
                IfNot B$Operands MEM_TO_REG L6>
                ToOpcode 0F2 | Mov Op1 0F0 | jmp MMXmemXMM
L6: BadOperand
L2:      ifnot op2 'E', L2>
           ifnot op3 'A', L3>
             ifnot op4 'V', L4>
               ifnot op5 'E', L5>
                 Mov op1 00_1100_1001 | jmp op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'O', L2>
           ifnot op3 'D', L3>
             ifnot op4 'S', L4>
               ifnot op5 'B', L5>              ; LODSB  /  W /  D
                 Mov op1 00_0101_01100 | jmp op
L5:            ifnot op5 'W', L5>
                 ToOpcode 066
                 Mov op1 00_1010_1101 | jmp op
L5:            ifnot op5 'D', L5>
                 Mov op1 00_1010_1101 | jmp op
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'O', L3>
             ifnot op4 'P', L4>
               ifnot op5 'Z', L6>                 ; LOOPZ  /  E
L5:              On B$LocalSize <> JMP_UP_SHORT error D$NoPlainLabelForLoopPtr
                 Mov op1 00_1110_0001 | jmp op_dis8
L6:            cmp op5, 'E' | je L5<
               BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'M', L1>>
         ifnot op2 'A', L2>
           ifnot op3 'X', L3>
             ifnot op4 'S', L4>
               ifnot op5 'S', L5>                 ; MAXSS
                 ToOpcode 0F3 | jmp L6>
L5:            ifnot op5 'D', L5>                 ; MAXSD
                 ToOpcode 0F2
L6:              Mov op1 05F | jmp XMMmemXMM
L5:            BadMnemonic
L4:          ifnot op4 'P', L4>
               ifnot op5 'D', L5>                 ; MAXPD
                   ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>                 ; MAXPS
L6:                Mov op1 001011111 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      ifnot op2 'I', L2>
           ifnot op3 'N', L3>
             ifnot op4 'S', L4>
               ifnot op5 'D', L5>                  ; MINSD
                   ToOpcode 0011110010 | jmp L6>
L5:            ifnot op5 'S', L5>                  ; MINSS
                 ToOpcode 0011110011 | jmp L6>
L5:            BadMnemonic
L4:          ifnot op4 'P', L4>
               ifnot op5 'D', L5>                 ; MINPD
                   ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>                 ; MINPS
L6:                Mov op1 001011101 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'U', L2>
           ifnot op3 'L', L3>
             ifnot op4 'S', L4>
               ifnot op5 'D', L5>                 ; MULSD
                 ToOpcode 0011110010 | jmp L6>
L5:            ifnot op5 'S', L5>                 ; MULSS
                 ToOpcode 0011110011 | jmp L6>
L5:            BadMnemonic
L4:          ifnot op4 'P', L4>
               ifnot op5 'D', L5>                 ; MULPD
                   ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>                 ; MULPS
L6:                Mov op1 001011001 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'W', L2>
           ifnot op3 'A', L3>
             ifnot op4 'I', L4>
               ifnot op5 'T', L5>                 ; MWAIT
                 ToOpcode 0F, 01, 0C9 | ret
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'O', L1>>
         ifnot op2 'U', L2>
           ifnot op3 'T', L3>
             ifnot op4 'S', L4>
               ifnot op5 'B', L5>                ; OUTSB  /  W  /  D
                 Mov op1 00_0110_1110 | jmp op
L5:            ifnot op5 'W', L5>
                 ToOpcode 066
                 Mov op1 00_0110_1111 | jmp op
L5:            ifnot op5 'D', L5>
                 Mov op1 00_0110_1111 | jmp op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'P', L1>>
         ifnot op2 'A', L2>>
           ifnot op3 'D', L3>>
             ifnot op4 'D', L4>>
               cmp op5 'B' | je L6>
               cmp op5 'W' | je L6>
               cmp op5 'D' | jne L5>                         ; PADDB/W/D
L6:              Mov cl op5 | Mov op1 00_11111100
                     jmp gg2
L5:            ifnot op5 'Q', L5>                            ; PADDQ
                     Mov op1 0011010100 | jmp OQRegMemToReg
L5:            ifnot op5 'S', L5>                            ; PADDS
                 Mov cl 'B' | Mov op1 00_11101100
                    jmp gg2
L5:          ;  BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'N', L3>
             ifnot op4 'D', L4>                      ; PANDB
               ifnot op5 'Q', L5>
                 Mov op1 00_11011011 | jmp mmTwo
L5:            ifnot op5 'N', L5>                    ; PANDN
                 Mov op1 00_11011111 | jmp OQRegMemToReg
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'U', L3>
             ifnot op4 'S', L4>                      ; PAUSE
               ifnot op5 'E', L5>
                   ToOpcode 0011110011 | LastOpcode 0010010000
L3:        ifnot op3 'V', L3>
             ifnot op4 'G', L4>
               ifnot op5  'B', L5>                   ; PAVGB
                 Mov op1 0E0 | jmp OQregMemToReg
L5:            ifnot op5 'W', L5>>                   ; PAVGW
                 Mov op1 0E3 | jmp OQregMemToReg
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'F', L2>>
           Ifnot op3 '2', L3>
             ifnot op4 'I', L4>
               ifnot op5 'D', L5>               ; PF2ID
                   Mov op1 01D | jmp mm3D
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        Ifnot op3 'A', L3>
             ifnot op4 'C', L4>
               ifnot op5 'C', L5>               ; PFACC
                   Mov op1 0AE | jmp mm3D
L5:            BadMnemonic
L4:          ifnot op4 'D', L4>
               ifnot op5 'D', L5>               ; PFADD
                   Mov op1 09E | jmp mm3D
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        Ifnot op3 'M', L3>
             ifnot op4 'A', L4>
               ifnot op5 'X', L5>               ; PFMAX
                   Mov op1 0A4 | jmp mm3D
L5:            BadMnemonic
L4:          ifnot op4 'I', L4>
               ifnot op5 'N', L5>               ; PFMIN
                   Mov op1 094 | jmp mm3D
L5:            BadMnemonic
L4:          ifnot op4 'U', L4>
               ifnot op5 'L', L5>               ; PFMUL
                   Mov op1 0B4 | jmp mm3D
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        Ifnot op3 'R', L3>
             ifnot op4 'C', L4>
               ifnot op5 'P', L5>               ; PFRCP
                   Mov op1 096 | jmp mm3D
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        Ifnot op3 'S', L3>
             ifnot op4 'U', L4>
               ifnot op5 'B', L5>               ; PFSUB
                   Mov op1 09A | jmp mm3D
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'I', L2>
           Ifnot op3 '2', L3>
             ifnot op4 'F', L4>
               ifnot op5 'D', L5>               ; PI2FD
                   Mov op1 0D | jmp mm3D
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'M', L2>
           Ifnot op3 'A', L3>
             ifnot op4 'D', L4>
               ifnot op5 'D', L5>               ; PMADD
                 Mov op1 00_11110101 | jmp OQRegMemToReg
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'U', L3>
             ifnot op4 'L', L4>
               ifnot op5 'H', L5>                  ; PMULH
                 Mov op1 00_11100101 | jmp OQRegMemToReg
L5:            ifnot op5 'L', L5>                  ; PMULL
                 Mov op1 00_11010101 | jmp OQRegMemToReg
L5:            ifnot op5 'W', L5>                  ; PMULW
                 Mov op1 0D5 | jmp OQRegMemToReg
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'O', L2>>
           ifnot op3 'P', L3>
             ifnot op4 'A', L4>
               ifnot op5 'D', L5>                 ; POPAD
                 Mov op1 00_0110_0001 | jmp op
L5:             ifnot op5 'W', L5>                 ; POPAW
                 ToOpcode 066 | Mov op1 00_0110_0001 | jmp op
L5:            BadMnemonic
L4:          ifnot op4 'F', L4>
               ifnot op5 'D',L5>                 ; POPFD
                 Mov op1 00_1001_1101 | jmp op
L5:            ifnot op5 'W',L5>                 ; POPFW
                 ToOpcode 066 | Mov op1 00_1001_1101 | jmp op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:       ifnot op2 'S', L2>>
            ifnot op3 'L', L3>
              ifnot op4 'L', L4>                  ; PSLLW/D/Q
                cmp op5 'W' | je L6>
                cmp op5 'D' | je L6>
                cmp op5 'Q' | jne L5>
L6:               Mov cl op5 |  Mov op1 00_11110000, op2 0011_110_000 | jmp gg3
L5:             ;BadMnemonic
L4:           BadMnemonic
L3:         ifnot op3 'R', L3>
              ifnot op4 'A', L4>
                cmp op5 'W' | je L6>
                cmp op5 'D' | jne L5>                             ; PSRAW/D
L6:               Mov cl op5 |  Mov op1 00_11100000, op2 0011_100_000 | jmp gg3
L5:             BadMnemonic
L4:           ifnot op4 'L', L4>
                cmp op5 'W' | je L6>
                cmp op5 'D' | je L6>
                cmp op5 'Q' | jne L5>                          ; PSRLW/D/Q
L6:               Mov cl op5 | Mov op1 00_11010000, op2 0011_010_000 | jmp gg3
L5:             BadMnemonic
L4:           BadMnemonic
L3:         ifnot op3 'U', L3>
              ifnot op4 'B', L4>
                cmp op5 'B' | je L6>
                cmp op5 'W' | je L6>
                cmp op5 'D' | jne L5>                           ; PSUBB/W/D
L6:               Mov cl op5 | Mov op1 00_11111000 | jmp gg2
L5:             cmp op5 'Q' | jne L5>                           ; PSUBQ
                  Mov op1 0011111011 | jmp OQregMemToReg
L5:            ifnot op5 'S', L5>                               ; PSUBS
                 Mov cl 'B' | Mov op1 00_11101000 | jmp gg2
L5:             ;BadMnemonic
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:      ifnot op2 'U', L2>
           ifnot op3 'S', L3>
             ifnot op4 'H', L4>
               ifnot op5 'A', L5>                 ; PUSHA
                 Mov op1 00_0110_0000 | jmp op
L5:            ifnot op5 'F', L5>                 ; PUSHF
                 Mov op1 00_0100_11100 | jmp op
L5:            ifnot op5 'W', L5>                 ; PUSHW
                  ifnot B$FirstGender IMM_VALUE L6>
                    Mov op1 00_0110_1000 | jmp s_imm16
L6:               BadOperand
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'R', L1>>
         ifnot op2 'C', L2>
           ifnot op3 'P', L3>
             ifnot op4 'S', L4>
               ToOpcode 0011110011 | jmp L5>           ; RCPSS
L4:          ifnot op4 'P', L4>
L5:            ifnot op5 'S', L5>                      ; RCPPS
                 Mov op1 001010011 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'D', L2>
           ifnot op3 'M', L3>
             ifnot op4 'S', L4>
               ifnot op5 'R', L5>                      ; RDMSR
                 Mov op1 00_1111,  op2 0011_0010 | jmp op_op
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'P', L3>
             ifnot op4 'M', L4>
               ifnot op5 'C', L5>                      ; RDPMC
                 Mov op1 00_1111,  op2 0011_0011 | jmp op_op
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'T', L3>
             ifnot op4 'S', L4>
               ifnot op5 'C', L5>                      ; RDTSC
                 Mov op1 00_1111,  op2 0011_0001 | jmp op_op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemnonic
L2:      BadMnemonic
L1:    ifnot op1 'S', L1>>
         ifnot op2 'C', L2>
           ifnot op3 'A', L3>
             ifnot op4 'S', L4>
               ifnot op5 'B', L5>                 ; SCASB / W / D
                 Mov op1 00_1010_1110    ; 011011110B mistake in intel doc
                    jmp op
L5:            ifnot op5 'W', L5>
                 ToOpcode 066
                 Mov op1 00_1010_1111     ; 011011111B
                   jmp op
L5:            ifnot op5 'D', L5>
                 Mov op1 00_1010_1111     ; 011011111B
                     jmp op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'T', L2>
           ifnot op3 'O', L3>
             ifnot op4 'S', L4>
               ifnot op5 'B', L5>                     ; STOSB / W / D
                 Mov op1 00_1010_1010 | jmp op
L5:            ifnot op5 'W', L5>
                 ToOpcode 066
                 Mov op1 00_1010_1011 | jmp op
L5:            ifnot op5 'D', L5>
                 Mov op1 00_1010_1011 | jmp op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'U', L2>
           ifnot op3 'B', L3>
             ifnot op4 'S', L4>
               ifnot op5 'D', L5>                     ; SUBSD
                   ToOpcode 0011110010 | jmp L6>
L5:            ifnot op5 'S', L5>                     ; SUBSS
                   ToOpcode 0011110011 | jmp L6>
L5:            BadMnemonic
L4:          ifnot op4 'P', L4>
               ifnot op5 'D', L5>                     ; SUBPD
                   ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>                     ; SUBPS
L6:                Mov op1 001011100 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'W', L1>
         ifnot op2 'R', L2>
           ifnot op3 'M', L3>
             ifnot op4 'S', L4>
               ifnot op5 'R', L5>                             ; WRMSR
                 Mov op1 00_1111,  op2 0011_0000 | jmp op_op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'X', L1>
         ifnot op2 'L', L2>
           ifnot op3 'A', L3>
             ifnot op4 'T', L4>
               ifnot op5 'B', L5>                            ; XLATB
                 Mov op1 00_1101_0111 | jmp op              ; XLATB 11   >>>  XLAT  ???
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'O', L2>
           ifnot op3 'R', L3>
             ifnot op4 'P', L4>
               ifnot op5 'D', L5>                            ; XORPD
                   ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>                            ; XORPS
L6:                Mov op1 001010111 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      ;BadMnemonic
L1:    BadMnemonic

 _______________________________________________________________________________________

SixLetters:     On op7 > Separators,  jmp SevenLetters

       ifnot op1 'A', L1>
         ifnot op2 'N', L2>
           ifnot op3 'D', L3>
             ifnot op4 'N', L4>
               ifnot op5 'P', L5>
                 ifnot op6 'D', L6>                      ; ANDNPD
                   ToOpcode 001100110 | jmp L7>
L6:              ifnot op6 'S', L6>                      ; ANDNPS
L7:                Mov op1 001010101 | jmp XMMmemXMM
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic

L1:    ifnot op1 'C', L1>
         ifnot op2 'O', L2>
           ifnot op3 'M', L3>
             ifnot op4 'I', L4>
               ifnot op5 'S', L5>
                 ifnot op6 'S', L6>                      ; COMISS
                   Mov op1 00101111 | jmp XMMmemXMM
L6:              ifnot op6 'D', L6>                      ; COMISD
                   ToOpcode 001100110 | Mov op1 02F | jmp XMMmemXMM  ; 66 0F 2F xx
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'H', L1>
         ifnot op2 'A', L2>
           ifnot op3 'D', L3>
             ifnot op4 'D', L4>
               ifnot op5 'P', L5>
                 ifnot op6 'D', L6>         ; HADDPD 66,0F,7C,/r HADDPD xmm1, xmm2/m128
                   ToOpcode 066 | Mov Op1 07C | jmp XmmMemXmm
L6:              ifnot op6 'S', L6>         ; HADDPS F2,0F,7C,/r HADDPS xmm1, xmm2/m128
                   ToOpcode 0F2 | Mov Op1 07C | jmp XmmMemXmm
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'S', L2>
           ifnot op3 'U', L3>
             ifnot op4 'B', L4>
               ifnot op5 'P', L5>
                 ifnot op6 'D', L6>         ; HSUBPD 66,0F,7D,/r HSUBPD xmm1, xmm2/m128
                   ToOpcode 066 | Mov Op1 07D | jmp XmmMemXmm
L6:              ifnot op6 'S', L6>         ; HSUBPS F2,0F,7D,/r HSUBPS xmm1, xmm2/m128
                   ToOpcode 0F2 | Mov Op1 07D | jmp XmmMemXmm
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'I', L1>
         ifnot op2 'N', L2>
           ifnot op3 'V', L3>
             ifnot op4 'L', L4>
               ifnot op5 'P', L5>
                 ifnot op6 'G', L6>     ; INVLPG
                   ifnot B$FirstGender MEM_LABEL L7>
                     Mov op1 00_1111,  op2 1,  op3 00_111_000 | jmp op_op_modRm
L7:                BadOperand
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'L', L1>
         ifnot op2 'F', L2>
           ifnot op3 'E', L3>
             ifnot op4 'N', L4>
               ifnot op5 'C', L5>
                 ifnot op6 'E', L6>                 ; LFENCE
                     ToOpcode 00001111, 0010101110 | LastOpcode 0011101000
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'O', L2>
           ifnot op3 'O', L3>
             ifnot op4 'P', L4>
               ifnot op5 'N', L5>
                 ifnot op6 'Z', L6>                 ; LOOPNZ /  E
L7:                On B$LocalSize <> JMP_UP_SHORT error D$NoPlainLabelForLoopPtr
                   Mov op1 00_1110_0000 | jmp op_dis8
L6:              cmp op6 'E' | je L7<
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'M', L1>
         ifnot op2 'F', L2>
           ifnot op3 'E', L3>
             ifnot op4 'N', L4>
               ifnot op5 'C', L5>
                 Ifnot op6 'E', L6>                         ; MFENCE
                     ToOpcode 00001111, 0010101110 | LastOpcode 0011110000
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'P', L1>>
         ifnot op2 'A', L2>>
           ifnot op3 'D', L3>>
             ifnot op4 'D', L4>>
               ifnot op5 'S', L5>
                 cmp op6 'B' | je L7>
                 cmp op6 'W' | jne L6>                         ; PADDSB/W
L7:                Mov cl op6 | Mov op1 00_11101100  ; = 0EC
                      jmp gg2
L6:              BadMnemonic
L5:            ifnot op5 'U', L5>
                 ifnot op6 'S', L6>                            ; PADDUS
                   Mov cl, 'B' | Mov op1 00_11011100
                       jmp gg2
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          BadMnemonic
L2:        ifnot op2 'C', L2>
             ifnot op3 'M', L3>
               ifnot op4 'P', L4>
                 ifnot op5 'E', L5>
                   ifnot op6 'Q', L6>                          ; PCMPEQ
                     Mov cl 'B' | Mov op1 00_01110100
                         jmp gg2
L6:                BadMnemonic
L5:              ifnot op5 'G', L5>
                   ifnot op6 'T', L6>                          ; PCMPGT
                     Mov cl 'B' | Mov op1 00_01100100
                         jmp gg2
L6:                ;BadMnemonic
L5:              ;BadMnemonic
L4:            ;BadMnemonic
L3:          BadMnemonic
L2:      ifnot op2 'E', L2>
           ifnot op3 'X', L3>
             ifnot op4 'T', L4>
               ifnot op5 'R', L5>
                 ifnot op6 'W', L6>                             ; PEXTRW
                     Mov op1 0011000101 | jmp OQregRegImm8
L6:                ;BadMnemonic
L5:              ;BadMnemonic
L4:            ;BadMnemonic
L3:          BadMnemonic
L2:      ifnot op2 'I', L2>
           ifnot op3 'N', L3>
             ifnot op4 'S', L4>
               ifnot op5 'R', L5>
                 ifnot op6 'W', L6>                              ; PINSRW
                     Mov op1 0011000100 | jmp OQregmemImm8
L6:                ;BadMnemonic
L5:              ;BadMnemonic
L4:            ;BadMnemonic
L3:          BadMnemonic
L2:      ifnot op2 'F', L2>
           ifnot op3 'S', L3>
             ifnot op4 'U', L4>
               ifnot op5 'B', L5>
                 ifnot op6 'R', L6>            ; PFSUBR
                     Mov op1 0AA | jmp mm3D
L6:                ;BadMnemonic
L5:              ;BadMnemonic
L4:            ;BadMnemonic
L3:          BadMnemonic
L2:      ifnot op2 'M', L2>>
           ifnot op3 'A', L3>
             ifnot op4 'X', L4>
               ifnot op5 'S', L5>
                 ifnot op6 'W', L6>                         ; PMAXSW
                    Mov op1 0011101110 | jmp OQregMemToReg
L6:                BadMnemonic
L5:            ifnot op5 'U', L5>
                 ifnot op6 'B', L6>                         ; PMAXUB
                    Mov op1 0011011110 | jmp OQregMemToReg
L5:             ;BadMnemonic
L4:            ;BadMnemonic
L3:        ifnot op3 'I', L3>
             ifnot op4 'N', L4>
               ifnot op5 'S', L5>
                 ifnot op6 'W', L6>                         ; PMINSW
                    Mov op1 0011101010 | jmp OQregMemToReg
L6:                BadMnemonic
L5:            ifnot op5 'U', L5>
                 ifnot op6 'B', L6>                         ; PMINUB
                    Mov op1 0011011010 | jmp OQregMemToReg
L5:              ;BadMnemonic
L4:            ;BadMnemonic
L3:        ifnot op3 'U', L3>
             ifnot op4 'L', L4>
               ifnot op5 'H', L5>
                 ifnot op6 'W', L6>                         ; PMULHW
                    Mov op1 0E5 | jmp OQregMemToReg
L6:                ;BadMnemonic

L5:            ifnot op5 'L', L5>
                 ifnot op6 'W', L6>                     ; PMULLW
                   Mov op1 0D5 | jmp OQRegMemToReg

L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'S', L2>>
           ifnot op3 'A', L3>
             ifnot op4 'D', L4>
               ifnot op5 'B', L5>
                 ifnot op6 'W', L6>                         ; PSADBW
                     Mov op1 0011110110 | jmp OQregMemToReg
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'H', L3>
             ifnot op4 'U', L4>
               ifnot op5 'F', L5>
                 ifnot op6 'D', L6>                         ; PSHUFD
                    ToOpcode 001100110 | Mov op1 001110000 | jmp XmmMemXmmImm8
L6:              ifnot op6 'W', L6>                         ; PSHUFW
                     Mov op1 001110000 | jmp mmTwoImm8
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'L', L3>
             ifnot op4 'L', L4>>
               ifnot op5 'D', L5>>
                 ifnot op6 'Q', L6>>                         ; PSLLDQ
                     If B$ImmInside = &FALSE
                        error D$MissingOperandPtr
                     Else_If B$FirstRegGender <> REG_XMM
                        BadOperand
                     End_If
                     Imm8Size
                     ToOpcode 001100110, 00001111, 001110011
                     Mov op1 0011111000 | or op1 B$FirstReg | LastOpcode op1
L3:        ifnot op3 'R', L3>
             ifnot op4 'L', L4>
               ifnot op5 'D', L5>
                 ifnot op6 'Q', L6>                         ; PSRLDQ
                     ToOpcode 001100110, 00001111, 001110011
                     On B$Operands <> IMM_TO_REG jmp L7>
                     On B$FirstRegGender <> REG_XMM jmp L7>
                     Imm8Size
                         Mov op1 0011_011_000 | or op1 B$FirstReg | LastOpcode op1
L7:                  BadOperand
L3:        ifnot op3 'U', L3>
             ifnot op4 'B', L4>
               ifnot op5 'S', L5>
                 cmp op6 'B' | je L7>
                 cmp op6 'W' | jne L6>                         ; PSUBSB/W
L7:                Mov cl op6 | Mov op1 00_11101000 | jmp gg2
L6:              ;BadMnemonic
L5:            ifnot op5 'U', L5>
                 ifnot op6 'S', L6>                            ; PSUBUS
                   Mov cl 'B' | Mov op1 00_11011000 | jmp gg2
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'U', L2>
           ifnot op3 'S', L3>
             ifnot op4 'H', L4>
               ifnot op5 'A', L5>
                 ifnot op6 'D', L6>                             ; PUSHAD
                   Mov op1 00_0110_0000 | jmp op
L6:             ifnot op6 'W', L6>                             ; PUSHAW
                   ToOpcode 066 | Mov op1 00_0110_0000 | jmp op
L6:              BadMnemonic
L5:            ifnot op5 'F', L5>                               ; PUSHFD
                 ifnot op6 'D', L6>
                   Mov op1 00_1001_1100 | jmp op
L6:              ifnot op6 'W', L6>                             ; PUSHFW
                   ToOpcode 066 | Mov op1 00_1001_1100 | jmp op
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'S', L1>>
         ifnot op2 'F', L2>
           ifnot op3 'E', L3>
             ifnot op4 'N', L4>
               ifnot op5 'C', L5>
                 ifnot op6 'E', L6>                           ; SFENCE
                    ToOpcode 00001111, 0010101110, 0011111000 | ret
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'H', L2>
           ifnot op3 'U', L3>
             ifnot op4 'F', L4>
               ifnot op5 'P', L5>
                 ifnot op6 'D', L6>                           ; SHUFPD
                 ;   01100110:00001111:11000110:11 xmmreg1 xmmreg2:imm8 (0/255)
                    ToOpcode 001100110 | Mov op1 0011000110 | jmp XMMmemXMMimm3
L6:              ifnot op6 'S', L6>                           ; SHUFPS
                   Mov op1 0011000110 | jmp XMMmemXMMimmFF
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'Q', L2>
           ifnot op3 'R', L3>
             ifnot op4 'T', L4>
               ifnot op5 'S', L5>
                 ifnot op6 'D', L6>                       ; SQRTSD
                     ToOpcode 0011110010 | jmp L7>
L6:              IfNot op6 'S', L6>                       ; SQRTSS
                     ToOpcode 0F3 | jmp L7>
L6:              BadMnemonic
L5:            ifnot op5 'P', L5>
                 ifnot op6 'D', L6>                       ; SQRTPD
                     ToOpcode 001100110 | jmp L7>
L6:              ifnot op6 'S', L6>                       ; SQRTPS
L7:                  Mov op1 001010001 | jmp XMMmemXMM
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'W', L1>
         ifnot op2 'B', L2>
           ifnot op3 'I', L3>
             ifnot op4 'N', L4>
               ifnot op5 'V', L5>
                 ifnot op6 'D', L6>                           ; WBINVD
                   Mov op1 00_1111,  op2 00_1001 | jmp op_op
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      ;BadMnemonic
L1:    BadMnemonic
 ________________________________________________________________________________________

SevenLetters:        On op8 > Separators,  jmp heightLetters
       ifnot op1 'C', L1>>
         ifnot op2 'L', L2>
           ifnot op3 'F', L3>
             ifnot op4 'L', L4>
               ifnot op5 'U', L5>
                 ifnot op6 'S', L6>
                   ifnot op7 'H', L7>                      ; CLFLUSH
                       Parms 1
                       On B$FirstGender <> MEM_LABEL BadOperand
                       On B$FirstOperandwbit <> BYTE_SIZE BadOperandSize
                       ToOpcode 00001111 | Mov op1 0010101110, op2 00_111_000 | jmp op_modRm

; CLFLUSH: intel doc says one time "00001111:10101110:mod r/m"
; and another time: 0F AE /7 mem8

L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic

L2:      ifnot op2 'M', L2>
           ifnot op3 'P', L3>
             ifnot op4 'X', L4>
               ifnot op5 'C', L5>
                 ifnot op6 'H', L6>
                   ifnot op7 'G', L7>                      ; CMPXCHG
                     Mov op1 00_1111,  op2 00_1011_0000
                 ;    cmp B$SecondReg REG_EAX | jne L0         ; ???????????????
                 ;    cmp B$SecondOperandWbit DWORD_SIZE
                  ;          jne CMPXCHG8  ; ???????????????????
                       ifnot B$Operands REG_TO_REG L0>
                         Mov op3 00_1100_0000 | jmp op_w_reg2reg1
L0:                    ifnot B$Operands REG_TO_MEM L9>
                         jmp op_w_modReg2Rm
L9:                    ifnot B$Operands MEM_TO_REG L8>    ; ???????
                         jmp op_w_modReg1Rm
L8:                  BadOperand
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'L', L1>
         ifnot op2 'D', L2>
           ifnot op3 'M', L3>
             ifnot op4 'X', L4>
               ifnot op5 'C', L5>
                 ifnot op6 'S', L6>
                   ifnot op7 'R', L7>                               ; LDMXCSR
                     ifnot B$FirstGender MEM_LABEL L8>
                       ifnot B$FirstOperandwbit DWORD_SIZE L9>
                         ToOpcode 0F | Mov op1 0AE, op2 00_010_000 | jmp op_ModRm
L9:                    error D$OperandSizePtr
L8:                  BadOperand
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:       BadMnemonic
L1:    ifnot op1 'M', L1>
         ifnot op2 'O', L2>
           ifnot op3 'N', L3>
             ifnot op4 'I', L4>
               ifnot op5 'T', L5>
                 ifnot op6 'O', L6>
                   ifnot op7 'R', L7>                   ; MONITOR
                     ToOpcode 0F, 01, 0C8 | ret
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:       BadMnemonic
L1:    ifnot op1 'P', L1>>
         ifnot op2 'A', L2>
           ifnot op3 'D', L3>
             ifnot op4 'D', L4>
               ifnot op5 'U', L5>
                 ifnot op6 'S', L6>
                   cmp op7 'B' | je L8>
                   cmp op7 'W' | jne L7>                ; PADDUSB/W
L8:                  Mov cl op7 | Mov op1 00_11011100
                        jmp gg2
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'V', L3>
             ifnot op4 'G', L4>
               ifnot op5 'U', L5>
                 ifnot op6 'S', L6>
                   ifnot op7 'B', L7>                   ; PAVGUSB
                       Mov op1 0BF | jmp mm3D
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:        ifnot op2 'C', L2>>
             ifnot op3 'M', L3>>
               ifnot op4 'P', L4>>
                 ifnot op5 'E', L5>
                   ifnot op6 'Q', L6>
                     cmp op7 'B' | je L8>
                     cmp op7 'W' | je L8>
                     cmp op7 'D' | jne L7>                     ; PCMPEQB/W/D
L8:                    Mov cl op7 | Mov op1 00_01110100
                         jmp gg2
L7:                  ;BadMnemonic
L6:                ;BadMnemonic
L5:                ifnot op5 'G', L5>
                     ifnot op6 'T', L6>
                       cmp op7 'B' | je L8>
                       cmp op7 'W' | je L8>
                       cmp op7 'D' | jne L7>                    ; PCMPGTB/W/D
L8:                      Mov cl op7 | Mov op1 00_01100100
                             jmp gg2
L7:                    ;BadMnemonic
L6:                  ;BadMnemonic
L5:               ;BadMnemonic
L4:             ;BadMnemonic
L3:          BadMnemonic
L2:        ifnot op2 'F', L2>
             ifnot op3 'C', L3>
               ifnot op4 'M', L4>
                 ifnot op5 'P', L5>
                   ifnot op6 'E', L6>
                     ifnot op7 'Q', L7>    ; PFCMPEQ
                         Mov op1 0B0 | jmp mm3D
L7:                  BadMnemonic
L6:                ifnot op6 'G', L6>
                     ifnot op7 'E', L7>    ; PFCMPGE
                         Mov op1 090 | jmp mm3D
L7:                  ifnot op7 'T', L7>    ; PFCMPGT
                         Mov op1 0A0 | jmp mm3D
L5:               ;BadMnemonic
L4:             BadMnemonic
L3:          ifnot op3 'R', L3>
               ifnot op4 'S', L4>
                 ifnot op5 'Q', L5>
                   ifnot op6 'R', L6>
                     ifnot op7 'T', L7>    ; PFRSQRT
                         Mov op1 097 | jmp mm3D
L7:
L6:
L5:
L4:
L3:          BadMnemonic
L2:        ifnot op2 'M', L2>>
             ifnot op3 'A', L3>
               ifnot op4 'D', L4>
                 ifnot op5 'D', L5>
                   ifnot op6 'W', L6>
                     ifnot op7 'D', L7>                      ; PMADDWD
                        Mov op1 0F5
                        If B$FirstRegGender = REG_XMM
                            ToOpcode 066 | jmp XmmMemXmm
                        Else_If B$FirstRegGender = REG_MMX
                            jmp mmTwo
                        End_If
L7: BadMnemonic
L6:
L5:
L4:
L3:          ifnot op3 'U', L3>
               ifnot op4 'L', L4>
                 ifnot op5 'H', L5>
                   ifnot op6 'R', L6>
                     ifnot op7 'W', L7>                      ; PMULHRW
                         Mov op1 0B7 | jmp mm3D
L7: BadMnemonic
L6:                ifnot op6 'U', L6>
                     ifnot op7 'W', L7>                      ; PMULHUW
                         Mov op1 0011100100 | jmp OQregMemToReg
L6:     ;BadMnemonic
L7: BadMnemonic
L5:              ifnot op5 'U', L5>
                   ifnot op6 'D', L6>
                     ifnot op7 'Q', L7>                      ; PMULUDQ
                         Mov op1 0F4 | jmp OQRegMemToReg
L7:
L6:
L5:
L4:
L3:          BadMnemonic
L2:        ifnot op2 'S', L2>
             ifnot op3 'H', L3>
               ifnot op4 'U', L4>
                 ifnot op5 'F', L5>
                      cmp op7 'W' | jne L7>                      ; PSHUFLW
                   If op6 = 'H'                      ; PSHUFHW
                       ToOpcode 0011110011 | jmp P0>
                   End_If
                   ifnot op6 'L', L6>
                       ToOpcode 0011110010
P0:                    Mov op1 001110000 | jmp XmmMemXmmImm3
L3:          ifnot op3 'U', L3>
               ifnot op4 'B', L4>
                 ifnot op5 'U', L5>
                   ifnot op6 'S', L6>
                     cmp op7 'B' | je L8>
                     cmp op7 'W' | jne L7>                      ; PSUBUSB/W
L8:                    Mov cl op7 | Mov op1 00_11011000 | jmp gg2
L7:                  ;BadMnemonic
L6:                ;BadMnemonic
L5:              ;BadMnemonic
L4:            ;BadMnemonic
L3:          BadMnemonic
L2:         ifnot op2 'U', L2>
              ifnot op3 'N', L3>
                ifnot op4 'P', L4>
                  ifnot op5 'C', L5>
                    ifnot op6 'K', L6>
                      ifnot op7 'H', L7>                        ; PUNPCKH/L
                        Mov cl, 'B' | Mov op1 00_01101000 | jmp gg2
L7:                   ifnot op7 'L', L7>
                        Mov cl, 'B' | Mov op1 00_01100000 | jmp gg2
L7:                   ;BadMnemonic
L6:                 ;BadMnemonic
L5:               ;BadMnemonic
L4:             ;BadMnemonic
L3:           ;BadMnemonic
L2:       BadMnemonic
L1:    ifnot op1 'R', L1>
         ifnot op2 'S', L2>
           ifnot op3 'Q', L3>
             ifnot op4 'R', L4>
               ifnot op5 'T', L5>
                 ifnot op6 'S', L6>
                   ToOpcode 0011110011 | jmp L7>     ; RSQRTSS
L6:              ifnot op6 'P', L6>
L7:                ifnot op7 'S', L7>                ; RSQRTPS
                      Mov op1 001010010 | jmp XMMmemXMM
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'S', L1>>
         ifnot op2 'Y', L2>
           ifnot op3 'S', L3>
             ifnot op4 'E', L4>
               ifnot op5 'X', L5>
                 ifnot op6 'I', L6>
                   ifnot op7 'T', L7>                ;  SYSEXIT (no use in win Apps)
                       parms 0
                       Mov al 0F | stosb | Mov al 035 | stosb | ret
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'T', L2>
           ifnot op3 'M', L3>
             ifnot op4 'X', L4>
               ifnot op5 'C', L5>
                 ifnot op6 'S', L6>
                   ifnot op7 'R', L7>                ;  STMXCSR
                       parms 1
                       On B$FirstGender <> MEM_LABEL BadOperand  ; xmmmemxmm
                       On B$FirstOperandWbit <> DWORD_SIZE BadOperandSize
                       ToOpcode 0F, 0AE
                       Mov al 00_011_000 | or al B$ModBits | or al B$RmBits | LastOpcode al
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      ;BadMnemonic
L1:    ifnot op1 'U', L1>
         ifnot op2 'C', L2>
           ifnot op3 'O', L3>
             ifnot op4 'M', L4>
               ifnot op5 'I', L5>
                 ifnot op6 'S', L6>
                   ifnot op7 'D', L7>                ;  UCOMISD
                       ToOpcode 001100110 | jmp L8>
L7:                ifnot op7 'S', L7>                ;  UCOMISS
L8:                   Mov op1 00101110 | jmp XMMmemXMM
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      ;BadMnemonic
L1:    BadMnemonic


 _________________________________________________________________________________________


heightLetters:        On B$esi+8 > Separators,  jmp NineLetters

L1:  ifnot op1 'A', L1>>
       ifnot op2 'D', L2>>
         ifnot op3 'D', L3>>
           ifnot op4 'S', L4>>
             ifnot op5 'U', L5>
               ifnot op6 'B', L6>
                 ifnot op7 'P', L7>
                   ifnot op8 'D', L8>   ; ADDSUBPD 66,0F,D0,/r ADDSUBPS xmm1, xmm2/m128
                     ToOpcode 066 | Mov Op1 0D0 | jmp XmmMemXmm
L8:                ifnot op8 'S', L8>   ; ADDSUBPS F2,0F,D0,/r ADDSUBPD xmm1, xmm2/m128
                     ToOpcode 0F2 | Mov Op1 0D0 | jmp XmmMemXmm
L8:                ;BadMnemonic
L8:              ;BadMnemonic
L7:            ;BadMnemonic
L6:          ;BadMnemonic
L5:        ;BadMnemonic
L4:      ;BadMnemonic
L3:    ;BadMnemonic
L2:   BadMnemonic
L1:  ifnot op1 'C', L1>>
       ifnot op2 'V', L2>>
         ifnot op3 'T', L3>>
           ifnot op4 'D', L4>>
             ifnot op5 'Q', L5>
               ifnot op6 '2', L6>
                 ifnot op7 'P', L7>
                   ifnot op8 'D', L8>                 ; CVTDQ2PD
                     ToOpcode 0011110011 | Mov op1 0011100110 | jmp XMMmemXMM
L8:                ifnot op8 'S', L8>                 ; CVTDQ2PS
                     Mov op1 001011011 | jmp XMMmemXMM
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            ;BadMnemonic
L5:          BadMnemonic
L4:        ifnot op4 'P', L4>>
             ifnot op5 'D', L5>
               ifnot op6 '2', L6>
                 ifnot op7 'D', L7>
                   ifnot op8 'Q', L8>                 ; CVTPD2DQ
                     ToOpcode 0011110010 | Mov op1 0011100110 | jmp XMMmemXMM
L8:                BadMnemonic
L7:              ifnot op7 'P', L7>
                   ifnot op8 'I', L8>                 ; CVTPD2PI
                     ToOpcode 001100110 | Mov op1 00101101 | jmp MMXmemXMM
L8:                ifnot op8 'S', L8>                 ; CVTPD2PS
                     ToOpcode 001100110 | Mov op1 001011010 | jmp MMXmemXMM
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            BadMnemonic
L5:          ifnot op5 'I', L5>
               ifnot op6 '2', L6>
                 ifnot op7 'P', L7>
                   ifnot op8 'D', L8>                 ; CVTPI2PD
                       ToOpcode 001100110 | jmp L9>
L8:                ifnot op8 'S', L8>                 ;  CVTPI2PS
L9:                    Mov op1  00101010 | jmp XMMmemXMM
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            BadMnemonic
L5:          ifnot op5 'S', L5>
               ifnot op6 '2', L6>
                 ifnot op7 'D', L7>
                   ifnot op8 'Q', L8>                 ;  CVTPS2DQ
                     ToOpcode 066 | Mov op1 05B | jmp XMMmemXMM
L8:                BadMnemonic
L7:              ifnot op7 'P', L7>
                   ifnot op8 'D', L8>                 ;  CVTPS2PD
                      Mov op1 001011010 | jmp XMMmemXMM
L8:                ifnot op8 'I', L8>                 ;  CVTPS2PI
                       Mov op1  00101101 | jmp MMXmemXMM
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            ;BadMnemonic
L5:          BadMnemonic
L4:        ifnot op4 'S', L4>>
             ifnot op5 'D', L5>
               ifnot op6 '2', L6>
                 ifnot op7 'S', L7>
                   ifnot op8 'S', L8>                 ;  CVTSD2SS
                       ToOpcode 0011110010 | Mov op1 001011010 | jmp XMMmemXMM
L8:                ifnot op8 'I', L8>                 ;  CVTSD2SI
                       Mov op1 02D | jmp LowXMMtoDwordWithF2
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            BadMnemonic
L5:          ifnot op5 'I', L5>
               ifnot op6 '2', L6>
                 ifnot op7 'S', L7>
                   ifnot op8 'D', L8>                 ;  CVTSI2SD
                       Mov op1 02A | jmp DwordToLowXMMWithF2
L8:                ifnot op8 'S', L8>                 ;  CVTSI2SS
L9:                    Mov op1 00101010 | jmp DwordToLowXMM
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            BadMnemonic
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            BadMnemonic
L5:          ifnot op5 'S', L5>
               ifnot op6 '2', L6>
                 ifnot op7 'S', L7>
                   ifnot op8 'D', L8>                 ;  CVTSS2SD
                       ToOpcode 0011110011 | Mov op1 001011010 | jmp XMMmemXMM
L8:                ifnot op8 'I', L8>                 ;  CVTSS2SI
L9:                    Mov op1 00101101 | jmp LowXMMtoDword
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            ;BadMnemonic
L5:          ;BadMnemonic
L4:       ;BadMnemonic
L3:     ;BadMnemonic
L2:   BadMnemonic
L1:  ifnot op1 'M', L1>
       ifnot op2 'A', L2>
         ifnot op3 'S', L3>
           ifnot op4 'K', L4>
             ifnot op5 'M', L5>
               ifnot op6 'O', L6>
                 ifnot op7 'V', L7>
                   ifnot op8 'Q', L8>                 ; MASKMOVQ
                       Mov op1 0011110111 | jmp mmOne
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            ;BadMnemonic
L5:          ;BadMnemonic
L4:       ;BadMnemonic
L3:     ;BadMnemonic
L2:   BadMnemonic
L1:  ifnot op1 'P', L1>>
       ifnot op2 'A', L2>>
         ifnot op3 'C', L3>>
           ifnot op4 'K', L4>>
             ifnot op5 'S', L5>>
               ifnot op6 'S', L6>>
                 ifnot op7 'D', L7>
                   ifnot op8 'W', L8>                 ; PACKSSDW
                       .If B$FirstRegGender = REG_XMM
                           ToOpcode 001100110 | Mov B$FirstRegGender REG_MMX
                           If B$Operands = REG_TO_REG
                               On B$SecondRegGender = REG_XMM Mov B$SecondRegGender REG_MMX
                           End_If
                       .End_If
                       Mov op1 00_01101011 | jmp mmTwo
L8:                BadMnemonic
L7:              ifnot op7 'W', L7>
                   ifnot op8 'B', L8>                 ; PACKSSWB
                       .If B$FirstRegGender = REG_XMM
                           ToOpcode 001100110 | Mov B$FirstRegGender REG_MMX
                           If B$Operands = REG_TO_REG
                               On B$SecondRegGender = REG_XMM Mov B$SecondRegGender REG_MMX
                           End_If
                       .End_If
                     Mov op1 00_01100011 | jmp mmTwo
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            BadMnemonic
L5:          ifnot op5 'U', L5>
               ifnot op6 'S', L6>
                 ifnot op7 'W', L7>
                   ifnot op8 'B', L8>                 ; PACKUSWB
                       .If B$FirstRegGender = REG_XMM
                           ToOpcode 001100110 | Mov B$FirstRegGender REG_MMX
                           If B$Operands = REG_TO_REG
                               On B$SecondRegGender = REG_XMM Mov B$SecondRegGender REG_MMX
                           End_If
                       .End_If
                       Mov op1 00_01100111 | jmp mmTwo
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            ;BadMnemonic
L5:          ;BadMnemonic
L4:        ;BadMnemonic
L3:      BadMnemonic
L2:      ifnot op2 'M', L2>
           ifnot op3 'O', L3>
             ifnot op4 'V', L4>
               ifnot op5 'M', L4>
                 ifnot op6 'S', L4>
                   ifnot op7 'K', L4>
                     ifnot op8 'B', L4>                   ; PMOVMSKB
                         Mov op1 0D7 | jmp OQreg32Reg
L4: BadMnemonic
L3:        ifnot op3 'U', L3>
             ifnot op4 'L', L4>>
               ifnot op5 'L', L4>>
                 ifnot op6 'U', L4>>
                   ifnot op7 'D', L4>>
                     ifnot op8 'Q', L4>>                   ; PMULLUDQ
                         Mov op1 0011110100 | jmp OQregMemToReg
L3: BadMnemonic
L2:      ifnot op2 'R', L2>
           ifnot op3 'E', L3>
             ifnot op4 'F', L4>
               ifnot op5 'E', L5>
                 ifnot op6 'T', L6>
                   ifnot op7 'C', L7>
                     ifnot op8 'H', L8>                   ; PREFETCH (AMD).
                         cmp B$ParametersNumber 1 | jne L9>
                         cmp B$FirstGender MEM_LABEL | jne L9>
                         cmp B$FirstOperandwBit BYTE_SIZE | jne L9>
                       ;  cmp B$SIBinside &TRUE | je L9>
                       ;  cmp B$EregInside &TRUE | je L9>
                             Mov al 0F | stosb | Mov al 0D | stosb
                             Mov al B$ModBits | or al B$RmBits | stosb | ret
L9: error D$PrefetchMemPtr
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            ;BadMnemonic
L5:          ;BadMnemonic
L4:        ;BadMnemonic
L3: BadMnemonic
L2:    ifnot op2 'U', L2>
         ifnot op3 'N', L3>
           ifnot op4 'P', L4>
             ifnot op5 'C', L5>
               ifnot op6 'K', L6>
                 ifnot op7 'H', L7>
                   cmp op8 'B' | je L9>
                   cmp op8 'W' | je L9>
                   cmp op8 'D' | jne L8>                         ; PUNPCKHB/W/D
PUNPCKH_one:
L9:                  Mov cl op8
                     Mov op1 00_01101000 | jmp gg2
L8:                BadMnemonic
L7:              ifnot op7 'L', L7>
                   cmp op8 'B' | je L9>
                   cmp op8 'W' | je L9>
                   cmp op8 'D' | jne L8>                         ; PUNPCKLB/W/
PUNPCKL_one:
L9:                  Mov cl op8
                     Mov op1 00_01100000 | jmp gg2
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:    ifnot op2 'F', L2>
         ifnot op3 'R', L3>
           ifnot op4 'C', L4>
             ifnot op5 'P', L5>
               ifnot op6 'I', L6>
                 ifnot op7 'T', L7>
                   ifnot op8 '1', L8>           ; PFRCPIT1
                       Mov op1 0A6 | jmp mm3D
L8:                ifnot op8 '2', L8>           ; PFRCPIT2
                       Mov op1 0B6 | jmp mm3D
L8:                  ;BadMnemonic
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:           BadMnemonic
L4:        ifnot op4 'S', L4>
             ifnot op5 'Q', L5>
               ifnot op6 'I', L6>
                 ifnot op7 'T', L7>
                   ifnot op8 '1', L8>           ; PFRSQIT1
                       Mov op1 0A7 | jmp mm3D
L8:                  ;BadMnemonic
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'U', L1>
         ifnot op2 'N', L2>
           ifnot op3 'P', L3>
             ifnot op4 'C', L4>
               ifnot op5 'K', L5>
                 ifnot op6 'H', L6>
                   ifnot op7 'P', L7>
                     ifnot op8 'D', L8>                             ; UNPCKHPD
                         ToOpcode 001100110 | jmp L9>
L8:                  ifnot op8 'S', L8>                             ; UNPCKHPS
L9:                      Mov op1 0010101 | jmp XMMmemXMM
L8:                  ;BadMnemonic
L7:                BadMnemonic
L6:              ifnot op6 'L', L6>
                   ifnot op7 'P', L7>
                     ifnot op8 'D', L8>                             ; UNPCKLPD
                         ToOpcode 001100110 | jmp L9>
L8:                  ifnot op8 'S', L8>                             ; UNPCKLPS
L9:                      Mov op1 0010100 | jmp XMMmemXMM
L8:                  ;BadMnemonic
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'S', L1>
         ifnot op2 'Y', L2>
           ifnot op3 'S', L3>
             ifnot op4 'E', L4>
               ifnot op5 'N', L5>
                 ifnot op6 'T', L6>
                   IFNOT op7 'E', L7>
                     ifnot op8 'R', L8>                             ; SYSENTER
                       parms 0
                       Mov al 0F | stosb | Mov al 034 | stosb | ret
L8:                  ;BadMnemonic
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      ;BadMnemonic
L1:    BadMnemonic

____________________________________________________________________________________________


NineLetters:   cmp B$esi+9 Separators | ja TenLetters

       ifnot op1 'C', L1>>
         ifnot op2 'M', L2>
           ifnot op3 'P', L3>>
             ifnot op4 'X', L3>>
               ifnot op5 'C', L3>>
                 ifnot op6 'H', L3>>
                   ifnot op7 'G', L3>>
                     ifnot op8 '8', L3>>
                       ifnot B$esi+8 'B', L3>>             ; CMPXCHG8B
                         On B$FirstOperandwbit <> QWORD_SIZE error D$OperandSizePtr
                         Mov op1 0F, op2 0C7, op3 00_001_000
                         jmp Op_Op_ModRm

L0:                        BadOperand
; ...............
L2:      ifnot op2 'V', L2>
           ifnot op3 'T', L3>
             ifnot op4 'T', L3>
               ifnot op5 'P', L5>
                 ifnot op6 'D', L6>
                   ifnot op7 '2', L3>
                     ifnot op8 'D', L8>
                       ifnot B$esi+8 'Q', L3>             ; CVTTPD2DQ
                           ToOpcode 001100110 | Mov op1 0011100110 | jmp XMMmemXMM
L3:                    ifnot B$esi+8 'I', L3>             ; CVTTPD2PI
                          ToOpcode 066 | Mov op1 02C | jmp MMXmemXMM
L6:              ifnot op6 'S', L3>
                   ifnot op7 '2', L3>
                     ifnot op8 'D', L8>
                       ifnot B$esi+8 'Q', L3>             ; CVTTPS2DQ
                           ToOpcode 0011110011 | Mov op1 001011011 | jmp XMMmemXMM
L8:                  ifnot op8 'P', L3>
                       ifnot B$esi+8 'I', L3>             ; CVTTPS2PI
C1:                      Mov op1 00101100 | jmp MMXmemXMM
L2:
L3: BadMnemonic

L5:            ifnot op5 'P', L5>
                 ifnot op6 'S', L3>
                   ifnot op7 '2', L3>
                     ifnot op8 'P', L3>
                       ifnot B$esi+8 'I', L3>             ; CVTTPS2SI
C1:                       Mov op1 00101100 | jmp LowXMMtoDword
L5:            ifnot op5 'S', L3>
                 ifnot op6 'D', L5>
                   ifnot op7 '2', L3>
                     ifnot op8 'S', L3>
                       ifnot B$esi+8 'I', L3>             ; CVTTSD2SI
                           Mov op1 02C | jmp LowXMMtoDwordWithF2
L5:              ifnot op6 'S', L3>
                   ifnot op7 '2', L3>
                     ifnot op8 'S', L3>
                       ifnot B$esi+8 'I', L3>             ; CVTTSS2SI r32, xmm/m32
                           Mov op1 02C | jmp LowXMMtoDword

L3: BadMnemonic

L1:    ifnot op1 'P', L3>>
         ifnot op2 'R', L2>>
           ifnot op3 'E', L3>>
             ifnot op4 'F', L3>>
               ifnot op5 'E', L3>>
                 ifnot op6 'T', L3>>
                   ifnot op7 'C', L3>>
                     ifnot op8 'H', L3>>                   ; PREFETCH0/1/2 (Intel).
                       If B$esi+8 = 'W'
                        ; AMD PREFETCHW:
                          Mov al 0F | stosb | Mov al 0D | stosb
                          Mov al 00_001_000 | or al B$ModBits | or al B$RmBits | stosb | ret
                       End_If
                       Mov bl B$esi+8                     ; 'W/0/1/2'
                       inc bl | sub bl '0'                ;    1/2/3
                       cmp bl 3 | ja L3>>                 ; Same as PREFETCHT0/1/2 (alternate).
                       cmp bl 0 | je L3>>
                       cmp B$ParametersNumber 1 | jne L1>
                         cmp B$FirstGender MEM_LABEL | jne L1>
                         cmp B$FirstOperandwBit BYTE_SIZE | jne L1>
                       ;  cmp B$SIBinside &TRUE | je L1>
                       ;  cmp B$EregInside &TRUE | je L1>
                             Mov al 0F | stosb
                             Mov al 018                ; INTEL (0/1/2)
                             stosb
                             Mov al bl | shl al 3
                             or al B$ModBits | or al B$RmBits | stosb | ret
L1: error D$PrefetchMemPtr

; PUNPCKH.. / PUNPCKL.. are send to PUNPCKH / L .

L2:     ifnot op2 'U', L3>>
           ifnot op3 'N', L3>>
             ifnot op4 'P', L3>>
               ifnot op5 'C', L3>>
                 ifnot op6 'K', L3>>
                   ifnot op7 'L', L7>
                     If W$esi+7 = 'BW'            ; PUNPCKLBW
                         jmp PUNPCKL_one
                     Else_If W$esi+7 = 'WD'       ; PUNPCKLWD
                         jmp PUNPCKL_one
                     Else_If W$esi+7 = 'DQ'       ; PUNPCKLDQ
                         jmp PUNPCKL_one
                     End_If
                     BadMnemonic
L7:               ifnot op7 'H', L3>
                     If W$esi+7 = 'BW'            ; PUNPCKLBW
                         jmp PUNPCKH_one
                     Else_If W$esi+7 = 'WD'       ; PUNPCKLWD
                         jmp PUNPCKH_one
                     Else_If W$esi+7 = 'DQ'       ; PUNPCKLDQ
                         jmp PUNPCKH_one
                     End_If
L3: BadMnemonic

TenLetters: cmp B$esi+10 Separators | ja ElevenLetters
       ifnot op1 'M', L1>>
         ifnot op2 'A', L3>>
           ifnot op3 'S', L3>>
             ifnot op4 'K', L3>>
               ifnot op5 'M', L3>>
                 ifnot op6 'O', L3>>
                   ifnot op7 'V', L3>>
                     ifnot op8 'D', L3>>
                       ifnot B$esi+8 'Q', L3>>
                         ifnot B$esi+9 'U', L3>>   ; MASKMOVDQU
                             ToOpcode 001100110 | Mov op1 0011110111 | jmp XmmXmm
L3: BadMnemonic

L1:    ifnot op1 'P', L3>>
         ifnot op2 'R', L2>>
           ifnot op3 'E', L3>>
             ifnot op4 'F', L3>>
               ifnot op5 'E', L3>>
                 ifnot op6 'T', L3>>
                   ifnot op7 'C', L3>>
                     ifnot op8 'H', L3>>                   ; PREFETCHT0/1/2 (Intel).
                       ifnot B$esi+8 'T', L3>>            ; Same as PREFETCH0/1/2
                       Mov bl B$esi+9                     ; 'W/0/1/2'
                       inc bl | sub bl '0'                ;    1/2/3
                       cmp bl 3 | ja L3>>
                       cmp bl 0 | je L3>>
                       cmp B$ParametersNumber 1 | jne L1>
                         cmp B$FirstGender MEM_LABEL | jne L1>
                         cmp B$FirstOperandwBit BYTE_SIZE | jne L1>
                       ;  cmp B$SIBinside &TRUE | je L1>
                       ;  cmp B$EregInside &TRUE | je L1>
                             Mov al 0F | stosb
                             Mov al 018                ; INTEL (0/1/2)
                             stosb
                             Mov al bl | shl al 3
                             or al B$ModBits | or al B$RmBits | stosb | ret
L1: error D$PrefetchMemPtr

L2:      ifnot op2 'U', L3>>
           ifnot op3 'N', L3>>
             ifnot op4 'P', L3>>
               ifnot op5 'C', L3>>
                 ifnot op6 'K', L3>>
                   ifnot op7 'H', L7>>
                     Mov op1 0001101101
L8:                  ifnot op8 'Q', L3>>
                       ifnot B$esi+8 'D', L3>>
                         ifnot B$esi+9 'Q', L3>>  ; PUNPCKHQDQ
                             ToOpcode 066 | jmp XmmMemXmm
L7: Mov op1 001101100 | jmp L8<                    ; PUNPCKLQDQ

L3: BadMnemonic

ElevenLetters: cmp B$esi+11 Separators | ja TwelveLetters

L1:    ifnot op1 'P', L3>>
         ifnot op2 'R', L3>>
           ifnot op3 'E', L3>>
             ifnot op4 'F', L3>>
               ifnot op5 'E', L3>>
                 ifnot op6 'T', L3>>
                   ifnot op7 'C', L3>>
                     ifnot op8 'H', L3>>                   ; PREFETCHNTA
                       ifnot B$esi+8 'N', L3>>
                         ifnot B$esi+9 'T', L3>>
                           ifnot B$esi+10 'A', L3>>
                             cmp B$ParametersNumber 1 | jne L1>
                               cmp B$FirstGender MEM_LABEL | jne L1>
                               cmp B$FirstOperandwBit BYTE_SIZE | jne L1>
                             ;  cmp B$SIBinside &TRUE | je L1>
                             ;  cmp B$EregInside &TRUE | je L1>
                                   Mov al 0F | stosb | Mov al 018 | stosb
                                   Mov al 0
                                   or al B$ModBits | or al B$RmBits | stosb | ret
L1: error D$PrefetchMemPtr
L3: BadMnemonic


TwelveLetters: BadMnemonic
 _________________________________________________________________________________________

; 'J'  >>>  all 'J'  first letter here
;
;  Special treatment for all 'tttn' opcodes and all '.MOV...' instructions
 _________________________________________________________________________________________


J_Branching:
    If op1 = 'U'
        ToOpcode 02E
    Else_If op1 = 'L'
        ToOpcode 03E
    End_If
    add esi 4 | Call Store8cars

Letter_J:        On op2 = 'M',  jmp JMPmnemo

         ifnot op2 'C', L2>
           ifnot op3 'X', L1>
             ifnot op4 'Z', L1>                     ; JCXZ
               cmp op5 Separators | ja L1>
                 ToOpcode 067 | jmp X0>

L2:      ifnot op2 'E', L1>
           ifnot op3 'C', L1>
             ifnot op4 'X', L1>
               ifnot op5 'Z', L1>                   ; JECXZ
                 cmp op6 Separators | ja L1>
X0:                cmp B$LocalSize JMP_DOWN_SHORT | je R1>
                   cmp B$LocalSize JMP_UP_SHORT | jne R0>
R1:                  Mov op1 00_1110_0011 | jmp op_dis8
R0:                error D$NoPlainLabelForJECXPtr


L1:      Push esi
           inc esi
           Call SearchFortttnBits
         Pop esi
      ;   Call Store8Cars

; JCC:
    On B$FirstGender <> DISPLACEMENT BadOperand

    cmp B$LocalSize JMP_DOWN_SHORT | je L1>
    cmp B$LocalSize JMP_UP_SHORT | jne L2>
L1:   Mov op1 00_0111_0000 | or op1 B$tttnBits | jmp op_dis8
L2: cmp B$LocalSize JMP_DOWN_LONG | je L3>
    cmp B$LocalSize JMP_UP_LONG | jne L4>
L3:   Mov D$Relative RelativeFlag
      On B$ShortenJumpsWanted = &TRUE, Call SetShortenJmpFlag
      Mov op1 00_1111,  op2 00_1000_0000 | or op2 B$tttnBits | jmp op_op_dis
L4: cmp B$LabelInside &TRUE | je L3<

    BadOperand


JMPmnemo:
            ifnot op3 'P', L9>>
              cmp op4 Separators | ja L1>>
              Mov D$Relative RelativeFlag
              cmp B$LocalSize JMP_DOWN_SHORT | Je L4>
              cmp B$LocalSize JMP_UP_SHORT | jne L5>

              ;On B$ShortenJumpsWanted = &TRUE, Call SetShortenJmpFlag

L4:           Mov op1 00_1110_1011 | jmp op_dis8     ; Short
L5:           cmp B$FirstGender DISPLACEMENT | jne L6>        ; Long
                cmp B$LocalSize JMP_DOWN_LONG | je K0>
                cmp B$LocalSize JMP_UP_LONG | jne K1>
K0:                  On B$ShortenJumpsWanted = &TRUE, Call SetJMPShortenJmpFlag
K1:                  Mov op1 00_1110_1001 | jmp op_dis
L6:           cmp B$FirstGender GENERAL_REG | jne L7>
                Mov op1 00_1111_1111,  op2 00_11_100_000 | jmp op_reg1
L7:           ifnot B$FirstGender MEM_LABEL L8>
                Mov D$Relative 0
                Mov op1 00_1111_1111,  op2 00_100_000 | jmp op_modRm
L8:           BadOperand
L9:    BadMnemonic

L1:         ifnot op4 'F', L3>>
             cmp op5 Separators | ja L3>>
L5:             ifnot B$FirstGender MEM_LABEL L4>
                ifnot B$ParametersNumber 2, L5>             ; JMPF jE! added
                ifnot B$SecondGender IMM_VALUE L4>
                cmp B$EregInside 0 | jne L4>
                ToOpcode  0EA
                cmp B$FirstParaMem 'W' | je L2>
                cmp B$FirstParaMem 'D' | jne L4>
                cmp B$PossibleImmLabel 0 | je L8>; | int 3
                Mov D$CodeListPtr edi | pushad | Call SecondParameterLabel | popad
            L8:
                Mov eax D$imm32 | stosd | jmp L6>
            L2: Mov eax D$imm32 | stosw | test eax 0FFFF0000 NOT_ZERO L7>
            L6: Mov eax D$dis32 | stosw | test eax 0FFFF0000 NOT_ZERO L7>
                Call ClearParameters
                ret
L5:           Mov op1 00_1111_1111,  op2 0010_1000 | jmp op_modRm
L4:          BadOperand
L3:         BadMnemonic
L7:       error D$OverWordPtr
 ________________________________________________________________________________________

; MOVs
 ________________________________________________________________________________________

; (segments registers are over 00111)

MOVinstructions:                                        ; killing exceptions !!!
                 On op4 <> Space,  jmp MOVsMnemo

      ifnot B$Operands REG_TO_REG L1>>
        ifnot B$SecondRegGender SEGMENT_REG L2>               ; general purpose? yes > L2
          On B$FirstRegGender <> GENERAL_REG error D$GPregisterPtr
          GPreg1
          Mov op1 00_1000_1100,  op2 00_1100_0000
          or op2 B$SecondReg | or op2 B$FirstReg | jmp op_op_P2     ; reg2 is an sreg
L2:     ifnot B$FirstRegGender SEGMENT_REG L2>               ; general purpose? yes > L2
          GPreg2
          ifnot B$FirstReg REG_SS L3>
            Mov op1 00_1000_1110,  op2 00_1100_0000           ; reg1 is an REG_SS
            or op2 B$FirstReg | or op2 B$SecondReg | jmp op_op_P2
L3:       Mov op1 00_1000_1110,  op2 00_1100_0000             ; reg1 is an sreg
          or op2 B$FirstReg | or op2 B$SecondReg | jmp op_op_P2

L2:   ifnot B$SecondRegGender DEBUG_REG L2>               ; Debug Register2?
        On B$FirstRegGender <> GENERAL_REG error D$GPregisterPtr
        GPreg1
        ToOpcode 0F, 0010_0001  ; 0000 1111 : 0010 0001 : 11 eee reg
        Mov al B$SecondReg | shl al 3 | or al B$FirstReg | or al 0011_000_000
        LastOpcode al

L2:   ifnot B$FirstRegGender DEBUG_REG L2>               ; Debug Register1?
        GPreg2
        ToOpcode 0F, 0010_0011  ; 0000 1111 : 0010 0011 : 11 eee reg
        Mov al B$FirstReg | shl al 3 | or al B$SecondReg | or al 0011_000_000
        LastOpcode al

L2:   ifnot B$SecondRegGender CONTROL_REG L2>               ; Control Register2?
        On B$FirstRegGender <> GENERAL_REG error D$GPregisterPtr
        GPreg1
        ToOpcode 0F, 0010_0000  ; 0000 1111 : 0010 0000 : 11 eee reg
        Mov al B$SecondReg | shl al 3 | or al B$FirstReg | or al 0011_000_000
        LastOpcode al

L2:   ifnot B$FirstRegGender CONTROL_REG L2>               ; Control Register1?
        GPreg2
        ToOpcode 0F, 0010_0010  ; 0000 1111 : 0010 0010 : 11 eee reg
        Mov al B$FirstReg | shl al 3 | or al B$SecondReg | or al 0011_000_000
        LastOpcode al

L2:     Mov op1 00_1000_1010,  op2 00_1100_0000 | jmp w_reg1reg2 ; 1/2 general P.

L1:   ifnot B$Operands MEM_TO_REG L1>
        ifnot B$FirstRegGender SEGMENT_REG L2> | Mov B$wBitDisagree &FALSE ; jE!
          ifnot B$FirstReg REG_SS L3>
            Mov op1 00_1000_1110
              Mov op2 B$FirstReg | jmp op_modRm_P2
L3:       Mov op1 00_1000_1110,  op2 B$FirstReg | jmp op_modRm_P2
L2:     GPreg1
        cmp B$FirstReg REG_EAX | jne L3>
          cmp B$ModBits 0 | jne L3>
            cmp B$RmBits 00101 | jne L3>
              Mov op1 00_1010_0000 | jmp w_dis  ;!!!!!!!!! simple label only !!!!!!!!

L3:     Mov op1 00_1000_1010 | jmp w_modReg1Rm

L1:   ifnot B$Operands REG_TO_MEM L1>
        ifnot B$SecondRegGender SEGMENT_REG L2> | Mov B$wBitDisagree &FALSE ; jE!
          Mov op1 00_1000_1100,  op2 B$SecondReg | jmp op_modRm_P2
L2:    GPreg2
       cmp B$SecondReg REG_EAX | jne L3>
          cmp B$ModBits 0 | jne L3>
            cmp B$RmBits 00101 | jne L3>
               Mov op1 00_1010_0010 | jmp w_dis  ;!!!!!!!!! simple label only !!!!!!!!

L3:     Mov op1 00_1000_1000 | jmp w_modreg2Rm

L1:  ifnot B$Operands IMM_TO_REG L1>
       ;Mov op1 00_1100_0110,  op2 00_1100_0000 | jmp w_reg1_imm ; alternate shorter >
        Mov op1 B$wBit | shl op1 3 | or op1 00_1011_0000 | jmp reg_in_op_imm
L1:  ifnot B$Operands IMM_TO_MEM L1>
        On B$FirstOperandwbit >= QWORD_SIZE jmp L1>

        Mov op1 00_1100_0110,  op2 0 | jmp w_modRm_imm

L1:  BadOperand


;Mov  Move to/from Control Registers
;CR0 from register               0000 1111 : 0010 0010 : 11 000 reg
;CR2 from register               0000 1111 : 0010 0010 : 11 010 reg
;CR3 from register               0000 1111 : 0010 0010 : 11 011 reg
;CR4 from register               0000 1111 : 0010 0010 : 11 100 reg
;register from CR0-CR4           0000 1111 : 0010 0000 : 11 eee reg

;Mov  Move to/from Debug Registers
;DR0-DR3 from register           0000 1111 : 0010 0011 : 11 eee reg
;DR4-DR5 from register           0000 1111 : 0010 0011 : 11 eee reg
;DR6-DR7 from register           0000 1111 : 0010 0011 : 11 eee reg
;register from DR6-DR7           0000 1111 : 0010 0001 : 11 eee reg
;register from DR4-DR5           0000 1111 : 0010 0001 : 11 eee reg
;register from DR0-DR3           0000 1111 : 0010 0001 : 11 eee reg


MOVsMnemo:
    On op5 > Separators, jmp L0>>
      ifnot op4 'D', L4>                                ; MOVD
        If B$FirstGender = MEM_LABEL
            On B$FirstOperandwBit <> DWORD_SIZE BadOperandSize
        Else_If B$SecondGender = MEM_LABEL
            On B$SecondOperandwBit <> DWORD_SIZE BadOperandSize
        End_If
          Mov op1 00_01101110
          cmp B$FirstRegGender REG_XMM | je XmmFour
          cmp B$SecondRegGender REG_XMM | je XmmFour
          jmp mmFour
L4:   ifnot op4 'Q', L4>                                ; MOVQ ; THE HELL!!!!!!!!!!!!!!
         If B$FirstRegGender = REG_XMM
             ToOpcode 0F3 | Mov op1 07E | jmp MovqXMMmemXMMmem ;XMMtoFromMem ; MovqXMMmemXMMmem
         Else_If B$SecondRegGender = REG_XMM
             ToOpcode 066 | Mov op1 0C6 | jmp MovqXMMmemXMMmem; XMMtoFromMem ; MovqXMMmemXMMmem
           ; This 0C6 will be 0D6 by the xor in the 'MovqXMMmemXMMmem' Routine.
           ; This encodage is not fully sure. May be an error in Intel Doc. Not
           ; implemented in NASM...
         Else_If B$Operands = REG_TO_MEM
            Mov op1 07F | jmp MMregToMem ;mmTwo ;mmFour
         Else
            Mov op1 06F | jmp mmTwo ;mmFour
         End_If

L4:   On op4 = 'S',  error D$NotYetMnemoPtr       ; MOVS  (???)

BadMnemonic

L0: On op6 > Separators,  jmp MovSixLetters


L4:   ifnot op4 'S', L4>>
        ifnot op5 'B', L5>                  ; MOVSB
          Mov op1 00_1010_0100 | jmp op
L5:     ifnot op5 'W', L5>                  ; MOVSW
          ToOpcode 066
          Mov op1 00_1010_0101 | jmp op
L5:     ifnot op5 'D', L5>                  ; MOVSD
          If B$FirstRegGender = REG_XMM
            ; down there
          Else_If B$SecondRegGender = REG_XMM
            ; down there
          Else
              Mov op1 00_0101_00101 | jmp op
          End_If

          ToOpcode 0011110010 | Mov op1 00010000 | jmp XMMmemXMMmem

L5:     ifnot op5 'S', L5>                      ; MOVSS (SSE SIMD)
          ToOpcode 0011110011
          Mov op1 010 | jmp XMMmem32XMMmem32
L5:     ifnot op5 'X', L5>
          Mov op1 00_1111,  op2 00_1011_1110    ; MOVSX
          ifnot B$Operands REG_TO_REG L6>
            Mov op3 00_1100_0000 | jmp op_w_reg1reg2X
L6:       ifnot B$Operands MEM_TO_REG L6>
            jmp op_w_modReg1RmX
L6:       ;BadOperand
L5:     BadMnemonic
L4:     ifnot op4 'Z', L4>                      ; MOVZX
          ifnot op5 'X', L4>
            Mov op1 00_1111
            Mov op2 00_1011_0110
            ifnot B$Operands REG_TO_REG L7>
              Mov op3 00_1100_0000 | jmp op_w_reg1reg2X
L7:         ifnot B$Operands MEM_TO_REG L7>
              jmp op_w_modReg1RmX
L7:         BadOperand
L6:       ;BadMnemonic
L5:     ;BadMnemonic
L4:   BadMnemonic


MovSixLetters:  On op7 > Separators, jmp MovSevenLetter

      ifnot op4 'A', L4>
        ifnot op5 'P', L5>
          ifnot op6 'D', L6>      ; MOVAPD
              ToOpcode 001100110 | Mov op1 00101000 | jmp XMMmemXMMmem
L6:       ifnot op6 'S', L6>      ; MOVAPS
            Mov op1 00101000 | jmp XMMmemXMMmem
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:   ifnot op4 'D', L4>
        ifnot op5 'Q', L5>
          ifnot op6 'A', L6>      ; MOVDQA
              ToOpcode 001100110 | Mov op1 06F | jmp MovqXMMmemXMMmem
L6:       ifnot op6 'U', L6>      ; MOVDQU
              ToOpcode 0011110011 | Mov op1 001101111 | jmp MovqXMMmemXMMmem
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:   ifnot op4 'H', L4>
        ifnot op5 'P', L5>
          ifnot op6 'D', L6>      ; MOVHPD
              ToOpcode 001100110 | Mov op1 00010110 | jmp XMMtoFromMem
L6:       ifnot op6 'S', L6>      ; MOVHPS
            Mov op1 0010110 | jmp XMMTOFromMem
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:   ifnot op4 'L', L4>
        ifnot op5 'P', L5>
          ifnot op6 'D', L6>      ; MOVLPD
              ToOpcode 001100110 | jmp L7>
L6:       ifnot op6 'S', L6>      ; MOVLPS
L7:           Mov op1 0010010 | jmp XMMTOFromMem
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:         ifnot op4 'N', L4>
               ifnot op5 'T', L5>
                 Ifnot op6 'I', L6>                         ; MOVNTI
                     ToOpcode 0F
                     Mov op1 0011000011 | jmp op_modReg2Rm
L6:              Ifnot op6 'Q', L6>                         ; MOVNTQ
                     Mov op1 0011100111 | jmp MMregToMem
L6:              ;BadMnemonic
L5:            BadMnemonic
L4:   ifnot op4 'U', L4>
        ifnot op5 'P', L5>
          ifnot op6 'D', L6>      ; MOVUPD
            ToOpcode 001100110 | jmp L7>
L6:       ifnot op6 'S', L6>      ; MOVUPS
L7:         Mov op1 0010000 | jmp XMMmemXMMmem
L6:       ;BadMnemonic
L5:     ;BadMnemonic
L4:   BadMnemonic


MovSevenLetter: On op8 > Separators, jmp MovHeightLetters
      ifnot op4 'D', L4>
        ifnot op5 'Q', L5>
          ifnot op6 '2', L6>
            ifnot op7 'Q', L7>                   ; MOVDQ2Q
                ToOpcode 0011110010 | Mov op1 0011010110 | jmp mmXmm
L7:         ;BadMnemonic
L6:       BadMnemonic
L5:     ifnot op5 'D', L5>
          ifnot op6 'U', L6>
            ifnot op7 'P', L7>                   ; MOVDDUP F2,0F,12,/r MOVDDUP xmm1, xmm2/m64
              ToOPcode 0F2 | Mov Op1 012 | jmp XmmMemXmm
L7:         ;BadMnemonic
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:   ifnot op4 'H', L4>
        ifnot op5 'L', L5>
          ifnot op6 'P', L6>
            ifnot op7 'S', L7>                   ; MOVHLPS
              Mov op1 0010010 | jmp XMMXMM
L7:         ;BadMnemonic
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:   ifnot op4 'L', L4>
        ifnot op5 'H', L5>
          ifnot op6 'P', L6>
            ifnot op7 'S', L7>                   ; MOVLHPS
              Mov op1 0010110 | jmp XMMXMM
L7:         ;BadMnemonic
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:   ifnot op4 'N', L4>
        ifnot op5 'T', L5>
          ifnot op6 'D', L6>
            ifnot op7 'Q', L7>                               ; MOVNTDQ
                ToOpcode 001100110 | Mov op1 0011100111 | jmp XMMtoMem
L7:         BadMnemonic
L6:       ifnot op6 'P', L6>
            ifnot op7 'D', L7>                               ; MOVNTPD
                ToOpcode 001100110 | jmp L8>
L7:         ifnot op7 'S', L7>                               ; MOVNTPS
L8:             Mov op1 00101011 | jmp XMMtoMem
L7:         ;BadMnemonic
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:   ifnot op4 'Q', L4>
        ifnot op5 '2', L5>
          ifnot op6 'D', L6>
            ifnot op7 'Q', L7>                   ; MOVQ2DQ
                ToOpcode 0011110011 | Mov op1 0011010110 | jmp Xmmmm ;XmmXmm mmXmm
L7:         ;BadMnemonic
L6:       ;BadMnemonic
L5:     ;BadMnemonic
L4:   BadMnemonic



MovHeightLetters: On B$esi+8 > Separators, BadMnemonic
      ifnot op4 'M', L4>
        ifnot op5 'S', L5>
          ifnot op6 'K', L6>
            ifnot op7 'P', L7>
              ifnot op8 'D', L8>                     ; MOVMSKPD
                ; 01100110:00001111:01010000:11 r32 REG_XMM
                ToOpcode 001100110 | jmp L9>
L8:           ifnot op8 'S', L8>                     ; MOVMSKPS
                ; 00001111:01010000:11 r32 REG_XMM    ; (unique)
L9:             ToOpcode 001111, 001010000
                cmp B$Operands REG_TO_REG | jne L9>
                cmp B$FirstRegGender GENERAL_REG | jne L9>>
                cmp B$SecondRegGender REG_XMM | jne L9>>
                On B$FirstOperandwBit <> DWORD_SIZE BadOperandSize
                Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
                LastOpcode al
L9:             BadOperand
L8:           ;BadMnemonic
L7:         ;BadMnemonic
L6:       ;BadMnemonic
L5:     ;BadMnemonic
L4:   ifnot op4 'S', L4>
        ifnot op5 'H', L5>
          ifnot op6 'D', L6>
            ifnot op7 'U', L7>
              ifnot op8 'P', L8>    ; MOVSHDUP: F3,0F,16,/r MOVSHDUP xmm1, xmm2/m128
                ToOpcode 0F3 | Mov Op1 016 | jmp XmmMemXmm
L8:           ;BadMnemonic
L7:         ;BadMnemonic
L6:       BadMnemonic
L5:     ifnot op5 'L', L5>
          ifnot op6 'D', L6>
            ifnot op7 'U', L7>
              ifnot op8 'P', L8>    ; MOVSLDUP: F3,0F,12,/r MOVSLDUP xmm1, xmm2/m128
                ToOpcode 0F3 | Mov Op1 012 | jmp XmmMemXmm
L8:           ;BadMnemonic
L7:         ;BadMnemonic
L6:       ;BadMnemonic
L5:     ;BadMnemonic
L4:   BadMnemonic



SETinstructions:

    Push esi
      add esi 3 | Call SearchFortttnBits
    Pop esi

    Mov op1 00_1111,  op2 00_1001_0000 | or op2 B$tttnBits
    On B$FirstOperandWbit <> 0,  error D$NeedByteSizePtr
    ifnot B$FirstGender GENERAL_REG L1>
      Mov op3 00_1100_0000 | jmp op_op_reg1
L1: ifnot B$FirstGender MEM_LABEL L2>
     Mov op3 0 | jmp op_op_modRm
L2: BadOperand



CMOVinstructions:                      ; CMOVcc

    Push esi
      add esi 4 | Call SearchFortttnBits
    Pop esi

    Mov op1 00_1111,  op2 00_0100_0000 | or op2 B$tttnBits

    ifnot B$Operands REG_TO_REG L1>
      Mov op3 00_1100_0000 | jmp op_op_reg1reg2
L1: ifnot B$Operands MEM_TO_REG L2>
      jmp op_op_modReg1Rm                           ; Intel doc says: ModMemRm (???!!!)
L2: BadOperand

____________________________________________________________________________________________
; XMM comparisons:
;
; the notation i choose is, for example, CMP_PS_AE.
; Setting the conditions a end simplify analyzes.
;
; Encodage is ended by a 8 bit imm (from 0 to 7) specifying the comparison mode.

XMMcomparePS: ; CMPPS... encounted.
    Mov B$imm32 0FF, B$immInside &TRUE, B$TrueSize BYTE_SIZE

    ...If B$esi+7 < Separators             ; B$esi+7 = op8 > 7 Chars mnemonic
        ..If op6 = 'E'
            If op7 = 'A'
                Mov B$imm32 0                   ; =  EA
            End_If
        ..Else_If op6 = 'L'
            If op7 = 'T'
                Mov B$imm32 1                   ; <  LT
            Else_If op7 = 'E'
                Mov B$imm32 2                   ; <= LE
            End_If
        ..End_If

    ...Else_If B$esi+8 < Separators        ; > 8 Chars
        ..If op6 = 'N'
            .If op7 = 'E'
                If op8 = 'Q'
                    Mov B$imm32 4               ; <> NEQ
                End_If
            .Else_If op7 = 'L'
                If op8 = 'T'
                    Mov B$imm32 5               ; NLT  (not <)
                Else_If op8 > 'E'
                    Mov B$imm32 6               ; NLE  (not <=)
                End_If
            .End_If
        ..Else_If op6 = 'O'
            .If op7 = 'R'
                If op8 = 'D'
                    Mov B$imm32 7               ; Ordonated
                End_If
            .End_If
        ..End_If

    ...Else_If B$esi+10 < Separators
        .If D$esi+5 = 'UNOR'
            If B$esi+9 = 'D'                    ; CMPPSUNORD
                Mov B$imm32 3                   ; UnOrdonated.... oughhhh!!!!!!!!!
            End_If
        .End_If

    ...End_If

    On B$imm32 = 0FF, BadMnemonic

    Mov op1 0011000010 | jmp XMMmemXMM

_________________________________________________________________

; Turn, for example,
; 'CMP_UNORD_SD'
;             ^edi  ('SD' in eax)
;          ^esi
; 'CMP_SD_UNORD':

TrySSE2:
    Push esi, edi
        lea ebx D$esi+2
        While B$esi > Separators | inc esi | End_While | dec esi
        Mov ax W$esi-1
        Mov edi esi | sub esi 2
        std
            while esi <> ebx | movsb | End_While
        cld
        dec edi | stosw
    Pop edi esi

    Call Store8cars

    ifnot op4 'P', L4>
        ifnot op5 'S', L5>      ; CMPPS... with given Condition (ex: CMP_SS_LT)
            jmp XMMcomparePS
L5:     ifnot op5 'D', L1>      ; CMPPD...
            jmp XMMcomparePD
L4: ifnot op4 'S', L1>
        ifnot op5 'S', L5>      ; CMPSS...
            jmp XMMcompareSS
L5:     ifnot op5 'D', L1>      ; CMPSD...
            jmp XMMcompareSD

L1: BadMnemonic
ret


XMMcompareSS: ; CMPSS... encounted.
    ToOpcode 0011110011 | jmp XMMcomparePS ; (Prefix + same encodage).

XMMcompareSD: ; CMPSS... encounted.
    ToOpcode 0011110010 | jmp XMMcomparePS ; (Prefix + same encodage).

XMMcomparePD: ; CMPSS... encounted.
    ToOpcode 0001100110 | jmp XMMcomparePS ; (Prefix + same encodage).

 _________________________________________________________________________________________

; all math mnemonics begin by 'F'.

; as FPU instructions operands are either memory or ST regs, no control is done here
; for other operands than 'mem' (if not mem >>> reg supposed). All needed controls are
; done in destination 'reg's routines. See down there 'op_STreg:' for exemple.


Math:

    On op4 > Separators, jmp M4>>
      ifnot op2 'L', L2>
        ifnot op3 'D', L3>                      ; FLD  Load Real
          ifnot B$FirstGender MEM_LABEL L4>
            ifnot B$FirstOperandWbit DWORD_SIZE L5>
              Mov op1 00_11011_001, op2 0 | jmp op_ModRm
L5:         ifnot B$FirstOperandWbit QWORD_SIZE L5>
              Mov op1 00_11011_101, op2 0 | jmp op_ModRm
L5:         ifnot B$FirstOperandWbit TBYTE_SIZE L5>
              Mov op1 00_11011_011, op2 00101_000 | jmp op_ModRm
L5:         BadOperandSize
L4:       Mov op1 00_1101_1001, op2 00_11000_000 | jmp op_STregP1
L3:     BadMnemonic
L2:   ifnot op2 'S', L2>
        ifnot op3 'T', L3>                        ; FST  Store Real
          ifnot B$FirstGender MEM_LABEL L4>
            ifnot B$FirstOperandWbit DWORD_SIZE L5>
              Mov op1 00_11011_001, op2 00010_000 | jmp op_ModRm
L5:         ifnot B$FirstOperandWbit QWORD_SIZE L5>
              Mov op1 00_11011_101, op2 00010_000 | jmp op_ModRm
L5:         BadOperandSize
L4:       Mov op1 00_11011_101, op2 00_11010_000 | jmp op_STregP1
L3:     ;BadMnemonic
L2:   BadMnemonic
 ____________________________________

M4: On op5 > Separators, jmp M5>>
      ifnot op2 'A', L2>
        ifnot op3 'B', L3>
          ifnot op4 'S', L4>                    ; FABS  Absolute Value
            Mov op1 00_1101_1001, op2 00_1110_0001 | jmp op_op
L4:       BadMnemonic
L3:     ifnot op3 'D', L3>
          ifnot op4 'D', L4>                    ; FADD  Add
            ifnot B$FirstGender MEM_LABEL L5>
              ifnot B$FirstOperandWbit DWORD_SIZE L6>
                Mov op1 00_11011_000, op2 0 | jmp op_ModRm
L6:           ifnot B$FirstOperandWbit QWORD_SIZE L6>
                Mov op1 00_11011_100, op2 0 | jmp op_ModRm
L6:           BadOperandSize
L5:         Mov op1 0011011_000, op2 00_11_000_000 | jmp d_STreg
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'B', L2>
          ifnot op3 'L', L3>
            ifnot op4 'D', L4>                     ; FBLD  Load Binary Coded Decimal
              ifnot B$FirstGender MEM_LABEL L5>
                  ifnot B$FirstOperandwbit TBYTE_SIZE L6>
                  Mov op1 0DF, op2 00_100_000 | jmp op_modRm
L6:             BadOperandSize
L5:           BadOperand
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'C', L2>>
          ifnot op3 'H', L3>
            ifnot op4 'S', L4>                     ; FCHS  Change Sign
              Mov op1 00_11011_001, op2 00_1110_0000 | jmp op_op
L4:         BadMnemonic
L3:       ifnot op3 'O', L3>
            ifnot op4 'M', L4>                     ; FCOM  Compare Real
L5:           ifnot B$FirstGender MEM_LABEL L5>
                ifnot B$FirstOperandWbit DWORD_SIZE L6>
                  Mov op1 00_11011_000, op2 00_010_000 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit QWORD_SIZE, L6>
                  Mov op1 00_11011_100, op2 00_010_000 | jmp op_ModRM
L6:             BadOperandSize
L5:           Mov op1 00_11011_000, op2 00_11_010_000 | jmp op_STreg
L4:         ifnot op4 'S', L4>                     ; FCOS  Cosine of ST(0)
              Mov op1 00_11011_001, op2 00_1111_1111 | jmp op_op
L4:         BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'D', L2>
          ifnot op3 'I', L3>
            ifnot op4 'V', L4>
              ifnot B$FirstGender MEM_LABEL L5>                 ; FDIV  Divide
                ifnot B$FirstOperandWbit DWORD_SIZE L6>
                  Mov op1 00_11011_000, op2 00_110_000 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit QWORD_SIZE, L6>
                  Mov op1 00_11011_100, op2 00_110_000 | jmp op_ModRm
L6:             BadOperandSize
L5:           Mov op1 00_11011_000, op2 00_1111_0_000 | jmp d_RSTreg
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'I', L2>>
          ifnot op3 'L', L3>
            ifnot op4 'D', L4>                ; FILD  Load Integer
              ifnot B$FirstGender MEM_LABEL L5>
                ifnot B$FirstOperandWbit WORD_SIZE L6>
                  Mov op1 00_11011_111, op2 0 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit DWORD_SIZE L6>
                  Mov op1 00_11011_011, op2 0 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit QWORD_SIZE L6>
                  Mov op1 00_11011_111, op2 00_101_000 | jmp op_ModRm
L6:             BadOperandSize
L5:           BadOperand
L4:         BadMnemonic
L3:       ifnot op3 'S', L3>
            ifnot op4 'T', L4>
              ifnot B$FirstGender MEM_LABEL L5>               ; FIST  Store Integer
                ifnot B$FirstOperandWbit WORD_SIZE L6>
                  Mov op1 00_11011_111, op2 00_010_000 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit DWORD_SIZE L6>
                  Mov op1  00_11011_011, op2 00_010_000 | jmp op_ModRm
L6:             BadOperandSize
L5:           BadOperand
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'L', L2>
          ifnot op3 'D', L3>
            ifnot op4 '1', L4>                             ; FLD1  Load +1.0 into ST(0)
              Mov op1 00_11011_001, op2 00_1110_1000 | jmp op_op
L4:         ifnot op4 'Z', L4>                             ; FLDZ  Load +0.0 into ST(0)
              Mov op1 00_11011_001, op2 00_1110_1110 | jmp op_op
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'M', L2>
          ifnot op3 'U', L3>
            ifnot op4 'L', L4>
              ifnot B$FirstGender MEM_LABEL L5>              ; FMUL  Multiply
                ifnot B$FirstOperandWbit DWORD_SIZE L6>
                  Mov op1 00_11011_000, op2 00_001_000 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit QWORD_SIZE L6>
                  Mov op1 00_11011_100, op2 00_001_000 | jmp op_ModRm
L6:             BadOperandSize
L5:           Mov op1 00_11011_000, op2 00_1100_1_000 | jmp d_STreg
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'N', L2>
          ifnot op3 'O', L3>
            ifnot op4 'P', L4>                ; FNOP  No Operation
              Mov op1 00_11011_001, op2 00_1101_0000 | jmp op_op
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'S', L2>>
          ifnot op3 'I', L3>
            ifnot op4 'N', L4>                 ; FSIN  Sine
              Mov op1 00_11011_001, op2 00_1111_1110 | jmp op_op
L4:         BadMnemonic
L3:       ifnot op3 'T', L3>>
            ifnot op4 'P', L4>                 ; FSTP  Store Real and Pop
              ifnot B$FirstGender MEM_LABEL L5>
                ifnot B$FirstOperandWbit DWORD_SIZE L6>
                  Mov op1 00_11011_001, op2 00_011_000 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit QWORD_SIZE L6>
                  Mov op1 00_11011_101, op2 00_011_000 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit TBYTE_SIZE L6>
                  Mov op1 00_11011_011, op2 00_111_000 | jmp op_ModRm
L6:             BadOperandSize
L5:           Mov op1 00_11°11_101, op2 00_11__011_000 | jmp op_STregP1
L4:         BadMnemonic
L3:       ifnot op3 'U', L3>
            ifnot op4 'B', L4>                          ; FSUB  Subtract
              ifnot B$FirstGender MEM_LABEL L5>
                ifnot B$FirstOperandWbit DWORD_SIZE L6>
                  Mov op1 00_11011_000, op2 00_100_000 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit QWORD_SIZE L6>
                  Mov op1 00_11011_100, op2 00_100_000 | jmp op_ModRm
L6:             BadOperandSize
L5:           Mov op1 00_11011_000, op2 00_1110_0_000 | jmp d_RSTreg ; d_STreg
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'T', L2>
          ifnot op3 'S', L3>
            ifnot op4 'T', L4>                         ; FTST  Test
              Mov op1 00_11011_001, op2 00_1110_0100 | jmp op_op
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'X', L2>
          ifnot op3 'A', L3>
            ifnot op4 'M', L4>                          ; FXAM  Examine
              Mov op1 00_11011_001, op2 00_1110_0101 | jmp op_op
L4:         BadMnemonic
L3:       ifnot op3 'C', L3>
            ifnot op4 'H', L4>                         ; FXCH  Exchange ST(0) and ST(i)
               Mov op1 00_11011_001, op2 00_1100_1_000 | jmp op_STreg
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:     BadMnemonic

 ____________________________________

M5: On op6 > Separators, jmp M6>>

      ifnot op2 '2', L2>
        ifnot op3 'X', L3>
          ifnot op4 'M', L4>
            ifnot op5 '1', L5>                     ;F2XM1  Compute 2 ST(0)  1
              Mov op1 00_11011_001, op2 00_11110000 | jmp op_op
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'A', L2>
        ifnot op3 'D', L3>
          ifnot op4 'D', L4>
            ifnot op5 'P', L5>                    ; FADDP  Add and Pop ST(0) ¬ ST(0) + ST(i)
              On B$ParametersNumber <> 2, NoFpAssume
              On B$SecondReg <> 0, error D$FADDPreg0Ptr
              Mov op1 00_11011_110, op2 00_11_000_000 | jmp op_STreg
L5:         ;BadMnemonic
L4:       ;BadMemonic
L3:     BadMnemonic
L2:   ifnot op2 'B', L2>
        ifnot op3 'S', L3>
          ifnot op4 'T', L4>
            ifnot op5 'P', L5>             ; FBSTP  Store Binary Coded Decimal and Pop
              ifnot B$FirstGender MEM_LABEL L6>
                ifnot B$FirstOperandwbit TBYTE_SIZE L7>
                Mov op1 0DF, op2 00_110_000 | jmp op_modRm
L7:             BadOperandSize
L6:           BadOperand
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'C', L2>
        ifnot op3 'L', L3>
          ifnot op4 'E', L4>
            ifnot op5 'X', L5>              ; FCLEX  Clear Exceptions
              ToOpcode 09B, 0DB | LastOpCode 0E2
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'O', L3>
          ifnot op4 'M', L4>
            ifnot op5 'P', L5>              ; FCOMP  Compare Real and Pop
              ifnot B$FirstGender MEM_LABEL L6>
                ifnot B$FirstOperandWbit DWORD_SIZE L7>
                  Mov op1 00_11011_000, op2 00_011_000 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit QWORD_SIZE L7>
                  Mov op1 00_11011_100, op2 00_011_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           Mov op1 00_11011_000, op2 00_11_011_000 | jmp op_STreg
L5:         ifnot op5 'I', L5>                 ; FCOMI  Compare Real and Set EFLAGS
              Mov op1 00_11011_011, op2 00_11_110_000 | jmp op_STreg
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'D', L2>
        ifnot op3 'I', L3>
          ifnot op4 'V', L4>
            ifnot op5 'P', L5>                    ; FDIVP  Divide and Pop
              On B$ParametersNumber <> 2, NoFpAssume
              Mov op1 00_11011_110, op2 00_1111_1_000 | jmp opSTreg
L5:         ifnot op5 'R', L5>                    ; FDIVR  Reverse Divide
              ifnot B$FirstGender MEM_LABEL L6>
                ifnot B$FirstOperandWbit DWORD_SIZE L7>
                  Mov op1 00_11011_000, op2 00_111_000 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit QWORD_SIZE L7>
                  Mov op1 00_11011_100, op2 00_111_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           Mov op1 00_11011_000, op2 00_1111_1_000 | jmp d_RSTreg
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:      ifnot op2 'E', L2>
           ifnot op3 'M', L3>
             ifnot op4 'M', L4>
               ifnot op5 'S', L5>               ; FEMMS (not an FPU -3DNaow!-)
                   Mov al 0F | stosb | Mov al 0E | stosb | ret
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:   ifnot op2 'F', L2>
        ifnot op3 'R', L3>
          ifnot op4 'E', L4>
            ifnot op5 'E', L5>                       ; FFREE  Free ST(i) Register
              Mov op1 00_11011_101, op2 00_1100_0_000 | jmp op_STregP1
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'I', L2>>
        ifnot op3 'A', L3>
          ifnot op4 'D', L4>
            ifnot op5 'D', L5>                      ; FIADD  Add Integer
              ifnot B$FirstGender MEM_LABEL L6>
                ifnot B$FirstOperandWbit WORD_SIZE L7>
                  Mov op1 00_11011_110, op2 0 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit DWORD_SIZE L7>
                  Mov op1 00_11011_010, op2 0 | jmp op_ModRm
L7:             BadOperandSize
L6:           BadOperand
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'C', L3>
          ifnot op4 'O', L4>
            ifnot op5 'M', L5>               ; FICOM  Compare Integer
              ifnot B$FirstGender MEM_LABEL L6>
                ifnot B$FirstOperandWbit WORD_SIZE L7>
                  Mov op1 00_11011_110, op2 00_010_000 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit DWORD_SIZE L7>
                  Mov op1 00_11011_010, op2 00_010_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           BadOperand
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'D', L3>
          ifnot op4 'I', L4>
            ifnot op5 'V', L5>                               ; FIDIV
              ifnot B$FirstGender MEM_LABEL L6>
                ifnot B$FirstOperandWbit WORD_SIZE L7>
                  Mov op1 00_11011_110, op2 00_110_000 | jmp op_modRm
L7:             ifnot B$FirstOperandWbit DWORD_SIZE L7>
                  Mov op1 00_11011_010, op2 00_110_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           BadOperand
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'M', L3>
          ifnot op4 'U', L4>
            ifnot op5 'L', L5>                              ; FIMUL
              ifnot B$FirstGender MEM_LABEL L6>
                ifnot B$FirstOperandWbit WORD_SIZE L7>
                  Mov op1 00_11011_110, op2 00_001_000 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit DWORD_SIZE L7>
                  Mov op1 00_11011_010, op2 00_001_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           Badoperand
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'N', L3>
          ifnot op4 'I', L4>
            ifnot op5 'T', L5>                      ; FINIT  Initialize Floating-Point Unit
              toOpcode 09B, 0DB | LastOpcode 0E3
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'S', L3>>
          ifnot op4 'T', L4>
            ifnot op5 'P', L5>                         ; FISTP  Store Integer and Pop
              ifnot B$FirstGender MEM_LABEL L6>
                ifnot B$FirstOperandWbit WORD_SIZE L7>
                  Mov op1 00_11011_111, op2 00_011_000 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit DWORD_SIZE L7>
                  Mov op1 00_11011_011, op2 00_011_000 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit QWORD_SIZE L7>
                  Mov op1 00_11011_111, op2 00_111_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           BadOperand
L5:         BadMnemonic
L4:       ifnot op4 'U', L4>
            ifnot op5 'B', L5>                         ; FISUB
              ifnot B$FirstGender MEM_LABEL L6>
                ifnot B$FirstOperandWbit WORD_SIZE L7>
                  dec edi       ; No need 066 here.
                  Mov op1 00_11011_110, op2 00_100_000 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit DWORD_SIZE L7>
                  Mov op1 00_11011_010, op2 00_100_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           BadOperand
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'L', L2>
        ifnot op3 'D', L3>
          ifnot op4 'C', L4>
            ifnot op5 'W', L5>                      ; FLDCW  Load Control Word
              ifnot B$FirstGender MEM_LABEL L6>
                ifnot B$FirstOperandWbit WORD_SIZE L7>
                  dec edi                             ; scratch 066 prefix (no use)
                  Mov op1 00_11011_001, op2 00_101_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           BadOperand
L5:         BadMnemonic
L4:       ifnot op4 'P', L4>
            ifnot op5 'I', L5>                         ; FLDPI  Load p into ST(0)
              Mov op1 00_11011_001, op2 00_11101011 | jmp op_op
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'M', L2>
        ifnot op3 'U', L3>
          ifnot op4 'L', L4>
            ifnot op5 'P', L5>                     ; FMULP  Multiply
              On B$ParametersNumber <> 2, NoFpAssume
              Mov op1 00_11011_110, op2 00_1100_1_000 | jmp op_STreg
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'P', L2>
        ifnot op3 'R', L3>
          ifnot op4 'E', L4>
            ifnot op5 'M', L5>                       ; FPREM  Partial Remainder
              Mov op1 00_11011_001, op2 00_1111_1000 | jmp op_op
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'T', L3>
          ifnot op4 'A', L4>
            ifnot op5 'N', L5>                       ; FPTAN  Partial Tangent
              Mov op1 00_11011_001, op2 00_1111_0010 | jmp op_op
L5:         BadMnemonic
L4:       BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'S', L2>>
        ifnot op3 'A', L3>
          ifnot op4 'V', L4>
            ifnot op5 'E', L5>                  ; FSAVE  Store FPU State 108 Bytes
              ifnot B$FirstGender MEM_LABEL L6>
                ifnot B$FirstOperandWbit USO_SIZE L7>
                  ToOpcode 09B
                  Mov op1 00_11011_101, op2 00_110_000 | jmp op_ModRm
L7:             error D$XmarkerPtr
L6:           BadOperand
L5:         BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'Q', L3>
          ifnot op4 'R', L4>
            ifnot op5 'T', L5>                  ; FSQRT  Square Root
              Mov op1 00_11011_001, op2 00_1111_1010 | jmp op_op
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:  ifnot op3 'T', L3>>
          ifnot op4 'C', L4>
            ifnot op5 'W', L5>                  ; FSTCW  Store Control Word
              ifnot B$FirstGender MEM_LABEL, L6>
                ifnot B$FirstOperandWbit WORD_SIZE L7>
                  dec edi                               ; scratch 066 prefix (no use here)
                  ToOpcode 09B
                  Mov op1 00_11011_001, op2 00_111_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           BadOperand
L5:         BadMnemonic
L4:     ifnot op4 'S', L4>
           ifnot op5 'W', L5>                  ; FSTSW  Store Status Word into AX or mem
             dec edi                               ; scratch 066 prefix (no use here)
             ToOpcode 09B
             ifnot B$FirstGender MEM_LABEL L6>
                ifnot B$FirstOperandWbit WORD_SIZE L7>
                  Mov op1 0DD, op2 00_111_000 | jmp op_ModRm
L7:             BadOperandSize
L6:          ifnot B$FirstGender GENERAL_REG L6>
               ifnot B$FirstOperandWbit WORD_SIZE L7>
                 ifnot B$FirstReg REG_AX L6>
                   Mov op1 0DF, op2 00_11100000 | jmp op_op_P1
L7:            BadOperandSize
L6:          BadOperand
L5:        BadMnemonic
L4:      BadMnemonic
L3:    ifnot op3 'U', L3>
         ifnot op4 'B', L4>
           ifnot op5 'P', L5>                   ; FSUBP  Subtract and Pop
             On B$ParametersNumber <> 2, NoFpAssume
             On B$SecondReg <> REG_ST0 error D$FSUBPreg0Ptr  ; FADDPreg0
             Mov op1 00_11011_110, op2 00_1110_1_000 | jmp d_STreg  ;;;op_STreg
L5:        ifnot op5 'R', L5>                   ; FSUBR  Reverse Subtract
             ifnot B$FirstGender MEM_LABEL L6>
               ifnot B$FirstOperandWbit DWORD_SIZE L7>
                 Mov op1 00_11011_000, op2 00_101_000 | jmp op_ModRm
L7:            ifnot B$FirstOperandWbit QWORD_SIZE L7>
                 Mov op1 00_11011_100, op2 00_101_000 | jmp op_ModRm
L7:            BadOperandSize
L6:          Mov op1 00_11011_000, op2 00_1110_1_000 | jmp d_RSTreg
L5:        ;BadMnemonic
L4:      ;BadMnemonic
L3:    BadMnemonic
L2:  ifnot op2 'U', L2>
       ifnot op3 'C', L3>
         ifnot op4 'O', L4>
           ifnot op5 'M', L5>              ; FUCOM  Unordered Compare Real
             Mov op1 00_11011_101, op2 00_1110_0_000 | jmp op_STreg
L5:        ;BadMnemonic
L4:      ;BadMnemonic
L3:    BadMnemonic
L2:  ifnot op2 'Y', L2>
       ifnot op3 'L', L3>
         ifnot op4 '2', L4>
           ifnot op5 'X', L5>              ; FYL2X  ST(1) ´ log 2 (ST(0))
             Mov op1 00_11011_001, op2 00_1111_0001 | jmp op_op
L5:        ;BadMnemonic
L4:      ;BadMnemonic
L3:    BadMnemonic
L2:  ifnot op2 'W', L2>
       ifnot op3 'A', L3>
         ifnot op4 'I', L4>
           ifnot op5 'T', L5>                   ; FWAIT  Wait until FPU Ready
             Mov op1 00_1001_1011 | jmp op
L5:        ;BadMnemonic
L4:      ;BadMnemonic
L3:    ;BadMnemonic
L2:  BadMnemonic

 ____________________________________

M6: On op7 > Separators, jmp M7>>

      ifnot op2 'C', L2>
        ifnot op3 'O', L3>
          ifnot op4 'M', L4>
            ifnot op5 'P', L5>
              ifnot op6 'P', L6>          ; FCOMPP  Compare Real and Pop Twice
                Mov op1 00_11011_110, op2 00_11_011_001 | jmp op_op
L6:           BadMnemonic
L5:         ifnot op5 'I', L5>
              ifnot op6 'P', L6>          ; FCOMIP  Compare Real, Set EFLAGS, and Pop
                Mov op1 00_11011_111, op2 00_11_110_000 | jmp op_STreg
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       BadMnemonic
 ________________________________

L3:     On op3 = 'M', jmp FCMOVcc        ; >>>>>>>>>> down there
 ________________________________

L2:   ifnot op2 'D', L2>
        ifnot op3 'I', L3>
          ifnot op4 'V', L4>
            ifnot op5 'R', L5>
              ifnot op6 'P', L6>              ; FDIVRP  Reverse Divide and Pop
                On B$ParametersNumber <> 2, NoFpAssume
                Mov op1 00_11011_110, op2 00_1111_0_000 | jmp op_STreg
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'F', L2>
        ifnot op3 'R', L3>
          ifnot op4 'E', L4>
            ifnot op5 'E', L5>                       ; FFREEP   Free ST(i) Register and Pop
              ifnot op6 'P', L6>
              Mov op1 0DF, op2 0C0 | jmp op_STregP1
L6:
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'I', L2>>
        ifnot op3 'C', L3>
          ifnot op4 'O', L4>
            ifnot op5 'M', L5>
              ifnot op6 'P', L6>           ; FICOMP  Compare Integer and Pop
                ifnot B$FirstGender MEM_LABEL L7>
                  ifnot B$FirstOperandWbit WORD_SIZE L8>
                    Mov op1 00_11011_110, op2 00_011_000 | jmp op_ModRm
L8:               ifnot B$FirstOperandWbit DWORD_SIZE L8>
                    Mov op1 00_11011_010, op2 00_011_000 | jmp op_ModRm
L8:               BadOperandSize
L7:             BadOperand
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'D', L3>
          ifnot op4 'I', L4>
            ifnot op5 'V', L5>
              ifnot op6, 'R', L6>                           ; FIDIVR
                ifnot B$FirstGender MEM_LABEL L7>
                  ifnot B$FirstOperandWbit WORD_SIZE L8>
                    Mov op1 00_11011_110, op2 00_111_000 | jmp op_ModRm
L8:               ifnot B$FirstOperandWbit DWORD_SIZE L8>
                    Mov op1 00_11011_010, op2 00_111_000 | jmp op_ModRm
L8:               BadOperandSize
L7:             BadOperand
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'S', L3>>
          ifnot op4 'T', L4>
            ifnot op5 'T', L5>>
              ifnot op6 'P', L6>>       ; FISTTP
                ifnot B$FirstGender MEM_LABEL L7>
                If B$FirstOperandWbit = WORD_SIZE
                    Mov op1 0DF
                Else_If B$FirstOperandWbit = DWORD_SIZE
                    Mov op1 0DB
                Else_If B$FirstOperandWbit = QWORD_SIZE
                    Mov op1 0DD
                Else
                    BadOperand
                End_If
                Mov op2 00_001_000 | jmp op_ModRm

L4:       ifnot op4 'U', L4>
            ifnot op5 'B', L5>
              ifnot op6 'R', L6>                       ; FISUBR
                ifnot B$FirstGender MEM_LABEL L7>
                  ifnot B$FirstOperandWbit WORD_SIZE L8>
                    dec edi         ; No need of 066 here.
                    Mov op1 00_11011_110, op2 00_101_000 | jmp op_ModRm
L8:               ifnot B$FirstOperandWbit DWORD_SIZE L8>
                    Mov op1 00_11011_010, op2 00_101_000 | jmp op_ModRm
L8:               BadOperandSize
L7:             BadOperand
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:      BadMnemonic
L2:    ifnot op2 'L', L2>>
         ifnot op3 'D', L3>>
           ifnot op4 'E', L4>
             ifnot op5 'N', L5>
               ifnot op6 'V', L6>                ; FLDENV  Load FPU Environment
                 ifnot B$FirstGender MEM_LABEL L7>
                   ifnot B$FirstOperandWbit USO_SIZE L8>
                     Mov op1 00_11011_001, op2 00_100_000 | jmp op_ModRm  ;  m28 bytes
L8:                error D$XmarkerPtr
L7:              BadOperand
L6:           ;BadMnemonic
L5:         BadMnemonic
L4:       ifnot op4 'L', L4>
            ifnot op5 '2', L5>
              ifnot op6 'E', L6>           ; FLDL2E  Load log 2 (e) into ST(0)
                Mov op1 00_11011_001, op2 00_1110_1010 | jmp op_op
L6:           ifnot op6 'T', L6>           ; FLDL2T  Load log 2 (10) into ST(0)
                Mov op1 00_11011_001, op2 00_1110_1001 | jmp op_op
L6:           BadMnemonic
L5:         ifnot op5 'G', L5>
              ifnot op6 '2', L6>            ; FLDLG2  Load log 10 (2) into ST(0)
                Mov op1 00_11011_001, op2 00_1110_1100 | jmp op_op
L6:           BadMnemonic
L5:         ifnot op5 'N', L5>
              ifnot op6 '2', L6>           ; FLDLN2  Load log = (2) into ST(0)
                Mov op1 00_11011_001, op2 00_1110_1101 | jmp op_op
L6:           ;BadMnemonic
L5:         ;Badmnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'N', L2>>
        ifnot op3 'C', L3>
           ifnot op4 'L', L4>
             ifnot op5 'E', L5>
               ifnot op6 'X', L6>                      ; FNCLEX
                  ToOpcode 0DB | LastOpcode 0E2
L6:         ;BadMnemonic
L5:       ;BadMnemonic
L4:     BadMnemonic
L3:      ifnot op3 'I', L3>
           ifnot op4 'N', L4>
             ifnot op5 'I', L5>
               ifnot op6 'T', L6>                      ; FNINIT*
                  ToOpcode 0DB | LastOpcode 0E3
L6:         ;BadMnemonic
L5:       ;BadMnemonic
L4:     BadMnemonic
L3:     ifnot op3 'S', L3>>
          ifnot op4 'A', L4>
            ifnot op5 'V', L5>                  ; FNSAVE  Store FPU Environ. 108 Bytes
              ifnot op6 'E', L6>
                ifnot B$FirstGender MEM_LABEL L7>
                  ifnot B$FirstOperandWbit USO_SIZE L8>
                    Mov op1 0D9, op2 00_111_000 | jmp op_ModRm
L8:               error D$XmarkerPtr
L7:           BadOperand
L6:         ;BadMnemonic
L5:       BadMnemonic
L4:       ifnot op4 'T', L4>>
            ifnot op5 'C', L5>                  ; FNSTCW  ; 'FSTCW'
              ifnot op6 'W', L6>
                ifnot B$FirstGender MEM_LABEL L7>
                  ifnot B$FirstOperandWbit WORD_SIZE L8>
                    dec edi                             ; scratch 066 prefix (no use here)
                    Mov op1 00_11011_001, op2 00_111_000 | jmp op_ModRm
                    ;Mov op1 00_11011_101, op2 00_110_000 | jmp op_ModRm
L8:               BadOperandSize
L7:           BadOperand
L6:         BadMnemonic
L5:         ifnot op5 'S', L5>                  ; FNSTSW
              ifnot op6 'W', L6>
                dec edi ; No need of 066 here.
                ifnot B$FirstGender MEM_LABEL L7>
                  ifnot B$FirstOperandWbit WORD_SIZE L8>
                    Mov op1 0DD, op2 00_111_000 | jmp op_ModRm
L7:             ifnot B$FirstGender GENERAL_REG L7>
                  ifnot B$FirstOperandWbit WORD_SIZE L8>
                    ifnot B$FirstReg REG_AX L7>
                      Mov op1 0DF, op2 0E0 | jmp op_op_P1
L8:               BadOperandSize
L7:           BadOperand
L6:         ;BadMnemonic
L5:       ;BadMnemonic
L4:     ;BadMnemonic
L3:   BadMnemonic
L2:   ifnot op2 'P', L2>
        ifnot op3 'A', L3>
          ifnot op4 'T', L4>
            ifnot op5 'A', L5>
              ifnot op6 'N', L6>            ; FPATAN  Partial Arctangent
                Mov op1 00_11011_001, op2 00_1111_0011 | jmp op_op
L6:           ;BadMnemonic
L5:         ;Badmnemonic
L4:       BadMnemonic
L3:     ifnot op3 'R', L3>
          ifnot op4 'E', L4>
            ifnot op5 'M', L5>
              ifnot op6 '1', L6>            ; FPREM1  Partial Remainder (IEEE)
                Mov op1 00_11011_001, op2 00_1111_0101 | jmp op_op
L6:           ;BadMnemonic
L5:         ;Badmnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'R', L2>
        ifnot op3 'S', L3>
          ifnot op4 'T', L4>
            ifnot op5 'O', L5>
              ifnot op6 'R', L6>            ; FRSTOR  Restore FPU State
                 ifnot B$FirstGender MEM_LABEL L7>
                   ifnot B$FirstOperandWbit USO_SIZE L8>
                     Mov op1 00_11011_101, op2 00_100_000 | jmp op_ModRm ; 180 bytes
L8:                error D$XmarkerPtr
L7:              BadOperand
L6:           ;BadMnemonic
L5:         ;Badmnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'S', L2>>
        ifnot op3 'C', L3>
          ifnot op4 'A', L4>
            ifnot op5 'L', L5>
              ifnot op6 'E', L6>           ; FSCALE  Scale
                Mov op1 0D9, op2 0FD | jmp op_op
L6:           ;BadMnemonic
L5:         ;Badmnemonic
L4:       BadMnemonic
L3:     ifnot op3 'T', L3>
          ifnot op4 'E', L4>
            ifnot op5 'N', L5>
              ifnot op6 'V', L6>            ; FSTENV  Store FPU Environment
                ifnot B$FirstGender MEM_LABEL L7>
                  ifnot B$FirstOperandWbit USO_SIZE L8>
                    Mov op1 00_11011_001, op2 00_110_000 | jmp op_ModRm  ; 28 bytes
L8:               error D$XmarkerPtr
L7:             BadOperand
L6:           ;BadMnemonic
L5:         ;Badmnemonic
L4:       BadMnemonic
L3:     ifnot op3 'U', L3>
          ifnot op4 'B', L4>
            ifnot op5 'R', L5>
              ifnot op6 'P', L6>            ; FSUBRP  Reverse Subtract and Pop
                On B$ParametersNumber <> 2, NoFpAssume
                Mov op1 00_11011_110, op2 0E0 ;00_1110_0_00 |
                jmp op_STreg
L6:           ;BadMnemonic
L5:         ;Badmnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'U', L2>
        ifnot op3 'C', L3>
          ifnot op4 'O', L4>
            ifnot op5 'M', L5>
              ifnot op6 'P', L6>       ; FUCOMP  Unordered Compare Real and Pop
                Mov op1 00_11011_101, op2 00_1110_1_000 | jmp op_STreg
L6:           ifnot op6 'I', L6>       ; FUCOMI  Unorderd Compare Real and Set EFLAGS
                Mov op1 00_11011_011, op2 00_11_101_000 | jmp op_STreg
L6:          ;BadMnemonic
L5:        ;Badmnemonic
L4:      ;BadMnemonic
L3:   BadMnemonic
L2:   ifnot op2 'X', L2>
        ifnot op3 'S', L3>
          ifnot op4 'A', L4>
            ifnot op5 'V', L5>
              ifnot op6 'E', L6>                      ; FXSAVE
                ifnot B$FirstGender MEM_LABEL L7>
                  ifnot B$FirstOperandwbit USO_SIZE L7>
                      Mov al 0F | stosb | Mov op1 0AE, op2 0 | jmp op_ModRm
L7:               error D$XmarkerPtr
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     ;BadMnemonic
L2:   BadMnemonic


 ____________________________________

M7: On op8 > Separators, jmp M8>>

      On op2 = 'C', jmp FCMOVcc       ;  >>>>>>>>>>>>>  Down there

      ifnot op2 'D', L2>
        ifnot op3 'E', L7>
          ifnot op4 'C', L7>
            ifnot op5 'S', L7>
              ifnot op6 'T', L7>
                ifnot op7 'P', L7>         ; FDECSTP  Decrement Stack-Top Pointer
                  Mov op1 00_11011_001, op2 00_1111_0110 | jmp op_op
L7:     BadMnemonic
L2:   ifnot op2 'I', L2>
        ifnot op3 'N', L7>
          ifnot op4 'C', L7>
            ifnot op5 'S', L7>
              ifnot op6 'T', L7>
                ifnot op7 'P', L7>         ; FINCSTP  Increment Stack Pointer
                  Mov op1 00_11011_001, op2 00_1111_0111 | jmp op_op
L7:     BadMnemonic
L2:   ifnot op2 'N', L2>
        ifnot op3 'S', L7>
          ifnot op4 'T', L7>
            ifnot op5 'E', L7>
              ifnot op6 'N', L7>
                ifnot op7 'V', L7>         ; FNSTENV
                  ifnot B$FirstOperandwbit USO_SIZE L8>
                    Mov op1 0D9, op2 00_110_000 | jmp op_ModRm
L8:               error D$XmarkerPtr
L7:     BadMnemonic
L2:   ifnot op2 'R', L2>
        ifnot op3 'N', L7>
          ifnot op4 'D', L7>
            ifnot op5 'I', L7>
              ifnot op6 'N', L7>
                ifnot op7 'T', L7>         ; FRNDINT  Round to Integer
                  Mov op1 00_11011_001, op2 00_1111_1100 | jmp op_op
L7:     BadMnemonic
L2:   ifnot op2 'S', L2>
        ifnot op3 'I', L7>
          ifnot op4 'N', L7>
            ifnot op5 'C', L7>
              ifnot op6 'O', L7>
                ifnot op7 'S', L7>         ; FSINCOS  Sine and Cosine
                  Mov op1 00_11011_001, op2 00_1111_1011 | jmp op_op
L7:     BadMnemonic
L2:   ifnot op2 'U', L2>
        ifnot op3 'C', L3>
          ifnot op4 'O', L4>
            ifnot op5 'M', L5>
              ifnot op6 'P', L6>
                ifnot op7 'P', L7>      ; FUCOMPP  Unordered Compare Real and Pop Twice
                  Mov op1 00_11011_010, op2 00_1110_1001 | jmp op_op
L7:             BadMnemonic
L6:           ifnot op6 'I', L6>
                ifnot op7 'P', L7>  ; FUCOMIP  Unorderd Compare Real, Set EFLAGS, and Pop
                  Mov op1 00_11011_111, op2 00_11_101_000 | jmp op_STreg
L7:             ;BadMnemnoic
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       ;BadMnemnonic
L3:     BadMnemonic
L2:   ifnot op2 'X', L2>
        ifnot op3 'R', L3>
          ifnot op4 'S', L7>
            ifnot op5 'T', L7>
              ifnot op6 'O', L7>
                ifnot op7 'R', L7>       ; FXRSTOR
                  ifnot B$FirstGender MEM_LABEL L8>
                     ifnot B$FirstOperandwbit USO_SIZE L8>
                         ToOpcode 0F | Mov op1 0AE, op2 00_001_000 | jmp op_ModRm
L8:                  error D$XmarkerPtr
L7:     BadMnemonic
L3: ifnot op3 'T', L7>
          ifnot op4 'R', L7>
            ifnot op5 'A', L7>
              ifnot op6 'C', L7>
                ifnot op7 'T', L7>       ; FXTRACT  Extract Exponent and Significand
                  Mov op1 00_11011_001, op2 00_1111_0100 | jmp op_op
L7:     BadMnemonic
L2:   ifnot op2 'Y', L2>
        ifnot op3 'L', L7>
          ifnot op4 '2', L7>
            ifnot op5 'X', L7>
              ifnot op6 'P', L7>
                ifnot op7 '1', L7>     ; FYL2XP1  ST(1) ´ log 2 (ST(0) + 1.0)
                  Mov op1 00_11011_001, op2 00_1111_1001 | jmp op_op
L7:     ;BadMnemonic
L2:   ;BadMnemonic

M8: On D$esi = 'FCMO', jmp FCMOVcc
    BadMnemonic

 ______________________________________________________________________________________

FCMOVcc:                       ; Conditional Move on EFLAG
      ifnot op3 'M', L8>>
        ifnot op4 'O', L8>>
          ifnot op5 'V', L8>>
            On op7 > Separators, jmp L2>
              ifnot op6 'E', L1>
                Mov op1 00_11011_010, op2 00_11_001_000 | jmp op_STreg  ; e
L1:           ifnot op6 'B', L1>
                Mov op1 00_11011_010, op2 00_11_000_000 | jmp op_STreg  ; b
L1:           ifnot op6 'U', L1>
                Mov op1 00_11011_010, op2 00_11_011_000 | jmp op_STreg  ; u
L1:           ifnot op6 'A', L7>>
E0:             Mov op1 00_11011_011, op2 00_11_010_000 | jmp op_STreg  ; a nbe
L2:         On op8 > Separators, jmp L3>
              ifnot op6 'N', L4>
                ifnot op7 'E', L5>
Z0:               Mov op1 00_11011_011, op2 00_11_001_000 | jmp op_STreg ; <> nz
L5:             ifnot op7 'A', L5>
B0:               Mov op1 00_11011_010, op2 00_11_010_000 | jmp op_STreg ; na be
L5:             ifnot op7 'B', L5>
A0:               Mov op1 00_11011_011, op2 00_11_000_000 | jmp op_STreg ; nb ae
L5:             ifnot op7 'U', L5>
                  Mov op1 00_11011_011, op2 00_11_011_000 | jmp op_STreg ; nu
L5:             ifnot op7 'Z', L7>
                  jmp Z0<
L4:           ifnot op7 'E', L7>
                ifnot op6 'B', L5>
                  jmp B0<
L5:             ifnot op6 'A', L7>
                  jmp A0<
L3:         On B$esi+9 > Separators, jmp L7>
              ifnot op6 'N', L7>
                ifnot op7 'B', L7>
                  ifnot op8 'E', L7>
                    jmp E0<<
L7:    error D$BadFPUcondPtr
L8:  BadMnemonic

 _________________________________________________________________________________________
 _________________________________________________________________________________________
;;
 End codage control and write routines. Jump from 'Encode' > RET > return to 'EncodeLines'

 'imm' and 'dis' are written after by 'EncodeLine'

 all the '......_P2' routines are for bit instruction that are two parameters when
 written in mnemonics, but only one when written in opCode. exemple:
                             shl eax, 1
 the immediate 1 doesn't appear in code flow but is given by the code instruction itself.
;;
 ___________________________________________________________________________________________

; macros and subs used down there:

[ToOpcode | Mov B$edi #1 | inc edi | #+1]

[LastOpcode | Mov B$edi #1 | inc edi | ret]       ; this RET is the true Encode job return

Params:
  On B$wBitDisagree = &TRUE,  error D$MixTypePtr
ParamsAny:
  On B$ParametersNumber < cl,  Error D$NotEnoughPtr
  On B$ParametersNumber > cl,  Error D$TooMuchPtr
ret


[Parms | Mov cl, #1 | Call Params]

[ParmsAny | Mov cl, #1 | Call ParamsAny]

Xparams:                                         ; used by for MOVSX / MOVZX
    Call ParamsAny

    cmp B$FirstOperandWbit WORD_SIZE | jne L8>
      ToOpcode 066
      On B$SecondOperandWbit = WORD_SIZE error D$MixTypePtr

L8: On B$FirstOperandWbit = BYTE_SIZE error D$MixTypePtr
    On B$SecondOperandWbit = DWORD_SIZE error D$MixTypePtr
    Mov dl B$SecondOperandWbit | and dl 1 | Mov B$wBit dl
    ret

[Xparms | Mov cl, #1 | Call Xparams]

im8Size:
    On B$ImmInside = &False, BadOperand
    On D$imm32 > 0FF,  error D$OverBytePtr
    Mov B$TrueSize BYTE_SIZE     ; for 'StoreImm' in case of bigger sized first parameter
  ret

[imm8Size | Call im8Size]

im16Size:
    On D$imm32 >= 010000,  error D$OverWordPtr
    Mov B$TrueSize WORD_SIZE
  ret

[imm16Size | Call im16Size]

ds8Size:
    On D$dis32 >= 0100,  error D$OverBytePtr
    cmp B$LocalSize JMP_DOWN_LONG | je L1>
    cmp B$LocalSize JMP_UP_LONG | jne L2>
L1:   error D$LongDisPtr
L2: Mov B$LongRelative &FALSE,  D$Relative RelativeFlag
    ret

[dis8Size | Call ds8Size]

GPrg1:                                    ; test a reg to be a general purpose
  On B$FirstReg > 00_0111,  error D$GPregisterPtr
  On B$FirstRegGender > GENERAL_REG error D$GPregisterPtr
ret

GPrg2:
  On B$SecondReg > 00_0111,  error D$GPregisterPtr
  On B$SecondRegGender > GENERAL_REG error D$GPregisterPtr
ret

GPrg1_2:
  Call GPrg1
  Call GPrg2
ret

[GPreg1 | Call GPrg1]     [GPreg2 | Call GPrg2]     [GPreg1_2 | Call GPrg1_2]

; The OpCodes concerned by Sign Extensions are: adc, add, and, cmp, imul, or, Push, sbb,
; sub, xor.

sIm:
    cmp B$immInside &TRUE | jne L9>
    Push eax
        Mov eax D$imm32
        If eax <= 07F
L1:         Mov B$sBit 0010
        Else
            and eax 0_FFFF_FF80
            On eax = 0_FFFF_FF80, Mov B$sBit 0010
        End_If

        On B$sBit = 0010, Call CkeckPossibleImmLabel
    Pop eax
    If B$sBit = 0010
        Mov B$TrueSize BYTE_SIZE | and D$imm32 0FF | Mov B$immSign &FALSE
      ; &FALSE, because we will not check the dWord High Bit in StoreImm
    End_If
L9: ret


; This is a simplified version of 'First / SecondParameterLabel'. In case of something
; remaining in the line, we abort the sBit encodage.

CkeckPossibleImmLabel:
    Push esi
        Mov esi D$LineStart
L0:     lodsb | cmp al Space | jne L0<
L0:     lodsb
            cmp al EOI | je L9>>
            cmp al meEOI | je L9>>   ; and not "cmp al EOI | JBE L9>>" because zeros inside...
            cmp al 'A' | jb L0<
            cmp al, 'Z' | ja L0<
            cmp al 'E' | jne L1>
            Push eax
                Call IsItAnEreg              ; usefull only in case of mem adressing
            Pop eax
            IfEregNotFound L1>
            add esi 2 | jmp L0<
L1:     Mov B$sBit 0
L9: Pop esi
ret


[signImm | Call sIm]


STrg12: On B$SecondRegGender <> REG_FPU error D$STwishedPtr
STrg1: On B$FirstRegGender <> REG_FPU error D$STwishedPtr  | ret

[STregs1_2 | Call STrg12]

[StReg1 | Call STrg1]
 ________________________________________________________________________________________
 ________________________________________________________________________________________
;;
 FPU job:

 each time it is possible, syntax is free. Good and equivalent, for exemple:

                FDIV = FDIV ST1 = FDIV ST0 ST1
                       FDIV ST2 = FDIV ST0 ST2
;;

op_STregP1:
    On B$ParametersNumber > 1, error D$TooMuchPtr
    ifnot B$ParametersNumber 0,  L1>
      ToOpcode op1 | LastOpcode op2
op_STreg:
    ifnot B$ParametersNumber 0,  L1>
      ToOpcode op1 | inc op2 | LastOpcode op2
L1: ifnot B$ParametersNumber 1,  L2>
      STreg1 | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2
L2: ifnot B$ParametersNumber 2,  L3>
 ;    ;;; On B$FirstReg <> REG_ST0 error ST0wished
 ;     On B$SecondReg <> REG_ST0 error ST0wished
 ;   ;;STregs1_2 | ToOpcode op1 | or op2 B$SecondReg | LastOpcode op2
 ;     STregs1_2 | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2

 ; Last choice > more flexibility:

        STregs1_2 | ToOpcode op1
        If B$FirstReg = REG_ST0
            or op2 B$SecondReg
        Else_If B$SecondReg = REG_ST0
            or op2 B$FirstReg
        Else
            error D$ST0wishedPtr
        End_If

        LastOpcode op2

L3: Error D$TooMuchPtr

d_STreg:
    ifnot B$ParametersNumber 0,  L1>
      ToOpcode op1 | inc op2 | LastOpcode op2
L1: ifnot B$ParametersNumber 1,  L2>
      STreg1 | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2
L2: ifnot B$ParametersNumber 2, L8>
      STregs1_2 | cmp B$FirstReg REG_ST0 | jne L3>
        or op2 B$SecondReg | ToOpcode op1 | LastOpcode op2
L3:   On B$SecondReg <> REG_ST0 error D$ST0wishedPtr
        or op1 00_100 | ToOpcode op1                        ; 00_100 = direction bit
        or op2 B$FirstReg | LastOpcode op2
L8: Error D$TooMuchPtr

; for FDIV / FDIVR // FSUB / FSUBR, R bit (second byte: 0000x000) XORed for reversed forms:
; R bit set by caller (jumper) to 0 for FDIV / FSUB,  to 1 for FDIVR / FSUBR

d_RSTreg:
    ifnot B$ParametersNumber 0,  L1>
      ToOpcode op1 | inc op2 | LastOpcode op2
L1: ifnot B$ParametersNumber 1,  L2>
      STreg1 | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2
L2: ifnot B$ParametersNumber 2,  L8<
    STregs1_2 | cmp B$FirstReg REG_ST0 | jne L1>
L0:   or op2 B$SecondReg | ToOpcode op1 | LastOpcode op2
L1: On B$SecondReg <> REG_ST0 error D$ST0wishedPtr
      or op1 00_0100 | ToOpcode op1                          ; 00_0100 = direction bit
      xor op2 00_1000 | or op2 B$FirstReg | LastOpcode op2   ; 00_1000 = Reverse bit

 ________________________________________________________________________________________
 ________________________________________________________________________________________
;;
 MMX job:

 As MMX coding is much more regular than it is for interger, less work is done in the
 'text routing' level and more work is done here. op1 is in fact the second opcode
 (00_1111 is always store at first here). All cases are covered by 4 routines, mm4,
 mm2, gg2, gg3.

 'gg_value' routine inputs granularity (Byte, Word, Dword or Qword) as a letter
 (B, W, D or Q) set in CL reg ( validity test done by mnemonics parser). Instead of
 4 different cases holding, we add 2 to ascii value and keep last two bits. Trick:

 cl = 'B' = 00_01000010 + 0010 = 00_01000100 >>> and 0011 >>> 00_00  >>>  gg_Byte
 cl = 'W' = 00_01010111 + 0010 = 00_01011001 >>> and 0011 >>> 00_01  >>>  gg_Word
 cl = 'D' = 00_01000100 + 0010 = 00_01000110 >>> and 0011 >>> 00_10  >>>  gg_dWord
 cl = 'Q' = 00_01010011 + 0010 = 00_01010011 >>> and 0011 >>> 00_11  >>>  gg_qWord
;;

[gg_value | add cl 2 | and cl 00_11 | or op1 cl]

;;
 Exemple for mm4:      MOVD - Move doubleword N N Y N

   reg to mmreg    00001111:01101110: 11 mmxreg1 reg2   ; movd MM0 eax
   reg from mmxreg 00001111:01111110: 11 mmxreg2 reg1   ; movd eax MM0
   mem to mmxreg   00001111:01101110: mod mmxreg1 r/m   ; movd MM0 D$val
   mem from mmxreg 00001111:01111110: mod mmxreg2 r/m   ; movd D$val MM0

 2 mnemonics only for mm4. In both cases op1 (true second opcode) is the same for the
 4 cases, but with 00_10000 add in cases 2 and 4.
;;

mmFour: ParmsAny 2 | ToOpcode 00_1111
     cmp B$Operands REG_TO_REG | jne L1>
      cmp B$FirstRegGender REG_MMX | jne L2>
        ToOpcode op1                                                 ; case 1
        GPreg2 | Mov op1 B$FirstReg | shl op1 3 | or op1 B$SecondReg
        or op1 00_11000000 | LastOpcode op1
L2:   cmp B$SecondRegGender REG_MMX | jne L2>
        or op1 00_10000 | toOpcode op1                               ; case 2
        GPreg1 | Mov op1 B$SecondReg | shl op1 3 | or op1 B$FirstReg
        or op1 00_11000000 | LastOpcode op1
L2:   BadOperand
L1: cmp B$Operands MEM_TO_REG | jne L1>
      ToOpcode op1 | Mov op1 B$ModBits | or op1 B$RmBits             ; case 3
      On B$FirstRegGender <> REG_MMX error D$OperandsTypesPtr
      Mov op2 B$FirstReg | shl op2 3 | or op1 op2 | LastOpcode op1
L1: cmp B$Operands REG_TO_MEM | jne L1>
      or op1 00_10000 | ToOpcode op1                                 ; case 4
      Mov op1 B$ModBits | or op1 B$RmBits
      On B$SecondRegGender <> REG_MMX error D$OperandsTypesPtr
      Mov op2 B$SecondReg | shl op2 3 | or op1 op2 | LastOpcode op1
L1: BadOperand



; Exemple for gg2:       PADD - Add with wrap-around Y Y Y N
;   mmxreg2 to mmxreg1 0000 1111: 111111gg: 11 mmxreg1 mmxreg2    ; padd MM0 MM1
;   memory to mmxreg   0000 1111: 111111gg: mod mmxreg r/m        ; padd MM0 B$Val

gg2: gg_Value    ; >>> mm2:

    .If B$FirstRegGender = REG_XMM
        ToOpcode 066 | Mov B$FirstRegGender REG_MMX
        If B$SecondRegGender = REG_XMM
            Mov B$SecondRegGender REG_MMX
        End_If
    .End_If

; Exemple for mm2:       PAND - Bitwise And N N N Y
;   mmxreg2 to mmxreg1 0000 1111:11011011: 11 mmxreg1 mmxreg2   ; pand MM0 MM1
;   memory to mmxreg   0000 1111:11011011: mod mmxreg r/m       ; pand MM0 Q$Val

mmTwo:

ParmsAny 2 | ToOpcode 00_1111, op1
L0: cmp B$Operands REG_TO_REG | jne L1>
      cmp B$FirstRegGender  REG_MMX | jne L8>
      cmp B$SecondRegGender REG_MMX | jne L8>
        Mov op1 B$FirstReg | shl op1 3 | or op1 B$SecondReg
        or op1 00_11000000 | LastOpcode op1
L1: Mov op1 B$ModBits | or op1 B$RmBits
    cmp B$Operands MEM_TO_REG | jne L8>
      cmp B$FirstRegGender REG_MMX | jne L8>
      Mov op2 B$FirstReg | shl op2 3 | or op1 op2 | LastOpcode op1
L8: BadOperand

mmTwoImm8:
    ParmsAny 3 | ToOpcode 00_1111, op1
    On B$immInside = &FALSE, error D$EndingImmPtr
    On D$imm32 > 0FF, BadOperandSize
        Mov B$TrueSize BYTE_SIZE                 ; to ajust imm size to 8 bits storage
        jmp L0<<

mmOne:
    ParmsAny 2
    cmp B$Operands REG_TO_REG | jne L9>
        cmp B$FirstRegGender REG_MMX | jne L9>
            cmp B$SecondRegGender REG_MMX | jne L9>
                ToOpcode 0F, op1
                Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
                LastOpcode al

L9: BadOperand


; Used only with movntq and one of movq:

MMregToMem:
    ParmsAny 2
    cmp B$Operands REG_TO_MEM | jne L9>
        cmp B$SecondRegGender REG_MMX | jne L9>
            cmp B$FirstOperandWbit USO_SIZE | je L7>
            cmp B$FirstOperandWbit QWORD_SIZE | jne L8>
L7:             ToOpcode 0F, op1
                Mov al B$SecondReg | shl al 3 | or al B$ModBits | or al B$RmBits
                LastOpcode al
L8: BadOperandSize
L9: BadOperand

;;
 Exemple for gg3:       PSLL  - Packed shift left logical N Y Y Y
   mmxreg1 by mmxreg2  00001111:111100gg: 11 mmxreg1 mmxreg2        ; psll MM0 MM1
   mmxreg by memory    00001111:111100gg: mod mmxreg r/m            ; psll MM0 D$val
   mmxreg by immediate 00001111:011100gg: 11 110 mmxreg: imm8 data  ; psll MM1 28
                                             ^^^ /n is here (op2)
 3 mnemonic for gg3. For all, case 1 and 2 have the same op1 code.
 For all, case 3 is 011100gg. (070 + gg)
;;

gg3:
    .If B$FirstRegGender = REG_XMM
        ToOpcode 066 | Mov B$FirstRegGender REG_MMX
        If B$SecondRegGender = REG_XMM
            Mov B$SecondRegGender REG_MMX
        End_If
    .End_If

    Push ecx
        ParmsAny 2 | ToOpcode 00_1111
    Pop ecx
    cmp B$Operands REG_TO_REG | jne L1>
      cmp B$FirstRegGender  REG_MMX | jne L8>>
      cmp B$SecondRegGender REG_MMX | jne L8>>
        gg_Value | ToOpcode op1                                 ; case 1
        Mov op1 B$FirstReg | shl op1 3 | or op1 B$SecondReg
        or op1 00_11000000 | LastOpcode op1
L1: cmp B$Operands MEM_TO_REG | jne L1>
      cmp B$FirstRegGender REG_MMX | jne L8>
        gg_Value | ToOpcode op1                                 ; case 2
        Mov op1 B$ModBits | or op1 B$RmBits
        Mov op2 B$FirstReg | shl op2 3 | or op1 op2 | LastOpcode op1
L1: cmp B$Operands IMM_TO_REG | jne L8>
      cmp B$FirstRegGender REG_MMX | jne L8>
      ; xor op1 00_010_000_000 (???!!!...)
       Mov op1 070 | gg_Value | ToOpcode op1         ; case 3
        imm8Size | or op2 B$FirstReg | LastOpcode op2
L8: BadOperand
____________________________________________________________________________________________
____________________________________________________________________________________________

; XMM job:

; example: ADDPS XMM1 XMM2
;          ADDPS XMM5 X$MyPackedData   ; (X$ or O$) (Sib allowed)

XMMXMM:
    ParmsAny 2
    ToOpcode 0F, op1
    cmp B$Operands REG_TO_REG | jne L8>
        cmp B$FirstRegGender  REG_XMM | jne L8>>
        cmp B$SecondRegGender REG_XMM | jne L8>>
            Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al
L8: BadOperand


XmmMemXmmImm7:
ParmsAny 3
    On B$immInside = &FALSE, error D$EndingImmPtr
    On D$imm32 > 00111, BadOperandSize
        Mov B$TrueSize BYTE_SIZE                 ; to ajust imm size to 8 bits storage
        jmp L0>>


XmmMemXmmImm8:
ParmsAny 3
    On B$immInside = &FALSE, error D$EndingImmPtr
    On D$imm32 > 0FF, BadOperandSize
        Mov B$TrueSize BYTE_SIZE                 ; to ajust imm size to 8 bits storage
        jmp L0>

XmmMemXmmImm3:
ParmsAny 3
    On B$immInside = &FALSE, error D$EndingImmPtr
    On D$imm32 > 0011, BadOperandSize
        Mov B$TrueSize BYTE_SIZE                 ; to ajust imm size to 8 bits storage
        jmp L0>

XmmMemXmmImmFF:
ParmsAny 3
    On B$immInside = &FALSE, error D$EndingImmPtr
        Mov B$TrueSize BYTE_SIZE                 ; to ajust imm size to 8 bits storage
        jmp L0>


;Xmmgg2:  gg_Value >>> now gg2 extended

XMMmemXMM:
    ParmsAny 2
L0: ToOpcode 0F, op1
    cmp B$Operands REG_TO_REG | jne L2>
        cmp B$FirstRegGender  REG_XMM | jne L8>>
        cmp B$SecondRegGender REG_XMM | jne L8>>
            Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MEM_TO_REG | jne L8>
        cmp B$SecondOperandwbit USO_SIZE | je L1>
        cmp B$SecondOperandwbit OWORD_SIZE | jne L7>
L1:     cmp B$FirstRegGender REG_XMM | jne L8>>
            Mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


MMXmemXMM:
    ParmsAny 2
L0: ToOpcode 0F, op1
    cmp B$Operands REG_TO_REG | jne L2>
        cmp B$FirstRegGender  REG_MMX | jne L8>>
        cmp B$SecondRegGender REG_XMM | jne L8>>
            Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MEM_TO_REG | jne L8>
        cmp B$SecondOperandwbit USO_SIZE | je L1>
        cmp B$SecondOperandwbit OWORD_SIZE | jne L7>
L1:     cmp B$FirstRegGender REG_MMX | jne L8>>
            Mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


mmXmm:
    ParmsAny 2
L0: ToOpcode 0F, op1
    cmp B$Operands REG_TO_REG | jne L8>
        cmp B$FirstRegGender  REG_MMX | jne L8>>
        cmp B$SecondRegGender REG_XMM | jne L8>>
            Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


Xmmmm:
    ParmsAny 2
L0: ToOpcode 0F, op1
    cmp B$Operands REG_TO_REG | jne L8>
        cmp B$FirstRegGender  REG_XMM | jne L8>>
        cmp B$SecondRegGender REG_MMX | jne L8>>
            Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


; Example CVTSI2SS xmm1 eax
;         CVTSI2SS xmm D$memory

DwordToLowXMM:
    ParmsAny 2
    ToOpcode 00_11110011, 001111, op1
    cmp B$Operands REG_TO_REG | jne L2>
        cmp B$FirstRegGender  REG_XMM | jne L8>>
        cmp B$SecondRegGender GENERAL_REG | jne L8>>
            Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MEM_TO_REG | jne L8>
        cmp B$SecondOperandwbit DWORD_SIZE | jne L7>
        cmp B$FirstRegGender REG_XMM | jne L8>>
            Mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


DwordToLowXMMWithF2:
    ParmsAny 2
    ToOpcode 00_11110010, 001111, op1
    cmp B$Operands REG_TO_REG | jne L2>
        cmp B$FirstRegGender  REG_XMM | jne L8>>
        cmp B$SecondRegGender GENERAL_REG | jne L8>>
            Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MEM_TO_REG | jne L8>
        cmp B$SecondOperandwbit DWORD_SIZE | jne L7>
        cmp B$FirstRegGender REG_XMM | jne L8>>
            Mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


; Example: CVTTPS2SI ebx xmm3
;          CVTTPS2SI edx O$memory

LowXMMtoDword:
    ParmsAny 2
    ToOpcode 00_11110011, 001111, op1
    cmp B$Operands REG_TO_REG | jne L2>
        cmp B$FirstRegGender GENERAL_REG | jne L8>>
        cmp B$SecondRegGender REG_XMM | jne L8>>
            Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MEM_TO_REG | jne L8>
        cmp B$SecondOperandwbit OWORD_SIZE | je L1>
        cmp B$SecondOperandwbit USO_SIZE | jne L7>
L1:     cmp B$FirstRegGender GENERAL_REG | jne L8>>
            Mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


LowXMMtoDwordWithF2:
    ParmsAny 2
    ToOpcode 00_11110010, 001111, op1
    cmp B$Operands REG_TO_REG | jne L2>
        cmp B$FirstRegGender  GENERAL_REG | jne L8>>
        cmp B$SecondRegGender REG_XMM | jne L8>>
            Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MEM_TO_REG | jne L8>
        cmp B$SecondOperandwbit OWORD_SIZE | je L1>
        cmp B$SecondOperandwbit USO_SIZE | jne L7>
L1:     cmp B$FirstRegGender GENERAL_REG | jne L8>>
            Mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


XMMmemXMMmem:
    ParmsAny 2
    ToOpcode 0F
    cmp B$Operands REG_TO_REG | jne L2>
        cmp B$FirstRegGender  REG_XMM | jne L8>>
        cmp B$SecondRegGender REG_XMM | jne L8>>
            ToOpcode op1
            Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MEM_TO_REG | jne L2>
        cmp B$SecondOperandwbit USO_SIZE | je L1>
        cmp B$SecondOperandwbit OWORD_SIZE | jne L7>
L1:     cmp B$FirstRegGender REG_XMM | jne L8>>
            ToOpcode op1
            Mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L2: cmp B$Operands REG_TO_MEM | jne L8>
        cmp B$FirstOperandwbit USO_SIZE | je L1>
        cmp B$FirstOperandwbit OWORD_SIZE | jne L7>
L1:     cmp B$SecondRegGender REG_XMM | jne L8>>
            or op1 1 | ToOpcode op1
            Mov al B$SecondReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


; Special for MOVSS, that deals with one F$ mem:

XMMmem32XMMmem32:
    ParmsAny 2
    ToOpcode 0F
    cmp B$Operands REG_TO_REG | jne L2>
        cmp B$FirstRegGender  REG_XMM | jne L8>>
        cmp B$SecondRegGender REG_XMM | jne L8>>
            ToOpcode op1
            Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MEM_TO_REG | jne L2>
        cmp B$SecondOperandwbit DWORD_SIZE | je L1>
        cmp B$SecondOperandwbit USO_SIZE | je L1>
        cmp B$SecondOperandwbit OWORD_SIZE | jne L7>
L1:     cmp B$FirstRegGender REG_XMM | jne L8>>
            ToOpcode op1
            Mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L2: cmp B$Operands REG_TO_MEM | jne L8>
        cmp B$FirstOperandwbit DWORD_SIZE | je L1>
        cmp B$FirstOperandwbit USO_SIZE | je L1>
        cmp B$FirstOperandwbit OWORD_SIZE | jne L7>
L1:     cmp B$SecondRegGender REG_XMM | jne L8>>
            or op1 1 | ToOpcode op1
            Mov al B$SecondReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


; Same as uper but with "xor op1 0010000" (instead of "or 1").
; For MOVQ/MOVDQA/MOVDQU only.

MovqXMMmemXMMmem:
    ParmsAny 2
    ToOpcode 0F
    cmp B$Operands REG_TO_REG | jne L2>
        cmp B$FirstRegGender  REG_XMM | jne L8>>
        cmp B$SecondRegGender REG_XMM | jne L8>>
            ToOpcode op1
            Mov al B$FirstReg | shl al 3 | or al 00_11_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MEM_TO_REG | jne L2>
        cmp B$SecondOperandwbit USO_SIZE | je L1>
        cmp B$SecondOperandwbit QWORD_SIZE | jne L7>
L1:     cmp B$FirstRegGender REG_XMM | jne L8>>
            ToOpcode op1
            Mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L2: cmp B$Operands REG_TO_MEM | jne L8>
        cmp B$FirstOperandwbit USO_SIZE | je L1>
        cmp B$FirstOperandwbit QWORD_SIZE | jne L7>
L1:     cmp B$SecondRegGender REG_XMM | jne L8>>
            xor op1 0010000 | ToOpcode op1
            Mov al B$SecondReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


XMMtoFromMem:
    ParmsAny 2
    ToOpcode 0F

    cmp B$Operands MEM_TO_REG | jne L2>
        cmp B$SecondOperandwbit USO_SIZE | je L1>
        cmp B$SecondOperandwbit OWORD_SIZE | jne L7>
L1:     cmp B$FirstRegGender REG_XMM | jne L8>>
            ToOpcode op1
            Mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L2: cmp B$Operands REG_TO_MEM | jne L8>
        cmp B$FirstOperandwbit USO_SIZE | je L1>
        cmp B$FirstOperandwbit OWORD_SIZE | jne L7>
L1:     cmp B$SecondRegGender REG_XMM | jne L8>
            or op1 1 | ToOpcode op1
            Mov al B$SecondReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


XMMtoMem:
    ParmsAny 2
    ToOpcode 0F | jmp L2<
;;
 Exemple for Xmm4:      MOVD - Move doubleword N N Y N

   reg to Xmmreg    0000 1111:01101110: 11 Xmmreg1 reg2   ; movd XMM0 eax
   reg from Xmmxreg 0000 1111:01111110: 11 Xmmreg2 reg1   ; movd eax XMM0
   mem to Xmmxreg   0000 1111:01101110: mod Xmmreg1 r/m   ; movd XMM0 D$val
   mem from Xmmxreg 0000 1111:01111110: mod Xmmreg2 r/m   ; movd D$val XMM0

 2 mnemonics only for mm4. In both cases op1 (true second opcode) is the same for the
 4 cases, but with 00_10000 add in cases 2 and 4.

 This is exactely the same encoding as for mmFour, but with an added 066 prefix. So:
;;

XmmFour:
    ToOpcode 066
    cmp B$FirstRegGender REG_XMM | jne L1>
        Mov B$FirstRegGender REG_MMX | jmp mmFour
L1: cmp B$SecondRegGender REG_XMM | jne L1>
        Mov B$SecondRegGender REG_MMX | jmp mmFour
L1: BadOperand


____________________________________
; These Routines are for 066 prefixed for SSE SIMD Integer Instructions.

; Example: PAVGB mm1,  mm2/m64    (0F E0 /r)
;          PAVGB xmm1, xmm2/m128  (66 0F E0, /r)

OQregMemToReg:
    ParmsAny 2
    ..If B$Operands = REG_TO_REG
        .If B$FirstRegGender = REG_MMX
            If B$SecondRegGender = REG_MMX
                ToOpcode 0F, op1
                Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
                LastOpcode al
            End_If
            BadOperand

        .Else_If B$FirstRegGender = REG_XMM
            If B$SecondRegGender = REG_XMM
                ToOpcode 066, 0F, op1
                Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
                LastOpcode al
            End_If
            BadOperand

        .End_If
        BadOperand

    ..Else_If B$Operands = MEM_TO_REG
        On B$SecondOperandwbit = USO_SIZE Mov B$SecondOperandwbit OWORD_SIZE
        .If B$FirstRegGender = REG_MMX
            If B$SecondOperandwbit = QWORD_SIZE
                ToOpcode 0F, op1
                Mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
                LastOpcode al
            End_If
            BadOperandSize
        .Else_If B$FirstRegGender = REG_XMM
            If B$SecondOperandwbit = OWORD_SIZE
                ToOpcode 066, 0F, op1
                Mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
                LastOpcode al
            End_If
            BadOperandSize

        .End_If
        BadOperand
    ..End_If
    BadOperand

;;
 Example: PEXTRW r32,  mm, imm8  (0F C5 /r ib)
          PEXTRW r32, xmm, imm8  (66 0F C5 /r ib) (Actually used only for PEXTRW)

 Note: Encodage of Registers fields are given in reverse of usual order in Intel Doc.
 Don't know if it is an error or not. I set here the record as given > to be controled.
 (same for PINSRW).
 
 'Werewolf' says it should be reversed. Therefore the replacement.
;;

OQregRegImm8:
    ParmsAny 3
    On B$immInside = &FALSE, error D$EndingImmPtr
    cmp B$Operands REG_TO_REG | jne L9>
        cmp B$FirstRegGender GENERAL_REG | jne L9>
            Mov B$TrueSize BYTE_SIZE                 ; to ajust imm size to 8 bits storage
            cmp B$SecondRegGender REG_XMM | jne L1>
                cmp D$Imm32, 00111 | ja L8>
                ToOpcode 066 | jmp L2>
L1:         cmp B$SecondRegGender REG_MMX | jne L9>
                cmp D$Imm32, 0011 | ja L8>
L2:                 ToOpcode 0F, op1
                    ;Mov al B$SecondReg | shl al 3 | or al 0011_000_000 | or al B$FirstReg ;!!!!
                    Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
                    LastOpcode al

L8: BadOperandSize
L9: BadOperand


; Example: PINSRW  mm, r32/mem16, imm8 ; <<<< this one in reserse order too !!!!!!!!!!!!!!!!
;          PINSRW xmm, r32/mem16, imm8
;
; in all case mm (xmm) apear as regBits.

OQregMemImm8:
    ParmsAny 3
    On B$immInside = &FALSE, error D$EndingImmPtr
    Mov B$TrueSize BYTE_SIZE                 ; to ajust imm size to 8 bits storage
    ..If B$Operands = REG_TO_REG
        .If B$FirstRegGender = REG_MMX
            If B$SecondRegGender = GENERAL_REG
                cmp D$Imm32, 0011 | ja L8>>
                ToOpcode 0F, op1
                Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
                LastOpcode al
            End_If
            BadOperand

        .Else_If B$FirstRegGender = REG_XMM
            If B$SecondRegGender = GENERAL_REG
                cmp D$Imm32, 00111 | ja L8>>
                ToOpcode 066, 0F, op1
                Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
                LastOpcode al
            End_If
            BadOperand

        .End_If
        BadOperand


    ..Else_If B$Operands = MEM_TO_REG
        cmp B$SecondOperandwbit WORD_SIZE | jne L8>>
        .If B$FirstRegGender = REG_MMX
                cmp D$Imm32, 0011 | ja L8>>
                ToOpcode 0F, op1
                Mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
                LastOpcode al
        .Else_If B$FirstRegGender = REG_XMM
                cmp D$Imm32, 00111 | ja L8>>
                ToOpcode 066, 0F, op1
                Mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
                LastOpcode al
        .End_If
        BadOperand
    ..End_If

    BadOperand
L8: BadOperandSize


; Example: MOVMSKB reg32  REG_MMX
;          MOVMSKB reg32 REG_XMM   ; here also dest at last

OQReg32Reg:
    ParmsAny 2
    cmp B$Operands REG_TO_REG | jne L9>
        cmp B$FirstRegGender GENERAL_REG | jne L9>
            cmp B$SecondRegGender REG_XMM | jne L1>
                ToOpcode 066 | jmp L2>
L1:         cmp B$SecondRegGender REG_MMX | jne L9>
L2:             ToOpcode 0F, op1
                Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$secondReg
                LastOpcode al

L9: BadOperand

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
 3D Now: out of FEMMS and PREFETCH/W, all 3D Now instructions aply on

 mmReg1, mmReg2/mm64

 and all start with 0F 0F, and end with the true opcode (suffix) written at last by
 EncodeLines
;;

[mm3Dsuffix: D$ ?]

mm3D:
    ParmsAny 2 | ToOpcode 0F, 0F | Mov B$mm3Dsuffix op1
    cmp B$FirstRegGender REG_MMX | jne L8>>
    cmp B$Operands REG_TO_REG | jne L1>
        cmp B$SecondRegGender REG_MMX | jne L8>>
            Mov op1 B$FirstReg | shl op1 3 | or op1 B$SecondReg
            or op1 00_11_000_000 | LastOpcode op1
L1: cmp B$Operands MEM_TO_REG | jne L8>
        On B$SecondOperandwBit <> QWORD_SIZE error D$Mem3DPtr
        Mov op1 B$FirstReg | shl op1 3 | or op1 B$ModBits | or op1 B$RmBits | LastOpcode op1
L8: BadOperand

 ________________________________________________________________________________________


op: Parms 0 | LastOpcode op1

op_P1: Parms 1 | LastOpcode op1

op_imm8: Parms 1 | imm8Size | LastOpcode op1

op_imm16: Parms 1 | imm16Size | LastOpcode op1

reg_in_op_imm: Parms 2 | GPreg1 | or op1 B$FirstReg | LastOpcode op1 ; for Mov reg imm (alternate)

reg1_in_op: GPreg1 | or op1 B$FirstReg                       ; for dec / inc
op_dis: Parms 1 | lastOpcode op1

op_dis8: Parms 1 | dis8Size | LastOpcode op1

op_reg1: Parms 1 | GPreg1 | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2

  ; This is only for Push/Pop sreg when reg is FS or GS. We overwrite the no use 066h
  ; previously written because of size:
op_sreg3: Parms 1 | dec edi | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2

op_modRm: Parms 1 | ToOpcode op1 | or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

op_modRm_P2: Parms 2 | ToOpcode op1 | or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

op_reg2reg1:
  Parms 2 | GPreg1_2 | ToOpcode op1
  Mov op1 B$SecondReg | shl op1 3 | or op1 B$FirstReg | or op2 op1 | LastOpcode op2

op_w_modReg1Rm:
  Parms 2 | GPreg1 | ToOpcode op1
  or op2 B$wBit | ToOpcode op2
  Mov op3 B$FirstReg | shl op3 3 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_w_modReg1RmX:
  XParms 2 | GPreg1 | ToOpcode op1
  or op2 B$wBit | ToOpcode op2
  Mov op3 B$FirstReg | shl op3 3 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_w_modreg2Rm:
  Parms 2 | GPreg2 | ToOpcode op1
  or op2 B$wBit | ToOpcode op2
  Mov op3 B$SecondReg | shl op3 3 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_w_reg2reg1:
  Parms 2 | GPreg1_2 | ToOpcode op1
  or op2 B$wBit | ToOpcode op2
  Mov op1 B$SecondReg | shl op1 3 | or op3 op1 | or op3 B$FirstReg | LastOpcode op3

op_w_reg1reg2X:                ; special for B$wBit]s disagree in MOVSX / MOVZX
  XParms 2 | GPreg1_2 | ToOpcode op1
  or op2 B$wBit | ToOpcode op2
;  Mov op1 B$SecondReg | shl op1 3 | or op3 op1 | or op3 B$FirstReg | LastOpcode op3
  Mov op1 B$FirstReg | shl op1 3 | or op3 op1 | or op3 B$SecondReg | LastOpcode op3

op_modReg1Rm:
  Parms 2 | GPreg1 | ToOpcode op1
  Mov op2 B$FirstReg | shl op2 3 | or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

op_modReg2Rm:
  Parms 2 | GPreg2 | ToOpcode op1
  Mov op2 B$SecondReg | shl op2 3 | or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2
 ______________________________________________________________________________________

op_op: Parms 0 | ToOpcode op1 | LastOpcode op2

op_op_P1: Parms 1 | ToOpcode op1 | LastOpcode op2

op_op_P2: ParmsAny 2 | ToOpcode op1 | LastOpcode op2

op_op_dis: Parms 1 | ToOpcode op1 | LastOpcode op2

op_op_reg1:
  Parms 1 | GPreg1 | ToOpcode op1, op2
  or op3 B$FirstReg | LastOpcode op3

op_op_reg16:
  Parms 1 | GPreg1 | On B$FirstOperandWbit <> WORD_SIZE error D$VERRwordPtr
  ToOpcode op1, op2 | or op3 B$FirstReg | LastOpcode op3

op_op_reg1reg2:
  Parms 2 | GPreg1_2 | ToOpcode op1, op2
  Mov op1 B$FirstReg | shl op1 3 | or op3 op1 | or op3 B$SecondReg | LastOpcode op3

op_op_reg1_imm8:
  Parms 2 | GPreg1 | imm8Size | ToOpcode op1, op2 | or op3 B$FirstReg | LastOpcode op3

op_op_reg2reg1:
  Parms 2 | GPreg1_2 | ToOpcode op1, op2
  Mov op1 B$SecondReg | shl op1 3 | or op3 op1 | or op3 B$FirstReg | LastOpcode op3

op_op_reg2reg1_cl:
  Parms 3 | GPreg1_2
  On B$ThirdOperandWbit <> BYTE_SIZE error D$NeedByteSizePtr
  ToOpcode op1, op2
  Mov op1 B$SecondReg | shl op1 3 | or op3 op1 | or op3 B$FirstReg | LastOpcode op3

op_op_reg2reg1_imm8:
  Parms 3 | imm8Size | GPreg1_2 | ToOpcode op1, op2
  Mov op1 B$SecondReg | shl op1 3 | or op3 op1 | or op3 B$FirstReg | LastOpcode op3

op_op_modRm:
  Parms 1 | ToOpcode op1, op2 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_op_modRm16:
  Parms 1
  On B$FirstOperandWbit <> WORD_SIZE error D$VERRwordPtr
  ToOpcode op1 | ToOpcode op2 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3


op_op_modRm_imm8:
  Parms 2 | imm8Size | ToOpcode op1, op2
  or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_op_modReg2Rm:
  Parms 2 | GPreg2 | ToOpcode op1, op2
  Mov op3 B$SecondReg | shl op3 3 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_op_modReg2Rm_cl:
  Parms 3 | GPreg2 | ToOpcode op1, op2
  On B$ThirdOperandWbit <> BYTE_SIZE error D$NeedByteSizePtr
  Mov op3 B$SecondReg | shl op3 3 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_op_modReg2Rm_imm8:
  Parms 3 | GPreg2 | imm8Size | ToOpcode op1, op2
  Mov op3 B$SecondReg | shl op3 3 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_op_modReg1Rm:
  Parms 2 | GPreg1 | ToOpcode op1, op2
  Mov op3 B$FirstReg | shl op3 3 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

 ________________________________________________________________________________________


w_P2: ParmsAny 2 | or op1 B$wBit | LastOpcode op1

w_imm8:
  Parms 2 | imm8Size | On B$SecondReg <> REG_EAX error D$OnlyAccPtr
  or op1 B$wBit | LastOpcode op1

w_imm: Parms 2 | or op1 B$wBit | lastOpcode op1

; w_dis is used only by Mov mem to accum.   or  accum. to mem.:

w_dis: Parms 2 | or op1 B$wBit | LastOpcode op1

w_reg1:
  Parms 1 | GPreg1 | or op1 B$wBit | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2

w_reg1_P2:
  Parms 2 | imm8Size | GPreg1
  Mov B$immInside &FALSE         ; exemple: SHL eax, 1  >>> no more imm
  or op1 B$wBit | ToOpcode op1
  or op2 B$FirstReg | LastOpcode op2

w_reg1_P2cl:
    ParmsAny 2 | GPreg1
    cmp B$SecondReg REG_CL | jne L1>
    cmp B$SecondOperandWbit BYTE_SIZE | je L2>
L1:   error D$MixTypePtr
L2: or op1 B$FirstOperandWbit | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2

w_reg1reg2:
  Parms 2 | GPreg1_2 | or op1 B$wBit | ToOpcode op1
  Mov op1 B$FirstReg | shl op1 3 | or op2 op1 | or op2 B$SecondReg | LastOpcode op2

w_reg2reg1:
  Parms 2 | GPreg1_2 | or op1 B$wBit | ToOpcode op1
  Mov op1 B$SecondReg | shl op1 3 | or op2 op1 | or op2 B$FirstReg | LastOpcode op2

w_reg1_imm8:
  Parms 2 | GPreg1 | imm8Size
  or op1 B$wBit | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2

w_reg1_imm:
  Parms 2 | GPreg1 | or op1 B$wBit | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2

w_modRm:
  Parms 1 | or op1 B$wBit | ToOpcode op1
  or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

w_modRm_P2:
  Parms 2 | Mov B$immInside &FALSE         ; exemple: SHL eax, 1  >>> no more imm
  or op1 B$wBit | ToOpcode op1
  or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

w_modRm_P2cl:
    ParmsAny 2
    On B$FirstOperandWbit = WORD_SIZE ToOpcode 066
    cmp B$SecondReg REG_CL | jne L1>
    cmp B$SecondOperandWbit BYTE_SIZE | je L2>
L1:   error D$MixTypePtr
L2: or op1 B$FirstOperandWbit | ToOpcode op1
    or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

w_modReg1Rm:
  Parms 2 | GPreg1 | or op1 B$wBit | ToOpcode op1
  Mov op2 B$FirstReg | shl op2 3 | or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

w_modReg2Rm:
  Parms 2 | GPreg2 | or op1 B$wBit | ToOpcode op1
  Mov op2 B$SecondReg | shl op2 3 | or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

w_modRm_imm8:
  Parms 2 | imm8Size | or op1 B$wBit | ToOpcode op1
  or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

w_modRm_imm:
  Parms 2 | or op1 B$wBit | ToOpcode op1
  or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

 _______________________________________________________________________________________


sw_reg1_imm:
  Parms 2 | GPreg1 | signImm
 ; On B$wBitDisagr&TRUEee = , or op1 B$sBit
  On B$FirstOperandWbit <> BYTE_SIZE or op1 B$sBit
  or op1 B$wBit | ToOpcode op1
  or op2 B$FirstReg | LastOpcode op2

sw_modRm_imm:
  Parms 2 | signImm
  ;On B$wBitDisagree = &TRUE,  or op1 B$sBit
  On B$FirstOperandWbit <> BYTE_SIZE or op1 B$sBit
  or op1 B$wBit | ToOpcode op1
  or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

 ________________________________________________________________________________________

s_reg1reg2_imm:      ; imul only: pb: can be 8 or 16 or 32 bits imm >>> sbts (?)
  Parms 3 | signImm | GPreg1_2
 ; On B$wBitDisagree = &TRUE,  or op1 B$sBit
 ;  On B$FirstOperandWbit <> BYTE_SIZE or op1 B$sBit     ; supposed of no use...
  or op1 B$sBit | ToOpcode op1
  Mov op1 B$FirstReg | shl op1 3 | or op2 op1 | or op2 B$SecondReg | LastOpcode op2

s_modReg1Rm_imm:     ; idem
  Parms 3 | signImm | GPreg1
  ; On B$wBitDisagree = &TRUE, ...   ; supposed of no use...
  or op1 B$sBit | ToOpcode op1
  Mov op2 B$FirstReg | shl op2 3 | or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

 ; used by 'Push imm' only:
s_imm: Parms 1 | Mov B$TrueSize DWORD_SIZE | signImm | or op1 B$sBit | LastOpcode op1

s_imm16: Parms 1 | ToOpcode 066 | Mov B$TrueSize WORD_SIZE | signImm | or op1 B$sBit
         LastOpcode op1

 _________________________________________________________________________________________

sReg2:    ; for Pop only. Nothing special here because segment regs are greater code
          ; than 0111B
          ;
          ; a 066h prefix have been written because of size. This is no use for this:
  dec edi
  Parms 1 | or op1 B$FirstReg | LastOpcode op1

 _________________________________________________________________________________________

 ; Only for XCHG with EAX as second register:

XOPreg1: Parms 2 | or op1 B$FirstReg | LastOpcode op1
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Error           ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;;
 'error' deal. 'OutOnError'

 how it works:

 Because of the structure of RosAsm (multiple passes with source transformations), pointing
 a bad statement, in true source file is a real head break. I thaught of two solutions:
 line numbers, that would allowed jumping from one state to a previous one, and error
 level flag that would allowed jumping to specific error check routines level-dependant.
 i choose the second solution. Heavy, but it works,... as far as i can know. Sometimes
 dirty; always difficult to understand. Sorry; after 3 writings from scratch, i think it
 can't be really simple anyway.

 In this version, 2 main routines (+ others...) are used, depending on the fact that the 
 error occurred inside EOIs (|...|) or inside brackets ([...]). Some ajustements are made:
 
- when a statement is the result of macro expending (doesn't exist in first source text),
 it is inside 'meEOIs' (Macro expension End Of Instruction) so that they are not counted
 in 'StatementCounter'.
 
- when error occur in data storing work any 'non data' bracket must be added to
 'bracketCounter'
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

[OldStackPointer: D$ ?]

[bracketCounter: D$ ?
 StatementsCounter: D$ ?
 ErrorLevel: D$ ?
 InsideBracket: D$ ?
 InsideComment: D$ ?
 InsideMLC: D$ ?]

[Error | Call ViewCookedError #2>L | Mov eax #1 | jmp OutOnError]
________________________________________________________________________________________

[LinesCounter: D$ ?
 DontCountNext: D$ ?
 StatementsTable: D$ ?
 StatementsTable2: D$ ?
 StatementsPtr: D$ ?
 StatementsPtr2: D$ ?]


_____________________________________________________________________________________

; final error prompting:

[ErrorMessagePtr: D$ ?]

ShowError:
; First, we make the MessageBox a little wider if the title is longer than the Message.
; Win set the Box width on the Message (not on the Title).
    pushad
        Mov ecx 10, edx 0
        While B$eax > 0
            inc eax | inc ecx        ; > lenght of Title
        End_While
        Mov edi Trash2
        While B$esi <> 0FF
            movsb | inc edx          ; lenght of Message Text
        End_While

        If edx < ecx
            sub ecx edx
            shl ecx 1
            Mov al SPC | rep stosb   ; ajusts text widht around the title width
        End_If
;;
  If CookedErrorMessage Buffer is not empty, this is because Errror Macro has been
  evocated with two Parameters 1) Error Title 2) Pointer to the internal Member of
  the Instruction that produced the error. If two Parameters, we add this Member
  under the Statement viewed in the Dialog Box. 'CookedErrorMessage' has been "Un-Cooked"
  by 'ViewCookedError'.
;;
        If D$CookedErrorMessage = 0
            Mov al 0 | stosb
        Else
            Mov W$edi CRLF, W$edi+2 CRLF | add edi 2 ;4
            Mov D$edi '>>> ' | add edi 4
            Mov esi CookedErrorMessage

            While B$esi <> 0
                movsb | On esi = EndOfCookedErrorMessage, jmp L1>
            End_While
L1:         Mov B$edi 0

        End_If

        Mov esi D$OldCharPos, al B$OldChar, B$esi al

        sub esi 1 | Mov D$LP.BlockEndText esi

    popad

    pushad

      ;Call ErrorMessageBox Trash2, eax
      Call ReleaseAsmTables

    popad

    Call SetDebuggeeText

    Call ErrorMessageBox Trash2, D$ErrorMessagePtr
ret


SetDebuggeeText:
    Mov D$LP.BlockStartText esi, D$STRUCT.EditData@UpperLine esi, D$STRUCT.EditData@CurrentWritingPos esi

    Call TryToMove

    Mov ebx 0, esi D$STRUCT.EditData@UpperLine               ; Where is the block at screen?
L0: lodsb | On al = LF, inc ebx
    cmp esi D$LP.BlockStartText | jb L0<

    Mov ecx D$STRUCT.EditData@LineNumber | shr ecx 1         ; if higher than half screen,
    shr ecx 1
    .If ebx < ecx                             ; scroll to half screen.
        sub ecx ebx                           ; if down, we are at end of source...

      ; Also, don't Move, for error pointing, upper than possible:
        If D$LP.ActualTitle <> &NULL
            Mov edx D$LP.ActualTitle
        Else
            Mov edx D$CodeSource
        End_If

L2:     cmp D$STRUCT.EditData@UpperLine edx | jbe L3>
        Call UpOneLine | loop L2<
   .End_If

L3: Mov D$FL.BlockInside &TRUE

    Mov esi D$OldCharPos, al B$OldChar, B$esi al

    Call SearchForEndOfErrorBlock

    Call SetCaret D$LP.BlockEndText

  ; Clear possible previous ShiftPos, in case user first hit [Shift] right after
  ; the error isq pointed out:
    Move D$ShiftBlockCol D$STRUCT.EditData@CaretRow, D$ShiftBlockLine D$STRUCT.EditData@CaretLine

    Call AskForRedrawNow
ret


[LastErrorBlockPipe: D$ ?]

SearchForEndOfErrorBlock:
    Mov esi D$LP.BlockStartText, ecx 0, D$LastErrorBlockPipe 0
    On B$esi = '[', jmp SearchForEndOfErrorBracketBlock

L0: lodsb | On esi = D$STRUCT.EditData@SourceEnd, jmp L2>>

    If al = "'"
        While B$esi <> "'" | inc esi | On esi = D$STRUCT.EditData@SourceEnd, jmp L2>>
        End_While | inc esi
        Mov ecx 0
    Else_If al = '"'
        While B$esi <> '"' | inc esi | On esi = D$STRUCT.EditData@SourceEnd, jmp L2>
        End_While | inc esi
        Mov ecx 0
    Else_If al = ';'
        On ecx = 0, jmp L2>
        While B$esi >= SPC | inc esi | On esi = D$STRUCT.EditData@SourceEnd, jmp L2>
        End_While | add esi 2
    Else_If al = ','
        Mov ecx 1
    Else_If al = '|'
        On D$LastErrorBlockPipe = 0, Mov D$LastErrorBlockPipe, esi
    Else_If al < SPC
        On ecx = 0, jmp L2>
    Else_If al = SPC

    Else
        Mov ecx 0
    End_If
    jmp L0<<

L2: sub esi 2 | Mov D$LP.BlockEndText esi

    If D$LastErrorBlockPipe <> 0
        Mov eax D$LastErrorBlockPipe | sub eax 2 | Mov D$LP.BlockEndText eax
    End_If

    Move D$STRUCT.EditData@CurrentWritingPos D$LP.BlockEndText
ret


SearchForEndOfErrorBracketBlock:
L0: lodsb | On esi = D$STRUCT.EditData@SourceEnd, jmp L2>

    If al = "'"
        While B$esi <> "'" | inc esi | End_While | inc esi
    Else_If al = '"'
        While B$esi <> '"' | inc esi | End_While | inc esi
    Else_If al = ';'
        While B$esi >= SPC | inc esi | End_While | add esi 2
    Else_If al = ']'
        jmp L2>
    End_If
    jmp L0<

L2: Mov D$LP.BlockEndText esi

ret
_________________________________________________________________________________________

[FL.CompileErrorHappend: D$ ?
 FirstPass: D$ ?]

OutOnError:

    Mov D$ErrorMessagePtr eax

    Mov D$FL.CompileErrorHappend &TRUE,
        D$NextSearchPos 0

    On B$WeAreChecking = &TRUE ret

    On D$FL.WeAreUnfolding = &TRUE jmp UnfoldingError

    ; Error in the second part of the Encode-DecodeBox 'B$Errorlevel 7'
    On B$Errorlevel = 7,  jmp EncodeError
    On B$WeAreInTheCodeBox = &TRUE, jmp EncodeBoxError

    cld
L0: Mov esp D$OldStackPointer               ; restor stack (...comming from anywhere)

L1: pushad

       Call CloseProgressBar
    popad

    On B$Errorlevel = 0,  jmp Error0        ; open text error in 'SourceCleaner'
    On B$Errorlevel = 1,  jmp Error1        ; error inside square bracket
    On B$Errorlevel = 2,  jmp Error2        ; error in statements
    On B$Errorlevel = 3,  jmp Error3        ; error inside     ;;;;;;;;;;;;StoreDatas
    On B$Errorlevel = 4,  jmp Error4        ; error in DLL name ; Mov B$Errorlevel 1
    On B$Errorlevel = 5,  jmp Error5        ; error in api name  ; Mov B$Errorlevel 5
    On B$Errorlevel = 6,  jmp Error6        ; error in the form of api Call
  ; Error7 is reserved for the Encode-Decode Box.
    On B$Errorlevel = 8,  jmp Error8        ; error in Win Equate Name
    On B$Errorlevel = 11,  jmp Error11      ; error in ClASSes
   ; On B$Errorlevel = 12,  jmp Error12      ; Short Displacement error

  ; Error9 (or none) falls there:
    Call AskForRedrawNow

    If D$CookedErrorMessage <> 0
        Call ErrorMessageBox CookedErrorMessage, D$ErrorMessagePtr
    Else
        Call ErrorMessageBox 0, D$ErrorMessagePtr
    End_If

    Call ReleaseAsmTables

    ret ; for 'no search' errors (esi known) or 'Main:' missing

____________________________________________________________________________________________

;;
  To YeoH: '.zh' should be the extension of your 'RosAsmStrings' File.
  
  I hope you will succeed to make this "...If D$StringsLanguage = '.zh'" work... ;)
  As, off course, as you may guess, i cannot see anything on my Computer...
;;

Proc ErrorMessageBox:

    Arguments @Text1,
              @Text2

        ...If D$StringsLanguage = '.zh'

            ; Unicode:
            Mov esi D@Text1,
                edi Trash1,
                ecx 0

            If esi <> &NULL

                While W$esi > EOS

                    movsw | inc ecx | cmp ecx 400 | ja L1>

                End_While

            End_If

L1:         Mov W$edi EOS

            .If D@Text2 <> &NULL

                Mov esi D@Text2,
                    edi Trash2,
                    ecx 0

                If esi <> &NULL

                    While W$esi > EOS

                        movsw | inc ecx | cmp ecx 400 | ja L1>

                    End_While

                End_If
L1:
                Mov W$edi EOS

            .Else

                Mov W$Trash2 EOS

            .End_If

            ; Tag Dialog 10
            Call 'USER32.DialogBoxIndirectParamW' D$H.Instance,
                                                  ErrorUnicodeDialog,
                                                  &NULL,
                                                  ErrorMessageDialogW,
                                                  &NULL

        ...Else
          ; Ascii:
            If D@Text1 <> 0
                Mov esi D@Text1, edi Trash1, ecx 0 | Mov D$edi CRLF | add edi 2
                While B$esi > 0
                    movsb | inc ecx | cmp ecx 400 | ja L1>
                End_While
            End_If
L1:         Mov B$edi 0

            .If D@Text2 <> 0
                Mov esi D@Text2, edi Trash2, ecx 0 | Mov D$edi CRLF | add edi 2
                If esi <> 0
                    While B$esi > 0
                        movsb | inc ecx | cmp ecx 400 | ja L1>
                    End_While
                End_If
L1:             Mov B$edi 0
            .Else
                Mov B$Trash2 0
            .End_If

            Mov al B$Trash1+2 | or al B$Trash2
          ; Tag Dialog 10
            On al <> 0,
            Call 'USER32.DialogBoxParamA' D$H.Instance, 10, D$H.MainWindow, ErrorMessageDialogA, &NULL

        ...End_If
EndP

[ErrorUnicodeDialog: D$ 090CC08C2 0        ; Style
 U$ 03 0 0 0DC 065             ; Dim
 0                             ;      no Menu
 '' 0                          ; Class
 '' 0                          ; Title
 12 'SimSun' 0]                ; Font  MS Song // SimSun  //   'MS Song', 0] ;

[@Control0000: D$ 050800004 0      ; Style
 U$ 0 01 0DC 028               ; Dim
 0A                            ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data

[@Control0001: D$ 050800004 0      ; Style
 U$ 0 02A 0DC 028              ; Dim
 014                           ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data

[@Control0002: D$ 050000000 0      ; Style
 U$ 050 054 037 010            ; Dim
 01                            ; ID
 0FFFF 080                     ; Class
 'OK' 0                        ; Title
 0]                            ; No creation data


; Tag Dialog 10

Proc ErrorMessageDialogW:

    Arguments @hwnd,
              @msg,
              @wParam,
              @lParam

    If D@msg = &WM_INITDIALOG

        Call WM_INITDIALOG_ErrorMessageDialogW

    Else_If D@msg = &WM_CTLCOLOREDIT

        Call WM_CTLCOLOREDIT | ExitP

    Else_If D@msg = &WM_COMMAND

        On W@wParam = HIDE_PUSHBUTTON_OK Call WM_CLOSE_ErrorMessageDialog

    Else_If D@msg = &WM_CLOSE

        Call WM_CLOSE_ErrorMessageDialog

    Else

         Return &FALSE

    End_If

    Mov eax &TRUE

EndP


WM_INITDIALOG_ErrorMessageDialogW:

    Call SetIconDialog

    Call 'USER32.SendDlgItemMessageA' D$HWND,
                                      10,
                                      &WM_SETFONT,
                                      D$H.Font1,
                                      &FALSE

    On D$H.NationalFont <> &NULL Call 'USER32.SendDlgItemMessageW' D$HWND,
                                                                   20,
                                                                   &WM_SETFONT,
                                                                   D$H.NationalFont,
                                                                   &FALSE

    Call 'USER32.SendDlgItemMessageA' D$HWND,
                                      10,
                                      &EM_SETMARGINS,
                                      &EC_LEFTMARGIN+&EC_RIGHTMARGIN,
                                      10

    Call 'USER32.SendDlgItemMessageA' D$HWND,
                                      20,
                                      &EM_SETMARGINS,
                                      &EC_LEFTMARGIN+&EC_RIGHTMARGIN,
                                      10

    Call 'USER32.SendMessageA' D$HWND,
                               &WM_SETTEXT,
                               &NULL,
                               D$ErrorMessageTitlePtr

    Call 'USER32.SendDlgItemMessageA' D$HWND,
                                      10,
                                      &WM_SETTEXT,
                                      0,
                                      Trash1

    On B$trash2 <> EOS Call 'USER32.SendDlgItemMessageW' D$HWND,
                                                         20,
                                                         &WM_SETTEXT,
                                                         0,
                                                         Trash2

ret


Proc ErrorMessageDialogA:

    Arguments @hwnd,
              @msg,
              @wParam,
              @lParam

    If D@msg = &WM_INITDIALOG

        Call WM_INITDIALOG_ErrorMessageDialogA

    Else_If D@msg = &WM_CTLCOLOREDIT

        Call WM_CTLCOLOREDIT | ExitP

    Else_If D@msg = &WM_COMMAND

        On W@wParam = HIDE_PUSHBUTTON_OK Call WM_CLOSE_ErrorMessageDialog

    Else_If D@msg = &WM_CLOSE

        Call WM_CLOSE_ErrorMessageDialog

    Else

        Return &FALSE

    End_If

    Mov eax &TRUE

EndP

WM_INITDIALOG_ErrorMessageDialogA:

        Call SetIconDialog

        Call 'USER32.SendDlgItemMessageA' D$HWND,
                                          10,
                                          &EM_SETMARGINS,
                                          &EC_LEFTMARGIN+&EC_RIGHTMARGIN,
                                          10

        Call 'USER32.SendMessageA' D$HWND,
                                   &WM_SETTEXT,
                                   &NULL,
                                   D$ErrorMessageTitlePtr

        Call 'USER32.SendDlgItemMessageA' D$HWND,
                                          20,
                                          &EM_SETMARGINS,
                                          &EC_LEFTMARGIN+&EC_RIGHTMARGIN,
                                          10


        Call 'USER32.SendDlgItemMessageA' D$HWND,
                                          10,
                                          &WM_SETTEXT,
                                          0,
                                          Trash1

        On D$H.NationalFont <> &NULL Call 'USER32.SendDlgItemMessageA' D$HWND,
                                                                       20,
                                                                       &WM_SETFONT,
                                                                       D$H.NationalFont,
                                                                       &FALSE

        Call 'USER32.SendDlgItemMessageW' D$HWND,
                                          10,
                                          &WM_SETFONT,
                                          D$H.Font1,
                                          &FALSE

        On B$trash2 <> EOS Call 'USER32.SendDlgItemMessageA' D$HWND,
                                                             20,
                                                             &WM_SETTEXT,
                                                             0,
                                                             Trash2

ret

WM_CLOSE_ErrorMessageDialog:

    Call 'USER32.EndDialog' D$HWND,
                            &NULL

ret
____________________________________________________________________________________________

[CookedErrorMessage: D$ ? # 20]
[EndOfCookedErrorMessage: D$ ? ?]

;;
  This shows the internal Source of error. Can't work actually as i don't know how to
  to make sure that esi points to something inside the Assembler Tables Memory, and i
  don't find any function that would say if the pointer is valid or not. Nothing like
  'ReadProcessmemory' in the Debugger. There is 'KERNEL32.SetErrorMode', but i don't
  know if it works or not for x86, and what Message is suppose to be sent back.
  
  Would probably require SEH...
;;

Proc ViewCookedError:

    Argument @STR.A

    Uses esi,
         edi

        While B$esi > EOI | sub esi (1*ASCII) | End_While | add esi (1*ASCII)

        Mov edi CookedErrorMessage

L1:     lodsb
        ; TODO TABLE !!!
        .If al = TextSign ; 30

            Mov al '"'

        .Else_If al = numSign ; 28
            Mov al '#'
        .Else_If al = CommaSign ; 23
            Mov al ','
        .Else_If al = OpenVirtual ; 22
            Mov al '{'
        .Else_If al = CloseVirtual ; 21
            Mov al '}'
        .Else_If al = Openbracket ; 20
            Mov al '['
        .Else_If al = Closebracket ; 19
            Mov al ']'
        .Else_If al = memMarker ; 15
            Mov al '$'
        .Else_If al = colonSign ; 14
            Mov al ':'
        .Else_If al = openSign ; 13
            Mov al '('
        .Else_If al = closeSign ; 12
            Mov al ')'
        .Else_If al = addSign ; 10
            Mov al '+'
        .Else_If al = subSign ; 9
            Mov al '-'
        .Else_If al = mulSign ; 8
            Mov al '*'
        .Else_If al = divSign ; 7
            Mov al '/'
        .Else_If al = expSign ; 6
            Mov al '^'
        .Else_If al = Space ;  3
            Mov al SPC
        .Else_If al = EOI ;  2
            Mov al '|' | jmp S0>
        .Else_If al = meEOI ; 1
            Mov al '|'
        .End_If

        stosb

        On edi < EndOfCookedErrorMessage jmp L1<<

S0:     Mov B$edi EOS

EndP

 _________________________________________________________________________________________

; open text error in 'SourceCleaner'

[OldChar: D$ ?
 OldCharPos: D$ ?]

SetEndOfErrorText:

    Mov esi D$StatementsPtr, esi D$esi

    .If esi < D$CodeSource
        Mov esi D$CodeSource

    .Else_If esi > D$STRUCT.EditData@SourceEnd
        Mov esi D$STRUCT.EditData@SourceEnd | std
L0:     lodsb
        If al = LF
            inc esi ; stop
        Else_If al = '|'
            inc esi ; stop
        Else_If al = '['
                    ; stop
        Else_If esi > D$CodeSource
                    ; stop
        Else
            jmp L0<
        End_If
        cld
    .End_If

@DirectSourcePointing:
    Mov ecx 200
    Push esi, eax
L0:     lodsb
        If al <= CR
            dec esi ; stop
        Else_If al = '|'
            dec esi ; stop
        Else_If al = ']'
                    ; stop
        Else_If esi > D$STRUCT.EditData@SourceEnd
                    ; stop
        Else
            loop L0<
        End_If
        Mov al B$esi, B$OldChar al, B$esi 0FF, D$OldCharPos esi

        dec esi | Mov D$LP.BlockEndText esi  ;, D$CurrentWritingPos esi ; ?Case of Bad Pos?

    Pop eax esi

    Call VerifyNotOneChar
ret


; Because Blocks of one char was not outputed, in older version of the Editor.
; Should be of no more use now:

VerifyNotOneChar:
    Push esi, eax

        Mov eax D$LP.BlockEndText

        cmp eax D$LP.BlockStartText | ja L9>

            add D$LP.BlockEndText 1

            Mov eax D$LP.BlockEndText,
                al B$eax

            On al = CR add D$LP.BlockEndText 1

            Mov esi D$OldCharPos, al B$OldChar, B$esi al

            Mov esi D$LP.BlockEndText | add esi 1

            Mov al B$esi, B$OldChar al, B$esi 0FF, D$OldCharPos esi

L9: Pop eax, esi
ret


Error0:

    Call SetEndOfErrorText

    jmp ShowError
 _________________________________________________________________________________________

; error inside square bracket: we search [bracketCounter] square bracket number

Error1:
    Push eax
      Mov esi, D$CodeSource | Mov ecx, 0
L1:   lodsb | cmp al '"' | jne L3>
L2:   lodsb | cmp al '"' | jne L2<         ; strip "text"
        jmp L1<
L3:   cmp al "'" | jne L5>
L4:   lodsb | cmp al "'" | jne L4<         ; strip 'text'
        jmp L1<


L5: cmp al ';' | jne L7>                     ; jmp over comments
        If D$esi-2 = MLC   ; (LF ; ; CR)
            Do
                inc esi | cmp esi D$STRUCT.EditData@SourceEnd | jae L9>
            Loop_Until D$esi = MLC
            add esi 3 | cmp esi D$STRUCT.EditData@SourceEnd | jae L9>
        Else
L6:         lodsb | cmp al LF | jne L6<
        End_If
        jmp L1<

;L5:   cmp al ';' | jne L7>
;L6:   lodsb | cmp al LF | jne L6<          ; strip comments
;        jmp L1<

L7:   cmp al '[' | jne L1<
        inc ecx | cmp ecx D$bracketCounter | jb L1<

      Push esi
L8:     lodsb | cmp al ']' | jne L8<
          Mov al B$esi, B$esi 0FF, B$OldChar al, D$OldCharPos esi
      Pop esi
L9: Pop eax

    dec esi | jmp ShowError
 _________________________________________________________________________________________

; error in statements. We search D$StatementsCounter '|' number
; Nothing but a modified version of text cleaner first part.

Error2:
    Mov esi D$StatementsCounter
 ; showme eax
    Push esi, eax
L0:     lodsb
        If al = CR
            dec esi ; stop
        Else_If al = '|'
            dec esi ; stop
        Else_If al = ']'
                    ; stop
        Else_If esi > D$STRUCT.EditData@SourceEnd
                    ; stop
        Else
            jmp L0<
        End_If

    Mov al B$esi, B$OldChar al, D$OldCharPos esi, B$esi 0FF

    Pop eax esi

    jmp ShowError

 ________________________________________________________________________________________
;;
 error inside ReplaceEquate in brackets statements or...
 error inside StoreData: value in [bracketCounter] did not count equates and macros
 so that we have to do a new count in ecx before jumping to error1 bracket research.
;;

Error3:
;;
 now: ecx = lenght, esi > start of bad Name in Data.
 Used now only by 'SearchRegularLabel' when filling Data symbols evocations. At this
 time, we do not have any more the source Data pointers available in "StatementsTable".
;;
    pushad

    While B$esi-1 > LowSigns | dec esi | End_While

    Push esi
        Mov ecx 1
        While B$esi > LowSigns | inc esi | inc ecx | End_While
    Pop esi

    dec ecx | Mov D$LenOfSearchedString ecx

    Mov edi SearchString | rep movsb | Mov al 0 | stosb

    Push D$DownSearch, D$CaseSearch, D$WholeWordSearch, D$STRUCT.EditData@CurrentWritingPos
        Mov B$DownSearch &TRUE, B$CaseSearch &FALSE, B$WholeWordSearch &TRUE
        Move D$STRUCT.EditData@CurrentWritingPos D$CodeSource

        Mov D$Trash2 0

        Push D$NextSearchPos
            Mov D$NextSearchPos 0
L0:         Call StringSearch | On D$FL.BlockInside = &FALSE, jmp L7>>

          ; just in case the searched word is too inside a comment:
            Mov esi D$LP.BlockStartText | dec esi
            .While B$esi > LF
                If B$esi = '"'
                    dec esi
                    While B$esi <> '"'
                        dec esi
                    End_While
                Else_If B$esi = "'"
                    dec esi
                    While B$esi <> "'"
                        dec esi
                    End_While
                Else_If B$esi = ';'
                    jmp L0<
                End_If
                dec esi
            .End_While

            Mov esi D$LP.BlockStartText,
                edi Trash2,
                ecx D$LP.BlockEndText

            sub ecx D$LP.BlockStartText | inc ecx | rep movsb | Mov al 0 | stosb

L7: Pop D$NextSearchPos
    Pop D$STRUCT.EditData@CurrentWritingPos, D$WholeWordSearch, D$CaseSearch, D$DownSearch
    popad
    pushad
        Call AskForRedrawNow

        If D$Trash2 <> 0
            Call ErrorMessageBox Trash2, D$ErrorMessagePtr
        Else
            Call ErrorMessageBox esi, D$ErrorMessagePtr
        End_If
        Call ReleaseAsmTables
    popad
ret

_________________________________________________________________________________________

; Error in DLL name:

Error4:

    Mov D$FL.CompileErrorHappend &TRUE

    Push esi

;L9: pushad
;        ;Call 'USER32.MessageBoxA' D$H.MainWindow, esi, eax, &MB_SYSTEMMODAL
;        Call AskForRedrawNow
;
;        Call ErrorMessageBox esi, D$ErrorMessagePtr
;    popad

    Mov edi SearchString, B$DownSearch &TRUE, B$WholeWordSearch &FALSE
    Move D$STRUCT.EditData@CurrentWritingPos D$CodeSource
    Mov ecx 0

L0: inc ecx | lodsb | stosb | cmp al 0 | jne L0<
    dec edi | Mov al '.' | stosb | Mov D$LenOfSearchedString ecx

    Call  StringSearch

    Call AskForRedrawNow

    Pop esi

    Call ErrorMessageBox esi, D$ErrorMessagePtr

    Call ReleaseAsmTables
ret


; error in function name:

Error5:

    Mov D$FL.CompileErrorHappend &TRUE

    ;Push esi

    cld

;L9: ;Call 'USER32.MessageBoxA' D$H.MainWindow, esi, eax, &MB_SYSTEMMODAL
;    Call ErrorMessageBox esi, D$ErrorMessagePtr

    Mov edi SearchString, B$DownSearch &TRUE, B$WholeWordSearch &FALSE, B$CaseSearch &FALSE
    Move D$STRUCT.EditData@CurrentWritingPos D$CodeSource

    Mov esi D$StartOfFunctionName, ecx 0

L0: inc ecx | lodsb | stosb | cmp al 0 | jne L0<
    dec ecx
    Mov D$LenOfSearchedString ecx

    Call  StringSearch

    Call AskForRedrawNow

    ;Pop esi

    Call ErrorMessageBox D$StartOfFunctionName, D$ErrorMessagePtr

    Call ReleaseAsmTables
ret


; for bad api Call formulation:

Error6: ; Mov B$ErrorLevel 6
    Push esi

    Mov D$FL.CompileErrorHappend &TRUE

L9: ;pushad
      ;Call 'USER32.MessageBoxA' D$H.MainWindow, esi, eax, &MB_SYSTEMMODAL
    ;  Call ErrorMessageBox esi, D$ErrorMessagePtr
    ;popad

    Mov edi SearchString, B$DownSearch &TRUE, B$WholeWordSearch &FALSE
    Move D$STRUCT.EditData@CurrentWritingPos D$CodeSource
    Mov ecx 0

L0: inc ecx | lodsb | stosb | cmp al 0 | jne L0<
    dec ecx | Mov D$LenOfSearchedString ecx

    Call StringSearch

    Call AskForRedrawNow

    Pop esi

    Call ErrorMessageBox esi, D$ErrorMessagePtr

    Call ReleaseAsmTables
ret


; For Bad Win32 Equate Name:

Error8:

    Mov D$FL.CompileErrorHappend &TRUE

    Push esi

;;;    Mov B$esi 0
;;;    While B$esi <> '&' | dec esi | End_While

   ; pushad
   ;   ;Call 'USER32.MessageBoxA' D$H.MainWindow, esi, eax, &MB_SYSTEMMODAL
   ;   Call ErrorMessageBox esi, D$ErrorMessagePtr
   ; popad

    Push D$DownSearch, D$WholeWordSearch
        Mov edi SearchString, B$DownSearch &TRUE, B$WholeWordSearch &FALSE
        Move D$STRUCT.EditData@CurrentWritingPos D$CodeSource
        Mov ecx 0

L0:     inc ecx | lodsb | stosb | cmp al 0 | jne L0<
        dec ecx | Mov D$LenOfSearchedString ecx


L1:     Call StringSearch | cmp B$StringFound &FALSE | je L2>

        Mov esi D$LP.BlockEndText | Mov al B$esi+1

      ; Next Char Must be some separator, or some '_':
        If al = '_'
            ; OK
        Else
            Call WordEdge | On B$Edge = &FALSE, jmp L1<
        End_If

L2:     Call ReleaseAsmTables
    Pop D$WholeWordSearch, D$DownSearch

    Pop esi

    Call AskForRedrawNow

    Call ErrorMessageBox esi, D$ErrorMessagePtr
ret

[OneCLASSname: D$ ? # 80]

Error11:

    Mov D$FL.CompileErrorHappend &TRUE

    Push esi

L9: ;pushad
    ;  ;Call 'USER32.MessageBoxA' D$H.MainWindow, esi, eax, &MB_SYSTEMMODAL
    ;  Call ErrorMessageBox esi, D$ErrorMessagePtr
    ;popad

    Mov edi SearchString, B$DownSearch &TRUE, B$WholeWordSearch &FALSE
    Move D$STRUCT.EditData@CurrentWritingPos D$CodeSource
    Mov esi OneCLASSname, ecx 0

L0: inc ecx | lodsb | stosb | cmp al 0 | jne L0<
    dec ecx | Mov D$LenOfSearchedString ecx

L1: Call StringSearch
    Mov esi D$LP.BlockStartText | dec esi
    While B$esi = SPC | dec esi | End_While
    Mov eax D$esi-4 | and eax (not 020202020)

  ;  On eax <> 'CLAS', jmp L1<
  ;  On B$esi-5 <> '5', jmp L1<

    sub esi 5 | Mov D$LP.BlockStartText esi

    While B$esi <> ']' | inc esi | End_While

    Mov D$LP.BlockEndText esi

    Call ReleaseAsmTables
    Call AskforRedraw

    Pop esi

    Call ErrorMessageBox esi, D$ErrorMessagePtr
ret

;;
Error12:
    Push eax
      ; Write the Number out out of range Bytes at 'TooLongOf'
        Mov edi D$TooLongOfPtr, D$edi '    ' | Mov eax ebx | Call WriteEax

      ; Kill the Line Break between 'ShortDis' and 'TooLongOf'
        Mov esi D$TooLongOfPtr | dec esi
        While B$esi >= SPC | Mov B$esi SPC | dec esi | End_While
        While B$esi < SPC | Mov B$esi SPC | dec esi | End_While
    Pop eax
    
    jmp Error2
ret
;;


[CookedError2 | Mov esi #1 | Call ViewCookedError2]

[SyntaxErrorInMacro1 | pushad | inc #2 | CookedError2 #2>L | popad
pushad
Mov eax, #1 | Move D$ErrorMessagePtr #1 | Call ErrorMessageBox CookedErrorMessage, D$ErrorMessagePtr
popad]


ViewCookedError2:
    pushad
    Mov eax esi


    sub esi 20 ; 20 is the size of CookedErrorMessage message
    Mov edi CookedErrorMessage

    Do
        movsb
    Loop_Until esi = eax

     Mov B$edi 0

    popad
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Profiler        ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

@ProfileComments:
;;

____________________________________________________________________________________________

  ________
  Routines:
  
  From the Menu 'M00_Profile', Call to the Main Routine: 'Profiler'.
  
  From 'AsmMain':
  
  * 'InjectedCopyToCodeSourceA' injects additional Coding in the Timed App,
    instead of the normal 'NewCopyToCodeSourceA'. (Materials at 'InjectedTIME_COUNT')
    
  * In 'HotParsers', after the Call to 'StripUnderscore', turn the '.' of
    'InjectedTIME_COUNT' into '_', to build unique Symbols, by calling to
    'InjectDashLines'.
  
  * After execution of 'EncodeLines', Call to 'CreateProfilerTables'
  
  * 'FillCodeSymbols' takes in charge the filling of the Relays Table and
    does the substitutions. >>> 'TimingCalls'
  
  ______
  Plan_2:
  
  All calls are turned "Call Time_Count" So, we need a Table for storing the
  real calls Addresses. Same size as the CodeList Buffer. In 'FillCodeSymbols',
  "If B$ProfilerFlag = &TRUE", we do the substitution and save the Original Call
  Address in the Parallel Table.
  
  Inserted Routins, in the compiled Applicatinon, at 'InjectedTIME_COUNT'.
  There, the real Call will be in the form of "Call D$Address_Relay", which
  Variable will hold the Table Assress.
  
  This Table is created On RosAsm Side: Call for 'CreateMemoryMapFile'. This
  sould be done after the Call to EncodeLines, in 'AsmMain', by 'CreateProfilerTables'
  
  The 'Time_Count' inserted Routine must write the Timing in a second Table
  dedicated to these recordings.
  
  How to record the Timings?
  
  We need a qWords Table where what will be stored will be the difference
  between rdtsc, before and after the real call.
  
  Note: I do not see any Function associted to 'CreateFileMapping' that could
  tell the size of the File (?...). For now, simpler is to store this size in
  a Variable of 'InjectedTIME_COUNT'.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

[TimingMapName: B$ 'TestMem.tst' EOS]

[H.TimingMapFile: D$ ?
 OrigineOfTimingMap: D$ ?]

Proc CreateMemoryMapFile:
    Argument @Size
        Call 'KERNEL32.CreateFileMappingA' 0-1, &NULL, &PAGE_READWRITE,
                                        0, D@Size, TimingMapName
        Mov D$H.TimingMapFile eax

        Call 'KERNEL32.MapViewOfFile' D$H.TimingMapFile, &FILE_MAP_ALL_ACCESS,
                                      0, 0, D@Size
        Mov D$OrigineOfTimingMap eax
ret
____________________________________________________________________________________________


[ProfilerFlag: D$ ?]

; ProfileComments


[ProfilerOriginalCalls: D$ ?
 ProfilerNumberOfCalls: D$ ?]

CreateProfilerTables:
;;
 What Table do we need in the MapFile?
 
 - Storing the Real Calls Addresses. Same size as the real Code.
 - Storing the Number of calls. Same size as the real Code.
 - Storing the Timings on the calls Rooms. One qWord each. Double Size.
 
;;
  ; (Size of Code) * 4:
    Mov ecx D$CodeListPtr | sub ecx D$CodeOrigine | shl ecx 2

    Call CreateMemoryMapFile ecx

  ; The Timed App needs to know of the Displacement...
  ; .. and 'FillCodeSymbols' must fill the proper Displacements...
ret


ReleaseProfilerTables:

    Call VirtualFree ProfilerOriginalCalls

    Call VirtualFree ProfilerNumberOfCalls

ret

____________________________________________________________________________________________

[AddressOfTimeCount: D$ ?]
[ModelOfTimeCount: B$ 'TIME_COUNT' EOS]

SetAddressOfTimeCount:
    pushad
      ; 'FillCodeSymbols'
        Call GetFromQwordCheckSum ModelOfTimeCount, D$LabelList, D$LabelListLimit
        While B$eax > LowSigns | inc eax | inc esi | End_While | inc eax | inc esi
        Mov edi eax, ecx 0
    popad
ret

[InjectedTIME_COUNT: B$ "
Time.Count:
  ; The 'Call' Return Address is at D$esp
    Pop D$ReturnAddressOfTimeCount

        Push eax, ebx, ecx, edx
            cpuid | rdtsc
            sub D$Duration eax | sbb D$Duration+4 edx
        Pop edx, ecx, ebx, eax

        Call D$CallAddress

        Push eax, ebx, ecx, edx
            cpuid | rdtsc
            add D$Duration eax | adc D$Duration+4 edx
        Pop edx, ecx, ebx, eax

        hexprint D$Duration+4, D$Duration

    Push D$ReturnAddressOfTimeCount
ret

; To be paste here: 'OpenMemoryMapFile', 'WriteMemoryMapFile', 'CloseMemoryMapFile'.

" InjectedTIME_COUNT_Len: D$ Len]


; Called from 'HotParsers': ; CoolParsers

InjectDashLines:
    Mov esi D$CodeSourceA, ecx 1
  ; ecx = Hard code number of '.' in 'InjectedTIME_COUNT'.
L0: If B$esi = '.'
        Mov B$esi '_' | loop L0<
    Else
        jmp L0<
    End_If
ret



; Called from 'FillCodeSymbols':

TimingCalls:
  ; eax+4 = Original Displacement.

    On B$edi+1 <> 0E8, ret

    On D$AddressOfTimeCount = 0, Call SetAddressOfTimeCount
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE UnusedSymbols   ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
writer :  /\\o//\      - December the 31, 2004 -

 'LabelList'
 'SearchSortedRegularLabel'
 'LowSigns'
 'FLAG_DONE'
 'BuildPlainLabelList'

;;
____________________________________________________________________________________________

____________________________________________________________________________________________
____________________________________________________________________________________________

RemoveLocalLabels:

    Call VirtualFree PlainLabelList

    Mov eax D$LabelList, eax D$eax | inc eax

    Call VirtualAlloc PlainLabelList,
                      eax

    Mov edx D$LabelList | add edx D$edx
    Mov edi D$PlainLabelList | add edi 5
    Mov esi D$LabelList | add esi 5

    .While esi < edx
        cmp B$esi+2 EOI | jne L1>
            cmp B$esi 'A' | jb L1>
            cmp B$esi 'Z' | ja L1>
                cmp B$esi+1 '0' | jb L1>
                cmp B$esi+1 '9' | ja L1>
                  ; |L0|dWord Byte| >>> 9
                    add esi 9 | jmp L2>

L1:     While B$esi <> EOI
            movsb
        End_While
        movsb   ; |
        movsd   ; Ptr
        movsb   ; Flag
        movsb   ; |
L2: .End_While

    Mov eax edi | Mov D$EndOfPlainLabelList eax | sub eax D$PlainLabelList
    Mov edi D$PlainLabelList | stosd | Mov al EOI | stosb
ret
____________________________________________________________________________________________

[WorkBuffer: D$ ? # 256]

[CodeLabelNameList: D$ ?
 CodeLabelNameList.Current: D$ ?
 DataLabelNameList: D$ ?
 DataLabelNameList.Current: D$ ?
 H.UnusedCodeAndDataDialog: D$ ?
 RecompileWanted: D$ ?
 NumberOfUnusedDataLabels: D$ ?
 NumberOfUnusedCodeLabels: D$ ?]


;Task : Seperate CodeLabels from DataLabel, (Put into a list of their own)
Proc DisplayUnusedSymbolsDialog:
    Argument @hwnd
        Call RemoveLocalLabels
        Mov eax D$PlainLabelList | Mov eax D$eax

        Call VirtualAlloc CodeLabelNameList,
                          eax

        Call VirtualAlloc DataLabelNameList,
                          eax

        Mov edi D$CodeLabelNameList, D$CodeLabelNameList.Current edi
        Mov edi D$DataLabelNameList, D$DataLabelNameList.Current edi

        Mov ecx D$PlainLabelList | add ecx D$ecx
        Mov esi D$PlainLabelList | add esi 5
        Mov edi WorkBuffer
        Mov D$NumberOfUnusedCodeLabels 0, D$NumberOfUnusedDataLabels 0

        .While esi < ecx
L1:         While B$esi <> EOI
                movsb
            End_While

            Test B$esi+5 FLAG_DONE NOT_ZERO L1>>

            Mov B$edi 0 | inc edi

            Test B$esi+5 FLAG_CODE_LABEL ZERO L2>
                Push esi
                    Mov edi D$CodeLabelNameList.Current
                    Mov esi WorkBuffer
                    While B$esi <> 0 | movsb | End_While
                    Mov B$edi 0 | inc edi
                    Mov D$CodeLabelNameList.Current edi
                    inc D$NumberOfUnusedCodeLabels
                Pop esi
            jmp L1>

            L2: Test B$esi+5 FLAG_DATA_LABEL ZERO L1>
                Push esi
                    Mov edi D$DataLabelNameList.Current esi WorkBuffer
                    While B$esi <> 0 | movsb | End_While
                    Mov B$edi 0 | inc edi
                    Mov D$DataLabelNameList.Current edi
                    inc D$NumberOfUnusedDataLabels
                Pop esi
            Jmp L1>
L1:         add esi 7
            Mov edi WorkBuffer
L2:     .End_While
; Tag Dialog 4
        Call 'USER32.EndDialog' D@hwnd, 0
        Call 'USER32.DialogBoxParamA' D$H.Instance, 4, 0, UnusedCodeAndDataDialogCallBack, 0

        Call VirtualFree CodeLabelNameList

        Call VirtualFree DataLabelNameList

EndP
____________________________________________________________________________________________

[CodeListBox 101
 DataListbox 102
 UnUsedSymbolsEditBox 111
 FindDeclaration 4
 FreeSearchCheckBox 5
 UnusedSymbolHelpbutton 9]

[TextToRetrive: B$ ? # 256]
[FocusedChild: D$ ?
CurrentListBox: D$ ?

H.CodeListBox: D$ ?
H.DataListBox: D$ ?
H.UnUsedSymbolsEditBox: D$ ?
H.FindDeclaration: D$ ?
H.UnusedSymbolHelpbutton: D$ ?]
DataAndCodeLabelListBoxNotification:
   movzx ebx ax | Mov D$CurrentListBox ebx
   shr eax 16
   If ax = &LBN_DBLCLK
      Call 'USER32.SendDlgItemMessageA' D$H.UnusedCodeAndDataDialog, D$CurrentListBox,
                                        &LB_GETCARETINDEX 0 0
      Call 'USER32.SendDlgItemMessageA' D$H.UnusedCodeAndDataDialog, D$CurrentListBox,
                                        &LB_GETTEXT eax TextToRetrive
      Call 'USER32.SetDlgItemTextA' D$H.UnusedCodeAndDataDialog, UnUsedSymbolsEditBox,
                                    TextToRetrive
      Call SearchForUnusedSymbol
   Else_If ax = &LBN_SETFOCUS
        Move D$FocusedChild D$CurrentListBox
   End_If
ret

[EM_SETFOCUS 0100]
UnUsedSymbolsEditBoxNotification:
   shr eax 16
   If ax = EM_SETFOCUS
        Mov D$FocusedChild UnUsedSymbolsEditBox
   End_If
ret

[CharDistance 020]
SearchForTheSymbolInUnUsedSymbolsEditBox:
   Call 'USER32.SendDlgItemMessageA' D$H.UnusedCodeAndDataDialog, UnUsedSymbolsEditBox,
                                        &WM_GETTEXTLENGTH 0 0
   inc eax
   Mov D$LenOfSearchedString eax



   Call 'USER32.SendDlgItemMessageA' D$H.UnusedCodeAndDataDialog, UnUsedSymbolsEditBox,
                                        &WM_GETTEXT eax TextToRetrive


   Mov eax TextToRetrive

   While B$eax <> 0
      cmp B$eax 'Z' | jbe L0>
      cmp B$eax 'A' | ja L0>
      sub B$eax CharDistance
     L0:
     inc eax
   End_While

    Mov eax TextToRetrive
    Mov ecx D$LenOfSearchedString


    Mov esi TextToRetrive, edi ControlString | rep movsb
    Mov esi TextToRetrive, edi SearchString ecx D$LenOfSearchedString | rep movsb

    dec D$LenOfSearchedString
    Push D$DownSearch, D$WholeWordSearch, D$SkipDashLines
        Mov B$DownSearch &TRUE, B$WholeWordSearch &FALSE, B$SkipDashLines &TRUE
        Mov D$NextSearchPos 0
        On D$FL.RealSourceRestored = &FALSE Call RestoreRealSource
            Move D$STRUCT.EditData@CurrentWritingPos D$CodeSource
            Call StringSearch
            Push D$CodeSourceA D$CodeSourceB
                Mov esi D$STRUCT.EditData@CurrentWritingPos | sub esi 2 | Call InternalRightClick
            Pop D$CodeSourceB D$CodeSourceA
            Mov B$FinfOrReplace &FALSE
        Call SetPartialEditionFromPos
    Pop D$SkipDashLines, D$WholeWordSearch, D$DownSearch
    On B$StringFound = &FALSE, Call 'USER32.SetForegroundWindow' D$H.UnusedCodeAndDataDialog


ret



____________________________________________________________________________________________

[FreeSearchActive: &FALSE]
SearchForUnusedSymbol:
    Mov eax TextToRetrive, ecx 0

    While b$eax <> 0
        inc ecx | inc eax
    End_While
    inc ecx

    Push eax ecx
        Call 'USER32.SendDlgItemMessageA' D$H.UnusedCodeAndDataDialog, FreeSearchCheckBox,
                                     &BM_GETCHECK, 0, 0

        Mov D$FreeSearchActive eax
        cmp eax &TRUE
    Pop ecx eax | je L0>

            Mov B$eax ':', B$eax + 1 0 | inc ecx
    L0:
    Mov D$LenOfSearchedString ecx

    Mov eax TextToRetrive
    While B$eax <> 0
        cmp B$eax 'Z' | jbe L0>
        cmp B$eax 'A' | ja L0>
        sub B$eax CharDistance
     L0:
        inc eax
    End_While



DesideSearchForUnusedSymbols:
  If D$FocusedChild = UnUsedSymbolsEditBox
      Call SearchForTheSymbolInUnUsedSymbolsEditBox
  Else
     Mov ax &LBN_DBLCLK | shl eax 16 | Mov ax w$FocusedChild | Call DataAndCodeLabelListBoxNotification
  End_If

  On B$StringFound = &FALSE, Call 'USER32.SetForegroundWindow' D$H.UnusedCodeAndDataDialog
ret
____________________________________________________________________________________________

[NoteForWorkerBee:"You can press F5 to compile, without losing this list" EOS]

; Tag Dialog 4


[OldUnusedSymbolDialogSubClassProc1: D$ ?
 OldUnusedSymbolDialogSubClassProc2: D$ ?
 OldUnusedSymbolDialogSubClassProc3: D$ ?
 OldUnusedSymbolDialogSubClassProc4: D$ ?
 OldUnusedSymbolDialogSubClassProc5: D$ ?
 OldUnusedSymbolDialogSubClassProc6: D$ ?]

Proc UnusedSymbolDialogSubClassProc:
Arguments @hwnd, @msg, @wParam, @lParam

    .If D@msg = &WM_KEYDOWN
        If D@Wparam = &VK_F5
            Mov B$RecompileWanted &TRUE
            Mov D$FL.ShowStats &FALSE
            Call SaveUnusedIndex
            Push D$H.UnusedCodeAndDataDialog
                Mov D$H.UnusedCodeAndDataDialog 0
                Mov B$UnusedSymbolsWanted &TRUE
            Pop eax
            Call 'USER32.EndDialog' eax, 0

EndP

        End_If
    .End_If


   @DefaultProcessing:
   Mov eax D@hwnd
   .If eax = D$H.CodeListBox
       Call D$OldUnusedSymbolDialogSubClassProc1 D@hwnd, D@msg, D@wParam, D@lParam
   .Else_if eax = D$H.DataListBox
       Call D$OldUnusedSymbolDialogSubClassProc2 D@hwnd, D@msg, D@wParam, D@lParam
   .Else_if eax = D$H.UnUsedSymbolsEditBox
       Call D$OldUnusedSymbolDialogSubClassProc3 D@hwnd, D@msg, D@wParam, D@lParam
   .Else_if eax = D$H.FindDeclaration
       Call D$OldUnusedSymbolDialogSubClassProc4 D@hwnd, D@msg, D@wParam, D@lParam
   .Else_if eax = D$H.UnusedSymbolHelpbutton
       Call D$OldUnusedSymbolDialogSubClassProc5 D@hwnd, D@msg, D@wParam, D@lParam
   .Else
       Call D$OldUnusedSymbolDialogSubClassProc6 D@hwnd, D@msg, D@wParam, D@lParam
   .End_If
EndP

Proc InstallSubClassCallbacks:
Argument @hwnd
            Call 'USER32.GetDlgItem' D@hwnd CodeListBox
            If eax <> 0
                Mov D$H.CodeListBox eax
                Call 'USER32.SetWindowLongA' eax &GWL_WNDPROC UnusedSymbolDialogSubClassProc
                Mov D$OldUnusedSymbolDialogSubClassProc1 eax
            End_If

            Call 'USER32.GetDlgItem' D@hwnd DataListbox
            If eax <> 0
                Mov D$H.DataListBox eax
                Call 'USER32.SetWindowLongA' eax &GWL_WNDPROC UnusedSymbolDialogSubClassProc
                Mov D$OldUnusedSymbolDialogSubClassProc2 eax
            End_If

            Call 'USER32.GetDlgItem' D@hwnd UnUsedSymbolsEditBox
            If eax <> 0
                Mov D$H.UnUsedSymbolsEditBox eax
                Call 'USER32.SetWindowLongA' eax &GWL_WNDPROC UnusedSymbolDialogSubClassProc
                Mov D$OldUnusedSymbolDialogSubClassProc3 eax
            End_If

            Call 'USER32.GetDlgItem' D@hwnd FindDeclaration
            If eax <> 0
                Mov D$H.FindDeclaration eax
                Call 'USER32.SetWindowLongA' eax &GWL_WNDPROC UnusedSymbolDialogSubClassProc
                Mov D$OldUnusedSymbolDialogSubClassProc4 eax
            End_If
            Mov D$H.FindDeclaration eax

            Call 'USER32.GetDlgItem' D@hwnd UnusedSymbolHelpbutton
            If eax <> 0
                Mov D$H.UnusedSymbolHelpbutton eax
                Call 'USER32.SetWindowLongA' eax &GWL_WNDPROC UnusedSymbolDialogSubClassProc
                Mov D$OldUnusedSymbolDialogSubClassProc5 eax
            End_If

            Call 'USER32.GetDlgItem' D@hwnd FreeSearchCheckBox
            If eax <> 0
                Call 'USER32.SetWindowLongA' eax &GWL_WNDPROC UnusedSymbolDialogSubClassProc
                Mov D$OldUnusedSymbolDialogSubClassProc6 eax
            End_If
EndP

Proc UnusedCodeAndDataDialogCallBack:
    Arguments @hwnd, @msg, @wParam, @lParam

       pushad

        Mov eax &FALSE
        ..If D@msg = &WM_COMMAND
            If D@wParam = &IDHELP
                Call Help, B_U_AsmName, UnusedSymbolsHelp, ContextHlpMessage
            End_If

            Mov B$StringFound &TRUE
            Mov eax D@wParam

            If ax = CodeListBox
                Call DataAndCodeLabelListBoxNotification

            Else_If ax = DataListBox
                Call DataAndCodeLabelListBoxNotification

            Else_If ax = FindDeclaration
                shr eax 16
                cmp ax &BN_CLICKED | jne L0>
                    Call DesideSearchForUnusedSymbols
                L0:
            Else_If ax = &IDOK
                  Call DesideSearchForUnusedSymbols

            Else_If ax = &IDCANCEL
                    Mov B$UnusedSymbolsWanted &FALSE
                    Mov D$FL.UnusedSymbolsDialogWanted &FALSE
                    Mov D$H.UnusedCodeAndDataDialog 0
                    Call 'USER32.EndDialog' D@hwnd, 0

            Else_If ax = UnUsedSymbolsEditBox

                Call UnUsedSymbolsEditBoxNotification
            End_If

        ..Else_If D@msg = &WM_MOUSEMOVE

        ..Else_If D@msg = &WM_HELP
             Call Help B_U_AsmName, UnusedSymbolsHelp, ContextHlpMessage

        ..Else_If D@msg = &WM_KEYDOWN
             Call Help, B_U_AsmName, UnusedSymbolsHelp, ContextHlpMessage

        ..Else_If D@msg = &WM_INITDIALOG
            Call InstallSubClassCallbacks D@hwnd

            Mov eax D@hwnd
            Mov D$H.UnusedCodeAndDataDialog eax
            Call SetUnusedDialogPos D@hwnd
            Mov ecx D$NumberOfUnusedCodeLabels | jecxz L9>
            Mov eax D$CodeLabelNameList

L0:         Push eax ecx
                Push eax
                    While B$eax <> 0
                        cmp B$eax '@' | je L1>
                        inc eax
                    End_While
                Pop eax
                Push eax
                    Call 'USER32.SendDlgItemMessageA' D$H.UnusedCodeAndDataDialog,
                                                      CodeListBox, &LB_ADDSTRING, 0, eax
L1:             Pop eax
            Pop ecx eax
            While B$eax <> 0 | inc eax | End_While
            inc eax | dec ecx | jnz L0<

L9:         Mov ecx D$NumberOfUnusedDataLabels | jecxz L9>
            Mov eax D$DataLabelNameList

L0:         Push eax ecx
                Push eax
                    While B$eax <> 0
                        cmp B$eax '@' | je L1>
                        inc eax
                    End_While
                Pop eax
                Push eax
                    Call 'USER32.SendDlgItemMessageA' D$H.UnusedCodeAndDataDialog,
                                                      DataListbox, &LB_ADDSTRING, 0, eax
L1:             Pop eax
            Pop ecx eax
            While B$eax <> 0 | inc eax | End_While
            inc eax | dec ecx | jnz L0<

L9:         Call 'USER32.SetDlgItemTextA' D$H.UnusedCodeAndDataDialog,
                                          UnUsedSymbolsEditBox, NoteForWorkerBee

            Mov eax D$UnusedCodeIndex | or eax D$UnusedDataIndex
            On eax <> 0 Call RestoreUnusedIndex

        ..Else
            popad | Mov eax &FALSE | ExitP

        ..End_If

        popad | Mov eax &TRUE
EndP
____________________________________________________________________________________________

[UnusedCodeIndex: D$ ?
 UnusedDataIndex: D$ ?]

SaveUnusedIndex:
    Call 'USER32.SendDlgItemMessageA' D$H.UnusedCodeAndDataDialog, CODELISTBOX,
                                      &LB_GETTOPINDEX, 0, 0
    Mov D$UnusedCodeIndex eax

    Call 'USER32.SendDlgItemMessageA' D$H.UnusedCodeAndDataDialog, DATALISTBOX,
                                      &LB_GETTOPINDEX, 0, 0
    Mov D$UnusedDataIndex eax
ret

RestoreUnusedIndex:
    Call 'USER32.SendDlgItemMessageA' D$H.UnusedCodeAndDataDialog, CODELISTBOX,
                                      &LB_SETTOPINDEX, D$UnusedCodeIndex, 0

    Call 'USER32.SendDlgItemMessageA' D$H.UnusedCodeAndDataDialog, DATALISTBOX,
                                      &LB_SETTOPINDEX, D$UnusedDataIndex, 0
ret
____________________________________________________________________________________________

Proc SetUnusedDialogPos:
    Argument @hwnd
    Structure @WINDOWPLACEMENT 44,
              WINDOWPLACEMENT.iLengthDis 0,
              WINDOWPLACEMENT.flagsDis 4,
              WINDOWPLACEMENT.showCmdDis 8,
              WINDOWPLACEMENT.ptMinPosition.xDis 12,
              WINDOWPLACEMENT.ptMinPosition.yDis 16,
              WINDOWPLACEMENT.ptMaxPosition.xDis 20,
              WINDOWPLACEMENT.ptMaxPosition.yDis 24,
              WINDOWPLACEMENT.rcNormalPosition.leftDis 28,
              WINDOWPLACEMENT.rcNormalPosition.topDis 32,
              WINDOWPLACEMENT.rcNormalPosition.rightDis 36,
              WINDOWPLACEMENT.rcNormalPosition.bottomDis 40

        Mov D$WINDOWPLACEMENT.iLengthDis 44

        Call 'USER32.GetWindowPlacement' D$H.UnusedCodeAndDataDialog, D@WINDOWPLACEMENT

        Call 'USER32.GetSystemMetrics' &SM_CXSCREEN | sub eax 5
        Mov ecx D$WINDOWPLACEMENT.rcNormalPosition.rightDis
        sub ecx D$WINDOWPLACEMENT.rcNormalPosition.leftDis
        Mov D$WINDOWPLACEMENT.rcNormalPosition.rightDis eax
        sub eax ecx | Mov D$WINDOWPLACEMENT.rcNormalPosition.leftDis eax

        Call 'USER32.GetSystemMetrics' &SM_CYSCREEN | sub eax 30
        Mov ecx D$WINDOWPLACEMENT.rcNormalPosition.bottomDis
        sub ecx D$WINDOWPLACEMENT.rcNormalPosition.topDis
        Mov D$WINDOWPLACEMENT.rcNormalPosition.bottomDis eax
        sub eax ecx | Mov D$WINDOWPLACEMENT.rcNormalPosition.topDis eax

        Call 'USER32.SetWindowPlacement' D$H.UnusedCodeAndDataDialog, D@WINDOWPLACEMENT
EndP

____________________________________________________________________________________________

ReInitUnusedDialog:
    Call SaveUnusedIndex
    Call 'USER32.EndDialog' D$H.UnusedCodeAndDataDialog, 0
    Mov D$H.UnusedCodeAndDataDialog 0
    Mov B$UnusedSymbolsWanted &TRUE
    Mov B$RecompileWanted &TRUE
    Mov D$FL.ShowStats &FALSE
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Includes        ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;;

'BuildEquatesTables' 'GetEquates' 
 
 
Win Equates: How it works.

The Equates.equ Files expected by the Parsers is in the form of:

A0_REG 010
A1_REG 011
A2_REG 012
A3_REG 013
A4_REG 014
A5_REG 015
AADBE_ADD_ENTRY 01
AADBE_DEL_ENTRY 02
... and so on.

That is:

* Zero blank Line.
* One line is: NAME / Space / HEXA / CR-LF
* File CR-LF ended.

Zero flexibility. Simply have 2 spaces instead of one, or a space after the Hexa, will
make it fail.

At launch time, RosAsm attempts to open "Equates.equ". If not found, it sends a 
Message telling the user to provide the path for that file.

After having open "Equates.equ", RosAsm also opens all other '*.equ" Files encounted
aside "Equates.equ", loads all of these Data and compiles them.

Compiling the Win Equates:

The Equates Names and Values are stored into two different parallel Tables, one for
the Names, one for the Values. The names are computed into encoded dWords (a kind
of CheckSum), so that the two Tables are the same size.


The NamesTable begins by a Header of dWords Pointers: In fact, not only the Equates
are encoded, but they also are divided in 'First-Char's Chunks and each Chunk is sorted
in numerical order. When searching for an Equate Value, RosAsm first re-encodes the
Name into the CheckSum, condiders the First Equate Char, read the according Pointer
in the NameTable Header (and also the next Pointer to get the size by substraction),
and begins searching in the proper Chunk only. This final search, for recovering a
Value from a given Name, is done by a fast 2n Search Algo.

____________________________________________________________________________________________
____________________________________________________________________________________________


 Reading the "Include" Files: At least: Equates.equ / Functions.api / Structures.str,
 which are the required ones for Win32. RosAsm does not run without ( > Run Help File
 if not found / Load them if found).

 All other .equ Files found in the same Directory add pasted to the same Memory Tables
 for Equates.

 Functions.api is a single File (Right-Click / Disassembly).

 .str Files will be available trough [Struc] main menu option. If several .str Files
 are found > build a child menu with an Item for each, and branch the sub Menu to
 [Struc].
;;
____________________________________________________________________________________________

[IncludeFileName: B$ ? # &MAX_PATH]

; Called with '.ext' in eax:

Proc SetAllIncludeFilesExtension:
    Argument @Extension

    Mov esi EquatesName, edi IncludeFileName

    While B$esi <> 0 | movsb | End_While
    dec edi
    While B$edi <> '.' | dec edi | End_While

L0: dec edi | cmp B$edi '\' | je L1>
              cmp B$edi ':' | je L1>
              cmp edi IncludeFileName | ja L0<
                jmp L2>
L1: inc edi
L2: Mov B$edi '*' | inc edi | Mov eax D@Extension | stosd | Mov B$edi 0
EndP

____________________________________________________________________________________________

[H.StructPopUp: D$ ?
 StructuresFileOK: D$ ?]

[StructuresItem: B$ 'Structures' EOS]

PrepareStructuresFiles:
    Call SetAllIncludeFilesExtension '.str'
    Call 'KERNEL32.FindFirstFileA' IncludeFileName FIND_EQU | Call SetFullName

    ..If eax = &INVALID_HANDLE_VALUE
        Mov B$StructuresFileOK &FALSE
        ret
      ; Better let it run without Structures and Api Files if user wants to...
      ; May be temporary...

        Call Help, B_U_AsmName, IncludeFilesHelp, ContextHlpMessage

        Mov D$FL.Includes &FALSE

    ..Else  ; 'AddUserMenu'
        Mov D$H.FindInc eax
      ; Copy first the first File Path and Name in case there is only one:
        Mov B$StructuresFileOK &TRUE
        Mov esi FullName, edi MenuItemString, ecx (&MAX_PATH/DWORD) | rep movsd

      ; Is there more than one File.str?
        Call 'KERNEL32.FindNextFileA' D$H.FindInc FIND_EQU

;Mov eax &FALSE ; <<<<<<<<<<<<<<<< Temporary... (ToDo List...).

        .If eax = &TRUE
            Call 'KERNEL32.FindClose' D$H.FindInc

            Mov D$StructureMenuID 4000, B$SeveralStructuresFiles &TRUE

            Call 'USER32.CreatePopupMenu' | Mov D$H.StructPopUp eax

            Call 'KERNEL32.FindFirstFileA' IncludeFileName FIND_EQU
            Mov D$H.FindInc eax

            Do
                Call SetStructuresMenuItem
                Call 'KERNEL32.FindNextFileA' D$H.FindInc FIND_EQU
            Loop_Until eax = &FALSE



            Call 'USER32.InsertMenuA' D$H.MenuMain, M00_Structures,
                                  &MF_BYCOMMAND__&MF_POPUP__&MF_STRING,
                                  D$H.StructPopUp, StructuresItem

            Call 'USER32.DeleteMenu' D$H.MenuMain, M00_Structures, &MF_BYCOMMAND


          ;  Call 'USER32.DeleteMenu' D$H.MenuMain 8 &MF_BYPOSITION
          ;  Call 'USER32.InsertMenuA' D$H.MenuMain 8 &MF_BYPOSITION__&MF_STRING__&MF_POPUP,
          ;                    D$H.StructPopUp  StrucPopMenu
        .Else
          ; Else, there is only one .str File.
            Mov B$SeveralStructuresFiles &FALSE

        .End_If

        Call 'KERNEL32.FindClose' D$H.FindInc

    ..End_If
ret

[StructureMenuID: D$ ?]

; Builds the added PopUp Menu under [Struct] main Option:
; (We have a: > Mov D$StructureMenuID 4000 in caller ('OpenStructuresFiles').

SetStructuresMenuItem:
    Mov esi FIND_EQU@cFileName
    While B$esi <> 0 | inc esi | End_While
    dec esi
    While B$esi <> '.' | dec esi | End_While
    Mov B$esi 0
L0: dec esi | cmp B$esi '\' | je L1>
              cmp B$esi ':' | je L1>
              cmp esi FIND_EQU@cFileName | ja L0<

L1: Call 'USER32.AppendMenuA' D$H.StructPopUp &MF_STRING D$StructureMenuID esi
    inc D$StructureMenuID
ret

 ________________________________________________________________________________________
 _________________________________________________________________________________________
;;
 15948 Win Equates are stored in 2 tables of dWords: The first one for the Names
 (stored as one dWord per name after string coding) and the second one for the
 relative Values. The routine for coding the names i used when building these tables
 is the same as the one use here for the Win Equates Search (see down there).

 The storage (and search) algorithm is NOT univoque. It simply revealed efficient
 upon this list (without any double values -same value for 2 names- encounted).

 The Data for OS Equates are now outside RosAsm, and computed at launch time.
;;
____________________________________________________________________________________________





[EquatesCurrentDirectory: B$ ? # &MAX_PATH]

;;
  In case user did not re-define the 'Equates.equ' Path, but set the 'Equates.equ' aside
  RosAsm, if he changes the Current Directory when working, and then run, for example [Struct]
  Menu Item, RosAsm would hang when expecting to find out 'Structures.str' in the new Current
  Path. So, we complete the Path here, if needed.
;;

AppendToCurrentDirectory:
    Call GetDirectory EquatesCurrentDirectory
    If eax <> 0
        Mov edi EquatesCurrentDirectory | add edi eax
        Mov al '\'
        On B$edi-1 <> al, stosb
        Mov esi EquatesName | While B$esi <> 0 | movsb | End_While

        Mov esi EquatesCurrentDirectory, edi EquatesName
        While B$esi <> 0 | movsb | End_While
    End_If
ret
____________________________________________________________________________________________

[EquatesIncFileSize: D$ ?
 EquateIncMemory: D$ ?
 EquateIncMemoryPointer: D$ ?]

[H.FindInc: D$ ?]

[FIND_EQU:
 @dwFileAttributes: D$ ?
 @ftCreationTime.dwLowDateTime: D$ ?
 @ftCreationTime.dwHighDateTime: D$ ?
 @ftLastAccessTime.dwLowDateTime: D$ ?
 @ftLastAccessTime.dwHighDateTime: D$ ?
 @ftLastWriteTime.dwLowDateTime: D$ ?
 @ftLastWriteTime.dwHighDateTime: D$ ?
 @nFileSizeHigh: D$ ?
 @nFileSizeLow: D$ ?
 @dwReserved0: D$ ?
 @dwReserved1: D$ ?
 @cFileName: B$ ? # &MAX_PATH
 @cAlternate: B$ ? # 14]

[FullName: B$ ? # &MAX_PATH]

SetFullName:
    pushad
        Mov esi IncludeFileName, edi FullName
        While W$esi <> '*.' | movsb | End_While
        Mov esi FIND_EQU@cFileName
        While B$esi <> EOS | movsb | End_While | movsb
    popad
ret
____________________________________________________________________________________________

OpenEquFiles:
    Call IsEquatesEquThere

    If D$FL.Includes = &TRUE
        Call GetEquFilesMemory
        Call ReadEquatesEqu
        Call ReadOtherEquFiles
        Call CleanEquateIncMemory
    End_If
ret


[EquatesEquFileName: B$ 'Equates.equ' EOS]

SetEquatesEquFileName:
    Mov esi EquatesName, edi IncludeFileName

    While B$esi <> 0 | movsb | End_While
    dec edi
    While B$edi <> '.' | dec edi | End_While

L0: dec edi | cmp B$edi '\' | je L1>
              cmp B$edi ':' | je L1>
              cmp edi IncludeFileName | ja L0<
                jmp L2>
L1: inc edi
L2: Mov esi EquatesEquFileName
    While B$esi <> 0 | movsb | End_While | movsb
ret


IsEquatesEquThere:
    Call SetEquatesEquFileName

    Call 'KERNEL32.FindFirstFileA' IncludeFileName FIND_EQU

    .If eax = &INVALID_HANDLE_VALUE
        Mov D$FL.Includes &FALSE
        Call Help B_U_AsmName, IncludeFilesHelp, BUAsmHlpMessage

    .Else
        Mov D$FL.Includes &TRUE
    .End_If
ret


GetEquFilesMemory:
    Call SetAllIncludeFilesExtension '.equ'

    Call 'KERNEL32.FindFirstFileA' IncludeFileName FIND_EQU | Call SetFullName

    Mov D$H.FindInc eax, D$EquatesIncFileSize 0

L0:     Mov eax D$FIND_EQU@nFileSizeLow | add D$EquatesIncFileSize eax

        Call 'KERNEL32.FindNextFileA' D$H.FindInc FIND_EQU
        Call SetFullName | On eax = &TRUE, jmp L0<

    Call VirtualAlloc EquateIncMemory,
                      D$EquatesIncFileSize

L9: Call 'KERNEL32.FindClose' D$H.FindInc
ret


ReadEquatesEqu:
    Call SetEquatesEquFileName
    Call 'KERNEL32.CreateFileA' IncludeFileName &GENERIC_READ, &FILE_SHARE_READ, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0


    Push eax
        Push eax
            Call 'KERNEL32.GetFileSize' eax, 0 | Mov ecx eax
            If ecx = 0
                Pop eax | jmp L9>
            End_If
            add eax D$EquateIncMemory | Mov D$EquateIncMemoryPointer eax
        Pop eax
        Call 'KERNEL32.ReadFile' eax, D$EquateIncMemory, ecx, NumberOfReadBytes, 0
    Pop eax

L9: Call 'KERNEL32.CloseHandle' eax
ret


IsItEquatesEqu:
    Mov esi FIND_EQU@cFileName, edi EquatesEquFileName
L0: Mov al B$esi, bl B$edi | inc edi | inc esi
    If al = 0
        cmp bl 0
    Else
        or al SPC | or bl SPC | cmp al bl | je L0<
    End_If
ret


ReadOtherEquFiles:
    Call SetAllIncludeFilesExtension '.equ'

    Call 'KERNEL32.FindFirstFileA' IncludeFileName FIND_EQU | Call SetFullName

        Push 0-1

        Mov D$H.FindInc eax

L0:     Call IsItEquatesEqu | je L1>
        Mov eax D$FIND_EQU@nFileSizeLow
        Push eax
            Call 'KERNEL32.CreateFileA' FullName &GENERIC_READ, &FILE_SHARE_READ, 0,
                                        &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
        Push eax

L1:     Call 'KERNEL32.FindNextFileA' D$H.FindInc FIND_EQU
        Call SetFullName | On eax = &TRUE, jmp L0<


        Mov edi D$EquateIncMemoryPointer
L0:     Pop eax                     ; Handle
        On eax = 0-1, jmp L9>
        Pop ecx                     ; Size
        Push edi, ecx, eax
            Call 'KERNEL32.ReadFile' eax, edi, ecx, NumberOfReadBytes, 0
        Pop eax, ecx, edi

        add edi ecx

        On W$edi-2 <> 0A0D, jmp BadEquatesFileEnd
        On W$edi-4 = 0A0D, jmp BadEquatesFileEnd

        Push edi | Call 'KERNEL32.CloseHandle' eax | Pop edi | jmp L0<

L9:     Call 'KERNEL32.FindClose' D$H.FindInc
ret


CleanEquateIncMemory:
    Mov esi D$EquateIncMemory, edi esi, edx esi | add edx D$EquatesIncFileSize

    While esi < edx
        On B$esi = TAB Mov B$esi SPC
        inc esi
    End_While

    Mov esi edi

    .While esi < edx
        lodsb | stosb
        If al = SPC
            While B$esi = SPC
                inc esi | dec D$EquatesIncFileSize
            End_While
        End_If
    .End_While
ret

____________________________________________________________________________________________

[NumberOfEquates: D$ ?]

; In factn ot only 'Count Equates', but also verify integrity of File syntax:
; One Symbol UpperCase / One space / One Hexa in RosAsm syntax / One CR/LF.

CountEquates:
    Mov edx D$EquateIncMemory | add edx D$EquatesIncFileSize

    On W$edx-2 <> 0A0D, jmp BadEquatesFileEnd
    On W$edx-4 = 0A0D, jmp BadEquatesFileEnd

    Mov esi D$EquateIncMemory, ecx 0

    .While esi < edx
        Mov ebx esi

        While B$esi > SPC | inc esi | End_While         ; Read Symbol.

        On B$esi <> SPC, jmp BadEquatesFile             ; One single space.

        inc esi | On B$esi <> '0', jmp BadEquatesFile

        While B$esi > SPC | inc esi | End_While         ; One RosAsm syntax Hexa number.

        On W$esi <> 0A0D, jmp BadEquatesFile  ; CR/LF

        add esi 2 | inc ecx
    .End_While

    Mov D$NumberOfEquates ecx
ret

____________________________________________________________________________________________

[BadEquatesFileTitle: B$ 'Bad Equates File' EOS]
[BadEquatesFileMessage: D$ ? # 10]
[BadEquatesFileEndMessage: B$ 'The Equates File must be ended by *one* CR/FL' EOS]

BadEquatesFile:
    Mov esi ebx, edi BadEquatesFileMessage
    While B$esi > SPC | movsb | End_While
    Mov D$edi '...', B$edi+4 0


    Call 'USER32.MessageBoxA' D$H.MainWindow, BadEquatesFileMessage, BadEquatesFileTitle, 0
    Call 'KERNEL32.ExitProcess' 0


BadEquatesFileEnd:

    Call 'USER32.MessageBoxA' D$H.MainWindow, BadEquatesFileEndMessage, BadEquatesFileTitle, 0
    Call 'KERNEL32.ExitProcess' 0
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Functions       ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

[Win32ApiList: D$ ?]

;;
  Tghis List of Functions must be sorted in Alphabetic order. If one Item is
  wrong, all of the downward Item will be ignored, by the scanner.
  
  A simple way to sort a List of Lines, is to use "Ultra-Edit" / [File] / [Sort]
  (using current Option).
;;
[Win32Functions: B$
"ADVANCEDSETUPDIALOG
ADsBuildEnumerator
ADsEnumerateNext
ADsFreeEnumerator
ADsGetLastError
ADsGetObject
ADsOpenObject
ADsSetLastError
AMGetErrorTextA
AMGetWideString
AMovieDllRegisterServer
AMovieDllRegisterServer2
AMovieDllUnregisterServer
AMovieSetupRegisterFilter
AMovieSetupRegisterFilter2
AMovieSetupRegisterServer
AMovieSetupUnregisterServer
AVIBuildFilterA
AVIClearClipboard
AVIFileAddRef
AVIFileCreateStreamA
AVIFileEndRecord
AVIFileExit
AVIFileGetStream
AVIFileInfoA
AVIFileInit
AVIFileOpenA
AVIFileReadData
AVIFileRelease
AVIFileWriteData
AVIGetFromClipboard
AVIMakeCompressedStream
AVIMakeFileFromStreams
AVIMakeStreamFromClipboard
AVIPutFileOnClipboard
AVISaveOptions
AVISaveOptionsFree
AVISaveVA
AVIStreamAddRef
AVIStreamBeginStreaming
AVIStreamCreate
AVIStreamEndStreaming
AVIStreamFindSample
AVIStreamGetFrame
AVIStreamGetFrameClose
AVIStreamGetFrameOpen
AVIStreamInfoA
AVIStreamLength
AVIStreamOpenFromFileA
AVIStreamRead
AVIStreamReadData
AVIStreamReadFormat
AVIStreamRelease
AVIStreamSampleToTime
AVIStreamSetFormat
AVIStreamStart
AVIStreamTimeToSample
AVIStreamWrite
AVIStreamWriteData
AbortDoc
AbortPath
AbortPrinter
AbortRun
AbortSystemShutdownA
AcceptEx
AccessCheck
AccessCheckAndAuditAlarmA
AccessCheckByType
AccessCheckByTypeAndAuditAlarmA
AccessCheckByTypeResultList
AccessCheckByTypeResultListAndAuditAlarmA
AccessNtmsLibraryDoor
AccessibleChildren
AccessibleObjectFromEvent
AccessibleObjectFromPoint
AccessibleObjectFromWindow
AcquireSCMLock
AcsLan
ActivateKeyboardLayout
AddAccessAllowedAce
AddAccessAllowedAceEx
AddAccessAllowedObjectAce
AddAccessDeniedAce
AddAccessDeniedAceEx
AddAccessDeniedObjectAce
AddAce
AddAtomA
AddAuditAccessAce
AddAuditAccessAceEx
AddAuditAccessObjectAce
AddClusterResourceDependency
AddClusterResourceNode
AddConsoleAliasA
AddFontMemResourceEx
AddFontResourceA
AddFontResourceExA
AddFormA
AddInksetInterval
AddJobA
AddMIMEFileTypesPS
AddMiniIconToList
AddMonitorA
AddPenDataHRC
AddPenInputHRC
AddPerMachineConnectionA
AddPointsPenData
AddPortA
AddPortExA
AddPrintProcessorA
AddPrintProvidorA
AddPrinterA
AddPrinterConnectionA
AddPrinterConnectionUI
AddPrinterDriverA
AddPrinterDriverExA
AddTagToGroupOrderListEntry
AddWordsHWL
AdjustTokenGroups
AdjustTokenPrivileges
AdjustWindowRect
AdjustWindowRectEx
AdsBuildVarArrayInt
AdsBuildVarArrayStr
AdsEncodeBinaryData
AdsFreeAdsValues
AdsTypeToPropVariant
AdvancedDocumentPropertiesA
AdvancedSetupDialog
AllocADsMem
AllocADsStr
AllocConsole
AllocateAndInitializeSid
AllocateLocallyUniqueId
AllocateMemory
AllocateNtmsMedia
AllocateZeroedMemory
AlphaBlend
AmpFactorToDB
AngleArc
AnimatePalette
AnimateWindow
AnyPopup
AppCleanup
AppendMenuA
AppendStringToMultiSz
Arc
ArcTo
AreAllAccessesGranted
AreAnyAccessesGranted
AreFileApisANSI
Arith_Close
Arith_Decode_Bits
Arith_Init
ArrangeIconicWindows
AssertFail
AssignProcessToJobObject
AssociateColorProfileWithDeviceA
AttachThreadInput
BSTR_UserFree
BSTR_UserMarshal
BSTR_UserSize
BSTR_UserUnmarshal
BackupEventLogA
BackupRead
BackupSeek
BackupWrite
BaseAttachCompleteThunk
Beep
BeginDeferWindowPos
BeginPaint
BeginPath
BeginUpdateResourceA
BindAsyncMoniker
BindIFilterFromStorage
BindIFilterFromStream
BindImage
BindImageEx
BindMoniker
BitBlt
BlockInput
BoundingRectFromPoints
BringWindowToTop
BroadcastSystemMessageA
BstrFromVector
BuildCommDCBA
BuildCommDCBAndTimeoutsA
BuildDisplayTable
BuildExplicitAccessWithNameA
BuildImpersonateExplicitAccessWithNameA
BuildImpersonateTrusteeA
BuildSecurityDescriptorA
BuildTrusteeWithNameA
BuildTrusteeWithSidA
CElapsed
CIBuildQueryNode
CIBuildQueryTree
CICreateCommand
CIMakeICommand
CIRestrictionToFullTree
CITextToFullTree
CITextToSelectTree
CLIENT_ALLOC
CLIENT_FREE
CLIPFORMAT_UserFree
CLIPFORMAT_UserMarshal
CLIPFORMAT_UserSize
CLIPFORMAT_UserUnmarshal
CLSIDFromProgID
CLSIDFromString
CSUMCompute
CStdStubBuffer_AddRef
CStdStubBuffer_Connect
CStdStubBuffer_CountRefs
CStdStubBuffer_DebugServerQueryInterface
CStdStubBuffer_DebugServerRelease
CStdStubBuffer_Disconnect
CStdStubBuffer_Invoke
CStdStubBuffer_IsIIDSupported
CStdStubBuffer_QueryInterface
CallMsgFilterA
CallNamedPipeA
CallNextHookEx
CallWindowProcA
Callback12
Callback16
Callback20
Callback24
Callback28
Callback32
Callback36
Callback4
Callback40
Callback44
Callback48
Callback52
Callback56
Callback60
Callback64
Callback8
CanResourceBeDependent
CancelDC
CancelIo
CancelNtmsLibraryRequest
CancelNtmsOperatorRequest
CancelOverlappedAccess
CancelWaitableTimer
CaptureAndConvertAnsiArg
CaptureStringArg
CascadeChildWindows
CascadeWindows
CbOfEncoded
CchOfEncoding
CenterDialog
CenterWindowRelativeToParent
CertAddCRLContextToStore
CertAddCTLContextToStore
CertAddCertificateContextToStore
CertAddEncodedCRLToStore
CertAddEncodedCTLToStore
CertAddEncodedCertificateToStore
CertAddEncodedCertificateToSystemStoreA
CertAddEnhancedKeyUsageIdentifier
CertAddSerializedElementToStore
CertAlgIdToOID
CertCloseStore
CertCompareCertificate
CertCompareCertificateName
CertCompareIntegerBlob
CertComparePublicKeyInfo
CertCreateCRLContext
CertCreateCTLContext
CertCreateCertificateContext
CertDeleteCRLFromStore
CertDeleteCTLFromStore
CertDeleteCertificateFromStore
CertDuplicateCRLContext
CertDuplicateCTLContext
CertDuplicateCertificateContext
CertDuplicateStore
CertEnumCRLContextProperties
CertEnumCTLContextProperties
CertEnumCTLsInStore
CertEnumCertificateContextProperties
CertEnumCertificatesInStore
CertFindAttribute
CertFindCTLInStore
CertFindCertificateInStore
CertFindExtension
CertFindRDNAttr
CertFindSubjectInCTL
CertFreeCRLContext
CertFreeCTLContext
CertFreeCertificateContext
CertGetCRLContextProperty
CertGetCRLFromStore
CertGetCTLContextProperty
CertGetCertificateContextProperty
CertGetEnhancedKeyUsage
CertGetIntendedKeyUsage
CertGetIssuerCertificateFromStore
CertGetSubjectCertificateFromStore
CertIsRDNAttrsInCertificateName
CertNameToStrA
CertOIDToAlgId
CertOpenStore
CertOpenSystemStoreA
CertRDNValueToStrA
CertRemoveEnhancedKeyUsageIdentifier
CertSaveStore
CertSerializeCRLStoreElement
CertSerializeCTLStoreElement
CertSerializeCertificateStoreElement
CertSetCRLContextProperty
CertSetCTLContextProperty
CertSetCertificateContextProperty
CertSetEnhancedKeyUsage
CertStrToNameA
CertVerifyCRLRevocation
CertVerifyCRLTimeValidity
CertVerifyCTLUsage
CertVerifyRevocation
CertVerifySubjectCertificateContext
CertVerifyTimeValidity
CertVerifyValidityNesting
ChangeClipboardChain
ChangeClusterResourceGroup
ChangeDisplaySettingsA
ChangeDisplaySettingsExA
ChangeIdleRoutine
ChangeMenuA
ChangeServiceConfig2A
ChangeServiceConfigA
ChangeSupervisorPassword
CharLowerA
CharLowerBuffA
CharNextA
CharNextExA
CharPrevA
CharPrevExA
CharToOemA
CharToOemBuffA
CharUpperA
CharUpperBuffA
CharacterToSymbol
CheckBitmapBits
CheckColors
CheckColorsInGamut
CheckDlgButton
CheckEscapesA
CheckMenuItem
CheckMenuRadioItem
CheckRadioButton
CheckSumMappedFile
ChildWindowFromPoint
ChildWindowFromPointEx
ChooseColorA
ChooseFontA
ChoosePixelFormat
Chord
ChrCmpIA
CleanNtmsDrive
CleanUp
ClearCommBreak
ClearCommError
ClearCustData
ClearEventLogA
ClientToScreen
ClipCursor
CloseClipboard
CloseCluster
CloseClusterGroup
CloseClusterNetInterface
CloseClusterNetwork
CloseClusterNode
CloseClusterNotifyPort
CloseClusterResource
CloseColorProfile
CloseConsoleHandle
CloseDesktop
CloseDriver
CloseEnhMetaFile
CloseEventLog
CloseFigure
CloseHandle
CloseIMsgSession
CloseMetaFile
CloseNtmsNotification
CloseNtmsSession
ClosePrinter
CloseProfileUserMapping
CloseRaw
CloseServiceHandle
CloseWindow
CloseWindowStation
ClusWorkerCheckTerminate
ClusWorkerCreate
ClusWorkerStart
ClusWorkerTerminate
ClusterCloseEnum
ClusterEnum
ClusterGroupCloseEnum
ClusterGroupControl
ClusterGroupEnum
ClusterGroupOpenEnum
ClusterNetInterfaceControl
ClusterNetworkCloseEnum
ClusterNetworkControl
ClusterNetworkEnum
ClusterNetworkOpenEnum
ClusterNodeCloseEnum
ClusterNodeControl
ClusterNodeEnum
ClusterNodeOpenEnum
ClusterOpenEnum
ClusterRegCloseKey
ClusterRegCreateKey
ClusterRegDeleteKey
ClusterRegDeleteValue
ClusterRegEnumKey
ClusterRegEnumValue
ClusterRegGetKeySecurity
ClusterRegOpenKey
ClusterRegQueryInfoKey
ClusterRegQueryValue
ClusterRegSetKeySecurity
ClusterRegSetValue
ClusterResourceCloseEnum
ClusterResourceControl
ClusterResourceEnum
ClusterResourceOpenEnum
ClusterResourceTypeControl
ClusterSplClose
ClusterSplIsAlive
ClusterSplOpen
CmdBatNotification
CoAddRefServerProcess
CoBuildVersion
CoCancelCall
CoCopyProxy
CoCreateFreeThreadedMarshaler
CoCreateGuid
CoCreateInstance
CoCreateInstanceEx
CoDisconnectObject
CoDosDateTimeToFileTime
CoFileTimeNow
CoFileTimeToDosDateTime
CoFreeAllLibraries
CoFreeLibrary
CoFreeUnusedLibraries
CoGetCallContext
CoGetCallerTID
CoGetCancelObject
CoGetClassAccess
CoGetClassInfo
CoGetClassObject
CoGetClassObjectFromURL
CoGetCurrentLogicalThreadId
CoGetCurrentProcess
CoGetInstanceFromFile
CoGetInstanceFromIStorage
CoGetInterfaceAndReleaseStream
CoGetMalloc
CoGetMarshalSizeMax
CoGetObject
CoGetPSClsid
CoGetPublishedAppInfo
CoGetStandardMarshal
CoGetState
CoGetStaticMarshal
CoGetStaticObjectPacket
CoGetStdMarshalEx
CoGetTIDFromIPID
CoGetTreatAsClass
CoImpersonateClient
CoInitialize
CoInitializeEx
CoInitializeSecurity
CoInstall
CoInternetCombineUrl
CoInternetCompareUrl
CoInternetCreateSecurityManager
CoInternetCreateZoneManager
CoInternetGetProtocolFlags
CoInternetGetSecurityUrl
CoInternetGetSession
CoInternetParseUrl
CoInternetQueryInfo
CoIsHandlerConnected
CoIsOle1Class
CoLoadLibrary
CoLockObjectExternal
CoMarshalHresult
CoMarshalInterThreadInterfaceInStream
CoMarshalInterface
CoQueryAuthenticationServices
CoQueryClientBlanket
CoQueryProxyBlanket
CoQueryReleaseObject
CoRegisterChannelHook
CoRegisterClassObject
CoRegisterMallocSpy
CoRegisterMessageFilter
CoRegisterPSClsid
CoRegisterSurrogate
CoReleaseMarshalData
CoReleaseServerProcess
CoResumeClassObjects
CoRevertToSelf
CoRevokeClassObject
CoRevokeMallocSpy
CoSetCancelObject
CoSetProxyBlanket
CoSetState
CoSuspendClassObjects
CoSwitchCallContext
CoTaskMemAlloc
CoTaskMemFree
CoTaskMemRealloc
CoTestCancel
CoTreatAsClass
CoUninitialize
CoUnmarshalHresult
CoUnmarshalInterface
ColorCorrectPalette
ColorMatchToTarget
CombineRgn
CombineTransform
CommConfigDialogA
CommDlgExtendedError
CommitUrlCacheEntryA
CompareFileTime
CompareStringA
ComponentFromIndex
CompressPenData
ConcatenatePaths
ConfigHREC
ConfigurePortA
ConnectNamedPipe
ConnectToPrinterDlg
ConsoleMenuControl
ContainsPalette
ContinueDebugEvent
ControlService
ConvertAccessToSecurityDescriptorA
ConvertAnsiDevModeToUnicodeDevmode
ConvertDefaultLocale
ConvertSecurityDescriptorToAccessA
ConvertSecurityDescriptorToAccessNamedA
ConvertThreadToFiber
ConvertToAutoInheritPrivateObjectSecurity
ConvertUnicodeDevModeToAnsiDevmode
CopyAcceleratorTableA
CopyBindInfo
CopyEnhMetaFileA
CopyFileA
CopyFileExA
CopyIcon
CopyImage
CopyLZFile
CopyMetaFileA
CopyPdb
CopyRect
CopySid
CopyStgMedium
CorrectWriting
CountClipboardFormats
CreateAcceleratorTableA
CreateAntiMoniker
CreateAsyncBindCtx
CreateAsyncBindCtxEx
CreateAudioMediaType
CreateBindCtx
CreateBindProtocol
CreateBitmap
CreateBitmapIndirect
CreateBrushIndirect
CreateCIPalette
CreateCaret
CreateClassMoniker
CreateClusterGroup
CreateClusterNotifyPort
CreateClusterResource
CreateClusterResourceType
CreateColorSpaceA
CreateColorTransformA
CreateCompatibleBitmap
CreateCompatibleDC
CreateCompatibleHRC
CreateConsoleScreenBuffer
CreateCursor
CreateDCA
CreateDIBPatternBrush
CreateDIBPatternBrushPt
CreateDIBSection
CreateDIBitmap
CreateDataAdviseHolder
CreateDataCache
CreateDesktopA
CreateDeviceLinkProfile
CreateDialogIndirectParamA
CreateDialogParamA
CreateDirectoryA
CreateDirectoryExA
CreateDiscardableBitmap
CreateDispTypeInfo
CreateEditableStream
CreateEllipticRgn
CreateEllipticRgnIndirect
CreateEnhMetaFileA
CreateErrorInfo
CreateEventA
CreateFiber
CreateFileA
CreateFileMappingA
CreateFileMoniker
CreateFileU
CreateFontA
CreateFontIndirectA
CreateFontIndirectExA
CreateFormatEnumerator
CreateGenericComposite
CreateHWL
CreateHalftonePalette
CreateHardLinkA
CreateHatchBrush
CreateICA
CreateILockBytesOnHGlobal
CreateIProp
CreateIcon
CreateIconFromResource
CreateIconFromResourceEx
CreateIconIndirect
CreateInkset
CreateInksetHRCRESULT
CreateIoCompletionPort
CreateItemMoniker
CreateJobObjectA
CreateMDIWindowA
CreateMailslotA
CreateMappedBitmap
CreateMemoryAllocator
CreateMenu
CreateMetaFileA
CreateMultiProfileTransform
CreateMutexA
CreateNamedPipeA
CreateNtmsMediaPoolA
CreateOleAdviseHolder
CreatePalette
CreatePatternBrush
CreatePen
CreatePenDataEx
CreatePenDataHRC
CreatePenDataRegion
CreatePenIndirect
CreatePipe
CreatePointerMoniker
CreatePolyPolygonRgn
CreatePolygonRgn
CreatePopupMenu
CreatePosPassThru
CreatePrinterIC
CreatePrivateObjectSecurity
CreatePrivateObjectSecurityEx
CreateProcessA
CreateProcessAsUserA
CreateProfileFromLogColorSpaceA
CreatePropertySheetPageA
CreateRGBPalette
CreateRectRgn
CreateRectRgnIndirect
CreateRemoteThread
CreateRestrictedToken
CreateRoundRectRgn
CreateScalableFontResourceA
CreateSemaphoreA
CreateServiceA
CreateSocketPort
CreateSolidBrush
CreateStatusWindowA
CreateStdAccessibleObject
CreateStdDispaôch
CreateStdProgressIndicator
CreateStreamOnHGlobal
CreateTable
CreateTapePartition
CreateTestList
CreateThread
CreateToolbar
CreateToolbarEx
CreateToolhelp32Snapshot
CreateTypeLib
CreateTypeLib2
CreateURLMoniker
CreateUpDownControl
CreateUrlCacheContainerA
CreateUrlCacheEntryA
CreateUrlCacheGroup
CreateVirtualBuffer
CreateWaitableTimerA
CreateWindowExA
CreateWindowStationA
CryptAcquireContextA
CryptAcquireContextU
CryptContextAddRef
CryptCreateHash
CryptDecodeMessage
CryptDecodeObject
CryptDecrypt
CryptDecryptAndVerifyMessageSignature
CryptDecryptMessage
CryptDeriveKey
CryptDestroyHash
CryptDestroyKey
CryptDuplicateHash
CryptDuplicateKey
CryptEncodeObject
CryptEncrypt
CryptEncryptMessage
CryptEnumOIDFunction
CryptEnumProviderTypesA
CryptEnumProvidersA
CryptExportKey
CryptExportPublicKeyInfo
CryptExportPublicKeyInfoEx
CryptFormatObject
CryptFreeOIDFunctionAddress
CryptGenKey
CryptGenRandom
CryptGetDefaultOIDDllList
CryptGetDefaultOIDFunctionAddress
CryptGetDefaultProviderA
CryptGetHashParam
CryptGetKeyParam
CryptGetMessageCertificates
CryptGetMessageSignerCount
CryptGetOIDFunctionAddress
CryptGetOIDFunctionValue
CryptGetProvParam
CryptGetUserKey
CryptHashCertificate
CryptHashData
CryptHashMessage
CryptHashPublicKeyInfo
CryptHashSessionKey
CryptHashToBeSigned
CryptImportKey
CryptImportPublicKeyInfo
CryptImportPublicKeyInfoEx
CryptInitOIDFunctionSet
CryptInstallOIDFunctionAddress
CryptLoadSip
CryptMsgCalculateEncodedLength
CryptMsgClose
CryptMsgControl
CryptMsgCountersign
CryptMsgCountersignEncoded
CryptMsgEncodeAndSignCTL
CryptMsgGetAndVerifySigner
CryptMsgGetParam
CryptMsgOpenToDecode
CryptMsgOpenToEncode
CryptMsgSignCTL
CryptMsgUpdate
CryptMsgVerifyCountersignatureEncoded
CryptRegisterDefaultOIDFunction
CryptRegisterOIDFunction
CryptReleaseContext
CryptSIPRetrieveSubjectGuid
CryptSetHashParam
CryptSetKeyParam
CryptSetOIDFunctionValue
CryptSetProvParam
CryptSetProviderA
CryptSetProviderExA
CryptSetProviderU
CryptSignAndEncodeCertificate
CryptSignAndEncryptMessage
CryptSignCertificate
CryptSignHashA
CryptSignHashU
CryptSignMessage
CryptSignMessageWithKey
CryptUnregisterDefaultOIDFunction
CryptUnregisterOIDFunction
CryptVerifyCertificateSignature
CryptVerifyDetachedMessageHash
CryptVerifyDetachedMessageSignature
CryptVerifyMessageHash
CryptVerifyMessageSignature
CryptVerifyMessageSignatureWithKey
CryptVerifySignatureA
CryptVerifySignatureU
CursorLibTransact
D3DRMColorGetAlpha
D3DRMColorGetBlue
D3DRMColorGetGreen
D3DRMColorGetRed
D3DRMCreateColorRGBA
D3DRMMatrixFromQuaternion
D3DRMQuaternionFromRotation
D3DRMQuaternionMultiply
D3DRMQuaternionSlerp
D3DRMVectorAdd
D3DRMVectorCrossProduct
D3DRMVectorDotProduct
D3DRMVectorModulus
D3DRMVectorNormalize
D3DRMVectorRandom
D3DRMVectorReflect
D3DRMVectorRotate
D3DRMVectorScale
D3DRMVectorSubtract
DBToAmpFactor
DComp_Close
DComp_DecompressBlock
DComp_Init
DComp_Reset
DComp_Ring_Close
DComp_Ring_Init
DComp_Ring_Load
DComp_Ring_Reset
DDHAL32_VidMemAlloc
DDHAL32_VidMemFree
DDInternalLock
DDInternalUnlock
DDMGetPhonebookInfo
DEVICECAPABILITIES
DEVICEMODE
DLLInit
DPtoLP
DPtoTP
DSoundHelp
DceErrorInqTextA
DdeAbandonTransaction
DdeAccessData
DdeAddData
DdeClientTransaction
DdeCmpStringHandles
DdeConnect
DdeConnectList
DdeCreateDataHandle
DdeCreateStringHandleA
DdeDisconnect
DdeDisconnectList
DdeEnableCallback
DdeFreeDataHandle
DdeFreeStringHandle
DdeGetData
DdeGetLastError
DdeGetQualityOfService
DdeImpersonateClient
DdeInitializeA
DdeKeepStringHandle
DdeNameService
DdePostAdvise
DdeQueryConvInfo
DdeQueryNextServer
DdeQueryStringA
DdeReconnect
DdeSetQualityOfService
DdeSetUserHandle
DdeUnaccessData
DdeUninitialize
DeallocateNtmsMedia
DebugActiveProcess
DebugBreak
DecommissionNtmsMedia
DecryptFileA
DefDlgProcA
DefDriverProc
DefFrameProcA
DefMDIChildProcA
DefScreenSaverProc
DefWindowProcA
DefaultHandleExpose
DefaultHandleReshape
DeferWindowPos
DefineDosDeviceA
DeinitMapiUtil
DelayPaletteRealization
DelayedMove
DeleteAce
DeleteAtom
DeleteClusterGroup
DeleteClusterResource
DeleteClusterResourceType
DeleteColorSpace
DeleteColorTransform
DeleteCriticalSection
DeleteDC
DeleteEnhMetaFile
DeleteFiber
DeleteFileA
DeleteFormA
DeleteIE3Cache
DeleteMenu
DeleteMetaFile
DeleteMonitorA
DeleteNtmsLibrary
DeleteNtmsMedia
DeleteNtmsMediaPool
DeleteObject
DeletePerMachineConnectionA
DeletePortA
DeletePrintProcessorA
DeletePrintProvidorA
DeletePrinter
DeletePrinterConnectionA
DeletePrinterDataA
DeletePrinterDataExA
DeletePrinterDriverA
DeletePrinterDriverExA
DeletePrinterIC
DeletePrinterKeyA
DeleteService
DeleteSocketPort
DeleteUrlCacheContainerA
DeleteUrlCacheEntry
DeleteUrlCacheGroup
DelimStringToMultiSz
DeregisterEventSource
DeregisterIdleRoutine
DescribePixelFormat
DestroyAcceleratorTable
DestroyCaret
DestroyCursor
DestroyHRC
DestroyHRCRESULT
DestroyHWL
DestroyIcon
DestroyInkset
DestroyMenu
DestroyPenData
DestroyPrivateObjectSecurity
DestroyPropertySheetPage
DestroyTextFileReadBuffer
DestroyThisWindow
DestroyWindow
DevQueryPrint
DevQueryPrintEx
DeviceCapabilitiesA
DeviceCapabilitiesExA
DeviceIoControl
DeviceMode
DevicePropertySheets
DialogBoxIndirectParamA
DialogBoxParamA
DibNumColors
Direct3DRMCreate
DirectDrawCreate
DirectDrawCreateClipper
DirectDrawCreateFromDevice
DirectDrawCreateFromDeviceEx
DirectDrawEnumerateA
DirectInputCreateA
DirectPlayCreate
DirectPlayEnumerateA
DirectPlayLobbyCreateA
DirectSoundCaptureCreate
DirectSoundCaptureEnumerateA
DirectSoundCreate
DirectSoundEnumerateA
DirectXDeviceDriverSetupA
DirectXLoadString
DirectXRegisterApplicationA
DirectXSetupA
DirectXSetupCallback
DirectXSetupGetVersion
DirectXSetupIsJapan
DirectXSetupIsJapanNec
DirectXSetupSetCallback
DirectXUnRegisterApplication
DisableNtmsObject
DisableThreadLibraryCalls
DisassociateColorProfileFromDeviceA
DisconnectNamedPipe
DismountNtmsDrive
DismountNtmsMedia
DispCallFunc
DispGetIDsOfNames
DispGetParam
DispInvoke
DispatchMessageA
DlcCallDriver
DlgDirListA
DlgDirListComboBoxA
DlgDirSelectComboBoxExA
DlgDirSelectExA
DllCanUnloadNow
DllDebugObjectRPCHook
DllEntryPoint
DllGetClassObject
DllInitialize
DoChangePw
DoConfigBox
DoDefaultPenInput
DoDragDrop
DoEnvironmentSubstA
DoInstallActionWithParams
DoPasswordCheck
DoSaverPreview
DoScreenSave
DocumentEvent
DocumentPropertiesA
DocumentPropertySheets
DoesUserHavePrivilege
DosDateTimeToFileTime
DosDateTimeToVariantTime
DragAcceptFiles
DragDetect
DragFinish
DragObject
DragQueryFileA
DragQueryPoint
DrawAnimatedRects
DrawBitmap
DrawCaption
DrawDibBegin
DrawDibChangePalette
DrawDibClose
DrawDibDraw
DrawDibEnd
DrawDibGetBuffer
DrawDibGetPalette
DrawDibOpen
DrawDibProfileDisplay
DrawDibRealize
DrawDibSetPalette
DrawDibStart
DrawDibStop
DrawDibTime
DrawEdge
DrawEscape
DrawFocusRect
DrawFrame
DrawFrameControl
DrawIcon
DrawIconEx
DrawInsert
DrawMenuBar
DrawPenDataEx
DrawStateA
DrawStatusTextA
DrawTextA
DrawTextExA
DriverCallback
DrvGetModuleHandle
DsGetDcClose
DsGetDcNameA
DsGetDcNext
DsGetDcOpen
DsGetSiteNameA
DsValidateSubnetNameA
DummyEntry
DuplicateConsoleHandle
DuplicateHandle
DuplicateIcon
DuplicatePenData
DuplicateString
DuplicateToken
DuplicateTokenEx
EXTDEVICEMODE
EditStreamClone
EditStreamCopy
EditStreamCut
EditStreamPaste
EditStreamSetInfoA
EditStreamSetNameA
EditWndProc
EjectNtmsCleaner
EjectNtmsMedia
ElfBackupEventLogFileA
ElfChangeNotify
ElfClearEventLogFileA
ElfCloseEventLog
ElfDeregisterEventSource
ElfNumberOfRecords
ElfOldestRecord
ElfOpenBackupEventLogA
ElfOpenEventLogA
ElfReadEventLogA
ElfRegisterEventSourceA
ElfReportEventA
EliminateSubKey
Ellipse
EmptyClipboard
EnableEUDC
EnableGestureSetHRC
EnableHookObject
EnableIdleRoutine
EnableMenuItem
EnableNtmsObject
EnablePrivilege
EnableScrollBar
EnableSystemDictionaryHRC
EnableWindow
EncodeID
EncryptFileA
EndDeferWindowPos
EndDialog
EndDoc
EndDocPrinter
EndMenu
EndPage
EndPagePrinter
EndPaint
EndPath
EndPenInputHRC
EndUpdateResourceA
EnterCriticalSection
EnumCalendarInfoA
EnumCalendarInfoExA
EnumChildWindows
EnumClipboardFormats
EnumColorProfilesA
EnumDateFormatsA
EnumDateFormatsExA
EnumDependentServicesA
EnumDesktopWindows
EnumDesktopsA
EnumDisplayMonitors
EnumDisplaySettingsA
EnumDisplaySettingsExA
EnumEnhMetaFile
EnumFontFamiliesA
EnumFontFamiliesExA
EnumFontsA
EnumFormsA
EnumICMProfilesA
EnumJobsA
EnumMetaFile
EnumMonitorsA
EnumObjects
EnumPerMachineConnectionsA
EnumPortsA
EnumPrintProcessorDatatypesA
EnumPrintProcessorsA
EnumPrinterDataA
EnumPrinterDataExA
EnumPrinterDriversA
EnumPrinterKeyA
EnumPrinterPropertySheets
EnumPrintersA
EnumPropsA
EnumPropsExA
EnumProtocolsA
EnumResourceLanguagesA
EnumResourceNamesA
EnumResourceTypesA
EnumServicesStatusA
EnumSystemCodePagesA
EnumSystemLocalesA
EnumThreadWindows
EnumTimeFormatsA
EnumWindowStationsA
EnumWindows
EnumerateLoadedModules
EnumerateMonitors
EnumerateNtmsObject
EqualPrefixSid
EqualRect
EqualRgn
EqualSid
EraseTape
ErfSetCodes
Escape
EscapeCommFunction
EvictClusterNode
ExcludeClipRect
ExcludeUpdateRgn
ExitProcess
ExitThread
ExitVDM
ExitWindowsEx
ExpandEnvironmentStringsA
ExportNtmsDatabase
ExpungeConsoleCommandHistoryA
ExtCreatePen
ExtCreateRegion
ExtDeviceMode
ExtEscape
ExtFloodFill
ExtSelectClipRgn
ExtTextOutA
ExtendVirtualBuffer
ExtensionPropSheetPageProc
Extract
ExtractAssociatedIconA
ExtractAssociatedIconExA
ExtractIconA
ExtractIconExA
ExtractIconResInfoA
ExtractPenDataPoints
ExtractPenDataStrokes
FAbortCheck
FBadColumnSet
FBadEntryList
FBadProp
FBadPropTag
FBadRestriction
FBadRglpNameID
FBadRglpszA
FBadRow
FBadRowSet
FBadSortOrderSet
FBinFromHex
FDIGetDataBlock
FDIGetFile
FDIReadCFDATAEntry
FDIReadCFFILEEntry
FDIReadPSZ
FDecodeID
FEqualNames
FORWARD_FUNCTION
FPropCompareProp
FPropContainsProp
FPropExists
FailClusterResource
FatalAppExitA
FatalExit
FileExists
FileTimeToDosDateTime
FileTimeToLocalFileTime
FileTimeToSystemTime
FillConsoleOutputAttribute
FillConsoleOutputCharacterA
FillPath
FillRect
FillRgbPaletteEntries
FillRgn
FindAtomA
FindBestPixelFormat
FindClose
FindCloseChangeNotification
FindClosePrinterChangeNotification
FindCloseUrlCache
FindDebugInfoFile
FindExactPixelFormat
FindExeDlgProc
FindExecutableA
FindExecutableImage
FindFileDir
FindFirstChangeNotificationA
FindFirstFileA
FindFirstFileExA
FindFirstFreeAce
FindFirstPrinterChangeNotification
FindFirstUrlCacheContainerA
FindFirstUrlCacheEntryA
FindFirstUrlCacheEntryExA
FindMediaType
FindMediaTypeClass
FindMimeFromData
FindNextChangeNotification
FindNextFileA
FindNextPrinterChangeNotification
FindNextUrlCacheContainerA
FindNextUrlCacheEntryA
FindNextUrlCacheEntryExA
FindPixelFormat
FindResourceA
FindResourceExA
FindTextA
FindWindowA
FindWindowExA
FixBrushOrgEx
FlashWindow
FlatSB_EnableScrollBar
FlatSB_GetScrollInfo
FlatSB_GetScrollPos
FlatSB_GetScrollProp
FlatSB_GetScrollRange
FlatSB_SetScrollInfo
FlatSB_SetScrollPos
FlatSB_SetScrollProp
FlatSB_SetScrollRange
FlatSB_ShowScrollBar
FlattenPath
FloodFill
FlushConsoleInputBuffer
FlushFileBuffers
FlushInstructionCache
FlushPalette
FlushViewOfFile
FmtIdToPropStgName
FoldStringA
ForceRedraw
FormatCharDlgProc
FormatMessageA
FrameRect
FrameRgn
FreeADsMem
FreeADsStr
FreeBSTR
FreeConsole
FreeDDElParam
FreeEnvironmentStringsA
FreeIconList
FreeLibrary
FreeLibraryAndExitThread
FreeMemory
FreePadrlist
FreePrinterNotifyInfo
FreePropVariantArray
FreeProws
FreeResource
FreeSid
FreeStringArray
FreeUrlCacheSpaceA
FreeVirtualBuffer
FtAdcFt
FtAddFt
FtDivFtBogus
FtMulDw
FtMulDwDw
FtNegFt
FtSubFt
FtgRegisterIdleRoutine
FtpCreateDirectoryA
FtpDeleteFileA
FtpFindFirstFileA
FtpGetCurrentDirectoryA
FtpGetFileA
FtpOpenFileA
FtpPutFileA
FtpRemoveDirectoryA
FtpRenameFileA
FtpSetCurrentDirectoryA
FwBindFwInterfaceToAdapter
FwConnectionRequestFailed
FwCreateInterface
FwDeleteInterface
FwDisableFwInterface
FwEnableFwInterface
FwGetInterface
FwGetNotificationResult
FwGetStaticNetbiosNames
FwNotifyConnectionRequest
FwSetInterface
FwSetStaticNetbiosNames
FwStart
FwStop
FwUnbindFwInterfaceFromAdapter
FwUpdateRouteTable
GdiComment
GdiDeleteSpoolFileHandle
GdiEndDocEMF
GdiEndPageEMF
GdiFlush
GdiGetBatchLimit
GdiGetDC
GdiGetDevmodeForPage
GdiGetPageCount
GdiGetPageHandle
GdiGetSpoolFileHandle
GdiPlayDCScript
GdiPlayEMF
GdiPlayJournal
GdiPlayPageEMF
GdiPlayPrivatePageEMF
GdiPlayScript
GdiResetDCEMF
GdiSetBatchLimit
GdiStartDocEMF
GdiStartPageEMF
GenerateConsoleCtrlEvent
GenerateCopyFilePaths
GetACP
GetAcceptExSockaddrs
GetAccessPermissionsForObjectA
GetAce
GetAclInformation
GetActiveObject
GetActiveWindow
GetAddressByNameA
GetAlphabetHRC
GetAlphabetPriorityHRC
GetAltMonthNames
GetAltTabInfoA
GetAlternateWordsHRCRESULT
GetAncestor
GetArcDirection
GetAspectRatioFilterEx
GetAsyncKeyState
GetAtomNameA
GetAttribIMsgOnIStg
GetAuditedPermissionsFromAclA
GetAutoTests
GetBinaryTypeA
GetBitCount
GetBitmapBits
GetBitmapDimensionEx
GetBitmapFormatSize
GetBitmapPalette
GetBitmapSize
GetBitmapSubtype
GetBkColor
GetBkMode
GetBoundsRect
GetBoxMappingHRCRESULT
GetBoxResultsHRC
GetBrushOrgEx
GetCMMInfo
GetCPInfo
GetCPInfoExA
GetCapture
GetCaretBlinkTime
GetCaretPos
GetCharABCWidthsA
GetCharABCWidthsFloatA
GetCharABCWidthsI
GetCharWidth32A
GetCharWidthA
GetCharWidthFloatA
GetCharWidthI
GetCharacterPlacementA
GetClassFile
GetClassFileOrMime
GetClassInfoA
GetClassInfoExA
GetClassLongA
GetClassNameA
GetClassURL
GetClassWord
GetClientRect
GetClipBox
GetClipCursor
GetClipRgn
GetClipboardData
GetClipboardFormatNameA
GetClipboardOwner
GetClipboardSequenceNumber
GetClipboardViewer
GetClusterGroupKey
GetClusterGroupState
GetClusterInformation
GetClusterKey
GetClusterNetInterface
GetClusterNetInterfaceKey
GetClusterNetInterfaceState
GetClusterNetworkId
GetClusterNetworkKey
GetClusterNetworkState
GetClusterNodeId
GetClusterNodeKey
GetClusterNodeState
GetClusterNotify
GetClusterQuorumResource
GetClusterResourceKey
GetClusterResourceNetworkName
GetClusterResourceState
GetClusterResourceTypeKey
GetColorAdjustment
GetColorDirectoryA
GetColorProfileElement
GetColorProfileElementTag
GetColorProfileFromHandle
GetColorProfileHeader
GetColorSpace
GetComboBoxInfo
GetCommConfig
GetCommMask
GetCommModemStatus
GetCommProperties
GetCommState
GetCommTimeouts
GetCommandLineA
GetCompressedFileSizeA
GetComputerNameA
GetConsoleAliasA
GetConsoleAliasExesA
GetConsoleAliasExesLengthA
GetConsoleAliasesA
GetConsoleAliasesLengthA
GetConsoleCP
GetConsoleCommandHistoryA
GetConsoleCommandHistoryLengthA
GetConsoleCursorInfo
GetConsoleDisplayMode
GetConsoleFontInfo
GetConsoleFontSize
GetConsoleHardwareState
GetConsoleInputExeNameA
GetConsoleInputWaitHandle
GetConsoleKeyboardLayoutNameA
GetConsoleMode
GetConsoleOutputCP
GetConsoleScreenBufferInfo
GetConsoleTitleA
GetConsoleWindow
GetConvertStg
GetCount
GetCountColorProfileElements
GetCurrencyFormatA
GetCurrentConsoleFont
GetCurrentDirectoryA
GetCurrentHwProfileA
GetCurrentObject
GetCurrentPositionEx
GetCurrentProcess
GetCurrentProcessId
GetCurrentThread
GetCurrentThreadId
GetCursor
GetCursorInfo
GetCursorPos
GetDC
GetDCBrushColor
GetDCEx
GetDCOrgEx
GetDCPenColor
GetDIBColorTable
GetDIBits
GetDateFormatA
GetDefaultCommConfigA
GetDefaultPrinterA
GetDesktopWindow
GetDeviceCaps
GetDeviceGammaRamp
GetDevicePowerState
GetDialogBaseUnits
GetDiskFreeSpaceA
GetDiskFreeSpaceExA
GetDlgCtrlID
GetDlgItem
GetDlgItemInt
GetDlgItemTextA
GetDocumentBitStg
GetDoubleClickTime
GetDriveTypeA
GetDriverModuleHandle
GetEffectiveClientRect
GetEffectiveRightsFromAclA
GetElapsedTime
GetEnhMetaFileA
GetEnhMetaFileBits
GetEnhMetaFileDescriptionA
GetEnhMetaFileHeader
GetEnhMetaFilePaletteEntries
GetEnhMetaFilePixelFormat
GetEnvironmentStringsA
GetEnvironmentVariableA
GetErrorInfo
GetExitCodeProcess
GetExitCodeThread
GetExpandedNameA
GetExplicitEntriesFromAclA
GetFileAttributesA
GetFileAttributesExA
GetFileInformationByHandle
GetFileSecurityA
GetFileSize
GetFileTime
GetFileTitleA
GetFileType
GetFileVersionInfoA
GetFileVersionInfoSizeA
GetFilters
GetFocus
GetFontAssocStatus
GetFontData
GetFontLanguageInfo
GetFontUnicodeRanges
GetForegroundWindow
GetFormA
GetFullPathNameA
GetGUIThreadInfo
GetGlyphIndicesA
GetGlyphOutlineA
GetGraphicsMode
GetGuiResources
GetGuideHRC
GetHGlobalFromILockBytes
GetHGlobalFromStream
GetHRECFromHRC
GetHandleInformation
GetHookInterface
GetHotspotsHRCRESULT
GetICMProfileA
GetIconInfo
GetImageConfigInformation
GetImageUnusedHeaderBytes
GetIniNameUsage
GetInksetInterval
GetInksetIntervalCount
GetInputDesktop
GetInputState
GetInterface
GetInternationalHRC
GetJobA
GetKBCodePage
GetKernelObjectSecurity
GetKerningPairsA
GetKeyNameTextA
GetKeyState
GetKeyboardLayout
GetKeyboardLayoutList
GetKeyboardLayoutNameA
GetKeyboardState
GetKeyboardType
GetLargestConsoleWindowSize
GetLastActivePopup
GetLastError
GetLastInputInfo
GetLengthSid
GetListBoxInfo
GetLocalTime
GetLocaleInfoA
GetLogColorSpaceA
GetLogFile
GetLogicalDriveStringsA
GetLogicalDrives
GetLongPathNameA
GetMailslotInfo
GetMapMode
GetMaxResultsHRC
GetMenu
GetMenuBarInfo
GetMenuCheckMarkDimensions
GetMenuContextHelpId
GetMenuDefaultItem
GetMenuInfo
GetMenuItemCount
GetMenuItemID
GetMenuItemInfoA
GetMenuItemRect
GetMenuPosFromID
GetMenuState
GetMenuStringA
GetMessageA
GetMessageExtraInfo
GetMessagePos
GetMessageTime
GetMetaFileA
GetMetaFileBitsEx
GetMetaRgn
GetMiterLimit
GetModuleFileNameA
GetModuleHandleA
GetMonitorInfoA
GetMouseMovePoints
GetMultipleTrusteeA
GetMultipleTrusteeOperationA
GetNameByTypeA
GetNamedPipeHandleStateA
GetNamedPipeInfo
GetNamedSecurityInfoA
GetNamedSecurityInfoExA
GetNearestColor
GetNearestPaletteIndex
GetNewInfName
GetNextDlgGroupItem
GetNextDlgTabItem
GetNextVDMCommand
GetNtmsMediaPoolNameA
GetNtmsObjectAttributeA
GetNtmsObjectInformationA
GetNtmsObjectSecurity
GetNumberFormatA
GetNumberOfConsoleFonts
GetNumberOfConsoleInputEvents
GetNumberOfConsoleMouseButtons
GetNumberOfEventLogRecords
GetOEMCP
GetObjectA
GetObjectType
GetOldestEventLogRecord
GetOpenCardNameA
GetOpenClipboardWindow
GetOpenFileNameA
GetOpenFileNamePreviewA
GetOutlineTextMetricsA
GetOverlappedAccessResults
GetOverlappedResult
GetPS2ColorRenderingDictionary
GetPS2ColorRenderingIntent
GetPS2ColorSpaceArray
GetPaletteEntries
GetParent
GetPath
GetPenAppFlags
GetPenAsyncState
GetPenDataAttributes
GetPenDataInfo
GetPenInput
GetPenMiscInfo
GetPixel
GetPixelFormat
GetPointsFromPenData
GetPolyFillMode
GetPrintProcessorDirectoryA
GetPrinterA
GetPrinterDataA
GetPrinterDataExA
GetPrinterDriverA
GetPrinterDriverDirectoryA
GetPrinterHTMLViewA
GetPrinterWebInformation
GetPriorityClass
GetPriorityClipboardFormat
GetPrivateObjectSecurity
GetPrivateProfileIntA
GetPrivateProfileSectionA
GetPrivateProfileSectionNamesA
GetPrivateProfileStringA
GetPrivateProfileStructA
GetProcAddress
GetProcessAffinityMask
GetProcessHeap
GetProcessHeaps
GetProcessPriorityBoost
GetProcessShutdownParameters
GetProcessTimes
GetProcessVersion
GetProcessWindowStation
GetProcessWorkingSetSize
GetProfileIntA
GetProfileSectionA
GetProfileStringA
GetPropA
GetQueueStatus
GetQueuedCompletionStatus
GetRCString
GetROP2
GetRandomRgn
GetRasDialOutProtocols
GetRasterizerCaps
GetRecordInfoFromGuids
GetRecordInfoFromTypeInfo
GetRegionData
GetRegistrySysColors
GetRelAbs
GetResultsHRC
GetRgnBox
GetRoleTextA
GetRunningObjectTable
GetSaveFileNameA
GetSaveFileNamePreviewA
GetScrollBarInfo
GetScrollInfo
GetScrollPos
GetScrollRange
GetSecurityDescriptorControl
GetSecurityDescriptorDacl
GetSecurityDescriptorGroup
GetSecurityDescriptorLength
GetSecurityDescriptorOwner
GetSecurityDescriptorSacl
GetSecurityInfo
GetSecurityInfoExA
GetServiceA
GetServiceDisplayNameA
GetServiceKeyNameA
GetSetFileTimestamp
GetSetLastRunInfo
GetShellWindow
GetShortPathNameA
GetSidIdentifierAuthority
GetSidLengthRequired
GetSidSubAuthority
GetSidSubAuthorityCount
GetSoftwareUpdateInfo
GetStandardColorSpaceProfileA
GetStartupInfoA
GetStateTextA
GetStdHandle
GetStockObject
GetStretchBltMode
GetStringTypeA
GetStringTypeExA
GetStrokeAttributes
GetStrokeTableAttributes
GetSubMenu
GetSubtypeName
GetSurfaceFromDC
GetSymbolCountHRCRESULT
GetSymbolsHRCRESULT
GetSysColor
GetSysColorBrush
GetSystemDefaultLCID
GetSystemDefaultLangID
GetSystemDirectoryA
GetSystemInfo
GetSystemMenu
GetSystemMetrics
GetSystemPaletteEntries
GetSystemPaletteUse
GetSystemPowerStatus
GetSystemTime
GetSystemTimeAdjustment
GetSystemTimeAsFileTime
GetTabbedTextExtentA
GetTapeParameters
GetTapePosition
GetTapeStatus
GetTempFileNameA
GetTempPathA
GetTestCases
GetTestGroups
GetTextAlign
GetTextCharacterExtra
GetTextCharset
GetTextCharsetInfo
GetTextColor
GetTextExtentExPointA
GetTextExtentExPointI
GetTextExtentPoint32A
GetTextExtentPointA
GetTextExtentPointI
GetTextFaceA
GetTextMetricsA
GetTheFunctionPtr
GetThreadContext
GetThreadDesktop
GetThreadLocale
GetThreadPriority
GetThreadPriorityBoost
GetThreadSelectorEntry
GetThreadTimes
GetTickCount
GetTimeFormatA
GetTimeZoneInformation
GetTimestampForLoadedLibrary
GetTitleBarInfo
GetTnefStreamCodepage
GetTokenInformation
GetTopWindow
GetTrueColorType
GetTrusteeNameA
GetTrusteeTypeA
GetTypeByNameA
GetUpdateRect
GetUpdateRgn
GetUrlCacheConfigInfoA
GetUrlCacheEntryInfoA
GetUrlCacheEntryInfoExA
GetUrlCacheHeaderData
GetUserDefaultLCID
GetUserDefaultLangID
GetUserNameA
GetUserObjectInformationA
GetUserObjectSecurity
GetVDMCurrentDirectories
GetVersion
GetVersionExA
GetVersionInfoFromImage
GetVersionPenWin
GetViewportExtEx
GetViewportOrgEx
GetVolumeInformationA
GetWinMetaFileBits
GetWindow
GetWindowContextHelpId
GetWindowDC
GetWindowExtEx
GetWindowInfo
GetWindowLongA
GetWindowModuleFileNameA
GetWindowOrgEx
GetWindowPlacement
GetWindowRect
GetWindowRgn
GetWindowTextA
GetWindowTextLengthA
GetWindowThreadProcessId
GetWindowWord
GetWindowsDirectoryA
GetWordlistCoercionHRC
GetWordlistHRC
GetWorldTransform
GlmfBeginGlsBlock
GlmfCloseMetaFile
GlmfEndGlsBlock
GlmfEndPlayback
GlmfInitPlayback
GlmfPlayGlsRecord
GlobalAddAtomA
GlobalAlloc
GlobalCompact
GlobalDeleteAtom
GlobalFindAtomA
GlobalFix
GlobalFlags
GlobalFree
GlobalGetAtomNameA
GlobalHandle
GlobalLock
GlobalMemoryStatus
GlobalMemoryStatusVlm
GlobalMutexClear
GlobalMutexRequest
GlobalReAlloc
GlobalSize
GlobalUnWire
GlobalUnfix
GlobalUnlock
GlobalWire
GopherCreateLocatorA
GopherFindFirstFileA
GopherGetAttributeA
GopherGetLocatorTypeA
GopherOpenFileA
GrabStaticEntries
GradientFill
GrayStringA
HACCEL_UserFree
HACCEL_UserMarshal
HACCEL_UserSize
HACCEL_UserUnmarshal
HBITMAP_UserFree
HBITMAP_UserMarshal
HBITMAP_UserSize
HBITMAP_UserUnmarshal
HBRUSH_UserFree
HBRUSH_UserMarshal
HBRUSH_UserSize
HBRUSH_UserUnmarshal
HENHMETAFILE_UserFree
HENHMETAFILE_UserMarshal
HENHMETAFILE_UserSize
HENHMETAFILE_UserUnmarshal
HGLOBAL_UserFree
HGLOBAL_UserMarshal
HGLOBAL_UserSize
HGLOBAL_UserUnmarshal
HMENU_UserFree
HMENU_UserMarshal
HMENU_UserSize
HMENU_UserUnmarshal
HMETAFILEPICT_UserFree
HMETAFILEPICT_UserMarshal
HMETAFILEPICT_UserSize
HMETAFILEPICT_UserUnmarshal
HMETAFILE_UserFree
HMETAFILE_UserMarshal
HMETAFILE_UserSize
HMETAFILE_UserUnmarshal
HPALETTE_UserFree
HPALETTE_UserMarshal
HPALETTE_UserSize
HPALETTE_UserUnmarshal
HWND_UserFree
HWND_UserMarshal
HWND_UserSize
HWND_UserUnmarshal
HashData
Heap32First
Heap32ListFirst
Heap32ListNext
Heap32Next
HeapAlloc
HeapCompact
HeapCreate
HeapDestroy
HeapExtend
HeapFree
HeapLock
HeapReAlloc
HeapSize
HeapSummary
HeapUnlock
HeapUsage
HeapValidate
HeapVidMemAllocAligned
HeapWalk
HexFromBin
HideCaret
HiliteMenuItem
HitTestPenData
HkOleRegisterObject
HlinkClone
HlinkCreateBrowseContext
HlinkCreateExtensionServices
HlinkCreateFromData
HlinkCreateFromMoniker
HlinkCreateFromString
HlinkCreateShortcut
HlinkCreateShortcutFromMoniker
HlinkCreateShortcutFromString
HlinkGetSpecialReference
HlinkGetValueFromParams
HlinkGoBack
HlinkGoForward
HlinkIsShortcut
HlinkNavigate
HlinkNavigateMoniker
HlinkNavigateString
HlinkNavigateToStringReference
HlinkOnNavigate
HlinkOnRenameDocument
HlinkParseDisplayName
HlinkPreprocessMoniker
HlinkQueryCreateFromData
HlinkResolveMonikerForData
HlinkResolveShortcut
HlinkResolveShortcutToMoniker
HlinkResolveShortcutToString
HlinkResolveStringForData
HlinkSetSpecialReference
HlinkSimpleNavigateToMoniker
HlinkSimpleNavigateToString
HlinkTranslateURL
HlinkUpdateStackItem
HogMachine
HrAddColumns
HrAddColumnsEx
HrAllocAdviseSink
HrComposeEID
HrComposeMsgID
HrDecomposeEID
HrDecomposeMsgID
HrDispatchNotifications
HrEntryIDFromSz
HrGetOneProp
HrIStorageFromStream
HrQueryAllRows
HrSetOneProp
HrSzFromEntryID
HrThisThreadAdviseSink
HrValidateIPMSubtree
HrValidateParameters
HttpAddRequestHeadersA
HttpEndRequestA
HttpOpenRequestA
HttpQueryInfoA
HttpSendRequestA
HttpSendRequestExA
HuftBuild
ICClose
ICCompressorChoose
ICCompressorFree
ICGetDisplayFormat
ICGetInfo
ICImageCompress
ICImageDecompress
ICInfo
ICInstall
ICLocate
ICMThunk32
ICOpen
ICOpenFunction
ICRemove
ICSendMessage
ICSeqCompressFrame
ICSeqCompressFrameEnd
ICSeqCompressFrameStart
IF_CALLBACK_FN
IIDFromString
IMPGetIMEA
IMPQueryIMEA
IMPSetIMEA
IUnknown_AddRef_Proxy
IUnknown_QueryInterface_Proxy
IUnknown_Release_Proxy
I_BrowserDebugCall
I_BrowserDebugTrace
I_BrowserQueryEmulatedDomains
I_BrowserQueryOtherDomains
I_BrowserQueryStatistics
I_BrowserResetNetlogonState
I_BrowserResetStatistics
I_BrowserServerEnum
I_BrowserSetNetlogonState
I_CryptAllocTls
I_CryptDetachTls
I_CryptGetOssGlobal
I_CryptGetTls
I_CryptInstallOssGlobal
I_CryptSetTls
I_GetDefaultEntrySyntax
I_MprSaveConn
I_NetAccountDeltas
I_NetAccountSync
I_NetDatabaseDeltas
I_NetDatabaseRedo
I_NetDatabaseSync
I_NetDatabaseSync2
I_NetDfsCreateExitPoint
I_NetDfsCreateLocalPartition
I_NetDfsDeleteExitPoint
I_NetDfsDeleteLocalPartition
I_NetDfsFixLocalVolume
I_NetDfsGetFtServers
I_NetDfsGetVersion
I_NetDfsIsThisADomainName
I_NetDfsModifyPrefix
I_NetDfsSetLocalVolumeState
I_NetDfsSetServerInfo
I_NetGetDCList
I_NetListCanonicalize
I_NetListTraverse
I_NetLogonControl
I_NetLogonControl2
I_NetLogonGetDomainInfo
I_NetLogonSamLogoff
I_NetLogonSamLogon
I_NetLogonUasLogoff
I_NetLogonUasLogon
I_NetNameCanonicalize
I_NetNameCompare
I_NetNameValidate
I_NetPathCanonicalize
I_NetPathCompare
I_NetPathType
I_NetServerAuthenticate
I_NetServerAuthenticate2
I_NetServerAuthenticate3
I_NetServerPasswordSet
I_NetServerPasswordSet2
I_NetServerReqChallenge
I_NetServerSetServiceBits
I_NetServerSetServiceBitsEx
I_NetlogonComputeClientDigest
I_NetlogonComputeServerDigest
I_NetlogonGetTrustRid
I_RpcAbortAsyncCall
I_RpcAllocate
I_RpcAsyncAbortCall
I_RpcAsyncSendReceive
I_RpcAsyncSetHandle
I_RpcBindingCopy
I_RpcBindingInqDynamicEndpointA
I_RpcBindingInqTransportType
I_RpcBindingIsClientLocal
I_RpcBindingSetAsync
I_RpcClearMutex
I_RpcConnectionInqSockBuffSize
I_RpcConnectionSetSockBuffSize
I_RpcDeleteMutex
I_RpcFree
I_RpcFreeBuffer
I_RpcFreePipeBuffer
I_RpcGetAssociationContext
I_RpcGetBuffer
I_RpcGetCurrentCallHandle
I_RpcGetServerContextList
I_RpcGetThreadWindowHandle
I_RpcIfInqTransferSyntaxes
I_RpcMapWin32Status
I_RpcMonitorAssociation
I_RpcNsBindingSetEntryNameA
I_RpcNsGetBuffer
I_RpcNsRaiseException
I_RpcNsSendReceive
I_RpcParseSecurity
I_RpcPauseExecution
I_RpcReBindBuffer
I_RpcReallocPipeBuffer
I_RpcReceive
I_RpcRequestMutex
I_RpcSend
I_RpcSendReceive
I_RpcServerAllocateIpPort
I_RpcServerInqTransportType
I_RpcServerRegisterForwardFunction
I_RpcServerStartListening
I_RpcServerStopListening
I_RpcSetAsyncHandle
I_RpcSetServerContextList
I_RpcSetWMsgEndpoint
I_RpcSsDontSerializeContext
I_RpcStopMonitorAssociation
I_RpcTransConnectionAllocatePacket
I_RpcTransConnectionFreePacket
I_RpcTransConnectionReallocPacket
I_RpcTransDatagramAllocate
I_RpcTransDatagramAllocate2
I_RpcTransDatagramFree
I_RpcTransGetReadEvent
I_RpcTransGetWriteEvent
I_RpcTransIoCancelled
I_RpcTransPingServer
I_RpcTransProtectThread
I_RpcTransServerAllocatePacket
I_RpcTransServerFreePacket
I_RpcTransServerNewConnection
I_RpcTransServerReallocPacket
I_RpcTransUnprotectThread
I_RpcWindowProc
I_ScSetServiceBitsA
I_UuidCreate
ImageAddCertificate
ImageDirectoryEntryToData
ImageEnumerateCertificates
ImageGetCertificateData
ImageGetCertificateHeader
ImageGetDigestStream
ImageList_Add
ImageList_AddIcon
ImageList_AddMasked
ImageList_BeginDrag
ImageList_Copy
ImageList_Create
ImageList_Destroy
ImageList_DragEnter
ImageList_DragLeave
ImageList_DragMove
ImageList_DragShowNolock
ImageList_Draw
ImageList_DrawEx
ImageList_DrawIndirect
ImageList_Duplicate
ImageList_EndDrag
ImageList_GetBkColor
ImageList_GetDragImage
ImageList_GetIcon
ImageList_GetIconSize
ImageList_GetImageCount
ImageList_GetImageInfo
ImageList_GetImageRect
ImageList_LoadImageA
ImageList_Merge
ImageList_Read
ImageList_Remove
ImageList_Replace
ImageList_ReplaceIcon
ImageList_SetBkColor
ImageList_SetDragCursorImage
ImageList_SetFilter
ImageList_SetIconSize
ImageList_SetImageCount
ImageList_SetOverlayImage
ImageList_Write
ImageLoad
ImageNtHeader
ImageRemoveCertificate
ImageRvaToSection
ImageRvaToVa
ImageUnload
ImagehlpApiVersion
ImagehlpApiVersionEx
ImmAssociateContext
ImmAssociateContextEx
ImmConfigureIMEA
ImmCreateContext
ImmCreateIMCC
ImmCreateSoftKeyboard
ImmDestroyContext
ImmDestroyIMCC
ImmDestroySoftKeyboard
ImmDisableIME
ImmEnumRegisterWordA
ImmEscapeA
ImmGenerateMessage
ImmGetCandidateListA
ImmGetCandidateListCountA
ImmGetCandidateWindow
ImmGetCompositionFontA
ImmGetCompositionStringA
ImmGetCompositionWindow
ImmGetContext
ImmGetConversionListA
ImmGetConversionStatus
ImmGetDefaultIMEWnd
ImmGetDescriptionA
ImmGetGuideLineA
ImmGetHotKey
ImmGetIMCCLockCount
ImmGetIMCCSize
ImmGetIMCLockCount
ImmGetIMEFileNameA
ImmGetImeMenuItemsA
ImmGetOpenStatus
ImmGetProperty
ImmGetRegisterWordStyleA
ImmGetStatusWindowPos
ImmGetVirtualKey
ImmInstallIMEA
ImmIsIME
ImmIsUIMessageA
ImmLockIMC
ImmLockIMCC
ImmNotifyIME
ImmReSizeIMCC
ImmRegisterWordA
ImmReleaseContext
ImmRequestMessageA
ImmSetCandidateWindow
ImmSetCompositionFontA
ImmSetCompositionStringA
ImmSetCompositionWindow
ImmSetConversionStatus
ImmSetHotKey
ImmSetOpenStatus
ImmSetStatusWindowPos
ImmShowSoftKeyboard
ImmSimulateHotKey
ImmUnlockIMC
ImmUnlockIMCC
ImmUnregisterWordA
ImpersonateDdeClientWindow
ImpersonateLoggedOnUser
ImpersonateNamedPipeClient
ImpersonateSelf
ImportNtmsDatabase
InSendMessage
InSendMessageEx
IncrementUrlCacheHeaderData
InetIsOffline
InfIsFromOemLocation
InflateBlock
InflateCodes
InflateDynamic
InflateFixed
InflateRect
InflateStored
InitAtomTable
InitCommonControls
InitCommonControlsEx
InitFixed
InitFolder
InitRealScreenSave
InitializeAcl
InitializeCriticalSection
InitializeCriticalSectionAndSpinCount
InitializeDll
InitializeFlatSB
InitializePrintMonitor
InitializePrintProvidor
InitializeSecurityDescriptor
InitializeSid
InitiateSystemShutdownA
InjectNtmsCleaner
InjectNtmsMedia
InsertMenuA
InsertMenuItemA
InsertPenData
InsertPenDataPoints
InsertPenDataStroke
InstallColorProfileA
InstallFilterHook
InstallHinfSectionA
InstallRecognizer
InstallStop
InterlockedCompareExchange
InterlockedDecrement
InterlockedExchange
InterlockedExchangeAdd
InterlockedIncrement
InternalExtractIconListA
Internal_Literal
Internal_Match
InternetAttemptConnect
InternetAutodial
InternetAutodialCallback
InternetAutodialHangup
InternetCanonicalizeUrlA
InternetCheckConnectionA
InternetCloseHandle
InternetCombineUrlA
InternetConfirmZoneCrossing
InternetConnectA
InternetCrackUrlA
InternetCreateUrlA
InternetDebugGetLocalTime
InternetDial
InternetErrorDlg
InternetFindNextFileA
InternetGetCertByURL
InternetGetConnectedState
InternetGetCookieA
InternetGetLastResponseInfoA
InternetGoOnline
InternetHangUp
InternetLockRequestFile
InternetOpenA
InternetOpenUrlA
InternetQueryDataAvailable
InternetQueryOptionA
InternetReadFile
InternetReadFileExA
InternetSetCookieA
InternetSetDialState
InternetSetFilePointer
InternetSetOptionA
InternetSetOptionExA
InternetSetStatusCallback
InternetShowSecurityInfoByURL
InternetTimeFromSystemTime
InternetTimeToSystemTime
InternetUnlockRequestFile
InternetWriteFile
InternetWriteFileExA
IntersectClipRect
IntersectRect
IntlStrEqWorkerA
IntroDialogProc
InvalidateConsoleDIBits
InvalidateRect
InvalidateRgn
InventoryNtmsLibrary
InvertRect
InvertRgn
IpxAdjustIoCompletionParams
IpxCreateAdapterConfigurationPort
IpxDeleteAdapterConfigurationPort
IpxGetOverlappedResult
IpxGetQueuedAdapterConfigurationStatus
IpxGetQueuedCompletionStatus
IpxPostQueuedCompletionStatus
IpxRecvPacket
IpxSendPacket
IpxWanCreateAdapterConfigurationPort
IpxWanQueryInactivityTimer
IpxWanSetAdapterConfiguration
IsAccelerator
IsAsyncMoniker
IsBadBoundedStringPtr
IsBadCodePtr
IsBadHugeReadPtr
IsBadHugeWritePtr
IsBadReadPtr
IsBadStringPtrA
IsBadWritePtr
IsCharAlphaA
IsCharAlphaNumericA
IsCharLowerA
IsCharUpperA
IsChicago
IsChild
IsClipboardFormatAvailable
IsColorProfileTagPresent
IsColorProfileValid
IsDBCSLeadByte
IsDBCSLeadByteEx
IsDebuggerPresent
IsDialogMessageA
IsDlgButtonChecked
IsEqualGUID
IsHostInProxyBypassList
IsIconic
IsLoggingEnabledA
IsMenu
IsPenEvent
IsPixelFormatValid
IsProcessorFeaturePresent
IsRectEmpty
IsTextUnicode
IsTokenRestricted
IsUserAdmin
IsValidAcl
IsValidCodePage
IsValidIid
IsValidInterface
IsValidLocale
IsValidPtrIn
IsValidPtrOut
IsValidSecurityDescriptor
IsValidSid
IsValidURL
IsWindow
IsWindowEnabled
IsWindowUnicode
IsWindowVisible
IsZoomed
K32Thk1632Epilog
K32Thk1632Prolog
KeyDown
KillSystemTimer
KillTimer
LBItemFromPt
LCMapStringA
LHashValOfNameSysA
LPSAFEARRAY_Marshal
LPSAFEARRAY_Size
LPSAFEARRAY_Unmarshal
LPSAFEARRAY_UserFree
LPSAFEARRAY_UserMarshal
LPSAFEARRAY_UserSize
LPSAFEARRAY_UserUnmarshal
LPropCompareProp
LPtoDP
LSEnumProviders
LSFreeHandle
LSGetMessage
LSInstall
LSLicenseUnitsGet
LSLicenseUnitsSet
LSQuery
LSRelease
LSRequest
LSUpdate
LZClose
LZCopy
LZDone
LZInit
LZOpenFileA
LZRead
LZSeek
LZStart
LateAllocateSurfaceMem
LaunchWizard
LdapDllInit
LeaveCriticalSection
LibMain
LineDDA
LineTo
LoadAcceleratorsA
LoadAlterBitmap
LoadBitmapA
LoadCursorA
LoadCursorFromFileA
LoadIFilter
LoadIconA
LoadImageA
LoadKeyboardLayoutA
LoadLibraryA
LoadLibraryExA
LoadMenuA
LoadMenuIndirectA
LoadModule
LoadPerfCounterTextStringsA
LoadPrinterDriver
LoadPwdDLL
LoadRegTypeLib
LoadResource
LoadStringA
LoadTypeLib
LoadTypeLibEx
LoadUrlCacheContent
LocalAlloc
LocalCompact
LocalFileTimeToFileTime
LocalFlags
LocalFree
LocalHandle
LocalLock
LocalReAlloc
LocalShrink
LocalSize
LocalUnlock
LocateCatalogsA
LockFile
LockFileEx
LockResource
LockServiceDatabase
LockWindowUpdate
LockWorkStation
LogErrorA
LogEventA
LoginCabinet
LogonUserA
LookUpStringInTable
LookupAccountNameA
LookupAccountSidA
LookupIconIdFromDirectory
LookupIconIdFromDirectoryEx
LookupPrivilegeDisplayNameA
LookupPrivilegeNameA
LookupPrivilegeValueA
LookupSecurityDescriptorPartsA
LpValFindProp
LresultFromObject
LsaAddAccountRights
LsaAddPrivilegesToAccount
LsaClearAuditLog
LsaClose
LsaCreateAccount
LsaCreateSecret
LsaCreateTrustedDomain
LsaCreateTrustedDomainEx
LsaDelete
LsaDeleteTrustedDomain
LsaEnumerateAccountRights
LsaEnumerateAccounts
LsaEnumerateAccountsWithUserRight
LsaEnumeratePrivileges
LsaEnumeratePrivilegesOfAccount
LsaEnumerateTrustedDomains
LsaEnumerateTrustedDomainsEx
LsaFreeMemory
LsaGetQuotasForAccount
LsaGetSystemAccessAccount
LsaGetUserName
LsaICLookupNames
LsaICLookupSids
LsaIGetTrustedDomainAuthInfoBlobs
LsaISetTrustedDomainAuthInfoBlobs
LsaLookupNames
LsaLookupPrivilegeDisplayName
LsaLookupPrivilegeName
LsaLookupPrivilegeValue
LsaLookupSids
LsaNtStatusToWinError
LsaOpenAccount
LsaOpenPolicy
LsaOpenSecret
LsaOpenTrustedDomain
LsaQueryDomainInformationPolicy
LsaQueryInfoTrustedDomain
LsaQueryInformationPolicy
LsaQueryLocalInformationPolicy
LsaQuerySecret
LsaQuerySecurityObject
LsaQueryTrustedDomainInfo
LsaQueryTrustedDomainInfoByName
LsaRemoveAccountRights
LsaRemovePrivilegesFromAccount
LsaRetrievePrivateData
LsaSetDomainInformationPolicy
LsaSetInformationPolicy
LsaSetInformationTrustedDomain
LsaSetLocalInformationPolicy
LsaSetQuotasForAccount
LsaSetSecret
LsaSetSecurityObject
LsaSetSystemAccessAccount
LsaSetTrustedDomainInfoByName
LsaSetTrustedDomainInformation
LsaStorePrivateData
Lz_Bump
Lz_Close
Lz_Init
Lz_NextToken
MAPIAdminProfiles
MAPIAllocateBuffer
MAPIAllocateMore
MAPIDeinitIdle
MAPIFreeBuffer
MAPIGetDefaultMalloc
MAPIInitIdle
MAPIInitialize
MAPILogonEx
MAPIOpenFormMgr
MAPIOpenLocalFormContainer
MAPIUninitialize
MDICreateDecompressionGlobal
MDIDecompressGlobal
MDIDestroyDecompressionGlobal
MDIResetDecompressionGlobal
MIDL_user_allocate
MIDL_wchar_strcpy
MIDL_wchar_strlen
MIMEAssociationDialogA
MMCFreeNotifyHandle
MMCIsMTNodeValid
MMCPropPageCallback
MMCPropertyChangeNotify
MNLS_MultiByteToWideChar
MNLS_WideCharToMultiByte
MQBeginTransaction
MQCloseCursor
MQCloseQueue
MQCreateCursor
MQCreateInternalCert
MQCreateQueue
MQDeleteInternalCert
MQDeleteQueue
MQFreeMemory
MQFreeSecurityContext
MQGetInternalCert
MQGetInternalCertificate
MQGetMachineProperties
MQGetQueueProperties
MQGetQueueSecurity
MQGetSecurityContext
MQGetUserCerts
MQHandleToFormatName
MQInstanceToFormatName
MQLocateBegin
MQLocateEnd
MQLocateNext
MQOpenQueue
MQPathNameToFormatName
MQPurgeQueue
MQReceiveMessage
MQRegisterUserCert
MQRemoveUserCert
MQSendMessage
MQSetQueueProperties
MQSetQueueSecurity
MTSCreateActivity
MakeAbsoluteSD
MakeDragList
MakeSelfRelativeSD
MakeSureDirectoryPathExists
ManageGroups
ManageSources
ManageTests
MapAndLoad
MapDebugInformation
MapDialogRect
MapFileAndCheckSumA
MapGenericMask
MapLS
MapSL
MapSLFix
MapStorageSCode
MapViewOfFile
MapViewOfFileEx
MapViewOfFileVlm
MapVirtualKeyA
MapVirtualKeyExA
MapWindowPoints
MarkImageAsRunFromSwap
MaskBlt
MemoryInitialize
MenuHelp
MenuItemFromPoint
MesBufferHandleReset
MesDecodeBufferHandleCreate
MesDecodeIncrementalHandleCreate
MesEncodeDynBufferHandleCreate
MesEncodeFixedBufferHandleCreate
MesEncodeIncrementalHandleCreate
MesHandleFree
MesIncrementalHandleReset
MesInqProcEncodingId
MessageBeep
MessageBoxA
MessageBoxExA
MessageBoxIndirectA
MetricScalePenData
MigrateAllDrivers
MigrateMidiUser
MigrateSoundEvents
MigrateWinsockConfiguration
MkParseDisplayName
MkParseDisplayNameEx
ModifyMenuA
ModifyWorldTransform
Module32First
Module32Next
MonikerCommonPrefixWith
MonikerRelativePathTo
MonitorFromPoint
MonitorFromRect
MonitorFromWindow
MountNtmsMedia
MouseDown
MouseLoc
MouseUp
MoveClusterGroup
MoveFileA
MoveFileExA
MoveFileWithProgressA
MoveToEx
MoveToNtmsMediaPool
MoveWindow
MprAdminBufferFree
MprAdminConnectionClearStats
MprAdminConnectionEnum
MprAdminConnectionGetInfo
MprAdminGetErrorString
MprAdminGetPDCServer
MprAdminInterfaceConnect
MprAdminInterfaceCreate
MprAdminInterfaceDelete
MprAdminInterfaceDisconnect
MprAdminInterfaceEnum
MprAdminInterfaceGetCredentials
MprAdminInterfaceGetHandle
MprAdminInterfaceGetInfo
MprAdminInterfaceQueryUpdateResult
MprAdminInterfaceSetCredentials
MprAdminInterfaceSetInfo
MprAdminInterfaceTransportAdd
MprAdminInterfaceTransportGetInfo
MprAdminInterfaceTransportRemove
MprAdminInterfaceTransportSetInfo
MprAdminInterfaceUpdatePhonebookInfo
MprAdminInterfaceUpdateRoutes
MprAdminIsServiceRunning
MprAdminMIBBufferFree
MprAdminMIBEntryCreate
MprAdminMIBEntryDelete
MprAdminMIBEntryGet
MprAdminMIBEntryGetFirst
MprAdminMIBEntryGetNext
MprAdminMIBEntrySet
MprAdminMIBServerConnect
MprAdminMIBServerDisconnect
MprAdminPortClearStats
MprAdminPortDisconnect
MprAdminPortEnum
MprAdminPortGetInfo
MprAdminPortReset
MprAdminServerConnect
MprAdminServerDisconnect
MprAdminServerGetInfo
MprAdminTransportGetInfo
MprAdminTransportSetInfo
MprAdminUserGetInfo
MprAdminUserSetInfo
MprConfigBufferFree
MprConfigInterfaceCreate
MprConfigInterfaceDelete
MprConfigInterfaceEnum
MprConfigInterfaceGetHandle
MprConfigInterfaceGetInfo
MprConfigInterfaceSetInfo
MprConfigInterfaceTransportAdd
MprConfigInterfaceTransportEnum
MprConfigInterfaceTransportGetHandle
MprConfigInterfaceTransportGetInfo
MprConfigInterfaceTransportRemove
MprConfigInterfaceTransportSetInfo
MprConfigServerBackup
MprConfigServerConnect
MprConfigServerDisconnect
MprConfigServerGetInfo
MprConfigServerRestore
MprConfigTransportCreate
MprConfigTransportDelete
MprConfigTransportEnum
MprConfigTransportGetHandle
MprConfigTransportGetInfo
MprConfigTransportSetInfo
MprInfoBlockAdd
MprInfoBlockFind
MprInfoBlockRemove
MprInfoBlockSet
MprInfoCreate
MprInfoDelete
MprInfoDuplicate
MprInfoRemoveAll
MprSetupProtocolEnum
MprSetupProtocolFree
MsgWaitForMultipleObjects
MsgWaitForMultipleObjectsEx
Msr_Control
Msr_Dump
Msr_DumpStats
Msr_Init
Msr_Integer
Msr_Note
Msr_Register
Msr_Reset
Msr_Start
Msr_Stop
Msr_Terminate
MulDiv
MultiByteToUnicode
MultiByteToWideChar
MultiSzFromSearchControl
MultinetGetConnectionPerformanceA
MultinetGetErrorTextA
MyFree
MyGetFileTitle
MyMalloc
MyRealloc
NDRCContextBinding
NDRCContextMarshall
NDRCContextUnmarshall
NDRSContextMarshall
NDRSContextMarshallEx
NDRSContextUnmarshall
NDRSContextUnmarshallEx
NDRcopy
NDdeGetErrorStringA
NDdeGetShareSecurityA
NDdeGetTrustedShareA
NDdeIsValidAppTopicListA
NDdeIsValidShareNameA
NDdeSetShareSecurityA
NDdeSetTrustedShareA
NDdeShareAddA
NDdeShareDelA
NDdeShareEnumA
NDdeShareGetInfoA
NDdeShareSetInfoA
NDdeSpecialCommandA
NDdeTrustedShareEnumA
NFMDestroyContext
NFMInitializeContext
NFM_Decompress
NFM_Prepare
NPLoadNameSpaces
NdrAllocate
NdrAsyncServerCall
NdrAsyncStubCall
NdrByteCountPointerBufferSize
NdrByteCountPointerFree
NdrByteCountPointerMarshall
NdrByteCountPointerUnmarshall
NdrCStdStubBuffer2_Release
NdrCStdStubBuffer_Release
NdrClearOutParameters
NdrClientContextMarshall
NdrClientContextUnmarshall
NdrClientInitialize
NdrClientInitializeNew
NdrComplexArrayBufferSize
NdrComplexArrayFree
NdrComplexArrayMarshall
NdrComplexArrayMemorySize
NdrComplexArrayUnmarshall
NdrComplexStructBufferSize
NdrComplexStructFree
NdrComplexStructMarshall
NdrComplexStructMemorySize
NdrComplexStructUnmarshall
NdrConformantArrayBufferSize
NdrConformantArrayFree
NdrConformantArrayMarshall
NdrConformantArrayMemorySize
NdrConformantArrayUnmarshall
NdrConformantStringBufferSize
NdrConformantStringMarshall
NdrConformantStringMemorySize
NdrConformantStringUnmarshall
NdrConformantStructBufferSize
NdrConformantStructFree
NdrConformantStructMarshall
NdrConformantStructMemorySize
NdrConformantStructUnmarshall
NdrConformantVaryingArrayBufferSize
NdrConformantVaryingArrayFree
NdrConformantVaryingArrayMarshall
NdrConformantVaryingArrayMemorySize
NdrConformantVaryingArrayUnmarshall
NdrConformantVaryingStructBufferSize
NdrConformantVaryingStructFree
NdrConformantVaryingStructMarshall
NdrConformantVaryingStructMemorySize
NdrConformantVaryingStructUnmarshall
NdrContextHandleSize
NdrConvert
NdrConvert2
NdrDllCanUnloadNow
NdrDllGetClassObject
NdrDllRegisterProxy
NdrDllUnregisterProxy
NdrEncapsulatedUnionBufferSize
NdrEncapsulatedUnionFree
NdrEncapsulatedUnionMarshall
NdrEncapsulatedUnionMemorySize
NdrEncapsulatedUnionUnmarshall
NdrFixedArrayBufferSize
NdrFixedArrayFree
NdrFixedArrayMarshall
NdrFixedArrayMemorySize
NdrFixedArrayUnmarshall
NdrFreeBuffer
NdrFullPointerFree
NdrFullPointerInsertRefId
NdrFullPointerQueryPointer
NdrFullPointerQueryRefId
NdrFullPointerXlatFree
NdrFullPointerXlatInit
NdrGetBuffer
NdrGetDcomProtocolVersion
NdrGetPartialBuffer
NdrGetPipeBuffer
NdrHardStructBufferSize
NdrHardStructFree
NdrHardStructMarshall
NdrHardStructMemorySize
NdrHardStructUnmarshall
NdrInterfacePointerBufferSize
NdrInterfacePointerFree
NdrInterfacePointerMarshall
NdrInterfacePointerMemorySize
NdrInterfacePointerUnmarshall
NdrIsAppDoneWithPipes
NdrMapCommAndFaultStatus
NdrMarkNextActivePipe
NdrMesSimpleTypeAlignSize
NdrMesSimpleTypeDecode
NdrMesSimpleTypeEncode
NdrMesTypeAlignSize
NdrMesTypeDecode
NdrMesTypeEncode
NdrNonConformantStringBufferSize
NdrNonConformantStringMarshall
NdrNonConformantStringMemorySize
NdrNonConformantStringUnmarshall
NdrNonEncapsulatedUnionBufferSize
NdrNonEncapsulatedUnionFree
NdrNonEncapsulatedUnionMarshall
NdrNonEncapsulatedUnionMemorySize
NdrNonEncapsulatedUnionUnmarshall
NdrNsGetBuffer
NdrNsSendReceive
NdrOleAllocate
NdrOleFree
NdrPipePull
NdrPipePush
NdrPipeSendReceive
NdrPipesDone
NdrPipesInitialize
NdrPointerBufferSize
NdrPointerFree
NdrPointerMarshall
NdrPointerMemorySize
NdrPointerUnmarshall
NdrProxyErrorHandler
NdrProxyFreeBuffer
NdrProxyGetBuffer
NdrProxyInitialize
NdrProxySendReceive
NdrRpcSmClientAllocate
NdrRpcSmClientFree
NdrRpcSmSetClientToOsf
NdrRpcSsDefaultAllocate
NdrRpcSsDefaultFree
NdrRpcSsDisableAllocate
NdrRpcSsEnableAllocate
NdrSendReceive
NdrServerCall
NdrServerCall2
NdrServerContextMarshall
NdrServerContextUnmarshall
NdrServerInitialize
NdrServerInitializeMarshall
NdrServerInitializeNew
NdrServerInitializePartial
NdrServerInitializeUnmarshall
NdrServerMarshall
NdrServerUnmarshall
NdrSimpleStructBufferSize
NdrSimpleStructFree
NdrSimpleStructMarshall
NdrSimpleStructMemorySize
NdrSimpleStructUnmarshall
NdrSimpleTypeMarshall
NdrSimpleTypeUnmarshall
NdrStubCall
NdrStubCall2
NdrStubForwardingFunction
NdrStubGetBuffer
NdrStubInitialize
NdrStubInitializeMarshall
NdrUserMarshalBufferSize
NdrUserMarshalFree
NdrUserMarshalMarshall
NdrUserMarshalMemorySize
NdrUserMarshalSimpleTypeConvert
NdrUserMarshalUnmarshall
NdrVaryingArrayBufferSize
NdrVaryingArrayFree
NdrVaryingArrayMarshall
NdrVaryingArrayMemorySize
NdrVaryingArrayUnmarshall
NdrXmitOrRepAsBufferSize
NdrXmitOrRepAsFree
NdrXmitOrRepAsMarshall
NdrXmitOrRepAsMemorySize
NdrXmitOrRepAsUnmarshall
NdrpSetRpcSsDefaults
NetAccessAdd
NetAccessCheck
NetAccessDel
NetAccessEnum
NetAccessGetInfo
NetAccessGetUserPerms
NetAccessSetInfo
NetAlertRaise
NetAlertRaiseEx
NetApiBufferAllocate
NetApiBufferFree
NetApiBufferReallocate
NetApiBufferSize
NetAuditClear
NetAuditRead
NetAuditWrite
NetBrowserStatisticsGet
NetConfigGet
NetConfigGetAll
NetConfigSet
NetConnectionEnum
NetDfsAdd
NetDfsEnum
NetDfsGetInfo
NetDfsManagerGetConfigInfo
NetDfsMove
NetDfsRemove
NetDfsRename
NetDfsSetInfo
NetEnumerateTrustedDomains
NetErrorLogClear
NetErrorLogRead
NetErrorLogWrite
NetFileClose
NetFileClose2
NetFileEnum
NetFileGetInfo
NetGetAnyDCName
NetGetDCName
NetGetDisplayInformationIndex
NetGroupAdd
NetGroupAddUser
NetGroupDel
NetGroupDelUser
NetGroupEnum
NetGroupGetInfo
NetGroupGetUsers
NetGroupSetInfo
NetGroupSetUsers
NetLocalGroupAdd
NetLocalGroupAddMember
NetLocalGroupAddMembers
NetLocalGroupDel
NetLocalGroupDelMember
NetLocalGroupDelMembers
NetLocalGroupEnum
NetLocalGroupGetInfo
NetLocalGroupGetMembers
NetLocalGroupSetInfo
NetLocalGroupSetMembers
NetLogonSetServiceBits
NetMessageBufferSend
NetMessageNameAdd
NetMessageNameDel
NetMessageNameEnum
NetMessageNameGetInfo
NetQueryDisplayInformation
NetRemoteComputerSupports
NetRemoteTOD
NetReplExportDirAdd
NetReplExportDirDel
NetReplExportDirEnum
NetReplExportDirGetInfo
NetReplExportDirLock
NetReplExportDirSetInfo
NetReplExportDirUnlock
NetReplGetInfo
NetReplImportDirAdd
NetReplImportDirDel
NetReplImportDirEnum
NetReplImportDirGetInfo
NetReplImportDirLock
NetReplImportDirUnlock
NetReplSetInfo
NetScheduleJobAdd
NetScheduleJobDel
NetScheduleJobEnum
NetScheduleJobGetInfo
NetSecurityGetInfo
NetServerComputerNameAdd
NetServerComputerNameDel
NetServerDiskEnum
NetServerEnum
NetServerEnumEx
NetServerGetInfo
NetServerSetInfo
NetServerTransportAdd
NetServerTransportAddEx
NetServerTransportDel
NetServerTransportEnum
NetServiceControl
NetServiceEnum
NetServiceGetInfo
NetServiceInstall
NetSessionDel
NetSessionEnum
NetSessionGetInfo
NetShareAdd
NetShareCheck
NetShareDel
NetShareDelSticky
NetShareEnum
NetShareEnumSticky
NetShareGetInfo
NetShareSetInfo
NetStatisticsGet
NetUseAdd
NetUseDel
NetUseEnum
NetUseGetInfo
NetUserAdd
NetUserChangePassword
NetUserDel
NetUserEnum
NetUserGetGroups
NetUserGetInfo
NetUserGetLocalGroups
NetUserModalsGet
NetUserModalsSet
NetUserSetGroups
NetUserSetInfo
NetWkstaGetInfo
NetWkstaSetInfo
NetWkstaTransportAdd
NetWkstaTransportDel
NetWkstaTransportEnum
NetWkstaUserEnum
NetWkstaUserGetInfo
NetWkstaUserSetInfo
NetapipBufferAllocate
Netbios
NetpAccessCheck
NetpAccessCheckAndAudit
NetpAllocConfigName
NetpAllocStrFromStr
NetpAllocStrFromWStr
NetpAllocTStrFromString
NetpAllocWStrFromStr
NetpAllocWStrFromWStr
NetpApiStatusToNtStatus
NetpAssertFailed
NetpCloseConfigData
NetpCopyStringToBuffer
NetpCreateSecurityObject
NetpDbgDisplayServerInfo
NetpDeleteSecurityObject
NetpGetComputerName
NetpGetConfigBool
NetpGetConfigDword
NetpGetConfigTStrArray
NetpGetConfigValue
NetpGetDomainName
NetpGetFileSecurity
NetpGetPrivilege
NetpHexDump
NetpInitOemString
NetpIsRemote
NetpIsUncComputerNameValid
NetpLocalTimeZoneOffset
NetpLogonPutUnicodeString
NetpNetBiosAddName
NetpNetBiosCall
NetpNetBiosDelName
NetpNetBiosGetAdapterNumbers
NetpNetBiosHangup
NetpNetBiosReceive
NetpNetBiosReset
NetpNetBiosSend
NetpNetBiosStatusToApiStatus
NetpNtStatusToApiStatus
NetpOpenConfigData
NetpPackString
NetpReleasePrivilege
NetpSetConfigBool
NetpSetConfigDword
NetpSetConfigTStrArray
NetpSetFileSecurity
NetpSmbCheck
NetpStringToNetBiosName
NetpTStrArrayEntryCount
NetpwNameCanonicalize
NetpwNameCompare
NetpwNameValidate
NetpwPathCanonicalize
NetpwPathCompare
NetpwPathType
NlBindingAddServerToCache
NlBindingRemoveServerFromCache
NotfDeliverNotification
NotifyBootConfigStatus
NotifyCallbackData
NotifyChangeEventLog
NotifyWinEvent
NtAcsLan
OACreateTypeLib2
OBJECT_INQ_FN
OaBuildVersion
ObjectCloseAuditAlarmA
ObjectDeleteAuditAlarmA
ObjectFromLresult
ObjectOpenAuditAlarmA
ObjectPrivilegeAuditAlarmA
ObtainUserAgentString
OemKeyScan
OemToCharA
OemToCharBuffA
OfflineClusterGroup
OfflineClusterResource
OffsetClipRgn
OffsetPenData
OffsetRect
OffsetRgn
OffsetViewportOrgEx
OffsetWindowOrgEx
OleBuildVersion
OleConvertIStorageToOLESTREAM
OleConvertIStorageToOLESTREAMEx
OleConvertOLESTREAMToIStorage
OleConvertOLESTREAMToIStorageEx
OleCreate
OleCreateDefaultHandler
OleCreateEmbeddingHelper
OleCreateEx
OleCreateFontIndirect
OleCreateFromData
OleCreateFromDataEx
OleCreateFromFile
OleCreateFromFileEx
OleCreateLink
OleCreateLinkEx
OleCreateLinkFromData
OleCreateLinkFromDataEx
OleCreateLinkToFile
OleCreateLinkToFileEx
OleCreateMenuDescriptor
OleCreatePictureIndirect
OleCreatePropertyFrame
OleCreatePropertyFrameIndirect
OleCreateStaticFromData
OleDestroyMenuDescriptor
OleDoAutoConvert
OleDraw
OleDuplicateData
OleFlushClipboard
OleGetAutoConvert
OleGetClipboard
OleGetIconOfClass
OleGetIconOfFile
OleIconToCursor
OleInitialize
OleIsCurrentClipboard
OleIsRunning
OleLoad
OleLoadFromStream
OleLoadPicture
OleLoadPictureEx
OleLoadPictureFile
OleLoadPictureFileEx
OleLoadPicturePath
OleLockRunning
OleMetafilePictFromIconAndLabel
OleNoteObjectVisible
OleQueryCreateFromData
OleQueryLinkFromData
OleRegEnumFormatEtc
OleRegEnumVerbs
OleRegGetMiscStatus
OleRegGetUserType
OleRun
OleSave
OleSavePictureFile
OleSaveToStream
OleSaveToStreamEx
OleSetAutoConvert
OleSetClipboard
OleSetContainedObject
OleSetMenuDescriptor
OleTranslateAccelerator
OleTranslateColor
OleUIAddVerbMenu
OleUIAddVerbMenuA
OleUIBusy
OleUIBusyA
OleUICanConvertOrActivateAs
OleUIChangeIcon
OleUIChangeIconA
OleUIChangeSourceA
OleUIConvert
OleUIConvertA
OleUIEditLinks
OleUIEditLinksA
OleUIInsertObject
OleUIInsertObjectA
OleUIObjectPropertiesA
OleUIPasteSpecial
OleUIPasteSpecialA
OleUIUpdateLinks
OleUIUpdateLinksA
OleUninitialize
OnlineClusterGroup
OnlineClusterResource
OpenAndMapFileForRead
OpenBackupEventLogA
OpenClipboard
OpenCluster
OpenClusterGroup
OpenClusterNetInterface
OpenClusterNetwork
OpenClusterNode
OpenClusterResource
OpenColorProfileA
OpenDesktopA
OpenDriver
OpenEventA
OpenEventLogA
OpenFile
OpenFileMappingA
OpenIMsgOnIStg
OpenIMsgSession
OpenIcon
OpenInputDesktop
OpenJobObjectA
OpenMutexA
OpenNtmsNotification
OpenNtmsSessionA
OpenOrCreateStream
OpenPrinterA
OpenProcess
OpenProcessToken
OpenProfileUserMapping
OpenRawA
OpenSCManagerA
OpenSemaphoreA
OpenServiceA
OpenStream
OpenStreamOnFile
OpenThreadToken
OpenTnefStream
OpenTnefStreamEx
OpenWaitableTimerA
OpenWindowStationA
OssX509SpcIndirectDataContentDecode
OssX509SpcIndirectDataContentEncode
OutOfMemory
OutputDebugStringA
PackDDElParam
PageSetupDlgA
PaintDesktop
PaintRgn
ParseX509EncodedCertificateForListBoxEntry
PatBlt
PathAddBackslashA
PathAddExtensionA
PathAppendA
PathBuildRootA
PathCanonicalizeA
PathCombineA
PathCommonPrefixA
PathCompactPathA
PathCompactPathExA
PathCreateFromUrlA
PathFileExistsA
PathFindExtensionA
PathFindFileNameA
PathFindNextComponentA
PathFindOnPathA
PathGetArgsA
PathGetCharTypeA
PathGetDriveNumberA
PathIsContentTypeA
PathIsDirectoryA
PathIsFileSpecA
PathIsPrefixA
PathIsRelativeA
PathIsRootA
PathIsSameRootA
PathIsSystemFolderA
PathIsUNCA
PathIsUNCServerA
PathIsUNCServerShareA
PathIsURLA
PathMakePrettyA
PathMakeSystemFolderA
PathMatchSpecA
PathParseIconLocationA
PathQuoteSpacesA
PathRelativePathToA
PathRemoveArgsA
PathRemoveBackslashA
PathRemoveBlanksA
PathRemoveExtensionA
PathRemoveFileSpecA
PathRenameExtensionA
PathSearchAndQualifyA
PathSetDlgItemPathA
PathSkipRootA
PathStripPathA
PathStripToRootA
PathToRegion
PathUnmakeSystemFolderA
PathUnquoteSpacesA
PauseClusterNode
PdhAddCounterA
PdhBrowseCountersA
PdhCalculateCounterFromRawValue
PdhCloseLog
PdhCloseQuery
PdhCollectQueryData
PdhCollectQueryDataEx
PdhComputeCounterStatistics
PdhConnectMachineA
PdhDecodeWmiPathA
PdhEncodeWmiPathA
PdhEnumMachinesA
PdhEnumObjectItemsA
PdhEnumObjectsA
PdhExpandCounterPathA
PdhFormatFromRawValue
PdhGetCounterInfoA
PdhGetCounterTimeBase
PdhGetDataSourceTimeRangeA
PdhGetDefaultPerfCounterA
PdhGetDefaultPerfObjectA
PdhGetDllVersion
PdhGetFormattedCounterArrayA
PdhGetFormattedCounterValue
PdhGetLogFileSize
PdhGetRawCounterArrayA
PdhGetRawCounterValue
PdhIsRealTimeQuery
PdhLogServiceCommandA
PdhLogServiceControlA
PdhLookupPerfIndexByNameA
PdhLookupPerfNameByIndexA
PdhMakeCounterPathA
PdhOpenLogA
PdhOpenQueryA
PdhParseCounterPathA
PdhParseInstanceNameA
PdhReadRawLogRecord
PdhRemoveCounter
PdhSelectDataSourceA
PdhSetCounterScaleFactor
PdhSetQueryTimeRange
PdhUpdateLogA
PdhValidatePathA
PdhVbAddCounter
PdhVbCreateCounterPathList
PdhVbGetCounterPathElements
PdhVbGetCounterPathFromList
PdhVbGetDoubleCounterValue
PdhVbGetOneCounterPath
PdhVbIsGoodStatus
PdhVbOpenQuery
PeekConsoleInputA
PeekMessageA
PeekNamedPipe
PeekPenInput
PenDataFromBuffer
PenDataToBuffer
Pie
PixelFormatDescriptorFromDc
PlayEnhMetaFile
PlayEnhMetaFileRecord
PlayGdiScriptOnPrinterIC
PlayMetaFile
PlayMetaFileRecord
PlaySoundA
PlgBlt
PolyBezier
PolyBezierTo
PolyDraw
PolyPatBlt
PolyPolygon
PolyPolyline
PolyTextOutA
Polygon
Polyline
PolylineTo
PostComponentError
PostMessageA
PostODBCComponentError
PostODBCError
PostQueuedCompletionStatus
PostQuitMessage
PostThreadMessageA
PpropFindProp
PrepareTape
PrintDlgA
PrinterMessageBoxA
PrinterProperties
PrivilegeCheck
PrivilegedServiceAuditAlarmA
Process32First
Process32Next
ProcessHRC
ProgIDFromCLSID
PropCopyMore
PropStgNameToFmtId
PropSysAllocString
PropSysFreeString
PropVariantClear
PropVariantCopy
PropVariantToAdsType
PropertySheetA
PtInRect
PtInRegion
PtVisible
PulseEvent
PurgeComm
QueryDosDeviceA
QueryInformationJobObject
QueryMultiSzValueToArray
QueryPathOfRegTypeLib
QueryPerformanceCounter
QueryPerformanceFrequency
QueryRecoveryAgentsA
QueryRegistryValue
QueryRemoteFonts
QueryServiceConfig2A
QueryServiceConfigA
QueryServiceLockStatusA
QueryServiceObjectSecurity
QueryServiceStatus
QuerySpoolMode
QueryWin31IniFilesMappedToRegistry
QueryWindows31FilesMigration
QueueUserAPC
QueueWorkItem
ROUTINE
RTFSync
RaiseException
RasAdminCompressPhoneNumber
RasAdminDLLInit
RasAdminFreeBuffer
RasAdminGetErrorString
RasAdminGetUserAccountServer
RasAdminGetUserParms
RasAdminPortClearStatistics
RasAdminPortDisconnect
RasAdminPortEnum
RasAdminPortGetInfo
RasAdminServerGetInfo
RasAdminSetUserParms
RasAdminUserGetInfo
RasAdminUserSetInfo
RasAutodialAddressToNetwork
RasAutodialDisableDlgA
RasAutodialEntryToNetwork
RasAutodialQueryDlgA
RasConnectionNotificationA
RasCreatePhonebookEntryA
RasDeleteEntryA
RasDialA
RasDialDlgA
RasDialWow
RasEditPhonebookEntryA
RasEntryDlgA
RasEnumAutodialAddressesA
RasEnumConnectionsA
RasEnumConnectionsWow
RasEnumDevicesA
RasEnumEntriesA
RasEnumEntriesWow
RasGetAutodialAddressA
RasGetAutodialEnableA
RasGetAutodialParamA
RasGetConnectResponse
RasGetConnectStatusA
RasGetConnectStatusWow
RasGetCountryInfoA
RasGetCredentialsA
RasGetEntryDialParamsA
RasGetEntryPropertiesA
RasGetErrorStringA
RasGetErrorStringWow
RasGetHport
RasGetProjectionInfoA
RasGetSubEntryHandleA
RasGetSubEntryPropertiesA
RasHangUpA
RasHangUpWow
RasIsRouterConnection
RasMonitorDlgA
RasPhonebookDlgA
RasRenameEntryA
RasSetAutodialAddressA
RasSetAutodialEnableA
RasSetAutodialParamA
RasSetCredentialsA
RasSetEntryDialParamsA
RasSetEntryPropertiesA
RasSetOldPassword
RasSetSubEntryPropertiesA
RasValidateEntryNameA
RatingAccessDeniedDialog
RatingAccessDeniedDialog2
RatingAddPropertyPages
RatingCheckUserAccess
RatingEnable
RatingEnabledQuery
RatingFreeDetails
RatingInit
RatingObtainCancel
RatingObtainQuery
RatingSetupUI
RawImageClose
RawImageGetData
RawImageGetRow
ReBaseImage
ReadAsciiOrUnicodeTextFile
ReadClassStg
ReadClassStm
ReadConsoleA
ReadConsoleInputA
ReadConsoleInputExA
ReadConsoleOutputA
ReadConsoleOutputAttribute
ReadConsoleOutputCharacterA
ReadEventLogA
ReadFile
ReadFileEx
ReadFileScatter
ReadFileVlm
ReadFmtUserTypeStg
ReadHWL
ReadInt
ReadOleStg
ReadPrinter
ReadProcessMemory
ReadProcessMemoryVlm
ReadRaw
ReadStringStream
ReadUrlCacheEntryStream
RealChildWindowFromPoint
RealGetWindowClassA
RealScreenSaverProc
RealShellExecuteA
RealShellExecuteExA
RealizePalette
RealizePaletteNow
ReallocADsMem
ReallocADsStr
RectInRegion
RectVisible
Rectangle
RedisplayPenData
RedrawWindow
RefreshInstalledTestList
RegCloseKey
RegConnectRegistryA
RegCreateKeyA
RegCreateKeyExA
RegCreateKeyExU
RegDeleteKeyA
RegDeleteValueA
RegDeleteValueU
RegEnumKeyA
RegEnumKeyExA
RegEnumValueA
RegEnumValueU
RegFlushKey
RegGetKeySecurity
RegLoadKeyA
RegNotifyChangeKeyValue
RegOpenKeyA
RegOpenKeyExA
RegOverridePredefKey
RegQueryInfoKeyA
RegQueryInfoKeyU
RegQueryMultipleValuesA
RegQueryValueA
RegQueryValueExA
RegQueryValueExU
RegReplaceKeyA
RegRestoreKeyA
RegSaveKeyA
RegSetKeySecurity
RegSetValueA
RegSetValueExA
RegSetValueExU
RegUnLoadKeyA
RegenerateUserEnvironment
RegisterActiveObject
RegisterAllServers
RegisterBindStatusCallback
RegisterCMMA
RegisterClassA
RegisterClassExA
RegisterClipboardFormatA
RegisterClusterNotify
RegisterConsoleVDM
RegisterDeviceNotificationA
RegisterDialogClasses
RegisterDragDrop
RegisterEventSourceA
RegisterFormatEnumerator
RegisterHotKey
RegisterMediaTypeClass
RegisterMediaTypes
RegisterServiceCtrlHandlerA
RegisterTypeLib
RegisterWaitForInputIdle
RegisterWindowMessageA
RegisterWowBaseHandlers
RegisterWowExec
RegistryDelnode
ReleaseBindInfo
ReleaseCapture
ReleaseDC
ReleaseMutex
ReleaseNtmsCleanerSlot
ReleaseSemaphore
ReleaseStaticEntries
ReleaseStgMedium
RemoveClusterResourceDependency
RemoveClusterResourceNode
RemoveDirectoryA
RemoveFontMemResourceEx
RemoveFontResourceA
RemoveFontResourceExA
RemoveMenu
RemovePenDataStrokes
RemovePrivateCvSymbolic
RemovePrivateCvSymbolicEx
RemovePropA
RemoveRelocations
Remove_Symbol
ReplaceTextA
ReplyMessage
ReportEventA
RequestWakeupLatency
ResUtilAddUnknownProperties
ResUtilDoIoctl
ResUtilDupParameterBlock
ResUtilDupString
ResUtilEnumPrivateProperties
ResUtilEnumProperties
ResUtilEnumResources
ResUtilFindDwordProperty
ResUtilFindSzProperty
ResUtilFreeParameterBlock
ResUtilGetAllProperties
ResUtilGetBinaryProperty
ResUtilGetBinaryValue
ResUtilGetDwordProperty
ResUtilGetDwordValue
ResUtilGetEnvironmentWithNetName
ResUtilGetMultiSzProperty
ResUtilGetPrivateProperties
ResUtilGetProperties
ResUtilGetPropertiesToParameterBlock
ResUtilGetProperty
ResUtilGetPropertySize
ResUtilGetResourceDependency
ResUtilGetResourceNameDependency
ResUtilGetSzProperty
ResUtilGetSzValue
ResUtilIsPathValid
ResUtilOpenDriver
ResUtilPropertyListFromParameterBlock
ResUtilResourceTypesEqual
ResUtilResourcesEqual
ResUtilSetBinaryValue
ResUtilSetDwordValue
ResUtilSetExpandSzValue
ResUtilSetMultiSzValue
ResUtilSetPrivatePropertyList
ResUtilSetPropertyParameterBlock
ResUtilSetPropertyTable
ResUtilSetSzValue
ResUtilStartResourceService
ResUtilStopResourceService
ResUtilStopService
ResUtilVerifyPrivatePropertyList
ResUtilVerifyPropertyTable
ResUtilVerifyResourceService
ResUtilVerifyService
ReserveNtmsCleanerSlot
ResetDCA
ResetEvent
ResetForRunList
ResetPrinterA
ResizePalette
ResizePenData
RestoreConnectionA0
RestoreDC
ResumeClusterNode
ResumeThread
RetreiveFileSecurity
RetrieveServiceConfig
RetrieveUrlCacheEntryFileA
RetrieveUrlCacheEntryStreamA
ReuseDDElParam
RevertToSelf 
RevokeActiveObject
RevokeBindStatusCallback
RevokeDragDrop
RevokeFormatEnumerator
Ring_Literal
Ring_Match
RoundRect
RouterAssert
RouterEntryDlgA
RouterGetErrorStringA
RouterLogDeregisterA
RouterLogEventA
RouterLogEventDataA
RouterLogEventStringA
RouterLogRegisterA
RpcAbortAsyncCall
RpcAsyncAbortCall
RpcAsyncCancelCall
RpcAsyncCompleteCall
RpcAsyncGetCallStatus
RpcAsyncInitializeHandle
RpcAsyncRegisterInfo
RpcBindingCopy
RpcBindingFree
RpcBindingFromStringBindingA
RpcBindingInqAuthClientA
RpcBindingInqAuthInfoA
RpcBindingInqAuthInfoExA
RpcBindingInqObject
RpcBindingInqOption
RpcBindingReset
RpcBindingServerFromClient
RpcBindingSetAuthInfoA
RpcBindingSetAuthInfoExA
RpcBindingSetObject
RpcBindingSetOption
RpcBindingToStringBindingA
RpcBindingVectorFree
RpcCancelAsyncCall
RpcCancelThread
RpcCompleteAsyncCall
RpcEpRegisterA
RpcEpRegisterNoReplaceA
RpcEpResolveBinding
RpcEpUnregister
RpcGetAsyncCallStatus
RpcIfIdVectorFree
RpcIfInqId
RpcImpersonateClient
RpcInitializeAsyncHandle
RpcMgmtBindingInqParameter
RpcMgmtBindingSetParameter
RpcMgmtEnableIdleCleanup
RpcMgmtEpEltInqBegin
RpcMgmtEpEltInqDone
RpcMgmtEpEltInqNextA
RpcMgmtEpUnregister
RpcMgmtInqComTimeout
RpcMgmtInqDefaultProtectLevel
RpcMgmtInqIfIds
RpcMgmtInqParameter
RpcMgmtInqServerPrincNameA
RpcMgmtInqStats
RpcMgmtIsServerListening
RpcMgmtSetAuthorizationFn
RpcMgmtSetCancelTimeout
RpcMgmtSetComTimeout
RpcMgmtSetParameter
RpcMgmtSetServerStackSize
RpcMgmtStatsVectorFree
RpcMgmtStopServerListening
RpcMgmtWaitServerListen
RpcNetworkInqProtseqsA
RpcNetworkIsProtseqValidA
RpcNsBindingExportA
RpcNsBindingImportBeginA
RpcNsBindingImportDone
RpcNsBindingImportNext
RpcNsBindingInqEntryNameA
RpcNsBindingLookupBeginA
RpcNsBindingLookupDone
RpcNsBindingLookupNext
RpcNsBindingSelect
RpcNsBindingUnexportA
RpcNsEntryExpandNameA
RpcNsEntryObjectInqBeginA
RpcNsEntryObjectInqDone
RpcNsEntryObjectInqNext
RpcNsGroupDeleteA
RpcNsGroupMbrAddA
RpcNsGroupMbrInqBeginA
RpcNsGroupMbrInqDone
RpcNsGroupMbrInqNextA
RpcNsGroupMbrRemoveA
RpcNsMgmtBindingUnexportA
RpcNsMgmtEntryCreateA
RpcNsMgmtEntryDeleteA
RpcNsMgmtEntryInqIfIdsA
RpcNsMgmtHandleSetExpAge
RpcNsMgmtInqExpAge
RpcNsMgmtSetExpAge
RpcNsProfileDeleteA
RpcNsProfileEltAddA
RpcNsProfileEltInqBeginA
RpcNsProfileEltInqDone
RpcNsProfileEltInqNextA
RpcNsProfileEltRemoveA
RpcObjectInqType
RpcObjectSetInqFn
RpcObjectSetType
RpcProtseqVectorFreeA
RpcRaiseException
RpcRegisterAsyncInfo
RpcRevertToSelf
RpcRevertToSelfEx
RpcServerInqBindings
RpcServerInqDefaultPrincNameA
RpcServerInqIf
RpcServerListen
RpcServerRegisterAuthInfoA
RpcServerRegisterIf
RpcServerRegisterIfEx
RpcServerTestCancel
RpcServerUnregisterIf
RpcServerUseAllProtseqs
RpcServerUseAllProtseqsEx
RpcServerUseAllProtseqsIf
RpcServerUseAllProtseqsIfEx
RpcServerUseProtseqA
RpcServerUseProtseqEpA
RpcServerUseProtseqEpExA
RpcServerUseProtseqExA
RpcServerUseProtseqIfA
RpcServerUseProtseqIfExA
RpcSmAllocate
RpcSmClientFree
RpcSmDestroyClientContext
RpcSmDisableAllocate
RpcSmEnableAllocate
RpcSmFree
RpcSmGetThreadHandle
RpcSmSetClientAllocFree
RpcSmSetThreadHandle
RpcSmSwapClientAllocFree
RpcSsAllocate
RpcSsDestroyClientContext
RpcSsDisableAllocate
RpcSsDontSerializeContext
RpcSsEnableAllocate
RpcSsFree
RpcSsGetThreadHandle
RpcSsSetClientAllocFree
RpcSsSetThreadHandle
RpcSsSwapClientAllocFree
RpcStringBindingComposeA
RpcStringBindingParseA
RpcStringFreeA
RpcTestCancel
RtlFillMemory
RtlMoveMemory
RtlUnwind
RtlZeroMemory
Rtl_Free
Rtl_Malloc
RtmAddRoute
RtmBlockConvertRoutesToStatic
RtmBlockDeleteRoutes
RtmBlockSetRouteEnable
RtmCloseEnumerationHandle
RtmCreateEnumerationHandle
RtmCreateRouteTable
RtmDeleteRoute
RtmDeleteRouteTable
RtmDequeueRouteChangeMessage
RtmDeregisterClient
RtmEnumerateGetNextRoute
RtmGetFirstRoute
RtmGetNetworkCount
RtmGetNextRoute
RtmGetRouteAge
RtmIsRoute
RtmRegisterClient
RunAutoTest
RunOnceUrlCache
RxNetAccessAdd
RxNetAccessDel
RxNetAccessEnum
RxNetAccessGetInfo
RxNetAccessGetUserPerms
RxNetAccessSetInfo
RxNetServerEnum
RxNetUserPasswordSet
SCardAddReaderToGroupA
SCardBeginTransaction
SCardCancel
SCardConnectA
SCardControl
SCardDisconnect
SCardDlgExtendedError
SCardEndTransaction
SCardEstablishContext
SCardForgetCardTypeA
SCardForgetReaderA
SCardForgetReaderGroupA
SCardFreeMemory
SCardGetAttrib
SCardGetProviderIdA
SCardGetStatusChangeA
SCardIntroduceCardTypeA
SCardIntroduceReaderA
SCardIntroduceReaderGroupA
SCardListCardsA
SCardListInterfacesA
SCardListReaderGroupsA
SCardListReadersA
SCardLocateCardsA
SCardReconnect
SCardReleaseContext
SCardRemoveReaderFromGroupA
SCardSetAttrib
SCardState
SCardStatusA
SCardTransmit
SHAddToRecentDocs
SHAppBarMessage
SHBrowseForFolderA
SHChangeNotify
SHCreateShellPalette
SHDeleteEmptyKeyA
SHDeleteKeyA
SHDeleteOrphanKeyA
SHDeleteValueA
SHEmptyRecycleBinA
SHEnumKeyExA
SHEnumValueA
SHFileOperationA
SHFormatDrive
SHFreeNameMappings
SHGetDataFromIDListA
SHGetDesktopFolder
SHGetDiskFreeSpaceA
SHGetFileInfoA
SHGetInstanceExplorer
SHGetInverseCMAP
SHGetMalloc
SHGetNewLinkInfo
SHGetPathFromIDListA
SHGetSettings
SHGetSpecialFolderLocation
SHGetSpecialFolderPathA
SHGetValueA
SHInvokePrinterCommandA
SHIsLowMemoryMachine
SHLoadInProc
SHOpenRegStreamA
SHQueryInfoKeyA
SHQueryRecycleBinA
SHQueryValueExA
SHRegCloseUSKey
SHRegCreateUSKeyA
SHRegDeleteEmptyUSKeyA
SHRegDeleteUSValueA
SHRegEnumUSKeyA
SHRegEnumUSValueA
SHRegGetBoolUSValueA
SHRegGetUSValueA
SHRegOpenUSKeyA
SHRegQueryInfoUSKeyA
SHRegQueryUSValueA
SHRegSetUSValueA
SHRegWriteUSValueA
SHSetValueA
SHUpdateRecycleBinIcon
SNB_UserFree
SNB_UserMarshal
SNB_UserSize
SNB_UserUnmarshal
SQLAllocConnect
SQLAllocEnv
SQLAllocHandle
SQLAllocHandleStd
SQLAllocStmt
SQLBindCol
SQLBindParam
SQLBindParameter
SQLBrowseConnectA
SQLBulkOperations
SQLCancel
SQLCloseCursor
SQLColAttributeA
SQLColAttributesA
SQLColumnPrivilegesA
SQLColumnsA
SQLConfigDataSource
SQLConfigDriver
SQLConnectA
SQLCopyDesc
SQLCreateDataSource
SQLDataSourcesA
SQLDescribeColA
SQLDescribeParam
SQLDisconnect
SQLDriverConnectA
SQLDriversA
SQLEndTran
SQLErrorA
SQLExecDirectA
SQLExecute
SQLExtendedFetch
SQLFetch
SQLFetchScroll
SQLForeignKeysA
SQLFreeConnect
SQLFreeEnv
SQLFreeHandle
SQLFreeStmt
SQLGetAvailableDrivers
SQLGetConfigMode
SQLGetConnectAttrA
SQLGetConnectOptionA
SQLGetCursorNameA
SQLGetData
SQLGetDescFieldA
SQLGetDescRecA
SQLGetDiagFieldA
SQLGetDiagRecA
SQLGetEnvAttr
SQLGetFunctions
SQLGetInfoA
SQLGetInstalledDrivers
SQLGetPrivateProfileString
SQLGetStmtAttrA
SQLGetStmtOption
SQLGetTranslator
SQLGetTypeInfoA
SQLInstallDriver
SQLInstallDriverEx
SQLInstallDriverManager
SQLInstallODBC
SQLInstallTranslator
SQLInstallTranslatorEx
SQLInstallerError
SQLManageDataSources
SQLMoreResults
SQLNativeSqlA
SQLNumParams
SQLNumResultCols
SQLParamData
SQLParamOptions
SQLPostInstallerError
SQLPrepareA
SQLPrimaryKeysA
SQLProcedureColumnsA
SQLProceduresA
SQLPutData
SQLReadFileDSN
SQLRemoveDSNFromIni
SQLRemoveDefaultDataSource
SQLRemoveDriver
SQLRemoveDriverManager
SQLRemoveTranslator
SQLRowCount
SQLSetConfigMode
SQLSetConnectAttrA
SQLSetConnectOptionA
SQLSetCursorNameA
SQLSetDescFieldA
SQLSetDescRec
SQLSetEnvAttr
SQLSetParam
SQLSetPos
SQLSetScrollOptions
SQLSetStmtAttrA
SQLSetStmtOption
SQLSpecialColumnsA
SQLStatisticsA
SQLTablePrivilegesA
SQLTablesA
SQLTransact
SQLValidDSN
SQLWriteDSNToIni
SQLWriteFileDSN
SQLWritePrivateProfileString
STGMEDIUM_UserFree
STGMEDIUM_UserMarshal
STGMEDIUM_UserSize
STGMEDIUM_UserUnmarshal
SafeArrayAccessData
SafeArrayAllocData
SafeArrayAllocDescriptor
SafeArrayAllocDescriptorEx
SafeArrayCopy
SafeArrayCopyData
SafeArrayCreate
SafeArrayCreateEx
SafeArrayCreateVector
SafeArrayCreateVectorEx
SafeArrayDestroy
SafeArrayDestroyData
SafeArrayDestroyDescriptor
SafeArrayGetDim
SafeArrayGetElement
SafeArrayGetElemsize
SafeArrayGetIID
SafeArrayGetLBound
SafeArrayGetRecordInfo
SafeArrayGetUBound
SafeArrayGetVartype
SafeArrayLock
SafeArrayPtrOfIndex
SafeArrayPutElement
SafeArrayRedim
SafeArraySetIID
SafeArraySetRecordInfo
SafeArrayUnaccessData
SafeArrayUnlock
SatisfyNtmsOperatorRequest
SaveDC
ScBinFromHexBounded
ScCopyNotifications
ScCopyProps
ScCountNotifications
ScCountProps
ScCreateConversationIndex
ScDupPropset
ScGenerateMuid
ScInitMapiUtil
ScLocalPathFromUNC
ScRelocNotifications
ScRelocProps
ScUNCFromLocalPath
ScaleViewportExtEx
ScaleWindowExtEx
ScheduleJob
ScreenSaverChangePassword
ScreenSaverConfigureDialog
ScreenSaverProc
ScreenToClient
ScrollChildren
ScrollConsoleScreenBufferA
ScrollDC
ScrollWindow
ScrollWindowEx
SearchForInfFile
SearchPathA
SearchStatusCode
SearchTreeForFile
SeekFolder
SeekPrinter
SelectBrushLocal
SelectCMM
SelectClipPath
SelectClipRgn
SelectFontLocal
SelectObject
SelectPalette
SendDlgItemMessageA
SendDriverMessage
SendIMEMessageExA
SendInput
SendMessageA
SendMessageCallbackA
SendMessageTimeoutA
SendNotifyMessageA
ServiceHandler
ServiceMain
SetAbortProc
SetAclInformation
SetActiveWindow
SetAllocFailCount
SetAlphabetHRC
SetAlphabetPriorityHRC
SetArcDirection
SetArrayToMultiSzValue
SetAttribIMsgOnIStg
SetBitmapBits
SetBitmapDimensionEx
SetBkColor
SetBkMode
SetBoundsRect
SetBoxAlphabetHRC
SetBrushOrgEx
SetCapture
SetCaretBlinkTime
SetCaretPos
SetClassLongA
SetClassWord
SetClipboardData
SetClipboardViewer
SetClusterGroupName
SetClusterGroupNodeList
SetClusterName
SetClusterNetworkName
SetClusterNetworkPriorityOrder
SetClusterQuorumResource
SetClusterResourceName
SetColorAdjustment
SetColorProfileElement
SetColorProfileElementReference
SetColorProfileElementSize
SetColorProfileHeader
SetColorSpace
SetCommBreak
SetCommConfig
SetCommMask
SetCommState
SetCommTimeouts
SetComputerNameA
SetConsoleActiveScreenBuffer
SetConsoleCP
SetConsoleCommandHistoryMode
SetConsoleCtrlHandler
SetConsoleCursor
SetConsoleCursorInfo
SetConsoleCursorPosition
SetConsoleDisplayMode
SetConsoleFont
SetConsoleHardwareState
SetConsoleIcon
SetConsoleInputExeNameA
SetConsoleKeyShortcuts
SetConsoleMaximumWindowSize
SetConsoleMenuClose
SetConsoleMode
SetConsoleNumberOfCommandsA
SetConsoleOutputCP
SetConsolePalette
SetConsoleScreenBufferSize
SetConsoleTextAttribute
SetConsoleTitleA
SetConsoleWindowInfo
SetConvertStg
SetCriticalSectionSpinCount
SetCurrentDirectoryA
SetCursor
SetCursorPos
SetDCBrushColor
SetDCPenColor
SetDIBColorTable
SetDIBits
SetDIBitsToDevice
SetDebugErrorLevel
SetDecompressionType
SetDefaultCommConfigA
SetDefaultPrinterA
SetDeskWallpaper
SetDeviceGammaRamp
SetDlgItemInt
SetDlgItemTextA
SetDocumentBitStg
SetDoubleClickTime
SetEndOfFile
SetEnhMetaFileBits
SetEntriesInAccessListA
SetEntriesInAclA
SetEntriesInAuditListA
SetEnvironmentVariableA
SetErrorInfo
SetErrorMode
SetEvent
SetFileApisToANSI
SetFileApisToOEM
SetFileAttributesA
SetFilePointer
SetFileSecurityA
SetFileTime
SetFilters
SetFocus
SetFontEnumeration
SetForegroundWindow
SetFormA
SetGraphicsMode
SetGuideHRC
SetHandleCount
SetHandleInformation
SetICMMode
SetICMProfileA
SetImageConfigInformation
SetInformationJobObject
SetInternationalHRC
SetIoCompletionProc
SetJobA
SetKernelObjectSecurity
SetKeyboardState
SetLastConsoleEventActive
SetLastError
SetLastErrorEx
SetLocalTime
SetLocaleInfoA
SetMagicColors
SetMailslotInfo
SetMapMode
SetMapperFlags
SetMaxResultsHRC
SetMenu
SetMenuContextHelpId
SetMenuDefaultItem
SetMenuInfo
SetMenuItemBitmaps
SetMenuItemInfoA
SetMessageExtraInfo
SetMessageQueue
SetMetaFileBitsEx
SetMetaRgn
SetMiterLimit
SetNamedPipeHandleState
SetNamedSecurityInfoA
SetNamedSecurityInfoExA
SetNtmsMediaComplete
SetNtmsObjectAttributeA
SetNtmsObjectInformationA
SetNtmsObjectSecurity
SetPaletteEntries
SetParent
SetPenAppFlags
SetPenMiscInfo
SetPixel
SetPixelFormat
SetPixelV
SetPolyFillMode
SetPortA
SetPrinterA
SetPrinterDataA
SetPrinterDataExA
SetPrinterHTMLViewA
SetPriorityClass
SetPrivateObjectSecurity
SetPrivateObjectSecurityEx
SetProcessAffinityMask
SetProcessPriorityBoost
SetProcessShutdownParameters
SetProcessWindowStation
SetProcessWorkingSetSize
SetPropA
SetROP2
SetRect
SetRectEmpty
SetRectRgn
SetRelAbs
SetResultsHookHREC
SetScrollInfo
SetScrollPos
SetScrollRange
SetSecurityDescriptorControl
SetSecurityDescriptorDacl
SetSecurityDescriptorGroup
SetSecurityDescriptorOwner
SetSecurityDescriptorSacl
SetSecurityInfo
SetSecurityInfoExA
SetServiceA
SetServiceBits
SetServiceObjectSecurity
SetServiceStatus
SetShellWindow
SetSoftwareUpdateAdvertisementState
SetStandardColorSpaceProfileA
SetStdHandle
SetStretchBltMode
SetStrokeAttributes
SetStrokeTableAttributes
SetSysColors
SetSystemCursor
SetSystemMenu
SetSystemPaletteUse
SetSystemPowerState
SetSystemTime
SetSystemTimeAdjustment
SetSystemTimer
SetTapeParameters
SetTapePosition
SetTextAlign
SetTextCharacterExtra
SetTextColor
SetTextJustification
SetThreadAffinityMask
SetThreadContext
SetThreadDesktop
SetThreadExecutionState
SetThreadIdealProcessor
SetThreadLocale
SetThreadPriority
SetThreadPriorityBoost
SetThreadToken
SetTimeZoneInformation
SetTimer
SetTokenInformation
SetUnhandledExceptionFilter
SetUrlCacheConfigInfoA
SetUrlCacheEntryGroup
SetUrlCacheEntryInfoA
SetUrlCacheHeaderData
SetUserObjectInformationA
SetUserObjectSecurity
SetVDMCurrentDirectories
SetViewportExtEx
SetViewportOrgEx
SetVolumeLabelA
SetWaitableTimer
SetWinEventHook
SetWinMetaFileBits
SetWindowContextHelpId
SetWindowExtEx
SetWindowLongA
SetWindowOrgEx
SetWindowPlacement
SetWindowPos
SetWindowRgn
SetWindowTextA
SetWindowWord
SetWindowsHookA
SetWindowsHookExA
SetWordlistCoercionHRC
SetWordlistHRC
SetWorldTransform
SetupAddInstallSectionToDiskSpaceListA
SetupAddSectionToDiskSpaceListA
SetupAddToDiskSpaceListA
SetupAddToSourceListA
SetupAdjustDiskSpaceListA
SetupCancelTemporarySourceList
SetupCloseFileQueue
SetupCloseInfFile
SetupCloseLog
SetupColorMatchingA
SetupComm
SetupCommitFileQueueA
SetupCopyErrorA
SetupCopyOEMInfA
SetupCreateDiskSpaceListA
SetupDecompressOrCopyFileA
SetupDefaultQueueCallbackA
SetupDeleteErrorA
SetupDestroyDiskSpaceList
SetupDiAskForOEMDisk
SetupDiBuildClassInfoList
SetupDiBuildClassInfoListExA
SetupDiBuildDriverInfoList
SetupDiCallClassInstaller
SetupDiCancelDriverInfoSearch
SetupDiChangeState
SetupDiClassGuidsFromNameA
SetupDiClassGuidsFromNameExA
SetupDiClassNameFromGuidA
SetupDiClassNameFromGuidExA
SetupDiCreateDevRegKeyA
SetupDiCreateDeviceInfoA
SetupDiCreateDeviceInfoList
SetupDiCreateDeviceInfoListExA
SetupDiCreateDeviceInterfaceA
SetupDiCreateDeviceInterfaceRegKeyA
SetupDiDeleteDevRegKey
SetupDiDeleteDeviceInfo
SetupDiDeleteDeviceInterfaceData
SetupDiDeleteDeviceInterfaceRegKey
SetupDiDestroyClassImageList
SetupDiDestroyDeviceInfoList
SetupDiDestroyDriverInfoList
SetupDiDrawMiniIcon
SetupDiEnumDeviceInfo
SetupDiEnumDeviceInterfaces
SetupDiEnumDriverInfoA
SetupDiGetActualSectionToInstallA
SetupDiGetClassBitmapIndex
SetupDiGetClassDescriptionA
SetupDiGetClassDescriptionExA
SetupDiGetClassDevPropertySheetsA
SetupDiGetClassDevsA
SetupDiGetClassDevsExA
SetupDiGetClassImageIndex
SetupDiGetClassImageList
SetupDiGetClassImageListExA
SetupDiGetClassInstallParamsA
SetupDiGetDeviceInfoListClass
SetupDiGetDeviceInfoListDetailA
SetupDiGetDeviceInstallParamsA
SetupDiGetDeviceInstanceIdA
SetupDiGetDeviceInterfaceAlias
SetupDiGetDeviceInterfaceDetailA
SetupDiGetDeviceRegistryPropertyA
SetupDiGetDriverInfoDetailA
SetupDiGetDriverInstallParamsA
SetupDiGetHwProfileFriendlyNameA
SetupDiGetHwProfileFriendlyNameExA
SetupDiGetHwProfileList
SetupDiGetHwProfileListExA
SetupDiGetINFClassA
SetupDiGetSelectedDevice
SetupDiGetSelectedDriverA
SetupDiGetWizardPage
SetupDiInstallClassA
SetupDiInstallClassExA
SetupDiInstallDevice
SetupDiInstallDeviceInterfaces
SetupDiInstallDriverFiles
SetupDiLoadClassIcon
SetupDiMoveDuplicateDevice
SetupDiOpenClassRegKey
SetupDiOpenClassRegKeyExA
SetupDiOpenDevRegKey
SetupDiOpenDeviceInfoA
SetupDiOpenDeviceInterfaceA
SetupDiOpenDeviceInterfaceRegKey
SetupDiRegisterCoDeviceInstallers
SetupDiRegisterDeviceInfo
SetupDiRemoveDevice
SetupDiRemoveDeviceInterface
SetupDiSelectBestCompatDrv
SetupDiSelectDevice
SetupDiSelectOEMDrv
SetupDiSetClassInstallParamsA
SetupDiSetDeviceInstallParamsA
SetupDiSetDeviceRegistryPropertyA
SetupDiSetDriverInstallParamsA
SetupDiSetSelectedDevice
SetupDiSetSelectedDriverA
SetupDiUnremoveDevice
SetupDuplicateDiskSpaceListA
SetupFileInfo
SetupFindFirstLineA
SetupFindNextLine
SetupFindNextMatchLineA
SetupFreeSourceListA
SetupGetBinaryField
SetupGetFieldCount
SetupGetFileCompressionInfoA
SetupGetInfFileListA
SetupGetInfInformationA
SetupGetInfSections
SetupGetIntField
SetupGetLineByIndexA
SetupGetLineCountA
SetupGetLineTextA
SetupGetMultiSzFieldA
SetupGetSourceFileLocationA
SetupGetSourceFileSizeA
SetupGetSourceInfoA
SetupGetStringFieldA
SetupGetTargetPathA
SetupInitDefaultQueueCallback
SetupInitDefaultQueueCallbackEx
SetupInitializeFileLogA
SetupInstallFileA
SetupInstallFileExA
SetupInstallFilesFromInfSectionA
SetupInstallFromInfSectionA
SetupInstallServicesFromInfSectionA
SetupInstallServicesFromInfSectionExA
SetupIterateCabinetA
SetupLogErrorA
SetupLogFileA
SetupOpenAppendInfFileA
SetupOpenFileQueue
SetupOpenInfFileA
SetupOpenLog
SetupOpenMasterInf
SetupPromptForDiskA
SetupPromptReboot
SetupQueryDrivesInDiskSpaceListA
SetupQueryFileLogA
SetupQueryInfFileInformationA
SetupQueryInfVersionInformationA
SetupQuerySourceListA
SetupQuerySpaceRequiredOnDriveA
SetupQueueCopyA
SetupQueueCopySectionA
SetupQueueDefaultCopyA
SetupQueueDeleteA
SetupQueueDeleteSectionA
SetupQueueRenameA
SetupQueueRenameSectionA
SetupRemoveFileLogEntryA
SetupRemoveFromDiskSpaceListA
SetupRemoveFromSourceListA
SetupRemoveInstallSectionFromDiskSpaceListA
SetupRemoveSectionFromDiskSpaceListA
SetupRenameErrorA
SetupScanFileQueueA
SetupSetDirectoryIdA
SetupSetDirectoryIdExA
SetupSetPlatformPathOverrideA
SetupSetSourceListA
SetupTermDefaultQueueCallback
SetupTerminateFileLog
SheChangeDirA
SheChangeDirExA
SheFullPathA
SheGetCurDrive
SheGetDirA
SheRemoveQuotesA
SheSetCurDrive
SheShortenPathA
ShellAboutA
ShellExecuteA
ShellExecuteExA
ShellHookProc
Shell_NotifyIconA
ShouldDeviceBeExcluded
ShowCaret
ShowClientAuthCerts
ShowConsoleCursor
ShowCursor
ShowHideMenuCtl
ShowOwnedPopups
ShowScrollBar
ShowSecurityInfo
ShowWindow
ShowWindowAsync
ShowX509EncodedCertificate
SignalObjectAndWait
SizeofResource
Sleep
SleepEx
SnmpCleanup
SnmpClose
SnmpContextToStr
SnmpCountVbl
SnmpCreatePdu
SnmpCreateSession
SnmpCreateVbl
SnmpDecodeMsg
SnmpDeleteVb
SnmpDuplicatePdu
SnmpDuplicateVbl
SnmpEncodeMsg
SnmpEntityToStr
SnmpFreeContext
SnmpFreeDescriptor
SnmpFreeEntity
SnmpFreePdu
SnmpFreeVbl
SnmpGetLastError
SnmpGetPduData
SnmpGetRetransmitMode
SnmpGetRetry
SnmpGetTimeout
SnmpGetTranslateMode
SnmpGetVb
SnmpListen
SnmpMgrClose
SnmpMgrGetTrap
SnmpMgrGetTrapEx
SnmpMgrMIB2Disk
SnmpMgrOidToStr
SnmpMgrOpen
SnmpMgrRequest
SnmpMgrStrToOid
SnmpMgrTrapListen
SnmpOidCompare
SnmpOidCopy
SnmpOidToStr
SnmpOpen
SnmpRecvMsg
SnmpRegister
SnmpSendMsg
SnmpSetPduData
SnmpSetPort
SnmpSetRetransmitMode
SnmpSetRetry
SnmpSetTimeout
SnmpSetTranslateMode
SnmpSetVb
SnmpStartup
SnmpStrToContext
SnmpStrToEntity
SnmpStrToOid
SnmpSvcAddrIsIpx
SnmpSvcAddrToSocket
SnmpSvcGetEnterpriseOID
SnmpSvcGetUptime
SnmpSvcInitUptime
SnmpSvcSetLogLevel
SnmpSvcSetLogType
SnmpUtilAsnAnyCpy
SnmpUtilAsnAnyFree
SnmpUtilIdsToA
SnmpUtilMemAlloc
SnmpUtilMemFree
SnmpUtilMemReAlloc
SnmpUtilOctetsCmp
SnmpUtilOctetsCpy
SnmpUtilOctetsFree
SnmpUtilOctetsNCmp
SnmpUtilOidAppend
SnmpUtilOidCmp
SnmpUtilOidCpy
SnmpUtilOidFree
SnmpUtilOidNCmp
SnmpUtilOidToA
SnmpUtilPrintAsnAny
SnmpUtilPrintOid
SnmpUtilVarBindCpy
SnmpUtilVarBindFree
SnmpUtilVarBindListCpy
SnmpUtilVarBindListFree
SplitSymbols
SpoolerCopyFileEvent
SpoolerInit
SpoolerPrinterEvent
StackWalk
StampFileSecurity
StartDocA
StartDocDlgA
StartDocPrinterA
StartInking
StartPage
StartPagePrinter
StartPenInput
StartServiceA
StartServiceCtrlDispatcherA
StgCreateDocfile
StgCreateDocfileOnILockBytes
StgCreatePropSetStg
StgCreatePropStg
StgCreateStorageEx
StgGetIFillLockBytesOnFile
StgGetIFillLockBytesOnILockBytes
StgIsStorageFile
StgIsStorageILockBytes
StgOpenAsyncDocfileOnIFillLockBytes
StgOpenLayoutDocfile
StgOpenPropStg
StgOpenStorage
StgOpenStorageEx
StgOpenStorageOnILockBytes
StgSetTimes
StopInking
StopPenInput
StrCSpnA
StrCSpnIA
StrChrA
StrChrIA
StrCmpNA
StrCmpNIA
StrCpyNA
StrDupA
StrFormatByteSizeA
StrFromTimeIntervalA
StrIsIntlEqualA
StrNCatA
StrNCmpA
StrNCmpIA
StrNCpyA
StrPBrkA
StrRChrA
StrRChrIA
StrRStrA
StrRStrIA
StrSpnA
StrStrA
StrStrIA
StrToIntA
StrToIntExA
StrTrimA
StretchBlt
StretchDIB
StretchDIBits
StringFromCLSID
StringFromGUID2
StringFromIID
StringTableAddString
StringTableAddStringEx
StringTableDestroy
StringTableDuplicate
StringTableEnum
StringTableGetExtraData
StringTableInitialize
StringTableInitializeEx
StringTableLookUpString
StringTableLookUpStringEx
StringTableSetExtraData
StringTableStringFromId
StringTableTrim
StrokeAndFillPath
StrokePath
SubmitNtmsOperatorRequestA
SubtractRect
SuspendThread
SwapBuffers
SwapMouseButton
SwapNtmsMedia
SwapPlong
SwapPword
SwitchDesktop
SwitchToFiber
SwitchToNewCab
SwitchToThread
SymCleanup
SymEnumerateModules
SymEnumerateSymbols
SymFunctionTableAccess
SymGetLineFromAddr
SymGetLineFromName
SymGetLineNext
SymGetLinePrev
SymGetModuleBase
SymGetModuleInfo
SymGetOptions
SymGetSearchPath
SymGetSymFromAddr
SymGetSymFromName
SymGetSymNext
SymGetSymPrev
SymInitialize
SymLoadModule
SymMatchFileName
SymRegisterCallback
SymSetOptions
SymSetSearchPath
SymUnDName
SymUnloadModule
SymbolToCharacter
SynchronizeWindows31FilesAndWindowsNTRegistry
SysAllocString
SysAllocStringByteLen
SysAllocStringLen
SysFreeString
SysReAllocString
SysReAllocStringLen
SysStringByteLen
SysStringLen
SystemFunction001
SystemFunction002
SystemFunction003
SystemFunction004
SystemFunction005
SystemFunction006
SystemFunction007
SystemFunction008
SystemFunction009
SystemFunction010
SystemFunction011
SystemFunction012
SystemFunction013
SystemFunction014
SystemFunction015
SystemFunction016
SystemFunction017
SystemFunction018
SystemFunction019
SystemFunction020
SystemFunction021
SystemFunction022
SystemFunction023
SystemFunction024
SystemFunction025
SystemFunction026
SystemFunction027
SystemFunction028
SystemFunction029
SystemFunction030
SystemFunction031
SystemFunction032
SystemFunction033
SystemParametersInfoA
SystemTimeToFileTime
SystemTimeToTzSpecificLocalTime
SystemTimeToVariantTime
SzFindCh
SzFindLastCh
SzFindSz
TPtoDP
TabbedTextOutA
TakeOwnershipOfFile
TargetPoints
TerminateJobObject
TerminateProcess
TerminateThread
TestProc
TextOutA
Thread32First
Thread32Next
ThunkConnect32
TileChildWindows
TileWindows
TlsAlloc
TlsFree
TlsGetValue
TlsSetValue
ToAscii
ToAsciiEx
ToUnicode
ToUnicodeEx
Toolhelp32ReadProcessMemory
TouchFileTimes
TowerConstruct
TowerExplode
TraceDeregisterA
TraceDeregisterExA
TraceDumpExA
TraceGetConsoleA
TracePutsExA
TraceRegisterExA
TraceVprintfExA
TrackMouseEvent
TrackPopupMenu
TrackPopupMenuEx
TrainHREC
TransactNamedPipe
TranslateAcceleratorA
TranslateBitmapBits
TranslateCharsetInfo
TranslateColors
TranslateMDISysAccel
TranslateMessage
TranslateURLA
TransmitCommChar
TransmitFile
TransparentBlt
TrimPenData
TrimVirtualBuffer
TrusteeAccessToObjectA
TryEnterCriticalSection
UFromSz
UNKOBJ_COFree
UNKOBJ_Free
UNKOBJ_FreeRows
UNKOBJ_ScAllocate
UNKOBJ_ScAllocateMore
UNKOBJ_ScCOAllocate
UNKOBJ_ScCOReallocate
UNKOBJ_ScSzFromIdsAlloc
URLAssociationDialogA
URLDownloadA
URLDownloadToCacheFileA
URLDownloadToFileA
URLOpenBlockingStreamA
URLOpenPullStreamA
URLOpenStreamA
UlAddRef
UlFromSzHex
UlPropSize
UlRelease
UnDecorateSymbolName
UnMapAndLoad
UnMapLS
UnMapSLFixArray
UnRegisterTypeLib
UnhandledExceptionFilter
UnhookResultsHookHREC
UnhookWinEvent
UnhookWindowsHook
UnhookWindowsHookEx
UnicodeToMultiByte
UninitializeFlatSB
UninstallColorProfileA
UninstallRecognizer
UnionRect
UnloadKeyboardLayout
UnloadPerfCounterTextStringsA
UnloadPwdDLL
UnlockFile
UnlockFileEx
UnlockServiceDatabase
UnlockUrlCacheEntryFile
UnlockUrlCacheEntryStream
UnmapAndCloseFile
UnmapDebugInformation
UnmapViewOfFile
UnmapViewOfFileVlm
UnpackDDElParam
UnrealizeObject
UnregisterCMMA
UnregisterClassA
UnregisterDeviceNotification
UnregisterHotKey
UpdateClassStoreSettings
UpdateColors
UpdateDCOMSettings
UpdateDebugInfoFile
UpdateDebugInfoFileEx
UpdateICMRegKeyA
UpdateNtmsOmidInfo
UpdateResourceA
UpdateStaticMapping
UpdateUrlCacheContentPath
UpdateWindow
UrlApplySchemeA
UrlCanonicalizeA
UrlCombineA
UrlCompareA
UrlCreateFromPathA
UrlEscapeA
UrlGetLocationA
UrlGetPartA
UrlHashA
UrlIsA
UrlIsNoHistoryA
UrlIsOpaqueA
UrlMkBuildVersion
UrlMkGetSessionOption
UrlMkSetSessionOption
UrlUnescapeA
UserBSTR_free_inst
UserBSTR_free_local
UserBSTR_from_local
UserBSTR_to_local
UserEXCEPINFO_free_inst
UserEXCEPINFO_free_local
UserEXCEPINFO_from_local
UserEXCEPINFO_to_local
UserHWND_free_inst
UserHWND_free_local
UserHWND_from_local
UserHWND_to_local
UserHandleGrantAccess
UserMSG_free_inst
UserMSG_free_local
UserMSG_from_local
UserMSG_to_local
UserVARIANT_free_inst
UserVARIANT_free_local
UserVARIANT_from_local
UserVARIANT_to_local
UtConvertDvtd16toDvtd32
UtConvertDvtd32toDvtd16
UtGetDvtd16Info
UtGetDvtd32Info
UuidCompare
UuidCreate
UuidCreateNil
UuidEqual
UuidFromStringA
UuidHash
UuidIsNil
UuidToStringA
VARIANT_UserFree
VARIANT_UserMarshal
VARIANT_UserSize
VARIANT_UserUnmarshal
VDMBreakThread
VDMConsoleOperation
VDMEnumTaskWOWEx
VDMGetAddrExpression
VDMGetContext
VDMGetDbgFlags
VDMGetModuleSelector
VDMGetPointer
VDMGetSegmentInfo
VDMGetSegtablePointer
VDMGetSelectorModule
VDMGetSymbol
VDMGetThreadContext
VDMGetThreadSelectorEntry
VDMGlobalFirst
VDMGlobalNext
VDMIsModuleLoaded
VDMModuleFirst
VDMModuleNext
VDMOperationStarted
VDMProcessException
VDMSetContext
VDMSetDbgFlags
VDMSetThreadContext
VFreeErrors
VRetrieveDriverErrorsRowCol
ValidateErrorQueue
ValidateRect
ValidateRgn
VarAbs
VarAdd
VarAnd
VarBoolFromCy
VarBoolFromDate
VarBoolFromDec
VarBoolFromDisp
VarBoolFromI1
VarBoolFromI2
VarBoolFromI4
VarBoolFromR4
VarBoolFromR8
VarBoolFromStr
VarBoolFromUI1
VarBoolFromUI2
VarBoolFromUI4
VarBstrCat
VarBstrCmp
VarBstrFromBool
VarBstrFromCy
VarBstrFromDate
VarBstrFromDec
VarBstrFromDisp
VarBstrFromI1
VarBstrFromI2
VarBstrFromI4
VarBstrFromR4
VarBstrFromR8
VarBstrFromUI1
VarBstrFromUI2
VarBstrFromUI4
VarCat
VarCmp
VarCyAbs
VarCyAdd
VarCyCmp
VarCyCmpR8
VarCyFix
VarCyFromBool
VarCyFromDate
VarCyFromDec
VarCyFromDisp
VarCyFromI1
VarCyFromI2
VarCyFromI4
VarCyFromR4
VarCyFromR8
VarCyFromStr
VarCyFromUI1
VarCyFromUI2
VarCyFromUI4
VarCyInt
VarCyMul
VarCyMulI4
VarCyNeg
VarCyRound
VarCySub
VarDateFromBool
VarDateFromCy
VarDateFromDec
VarDateFromDisp
VarDateFromI1
VarDateFromI2
VarDateFromI4
VarDateFromR4
VarDateFromR8
VarDateFromStr
VarDateFromUI1
VarDateFromUI2
VarDateFromUI4
VarDateFromUdate
VarDecAbs
VarDecAdd
VarDecCmp
VarDecCmpR8
VarDecDiv
VarDecFix
VarDecFromBool
VarDecFromCy
VarDecFromDate
VarDecFromDisp
VarDecFromI1
VarDecFromI2
VarDecFromI4
VarDecFromR4
VarDecFromR8
VarDecFromStr
VarDecFromUI1
VarDecFromUI2
VarDecFromUI4
VarDecInt
VarDecMul
VarDecNeg
VarDecRound
VarDecSub
VarDiv
VarEqv
VarFix
VarFormat
VarFormatCurrency
VarFormatDateTime
VarFormatFromTokens
VarFormatNumber
VarFormatPercent
VarI1FromBool
VarI1FromCy
VarI1FromDate
VarI1FromDec
VarI1FromDisp
VarI1FromI2
VarI1FromI4
VarI1FromR4
VarI1FromR8
VarI1FromStr
VarI1FromUI1
VarI1FromUI2
VarI1FromUI4
VarI2FromBool
VarI2FromCy
VarI2FromDate
VarI2FromDec
VarI2FromDisp
VarI2FromI1
VarI2FromI4
VarI2FromR4
VarI2FromR8
VarI2FromStr
VarI2FromUI1
VarI2FromUI2
VarI2FromUI4
VarI4FromBool
VarI4FromCy
VarI4FromDate
VarI4FromDec
VarI4FromDisp
VarI4FromI1
VarI4FromI2
VarI4FromR4
VarI4FromR8
VarI4FromStr
VarI4FromUI1
VarI4FromUI2
VarI4FromUI4
VarIdiv
VarImp
VarInt
VarMod
VarMonthName
VarMul
VarNeg
VarNot
VarNumFromParseNum
VarOr
VarParseNumFromStr
VarPow
VarR4CmpR8
VarR4FromBool
VarR4FromCy
VarR4FromDate
VarR4FromDec
VarR4FromDisp
VarR4FromI1
VarR4FromI2
VarR4FromI4
VarR4FromR8
VarR4FromStr
VarR4FromUI1
VarR4FromUI2
VarR4FromUI4
VarR8FromBool
VarR8FromCy
VarR8FromDate
VarR8FromDec
VarR8FromDisp
VarR8FromI1
VarR8FromI2
VarR8FromI4
VarR8FromR4
VarR8FromStr
VarR8FromUI1
VarR8FromUI2
VarR8FromUI4
VarR8Pow
VarR8Round
VarRound
VarSub
VarTokenizeFormatString
VarUI1FromBool
VarUI1FromCy
VarUI1FromDate
VarUI1FromDec
VarUI1FromDisp
VarUI1FromI1
VarUI1FromI2
VarUI1FromI4
VarUI1FromR4
VarUI1FromR8
VarUI1FromStr
VarUI1FromUI2
VarUI1FromUI4
VarUI2FromBool
VarUI2FromCy
VarUI2FromDate
VarUI2FromDec
VarUI2FromDisp
VarUI2FromI1
VarUI2FromI2
VarUI2FromI4
VarUI2FromR4
VarUI2FromR8
VarUI2FromStr
VarUI2FromUI1
VarUI2FromUI4
VarUI4FromBool
VarUI4FromCy
VarUI4FromDate
VarUI4FromDec
VarUI4FromDisp
VarUI4FromI1
VarUI4FromI2
VarUI4FromI4
VarUI4FromR4
VarUI4FromR8
VarUI4FromStr
VarUI4FromUI1
VarUI4FromUI2
VarUdateFromDate
VarWeekdayName
VarXor
VariantChangeType
VariantChangeTypeEx
VariantClear
VariantCopy
VariantCopyInd
VariantInit
VariantTimeToDosDateTime
VariantTimeToSystemTime
VectorFromBstr
VerFindFileA
VerInstallFileA
VerLanguageNameA
VerQueryValueA
VerQueryValueIndexA
VerifyConsoleIoHandle
VerifySupervisorPassword
VerifyTestCaseCount
VidMemAlloc
VidMemAmountFree
VidMemFini
VidMemFree
VidMemInit
VidMemLargestFree
VideoForWindowsVersion
VirtualAlloc
VirtualAllocEx
VirtualAllocVlm
VirtualBufferExceptionHandler
VirtualFree
VirtualFreeEx
VirtualFreeVlm
VirtualLock
VirtualProtect
VirtualProtectEx
VirtualProtectVlm
VirtualQuery
VirtualQueryEx
VirtualQueryVlm
VirtualUnlock
VkKeyScanA
VkKeyScanExA
WEP
WINNLSEnableIME
WINNLSGetEnableStatus
WINNLSGetIMEHotkey
WNetAddConnection2A
WNetAddConnection3A
WNetAddConnectionA
WNetCancelConnection2A
WNetCancelConnectionA
WNetClearConnections
WNetCloseEnum
WNetConnectionDialog
WNetConnectionDialog1A
WNetConnectionDialog2
WNetDirectoryNotifyA
WNetDisconnectDialog
WNetDisconnectDialog1A
WNetDisconnectDialog2
WNetEnumResourceA
WNetFMXEditPerm
WNetFMXGetPermCaps
WNetFMXGetPermHelp
WNetFormatNetworkNameA
WNetGetConnection2A
WNetGetConnection3A
WNetGetConnectionA
WNetGetDirectoryTypeA
WNetGetLastErrorA
WNetGetNetworkInformationA
WNetGetPropertyTextA
WNetGetProviderNameA
WNetGetProviderTypeA
WNetGetResourceInformationA
WNetGetResourceParentA
WNetGetSearchDialog
WNetGetUniversalNameA
WNetGetUserA
WNetLogonNotify
WNetOpenEnumA
WNetPasswordChangeNotify
WNetPropertyDialogA
WNetSetConnectionA
WNetSetLastErrorA
WNetSupportGlobalEnum
WNetUseConnectionA
WOW32DriverCallback
WOW32ResolveMultiMediaHandle
WOWAppExit
WOWCallback16
WOWCallback16Ex
WOWDirectedYield16
WOWGetDescriptor
WOWGetVDMPointer
WOWGetVDMPointerFix
WOWGetVDMPointerUnfix
WOWGlobalAlloc16
WOWGlobalAllocLock16
WOWGlobalFree16
WOWGlobalLock16
WOWGlobalLockSize16
WOWGlobalUnlock16
WOWGlobalUnlockFree16
WOWHandle16
WOWHandle32
WOWShellExecute
WOWYield16
WPUCompleteOverlappedRequest
WSAAccept
WSAAddressToStringA
WSAAsyncGetHostByAddr
WSAAsyncGetHostByName
WSAAsyncGetProtoByName
WSAAsyncGetProtoByNumber
WSAAsyncGetServByName
WSAAsyncGetServByPort
WSAAsyncSelect
WSACancelAsyncRequest
WSACancelBlockingCall
WSACleanup
WSACloseEvent
WSAConnect
WSACreateEvent
WSADuplicateSocketA
WSAEnumNameSpaceProvidersA
WSAEnumNetworkEvents
WSAEnumProtocolsA
WSAEventSelect
WSAGetLastError
WSAGetOverlappedResult
WSAGetQOSByName
WSAGetServiceClassInfoA
WSAGetServiceClassNameByClassIdA
WSAHtonl
WSAHtons
WSAInstallServiceClassA
WSAIoctl
WSAIsBlocking
WSAJoinLeaf
WSALookupServiceBeginA
WSALookupServiceEnd
WSALookupServiceNextA
WSANtohl
WSANtohs
WSAProviderConfigChange
WSARecv
WSARecvDisconnect
WSARecvEx
WSARecvFrom
WSARemoveServiceClass
WSAResetEvent
WSASend
WSASendDisconnect
WSASendTo
WSASetBlockingHook
WSASetEvent
WSASetLastError
WSASetServiceA
WSASocketA
WSAStartup
WSAStringToAddressA
WSAUnhookBlockingHook
WSAWaitForMultipleEvents
WSCDeinstallProvider
WSCEnableNSProvider
WSCEnumProtocols
WSCGetProviderPath
WSCInstallNameSpace
WSCInstallProvider
WSCUnInstallNameSpace
WSCWriteProviderOrder
WaitCommEvent
WaitForDebugEvent
WaitForInputIdle
WaitForMultipleObjects
WaitForMultipleObjectsEx
WaitForNtmsNotification
WaitForNtmsOperatorRequest
WaitForPrinterChange
WaitForSingleObject
WaitForSingleObjectEx
WaitMessage
WaitNamedPipeA
WantArrows
WideCharToMultiByte
WidenPath
WinExec
WinHelpA
WinLoadTrustProvider
WinMain
WinMainN
WinSubmitCertificate
WinTrustProviderClientInitialize
WinVerifyTrust
WindowFromAccessibleObject
WindowFromDC
WindowFromPoint
WpBindToSiteA
WpCreateSiteA
WpDeleteSiteA
WpDoesSiteExistA
WpEnumProvidersA
WpGetErrorStringA
WpListSitesA
WpPostA
WrapCompressedRTFStream
WrapProgress
WrapStoreEntryID
WriteBSTR
WriteClassStg
WriteClassStm
WriteConsoleA
WriteConsoleInputA
WriteConsoleInputVDMA
WriteConsoleOutputA
WriteConsoleOutputAttribute
WriteConsoleOutputCharacterA
WriteFile
WriteFileEx
WriteFileGather
WriteFileVlm
WriteFmtUserTypeStg
WriteHWL
WriteHitLogging
WriteInt
WriteOleStg
WritePrinter
WritePrivateProfileSectionA
WritePrivateProfileStringA
WritePrivateProfileStructA
WriteProcessMemory
WriteProcessMemoryVlm
WriteProfileSectionA
WriteProfileStringA
WriteRaw
WriteStringStream
WriteTapemark
XRegThunkEntry
_TrackMouseEvent
__CPPValidateParameters
__ValidateParameters
__WSAFDIsSet
_hread
_hwrite
_lclose
_lcreat
_llseek
_lopen
_lread
_lwrite
accept
acmDriverAddA
acmDriverClose
acmDriverDetailsA
acmDriverEnum
acmDriverID
acmDriverMessage
acmDriverOpen
acmDriverPriority
acmDriverRemove
acmFilterChooseA
acmFilterDetailsA
acmFilterEnumA
acmFilterTagDetailsA
acmFilterTagEnumA
acmFormatChooseA
acmFormatDetailsA
acmFormatEnumA
acmFormatSuggest
acmFormatTagDetailsA
acmFormatTagEnumA
acmGetVersion
acmMessage32
acmMetrics
acmStreamClose
acmStreamConvert
acmStreamMessage
acmStreamOpen
acmStreamPrepareHeader
acmStreamReset
acmStreamSize
acmStreamUnprepareHeader
add3
atoui
aux32Message
auxCloseWindow
auxCreateFont
auxDIBImageLoadA
auxDrawStrA
auxExposeFunc
auxGetColorMapSize
auxGetDevCapsA
auxGetDisplayMode
auxGetDisplayModeID
auxGetDisplayModePolicy
auxGetHDC
auxGetHGLRC
auxGetHWND
auxGetMouseLoc
auxGetNumDevs
auxGetVolume
auxIdleFunc
auxInitDisplayMode
auxInitDisplayModeID
auxInitDisplayModePolicy
auxInitPosition
auxInitWindowA
auxKeyFunc
auxMainLoop
auxMouseFunc
auxOutMessage
auxQuit
auxRGBImageLoadA
auxReshapeFunc
auxSetFogRamp
auxSetGreyRamp
auxSetOneColor
auxSetRGBMap
auxSetVolume
auxSolidBox
auxSolidCone
auxSolidCube
auxSolidCylinder
auxSolidDodecahedron
auxSolidIcosahedron
auxSolidOctahedron
auxSolidSphere
auxSolidTeapot
auxSolidTetrahedron
auxSolidTorus
auxSwapBuffers
auxWireBox
auxWireCone
auxWireCube
auxWireCylinder
auxWireDodecahedron
auxWireIcosahedron
auxWireOctahedron
auxWireSphere
auxWireTeapot
auxWireTetrahedron
auxWireTorus
bind
capCreateCaptureWindowA
capGetDriverDescriptionA
char_array_from_ndr
char_from_ndr
closesocket
compareParams
connect
copy3
copymat3
crossprod
data_from_ndr
data_into_ndr
data_size_ndr
diff3
dist3
dn_expand
doCabinetInfoNotify
dodecahedron
dot3
double_array_from_ndr
double_from_ndr
doughnut
drawbox
drawtriangle
dwLBSubclass
dwOKSubclass
enum_from_ndr
error
findList
float_array_from_ndr
float_from_ndr
gdiPlaySpoolStream
gethostbyaddr
gethostbyname
gethostname
getmsg
getnetbyname
getpeername
getprotobyname
getprotobynumber
getservbyname
getservbyport
getsockname
getsockopt
glAccum
glAlphaFunc
glAreTexturesResident
glArrayElement
glBegin
glBindTexture
glBitmap
glBlendFunc
glCallList
glCallLists
glClear
glClearAccum
glClearColor
glClearDepth
glClearIndex
glClearStencil
glClipPlane
glColor3b
glColor3bv
glColor3d
glColor3dv
glColor3f
glColor3fv
glColor3i
glColor3iv
glColor3s
glColor3sv
glColor3ub
glColor3ubv
glColor3ui
glColor3uiv
glColor3us
glColor3usv
glColor4b
glColor4bv
glColor4d
glColor4dv
glColor4f
glColor4fv
glColor4i
glColor4iv
glColor4s
glColor4sv
glColor4ub
glColor4ubv
glColor4ui
glColor4uiv
glColor4us
glColor4usv
glColorMask
glColorMaterial
glColorPointer
glCopyPixels
glCopyTexImage1D
glCopyTexImage2D
glCopyTexSubImage1D
glCopyTexSubImage2D
glCullFace
glDebugEntry
glDeleteLists
glDeleteTextures
glDepthFunc
glDepthMask
glDepthRange
glDisable
glDisableClientState
glDrawArrays
glDrawBuffer
glDrawElements
glDrawPixels
glEdgeFlag
glEdgeFlagPointer
glEdgeFlagv
glEnable
glEnableClientState
glEnd
glEndList
glEvalCoord1d
glEvalCoord1dv
glEvalCoord1f
glEvalCoord1fv
glEvalCoord2d
glEvalCoord2dv
glEvalCoord2f
glEvalCoord2fv
glEvalMesh1
glEvalMesh2
glEvalPoint1
glEvalPoint2
glFeedbackBuffer
glFinish
glFlush
glFogf
glFogfv
glFogi
glFogiv
glFrontFace
glFrustum
glGenLists
glGenTextures
glGetBooleanv
glGetClipPlane
glGetDoublev
glGetError
glGetFloatv
glGetIntegerv
glGetLightfv
glGetLightiv
glGetMapdv
glGetMapfv
glGetMapiv
glGetMaterialfv
glGetMaterialiv
glGetPixelMapfv
glGetPixelMapuiv
glGetPixelMapusv
glGetPointerv
glGetPolygonStipple
glGetString
glGetTexEnvfv
glGetTexEnviv
glGetTexGendv
glGetTexGenfv
glGetTexGeniv
glGetTexImage
glGetTexLevelParameterfv
glGetTexLevelParameteriv
glGetTexParameterfv
glGetTexParameteriv
glHint
glIndexMask
glIndexPointer
glIndexd
glIndexdv
glIndexf
glIndexfv
glIndexi
glIndexiv
glIndexs
glIndexsv
glIndexub
glIndexubv
glInitNames
glInterleavedArrays
glIsEnabled
glIsList
glIsTexture
glLightModelf
glLightModelfv
glLightModeli
glLightModeliv
glLightf
glLightfv
glLighti
glLightiv
glLineStipple
glLineWidth
glListBase
glLoadIdentity
glLoadMatrixd
glLoadMatrixf
glLoadName
glLogicOp
glMap1d
glMap1f
glMap2d
glMap2f
glMapGrid1d
glMapGrid1f
glMapGrid2d
glMapGrid2f
glMaterialf
glMaterialfv
glMateriali
glMaterialiv
glMatrixMode
glMultMatrixd
glMultMatrixf
glNewList
glNormal3b
glNormal3bv
glNormal3d
glNormal3dv
glNormal3f
glNormal3fv
glNormal3i
glNormal3iv
glNormal3s
glNormal3sv
glNormalPointer
glOrtho
glPassThrough
glPixelMapfv
glPixelMapuiv
glPixelMapusv
glPixelStoref
glPixelStorei
glPixelTransferf
glPixelTransferi
glPixelZoom
glPointSize
glPolygonMode
glPolygonOffset
glPolygonStipple
glPopAttrib
glPopClientAttrib
glPopMatrix
glPopName
glPrioritizeTextures
glPushAttrib
glPushClientAttrib
glPushMatrix
glPushName
glRasterPos2d
glRasterPos2dv
glRasterPos2f
glRasterPos2fv
glRasterPos2i
glRasterPos2iv
glRasterPos2s
glRasterPos2sv
glRasterPos3d
glRasterPos3dv
glRasterPos3f
glRasterPos3fv
glRasterPos3i
glRasterPos3iv
glRasterPos3s
glRasterPos3sv
glRasterPos4d
glRasterPos4dv
glRasterPos4f
glRasterPos4fv
glRasterPos4i
glRasterPos4iv
glRasterPos4s
glRasterPos4sv
glReadBuffer
glReadPixels
glRectd
glRectdv
glRectf
glRectfv
glRecti
glRectiv
glRects
glRectsv
glRenderMode
glRotated
glRotatef
glScaled
glScalef
glScissor
glSelectBuffer
glShadeModel
glStencilFunc
glStencilMask
glStencilOp
glTexCoord1d
glTexCoord1dv
glTexCoord1f
glTexCoord1fv
glTexCoord1i
glTexCoord1iv
glTexCoord1s
glTexCoord1sv
glTexCoord2d
glTexCoord2dv
glTexCoord2f
glTexCoord2fv
glTexCoord2i
glTexCoord2iv
glTexCoord2s
glTexCoord2sv
glTexCoord3d
glTexCoord3dv
glTexCoord3f
glTexCoord3fv
glTexCoord3i
glTexCoord3iv
glTexCoord3s
glTexCoord3sv
glTexCoord4d
glTexCoord4dv
glTexCoord4f
glTexCoord4fv
glTexCoord4i
glTexCoord4iv
glTexCoord4s
glTexCoord4sv
glTexCoordPointer
glTexEnvf
glTexEnvfv
glTexEnvi
glTexEnviv
glTexGend
glTexGendv
glTexGenf
glTexGenfv
glTexGeni
glTexGeniv
glTexImage1D
glTexImage2D
glTexParameterf
glTexParameterfv
glTexParameteri
glTexParameteriv
glTexSubImage1D
glTexSubImage2D
glTranslated
glTranslatef
glVertex2d
glVertex2dv
glVertex2f
glVertex2fv
glVertex2i
glVertex2iv
glVertex2s
glVertex2sv
glVertex3d
glVertex3dv
glVertex3f
glVertex3fv
glVertex3i
glVertex3iv
glVertex3s
glVertex3sv
glVertex4d
glVertex4dv
glVertex4f
glVertex4fv
glVertex4i
glVertex4iv
glVertex4s
glVertex4sv
glVertexPointer
glViewport
gluBeginCurve
gluBeginPolygon
gluBeginSurface
gluBeginTrim
gluBuild1DMipmaps
gluBuild2DMipmaps
gluCylinder
gluDeleteNurbsRenderer
gluDeleteQuadric
gluDeleteTess
gluDisk
gluEndCurve
gluEndPolygon
gluEndSurface
gluEndTrim
gluErrorString
gluErrorUnicodeStringEXT
gluGetNurbsProperty
gluGetString
gluGetTessProperty
gluLoadSamplingMatrices
gluLookAt
gluNewNurbsRenderer
gluNewQuadric
gluNewTess
gluNextContour
gluNurbsCallback
gluNurbsCurve
gluNurbsProperty
gluNurbsSurface
gluOrtho2D
gluPartialDisk
gluPerspective
gluPickMatrix
gluProject
gluPwlCurve
gluQuadricCallback
gluQuadricDrawStyle
gluQuadricNormals
gluQuadricOrientation
gluQuadricTexture
gluScaleImage
gluSphere
gluTessBeginContour
gluTessBeginPolygon
gluTessCallback
gluTessEndContour
gluTessEndPolygon
gluTessNormal
gluTessProperty
gluTessVertex
gluUnProject
htonl
htons
icosahedron
identifymat3
inet_addr
inet_network
inet_ntoa
initdodec
ioctlsocket
joy32Message
joyConfigChanged
joyGetDevCapsA
joyGetNumDevs
joyGetPos
joyGetPosEx
joyGetThreshold
joyReleaseCapture
joySetCapture
joySetThreshold
keybd_event
length3
lineAccept
lineAddProviderA
lineAddToConference
lineAgentSpecific
lineAnswer
lineBlindTransferA
lineClose
lineCompleteCall
lineCompleteTransfer
lineConfigDialogA
lineConfigDialogEditA
lineConfigProvider
lineDeallocateCall
lineDevSpecific
lineDevSpecificFeature
lineDialA
lineDrop
lineForwardA
lineGatherDigitsA
lineGenerateDigitsA
lineGenerateTone
lineGetAddressCapsA
lineGetAddressIDA
lineGetAddressStatusA
lineGetAgentActivityListA
lineGetAgentCapsA
lineGetAgentGroupListA
lineGetAgentStatusA
lineGetAppPriorityA
lineGetCallInfoA
lineGetCallStatus
lineGetConfRelatedCalls
lineGetCountryA
lineGetDevCapsA
lineGetDevConfigA
lineGetIDA
lineGetIconA
lineGetLineDevStatusA
lineGetMessage
lineGetNewCalls
lineGetNumRings
lineGetProviderListA
lineGetRequestA
lineGetStatusMessages
lineGetTranslateCapsA
lineHandoffA
lineHold
lineInitialize
lineInitializeExA
lineMakeCallA
lineMonitorDigits
lineMonitorMedia
lineMonitorTones
lineNegotiateAPIVersion
lineNegotiateExtVersion
lineOpenA
lineParkA
linePickupA
linePrepareAddToConferenceA
lineProxyMessage
lineProxyResponse
lineRedirectA
lineRegisterRequestRecipient
lineReleaseUserUserInfo
lineRemoveFromConference
lineRemoveProvider
lineSecureCall
lineSendUserUserInfo
lineSetAgentActivity
lineSetAgentGroup
lineSetAgentState
lineSetAppPriorityA
lineSetAppSpecific
lineSetCallData
lineSetCallParams
lineSetCallPrivilege
lineSetCallQualityOfService
lineSetCallTreatment
lineSetCurrentLocation
lineSetDevConfigA
lineSetLineDevStatus
lineSetMediaControl
lineSetMediaMode
lineSetNumRings
lineSetStatusMessages
lineSetTerminal
lineSetTollListA
lineSetupConferenceA
lineSetupTransferA
lineShutdown
lineSwapHold
lineTranslateAddressA
lineTranslateDialogA
lineUncompleteCall
lineUnhold
lineUnparkA
listen
long_array_from_ndr
long_from_ndr
long_from_ndr_temp
lstrcatA
lstrcmpA
lstrcmpiA
lstrcpyA
lstrcpynA
lstrlenA
m_popmatrix
m_pushmatrix
m_scale
m_translate
m_xformpt
m_xformptonly
makeModelPtr
mci32Message
mciDriverNotify
mciDriverYield
mciExecute
mciFreeCommandResource
mciGetCreatorTask
mciGetDeviceIDA
mciGetDeviceIDFromElementIDA
mciGetDriverData
mciGetErrorStringA
mciGetYieldProc
mciLoadCommandResource
mciSendCommandA
mciSendStringA
mciSetDriverData
mciSetYieldProc
memmoveInternal
mid32Message
midiConnect
midiDisconnect
midiInAddBuffer
midiInClose
midiInGetDevCapsA
midiInGetErrorTextA
midiInGetID
midiInGetNumDevs
midiInMessage
midiInOpen
midiInPrepareHeader
midiInReset
midiInStart
midiInStop
midiInUnprepareHeader
midiOutCacheDrumPatches
midiOutCachePatches
midiOutClose
midiOutGetDevCapsA
midiOutGetErrorTextA
midiOutGetID
midiOutGetNumDevs
midiOutGetVolume
midiOutLongMsg
midiOutMessage
midiOutOpen
midiOutPrepareHeader
midiOutReset
midiOutSetVolume
midiOutShortMsg
midiOutUnprepareHeader
midiStreamClose
midiStreamOpen
midiStreamOut
midiStreamPause
midiStreamPosition
midiStreamProperty
midiStreamRestart
midiStreamStop
midl_allocate
mixerClose
mixerGetControlDetailsA
mixerGetDevCapsA
mixerGetID
mixerGetLineControlsA
mixerGetLineInfoA
mixerGetNumDevs
mixerMessage
mixerOpen
mixerSetControlDetails
mmDrvInstall
mmGetCurrentTask
mmTaskBlock
mmTaskCreate
mmTaskSignal
mmTaskYield
mmioAdvance
mmioAscend
mmioClose
mmioCreateChunk
mmioDescend
mmioFlush
mmioGetInfo
mmioInstallIOProcA
mmioOpenA
mmioRead
mmioRenameA
mmioSeek
mmioSendMessage
mmioSetBuffer
mmioSetInfo
mmioStringToFOURCCA
mmioWrite
mmsystemGetVersion
mod32Message
mouse_event
mxd32Message
normalize
ntohl
ntohs
octahedron
pSetupDiGetDeviceInfoContext
pSetupDiSetDeviceInfoContext
pSetupDirectoryIdToPath
pSetupGetField
pSetupGetOsLoaderDriveAndPath
pSetupGetVersionDatum
pSetupGuidFromString
pSetupIsGuidNull
pSetupMakeSurePathExists
pSetupSetSystemSourcePath
pSetupStringFromGuid
pentagon
perpnorm
phoneClose
phoneConfigDialogA
phoneDevSpecific
phoneGetButtonInfoA
phoneGetData
phoneGetDevCapsA
phoneGetDisplay
phoneGetGain
phoneGetHookSwitch
phoneGetIDA
phoneGetIconA
phoneGetLamp
phoneGetMessage
phoneGetRing
phoneGetStatusA
phoneGetStatusMessages
phoneGetVolume
phoneInitialize
phoneInitializeExA
phoneNegotiateAPIVersion
phoneNegotiateExtVersion
phoneOpen
phoneSetButtonInfoA
phoneSetData
phoneSetDisplay
phoneSetGain
phoneSetHookSwitch
phoneSetLamp
phoneSetRing
phoneSetStatusMessages
phoneSetVolume
phoneShutdown
poll
putmsg
rcmd
recorditem
recv
recvfrom
rexec
rresvport
s_ioctl
s_open
s_perror
samepoint
scalarmult
select
send
sendto
serverTrapThread
seterrorfunc
sethostname
setsockopt
short_array_from_ndr
short_from_ndr
short_from_ndr_temp
shutdown
sndPlaySoundA
socket
solidTeapot
sqlite3_aggregate_context
sqlite3_aggregate_count
sqlite3_bind_blob
sqlite3_bind_double
sqlite3_bind_int
sqlite3_bind_int64
sqlite3_bind_null
sqlite3_bind_text
sqlite3_bind_text16
sqlite3_busy_handler
sqlite3_busy_timeout
sqlite3_close
sqlite3_column_blob
sqlite3_column_bytes
sqlite3_column_bytes16
sqlite3_column_count
sqlite3_column_decltype
sqlite3_column_decltype16
sqlite3_column_double
sqlite3_column_int
sqlite3_column_int64
sqlite3_column_name
sqlite3_column_name16
sqlite3_column_text
sqlite3_column_text16
sqlite3_column_type
sqlite3_complete
sqlite3_complete16
sqlite3_create_function
sqlite3_create_function16
sqlite3_errcode
sqlite3_errmsg
sqlite3_errmsg16
sqlite3_finalize
sqlite3_free
sqlite3_interrupt
sqlite3_last_insert_rowid
sqlite3_mprintf
sqlite3_open
sqlite3_open16
sqlite3_prepare
sqlite3_prepare16
sqlite3_reset
sqlite3_result_blob
sqlite3_result_double
sqlite3_result_error
sqlite3_result_error16
sqlite3_result_int
sqlite3_result_int64
sqlite3_result_null
sqlite3_result_text
sqlite3_result_text16
sqlite3_result_value
sqlite3_set_authorizer
sqlite3_step
sqlite3_user_data
sqlite3_value_blob
sqlite3_value_bytes
sqlite3_value_bytes16
sqlite3_value_double
sqlite3_value_int
sqlite3_value_int64
sqlite3_value_text
sqlite3_value_text16
sqlite3_value_type
sqlite3_vmprintf
subdivide
tapiGetLocationInfoA
tapiPlaySound
tapiRequestDrop
tapiRequestMakeCallA
tapiRequestMediaCallA
tetrahedron
tid32Message
timeBeginPeriod
timeEndPeriod
timeGetDevCaps
timeGetSystemTime
timeGetTime
timeKillEvent
timeSetEvent
tkCloseWindow
tkCreateBitmapFont
tkCreateFilledFont
tkCreateOutlineFont
tkCreateStrokeFont
tkDIBImageLoad
tkDisplayFunc
tkDrawStr
tkErrorPopups
tkExec
tkExposeFunc
tkGetColorMapSize
tkGetDisplayMode
tkGetDisplayModeID
tkGetDisplayModePolicy
tkGetHDC
tkGetHRC
tkGetHWND
tkGetMouseLoc
tkIdleFunc
tkInitDisplayMode
tkInitDisplayModeID
tkInitDisplayModePolicy
tkInitPosition
tkInitWindow
tkKeyDownFunc
tkMouseDownFunc
tkMouseMoveFunc
tkMouseUpFunc
tkQuit
tkRGBImageLoad
tkReshapeFunc
tkSetFogRamp
tkSetGreyRamp
tkSetOneColor
tkSetRGBMap
tkSwapBuffers
tkWndProc
tree_into_ndr
tree_peek_ndr
tree_size_ndr
videoThunk32
waveInAddBuffer
waveInClose
waveInGetDevCapsA
waveInGetErrorTextA
waveInGetID
waveInGetNumDevs
waveInGetPosition
waveInMessage
waveInOpen
waveInPrepareHeader
waveInReset
waveInStart
waveInStop
waveInUnprepareHeader
waveOutBreakLoop
waveOutClose
waveOutGetDevCapsA
waveOutGetErrorTextA
waveOutGetID
waveOutGetNumDevs
waveOutGetPitch
waveOutGetPlaybackRate
waveOutGetPosition
waveOutGetVolume
waveOutMessage
waveOutOpen
waveOutPause
waveOutPrepareHeader
waveOutReset
waveOutRestart
waveOutSetPitch
waveOutSetPlaybackRate
waveOutSetVolume
waveOutUnprepareHeader
waveOutWrite
wglChoosePixelFormat
wglCopyContext
wglCreateContext
wglCreateLayerContext
wglDeleteContext
wglDescribeLayerPlane
wglDescribePixelFormat
wglGetCurrentContext
wglGetCurrentDC
wglGetDefaultProcAddress
wglGetLayerPaletteEntries
wglGetPixelFormat
wglGetProcAddress
wglMakeCurrent
wglRealizeLayerPalette
wglSetLayerPaletteEntries
wglSetPixelFormat
wglShareLists
wglSwapBuffers
wglSwapLayerBuffers
wglSwapMultipleBuffers
wglUseFontBitmapsA
wglUseFontOutlinesA
wid32Message
winmmSetDebugLevel
wireTeapot
wod32Message
wvsprintfA
xformvec3
" EndOfFunctionsList: D$ 0]
____________________________________________________________________________________________
____________________________________________________________________________________________

[OneApiInfo: D$ ? # 2000]

[ApiComment: D$ ?
 ApiCommentMax: D$ ?]

[NotYetApiInfo: B$ "
 Not yet. Under developement.
 
 Only the usual Functions are available, actually." EOS]

; In: edx = start of possible Api Call (DLL or Function)

WinApiFirstPass:
    dec edx | Mov esi edx

    While B$esi-1 <> '.'
        inc esi
        If B$esi = "'"
            ret
        Else_If B$esi = '"'
            ret
        End_If
    End_While

    Mov edi Win32Functions, ecx 0

    .While edi < EndOfFunctionsList
        Mov al B$esi+ecx

        ..If al > B$edi+ecx
            While B$edi <> LF | inc edi | End_While | inc edi | Mov ecx 0

        ..Else_If al < B$edi+ecx
            ret

        ..Else
            inc ecx
            .If B$edi+ecx = CR
              ; Name in List shorter than Source one:
                add edi ecx | add edi 2 | Mov ecx 0
            .Else
                If B$esi+ecx+1 = '"'
                    Call SearchInFunctionsFile

                    Call VirtualFree Win32ApiList

                Else_If B$esi+ecx+1 = "'"
                    Call SearchInFunctionsFile

                    Call VirtualFree Win32ApiList

                End_If
            .End_If

        ..End_If
    .End_While
ret


SearchInFunctionsFile:
    Mov edx esi | Call OpenApiFunctionsFile | On B$ApiFileOK = &FALSE, ret

@DirectSearchInFunctionsFile:
    Mov edi D$Win32ApiList

L1: Mov esi edx, ecx D$ApiFileSize | sub ecx edi | add ecx D$Win32ApiList

    Mov al '.' | repne scasb
    repe cmpsb
    ...If B$esi-1 = "'"
L2:     ..If B$edi-1 = '('
            sub edi 2
            While B$edi <> CR
               dec edi
            End_While
            Mov esi edi, edi OneApiInfo, ecx 800
            movsw
            Mov eax 'Call' | stosd |  Mov ax " '" | stosw
L5:         lodsb
            .If al = '('
                Mov al "'" | stosb
                If B$esi <> CR
                    Mov al 0 | stosb | jmp L8>>
                End_If
                Mov al ','
            .End_If
            stosb | cmp al LF | jne L5<

          ; Compute the Max Pos of Comments, for aligned presentation:
            Push esi
                Mov D$ApiComment 0, D$ApiCommentMax 0
                While B$esi <> ')'
                    lodsb | inc D$ApiComment
                    If al = ';'
                        Mov eax D$ApiCommentMax
                        On D$ApiComment > eax, Move D$ApiCommentMax D$ApiComment
                    Else_If al = LF
                        Mov D$ApiComment 0
                    End_If
                End_While
            Pop esi

            Mov eax '    ' | stosd | Mov D$ApiComment 0 | add D$ApiCommentMax 8
L5:         lodsb | stosb | inc D$ApiComment
            If al = LF
                Mov eax '    ' | stosd | Mov D$ApiComment 0
            Else_If al = ';'
                dec edi
                Mov ecx D$ApiCommentMax | sub ecx D$ApiComment
                Mov al SPC | rep stosb
                Mov al ';' | stosb
            End_If
            cmp al ')' | jne L5<
            Mov B$edi 0, B$edi-1 SPC
L8:         Call 'USER32.DialogBoxParamA' D$H.Instance 1000  &NULL ShowApiInfo &NULL
            ret
        ..End_If
    ...Else_If B$esi-1 = '"'
        jmp L2<<
    ...Else_If B$esi-1 = 'A'
L3:     On B$esi = "'", jmp L2<<
        On B$esi = '"', jmp L2<<
    ...Else_If B$esi-1 = 'W'
        jmp L3<
    ...End_If
    Mov al ')' | repne scasb | cmp B$edi 0 | je L9>
    add esi 2                                          ; +2 for CR/LF
        jmp L1<<
L9:ret


[ApiFileSize: D$ ?
 H.ApiFile: D$ ?
 ApiFileOK: D$ ?]

OpenApiFunctionsFile:  ; Like 'OpenStructureFile'
    pushad
        Mov esi EquatesName, edi IncludeFileName
        While B$esi <> 0 | movsb | End_While
        dec edi
        While B$edi <> '.' | dec edi | End_While

L0:     dec edi | cmp B$edi '\' | je L1>
                  cmp B$edi ':' | je L1>
                  cmp edi IncludeFileName | ja L0<
                    jmp L2>
L1:     inc edi
L2:     Mov D$edi 'Func', D$edi+4 'tion', D$edi+8 's.ap', B$edi+12 'i', B$edi+13 0

        Call 'KERNEL32.CreateFileA' IncludeFileName &GENERIC_READ, &FILE_SHARE_READ, 0,
                                    &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0

        .If eax = &INVALID_HANDLE_VALUE
            Call Help B_U_AsmName, IncludeFilesHelp, BUAsmHlpMessage

            Mov B$ApiFileOK &FALSE

        .Else
            Mov D$H.ApiFile eax

            Call 'KERNEL32.GetFileSize' eax 0 | Mov D$ApiFileSize eax

            Call VirtualAlloc Win32ApiList,
                              eax


            Call 'KERNEL32.ReadFile' D$H.ApiFile, D$Win32ApiList,
                                     D$ApiFileSize, NumberOfReadBytes, 0
            Mov B$ApiFileOK &TRUE

            Call 'KERNEL32.CloseHandle' D$H.ApiFile
        .End_If
    popad
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

ViewApiList:
    Call OpenApiFunctionsFile

    If B$ApiFileOK = &TRUE
        Call 'USER32.DialogBoxParamA' D$H.Instance, 30_000, &NULL, ApiChoice, &NULL
    End_If
ret


[H.ShowApiDialog: D$ ?]

Proc ApiChoice:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    .If D@msg = &WM_COMMAND
         If D@wParam = &IDCANCEL

            Mov D$H.ShowApiDialog 0

            Call VirtualFree Win32ApiList

            Call 'USER32.EndDialog' D@hwnd, 0

         End_If

         shr D@wParam 16

         On D@wParam = &CBN_SELCHANGE, Call ViewOneApiInfos

    .Else_If D@msg = &WM_INITDIALOG
        Move D$H.ShowApiDialog D@hwnd
        Call 'USER32.SetClassLongA' D@hwnd, &GCL_HICON, D$STRUC.WINDOWCLASS@hIcon

        Call InitApiList

    .Else_If D@msg = &WM_CTLCOLOREDIT
        If B$FirstCTLCOLOREDIT = &TRUE
            Call 'USER32.SendMessageA' D@lParam, &EM_SETSEL, 0, 0
            Mov B$FirstCTLCOLOREDIT &FALSE
        End_If
        Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>

    .Else
        popad | Mov eax &FALSE | jmp L9>

    .End_If

    popad | Mov eax &TRUE

L9: EndP



InitApiList:
    Mov esi Win32Functions

    .While esi < EndOfFunctionsList
        Mov eax esi
        While B$eax <> CR | inc eax | End_While | Mov B$eax 0

        Push esi, eax
            Call 'USER32.SendDlgItemMessageA' D$H.ShowApiDialog, 10, &CB_ADDSTRING, 0, esi
        Pop eax, esi

        Mov B$eax CR | add eax 2 | Mov esi eax
    .End_While
ret


[ApiItem: D$ ? # 10]

ViewOneApiInfos:
    Call 'USER32.SendDlgItemMessageA' D$H.ShowApiDialog 10 &CB_GETCURSEL  0 0
    Call 'USER32.SendDlgItemMessageA' D$H.ShowApiDialog 10 &CB_GETLBTEXT eax ApiItem
    Mov edx ApiItem
    Mov edi D$Win32ApiList

L1: Mov esi ApiItem, ecx D$ApiFileSize | sub ecx edi | add ecx D$Win32ApiList
    On ecx = 0, jmp L9>> ;ret

    Mov al '.' | repne scasb | On ecx = 0, ret

    repe cmpsb
    ...If ecx = 0
        ret
    ...Else_If B$esi-1 = 0
L2:     ..If B$edi-1 = '('
            sub edi 2
            While B$edi <> CR
               dec edi
            End_While
            Mov esi edi, edi OneApiInfo, ecx 800
            movsw
            Mov eax 'Call' | stosd |  Mov ax " '" | stosw
L5:         lodsb
            .If al = '('
                Mov al "'" | stosb
                If B$esi <> CR
                    Mov al 0 | stosb | jmp L8>>
                End_If
                Mov al ','
            .End_If
            stosb | cmp al LF | jne L5<

; Compute the Max Pos of Comments, for aligned presentation:
            Push esi
                Mov D$ApiComment 0, D$ApiCommentMax 0
                While B$esi <> ')'
                    lodsb | inc D$ApiComment
                    If al = ';'
                        Mov eax D$ApiCommentMax
                        On D$ApiComment > eax, Move D$ApiCommentMax D$ApiComment
                    Else_If al = LF
                        Mov D$ApiComment 0
                    End_If
                End_While
            Pop esi

            Mov eax '    ' | stosd | Mov D$ApiComment 0 | add D$ApiCommentMax 8
L5:         lodsb | stosb | inc D$ApiComment
            If al = LF
                Mov eax '    ' | stosd | Mov D$ApiComment 0
            Else_If al = ';'
                dec edi
                Mov ecx D$ApiCommentMax | sub ecx D$ApiComment
                Mov al SPC | rep stosb
                Mov al ';' | stosb
            End_If
            cmp al ')' | jne L5<
            Mov B$edi 0, B$edi-1 SPC
L8:         Call 'USER32.SendDlgItemMessageA' D$H.ShowApiDialog, 11, &WM_SETTEXT,
                                              0, OneApiInfo
            ret
        ..End_If

    ...Else_If B$esi-1 = 'A'
L3:     On B$esi = 0, jmp L2<<

    ...Else_If B$esi-1 = 'W'
        jmp L3<
    ...End_If
    Mov al ')' | repne scasb | On B$edi = 0, jmp L9>
    On ecx = 0, jmp L9> ;ret
    add edi 2 | jmp L1<<                                       ; +2 for CR/LF

L9: Call 'USER32.SendDlgItemMessageA' D$H.ShowApiDialog, 11, &WM_SETTEXT,
                                      0, NotYetApiInfo
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE MainProc        ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

; Equates given by the Menu Editor:

; Tag Menu 1000
[M00_Menu  1000                  M00_Open  1001                  M00_New  1002
 M00_New_Model  1003             M00_Paste_at_Pos  1004          M00_Change_Compile_Name  1005
 M00_Open_Source_Only  1006      M00_Replace_Source_Only  1007   M00_Save_Source_Only  1008
 M00_Print  1009                 M00_Output  1010                M00_Exit  1011
 M00_Tree  1012                  M00_Import  1013                M00_Export  1014
 M00_Find  1015                  M00_Replace  1016               M00_Undo  1017
 M00_Redo  1018                  M00_Copy  1019                  M00_Paste  1020
 M00_Delete  1021                M00_Cut  1022                   M00_Compile  1023
 M00_Run  1024                   M00_Optimize_Jumps_Sizes  1025  M00_Calc  1026
 M00_Ascii_Table  1027           M00_Show_BUAsm_Mems  1028       M00_Show_Symbols_Repartition  1029
 M00_Serial_Compilations  1030   M00_Data_to_Equates  1031       M00_Encoding  1032
 M00_DLLs_Scanner  1033          M00_Configuration  1034         M00_Create_Config_bin  1035
 M00_Main_Icon  1036             M00_Load_Icon  1037             M00_Delete_Icon  1038
 M00_Icon_IDs  1039              M00_Save_Icon  1040             M00_Load_BitMap  1041
 M00_Delete_BitMap  1042         M00_BitMaps_IDs  1043           M00_Save_BitMap  1044
 M00_Load_Cursor  1045           M00_Delete_Cursor  1046         M00_Cursors_IDs  1047
 M00_Save_Cursor  1048           M00_Load_Wave  1049             M00_Delete_Wave  1050
 M00_Waves_IDs  1051             M00_Save_Wave  1052             M00_Load_Avi  1053
 M00_Delete_Avi  1054            M00_Avi_IDs  1055               M00_Save_Avi  1056
 M00_Load_RC  1057               M00_Delete_RC  1058             M00_RCs_IDs  1059
 M00_Save_RC  1060               M00_New_Dialog  1061            M00_Load_from_Resources  1062
 M00_Load_from_ClipBoard  1063   M00_Load_from_File  1064        M00_Save_to_Binary_File  1065
 M00_Load_from_Binary_File  1066 M00_Replace_from_Binary_File  1067
 M00_Delete_Resources_Dialog  1068                               M00_Strings  1069
 M00_New_Menu  1070              M00_Existing_Menu  1071         M00_Delete_a_Menu  1072
 M00_Save_to_Binary_Menu_File  1073                              M00_Load_Binary_Menu_File  1074
 M00_Replace_from_Binary_Menu_File  1075                         M00_Clip_File  1076
 M00_Structures  1077            M00_Api_Functions  1078         M00_Sys_Resources  1079
 M00_GUIDs  1080                 M00_Win32_Equates  1081         M00_Win32_Data_Types  1082
 M00_Wizards  1083               M00_B_U_Asm  1084               M00_Sources_Editor  1085
 M00_Visual_Tuts  1086           M00_Win32_hlp  1087             M00_Mmedia_hlp  1088
 M00_OpenGl_hlp  1089            M00_WinSock_hlp  1090           M00_Dx_hlp  1091
 M00_SDL  1092                   M00_sqlite  1093                M00_DevIl  1094
 M00_About  1095                 M00_GPL_License  1096           M00_RosAsm_License  1097
 M00_<_  1098                    M00_>  1099]

[M00_About_ToolBar 1200]
____________________________________________________________________________________________

[FL.ShowStats: D$ &TRUE]

[FL.Redraw: D$ ?
 FL.ReadyToRun: D$ ?
 FL.UnusedSymbolsDialogWanted: D$ ?]

; Buffer for returned filename
[LP.File: B$ ? # &MAX_PATH]


Proc MainWindowProc:

; [TOPCODE] N° de version àmettre à jour à chaque modification

;;
    
    TEXT
    
    TEXT
    ___________________________________________________________________________
    ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
    TEXT

    ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
    ___________________________________________________________________________
    ¦TEXT¦TEXT¦ ...  *** /// <TEXT> | TEXT |^^^^^|----| (0123456789) |{texte}|
    ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
   
    TEXT
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯
    TEXT
    _ _ _ _ _ _ _ _ _ 
     ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯ ¯
    TEXT
     
    SYMBOLS: 45×6= ¼½¾  ÷ ± ø ^² ^³ ^¹ ^° º

    
    
    
    
    [MAIN]
    
    

    MAJ:
    
    Bp                                  ->  BreakPoint

    Macros évocation                    ->  mov/Mov pus/Push pop/Pop Move/Move If Else_IF End_If
    Début révision cursor               ->  ID_TIMER_CURSOR

    Début révision [CreateTitleTab]     ->  Changement des propriétés de la fonte et maintient
                                            du scroll molette pendant les changements de TITLEs.
                                            Affichage en une seule fois sans clignotement. 
[GetActualPartFromPos]
[ExtendMemory]

[OpenBUAsmPE]
[StoreChoosenName]

    Début révision [MainWindowProc]     ->  Restructuration avant démontage
 
    Révision [StatusBar]
 
    [ResizeScrollBar] refaire au model les autres fenêtres !!! -> MainResize: CreateEditWindow

;;

;;
    
  [CreateTitleTab]
    
  [NewReplaceMacAndEqu] [GetFileNameFromPath]
  
  'CheckMRUFile', 'RightClick','WheelMsg'
  'ShowUnfoldMacro', 'UnfoldMacro', 'ShowUnfoldDialog'
  'StructDialog'; 'NewFileNameDialog'
  'EncodeLines', 'StoreFlatData', 'UpdateTitlesFromIncludeFiles'
  
  'Main', 'AsmMain, 'checksum64' 'OutOnError'
  
  'NewReplaceMacAndEqu', 'zReplaceEquates'
  
  'KillTrailingSpaces', 'NewFileNameDialog', 'DataToStructureProc'

;;

    Arguments @hwnd,
              @msg,
              @wParam,
              @lParam

    Mov eax D@hwnd

    Comp eax D$H.MainWindow = S3>

    Comp eax D$H.EditWindow <> S1>

        Mov edx D$STRUC.WINDOWCLASS@hCursor | Comp D$H.CurrentCursor edx = S3> | jmp S2>

S1: Comp eax D$H.ScrollBarWindow = S3>

    Comp eax D$H.BreakPointWindow <> S1>

        Mov edx D$H.CursorARROW | Comp D$H.CurrentCursor edx = S3> | jmp S2>

    ; This may happend when [Run]ing. This works because we do not hold anything at creation time
S1: Call 'USER32.DefWindowProcA' D@hwnd,
                                 D@msg,
                                 D@wParam,
                                 D@lParam

EndP
    __________________

    ; MAJ du curseur: TODO déclarer les Curseurs dans la classe ?!?
    __________________

S2: Mov D$H.CurrentCursor edx

    Call 'USER32.SetClassLongA' eax,
                                &GCL_HCURSOR,
                                edx
    ____________________________

    ; General purpose Callback:
    ____________________________

S3: Mov eax D@msg

    ...If eax = &WM_KEYDOWN
        .If D$FL.SourceReady = &TRUE
            movzx eax B@Wparam | Mov B$Keys+eax 1

            Call KeyMessage ; CharMessage

            On D$FL.BlinkingCaretWanted = &TRUE, Call ResetBlinkCursor
            If B$KeyHasModifedSource = &TRUE

                Mov D$FL.SourceHasChanged &TRUE
                Call AskForRedraw |
              jmp @NotReadyToRun
           ; Else_If B$KeyHasMovedCaret = &TRUE
           ;     Call AskForRedraw
            End_If

        .Else_If D@wParam = &VK_F1
            Call BUAsmHelp

        .Else_If D@wParam = &VK_F2
            Call F2Help

        .End_If

    ...Else_If eax = &WM_KEYUP
        movzx eax B@Wparam | Mov B$Keys+eax 0
        On eax = &VK_MENU, Mov B$keys+&VK_CONTROL &FALSE

    ...Else_If eax = &WM_GETMINMAXINFO

            ; Dimensions minimum de la MainWindow TODO aligner la toolbar dessus !!!
            Mov eax D@lParam,
                D$eax+MINMAXINFO.ptTrackSize+POINTX 500,
                D$eax+MINMAXINFO.ptTrackSize+POINTY 300

        jmp @ExitFalse ; !!!

    ...Else_If eax = &WM_SIZE

        Call MainResize

    ...Else_If eax = &WM_WINDOWPOSCHANGED

        Call TabResize

    ...Else_If eax = &WM_DROPFILES

        Call 'SHELL32.DragQueryFile' D@wParam,
                                     0,
                                     LP.File,
                                     &MAX_PATH

        Mov esi LP.File,
                edi SaveFilter

        while B$esi <> 0 | movsb | End_While | movsb
        Call DirectLoad
        Call StartEdition
        Call ReInitUndo
        Call SetPartialEditionFromPos
        Call EnableMenutems
        Call LoadBookMarks
        Call AskForRedraw

    ...Else_If eax = &WM_DESTROY
        On D$FL.DialogEdition = &TRUE, Call CloseDialogEdition
        Call DeleteUndoFiles | Call KillUndo
        Call ReleaseResourceMemory
        Call 'USER32.PostQuitMessage' &WM_NULL

        jmp @ExitFalse ; !!!

    ...Else_If D@msg = &WM_NOTIFY

        Call KillCompletionList ; !!! ???

        ; Edx > NMHDR // eax > hwndFrom.
        Mov edx D@lParam, eax D$edx+TOOLTIPTEXT_NMHDR_hwndFrom

        ; Tab (TITLEs)
        .If eax = D$H.TabWindow

            If D$edx+TOOLTIPTEXT_NMHDR_code = &TCN_SELCHANGE

                Call WM_BUTTON_Tab

            End_If

        .Else_If eax = D$H.StatusBar

            If D$edx+TOOLTIPTEXT_NMHDR_code = &NM_CLICK

                Mov eax D$edx+NMMOUSE_HitInfo

                ; Ecx = Nombre byte dans table StatusPartsPos
                Mov edx TABLE.StatusPartsPos,
                    ecx D$edx-(1*DWORD)

                sub ecx (2*DWORD)

                jmp S1>

            L0: sub ecx DWORD

            S1: Comp eax D$edx+ecx < L0<

                ; Si selection de l'ID 1 ouvrir la fenêtre TITLEs
                On ecx = ((ID_STATUS_BAR_TITLE-1)*DWORD) Call TITLESOnOff

            End_If

        ; ToolBar Messages:
        .Else_If D$edx+TOOLTIPTEXT_NMHDR_code = &TTN_NEEDTEXT
            Mov eax D$edx+TOOLTIPTEXT_NMHDR_idfrom
          ; Pointing with esi to the Buttons List IDs:
            lea esi D$ToolBarButtons+4
            Mov ecx 0
            While D$esi <> eax
                add esi 20 | inc ecx | On ecx > TOOLBUTTONS_NUMBER jmp @ExitFalse ; !!!ExitP
            End_While
            Mov eax D$PointersToToolTipsStrings+ecx*4
            Mov D$edx+TOOLTIPTEXT_lpszText eax

        .Else_If D$edx+TOOLTIPTEXT_NMHDR_code = &TBN_QUERYINSERT ; May be inserted ?

            Mov eax &TRUE  ; > yes for all.

EndP

        .Else_If D$edx+TOOLTIPTEXT_NMHDR_code = &TBN_QUERYDELETE ; May be deleted?

                        Mov eax &TRUE         ; > yes for all.

EndP

        .Else_If D$edx+TOOLTIPTEXT_NMHDR_code = &TBN_FIRST  ; = &TBN_GETBUTTONINFO (missing?)
            Mov ecx D$edx+TB_NOTIFY_Item ;, edx ecx
            If ecx > TOOLBUTTONS_NUMBER

                jmp @ExitFalse ; !!!

            End_If
            lea ecx D$ecx*4+ecx | shl ecx 2                 ; ecx = ecx * 20 >>>
            add ecx ToolBarButtons                          ; Pointer to whished Button Data
            Move D$edx+TB_NOTIFY_TBBUTTON_iBitmap D$ecx
            Move D$edx+TB_NOTIFY_TBBUTTON_idCommand D$ecx+4
            Move D$edx+TB_NOTIFY_TBBUTTON_fsState D$ecx+8
            Move D$edx+TB_NOTIFY_TBBUTTON_dwData D$ecx+12
            Move D$edx+TB_NOTIFY_TBBUTTON_iString D$ecx+16
            Mov edi D$edx+TB_NOTIFY_TextPtr
            Mov ecx D$edx+TB_NOTIFY_Item | shl ecx 2        ; Displacement to pointers
            Mov eax PointersToToolTipsStrings | add eax ecx ; Pointer
            Mov esi D$eax                                   ; Source
            Mov ecx 0-1                                     ; Counter for Non-zero-ended text
            Do
                lodsb | stosb | inc ecx
            Loop_Until al = 0
            Mov D$edx+TB_NOTIFY_CharCount ecx               ; Lenght of String    (+36)

            Mov eax &TRUE

EndP

        .Else_If D$edx+TOOLTIPTEXT_NMHDR_code = &TBN_TOOLBARCHANGE
            Mov B$ToolBarChange &TRUE                       ; For Saving at Exit if TRUE.

            ; Next instruction of no use usually, but, under some unknown circumstances
            ; the Buttons Size may be changed (Win98 without IE). So, as it can't hurt:
            Call 'USER32.SendMessageA' D$H.ToolBar, &TB_SETBUTTONSIZE, 0, 014_0014

        .Else_If D$edx+TOOLTIPTEXT_NMHDR_code = &TBN_RESET
            Call 'USER32.SendMessageA' D$H.ToolBar, &TB_SAVERESTORE, &FALSE,
                                    TOOLBAR_REGISTRY        ; FALSE > restore

        .Else_If D$edx+TOOLTIPTEXT_NMHDR_code = &TBN_CUSTHELP
            Call 'USER32.MessageBoxA' D$H.MainWindow, HelpToolBar, HelpToolBarTitle,
                                    &MB_OK__&MB_SYSTEMMODAL
        .End_If
    ____________________________________________________________

    ; Main window CallBack: User choices open-file independant:
    ____________________________________________________________

    ...Else_If eax = &WM_COMMAND

        Call KillCompletionList

       Mov eax D@wParam | and eax 0FFFF

        If D$FL.Includes = &FALSE

            Call Configuration | Call 'USER32.SendMessageA' D$H.MainWindow,
                                                            &WM_CLOSE,
                                                            0,
                                                            0

        End_If

        ..If eax = M00_Open

            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse

            Call Security | On eax = &IDCANCEL jmp @ExitFalse

            Call OpenBUAsmPE

            Call UpdateTitlesFromIncludeFiles

            If D$SaveFilter <> 0

                Call ReInitUndo

                Call SetPartialEditionFromPos | Call EnableMenutems

                Call LoadBookMarks

            End_If

        ..Else_If eax = M00_Open_Source_Only

            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse ; !!!

            Call Security | On eax = &IDCANCEL, jmp @ExitFalse

            Call LooseResources
            .If B$KeepResources = &FALSE
                Call ReInitUndo | Call OpenSourceOnly
                Call UpdateTitlesFromIncludeFiles
                If D$SourceLen > 0
                    Call SetPartialEditionFromPos | Call EnableMenutems
                    Call LoadBookMarks
                End_If
            .End_If

        ..Else_If eax = M00_Exit

            Call 'USER32.SendMessageA' D$H.MainWindow &WM_CLOSE 0 0

        ..Else_If eax = M00_Sources_Editor
            Call Help, B_U_AsmName, SourceEditor, ContextHlpMessage

        ..Else_If eax = M00_Main_Icon
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call IconEdition | jmp @NotReadyToRun

        ..Else_If eax = M00_New_Menu
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call NewMenu | Mov D$ActualMenutestID 0 | Call EnableMenutems | jmp @NotReadyToRun

        ..Else_If eax = M00_Existing_Menu
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call ExistingMenu | Mov D$ActualMenutestID 0 | jmp @NotReadyToRun

        ..Else_If eax = M00_Delete_a_Menu
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call DeleteMenu | Mov D$ActualMenutestID 0 | Call EnableMenutems | jmp @NotReadyToRun

        ..Else_If eax = M00_Save_to_Binary_Menu_File
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call SaveMenuBinaryFile

        ..Else_If eax = M00_Load_Binary_Menu_File
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call LoadMenuBinaryFile | jmp @NotReadyToRun

        ..Else_If eax = M00_Replace_from_Binary_Menu_File
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call ReplaceMenuBinaryFile | jmp @NotReadyToRun

        ..Else_If eax = M00_About | Call AboutBox

        ..Else_If eax = M00_About_ToolBar | Call About_ToolBar

        ..Else_If eax = M00_GPL_License | Call GPLView

        ..Else_If eax = M00_RosAsm_License | Call LicenseView

        ..Else_If eax = M00_B_U_Asm | Call BUAsmHelp

        ..Else_If eax = M00_Configuration | Call Configuration

        ..Else_If eax = M00_Create_Config_bin | Call Create_Config_bin

        ..Else_If eax = M00_Api_Functions | Call ViewApiList

        ..Else_If eax = M00_New
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call Security | On eax = &IDCANCEL jmp @ExitFalse ; !!!
            Call AutoNew
            and D$FL.RelocsWanted 0 ; jE!
            Call ChangeName
            cmp D$SavingExtension '.DLL' | setz B$FL.RelocsWanted ; jE! Relocs for Dll
            Call StartNewFile

        ..Else_If eax = M00_New_Model
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call Security | On eax = &IDCANCEL jmp @ExitFalse ; !!!
            Call NewFileNameDialog

        ..Else_If eax = M00_Change_Compile_Name | Call ChangeName

        ..Else_If eax = M00_Calc | Call Calc

        ..Else_If eax = M00_DLLs_Scanner | Call ExportScanner

      ;  ..Else_If eax = M00_Libs_Scanner | Call LibScanner

        ..Else_If eax = M00_New_Dialog
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            If D$FL.DialogEdition = &FALSE
                Mov B$SameIdAllowed &FALSE
                On D$FL.BlinkingCaretWanted = &TRUE, Call KillBlinkCursor
                    Call InitDialogEdition | Call ReleaseDialogMemories
                On D$FL.BlinkingCaretWanted = &TRUE, Call ResetBlinkCursor
                Call EnableMenutems | jmp @NotReadyToRun
            End_If

        ..Else_If eax = M00_Load_from_ClipBoard
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            If D$FL.DialogEdition = &FALSE
                Mov B$SameIdAllowed &FALSE
                On D$FL.BlinkingCaretWanted = &TRUE, Call KillBlinkCursor
                    Call ReleaseDialogMemories | Call LoadDialogFromClipBoard
                On D$FL.BlinkingCaretWanted = &TRUE, Call ResetBlinkCursor
                Call EnableMenutems | jmp @NotReadyToRun
            End_If

        ..Else_If eax = M00_Load_from_File
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            If D$FL.DialogEdition = &FALSE
                Mov B$SameIdAllowed &FALSE
                On d$FL.BlinkingCaretWanted = &TRUE, Call KillBlinkCursor
                    Call ReleaseDialogMemories | Call LoadDialogFromFile
                On D$FL.BlinkingCaretWanted = &TRUE, Call ResetBlinkCursor
                Call EnableMenutems | jmp @NotReadyToRun
            End_If

        ..Else_If eax = M00_Load_from_Resources
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            If D$FL.DialogEdition = &FALSE
                Mov B$SameIdAllowed &TRUE
                On D$FL.BlinkingCaretWanted = &TRUE, Call KillBlinkCursor
                    Call ReleaseDialogMemories | Call LoadFromResources
                On D$FL.BlinkingCaretWanted = &TRUE, Call ResetBlinkCursor
                jmp @NotReadyToRun
            End_If

        ..Else_If eax = M00_Save_to_Binary_File
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call SaveToBinaryFile

        ..Else_If eax = M00_Load_from_Binary_File
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Mov B$SameIdAllowed &TRUE
            Call LoadFromBinaryFile | Call EnableMenutems | jmp @NotReadyToRun

        ..Else_If eax = M00_Replace_from_Binary_File
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call ReplaceFromBinaryFile | jmp @NotReadyToRun

        ..Else_If eax = M00_Delete_Resources_Dialog
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            On D$FL.BlinkingCaretWanted = &TRUE, Call KillBlinkCursor
                Call DeleteDialog | Call EnableMenutems
            On D$FL.BlinkingCaretWanted = &TRUE, Call ResetBlinkCursor
            jmp @NotReadyToRun

        ..Else_If eax = M00_Load_BitMap
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call LoadBitMap | Call EnableMenutems | jmp @NotReadyToRun

        ..Else_If eax = M00_Delete_BitMap
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call DeleteBitMap | Call EnableMenutems | jmp @NotReadyToRun

        ..Else_If eax = M00_BitMaps_IDs | Call ShowBitMapsIds

        ..Else_If eax = M00_Load_Wave
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call ReadWaveFile | Call EnableMenutems | jmp @NotReadyToRun

        ..Else_If eax = M00_Delete_Wave
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call DeleteWave | Call EnableMenutems | jmp @NotReadyToRun

        ..Else_If eax = M00_Load_Avi
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call ReadAviFile | Call EnableMenutems | jmp @NotReadyToRun

        ..Else_If eax = M00_Delete_Avi
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call DeleteAviFile | Call EnableMenutems | jmp @NotReadyToRun

        ..Else_If eax = M00_Load_RC
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call ReadRcData | Call EnableMenutems | jmp @NotReadyToRun

        ..Else_If eax = M00_Save_RC
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call SaveRcData | jmp @NotReadyToRun

        ..Else_If eax = M00_Delete_RC
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call DeleteRcData | Call EnableMenutems | jmp @NotReadyToRun

        ..Else_If eax = M00_Ascii_Table | Call AsciiTable

        ..Else_If eax = M00_Win32_hlp | Call Win32_Hlp

        ..Else_If eax = M00_Mmedia_hlp | Call Mmedia_Hlp

        ..Else_If eax = M00_OpenGl_hlp | Call OpenGl_Hlp

        ..Else_If eax = M00_WinSock_hlp | Call WinSock_Hlp

        ..Else_If eax = M00_Dx_hlp | Call Dx_Hlp

        ..Else_If eax = M00_SDL | Call SDL_hlp

        ..Else_If eax = M00_sqlite | Call sqlite_Hlp

        ..Else_If eax = M00_DevIl | Call DevIL_Hlp

        ..Else_If eax = M00_Win32_Data_Types | Call ShowTypes

        ..Else_If eax = M00_Win32_Equates | Call ShowEquates

        ..Else_If eax = M00_Strings
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call StringsResources | jmp @NotReadyToRun

        ..Else_If eax = M00_Load_Cursor
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call ReadCursor | Call EnableMenutems | jmp @NotReadyToRun

        ..Else_If eax = M00_Delete_Cursor
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call DeleteCursor | Call EnableMenutems | jmp @NotReadyToRun

        ..Else_If eax = M00_Load_Icon
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call ReadIcon | Call EnableMenutems | jmp @NotReadyToRun

        ..Else_If eax = M00_Delete_Icon
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse
            Call DeleteIcon | Call EnableMenutems | jmp @NotReadyToRun

        ..Else_If eax = M00_Clip_File | Call Templates
           ; Call SetQwordCheckSum String2

        ..Else_If eax = M00_Data_to_Equates | Call DataToStructure

        ..Else_If eax = M00_Structures | Call StructDialog

        ..Else_If eax = M00_Sys_Resources | Call ViewSysResources

        ..Else_If eax = M00_GUIDs | Call ViewGUIDs

        ..Else_If eax = M00_Show_BUAsm_Mems | Call ViewBUAsmMems

        ..Else_If eax = M00_Show_Symbols_Repartition | Call TestRepartition

      ;  ..Else_If eax = M00_Local_mem_Tests | Call TestLocals

        ..Else_If eax = M00_Serial_Compilations | Call MultipleCompileTests

        ..Else_If eax = M00_Encoding
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse

            Call ViewEncoding

            jmp @NotReadyToRun

        ..Else
            .If eax > 6999                      ; Clip Files
                Call Templates

            .Else_If eax > 5999                  ; Wizards
                Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse

                On D$FL.SourceReady = &FALSE,
                    Call 'USER32.SendMessageA', D$H.MainWindow, &WM_COMMAND, M00_New, 0

                On D$FL.SourceReady = &TRUE Call NewWizardForm

            .Else_If eax > 4999                  ; Visual Tuts
                If eax < 5100
                   Call VisualTuts
                Else
                    jmp L5>>
                End_If

            .Else_If eax > 3999             ; Added FloatMenu under [Struct].
                If eax < 4010
                    Mov D$MenuID eax | Call StructDialog ; OpenStructureFile
                Else
                    jmp L5>>
                End_If

            .Else_If eax > 3000             ; Most Recently Used Files.
                If eax < 3005
                    Push eax
                    Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse

                        Call Security       ; 'Security' also uses eax as return Value.
                    Pop ebx
                    On eax = &IDCANCEL jmp @ExitFalse  ; !!!
                        Mov eax ebx         ; ... and 'LoadRMUfile' as input.
                        Call LoadRMUfile
                        On eax = &FALSE, jmp L5>
                        Call SetPartialEditionFromPos
                        Call LoadBookMarks | Call EnableMenutems | Call LoadBookMarks
                Else
                    jmp L5>
                End_If
            .Else_If eax > 1999             ; User defined menu:
                If eax < 2009
                    Mov eax D@wParam | Call UserDefinedAction
                Else
                    jmp L5>
                End_If
            .Else
                jmp L5>
            .End_If
        ..End_If

        jmp @ExitFalse ; !!!

    ...Else_If eax = &WM_CLOSE

        Call WM_CLOSE_MainWindow

        jmp @ExitFalse ; !!!

    ...End_If

L5: test D$FL.SourceReady &TRUE ZERO @NoClient
    ________________________________________________________

    ; Main window CallBack going on: With opened file only:
    ________________________________________________________

    Mov eax D@msg

    ...If eax = &WM_PAINT

            .If D$CodeSource > 0

                Call TextPos

                Mov eax D@hwnd

                If eax = D$H.EditWindow

                    Call PrintColorText

                Else_If eax = D$H.BreakPointWindow

                    Call PrintBreakPoint

                End_If

                If B$MovingBlock = &TRUE

                    Call SetBlock | Call AskForRedraw

                End_If

            Call StatusBar

                Mov D$FL.Redraw &FALSE

            .End_If

        Mov eax D$H.EditWindow | On D@hwnd <> eax jmp @NoClient

    ...Else_If eax = &WM_CHAR
        ..If D$FL.Redraw = &FALSE
            Mov D$FL.Redraw &TRUE

            Call CharMessage D@wParam | or D$FL.SourceHasChanged eax

            Call AskForRedraw | jmp @NotReadyToRun
        ..End_If
;;
   Note from Betov: This 'WM_IME_CHAR' case and according Routine have been implemented
   by Liang Xianning. I am pretty sure that holding unicode oriental KeyBoards input
   can *not* be done this way for many reasons (what if one byte inside the unicode
   string is equal to Quote, Double-Quote,... and other critical Bytes values? What of
   BackSpace upon such a String, and so on. Also, all of the innumerous RosAsm Routines
   that perform any action on Source Text should be re-written too... What i would
   clearly refuse 'for many reasons...' too).

   The only solution i can imagine for inputing Oriental Unicode Strings would be to
   write an external little tool (a simple EditControl + a simple Routine to save the
   String Data in U$ RosAsm Format -in hexaDecimal Numbers- to be pasted in the Source
   Data through the ClipBoard. Very easy to do, but i can't do it. (I can't see any
   Oriental Char on my PC...).

   Another thing is that fully holding Oriental Char *inside* an Asm Source Editor
   does not make much sense, as the source would then be turned of no use for all other
   programmers. Do i write in french??? Oh yes,... Sometimes, when i am ashamed... :))
;;
    ...Else_If eax = &WM_IME_CHAR
        .If D$FL.Redraw = &FALSE
            Call CloseDebuggerOrIgnore | Comp eax &IDNO <> @ExitFalse

            Mov D$FL.Redraw &TRUE
            Mov eax D@Wparam | Call InsertDoubleByte | Call AskForRedraw
            jmp @NotReadyToRun
        .End_If

    ...Else_If eax = &WM_MOUSEWHEEL
            Call WheelMsg

    ...Else_If eax = &WM_XBUTTONDOWN
        ..If W@Wparam+2 = &XBUTTON1
            Mov D$FL.BlockInside &FALSE
            Call RestoreRealSource | Call BackClick | Call SetPartialEditionFromPos

        ..Else_If W@Wparam+2 = &XBUTTON2
            Mov D$FL.BlockInside &FALSE
            Call RestoreRealSource | Call ForwardClick | Call SetPartialEditionFromPos
        ..End_If

        Mov eax &TRUE

EndP

    ...Else_If eax = &WM_COMMAND
        Mov eax D@Wparam | and eax 0FFFF

        ..If eax = M00_<_
            Mov D$FL.BlockInside &FALSE
            Call RestoreRealSource | Call BackClick | Call SetPartialEditionFromPos

        ..Else_If eax = M00_>
            Mov D$FL.BlockInside &FALSE
            Call RestoreRealSource | Call ForwardClick | Call SetPartialEditionFromPos

        ..Else_If eax = M00_Compile
            Mov D$FL.ShowStats &TRUE
            Call Compile

        ..Else_If eax = M00_Run
            Call Run

        ..Else_If eax = M00_Optimize_Jumps_Sizes
            Call Optimize

       ; ..Else_If eax = M00_Profile | Call Profiler

        ..Else_If eax = M00_Paste_at_Pos
         ;   On D$IsDebugging = &TRUE, jmp @ExitFalse
            Call RestoreRealSource | Call IncludeSource | Call SetPartialEditionFromPos
            Mov D$FL.SourceHasChanged &TRUE, D$FL.SourceHasChanged &FALSE
            Call SetCaret D$STRUCT.EditData@CurrentWritingPos

        ..Else_If eax = M00_Find
            Mov D$NextSearchPos 0 | Call SetSimpleSearchBox

        ..Else_If eax = M00_Replace
            Mov D$NextSearchPos 0 | On D$FL.IsDebugging = &FALSE, Call SetFindReplaceBox

        ..Else_If eax = M00_Undo
            Call ControlZ

        ..Else_If eax = M00_Redo
            Call ControlShiftZ

        ..Else_If eax = M00_Copy
            Call ControlC

        ..Else_If eax = M00_Paste
            Call ControlV | Call AskForRedraw

        ..Else_If eax = M00_Delete
            Call ControlD | Call AskForRedraw

        ..Else_If eax = M00_Cut
            Call ControlX | Call AskForRedraw

        ..Else_If eax = M00_Save_Source_only
            Call ControlS

        ..Else_If eax = M00_Replace_Source_Only
            On D$FL.IsDebugging = &TRUE, jmp @ExitFalse
            Call ReInitUndoOnly
            Call ReplaceSourceOnly
            Call UpdateTitlesFromIncludeFiles
            On D$SourceLen > 0, Call SetPartialEditionFromPos

        ..Else_If eax = M00_Tree
            Call CreateTreeViewList | Call SetTreeDialogPos

        ..Else_If eax = M00_Import
           Call ShowSourceImports

        ..Else_If eax = M00_Export
           Call ShowSourceExports

        ..Else_If eax = M00_Print | Call Print

        ..Else_If eax = Float_Copy
            Call CopyFromFloatMenu | Call AskForRedraw
            Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint

        ..Else_If eax = Float_Delete
            Call ControlX | Call AskForRedraw
            Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint

        ..Else_If eax = Float_Replace
            Call ControlD | Call ControlV | Call AskForRedraw
            Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint

        ..Else_If eax = Float_SearchUp
            Call RestoreRealSource
            Call StorePosInBackTable | Call SearchUpFromFloatMenu
            Call SetPartialEditionFromPos
            Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint

        ..Else_If eax = Float_SearchDown
            Call RestoreRealSource
            Call StorePosInBackTable | Call SearchDownFromFloatMenu
            Call SetPartialEditionFromPos
            Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint

        ..Else_If eax = Float_SearchFromTop
            Call RestoreRealSource
            Call StorePosInBackTable | Call SearchFromTopFromFloatMenu
            Call SetPartialEditionFromPos
            Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint

        ..Else_If eax = Float_Unfold
            Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint
            Call RestoreRealSource | Call ShowUnfoldMacro | Call SetPartialEditionFromPos

        ..Else_If eax = Float_BookMark | Call StoreBookMark
            Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint

        ..Else_If eax = Float_UnBookMark | Call DeleteBookMark
            Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint

        ..Else_If eax = Float_Number | Call ViewClickedNumber
            Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint

        ..Else_If eax = Float_SelReplace
            Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint | Call BlockReplaceAll

        ..Else_If eax = MenuFloatSetBreakPoint
            Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint
            Call SetBreakPoint | Call DoStoreBreakPoint | jmp @NotReadyToRun

        ..Else_If eax = MenuFloatDelBreakPoint
            Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint
            Call DeleteBreakPoint | Call DoStoreRemoveBreakPoint | jmp @NotReadyToRun

        ..Else_If eax = MenuFloatDelAllBreakPoint
            Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint
            Call DeleteAllBreakpoints | jmp @NotReadyToRun

        ..Else_If eax = Float_BadDisLabel
            Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint
            Call ForcedFlags

        ..Else_If eax = M00_Output
            Call OutputFormat | Call EnableMenutems | jmp @NotReadyToRun

        ..End_If

    ...Else_If eax = &WM_MOUSEMOVE

        .If D@Wparam <> &MK_LBUTTON

            Call 'USER32.ClipCursor' &NULL ; !!! TODO à revoir pour éviter de le faire à chaque déplacement de curseur !!!

        .Else

            On B$UserHaveClickDown = &FALSE, jmp @NoClient

            On B$UserClickAfterEnd = &TRUE, jmp @NoClient

            Push D@Lparam | Pop W$MousePosX, W$MousePosY

            Call SetBlock

            If B$FirstBlockDraw = &FALSE

                On B$BlockRedraw = &TRUE, Call AskForRedrawNow

            End_If

        .End_If

    ...Else_If eax = &WM_LBUTTONDOWN

        Mov B$ShiftBlockInside &FALSE

        Call KillCompletionList

        On D$FL.BlinkingCaretWanted = &TRUE, Call ResetBlinkCursor
        Push D@Lparam | Pop W$MousePosX, W$MousePosY

        Mov D$FL.BlockInside &FALSE, eax D@hwnd | Call LeftButton

        Call AskForRedrawNow
        Mov D$NextSearchPos 0, B$UserHaveClickDown &TRUE

    ...Else_If eax = &WM_LBUTTONUP

        On D$FL.BlinkingCaretWanted = &TRUE, Call ResetBlinkCursor
        On B$FirstBlockDraw = &TRUE, Mov D$FL.BlockInside &FALSE
        Call LeftButtonUp | Mov B$UserHaveClickDown &FALSE | Call AskForRedrawNow

    ...Else_If eax = &WM_RBUTTONUP
        Call KillCompletionList
        On D$FL.BlinkingCaretWanted = &TRUE, Call ResetBlinkCursor

        Mov eax D@hwnd
        .If eax = D$H.BreakPointWindow
            If D$DBPMenuOn = RIGHT_CLICK_ACTION
                Mov B$ShiftBlockInside &FALSE

                Call KillCompletionList

                On D$FL.BlinkingCaretWanted = &TRUE, Call ResetBlinkCursor
                Call RestoreRealSource
                    Push D@Lparam | Pop W$MousePosX, W$MousePosY
                    Call MarginRightClick
                Call SetPartialEditionFromPos
            End_If

            jmp @NoClient
        .End_If

        Call RestoreRealSource
            Push D@Lparam | Pop W$MousePosX, W$MousePosY
            Call RightClick
        Call SetPartialEditionFromPos

    ...Else_If eax = &WM_LBUTTONDBLCLK
        Mov B$ShiftBlockInside &FALSE

        Call KillCompletionList

        On D$FL.BlinkingCaretWanted = &TRUE, Call ResetBlinkCursor
        Call RestoreRealSource
            Push D@Lparam | Pop W$MousePosX, W$MousePosY
            Call DoubleClick
        Call SetPartialEditionFromPos

    ...Else_If eax = D$FindStringMessage
        Call KillCompletionList

        Call StringSearch | Call AskForRedraw

    ...Else
        jmp @NoClient

    ...End_If

@ExitFalse:

      Mov eax &FALSE | jmp P9>>

@NotReadyToRun:

    If D$FL.ReadyToRun = &TRUE         ; (Something has just been modified).
        Mov D$FL.ReadyToRun &FALSE

        Call VirtualFree IpTable

        Call VirtualFree StatementsTable

        Call VirtualFree StatementsTable2

    End_If

    Mov D$FL.SourceHasChanged &TRUE

    Mov eax &FALSE | jmp P9>

@NoClient:

    Call 'USER32.DefWindowProcA' D@hwnd,
                                 D@msg,
                                 D@wParam,
                                 D@lParam

EndP
____________________________________________________________________________________________

WM_CLOSE_MainWindow:

        Call CloseDebuggerOrIgnore | Comp eax &IDNO = S1>

ret

S1:     On D$FL.DialogEdition = &TRUE Call CloseDialogEdition

        Call Security | On eax = &IDCANCEL ret

        If D$FL.SaveMainPos = &TRUE

            Call 'USER32.ShowWindow' D$H.MainWindow,
                                     &SW_RESTORE

            Call 'USER32.GetWindowRect' D$H.MainWindow,
                                        STRUC.RECT.MainWindow

            Mov eax D$WindowX | sub D$WindowW eax

            Mov eax D$WindowY | sub D$WindowH eax

            Call UpdateRegistry

        End_If

        On D$ToolBarChange = &TRUE Call SaveToolBar

        Call LeftButtonUp                            ; ensure no confined mouse

        Call CloseHelp

        On D$H.EditedDialog <> 0 Call 'USER32.DestroyWindow' D$H.EditedDialog

        On D$H.DialogEditor <> 0 Call 'USER32.EndDialog' D$H.DialogEditor

        Call 'USER32.DestroyWindow' D$H.MainWindow

ret
____________________________________________________________________________________________

Compile:

    If D$H.UnusedCodeAndDataDialog = &FALSE

        test D$FL.Compiling &TRUE NOT_ZERO S0>>

        test D$FL.IsDebugging &TRUE NOT_ZERO S0>

    Else

        Mov D$FL.ShowStats &FALSE

    End_If

    Mov B$RecompileWanted &FALSE, D$FL.Compiling &TRUE

    Call RestoreRealSource

    On D$H.UnusedCodeAndDataDialog <> 0 Call ReInitUnusedDialog

    Call AsmMain | Mov D$OldStackPointer &NULL

    If D$FL.CompileErrorHappend = &FALSE

        Mov D$FL.ReadyToRun &TRUE, D$FL.SourceHasChanged &FALSE

    End_If

    Call SetPartialEditionFromPos

    Call AskForRedraw

    Mov D$FL.Compiling &FALSE | Call ResetKeys

S0:
ret


Run:
    If D$H.UnusedCodeAndDataDialog <> &FALSE
      ; 'UnusedCodeAndDataDialogCallBack'
        Call 'USER32.EndDialog' D$H.UnusedCodeAndDataDialog, 0
        Mov D$H.UnusedCodeAndDataDialog 0
        Mov D$FL.Compiling &FALSE, D$FL.UnusedSymbolsDialogWanted &FALSE, D$FL.ShowStats &FALSE
        Mov D$FL.UnusedSymbolsDialogWanted &FALSE
    End_If

    On D$FL.Compiling = &TRUE, ret
    On D$FL.IsDebugging = &TRUE, ret

    Mov D$FL.ShowStats &FALSE, D$FL.Compiling &TRUE, B$RecompileWanted &FALSE

    Call RestoreRealSource

    If D$FL.ReadyToRun = &FALSE
        Mov D$FL.ShowStats &FALSE
        Call AsmMain
        Mov D$OldStackPointer &NULL
        Mov D$FL.UnusedSymbolsDialogWanted &FALSE

        On D$FL.CompileErrorHappend = &FALSE Mov D$FL.ReadyToRun &TRUE

    End_If

    Call SetPartialEditionFromPos

    If D$FL.CompileErrorHappend = &FALSE

        Mov D$FL.SourceHasChanged &FALSE

        Call Debugger

    End_If

    Mov D$FL.Compiling &FALSE | Call ResetKeys
ret


Optimize:
    Mov B$AlignFound &FALSE

    If D$H.UnusedCodeAndDataDialog <> &FALSE
      ; 'UnusedCodeAndDataDialogCallBack'
        Call 'USER32.EndDialog' D$H.UnusedCodeAndDataDialog, 0
        Mov D$H.UnusedCodeAndDataDialog 0
        Mov D$FL.Compiling &FALSE, D$FL.UnusedSymbolsDialogWanted &FALSE, D$FL.ShowStats &FALSE
    End_If

    If D$FL.ReadyToRun = &FALSE
        Mov D$FL.ShowStats &FALSE
        Call Compile
    End_If

    .If D$FL.ReadyToRun = &TRUE
        If B$AlignFound = &TRUE
            Call 'USER32.MessageBoxA' D$H.MainWindow, NoptimizeMessage,
                                      NoptimizeTitle, &MB_SYSTEMMODAL
        Else
            Mov B$ShortenJumpsWanted &TRUE
            Mov D$FL.ShowStats &TRUE
            Call Compile
            Mov B$ShortenJumpsWanted &FALSE
        End_If
    .End_If
ret

[NoptimizeTitle: B$ 'Optimizer' EOS
 NoptimizeMessage: B$ "The Assembler can not yet optimize the Jump Sizes  
 on a Source making use of the Align Statement:
 
 The Alignments would be broken." EOS]
____________________________________________________________________________________________
____________________________________________________________________________________________

Proc ScrollBarProc:

    Arguments @hwnd,
              @msg,
              @wParam,
              @lParam

    On D$FL.SourceReady = &FALSE, jmp S1>>

    ...If D@msg = &WM_VSCROLL

        Call KillCompletionList

        Call 'USER32.IsMenu' D$H.MenuFloatBreakPoint

        ..If eax = &FALSE

            .If W@wParam = &SB_THUMBTRACK

                If D$TotalNumberOfLines < 0FFFF

                    movzx edx W@wParam+2

                Else

                    Call 'USER32.GetScrollInfo' D$H.ScrollBarWindow,
                                                &SB_VERT,
                                                VScroll

                    Mov edx D$VScroll.nTrackPos

                End_If

                Call RePosFromScroll

            .Else_If W@wParam = &SB_LINEDOWN

                Call DownOneLine

            .Else_If W@wParam = &SB_LINEUP

                Call UpOneLine

            .Else_If W@wParam = &SB_PAGEDOWN

                Call DownOneLine

            .Else_If W@wParam = &SB_PAGEUP

                Call UpOneLine

            .End_If

            Call AskForRedraw

        ..End_If

        Mov eax &FALSE

     ...Else

S1:     Call 'USER32.DefWindowProcA' D@hwnd,
                                     D@msg,
                                     D@wParam,
                                     D@lParam

     ...End_If

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[QuitTitle: B$ 'Sure?' EOS]
[QuitMessage: B$ 'Source has changed. Save/Compile now?' EOS]

Security:

    Mov eax &IDNO

    On D$CodeSource = 0 ret

    ...If D$FL.SecurityWanted = &TRUE

        ..If D$FL.SourceHasChanged = &TRUE

            Call 'MessageBoxA' D$H.MainWindow,
                               QuitMessage,
                               QuitTitle,
                               &MB_YESNOCANCEL

            .If eax = &IDYES

                Call RestoreRealSource

                Call AsmMain | Mov D$OldStackPointer &NULL

                If D$FL.CompileErrorHappend = &FALSE

                    Mov D$FL.ReadyToRun &TRUE,
                        D$FL.SourceHasChanged &FALSE,
                        eax &IDNO

                Else

                    Call SetPartialEditionFromPos | Mov eax &IDCANCEL

                End_If

            .End_If

        ..End_If

    ...End_If

ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[OldBlockInside: D$ ?
 DollarOnly: D$ ?]

Proc CharMessage:
    Argument @wParam

    Mov eax D@wParam | On eax = &VK_ESCAPE EndP

    On B$keys+&VK_CONTROL = &TRUE, jmp L2>>

    .If D$H.DebugDialog <> 0
        Push eax
        Call CloseDebuggerOrIgnore
            If eax = &IDNO
                Mov eax &FALSE

EndP

            End_If
        Pop eax
    .End_If

    Move D$OldBlockInside D$FL.BlockInside | Mov D$FL.BlockInside &FALSE

    If B$WriteCheckerWanted = &TRUE
        cmp eax 32 | je L1>
        cmp eax CR | je L1>
        cmp eax ',' | je L1>
        cmp eax 8 | je L1>
       ; cmp eax ':' | je L1>
        cmp eax TAB | jne L0>
L1:     Call WriteChecker D$STRUCT.EditData@CurrentWritingPos, eax
    End_If

L0: cmp eax CR | jne L1>
        If D$H.CompletionList <> 0
            Call ToCompletionList CR

EndP

        End_If
        Call CarriageReturn | jmp P8>>
L1: cmp eax 8 | jne L1>
        Call BackSpace | jmp P8>>
L1: cmp al 167 | jne L1>   ; 167 = Paragraph Char (no more available).
        On B$DollarOnly = &TRUE, Mov al '$'
L1: Mov B$SimulatedBlock &FALSE
    cmp B$keys+&VK_SHIFT &TRUE | jne L1>
        On B$OldBlockInside = &FALSE, Call SimulateBlockForBackIndent
L1: cmp B$OldBlockInside &TRUE | jne L1>
        cmp al TAB | jne L1>
            Call IsItBlockIndent
            .If B$SimulatedBlock = &TRUE
                Mov D$FL.BlockInside &FALSE
                Mov esi D$STRUCT.EditData@CurrentWritingPos
                If B$esi-1 = LF
                    Call StartOfLine
                Else
                    Call StartOfLine | Call AskForRedrawNow | Call StartOfLine
                End_If
            .End_If
            On B$BlockIndent = &TRUE, jmp P8>>
L1: ;Mov D$OldBlockInside &FALSE
    cmp D$STRUCT.EditData@Overwrite &TRUE | jne L1>
        Call OverwriteSource | jmp P8>>
L1:     Call InsertSource | jmp P8>>

L2: Call GetCtrlKeyState

    .If eax = 03
        Call ControlC | Mov eax &FALSE
    .Else_If eax = 016
        ;Mov D$FL.BlockInside &FALSE
        Call ControlV | Mov eax &TRUE
        Mov D$FL.BlockInside &FALSE
    .Else_If eax = 018
        Call ControlX | Mov eax &TRUE
    .Else_If eax = 04
        Call ControlD | Mov eax &TRUE
    .Else_If eax = 01A
        If B$Keys+&VK_SHIFT = &TRUE
            Call ControlShiftZ | Mov eax &FALSE ; ??? What use is this, here ???
        Else
            Call ControlZ | Mov eax &TRUE  ; ???
        End_If
    .Else_If eax = 1
        Call ControlA | Mov eax &FALSE
    .Else_If eax = 010
        Call ControlP | Mov eax &FALSE
    .Else_If eax = 012
        Mov D$NextSearchPos 0 | Call SetFindReplaceBox
        Mov B$keys+&VK_CONTROL &FALSE, eax &TRUE
    .Else_If eax = 013
        Call ControlS | Mov eax &FALSE
        Mov B$keys+&VK_CONTROL &FALSE
    .Else_If eax = 0B
        Call ControlK | Mov eax &FALSE
        Mov B$keys+&VK_CONTROL &FALSE
    .Else_If eax = 06
        Mov D$NextSearchPos 0 | Call SetSimpleSearchBox
        Mov B$keys+&VK_CONTROL &FALSE
        Mov eax &FALSE
        Mov B$keys+&VK_CONTROL &FALSE
    .Else_If eax = 019
        If B$CtrlYFlag = &TRUE
            Call ControlY | Mov eax &TRUE
        End_If
    .Else_If eax = SPC
        On B$Underline = &TRUE, Call Completion
        Mov eax &TRUE
        Mov B$keys+&VK_CONTROL &FALSE
    .Else
        Mov eax &FALSE
    .End_If

    Push eax | Call CheckCtrlKeyState | Pop eax | Mov D$OldBlockInside &FALSE | ExitP

P8: Mov D$OldBlockInside &FALSE, eax &TRUE
EndP
____________________________________________________________________________________________

[CtrlKeyState: D$ ?]

; The "and eax 0FFFF" makes it work as well under 95 and 2000

GetCtrlKeyState:
    Push eax
        Call 'USER32.GetKeyState' &VK_CONTROL
        and eax 0FFFF | Mov D$CtrlKeyState eax
    Pop eax
ret


CheckCtrlKeyState:
    Call 'USER32.GetKeyState' &VK_CONTROL | and eax 0_FFFF
    On eax <> D$CtrlKeyState, Mov B$keys+&VK_CONTROL &FALSE
ret
____________________________________________________________________________________________

[SimulatedBlock: D$ ?]

SimulateBlockForBackIndent:
    Push esi
        Mov esi D$STRUCT.EditData@CurrentWritingPos
        While B$esi-1 <> LF | dec esi | End_While
        Mov D$LP.BlockStartText esi

        Mov esi D$STRUCT.EditData@CurrentWritingPos
        While B$esi <> CR | inc esi | End_While | dec esi

        Mov D$LP.BlockEndText esi

        Mov B$OldBlockInside &TRUE, B$SimulatedBlock &TRUE
    Pop esi
ret


[BlockIndent: D$ ?]

IsItBlockIndent:
    Mov B$BlockIndent &FALSE

  ; Verify that the Block includes a start of Line (accept non included Labels):
    Mov esi D$LP.BlockStartText
    While B$esi <> LF
        dec esi
        If B$esi = ':'
            jmp L2>
        Else_If B$esi > SPC
            jmp L9>>
        End_If
    End_While

  ; Verify that the Block is not empty:
L2: Mov esi D$LP.BlockStartText

    While esi < D$LP.BlockEndText

        On B$esi > SPC jmp L2>

        add esi (1*ASCII)

    End_While

    jmp L9>>

  ; Verify that the last selected line is complete (does not stop before CRLF):
L2: Mov esi D$LP.BlockEndText

    While W$esi+1 <> CRLF
        On esi < D$LP.BlockStartText jmp L9>>
        dec esi
    EndWhile

  ; OK, Block holds a full Lines content.  ; 'InsertSource'
  ; Insert or retrieve as many TAB as Lines (but preserve Labels):
L2: On B$keys+&VK_SHIFT = &TRUE, jmp RetrieveBlockIndent

L2: Mov esi D$LP.BlockStartText, B$FirstBlockLine &TRUE

    ..While esi < D$LP.BlockEndText

      ; Go to Start of Line:
        Mov ebx esi | While B$ebx <> LF | dec ebx | End_While
      ; Go to Start of first member, and save in eax:
        While B$ebx <= SPC | inc ebx | End_While
        Mov eax ebx
        .While B$ebx > SPC
            inc ebx
            If B$ebx = ':'
                inc ebx
                While B$ebx <= SPC
                    inc ebx | On B$ebx = CR, jmp L8>>
                End_While
          ; New Start of first memeber if first one was a label:
            Mov eax ebx
            End_If
        .End_While
      ; eax > real first member to move. Adjust Block Start if necessary:
        If B$FirstBlockLine = &TRUE
            Mov D$LP.BlockStartText eax
            Mov B$FirstBlockLine &FALSE
        End_If
        Push eax, D$SourceLen
            Call SetCaret eax | dec D$STRUCT.EditData@CaretRow | Move D$STRUCT.EditData@PhysicalCaretRow D$STRUCT.EditData@CaretRow
            Mov al TAB | Call InsertSourceOnBlockIndent
        Pop ecx, esi
      ; Next Line:
        While B$esi <> CR | inc esi | End_While | inc esi

        Mov eax D$SourceLen | sub eax ecx | add D$LP.BlockEndText eax

    ..End_While

    Mov eax D$LP.BlockStartText
    While B$eax = SPC | inc eax | End_While
    Mov D$LP.BlockStartText eax

    Call SetCaret D$LP.BlockEndText | Mov D$STRUCT.EditData@RightScroll 0

  ; 'KeyMessage'
  ;  Move D$ShiftBlockCol D$CaretRow
  ;  Move D$ShiftBlockLine D$CaretLine
  ;  Move D$PhysicalCaretRow D$CaretRow
  ;  Mov D$CaretEndOfLine &TRUE
  ;  Call KeyMessage

L8: Mov B$BlockIndent &TRUE, D$FL.BlockInside &TRUE
L9: ret


[FirstBlockLine: D$ ?
 NewCaretBlockPos: D$ ?]

RetrieveBlockIndent:
    Mov B$BlockIndent &TRUE, D$NewCaretBlockPos 0
  ; Are there enough free Spaces to be deleted on each Line? If not, abort:
    Mov esi D$LP.BlockStartText

    ..While esi < D$LP.BlockEndText

      ; Go to Start of Line:
        Mov ebx esi | While B$ebx <> LF | dec ebx | End_While
      ; Go to Start of first member, and save in eax:
        While B$ebx <= SPC | inc ebx | End_While
        Mov eax ebx
      ; If Label, jmp over it:
        .While B$ebx > SPC
            inc ebx
            If B$ebx = ':'
                inc ebx
                While B$ebx <= SPC
                    inc ebx | On B$ebx = CR, jmp L8>>
                End_While
              ; New Start of first memeber if first one was a label:
                Mov eax ebx
            End_If
        .End_While

      ; eax > now real first member to move. Are there enough Spaces in front of it?
        Push eax
            Mov ecx D$TabIs
L0:         dec eax
            If B$eax <> SPC
                Pop eax | jmp L8>>
            End_If
            loop L0<
        Pop esi
      ; OK, enough spaces > Next Line:
        While B$esi <> CR | inc esi | End_While | inc esi
    ..End_While

  ; OK, enough Spaces on each Line > Delete:
    Mov esi D$LP.BlockStartText, B$FirstBlockLine &TRUE

    ..While esi < D$LP.BlockEndText

      ; Go to Start of Line:
        Mov ebx esi | While B$ebx <> LF | dec ebx | End_While
      ; Go to Start of first member, and save in eax:
        While B$ebx <= SPC | inc ebx | End_While
        Mov eax ebx
        .While B$ebx > SPC
            inc ebx
            If B$ebx = ':'
                inc ebx
                While B$ebx <= SPC
                    inc ebx | On B$ebx = CR, jmp L8>>
                End_While
              ; New Start of first member if first one was a label:
                Mov eax ebx
            End_If
        .End_While
      ; eax > real first member to Move:
        On D$NewCaretBlockPos = 0, Mov D$NewCaretBlockPos eax

        If B$FirstBlockLine = &TRUE
            Mov D$LP.BlockStartText eax, B$FirstBlockLine &FALSE
        End_If
        Push eax, D$SourceLen
            Call SetCaret eax | sub D$STRUCT.EditData@CaretRow ASCII | Move D$STRUCT.EditData@PhysicalCaretRow D$STRUCT.EditData@CaretRow
            Mov ecx D$TabIs
L0:         Push ecx

                Mov al TAB | Call BackSpace | sub D$LP.BlockEndText (1*ASCII)

            Pop ecx | loop L0<
        Pop ecx, esi
      ; Next Line:
        sub esi D$TabIs
        While B$esi <> CR | inc esi | End_While | inc esi
    ..End_While

    Mov eax D$TabIs | sub D$LP.BlockStartText eax
    Mov eax D$NewCaretBlockPos | sub eax D$TabIs | dec eax | Call SetCaret eax

   ; Move D$ShiftBlockCol D$CaretRow
   ; Move D$ShiftBlockLine D$CaretLine
   ; Move D$PhysicalCaretRow D$CaretRow
   ; Mov D$CaretEndOfLine &FALSE

L8: Mov B$BlockIndent &TRUE, D$FL.BlockInside &TRUE
L9: ret



[ShiftDown: D$ ?
 ShiftBlockCol: D$ ?
 ShiftBlockLine: D$ ?]

[keys: B$ ? # 0100]

[KeyHasModifedSource: D$ ?
 KeyHasMovedCaret: D$ ?
 FL.SourceHasChanged: D$ ?]

KeyMessage:
    On D$FL.SourceReady = &FALSE, ret

    Mov B$KeyHasModifedSource &FALSE, B$KeyHasMovedCaret &FALSE

    ..If D$FL.BlockInside = &TRUE
        .If B$ShiftBlockInside = &TRUE
            If B$keys+&VK_SHIFT = &TRUE
                Move D$STRUCT.EditData@CaretRow D$ShiftBlockCol
                Move D$STRUCT.EditData@CaretLine D$ShiftBlockLine
                Move D$STRUCT.EditData@PhysicalCaretRow D$STRUCT.EditData@CaretRow
                Mov D$STRUCT.EditData@CaretEndOfLine &FALSE
            End_If
        .Else
            Mov D$ShiftDown 0
        .End_If
    ..End_If

  ; Under some configurations, it appears that [Atl-Gr] (Right [Alt]), may generate
  ; a Key Down Message not followed by a Key Up message, for the Control Key... So:
    ...If B$keys+&VK_MENU = &TRUE
        Mov B$keys+&VK_MENU &FALSE, B$keys+&VK_CONTROL &FALSE

    ...Else_If B$keys+&VK_CONTROL = &TRUE
        .If B$keys+&VK_PGDN = &TRUE
            Call FullDown | Mov D$FL.BlockInside &FALSE
            Mov B$KeyHasMovedCaret &TRUE
            If B$keys+&VK_SHIFT = &TRUE
                Call AskForRedrawNow | jmp L1>>
            End_If

            On B$ShiftBlockInside = &TRUE, Mov D$FL.BlockInside &FALSE, B$ShiftBlockInside &FALSE

        .Else_If B$keys+&VK_PGUP = &TRUE
            Call FullUp | Mov D$FL.BlockInside &FALSE
            Mov B$KeyHasMovedCaret &TRUE
            If B$keys+&VK_SHIFT = &TRUE
                Call AskForRedrawNow | jmp L1>>
            End_If

            On B$ShiftBlockInside = &TRUE, Mov D$FL.BlockInside &FALSE, B$ShiftBlockInside &FALSE

        .Else_If B$keys+&VK_LEFT = &TRUE
            Call StartOfWord | Mov B$KeyHasMovedCaret &TRUE
            If B$keys+&VK_SHIFT = &TRUE
                Call AskForRedrawNow | jmp L1>>
            End_If

            On B$ShiftBlockInside = &TRUE, Mov D$FL.BlockInside &FALSE, B$ShiftBlockInside &FALSE
            Mov B$keys+&VK_LEFT &FALSE

        .Else_If B$keys+&VK_RIGHT = &TRUE
            Call EndOfWord | Mov B$KeyHasMovedCaret &TRUE
            If B$keys+&VK_SHIFT = &TRUE
                Call AskForRedrawNow | jmp L1>>
            End_If

            On B$ShiftBlockInside = &TRUE, Mov D$FL.BlockInside &FALSE, B$ShiftBlockInside &FALSE
            Mov B$keys+&VK_RIGHT &FALSE

        .Else_If B$keys+&VK_DOWN = &TRUE
            Call DownOneLine | Mov B$KeyHasMovedCaret &TRUE
            If B$keys+&VK_SHIFT = &TRUE
                Call AskForRedrawNow | jmp L1>>
            End_If

            On B$ShiftBlockInside = &TRUE, Mov D$FL.BlockInside &FALSE, B$ShiftBlockInside &FALSE
            Mov B$keys+&VK_DOWN &FALSE

        .Else_If B$keys+&VK_UP = &TRUE
            Call UpOneLine | Mov B$KeyHasMovedCaret &TRUE
            If B$keys+&VK_SHIFT = &TRUE
                Call AskForRedrawNow | jmp L1>>
            End_If

            On B$ShiftBlockInside = &TRUE, Mov D$FL.BlockInside &FALSE, B$ShiftBlockInside &FALSE
            Mov B$keys+&VK_UP &FALSE

        .Else_If B$keys+&VK_DELETE = &TRUE
            On D$H.DebugDialog <> 0, ret
            Call ControlD | Mov B$keys+&VK_DELETE &FALSE, B$KeyHasModifedSource &TRUE

        .Else_If B$keys+&VK_INSERT = &TRUE
            On D$H.DebugDialog <> 0, ret
            Call ControlC | Mov B$keys+&VK_INSERT &FALSE, B$KeyHasModifedSource &TRUE

        .Else_If B$keys+&VK_BACK = &TRUE
            On D$H.DebugDialog <> 0, ret
            Call ControlX | Mov B$keys+&VK_BACK &FALSE, B$KeyHasModifedSource &TRUE
            Mov D$FL.Redraw &TRUE
          ; This 'FL.Redraw' is to kill the next coming WM_CHAR holding
          ; ([Ctrl][Back] sends a char).

        .Else_If B$keys+&VK_F4 = &TRUE
            Call RestoreRealSource
                Call SetCaret D$STRUCT.EditData@CurrentWritingPos
                Mov eax 0, ebx D$STRUCT.EditData@CaretLine | Call MarginAction
            Call SetPartialEditionFromPos
            Mov B$keys+&VK_F4 0

        .Else
            On B$keys+&VK_SHIFT = &TRUE, jmp L1>

        .End_If



    ...Else_If B$keys+&VK_SHIFT = &TRUE
L1:     .If B$keys+&VK_LEFT = &TRUE
            Call SetPhysicalCaretRow
            On B$keys+&VK_CONTROL = &FALSE, Call KeyLeft
            If D$ShiftDown <> 0
                Call SetShiftBlock
            Else
                Mov D$FL.BlockInside &FALSE
            End_If
            Mov B$KeyHasMovedCaret &TRUE
            Move D$STRUCT.EditData@PhysicalCaretRow D$STRUCT.EditData@CaretRow

        .Else_If B$keys+&VK_RIGHT = &TRUE
            On B$keys+&VK_CONTROL = &FALSE, Call KeyRight
            If D$ShiftDown <> 0
                Call SetShiftBlock
            Else
                Mov D$FL.BlockInside &FALSE
            End_If
            Mov B$KeyHasMovedCaret &TRUE

        .Else_If B$keys+&VK_UP = &TRUE
            On B$keys+&VK_CONTROL = &FALSE, Call KeyUp
            If D$ShiftDown <> 0
                Call SetShiftBlock
            Else
                Mov D$FL.BlockInside &FALSE
            End_If
            Mov B$KeyHasMovedCaret &TRUE

        .Else_If B$keys+&VK_DOWN = &TRUE
            On B$keys+&VK_CONTROL = &FALSE, Call KeyDown
            If D$ShiftDown <> 0
                Call SetShiftBlock
            Else
                Mov D$FL.BlockInside &FALSE
            End_If
            Mov B$KeyHasMovedCaret &TRUE

        .Else_If B$keys+&VK_PGUP = &TRUE
            On B$keys+&VK_CONTROL = &FALSE, Call OnlyOnePageUp
            If D$ShiftDown <> 0
                Call SetShiftBlock
            Else
                Mov D$FL.BlockInside &FALSE
            End_If
            Mov B$KeyHasMovedCaret &TRUE

        .Else_If B$keys+&VK_PGDN = &TRUE
            On B$keys+&VK_CONTROL = &FALSE, Call OnlyOnePageDown
            If D$ShiftDown <> 0
                Call SetShiftBlock
            Else
                Mov D$FL.BlockInside &FALSE
            End_If
            Mov B$KeyHasMovedCaret &TRUE

        .Else_If B$keys+&VK_HOME = &TRUE
            Call StartOfLine
            If D$ShiftDown <> 0
                Call SetShiftBlock
            Else
                Mov D$FL.BlockInside &FALSE
            End_If
            Mov B$KeyHasMovedCaret &TRUE

        .Else_If B$keys+&VK_END = &TRUE
            Call EndOfLine
            If D$ShiftDown <> 0
                Call SetShiftBlock
            Else
                Mov D$FL.BlockInside &FALSE
            End_If
            Mov B$KeyHasMovedCaret &TRUE

        .Else_If B$keys+&VK_INSERT = &TRUE
            On D$H.DebugDialog <> 0, ret
            Call ControlV | Mov B$keys+&VK_INSERT &FALSE, B$KeyHasModifedSource &TRUE

        .Else_If B$keys+&VK_DELETE = &TRUE
            On D$H.DebugDialog <> 0, ret
            Call ControlX | Mov B$keys+&VK_DELETE &FALSE, B$KeyHasModifedSource &TRUE

        .Else_If B$keys+&VK_F4 = &TRUE
            Call RestoreRealSource
                Call SetCaret D$STRUCT.EditData@CurrentWritingPos
                Mov eax 0, ebx D$STRUCT.EditData@CaretLine | Call MarginAction
            Call SetPartialEditionFromPos
            Mov B$keys+&VK_F4 0

        .Else
            If D$FL.BlockInside = &FALSE
                Move D$ShiftDown D$STRUCT.EditData@CurrentWritingPos | ret
           ; Else
           ;     Mov D$FL.BlockInside &FALSE | Call AskForRedraw | ret
            End_If

        .End_If

    ...Else
        ..If eax = &VK_PGDN
            Call OnlyOnePageDown | Mov D$FL.BlockInside &FALSE

        ..Else_If eax = &VK_PGUP
            Call OnlyOnePageUp | Mov D$FL.BlockInside &FALSE

        ..Else_If eax = &VK_DOWN
            If D$H.CompletionList <> 0
                Mov B$Keys+eax 0
                Call ToCompletionList &VK_DOWN
              ; To save from downward 'KeyHasMovedCaret' Flag modification:
                ret
            Else
                Call KeyDown | Mov D$FL.BlockInside &FALSE
            End_If

        ..Else_If eax = &VK_UP
            If D$H.CompletionList <> 0
                Mov B$Keys+eax 0
                Call ToCompletionList &VK_UP
              ; To save from downward 'KeyHasMovedCaret' Flag modification:
                ret
            Else
                Call KeyUp | Mov D$FL.BlockInside &FALSE
            End_If

        ..Else_If eax = &VK_LEFT
            Call KeyLeft | Mov D$FL.BlockInside &FALSE

        ..Else_If eax = &VK_RIGHT
            Call KeyRight | Mov D$FL.BlockInside &FALSE

        ..Else_If eax = &VK_INSERT
            Call KeyInsert | Mov D$FL.BlockInside &FALSE

        ..Else_If eax = &VK_DELETE
            .If D$H.DebugDialog <> 0
                Mov B$Keys+eax 0
                Call CloseDebuggerOrIgnore | On eax = &IDNO ret
            .End_If
            Call KeyDelete | Mov D$FL.BlockInside &FALSE, B$KeyHasModifedSource &TRUE

        ..Else_If eax = &VK_END
            Call EndOfLine | Mov D$FL.BlockInside &FALSE

        ..Else_If eax = &VK_HOME
            Call StartOfLine | Mov D$FL.BlockInside &FALSE

        ..Else_If eax = &VK_ESCAPE
            If D$H.CompletionList <> 0
                Call 'USER32.SendMessageA' D$H.CompletionList, &WM_COMMAND, &IDCANCEL, 0
                Mov B$keys+&VK_ESCAPE &FALSE | ret
            End_If

        ..Else_If eax = &VK_F1
            Call BUAsmHelp | Mov B$keys+&VK_F1 &FALSE

        ..Else_If eax = &VK_F2
            Call F2Help | Mov B$keys+&VK_F2 &FALSE

        ..Else_If eax = &VK_F3
            Call RestoreRealSource | Call StringSearch | Call SetPartialEditionFromPos
            Mov B$keys+&VK_F3 0

        ..Else_If eax = &VK_F4  ; BpMenu / SetBreakPoint / DeleteBreakpoint
            Call RestoreRealSource
                Call SetCaret D$STRUCT.EditData@CurrentWritingPos
                Mov eax 0, ebx D$STRUCT.EditData@CaretLine | Call MarginAction
            Call SetPartialEditionFromPos
            Mov B$keys+&VK_F4 0

        ..Else_If eax = &VK_F5
            Mov B$keys+&VK_F5 &FALSE
            Mov D$FL.ShowStats &TRUE
            Call Compile

        ..Else_If eax = &VK_F6
            Mov B$keys+&VK_F6 &FALSE

            If D$H.DebugDialog <> 0
                ret
            Else
                Call Run
            End_If

        ..Else_If eax = &VK_F8
            If D$H.DebugDialog <> 0
                Mov B$keys+&VK_F2 &FALSE
                Call CloseDebuggerOrIgnore | On eax = &IDNO ret
            End_If
            Call DrawOneLine

        ..Else_If eax = &VK_F9
            Mov B$Keys+eax 0
            ;Mov eax D$BreakPointsTables | int3
            ret
;;
; Problem if someone want to implement a Key doinf the same job as Right-Click:
; How to get back after Editor moves?

            Call KillCompletionList
  
            Call RowToX D$CaretRow | Mov D$MousePosY eax
            Call LineToY D$CaretLine | Mov D$MousePosY eax
            Call 'USER32.SetCursorPos' D$MousePosX, D$MousePosY

            Call RestoreRealSource
                Call RightClick
            Call SetPartialEditionFromPos
            Mov B$keys+&VK_F9 &FALSE
;;
        ..Else_If eax = &VK_F11
            Call SavePosOnF11

        ..Else_If eax = &VK_F12
            Call SetPosOnF12

        ..Else
            Mov B$Keys+eax 0 | ret

        ..End_If
      ; Necessity for clearing by hand because, with lengthy case (like upper 'StringSearch'),
      ; the OS clear the remaining Messages (here WM_KEYUP!!!) for the Message Flow.
       ; Pop eax | Mov B$Keys+eax 0
        Mov B$KeyHasMovedCaret &TRUE

    ...End_If


    On B$KeyHasMovedCaret = &TRUE, Call KillCompletionList
ret
____________________________________________________________________________________________

ResetKeys:
    Mov edi keys, eax 0, ecx (0100/4) | rep stosd
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

EnableMenutems:
   ; Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Profile, &MF_GRAYED

    .If D$FL.SourceReady = &FALSE
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Tree, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Paste_at_Pos, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Change_Compile_Name, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Replace_Source_Only, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_Source_Only, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Output, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Print, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Find, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Replace, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Replace, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Undo, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Redo, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Copy, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Paste, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Cut, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Compile, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Run, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Import, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Export, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_GUIDs, &MF_GRAYED

    .Else
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Tree, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Paste_at_Pos, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Change_Compile_Name, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Replace_Source_Only, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_Source_Only, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Output, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Print, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Find, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Replace, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Replace, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Undo, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Redo, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Copy, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Paste, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Cut, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Compile, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Run, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Import, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Export, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_GUIDs, &MF_ENABLED

    .End_If

    If D$SavingExtension = '.SYS'
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Run, &MF_GRAYED
    Else_If D$FL.SourceReady = &TRUE
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Run, &MF_ENABLED
    End_If

    If D$IconList = 0
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_Icon, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Icon_IDs, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_Icon, &MF_GRAYED
    Else
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_Icon, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Icon_IDs, &MF_GRAYED ; &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_Icon, &MF_GRAYED ;&MF_ENABLED
    End_If

    If D$BitMapList = 0
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_BitMap, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_BitMaps_IDs, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_BitMap, &MF_GRAYED
    Else
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_BitMap, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_BitMaps_IDs, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_BitMap, &MF_GRAYED ;&MF_ENABLED
    End_If

    If D$CursorList = 0
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_Cursor, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Cursors_IDs, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_Cursor, &MF_GRAYED
    Else
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_Cursor, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Cursors_IDs, &MF_GRAYED ;&MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_Cursor, &MF_GRAYED ;&MF_ENABLED
    End_If

    If D$WaveList = 0
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_Wave, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Waves_IDs, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_Wave, &MF_GRAYED
    Else
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_Wave, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Waves_IDs, &MF_GRAYED ;&MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_Wave, &MF_GRAYED ;&MF_ENABLED
    End_If

    If D$AviList = 0
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_Avi, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Avi_IDs, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_Avi, &MF_GRAYED
    Else
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_Avi, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Avi_IDs, &MF_GRAYED ;&MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_Avi, &MF_GRAYED ;&MF_ENABLED
    End_If

    If D$RCDataList = 0
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_RC, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_RCs_IDs, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_RC, &MF_GRAYED
    Else
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_RC, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_RCs_IDs, &MF_GRAYED ;&MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_RC, &MF_ENABLED
    End_If

    If D$DialogList = 0
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Load_from_Resources, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_Resources_Dialog, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_to_Binary_File, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Replace_from_Binary_File, &MF_GRAYED
    Else
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Load_from_Resources, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_Resources_Dialog, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_to_Binary_File, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Replace_from_Binary_File, &MF_ENABLED
    End_If

    If D$FL.SourceReady = &FALSE
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Load_from_Binary_File, &MF_GRAYED
    Else
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Load_from_Binary_File, &MF_ENABLED
    End_If

    If D$MenuList = 0
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Existing_Menu, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_a_Menu, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_to_Binary_Menu_File, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Load_Binary_Menu_File, &MF_GRAYED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Replace_from_Binary_Menu_File, &MF_GRAYED
    Else
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Existing_Menu, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Delete_a_Menu, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Save_to_Binary_Menu_File, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Load_Binary_Menu_File, &MF_ENABLED
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Replace_from_Binary_Menu_File, &MF_ENABLED
    End_If

    Call 'USER32.DrawMenuBar' D$H.MainWindow

ret


[H.VisualTutsFind: D$ ?
 H.VisualTutsMenu: D$ ?
 VisualTutMenuID: D$ ?]
[VisualTutsItem: B$ 'Visual Tuts' EOS]
[VisualTutPath: B$ ? # &MAX_PATH]
[WizardPath: B$ ? # &MAX_PATH]


EnableHelpMenutems:
    Call EnableHelpMenutem B_U_AsmName, M00_B_U_Asm
    Call EnableHelpMenutem Win32HlpName, M00_Win32_hlp
    Call EnableHelpMenutem MmediaHlpName, M00_Mmedia_hlp
    Call EnableHelpMenutem OpenGlHlpName, M00_OpenGl_hlp
    Call EnableHelpMenutem DxHlpName, M00_Dx_hlp
    Call EnableHelpMenutem WinsockHlpName, M00_WinSock_hlp
    Call EnableHelpMenutem SDLRefName, M00_SDL
    Call EnableHelpMenutem sqliteName, M00_sqlite
    Call EnableHelpMenutem DevILName, M00_DevIL
ret


[PreviousIVT: D$ ?]
[IVTFilesNames1 Trash1]
[IVTFilesNames2 Trash2]

EnableVisualTutsMenu:
  ; Enable the 'Visual Tuts' Item and create the Pop-Up if some Visual Tuts are there:
    Mov esi EquatesName, edi VisualTutPath, ecx (&MAX_PATH/DWORD) | rep movsd

    Mov esi VisualTutPath | While B$esi <> 0 | inc esi | End_While
    While B$esi <> '\' | dec esi | End_While
    Mov D$esi+1 'IVT*', D$esi+5 '.exe', B$esi+9 0

    Call 'KERNEL32.FindFirstFileA' VisualTutPath, STRUC.FindFile

    .If eax = &INVALID_HANDLE_VALUE
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Visual_Tuts, &MF_GRAYED

    .Else
        Mov D$H.VisualTutsFind eax

        Call 'USER32.CreatePopupMenu' | Mov D$H.VisualTutsMenu eax

        Mov edi IVTFilesNames1, ecx 0

L1:     Mov esi STRUC.FindFile@cFileName | inc ecx

        While B$esi <> 0 | movsb | End_While | Mov B$edi 0 | inc edi

        Push ecx
            Call 'KERNEL32.FindNextFileA' D$H.VisualTutsFind, STRUC.FindFile
        Pop ecx

        On eax = &TRUE, jmp L1<

        Call zStringsSort IVTFilesNames1, IVTFilesNames2, ecx
        ____________________________________________________

        Mov B$PreviousIVT '0', D$VisualTutMenuID 5000

        Call 'USER32.CreatePopupMenu' | Mov D$H.VisualTutsMenu eax

        Mov esi IVTFilesNames2

L1:     add esi 6

        Push esi
            Mov al B$esi-3
            If al <> B$PreviousIVT
                Mov B$PreviousIVT al
                Call 'USER32.AppendMenuA' D$H.VisualTutsMenu, &MF_SEPARATOR, 0, 0
            End_If

            Call 'USER32.AppendMenuA' D$H.VisualTutsMenu, &MF_ENABLED__&MF_STRING,
                                      D$VisualTutMenuID, esi
        Pop esi

        While B$esi <> 0 | inc esi | End_While | inc esi

        If B$esi <> 0
            inc D$VisualTutMenuID | jmp L1<
        End_If

        Call 'USER32.InsertMenuA' D$H.MenuMain, M00_Visual_Tuts,
                                  &MF_BYCOMMAND__&MF_POPUP__&MF_STRING,
                                  D$H.VisualTutsMenu, VisualTutsItem

        Call 'USER32.DeleteMenu' D$H.MenuMain, M00_Visual_Tuts, &MF_BYCOMMAND

        Call 'KERNEL32.FindClose' D$H.VisualTutsFind
    .End_If
ret


VisualTuts:
    Push eax
        .If D$H.DebugDialog <> 0
            Call CloseDebuggerOrIgnore
            If eax = &IDNO
                Pop eax | ret
            End_If
        .End_If

        ...If D$FL.SourceReady = &TRUE
            ..If D$FL.ReadyToRun = &FALSE
                .If D$FL.SecurityWanted = &TRUE
                    Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'Close the Actual File ?' EOS},
                                              {B$ 'Visual Tutorial' EOS}, &MB_YESNO
                    If eax = &IDNO
                        Pop eax | ret
                    End_If
                .End_If
            ..End_If
        ...End_If
    Pop eax

    Mov esi VisualTutPath | While D$esi <> '\IVT' | inc esi | End_While
    add esi 4 | Mov D$esi '???' | add esi 3
    Call 'USER32.GetMenuStringA' D$H.MenuMain, eax, esi, 100, &MF_BYCOMMAND

    Call 'KERNEL32.FindFirstFileA' VisualTutPath, STRUC.FindFile

    .If eax <> &INVALID_HANDLE_VALUE
        Mov D$H.VisualTutsFind eax
        Call 'KERNEL32.FindClose' D$H.VisualTutsFind

        Mov esi VisualTutPath, edi SaveFilter
        While D$esi <> '\IVT' | movsb | End_While | movsb
        Mov esi STRUC.FindFile@cFileName | While B$esi <> 0 | movsb | End_While | movsb

        Call DirectLoad

        Call ReInitUndo
        Call SetPartialEditionFromPos | Call EnableMenutems
        Call LoadBookMarks
    .End_If
ret


Proc EnableHelpMenutem:
    Argument @FileName, @Item

    Call 'KERNEL32.FindFirstFileA' D@FileName, STRUC.FindFile
    Push eax
        If eax = &INVALID_HANDLE_VALUE
            Mov eax &MF_GRAYED
        Else
            Mov eax &MF_ENABLED
        End_If

        Call 'USER32.EnableMenuItem' D$H.MenuMain, D@Item, eax
    Pop eax
    Call 'KERNEL32.FindClose' eax
EndP
____________________________________________________________________________________________

[H.WizardsFind: D$ ?
 H.WizardsMenu: D$ ?
 WizardMenuID: D$ ?]

[PreviousWZRD: D$ ?]

[WizardsItem: B$ 'Wizards' EOS]

EnableWizardsMenu:

    Call ClearTrashTables

  ; Enable the 'Visual Tuts' Item and create the Pop-Up if some Visual Tuts are there:
    Mov esi EquatesName, edi WizardPath, ecx (&MAX_PATH/DWORD) | rep movsd

    Mov esi WizardPath | While B$esi <> 0 | inc esi | End_While
    While B$esi <> '\' | dec esi | End_While

    Mov D$esi+1 'WZRD', D$esi+5 '*.*'

    Call 'KERNEL32.FindFirstFileA' WizardPath, STRUC.FindFile

    .If eax = &INVALID_HANDLE_VALUE
        Call 'USER32.EnableMenuItem' D$H.MenuMain, M00_Wizards, &MF_GRAYED

    .Else
        Mov D$H.WizardsFind eax

        Call 'USER32.CreatePopupMenu' | Mov D$H.WizardsMenu eax

        Mov edi Trash1, ecx 0

L1:     Mov esi STRUC.FindFile@cFileName | inc ecx

        While B$esi <> 0 | movsb | End_While | Mov B$edi 0 | inc edi

        Push ecx
            Call 'KERNEL32.FindNextFileA' D$H.WizardsFind, STRUC.FindFile
        Pop ecx

        On eax = &TRUE, jmp L1<

        Call zStringsSort Trash1, Trash2, ecx

        ____________________________________________________

        Mov B$PreviousWZRD '0', D$WizardMenuID 6000

        Call 'USER32.CreatePopupMenu' | Mov D$H.WizardsMenu eax

        Mov esi Trash2

L1:     add esi 4

        Push esi
           ; Mov al B$esi-3
           ; If al <> B$PreviousWZRD
           ;     Mov B$PreviousWZRD al
           ;     Call 'USER32.AppendMenuA' D$H.VisualTutsMenu, &MF_SEPARATOR, 0, 0
           ; End_If

            Call 'USER32.AppendMenuA' D$H.WizardsMenu, &MF_ENABLED__&MF_STRING,
                                      D$WizardMenuID, esi
        Pop esi

        While B$esi <> 0 | inc esi | End_While | inc esi

        If B$esi <> 0
            inc D$VisualTutMenuID | jmp L1<
        End_If

        Call 'USER32.InsertMenuA' D$H.MenuMain, M00_Wizards,
                                  &MF_BYCOMMAND__&MF_POPUP__&MF_STRING,
                                  D$H.WizardsMenu, WizardsItem

        Call 'USER32.DeleteMenu' D$H.MenuMain, M00_Wizards, &MF_BYCOMMAND

        Call 'KERNEL32.FindClose' D$H.WizardsFind
    .End_If
ret
____________________________________________________________________________________________

[ClipMenuID: 7000    NumberOfClipFiles: 0]

[H.FindClipFiles: D$ ?
 H.ClipFilePopUpMenu: D$ ?]

[ClipFilesPath: B$ ? # &MAX_PATH]

[ClipFilesItem: B$ 'Clip Files' EOS]

; Room for storing 20 Clip Files Names of 20 Chars each:

[ClipMenuStrings: D$ ? # 100]

Proc StoreClipMenuStrings:
    Argument @Source
    uses esi, edi

        Mov edi ClipMenuStrings
L1:     While B$edi <> 0 | inc edi | End_While
        If edi <> ClipMenuStrings
            inc edi | On B$edi <> 0, jmp L1<
        End_If
        Mov esi D@Source
        While B$esi <> 0 | movsb | End_While
EndP


EnableClipMenu: ; M00_Clip_File / 'LoadClipFile'
    Call 'KERNEL32.FindFirstFileA' ClipName, STRUC.FindFile
;;
  Assuming Multiple Clip Files had never been planed, and the whole implementation
  is supposed to work withnone single 'Clip.txt', which Path is given in 'ClipName',
  from the Configuration.
  
  So, if no Clip File found, we simple leave, and let the default way:
;;
    ...If eax = &INVALID_HANDLE_VALUE
        jmp L9>>

    ...Else
        Call 'KERNEL32.FindClose' eax

        Mov esi ClipName, edi ClipFilesPath
        While B$esi <> 0 | movsb | End_While
        While B$edi <> '\' | dec edi | End_While | inc edi
        Mov D$edi '*Cli', D$edi+4 'p.tx', W$edi+8 't'

        Call 'KERNEL32.FindFirstFileA' ClipFilesPath, STRUC.FindFile

        ..If eax = &INVALID_HANDLE_VALUE
            jmp L9>>

        ..Else
            Mov D$H.FindClipFiles eax

L1:         If D$H.ClipFilePopUpMenu = 0
                Call 'USER32.CreatePopupMenu' | Mov D$H.ClipFilePopUpMenu eax
            End_If

            inc D$NumberOfClipFiles

            Call 'USER32.AppendMenuA' D$H.ClipFilePopUpMenu,
                                      &MF_ENABLED__&MF_STRING,
                                      D$ClipMenuID, STRUC.FindFile@cFileName

            Call StoreClipMenuStrings STRUC.FindFile@cFileName

            inc D$ClipMenuID

            Call 'KERNEL32.FindNextFileA' D$H.FindClipFiles, STRUC.FindFile
            On eax = &TRUE, jmp L1<<

            Call 'KERNEL32.FindClose' D$H.FindClipFiles

            .If D$H.ClipFilePopUpMenu <> 0
                If D$NumberOfClipFiles > 1
                    Call 'USER32.InsertMenuA' D$H.MenuMain, M00_ClipFile,
                                              &MF_BYCOMMAND__&MF_POPUP__&MF_STRING,
                                              D$H.ClipFilePopUpMenu, ClipFilesItem

                    Call 'USER32.DeleteMenu' D$H.MenuMain, M00_ClipFile, &MF_BYCOMMAND
                End_If
            .End_If

        ..End_If

    ...End_If
L9: ret
____________________________________________________________________________________________


SetShiftBlock:
    Mov eax D$STRUCT.EditData@CaretRow, ebx D$STRUCT.EditData@CaretLine
    Push eax, ebx

        Call SearchTxtPtr               ; >>> eax = new Pos.

        .If D$FL.BlockInside = &FALSE
            If eax > D$ShiftDown
                dec eax
            End_If

        .Else
            If eax = D$ShiftDown
                Mov D$FL.BlockInside &FALSE | jmp L9>
            Else_If eax > D$ShiftDown
                dec eax
            End_If

        .End_If

        If eax < D$ShiftDown

            Mov D$LP.BlockStartText eax

            Move D$LP.BlockEndText D$ShiftDown

            sub D$LP.BlockEndText (1*ASCII)

        Else

            Move D$LP.BlockStartText D$ShiftDown

            Mov D$LP.BlockEndText eax

        End_If

        Mov D$FL.BlockInside &TRUE, B$ShiftBlockInside &TRUE

L9: Pop D$ShiftBlockLine, D$ShiftBlockCol
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  BackUps.
;;

____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE MRU             ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;                            Most Recently Used Files job.
____________________________________________________________________________________________
____________________________________________________________________________________________

[STR.A.MRU1: B$ ? # &MAX_PATH]
[STR.A.MRU2: B$ ? # &MAX_PATH]
[STR.A.MRU3: B$ ? # &MAX_PATH]
[STR.A.MRU4: B$ ? # &MAX_PATH]

[MRU1   3001
 MRU2   3002
 MRU3   3003
 MRU4   3004]

; Adds the menu Items in [File] Popup, between [OutPut] and [Exit]:

[H.FilePopUp: D$ ?
 AddedMRUitems: D$ ?]

SetMRUmenu:

    Call DeleteMRUmenu

    Test D$STR.A.MRU1 NA ZERO S1>

        Call 'USER32.InsertMenuA' D$H.FilePopUp,
                                  M00_Exit,
                                  &MF_BYCOMMAND,
                                  MRU1,
                                  STR.A.MRU1
        add D$AddedMRUitems 1

S1: Test D$STR.A.MRU2 NA ZERO S1>

        Call 'USER32.InsertMenuA' D$H.FilePopUp,
                                  M00_Exit,
                                  &MF_BYCOMMAND,
                                  MRU2,
                                  STR.A.MRU2

        add D$AddedMRUitems 1

S1: Test D$STR.A.MRU3 NA ZERO S1>

        Call 'USER32.InsertMenuA' D$H.FilePopUp,
                                  M00_Exit,
                                  &MF_BYCOMMAND,
                                  MRU3,
                                  STR.A.MRU3

        add D$AddedMRUitems 1

S1: Test D$STR.A.MRU4 NA ZERO S1>

        Call 'USER32.InsertMenuA' D$H.FilePopUp,
                                  M00_Exit,
                                  &MF_BYCOMMAND,
                                  MRU4,
                                  STR.A.MRU4

        add D$AddedMRUitems 1

  ; Separator:
S1: Test D$STR.A.MRU1 NA ZERO S0>

        Call 'USER32.InsertMenuA' D$H.FilePopUp,
                                  M00_Exit,
                                  &MF_BYCOMMAND+&MF_SEPARATOR,
                                  &NULL,
                                  &NULL

        add D$AddedMRUitems 1

S0:
ret


DeleteMRUmenu:

    Call 'USER32.GetSubMenu' D$H.MenuMain,
                             0

    Mov D$H.FilePopUp eax

    While D$AddedMRUitems > 0

        Call 'USER32.DeleteMenu' D$H.FilePopUp,
                                 16,
                                 &MF_BYPOSITION

        sub D$AddedMRUitems 1

    End_While

ret


; Push down (out) one MRU record to make leading room for a new File:

PushOneMRUrecordDown:

    Mov esi STR.A.MRU3,
        edi STR.A.MRU4,
        ecx (&MAX_PATH*3)

    add esi (&MAX_PATH-1) | add edi (&MAX_PATH-1)

    std | rep movsb | cld

ret

;;
 
    The recently saved file was already in the MRU list, but not in first Pos. We
    reorganise the List. Before calling, 'RecordMRU' Routine set esi to 'DestinationFile'
    and edi to STR.A.MRU1/2/... We reuse 'DestinationFile', just in case the Name Cases would
    have been changed by user in between. So, at first, we arase the old record (this
    let room in first Pos). I do not use directely 'DestinationFile', but edi, instead,
    in case this function would be extended in the futur

;;
RePosMRU:

    Push esi,
         edi

        ; First arase the record at edi:
        std

            Mov esi edi | add edi (&MAX_PATH-1) | dec esi

            Mov ecx esi | sub ecx STR.A.MRU1

            rep movsb

        cld

    Pop edi,
        esi

    ; then write new record at first Pos:
    Mov edi STR.A.MRU1,
            ecx (&MAX_PATH/DWORD)

    rep movsd

ret

;;

    Adding a new File in the MRU List if it is not already inside, or update the range
    if already there. The file is the last compiled one ('DestinationFile')

;;
RecordMRU:

    Mov esi DestinationFile | Call CheckMRUFile

    Mov ecx DestinationFile | While B$ecx <> EOS | add ecx ASCII | End_While

    sub ecx DestinationFile

    Mov esi DestinationFile

    Push esi,
         ecx

        Mov edi STR.A.MRU1 | repe cmpsb | je S0>

S1: Pop ecx,
        esi

    Push esi,
         ecx

        Mov edi STR.A.MRU2 | repe cmpsb | jne S1>

        Mov edi STR.A.MRU2 | jmp S2>

S1: Pop ecx,
        esi

    Push esi,
         ecx

        Mov edi STR.A.MRU3 | repe cmpsb | jne S1>

        Mov edi STR.A.MRU3 | jmp S2>

S1: Pop ecx,
        esi

    Push esi,
         ecx

        Mov edi STR.A.MRU4 | repe cmpsb | jne S1>

        Mov edi STR.A.MRU4 | jmp S2>

    ; If here, it is a new file name:
S1: Pop ecx,
        esi

    Call PushOneMRUrecordDown

    Mov esi DestinationFile,
        edi STR.A.MRU1, ecx 260

    rep movsb | Call SetMRUmenu

ret

    ; If here, the File is already Listed, but not at first Pos:
S2: Pop ecx,
        esi

    Call RePosMRU | Call SetMRUmenu

ret

    ; If here, the File is already Listed at first Pos >>> OK, exit:
S0: Pop ecx, esi

ret


; Arase one record if the File do not exist (example, if user deleted the file):

[CheckMRUpointer: D$ ?]

CheckMRUFile:

    Mov D$CheckMRUpointer esi

    Call 'KERNEL32.FindFirstFileA' esi,
                                   STRUC.FindFile

    Push eax

        If eax = &INVALID_HANDLE_VALUE

            Mov eax 0,
                esi D$CheckMRUpointer,
                edi esi

            add esi &MAX_PATH

            Mov ecx STR.A.MRU4 | sub ecx edi

            jecxz S1>

                rep movsb

S1:         Mov ecx (&MAX_PATH/DWORD)

            rep stosd

        Else                                           ; All this is only to retrieve

            Mov edi D$CheckMRUpointer                   ; the Name case (upper/lower),

            Mov al 0,
                ecx NA

            repne scasb | sub edi ASCII  ; in case the user modified it

            Mov esi STRUC.FindFile@cFileName,
                ecx 0           ; since last session.

            While B$esi <> EOS

                add ecx 1 | add esi ASCII

            End_While

            sub edi ecx

            Mov esi STRUC.FindFile@cFileName | rep movsb

        End_If

    Pop eax

    On eax <> &INVALID_HANDLE_VALUE Call 'KERNEL32.FindClose' eax

ret


CheckAllMRUFile:

    Mov esi STR.A.MRU1 | Call CheckMRUFile

    Mov esi STR.A.MRU2 | Call CheckMRUFile

    Mov esi STR.A.MRU3 | Call CheckMRUFile

    Mov esi STR.A.MRU4 | Call CheckMRUFile

ret


[MRUfileHasBeenDeleted: B$ 'This file has been deleted or renamed' EOS]

[SelectedMRUFileName: B$ ? # &MAX_PATH]

; Called from Main Message Loop with Menu ID in eax.

LoadRMUfile:

    Push eax

        If eax = MRU1

            Mov esi STR.A.MRU1

        Else_If eax = MRU2

            Mov esi STR.A.MRU2

        Else_If eax = MRU3

            Mov esi STR.A.MRU3

        Else_If eax = MRU4

            Mov esi STR.A.MRU4

        End_If

        Mov edi SelectedMRUFileName,
            ecx (&MAX_PATH/DWORD)

        rep movsd

        Call CheckAllMRUFile | Call SetMRUmenu

        Call ReInitUndo

    Pop eax

    If eax = MRU1

        Mov esi STR.A.MRU1

    Else_If eax = MRU2

        Mov esi STR.A.MRU2

    Else_If eax = MRU3

        Mov esi STR.A.MRU3

    Else_If eax = MRU4

        Mov esi STR.A.MRU4

    End_If

    Push esi

        Mov edi SelectedMRUFileName,
            ecx (&MAX_PATH/DWORD)

        rep cmpsd | jmpIf = S1>

    Pop esi

    Call MessageBox MRUfileHasBeenDeleted

    Mov eax &FALSE

ret

S1: Pop esi

    Mov edi SaveFilter,
        ecx (&MAX_PATH/DWORD)

    rep movsd

    Mov edi SaveFilter

    While B$edi <> 0 | add edi ASCII | End_While

    While B$edi <> '\' | SUB edi ASCII | End_While

    Push D$edi,
         edi

        Mov B$edi EOS

        Call SetDirectory SaveFilter  ; says TRUE.

    Pop edi,
        D$edi

    Test eax &TRUE FALSE S0>

        Call DirectLoad

        Call UpdateTitlesFromIncludeFiles

        Call AskForRedraw

        Mov eax &TRUE

S0:
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
;;
; Loading the last MRU File on Startup, if 'LoadMRU' Flag is set On.

[LoadMRU: D$ ?]

LoadLastMRUFile:
    .If D$STR.A.MRU1 <> 0
        StoreNameOnly STR.A.MRU1

        Mov esi STR.A.MRU1, edi SaveFilter
        While B$esi <> 0 | movsb | End_While

        Call LastMRULoading

        If D$SourceLen > 0
            Call SetPartialEditionFromPos | Call EnableMenutems
            Call LoadBookMarks
        End_If

    .End_If
ret
;;
____________________________________________________________________________________________
____________________________________________________________________________________________


  ; Loading the last MRU File on Startup, if 'LoadMRU' Flag is set On.
; RWE1 start of drag and drop modification
[LoadMRU: D$ ?]

LoadLastMRUFile:

    Call ProcessCL

    ; eax returned pointing to command line filename in CLbuffer:
    ; showme eax

    Test eax NA NOT_ZERO S1>

        Test D$STR.A.MRU1 NA ZERO S0> ; Do this if no command line parameters i.e. no drag and drop file

            Call StoreChoosenName STR.A.MRU1 ; Do this if 'autoreload last file on start up' selected

            Mov esi STR.A.MRU1,
                edi SaveFilter

        jmp S2>

S1: Call StoreChoosenName CLBuffer ; Do this if e.g. a file has been drag / dropped onto RosASM icon

    Mov esi CLBuffer,
        edi SaveFilter

S2: While B$esi <> EOS | movsb | End_While ; string MRU1 saved to Savefilter

    Call LastLoading

    Test D$SourceLen NA ZERO S0> ; If the file includes assembly language source

        Call SetPartialEditionFromPos | Call EnableMenutems

        Call LoadBookMarks

S0:
ret
______________________________________________________________________________________________________________________________________________

[CLBuffer : B$ ? # &MAX_PATH] ; Stores any filename drag and dropped to RosASM icon on desktop

ProcessCL:

    Call 'KERNEL32.GetCommandLineA'

    Mov edx eax,
        edi eax,
        ecx 0FF,
        al EOS

    repne scasb

    Mov esi edi,
        edi CLBuffer

L1: Comp esi edx <= S0>

        sub esi ASCII

        Comp B$esi '"' <> S2>

            sub esi ASCII | While B$esi <> '"' | sub esi ASCII | End_While

            Mov eax edi

            If esi <> edx

                add esi ASCII | While B$esi <> '"' | movsb | End_While

            Else

                Mov eax &NULL

            End_If

            Mov B$edi EOS

ret

S2:     Comp B$esi '.' <> L1<

            While B$esi <> ':' | sub esi ASCII | End_While

            Mov eax edi

            sub esi ASCII | While B$esi <> EOS | movsb | End_While

            Mov B$edi EOS

     jmp L1<

S0:  Mov eax &NULL

ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[ActualDir: B$ ? # &MAX_PATH]

[ActualDirPointer: D$ ?]

Proc GetDirectory:

    Argument @STR.A.Dir

    pushad

        Call 'KERNEL32.GetCurrentDirectoryA' &MAX_PATH,
                                             D@STR.A.Dir

    popad

EndP


Proc SetDirectory:

    Argument @STR.A.Dir

    pushad

        On D@STR.A.Dir <> 0 Call 'KERNEL32.SetCurrentDirectoryA' D@STR.A.Dir

    popad

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE StatusBar          ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;                                   Status Bar Job.
;
; Mainly done by Pit (Peter Tuente).
____________________________________________________________________________________________
____________________________________________________________________________________________

[H.StatusBar: D$ ?]

[STATUSBAR_ID              999
 ID_STATUS_BAR_TITLE        01
 ID_STATUS_BAR_TOTAL_LINES  02
 ID_STATUS_BAR_TOTAL_BYTES  03
 ID_STATUS_BAR_LINE         04
 ID_STATUS_BAR_ROW          05
 ID_STATUS_BAR_STATE        06
 ID_STATUS_BAR_NA7          07
 ID_STATUS_BAR_NA8          08
 ID_STATUS_BAR_NA9          09
 ID_STATUS_BAR_NA10         10]

[@: D$ len
 TABLE.StatusPartsPos:
 D$    0
 D$  100 ; 01 TITLE courant
 D$  176 ; 02 Total lines
 D$  264 ; 03 Bytes
 D$  340 ; 04 Line
 D$  396 ; 05 Row
 D$  472 ; 06 Modified/read to run
 D$  700
 D$  800
 D$  900
 D$ 1024]

[STR.A.StatusBar: B$ ? # 40]

[STR.A.StatusBarLineTotalLineText: B$ ' Lines' EOS
 STR.A.StatusBarLineOctetsText: B$ ' Bytes' EOS
 STR.A.StatusBarLineModified: B$ ' Modified' EOS
 STR.A.StatusBarLineUnModified: B$ ' Ready to run' EOS
 STR.A.StatusBarLineLinePos: B$ ' Line: ' STR.A.StatusBarLineLinePosNumber: B$ '           ' EOS
 STR.A.StatusBarLineRowPos: B$ ' Row: ' STR.A.StatusBarLineRowPosNumber: B$ '           ' EOS]

DecimalToAscii:

    ; input: eax = Number / edi = String Pointer

    Mov ecx 10,
        edx NA

L1: Push edx | xor edx edx | div ecx | test eax eax NOT_ZERO L1<

    Mov al dl

L2: add eax '0' | stosb | Pop eax | test eax eax POSITIVE L2<

    Mov al EOS | stosb

ret


StatusBarLineAppend:

    Mov edi STR.A.StatusBar,
        al EOS,
        ecx 40

    repne scasb | sub edi ASCII

L0: movsb | test B$esi-ASCII 0_FF NOT_ZERO L0<

ret
____________________________________________________________________________________________

[PointZeroed: D$ ?]

StatusBar:

    Mov eax D$STRUCT.EditData@CaretRowValue | shr eax 3 | add eax D$STRUCT.EditData@RightScroll | Mov D$StatusCol eax

  ; Name of the File, or of the TITLE:
    Mov esi D$LP.ActualTitle

    ..If esi <> 0

        On D$esi <> 'TITL', jmp L2>>

        While B$esi > SPC | inc esi | End_While
        While B$esi = SPC | inc esi | End_While
        Mov edi esi
        While B$edi > SPC | inc edi | End_While

        Push D$edi, edi

            Mov B$edi 0

            Call 'USER32.SendMessageA' D$H.StatusBar,
                                       &SB_SETTEXT,
                                       ID_STATUS_BAR_TITLE,
                                       esi

        Pop edi, D$edi

    ..Else
      ; eax: Simple flag for '.', because under some OS the .ext may be missing:
        Mov eax &FALSE, B$PointZeroed &FALSE
        Mov esi SaveFilter | On D$esi = 0, ret

        While B$esi <> 0 | inc esi | End_While
        While B$esi-1 <> '\'
            dec esi | On esi = SaveFilter, jmp L1>
            .If B$esi = '.'
                If B$PointZeroed = &FALSE
                    Push D$esi, esi
                    Mov B$esi 0
                    Mov eax &TRUE, B$PointZeroed &TRUE
                End_If
            .End_If
        End_While
L1:
        Push eax

            Call 'USER32.SendMessageA' D$H.StatusBar,
                                       &SB_SETTEXT,
                                       ID_STATUS_BAR_TITLE,
                                       esi

        Pop eax

        If eax = &TRUE

            Pop edi,
                D$edi

        End_If
    ..End_If
L2:
    ; Total Number of Sources Lines:
    Mov eax D$TotalNumberOfLines,
        edi STR.A.StatusBar

    Call DecimalToAscii

    Mov esi STR.A.StatusBarLineTotalLineText | Call StatusBarLineAppend

    Call 'USER32.SendMessageA' D$H.StatusBar,
                               &SB_SETTEXT,
                               ID_STATUS_BAR_TOTAL_LINES,
                               STR.A.StatusBar

    ; Total Number of Bytes:
    Mov eax D$STRUCT.EditData@SourceEnd | sub eax D$CodeSource

    Mov edi STR.A.StatusBar | Call DecimalToAscii

    Mov esi STR.A.StatusBarLineOctetsText | Call StatusBarLineAppend

    Call 'USER32.SendMessageA' D$H.StatusBar,
                               &SB_SETTEXT,
                               ID_STATUS_BAR_TOTAL_BYTES,
                               STR.A.StatusBar

    ; Line Pos:
    Mov eax D$StatusLine,
        edi STR.A.StatusBarLineLinePosNumber

    Call DecimalToAscii

    Call 'USER32.SendMessageA' D$H.StatusBar,
                               &SB_SETTEXT,
                               ID_STATUS_BAR_LINE,
                               STR.A.StatusBarLineLinePos

    ; Row Pos:
    Mov eax D$StatusCol,
        edi STR.A.StatusBarLineRowPosNumber

    Call DecimalToAscii

    Call 'USER32.SendMessageA' D$H.StatusBar,
                               &SB_SETTEXT,
                               ID_STATUS_BAR_ROW,
                               STR.A.StatusBarLineRowPos

    ; Source modified of ready to run:
    test D$FL.ReadyToRun &TRUE ZERO S1>

        mov eax STR.A.StatusBarLineUnModified

    jmp S2>

S1: mov eax STR.A.StatusBarLineModified

S2: Call 'USER32.SendMessageA' D$H.StatusBar,
                               &SB_SETTEXT,
                               ID_STATUS_BAR_STATE,
                               eax

ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT

TITLE Tab             ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
                  Main Editor's Upper Tab Control for TITLEd Chapters.

    When working with enTITLEd Sources, The Editor Copy/Paste the Actually edited Part
    at the very end of the Source Memory. Each time a new Part is activated, the previous
    one is copied back to its own room, and the new selected part is copied down in turn.

    At each event, a 'TABLE.Titles' is build. This Table holds nothing but the Addresses
    of each 'TITLE' inside the Source.

    During Partial Edition, the Partial Source is substituted to the real Source. This
    means that all the KeyBoard features work like if the whole Source was nothing but
    the Partial Source. The modified behaviours are:

    * All KeyBoard actions (example: [Ctrl][PgDwn/PgUp] are limited to the Actual Part).
  
    * The ScrollBar, if any.
    
    * The Status Bar, if any.
    
    * The [Ctrl][S] feature is added a Dialog to choose between Whole/Part Saving.

    All of the Search Features (Right-Click / Tree View / SearchBox / ...) work the
    same as without TITLEs (upon the real whole Source).

    The goals of the feature are:

    * To make Part savings easier (for example, for reuse of wide Chuncks).
    
    * To accelerate the Source Editor, which, with uge Sources (1 Mega and more) may
      become slow on older Computers.
 
    * To make easy uge Source reorganisations.

;;
____________________________________________________________________________________________
____________________________________________________________________________________________

SetPartialEditionFromPos:

    test D$PreviousPartialSourceLen NA ZERO S1>

ret

SetPartialEdition:

S1: test D$TABLE.Titles NA ZERO S1>

        Call GetActualPartFromPos | Call SetActualPartFromPos

    ; To force remaping the Source Editor Colors
S1: Mov D$PreviousUpperLine NA

 ;   Call AskForRedraw

    Mov D$FL.RealSourceRestored &FALSE

ret




[AddedSize: D$ ?]
[FL.RealSourceRestored: D$ ?]

RestoreRealSource:                      ; Called only by 'UndoTitleMove'

    On D$PreviousPartialSourceLen = 0 ret

   ; Call DeleteUndoFiles
   ; Call KillUndo
   ; Call InitUndo

    Mov eax D$STRUCT.EditData@SourceEnd

    If W$eax-2 <> CRLF

        add D$STRUCT.EditData@SourceEnd 2 | add D$SourceLen 2

    End_If

    Mov eax D$SourceLen | sub eax D$PreviousPartialSourceLen | Mov D$AddedSize eax

    ; Move down (as many 'AddedSize') from Top of Actual Source Part to
    ; End of Actual Edition, to make room:
    If eax = 0

        Mov edi D$LP.ActualTitle,
            esi D$CodeSource,
            ecx D$SourceLen

        rep movsb

    Else_If eax s> 0                ; Positive Number.

        Mov esi D$STRUCT.EditData@SourceEnd,         ; End of Partial Edition
            edi esi

        add edi D$AddedSize

        Mov ecx esi | sub ecx D$NextTitle | inc ecx

        ; ecx = length from Source-Next-Title to End-of-Partial-Edition
        std

            rep movsb

        cld

        Mov esi D$CodeSource,
            edi D$LP.ActualTitle

        add esi D$AddedSize         ; equal to the made up room

        Mov ecx D$SourceLen | rep movsb

    Else                           ; Negative Number.

        Mov esi D$CodeSource,
            edi D$LP.ActualTitle

        Mov ecx D$SourceLen | jecxz L0>

            rep movsb
L0:
        Mov esi D$NextTitle,
            ecx D$CodeSource

        sub ecx D$NextTitle | rep movsb

    End_If

    Mov eax D$STRUCT.EditData@CurrentWritingPos

    If eax = D$STRUCT.EditData@SourceEnd

L0:     dec eax | cmp B$eax SPC | jb L0<

    End_If

    sub eax D$CodeSource

    add eax D$LP.ActualTitle | Mov D$STRUCT.EditData@CurrentWritingPos eax

    Mov eax D$LP.ActualTitle | sub eax D$CodeSource    ; eax = adjustement to new Pos.

    add D$STRUCT.EditData@UpperLine eax

    If D$FL.BlockInside = &TRUE

        add D$LP.BlockStartText eax

        add D$LP.BlockEndText eax

    End_If

    Move D$CodeSource D$RealCodeSource

    Move D$STRUCT.EditData@SourceEnd D$RealSourceEnd

    Move D$SourceLen D$RealSourceLen

    Mov eax D$AddedSize | add D$STRUCT.EditData@SourceEnd eax | add D$SourceLen eax

    Mov D$PreviousPartialSourceLen 0

    Mov D$FL.RealSourceRestored &TRUE

ret


TITLESOnOff:

    test D$CodeSource NA NOT_ZERO S1>

ret

S1: xor D$FL.TabWindow &TRUE | jz S2>

        Call ShowTitles

S2: Call 'USER32.ShowWindow' D$H.TabWindow,
                             D$FL.TabWindow

ret


ShowTitles:

    Call RestoreRealSource | Call BuildTitlesTable | Call ShowWindowTitleTab
    ____________________________

    ; TODO traduction
    ; Afficher l'onglet courant
    ____________________________

    Call 'USER32.SendMessageA' D$H.TabWindow,
                               &TCM_SETCURSEL,
                               D$ID.ActualTitle,
                               &NULL

    Call SetPartialEditionFromPos

    ; TODO traduction
    ; Afin de pouvoir continuer à utiliser la molette de la souris pour le scroll dans l'éditeur de source
    Call 'USER32.SetFocus' D$H.MainWindow

ret



Proc BuildTitlesTable:

    Uses ebx,
         edi,
         esi

    [@ID.NumberOfTitles: D$ ?
     @ID.PreviousNumberOfTitles: D$ ?]

    Mov edi D$CodeSource,
        ecx D$SourceLen,
        ebx TABLE.Titles,
        eax 'TITL',
        D$TABLE.Titles EOS,
        B$edi-(1*ASCII) LF

    Move D@ID.PreviousNumberOfTitles D@ID.NumberOfTitles | Mov D@ID.NumberOfTitles 0

    ; TODO traduction Recherche dans edi par DWORD
    shr ecx 2

L1: repne scasd | jne S7>

    Comp W$edi 'E ' <> L1<

    Comp B$edi-5 LF <> L1<

        sub edi (4*ASCII)

        ; If the first TITLE is not Top of file, set one now
        ; Si le premier TITLE n'est pas le début du fichier, le créer
        Comp ebx TABLE.Titles = S2>
            _____________________________________________________

            ; If the TITLE too smaller for the screen, skip over
            ; Si le TITLE est trop court pour l'écran, l'ignorer
            _____________________________________________________

            ; Previous TITLE Pos/ Position du précédent TITLE
            Mov esi D$ebx-DWORD

            xor edx edx

            L2: Comp B$esi CR <> S1>

                    add edx 1

                S1: add esi ASCII

            Comp esi edi < L2<

            Comp edx D$STRUCT.EditData@LineNumber < S6>

       ; Else


S2:     add D@ID.NumberOfTitles 1

        Comp D@ID.NumberOfTitles MAXTITLE = S9>

        Mov D$ebx edi | add ebx DWORD

        add edi (4*ASCII)

S6: test ecx ecx NOT_ZERO L1<

    ; In case when only one valid TITLE is found, we run no TITLE
S7: test D$TABLE.Titles+DWORD NA NOT_ZERO S8>

        Mov D$TABLE.Titles &NULL,
            D@ID.NumberOfTitles 0

    ; TABLE.Titles end mark
S8: Mov D$ebx &NULL

    Mov eax D@ID.NumberOfTitles

    Comp eax D@ID.PreviousNumberOfTitles = S0>

        Call KillUndo | Call InitUndo

S0:
EndP

S9:     Call 'USER32.MessageBoxA' D$H.MainWindow,
                                  {B$ 'Too many TITLEs' EOS},
                                  {B$ 'BuildTitleTable' EOS},
                                  &MB_OK

    jmp S8<
____________________________________________________________________________________________
;;

 
    Partial Edition is done inside the 1_000_000 Octets reserved space that
    BUAsm always sets at the end of User Source. In case User would be
    dividing for the first time a very uge source, and, for example, write
    only one TITLE statement at the Top of Source, and then try to see what
    happends by moving the mouse outside the Client Area, the Partial Edition
    would be unable to copy Megas inside the reserved space. In such cases,
    we abort, and wait until user cut the Source in smaller parts, with
    more TITLES

;;

[TITLE_MAX 1_000_000]

; Sets the Actual Part Variables, depending on the Writing Position.

[LP.ActualTitle: D$ ?
 NextTitle: D$ ?
 PreviousPartialSourceLen: D$ ?
 ID.ActualTitle: D$ ?]

GetActualPartFromPos:

    Mov esi TABLE.Titles,
        ebx D$STRUCT.EditData@CurrentWritingPos,
        eax D$TABLE.Titles,
        edx 0

    Mov D$LP.ActualTitle eax | Move D$NextTitle D$esi+DWORD

    ; 0-2 because Tab Index are zero based (> -1) and because we are
    ; INCreasing until *next* Title found (> -1)
    Mov D$ID.ActualTitle 0-2

    While eax <= ebx

        inc D$ID.ActualTitle

        Mov edx eax | lodsd | On eax = 0, jmp L1>

    End_While

L1: On edx = 0 Mov edx D$TABLE.Titles eax D$TABLE.Titles+DWORD

    On eax = 0 Mov eax D$STRUCT.EditData@SourceEnd

    Mov D$LP.ActualTitle edx,
        D$NextTitle eax

ret
____________________________________________________________________________________________

;;

    The Code Source is always followed by 200 CR/LF (security) + 1_000_000 octets reserved
    for Editing. We set the Partial Edition after the 200 CR/LF
;;

[RealCodeSource: D$ ?
 RealSourceEnd: D$ ?
 RealSourceLen: D$ ?]

SetActualPartFromPos:

    On D$TABLE.Titles = &NULL ret

    Move D$RealCodeSource D$CodeSource
    Move D$RealSourceEnd D$STRUCT.EditData@SourceEnd
    Move D$RealSourceLen D$SourceLen

    Mov edi D$STRUCT.EditData@SourceEnd | add edi 400
    Mov D$CodeSource edi
    Mov esi D$LP.ActualTitle, ecx D$NextTitle | sub ecx esi

    Mov D$PreviousPartialSourceLen ecx, D$SourceLen ecx
    Mov D$STRUCT.EditData@SourceEnd edi | add D$STRUCT.EditData@SourceEnd ecx | rep movsb
    Mov eax 0A0D0A0D, ecx 100 | rep stosd

    Mov eax D$CodeSource | sub eax D$LP.ActualTitle  ; eax = Displacement.

    add D$STRUCT.EditData@CurrentWritingPos eax | add D$STRUCT.EditData@UpperLine eax

    If D$FL.BlockInside = &TRUE

        add D$LP.BlockStartText eax | add D$LP.BlockEndText eax

        Move D$STRUCT.EditData@CurrentWritingPos D$LP.BlockEndText

        Call SetCaret D$STRUCT.EditData@CurrentWritingPos
    End_If

  ; If user add or suppress a TITLE statement in the Partial Edition;
  ; all these Pointers are wrong. We reset at Top of Part:
    Mov eax D$STRUCT.EditData@CurrentWritingPos
    If eax >= D$STRUCT.EditData@SourceEnd
L1:     Move D$STRUCT.EditData@CurrentWritingPos D$CodeSource
        Move D$STRUCT.EditData@UpperLine D$CodeSource
        Mov D$FL.BlockInside &FALSE

        Call 'USER32.ShowWindow' D$H.TabWindow,
                                 &TRUE

        ret
    Else_If eax < D$CodeSource
        jmp L1<
    End_If

    Mov eax D$STRUCT.EditData@UpperLine
    If eax >= D$STRUCT.EditData@SourceEnd
        jmp L1<
    Else_If eax < D$CodeSource
        jmp L1<
    End_If
ret
____________________________________________________________________________________________

[MAXTITLE 100]

[ID.Title: D$ ?
 TABLE.Titles: D$ ? # MAXTITLE]

[STR.A.DefaultTopTITLE: B$ 'Top' EOS]

; One TABLE.Titles Record is: DWORD = Top of Part Pointer
; (>>> "TITLE TitleName")

[STRUC.TITLE.tcItem:
 @imask: D$ ?
 @lpReserved1: D$ ?
 @lpReserved2: D$ ?
 @pszText: D$ ?
 @cchTextMax: D$ ?
 @iImage: D$ ?
 @lParam: D$ ?]

Proc ShowWindowTitleTab:

    Local @DU.TitleTabHight

    Uses ebx,
         esi,
         edi

    test D$TABLE.Titles NA NOT_ZERO S1>

EndP

S1: Mov D$STRUC.TITLE.tcItem@imask &TCIF_TEXT

    Mov esi TABLE.Titles, D$ID.Title 0

    ;  Add a [Top] Tab Item if user did not
    Mov eax D$esi

    If D$eax <> 'TITL'

        Mov D$STRUC.TITLE.tcItem@pszText STR.A.DefaultTopTITLE

        Call 'USER32.SendMessageA' D$H.TabWindow,
                                   &TCM_INSERTITEM,
                                   D$ID.Title,
                                   STRUC.TITLE.tcItem

        add D$ID.Title 1

        Move D$TABLE.Titles D$CodeSource | add esi DWORD

        On D$ID.Title = MAXTITLE sub esi DWORD

    End_If

L1: lodsd | test eax eax ZERO S0> ; ExitP

        jmp S1>

        ; Jump over 'TITLE'/ Saute 'TITLE'
L2:     add eax ASCII

S1: Comp B$eax SPC = L2<

        jmp S2>

L3:     add eax ASCII

S2:     Comp B$eax SPC > L3<

        Mov D$STRUC.TITLE.tcItem@pszText eax

        ; Edx = Eax+20 (20 len max Tab)
        lea edx D$eax+20

        jmp S3>

L4:     add eax ASCII

            Comp eax edx > S5>

S3:     Comp B$eax SPC = L4<

        ; Search for end of 'TitleName', to write a zero, in user source.

        jmp S4>

L5:     add eax ASCII

            Comp eax edx > S5>

S4:     Comp B$eax SPC > L5<

S5:     Mov B$eax 0

        Call 'USER32.SendMessageA' D$H.TabWindow,
                                   &TCM_INSERTITEM,
                                   D$ID.Title,
                                   STRUC.TITLE.tcItem

        add D$ID.Title 1

    jmp L1<

S0:

EndP

[STRUC.RECT.TabWindow:
 D$ ?
 D$ ?
 D$ ?
 D$ ?]

[H.TabWindow: D$ ?
 FL.TabWindow: D$ ?
 H.TabFont: D$ ?]

[STR.A.WindowType.SysTabControl32: B$ 'SysTabControl32' EOS]


[STRUC.LOGFONTA:
 @lfHeight: D$ 0-13
 @lfWidth: D$ &NULL
 @lfEscapement: D$ &NULL
 @lfOrientation: D$ &NULL
 @lfWeight: D$ &FW_DONTCARE
 @lfItalic: B$ &FALSE
 @lfUnderline: B$ &FALSE
 @lfStrikeOut: B$ &FALSE
 @lfCharSet: B$ &DEFAULT_CHARSET
 @lfOutPrecision: B$ &OUT_DEFAULT_PRECIS
 @lfClipPrecision: B$ &CLIP_DEFAULT_PRECIS
 @lfQuality: B$ &DEFAULT_QUALITY
 @lfPitchAndFamily: B$ &DEFAULT_QUALITY
 @lfFaceName: B$ 'Courier New' EOS]

CreateTitleTab:

; [BuildTitlesTable]

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  STR.A.WindowType.SysTabControl32,
                                  &NULL,
                                  &WS_CHILD+&WS_POPUPWINDOW+&TCS_HOTTRACK+&TCS_BUTTONS+&TCS_FLATBUTTONS,
                                  0,
                                  0,
                                  0,
                                  0,
                                  D$H.MainWindow,
                                  &NULL,
                                  D$H.Instance,
                                  &NULL

    Mov D$H.TabWindow eax

    Call 'GDI32.CreateFontIndirectA' STRUC.LOGFONTA

    Mov D$H.TabFont eax

    Call 'USER32.SendMessageA' D$H.TabWindow,
                               &WM_SETFONT,
                               eax,
                               &TRUE

TabResize:

    Call 'USER32.GetWindowRect' D$H.EditWindow,
                                STRUC.RECT.TabWindow

    Mov eax D$STRUC.RECT.TabWindow+LEFT | sub D$STRUC.RECT.TabWindow+RIGHT eax

    sub D$STRUC.RECT.TabWindow+LEFT 1

    Call 'USER32.GetSystemMetrics' &SM_CYFIXEDFRAME

    add eax D$DU.StatusBarHight | sub eax 1

    Mov edx D$STRUC.RECT.TabWindow+BOTTOM | sub edx eax | Mov D$STRUC.RECT.TabWindow+TOP edx

    add eax 1 | Mov D$STRUC.RECT.TabWindow+BOTTOM eax

    Call 'USER32.MoveWindow' D$H.TabWindow,
                             D$STRUC.RECT.TabWindow+LEFT,
                             D$STRUC.RECT.TabWindow+TOP,
                             D$STRUC.RECT.TabWindow+RIGHT,
                             D$STRUC.RECT.TabWindow+BOTTOM,
                             &FALSE

ret

WM_BUTTON_Tab:

    Call 'USER32.SendMessageA' D$H.TabWindow,
                               &TCM_GETCURSEL,
                               &NULL,
                               &NULL

    Mov D$ID.ActualTitle eax

    Mov D$FL.BlockInside &FALSE

    Push eax

       Call RestoreRealSource

    Pop eax

    Mov edx D$TABLE.Titles+eax*DWORD, D$STRUCT.EditData@CurrentWritingPos edx

    Call SetPartialEdition

    Call ShowTitles

ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE INIT            ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

INIT:

    ; For the Resurces Editor:
    Call 'KERNEL32.LoadLibraryA' {B$ 'riched20.dll' EOS}

    Mov D$H.RichEdit eax

    ; Install exception handler
    Call 'KERNEL32.SetUnhandledExceptionFilter' FinalExceptionHandler

    ; Ensure mono-instance:
    Call 'KERNEL32.CreateMutexA' &NULL,
                                 &TRUE,
                                 {B$ 'BUA IsRuning' EOS}

    Call 'KERNEL32.GetLastError'

    On eax = &ERROR_ALREADY_EXISTS Mov D$FL.MultiInstance &TRUE

    Call INIT_WineKey

    Call INIT_WhateverConfig

    Mov D$WriteCheckerWanted 0 ; Temporary locked. ('WriteChecker' ---> toDo as a Hook).

    Call INIT_MainWindow
ret
____________________________________________________________________________________________

INIT_WineKey:

    Call 'ADVAPI32.RegCreateKeyExA' &HKEY_LOCAL_MACHINE,
                                    {B$ 'Software\Windows NT\CurrentVersion\AeDebug' EOS},
                                    0,
                                    0,
                                    0,
                                    &KEY_READ+&KEY_WRITE+&KEY_QUERY_VALUE,
                                    0,
                                    hRegKey,
                                    Result

    Call 'ADVAPI32.RegSetValueExA' D$hRegKey,
                                   {B$ 'Debugger' EOS},
                                   0,
                                   &REG_SZ,
                                   {B$ 'winedbg %ld %ld' EOS},
                                   15

ret
____________________________________________________________________________________________

[ConfigMessage: B$ "You can choose to save your Configuration either as a Registry Key, or under the form of a File: config.bin

You should choose the first option for regular work on your home computer.

The second option may be of interrest, for example, when working from an USB memory stick.

If you choose the second option, when doing a Copy of RosAsm to another Folder, you will have to also copy your 'config.bin' aside" EOS]

[UserConfig: D$ ?]

[REGISTRY 1
 CONFIGFILE 2]
; Regedit.exe: HKEY_CURRENT_USER / Software / RosAsm

INIT_WhateverConfig:

    Call SetMainConfigFilePath

    Call 'KERNEL32.FindFirstFileA' ConfigFilePath,
                                   STRUC.FindFile
    Push eax

        Call 'KERNEL32.FindClose' eax

    Pop eax

    ..If eax = &INVALID_HANDLE_VALUE

        Call OpenRegistry

        .If D$Result = &REG_CREATED_NEW_KEY

            ; Tag Dialog 3
            Call 'USER32.DialogBoxParamA' D$H.Instance,
                                          3,
                                          &NULL,
                                          ConfigProc,
                                          &NULL

            If D$UserConfig = 0FF

                Call CloseRegistry

                Call 'ADVAPI32.RegDeleteKeyA' &HKEY_CURRENT_USER,
                                              BUAsmKey

                Call 'KERNEL32.ExitProcess' 0

            Else_If D$UserConfig = REGISTRY

                ; "Read" assumes create when none:
                Call ReadRegistry

                Mov D$UserConfig REGISTRY

            Else

                Call CloseRegistry

                Call 'ADVAPI32.RegDeleteKeyA' &HKEY_CURRENT_USER,
                                              BUAsmKey

                Mov D$UserConfig CONFIGFILE

                Call AutoInit

                Call WriteConfigFile

            End_If

        .Else

            Call ReadRegistry

            Mov D$UserConfig REGISTRY

        .End_If

    ..Else

        Call ReadConfigFile

        Call CheckPaths

        Mov D$UserConfig CONFIGFILE

    ..End_If
ret
____________________________________________________________________________________________

INIT_MainWindow:

    Call 'KERNEL32.GetModuleHandleA' &NULL

    Mov D$H.Instance eax,
        D$STRUC.WINDOWCLASS@hInstance eax,
        D$OSSInstance eax,
        D$STRUC.OPENFILENAME@hInstance eax,
        D$BmOpenInstance eax

    Call 'USER32.LoadIconA' eax,
                            1

    Mov D$STRUC.WINDOWCLASS@hIcon eax

    Call INIT_Cursors

    Call 'USER32.RegisterClassA' STRUC.WINDOWCLASS

    Call 'USER32.LoadMenuA' D$H.Instance,
                            M00_Menu

    Mov D$H.MenuMain eax

    Call AddUserMenu

    Call NewBuildWin32Equates

    test D$FL.Includes &TRUE ZERO S1>

        On D$EquatesName = 'Equa' Call AppendToCurrentDirectory

        Call PrepareStructuresFiles

S1: Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  STR.A.BUAWindowClass,
                                  STR.A.ApplicationName,
                                  &WS_POPUP+&WS_CAPTION+&WS_SYSMENU+&WS_MINIMIZEBOX+&WS_MAXIMIZEBOX+&WS_THICKFRAME,
                                  D$WindowX,
                                  D$WindowY,
                                  D$WindowW,
                                  D$WindowH,
                                  &NULL,
                                  D$H.MenuMain,
                                  D$H.Instance,
                                  &NULL

    Mov D$H.MainWindow eax,
        D$hwndFileOwner eax,
        D$STRUC.OPENFILENAME@hwndOwner eax,
        D$PRINTDLG@PD_hWndOwner eax,
        D$BmhwndFileOwner eax

    Call 'SHELL32.DragAcceptFiles' eax,
                                   &TRUE

    Call INIT_BackGroundColors

 ret
____________________________________________________________________________________________

INIT_Cursors:

    Call 'USER32.LoadCursorA' 0,
                              &IDC_ARROW

    Mov D$H.CursorARROW eax

    Call 'USER32.LoadCursorA' 0,
                              &IDC_IBEAM

    Mov D$STRUC.WINDOWCLASS@hCursor eax

    Mov D$H.CurrentCursor eax

    Call 'USER32.LoadCursorA' 0,
                              &IDC_WAIT

    Mov D$H.CursorWAIT eax

ret
____________________________________________________________________________________________

INIT_BackGroundColors:

    Call 'GDI32.DeleteObject' D$H.BackGroundBrush | Call 'GDI32.CreateSolidBrush' D$ARVB.BackColor

    Mov D$H.BackGroundBrush eax

    Call 'USER32.SetClassLongA' D$H.Mainwindow,
                                &GCL_HBRBACKGROUND,
                                eax

    Call 'GDI32.DeleteObject' D$H.DialogsBackGroundBrush

    Call 'GDI32.CreateSolidBrush' D$ARVB.DialogsBackColor

    Mov D$H.DialogsBackGroundBrush eax

    Call 'GDI32.DeleteObject' D$H.CaretBrush | Call 'GDI32.CreateSolidBrush' D$StatementColor

    Mov D$H.CaretBrush eax

    Call 'GDI32.DeleteObject' D$H.RedBrush | Call 'GDI32.CreateSolidBrush' D$BracketColor

    Mov D$H.RedBrush eax

ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; EOT
TITLE MAIN            ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

[STRUC.RECT.MainWindow:
 WindowX: D$ 5
 WindowY: D$ 2
 WindowW: D$ 790
 WindowH: D$ 595]

[FL.SaveMainPos: D$ ?]

[IsMaximizedFlag: &SW_SHOWNORMAL]

[ListEditRect:
 ListERX: D$ ?
 ListERY: D$ ?
 ListERW: D$ ?
 ListERH: D$ ?]

[H.MenuMain: D$?]

[FL.ScrollBarWanted: D$ ?]

[FindString: B$ 'commdlg_FindReplace' EOS]
[FindStringMessage: D$ ?]

[FL.MultiInstance: D$ ?]

[STR.A.BUAWindowClass: B$ 'BUAWindowClass' EOS]
[STR.A.EditWindowClassName: B$ 'EDIT' EOS]

[STRUC.WINDOWCLASS:
 @style: D$ &CS_BYTEALIGNCLIENT+&CS_BYTEALIGNWINDOW+&CS_PARENTDC+&CS_HREDRAW+&CS_VREDRAW+&CS_DBLCLKS
 @lpfnWndProc: D$ MainWindowProc
 @cbClsExtra: D$ 0
 @cbWndExtra: D$ 0
 @hInstance: D$ &NULL
 @hIcon: D$ &NULL
 @hCursor: D$ &NULL
 @hbrBackground: D$ &NULL
 @lpszMenuName: D$ &NULL
 @lpszClassName: D$ STR.A.BUAWindowClass]

[H.CursorARROW: D$ ?
 H.CurrentCursor: D$ ?
 H.CursorWAIT: D$ ?]
 __________________________________________________________________________________

; First message structure is for the main loop (Get-Translate-DispatchMessage)
; Second is for Callback. They can't be only one because Wparam for ExitProcess is
; not the same as Wparam previously stored for CallBack.

[STRUC.MSG:
 @hwnd: D$ ?
 @message: D$ ?
 @wParam: D$ ?
 @lParam: D$ ?
 @time: D$ ?
 @STRUC.pt: D$ ? ?]

[H.Instance: D$ ?
 H.MainWindow: D$ ?]
____________________________________________________________________________________________

; For mem tests:

[UserHaveClickDown: B$ 0]

; (UserHaveClickDown flag is to prevent block drawing when back from 'OpenFileName' api
 __________________________________

; Accelerators:

; [DRAWLINE 628]

;;
ACCELNUMBER 2    FLAGLAST 080]

;  ;  01  070  03E8  00    ;03E8 > about ID  (F1)
;  ;  01  071  03F4  00    ;03F4 > Save ID   (F2)
;  ;  01  072  03EC  00    ;03EC > Open ID   (F3)
;  ; 090  078  03ED  00    ;03ED > Exit ID   (Alt-X)  78 > 'x'

; &FCONTROL  &FNOINVERT  &FSHIFT  &FVIRTKEY  &FALT

[ACCELERATORS:
 U$ &FVIRTKEY__&FNOINVERT                        &VK_F1    M00_RosAsm
    &FVIRTKEY__&FCONTROL__&FNOINVERT+FLAGLAST    &VK_8     DRAWLINE]
;;

[FL.Includes: D$ ?
 H.RichEdit: D$ ?]

MAIN:

    Call INIT


  ;  On D$StringsLanguage <> '.en' Call OpenStringsFile

    Call EnableMenutems | Call EnableHelpMenutems
    Call EnableVisualTutsMenu | Call EnableWizardsMenu
    Call EnableClipMenu

    Call CreateStatusBar
    On D$FL.ToolBarWanted = &TRUE, Call CreateToolBar
    On D$FL.ScrollBarWanted = &TRUE, Call CreateScrollBar
    Call CreateEditWindow
    Call CreateTitleTab

  ; (D$IsMaximizedFlag = &SW_SHOWNORMAL or &SW_MAXIMIZE):
    Call 'USER32.ShowWindow'  D$H.MainWindow,
                              D$IsMaximizedFlag

    Call 'USER32.RegisterWindowMessageA' FindString | Mov D$FindStringMessage eax

  ; Rotary table for moving inside text:
    Call SetBackTableMemory | Call InitUndo

    Call CreateFontForDialogEdition | Call LoadFont

    On D$NATION_LOGFONT@lfWeight <> 0, Call LoadNationalFont

    Call SetUndoDirectory
    Call DeleteOldUndoFiles

    Call CheckAllMRUFile | Call SetMRUmenu | On B$LoadMRU = &TRUE, Call LoadLastMRUFile


  ; copying compilable version of icon in case user compiles vithout defining any icon:
    Call StoreIcon

    On D$FL.BlinkingCaretWanted = &TRUE Call InitBlinkCursor

    Call InitExpressionBuffers

;    Call 'USER32.CreateAcceleratorTableA' ACCELERATORS ACCELNUMBER
;    Mov D$AccelHandle eax

    jmp L1>>
   ___________________________________________________________________________

   ; Our main loop: when 'DispatchMessageA' called, Win calls upper CallBack:
   ___________________________________________________________________________

L0: Call 'USER32.IsDialogMessageA' D$H.FindReplace STRUC.MSG  | On eax > 0, jmp L1>

    If D$FL.IsDebugging = &TRUE
        Call 'USER32.TranslateAcceleratorA' D$H.DebugDialog, D$H.DbgAccel, STRUC.MSG
        cmp eax &TRUE | je L1>
        Call 'USER32.IsDialogMessageA' D$H.CurrentDataPage, STRUC.MSG
        cmp eax &TRUE | je L1>
        Call 'USER32.IsDialogMessageA' D$H.DebugDialog, STRUC.MSG
        cmp eax &TRUE | je L1>
    End_If

    Call 'USER32.TranslateMessage' STRUC.MSG
    Call 'USER32.DispatchMessageA' STRUC.MSG

L1: Call 'USER32.GetMessageA' STRUC.MSG 0 0 0

    cmp eax 0 | ja L0<<

  ; Call ReleaseFonts
    Call UpdateRegistry

    Call 'KERNEL32.FreeLibrary' D$H.RichEdit

  ; Call 'USER32.DestroyAcceleratorTable' D$AccelHandle

    Call 'KERNEL32.ExitProcess' D$STRUC.MSG@wParam
____________________________________________________________________________________________

[ID_TIMER_CURSOR 1]

[DU.CaretTime: D$ ? ;600
 FL.ShowCaret: D$ ? ;&TRUE
 FL.BlinkingCaretWanted: D$ ?]

ResetBlinkCursor:

    Call KillBlinkCursor

InitBlinkCursor:

    Call 'USER32.SetTimer' D$H.MainWindow,
                           ID_TIMER_CURSOR,
                           D$DU.CaretTime,
                           TimerCusorProc

ret
____________________________________________________________________________________________

Proc TimerCusorProc:

    Arguments @hwnd,
              @msg,
              @idEvent,
              @dwTime

    xor D$FL.ShowCaret &TRUE | Call AskForRedraw

EndP
____________________________________________________________________________________________

KillBlinkCursor:

    Call 'USER32.KillTimer' D$H.MainWindow,
                            ID_TIMER_CURSOR

    Mov D$FL.ShowCaret &TRUE

ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; Init the Deleted Blocks Undo Folder and delete Undo Files if any:

[UndoDirectory: UndoFile: B$ ? # &MAX_PATH]
[PointerToUndoNumber: D$ '000.'] ; Old nUndoFile
[AllUndoFiles2: B$ ? # &MAX_PATH]

;[UndoFile: 'RosAsmUndo' nUndoFile: '000.$$$' 0  ; 17 Bytes.
; AllUndoFiles: B$ 'RosAsmUndo???.$$$' 0]
;
; The full name looks like this:
; 'E:\RosAsm3\RosAsmUndo\Undo000.$$$'
;
; 'PointerToUndoNumber' points to '000.$$$'
;
; 'AllUndoFiles', used to search for Files to be deleted, looks like this:
; 'E:\RosAsm3\RosAsmUndo\Undo???.$$$'

[UndoExist: B$ "
Block-Delete Undo-Files have been found in the
Temporary Directory (...\RosAsmUndo\).

The existing Undo-Files are going to be deleted and
the previous instance of RosAsm will no more be able to
UnDelete its saved Blocks.
"

MultiUndo: B$ "
You are runing several instances of RosAsm. Do not        
Delete/UnDelete Blocks of text [Ctrl][X] / [Ctrl][Z]
The results could be unwished.

" EOS]

SetUndoDirectory:

    Call ClearPATH UndoDirectory

    Call 'KERNEL32.GetTempPathA' &MAX_PATH,
                                 UndoDirectory

    Mov edi UndoDirectory,
         al EOS,
         ecx &MAX_PATH

    repne scasb | sub edi (1*ASCII)

    On B$edi-1 = '\' sub edi (1*ASCII)

    Mov eax '\Ros' | stosd

    Mov eax 'AsmU' | stosd

    Mov ax 'nd' | stosw

    Mov al 'o' | stosb

    Call 'KERNEL32.CreateDirectoryA' UndoDirectory,
                                     &NULL

    Mov ebx eax

    If D$FL.MultiInstance = &FALSE

        Mov D$edi '\Und',
            D$edi+(4*ASCII) 'o*.$',
            W$edi+(8*ASCII) '$$',
            B$edi+(9*ASCII) EOS

        Call 'KERNEL32.DeleteFileA' UndoDirectory

    End_If

    Mov eax '\Und' | stosd

    Mov eax 'o001' | stosd

    Mov eax '.$$$' | stosd

    Mov B$edi EOS

    sub edi (5*ASCII)

    Mov D$PointerToUndoNumber edi | sub D$PointerToUndoNumber (2*ASCII)

    Mov esi UndoDirectory,
        edi AllUndoFiles2,
        ecx (&MAX_PATH/DWORD)

    rep movsd

    Mov eax D$PointerToUndoNumber | sub eax UndoDirectory

    Mov edi AllUndoFiles2 | add edi eax | Mov eax '???.' | stosd

    ..If ebx = 0   ; 'CreateDirectoryA failed to create a new Dir >>> Already exist.

        Call 'KERNEL32.FindFirstFileA' AllUndoFiles2,
                                       STRUC.FindFile

        .If eax <> &INVALID_HANDLE_VALUE

            If D$FL.MultiInstance = &TRUE

                Call 'USER32.MessageBoxA' D$H.MainWindow,
                                          UndoExist,
                                          Argh,
                                          &MB_OKCANCEL+&MB_ICONHAND

                On eax = &IDCANCEL Call 'KERNEL32.ExitProcess' 0

            End_If

            Call DeleteOldUndoFiles

        .Else

            Call 'KERNEL32.FindClose' eax

            If D$FL.MultiInstance = &TRUE

                Call 'USER32.MessageBoxA' D$H.MainWindow,
                                          MultiUndo,
                                          Argh,
                                          &MB_OK

            End_If

        .End_If

    ..End_If

    Mov edi D$PointerToUndoNumber,
        eax '000.'

    stosd

ret


;;
 
    BackTable is used for moving back and forward in text after tree view or right clicks
    moves. It is an 8 bytes rotary table; this is to say that we use only lower byte of
    BackTablePtr to ajust moves inside table, like this:

    Mov ebx D$BackTablePtr | add (or sub) bl 4

    As memory given by win is page aligned, if bl = 0, "sub bl 4" points to end of table.
;;

[BackTable: D$ ?
 BackTablePtr: D$ ?]

SetBackTableMemory:

    Call VirtualAlloc BackTable,
                      0100

    Move D$BackTablePtr D$BackTable

ret

____________________________________________________________________________________________
____________________________________________________________________________________________

[H.ToolBar: D$ ?]
[TOOLBUTTONS_NUMBER 18] ; (zero based).

[ToolBarButtons:
 D$  0  M00_Tree  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$  0 0 B$ &TBSTATE_ENABLED  &TBSTYLE_SEP 0 0  D$ 0 0
 D$  1  M00_Open  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$  2  M00_New  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 0 0 B$ &TBSTATE_ENABLED  &TBSTYLE_SEP 0 0  D$ 0 0
 D$  3  M00_Compile  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$  4  M00_Run  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 0 0 B$ &TBSTATE_ENABLED  &TBSTYLE_SEP 0 0  D$ 0 0
 D$ 14  M00_About_ToolBar  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0

 D$ 0 0 B$ &TBSTATE_ENABLED  &TBSTYLE_SEP 0 0  D$ 0 0
 D$  5  M00_Calc  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$  6  M00_Clip_File  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$  7  M00_Structures  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$  8  M00_New_Dialog   B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$  9  M00_Find  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 10  M00_Replace  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 11  M00_Ascii_Table   B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 12  M00_Configuration   B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 13  M00_B_U_Asm  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
; D$ 14  M00_About   B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 15  M00_Print   B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 16  M00_Main_Icon   B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 17  M00_Save_Source_Only  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 18  M00_Exit  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 19 12  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
; D$ 20 0CE  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
; D$ 21 0CE  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
; D$ 22 0CE  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 ]

[toolbar00_str_00: B$ 'Tree' EOS]
[toolbar00_str_01: B$ '' EOS]
[toolbar00_str_02: B$ 'Open' EOS]
[toolbar00_str_03: B$ 'New' EOS]
[toolbar00_str_04: B$ '' EOS]
[toolbar00_str_05: B$ 'Compile' EOS]
[toolbar00_str_06: B$ 'Run' EOS]
[toolbar00_str_07: B$ '' EOS]
[toolbar00_str_08: B$ 'About ToolBar' EOS]
[toolbar00_str_09: B$ '' EOS]
[toolbar00_str_10: B$ 'Calc' EOS]
[toolbar00_str_11: B$ 'Clip' EOS]
[toolbar00_str_12: B$ 'Structures' EOS]
[toolbar00_str_13: B$ 'New Dialog' EOS]
[toolbar00_str_14: B$ 'Find' EOS]
[toolbar00_str_15: B$ 'Replace' EOS]
[toolbar00_str_16: B$ 'Ascii Table' EOS]
[toolbar00_str_17: B$ 'Configuration' EOS]
[toolbar00_str_18: B$ 'B_U_Asm' EOS]
[toolbar00_str_19: B$ 'Print' EOS]
[toolbar00_str_20: B$ 'Main Icon' EOS]
[toolbar00_str_21: B$ 'Save Source' EOS]
[toolbar00_str_22: B$ 'Exit' EOS]
[toolbar00_str_23: B$ 'Wizards' EOS 0]

[PointersToToolTipsStrings:
 toolbar00_str_00
 toolbar00_str_01
 toolbar00_str_02
 toolbar00_str_03
 toolbar00_str_04
 toolbar00_str_05
 toolbar00_str_06
 toolbar00_str_07
 toolbar00_str_08
 toolbar00_str_09
 toolbar00_str_10
 toolbar00_str_11
 toolbar00_str_12
 toolbar00_str_13
 toolbar00_str_14
 toolbar00_str_15
 toolbar00_str_16
 toolbar00_str_17
 toolbar00_str_18
 toolbar00_str_19
 toolbar00_str_20
 toolbar00_str_21
 toolbar00_str_22
 toolbar00_str_23]

[TOOLTIPTEXT_NMHDR_hwndFrom 0          ; With WM_NOTIFY Message, Win sends in
 TOOLTIPTEXT_NMHDR_idfrom   4          ; lParam a pointer to a TOOLTIPTEXT
 TOOLTIPTEXT_NMHDR_code     8          ; Structure (which win GIVES to us).

 TOOLTIPTEXT_lpszText       12         ; Item
 TOOLTIPTEXT_szText         16         ; These Equates are to ease accesses to
 TOOLTIPTEXT_hInst          96         ; this Structure (which doesn't belong
 TOOLTIPTEXT_uFlags         100]       ; to our Data area).


[TB_NOTIFY_NMHDR_hwndFrom     0          ; And same for "TBN_GETBUTTONINFO" answers:
 TB_NOTIFY_NMHDR__idfrom      4
 TB_NOTIFY_NMHDR__code        8

 TB_NOTIFY_Item      12

 TB_NOTIFY_TBBUTTON_iBitmap   16
 TB_NOTIFY_TBBUTTON_idCommand 20
 TB_NOTIFY_TBBUTTON_fsState   24
 TB_NOTIFY_TBBUTTON_fsStyle   23
 TB_NOTIFY_TBBUTTON_dwData    28
 TB_NOTIFY_TBBUTTON_iString   32

 TB_NOTIFY_CharCount 36
 TB_NOTIFY_TextPtr   40]


[NMMOUSE_hdr        00
 NMMOUSE_ItemSpec   04
 NMMOUSE_ItemData   08 ; Lp !!!
 NMMOUSE_pt         12
 NMMOUSE_HitInfo    20]

[TbRECT:
 @left: D$ ?
 @top: D$ ?
 @right: D$ ?
 @bottom: D$ ?]

[ToolBarPixelsHight: D$ ??]

[FL.ToolBarWanted: D$ ?]

[HelpToolBar: B$ 'Sure you need some help???!!!!' EOS]
[HelpToolBarTitle: B$ 'Poor you!' EOS]

[ToolBar_Registry:
 @TB_hkr: &HKEY_CURRENT_USER
 @TB_SubKey: ToolBarSubKey
 @TB_ValueName: ToolBarValueName]

[ToolBarChange: B$ 0]
[ToolBarSubKey: B$ 'Software\RosAsm\ToolBar' EOS]
[ToolBarValueName: B$ 'ToolBarState' EOS]

CreateToolBar:
 ;&TBSTYLE_TOOLTIPS__&TBSTYLE_ALTDRAG__&CCS_ADJUSTABLE,
    Call 'COMCTL32.CreateToolbarEx' D$H.MainWindow,
    &CCS_TOP__&TBSTYLE_TOOLTIPS__&WS_CHILD__&WS_VISIBLE__&TBSTYLE_ALTDRAG__&CCS_ADJUSTABLE__&WS_BORDER,
    0300, TOOLBUTTONS_NUMBER, D$H.Instance, 2, ToolBarButtons, 9, 0, 0, 20, 20, 20

; &WS_CHILD__&WS_VISIBLE__&WS_BORDER__&CCS_TOP__&TBSTYLE_ALTDRAG__&CCS_ADJUSTABLE,

    Mov D$H.ToolBar eax

    Call 'USER32.SendMessageA' D$H.ToolBar, &TB_AUTOSIZE, 0, 0

    Call 'USER32.GetWindowRect' D$H.ToolBar, TbRECT
    Mov eax D$TbRECT@bottom | sub eax D$TbRECT@top | dec eax
    Mov D$ToolBarPixelsHight eax

    Call 'USER32.SendMessageA' D$H.ToolBar, &TB_SAVERESTORE, &FALSE,  ; FALSE > restore
                               ToolBar_Registry
SaveToolBar:
    Call 'USER32.SendMessageA' D$H.ToolBar, &TB_SAVERESTORE, &TRUE,   ; TRUE > save
                               ToolBar_Registry
ret

[STRUC.RECT.StatusBar:
 D$ ?
 D$ ?
 D$ ?
 D$ ?]

[DU.StatusBarHight: D$ ?]

CreateStatusBar:

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  {B$ 'msctls_statusbar32' EOS},
                                  &NULL,
                                  &WS_CHILD+&WS_VISIBLE+&SBARS_SIZEGRIP,
                                  0,
                                  0,
                                  0,
                                  0,
                                  D$H.MainWindow,
                                  STATUSBAR_ID,
                                  D$H.Instance,
                                  0

    Mov D$H.StatusBar eax

    Call 'USER32.SendMessageA' D$H.StatusBar,
                               &SB_SETPARTS,
                               11,
                               TABLE.StatusPartsPos

    Call 'USER32.GetWindowRect' D$H.StatusBar,
                                STRUC.RECT.StatusBar

    Push D$STRUC.RECT.StatusBar+TOP

        Call 'USER32.GetClientRect' D$H.MainWindow,
                                    STRUC.RECT.StatusBar

        Call 'USER32.ClientToScreen' D$H.MainWindow,
                                     STRUC.RECT.StatusBar+RIGHT

    Pop edx

    Mov eax D$STRUC.RECT.StatusBar+BOTTOM | sub eax edx | Mov D$DU.StatusBarHight eax





ret

ResizeStatusBar:

    ; StatusBar:
    Call 'USER32.GetClientRect' D$H.MainWindow,
                                STRUC.RECT.StatusBar

    Mov eax D$STRUC.RECT.StatusBar+BOTTOM | sub eax D$DU.StatusBarHight | Mov D$STRUC.RECT.StatusBar+TOP eax

    Call 'USER32.MoveWindow' D$H.StatusBar,
                             D$STRUC.RECT.StatusBar+LEFT,
                             D$STRUC.RECT.StatusBar+TOP,
                             D$STRUC.RECT.StatusBar+RIGHT,
                             D$STRUC.RECT.StatusBar+BOTTOM,
                             &FALSE

ret

[STRUC.RECT.ScrollBarWindow:
 D$ ?
 D$ ?
 D$ ?
 D$ ?]

[H.ScrollBarWindow: D$ ?]

CreateScrollBar:

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  STR.A.EditWindowClassName,
                                  &NULL,
                                  &WS_VISIBLE+&WS_CHILD+&WS_VSCROLL,
                                  0,
                                  0,
                                  0,
                                  0,
                                  D$H.MainWindow,
                                  &NULL,
                                  D$H.Instance,
                                  &NULL
    Mov D$H.ScrollBarWindow eax

    Call 'USER32.SetWindowLongA' D$H.ScrollBarWindow,
                                 &GWL_WNDPROC,
                                 ScrollBarProc

ResizeScrollBar:

    Call 'USER32.GetClientRect' D$H.MainWindow,
                                STRUC.RECT.ScrollBarWindow

    If D$FL.ToolBarWanted = &TRUE

        Mov eax D$ToolBarPixelsHight | add D$STRUC.RECT.ScrollBarWindow+TOP eax | sub D$STRUC.RECT.ScrollBarWindow+BOTTOM eax

    End_If

    Call 'USER32.GetSystemMetrics' &SM_CXVSCROLL

    Mov edx D$STRUC.RECT.ScrollBarWindow+RIGHT, D$STRUC.RECT.ScrollBarWindow+RIGHT eax

    sub edx eax | Mov D$STRUC.RECT.ScrollBarWindow+LEFT edx

    Mov eax D$DU.StatusBarHight | sub D$STRUC.RECT.ScrollBarWindow+BOTTOM eax

    Call 'USER32.MoveWindow' D$H.ScrollBarWindow,
                             D$STRUC.RECT.ScrollBarWindow+LEFT,
                             D$STRUC.RECT.ScrollBarWindow+TOP,
                             D$STRUC.RECT.ScrollBarWindow+RIGHT,
                             D$STRUC.RECT.ScrollBarWindow+BOTTOM,
                             &TRUE

ret


[H.EditWindow: D$ ?
 H.BreakPointWindow: D$ ?]

[STRUC.RECT.EditWindow:
 D$ ?
 D$ ?
 D$ ?
 D$ ?]

[DU.BreakPointWindowMarginWidth: D$ ?]

CreateEditWindow:

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  STR.A.BUAWindowClass,
                                  &NULL,
                                  &WS_CHILD+&WS_VISIBLE,
                                  0, ;D$STRUC.RECT.EditWindow+LEFT,
                                  0, ;D$STRUC.RECT.EditWindow+TOP,
                                  0, ;D$STRUC.RECT.EditWindow+RIGHT,
                                  0, ;D$STRUC.RECT.EditWindow+BOTTOM,
                                  D$H.MainWindow,
                                  &NULL,
                                  D$H.Instance,
                                  &NULL
    Mov D$H.EditWindow eax

    ; Create the BreakPoint Margin Window:
    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  STR.A.BUAWindowClass,
                                  &NULL,
                                  &WS_CHILD+&WS_VISIBLE,
                                  0,
                                  0, ;D$STRUC.RECT.EditWindow+TOP,
                                  0, ;D$STRUC.RECT.EditWindow+LEFT,
                                  0, ;D$STRUC.RECT.EditWindow+BOTTOM,
                                  D$H.MainWindow,
                                  &NULL,
                                  D$H.Instance,
                                  &NULL
    Mov D$H.BreakPointWindow eax

ResizeEditWindow:

    Mov eax D$FontWidth | shl eax 1 | Mov D$DU.BreakPointWindowMarginWidth eax

    Call 'USER32.GetClientRect' D$H.MainWindow,
                                STRUC.RECT.EditWindow

    Mov eax D$DU.BreakPointWindowMarginWidth | add D$STRUC.RECT.EditWindow+LEFT eax

    If D$FL.ToolBarWanted = &TRUE

        Mov eax D$ToolBarPixelsHight | add D$STRUC.RECT.EditWindow+TOP eax

        sub D$STRUC.RECT.EditWindow+BOTTOM eax

    End_If

    If D$FL.ScrollBarWanted = &TRUE

        Mov eax D$STRUC.RECT.ScrollBarWindow+RIGHT | sub D$STRUC.RECT.EditWindow+RIGHT eax

    End_If

    Mov eax D$DU.StatusBarHight | sub D$STRUC.RECT.EditWindow+BOTTOM eax

    Mov eax D$DU.BreakPointWindowMarginWidth | sub D$STRUC.RECT.EditWindow+RIGHT eax

    Call 'USER32.MoveWindow' D$H.EditWindow,
                             D$STRUC.RECT.EditWindow+LEFT,
                             D$STRUC.RECT.EditWindow+TOP,
                             D$STRUC.RECT.EditWindow+RIGHT,
                             D$STRUC.RECT.EditWindow+BOTTOM,
                             &TRUE

    Call 'USER32.MoveWindow' D$H.BreakPointWindow ,
                             0,
                             D$STRUC.RECT.EditWindow+TOP,
                             D$STRUC.RECT.EditWindow+LEFT,
                             D$STRUC.RECT.EditWindow+BOTTOM,
                             &TRUE

ret
____________________________________________________________________________________________

MainResize:

    ; StatusBar:
    Call ResizeStatusBar

    ; ToolBar:
    On D$FL.ToolBarWanted = &TRUE Call 'USER32.SendMessageA' D$H.ToolBar,
                                                             &TB_AUTOSIZE,
                                                             &NULL,
                                                             &NULL
    ; ScrollBar:
    On D$FL.ScrollBarWanted = &TRUE Call ResizeScrollBar

    Call ResizeEditWindow

    ; TabWindow (TITLEs)
    Call TabResize

ret


RedrawInterface:
    ____________________________________________________________________________

    ; TODO traduction
    ; MAJ de l'interface selon les changements d'options (ToolBar/ScrollBar...)
    ____________________________________________________________________________

    Call DestroyWindow H.ToolBar

    On D$FL.ToolBarWanted = &TRUE Call CreateToolBar

    Call DestroyWindow H.ScrollBarWindow

    On D$FL.ScrollBarWanted = &TRUE Call CreateScrollBar

    Call DestroyWindow H.BreakPointWindow

    Call DestroyWindow H.EditWindow

    Call CreateEditWindow

ret


Proc DestroyWindow:

;;
    
    TODO traduction

    Il faut utiliser une procédure indépendante de la MainWindowProc pour détruire ses
    fenêtres filles ; dans le cas contraire la MainWindow serait elle-même détruite

;;
    ____________________________________________________

    ; TODO traduction
    ; Destruction de la fenêtre hwnd et RAZ de son hwnd
    ____________________________________________________

    Argument @LP.Handle

    Uses ebx

    Mov ebx D@LP.Handle

    ; Attribution de la nouvelle procédure de traitement
    Call 'USER32.SetWindowLongA' D$ebx,
                                 &GWL_WNDPROC,
                                 DeleteProc

    ; Destrution de la fenêtre
    Call 'USER32.DestroyWindow' D$ebx

    ; RAZ du Lp -> Fenêtre
    Mov D$ebx &NULL

EndP


Proc DeleteProc:
    _________________________________________________________

    ; TODO traduction
    ; Procédure réservée à la destruction de fenêtres filles
    _________________________________________________________

    Arguments @hwnd,
              @msg,
              @wParam,
              @lParam

    Call 'USER32.DefWindowProcA' D@hwnd,
                                 D@msg,
                                 D@wParam,
                                 D@lParam

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Progress        ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

; Progress Bar

[ProgressClassName: B$ 'msctls_progress32' EOS] ; ProgressName: 'Compiling...' EOS
[PWindowX: 10 PWindowY: 5 PWindowW: 300 PWindowH: 10
 PBarWindow: PBarWindowX: 0   PBarWindowY: 0   PBarWindowW: 340  PBarWindowH: 45
 ProgressInst: 0   H.ForBar: 0]

 Call 'Comctl32.InitCommonControls'

[Writing: B$ ' Writing PE' EOS]
[Fixing: B$ ' Resolving' EOS]
[BuildingHeader: B$ ' PE headers' EOS]
[Encoding: B$ ' Encoding' EOS]
[BuildingData: B$ ' Data job' EOS]
[BuildingRsrc: B$ ' Resources' EOS]
[BuildingImport: B$ ' Import Section' EOS]
[Replacing: B$ ' Replacing' EOS]
[Storing: B$ ' Storing Macros/Equates' EOS]
[Cleaning: B$ ' Cleaning' EOS]

[PROGRESS_BAR_WIDTH 340    PROGRESS_BAR_HIGHT 45]

InitProgressBar:
  ; Center the bar:
    Mov eax D$STRUC.RECT.EditWindow+RIGHT | sub eax PROGRESS_BAR_WIDTH
    shr eax 1 | Mov D$PBarWindowX eax

    Mov ebx D$STRUC.RECT.EditWindow+BOTTOM | sub ebx PROGRESS_BAR_HIGHT
    shr ebx 1 | Mov D$PBarWindowY eax

    Mov D$PBarWindowW PROGRESS_BAR_WIDTH, D$PBarWindowH, PROGRESS_BAR_HIGHT

    Call 'USER32.ClientToScreen' D$H.EditWindow, PBarWindow

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  STR.A.BUAWindowClass,
                                  Cleaning,
                                  &WS_OVERLAPPED+&WS_CAPTION+&WS_THICKFRAME+&WS_VISIBLE,
                                  D$PBarWindowX,
                                  D$PBarWindowY,
                                  D$PBarWindowW,
                                  D$PBarWindowH,
                                  0,
                                  &NULL,
                                  D$H.Instance,
                                  0
    Mov D$H.ForBar eax

 ;   Call 'USER32.ShowWindow' D$hwndForBar, &SW_SHOW ;&SW_SHOWNORMAL

 ;   Call 'USER32.UpdateWindow' D$hwndForBar
_____________________________

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  ProgressClassName,
                                  &NULL,
                                  &WS_CHILD+&WS_VISIBLE,
                                  D$PWindowX,
                                  D$PWindowY,
                                  D$PWindowW,
                                  D$PWindowH,
                                  D$H.ForBar,
                                  &NULL,
                                  D$H.Instance,
                                  0
    Mov D$ProgressInst eax
ret


Proc InitProgressSteps:
    Arguments @Range, @Step
      ; Low Word is 'Min', High Word is 'Max':
        shl D@Range 16
        Call 'USER32.SendMessageA'  D$ProgressInst, &PBM_SETRANGE, 0, D@Range
        Call 'USER32.SendMessageA'  D$ProgressInst, &PBM_SETSTEP, D@Step, 0
EndP


BarProgress:

    On D$FL.WeAreUnfolding = &TRUE ret

    pushad

        Call 'USER32.SendMessageA' D$ProgressInst,
                                   &PBM_STEPIT,
                                   &NULL,
                                   &NULL

    popad
ret

;;
"



      code instructions:                 "
 InstNumber: "                                               

              Data Labels:                 "
 LabsNumber: "                              
              Code Labels:                  "
 CodeLabelsNumber: "


             
             Parsing Time:                "
 ParsingTime: "           ms
             Compile time:                 "
 CompileTime: "           ms
            Creating time:                  "
 CreatingTime:"           ms

                Total time:                  "
 TotalTime:   "           ms


              Source size:                "
 SourceSize:"             octets
                    PE size:                "
     PEsize:"             octets
                Total Size:                "
  TotalSize:"             octets



 "

 0]
;;


; Tag Dialog 1

[TotalTime: D$ ?
 UnusedSymbolsWanted: D$ ?]

Proc Statistics:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ..If D@msg = &WM_COMMAND
        If D@wParam = &IDCANCEL
            Call 'USER32.EndDialog' D@hwnd, 0
        Else_If D@wParam = 3
            ;Call DisplayUnusedSymbolsDialog D@hwnd
            Call 'USER32.EndDialog' D@hwnd, 0
            Mov D$FL.UnusedSymbolsDialogWanted &TRUE
        End_If

    ..Else_If D@msg = &WM_INITDIALOG

        Call 'USER32.SetClassLongA' D@hwnd, &GCL_HICON, D$STRUC.WINDOWCLASS@hIcon

      ; Number of Instructions:
        Call 'USER32.SetDlgItemInt' D@hwnd, 110, D$InstructionsCounter, 0
      ; Number of Code and Data Labels:
        Call 'USER32.SetDlgItemInt' D@hwnd, 111, D$DataLabelsCounter, 0
        Call 'USER32.SetDlgItemInt' D@hwnd, 112, D$CodeLabelsCounter, 0

      ; Parsing Time:
        Mov eax D$Time2 | sub eax D$Time1 | Mov D$TotalTime eax
        Call 'USER32.SetDlgItemInt' D@hwnd, 120, eax, 0
      ; Compile Time:
        Mov eax D$Time3 | sub eax D$Time2 | add D$TotalTime eax
        Call 'USER32.SetDlgItemInt' D@hwnd, 121, eax, 0
      ; Creation Time:
        Mov eax D$Time4 | sub eax D$Time3 | add D$TotalTime eax
        Call 'USER32.SetDlgItemInt' D@hwnd, 122, eax, 0
      ; Total Time:
        Call 'USER32.SetDlgItemInt' D@hwnd, 129, D$TotalTime, 0

      ; Source Size:
        Call 'USER32.SetDlgItemInt' D@hwnd, 130, D$SourceLen, 0
      ; Code Size:
        Call 'USER32.SetDlgItemInt' D@hwnd, 131, D$LenOfCode, 0
      ; Total Size:
        Mov eax D$LenOfCode | add eax D$SourceLen
        Call 'USER32.SetDlgItemInt' D@hwnd, 139, eax, 0

        Call WritePE | Call RecordMRU | On D$BookMarks > 0, Call SaveBookMarks

        If B$UnusedSymbolsWanted = &TRUE
            Call DisplayUnusedSymbolsDialog D@hwnd
        Else
            Mov D$UnusedCodeIndex 0, D$UnusedDataIndex 0
        End_If

    ..Else
        popad | Mov eax &FALSE | ExitP

    ..End_If

    popad | Mov eax &TRUE
EndP


CloseProgressBar:

    Call 'USER32.SendMessageA' D$ProgressInst,
                               &PBM_SETPOS,
                               0,
                               &NULL

    Call 'USER32.DestroyWindow' D$H.ForBar

ret

____________________________________________________________________________________________
____________________________________________________________________________________________

AboutBox:

    Call 'USER32.MessageBoxA' D$H.MainWindow,
                              {B$ "BUA, the Bottom-Up Assembler

Download last version at:

http://code.google.com/p/rosasm64/downloads/list" EOS},
                             {B$ ' About:' EOS},
                             &MB_ICONINFORMATION+&MB_SYSTEMMODAL

ret
____________________________________________________________________________________________

About_ToolBar:

    Call 'USER32.MessageBoxA' D$H.MainWindow,
                              {B$ "Double-Click on the ToolBar for customization

You can Move the ToolBar Buttons by [Alt]+Drag" EOS},
                              {B$ 'ToolBar Info:' EOS},
                              &MB_ICONINFORMATION__&MB_SYSTEMMODAL

ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE SourceEdit      ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;;
  RosAsm Sources Editor
  
  - The Caret is Screen dependant. Not Text dependant.
  
  - The Editor is _not_ a Line-Oriented one.
  
  - The Main Routine called on WM_PAINT is 'PrintColorText'
  
  - Most minor Routines are called from 'CharMessage' or from 'KeyMessage'
  
  - The coloring is achieve through a parallele Table ('ColorsMap')
  
  __________________
  Overall mechanism: 
  
  This Editor is "File Oriented". This is to say, that, each time we insert
  or delete one single Char, all of the downward Text is moved. Over some size
  (depending on the Processor speed) the Editor looses its responsivity, once
  the Copy Operations are slwoer than the KeyBoard inputs speed.
  
  This was the first reason why a Mechanism of TITLEs was introduced, in order
  to divide the real momolitic user Source into "Sub-Sources": For Sources divided
  into TITLEs, the Editor makes a Copy of the Edited TITLE, at the End of the real
  Source, in Memory, and we always work on this isolated Part. This reduces the
  Copy operation to one smaller TITLE part, and the real Copy, into the real user
  Source is done only for each operation requiring to work with the real Source.
  
  The concerned Routines is 'RestoreRealSource' and, for going back to a TITLE
  Edition, 'SetPartialEditionFromPos'.
  
  ________________
  The user inputs:
  
  As said above ('CharMessage', 'KeyMessage') two imputs are considered:
  
  * &WM_CHAR, of course (Nothing special).
  
  * &WM_KEYDOWN / &WM_KEYUP. For these ones, the Editor manages a 'Keys' Table,
    where each Key State (1/0 -On/Off-) is stored.
    
  So, some Functionalities are driven from the &WM_CHAR, and some are driven
  from the &WM_KEYDOWN Messages.
  
    ____________________
    The output Routines.
    
    'XtoRow' 'RowToX' 'TroncatedXtoRow' 'YtoLine' 'LineToY' 'TroncatedYtoLine'
    
    'InitPrintText' 'BlankRemainders'
    
        'PrintColorText'
        
            'PrintCaretAndUnderline' 'GetLastCharPosOnScreen' 'AjustForRightScroll'
        
            'SetColorsMap' 'TextColorsMap'  'TextOutput'
    
            'InitPrintText'  'ClosePrint'
    
    ______________
    Minor Routines
   
    'MouseTextPos' 'SimpleMouseTextPos'
    
    'DownOneLine' 'UpOneLine' 'FullDown' 'OnlyOnePageDown' 'FullUp' 'OnlyOnePageUp'
    
    'AutoDeleteBlock'
    
    'OverwriteSource' 'InsertSource' 'InsertDoubleByte'
    
    'SetIndent' 'CarriageReturn'
    
    'TryToMove'
    
    'ResetCaretOnStripTab' 'StripBackSpace' 'BackSpace'
    
    'KeyDown' 'KeyUp' 'StartOfLine' 'KeyLeft'
    
    'SetPhysicalCaretRow'
    
    'StartOfWord' 'EndOfLine' 'KeyRight' 'EndOfWord'
    
    'KeyInsert' 'StripOneChar' 'KeyDelete'
    
    'SearchTxtPtr'
    
    'SetCaret' 'LeftButton'
    
    'SetBlock'
    
    'LeftButtonUp'
    
    'ControlC' 'ControlY' 'ControlD' 'ControlX' 'UndoControlV'
    
    'OpenClipBoard' 'ClipBordCleaner' 'KillTabs' 'CloseClipBoard'
    
    'ControlV'
    
    'ReMapSourceMemoryIfNeeded'
    
    'DrawOneLine'
    
    ____________
    Undo feature
    
    'InitUndo' 'KillUndo' 'ReInitUndo' 'DoStoreInsert' 'DoStoreOverWrite'
    'DoStoreCharDelete' 'ReInsertDeletedChar' 'DoStoreBlockPaste'
    
    'ResetUndoFileName' 'IncUndoFileName' 'DecUndoFileName'
    
    'WriteUndoBlockFile'
    
    'DeleteUndoFiles' 'DeleteOldUndoFiles'
    
    'UndoBlockCopy' 'ReadUndoBlockFile'
    
    'ControlZ' 'ReadUndoRecord'
    
    ____________________
    Main Redraw Routines
    
    'AskForRedraw' 'AskForRedrawNow'
    
    _____________________
    Text Pos and searches
    
    'TextPos' 'RedrawScrollBar' 'RePosFromScroll'
    
    'KillTrailingSpaces'
    
    'GetWheelInfo' 'WheelMsg'
    
    'StartEdition' 'ReplaceParagraphByDollar'
    
    'CloseHelp'
    
    'InternSearch'

    'SavePosOnF11' 'SetPosOnF12' 'ClearF11F12' 'ClearF12'
    
    _____
    Fonts (called from the Configuration Tab or from main
    
    'ChooseFontHook' 'SelectFont' 'LoadFont'
;;

; looks: Red , Green , Blue , 0  when bytes,     0/Blue/Green/Red  when dWord

[NormalTextColor: B$    0   0   0 0    ; color for Statements or brackets
 CaretColor:          150 150 150 0    ; (xor 00_01101001 for Insert Mode... avoid modifying)
 @PreviousNormalColor:   0   0   0 0]

[PAINTSTRUCT:
 @PShdc: D$ ?
 @PSfErase: D$ ?
 @PSrcPaint: D$ ? ? ? ?
 @PSfRestore: D$ ?
 @PSfIncUpdate: D$ ?
 @PSrgbReserved: D$ ? ? ? ? ? ? ? ?]

[RECT:
 RECTleft: D$ ?
 RECTtop: D$ ?
 RECTright: D$ ?
 RECTbottom: D$ ?]
____________________________________________________________________________________________

[STRUCT.EditData:  ; 21 dwords
 @hFont: D$ 0
 @Col: D$ 0
 @Line: D$ 0  ; Col2: 0  Line2: 0
 @HDC: D$ 0
 @CurrentWritingPos: D$ 0
 @ColNumber: D$ 8
 @LineNumber: D$ 0
 @SourceEnd: D$ 0
 @CaretLine: D$ 0
 @CaretRow: D$ 1
 @CaretRowValue: D$ 8
 @PhysicalCaretRow: D$ 1
 @Caret: D$ 0
 @RightScroll: D$ 0
 @CaretEndOfLine: D$ 0
 @Overwrite: D$ 0
 @StartOfNormalText: D$ 0
 @StartOfComment: D$ 0
 @StartOfBlockText: D$ 0
 @UpperLine: D$ 0]

____________________________________________________________________________________________

; SourceEnd: points AFTER the last byte (so that D$SourceEnd-D$CodeSource = D$SourceLen).

[BlankLine: B$ 32 # 200 EOS]

[H.BackGroundBrush: D$ ?
 H.DialogsBackGroundBrush: D$ ?]

[H.Font1: D$ ?]
____________________________________________________________________________________________

Proc XtoRow:
    Argument @X
    Uses edx, ecx

        Mov edx 0, eax D@X, ecx D$FontWidth | div ecx
      ; Round up:
        shr ecx 1 | On edx > ecx, inc eax
EndP


[XRemainder: D$ ?
 YRemainder: D$ ?]

Proc TroncatedXtoRow:
    Argument @X
    Uses edx

        Mov edx 0, eax D@X | div D$FontWidth
        Mov D$XRemainder edx
EndP


Proc YtoLine:
    Argument @Y
    Uses edx, ecx

        Mov edx 0, eax D@Y, ecx D$FontHeight | div ecx
      ; No 'HalfWay' adjustement to do: The Hot Point of the default Edit-type Cursor
      ; seems to be at the bottom of its shape...
EndP

Proc TroncatedYtoLine:
    Argument @Y
    Uses edx, ecx

        Mov edx 0, eax D@Y | div D$FontHeight
        Mov D$YRemainder edx
EndP


Proc RowToX:
    Argument @Row
    Uses edx

        Mov eax D@Row | mul D$FontWidth
EndP


Proc LineToY:
    Argument @Line
    Uses edx

        Mov eax D@Line | mul D$FontHeight
EndP
____________________________________________________________________________________________

[SourceEndReached: D$ ?
 EditRightPixel: D$ ?
 EditBottomPixel: D$ ?]

[AraseBackEdit:  ; TODO locla
 D$ ?
 D$ ?
 D$ ?
 D$ ? ]

InitPrintText:
    Call 'USER32.BeginPaint' D$H.EditWindow, PAINTSTRUCT | Mov D$STRUCT.EditData@HDC eax

    Call 'GDI32.SelectObject'  D$STRUCT.EditData@HDC D$H.Font1 | Mov D$STRUCT.EditData@hfont eax
    Call 'GDI32.SetBkColor' D$STRUCT.EditData@HDC D$ARVB.BackColor

    Call TroncatedXtoRow D$STRUC.RECT.EditWindow+RIGHT | Mov D$STRUCT.EditData@ColNumber eax
    Call RowToX eax | Mov D$EditRightPixel eax

    ;If D$H.TitleWindow <> 0
    ;    Mov eax D$TabWindowH | sub D$STRUC.RECT.EditWindow+BOTTOM eax
    ;End_If

    Call TroncatedYtoLine D$STRUC.RECT.EditWindow+BOTTOM | Mov D$STRUCT.EditData@LineNumber eax
    Call LineToY eax | dec eax | Mov D$EditBottomPixel eax

;    Call BlankRemainders
; If the division of the writing area by the Font size is not exact (no remainder)
; redraw this background part.

;BlankRemainders:

    If D$XRemainder <> 0

        Call 'USER32.GetClientRect' D$H.EditWindow,
                                    AraseBackEdit

        Move D$AraseBackEdit D$AraseBackEdit+8

        Mov eax D$XRemainder | sub D$AraseBackEdit eax

        Call 'USER32.FillRect' D$STRUCT.EditData@HDC,
                               AraseBackEdit,
                               D$H.BackGroundBrush

    End_If


    If D$YRemainder <> 0

        Call 'USER32.GetClientRect' D$H.EditWindow,
                                    AraseBackEdit

        Move D$AraseBackEdit+4 D$AraseBackEdit+12

        Mov eax D$YRemainder | sub D$AraseBackEdit+4 eax

        Call 'USER32.FillRect' D$STRUCT.EditData@HDC,
                               AraseBackEdit,
                               D$H.BackGroundBrush

    End_If

;ret

    dec D$STRUCT.EditData@LineNumber | dec D$STRUCT.EditData@ColNumber

    Mov B$TextGoingOn &FALSE | Move D$NormalTextColor D$StatementColor
    Mov B$SourceEndReached &FALSE
ret

RemoveCaretAndUnderline:
    If D$STRUC.RECT.Caret+RIGHT <> 0
        Call 'USER32.FillRect'  D$STRUCT.EditData@HDC STRUC.RECT.Caret D$H.BackGroundBrush
        Mov D$STRUC.RECT.Caret+RIGHT 0
    End_If

    If D$STRUC.RECT.UnderLine+RIGHT <> 0
        Call 'USER32.FillRect' D$STRUCT.EditData@HDC, STRUC.RECT.UnderLine, D$H.BackGroundBrush
    End_If
ret

ClosePrint:
    Call 'GDI32.SelectObject' D$STRUCT.EditData@HDC, D$STRUCT.EditData@hfont
    Call 'USER32.EndPaint' D$H.EditWindow, PAINTSTRUCT

    Mov B$TextGoingOn &FALSE
ret
____________________________________________________________________________________________

[TabOldCaretRow: D$ 1]

[Underline: D$ ?]

[STRUC.RECT.Caret:
 D$ ?
 D$ ?
 D$ ?
 D$ ?]

[STRUC.RECT.UnderLine:
 D$ ?
 D$ ?
 D$ ?
 D$ ?]

[H.CaretBrush: D$ ?
 H.RedBrush: D$ ?]


PrintCaretAndUnderline:
    Mov eax D$STRUCT.EditData@LineNumber | On D$STRUCT.EditData@CaretLine > eax, Mov D$STRUCT.EditData@CaretLine eax ; TODO Cmov...

    Mov esi D$STRUCT.EditData@UpperLine, ecx 0

L0: cmp ecx D$STRUCT.EditData@CaretLine | je L2>                 ; search for Caret line (esi)

    On ecx > D$STRUCT.EditData@LineNumber, ret
L1: lodsb | cmp al LF | jne L1<
    inc ecx | jmp L0<

L2: Mov D$STRUCT.EditData@CaretEndOfLine &FALSE, ecx 0
    On D$STRUCT.EditData@RightScroll > 0, sub ecx D$STRUCT.EditData@RightScroll

L0: cmp ecx D$STRUCT.EditData@CaretRow | je L5>>
L1: lodsb | cmp al TAB | je L3>
            cmp al CR | ja L2>                      ; search for Caret col (esi too)
      Mov D$STRUCT.EditData@CaretEndOfLine &TRUE | inc ecx
      Mov D$STRUCT.EditData@Caret 32, ebx ecx, D$STRUCT.EditData@PhysicalCaretRow ebx | jmp L6>>   ; Caret at end of line
L2: inc ecx | jmp L0<

L3: Mov ebx D$STRUCT.EditData@CaretRow, edx ecx | or ecx 00_111 | inc ecx | On ebx > ecx, Jmp L0<

    inc edx | Mov D$STRUCT.EditData@CaretRow edx | cmp ebx D$TabOldCaretRow | jbe L5>

    If edx = D$TabOldCaretRow
        inc ecx | Mov D$STRUCT.EditData@CaretRow ecx | lodsb  ; just for insert Pos on Tab
    End_If

L5: Mov B$STRUCT.EditData@Caret al ; !!! eax D$
    Mov ebx D$STRUCT.EditData@CaretRow, D$STRUCT.EditData@PhysicalCaretRow ebx
L6: dec esi | Mov D$STRUCT.EditData@CurrentWritingPos esi | Mov D$TabOldCaretRow ebx

    Call LineToY D$STRUCT.EditData@CaretLine | Mov ecx eax
    Call RowToX ebx | Mov ebx eax

    Mov D$STRUCT.EditData@CaretRowValue ebx
    On esi >= D$STRUCT.EditData@SourceEnd Mov D$STRUCT.EditData@Caret SPC

    If ecx > 0
        Mov eax D$FontHeight | shr eax 2 | sub ecx eax
    Else
        Mov eax 0
    End_If
    Mov D$STRUC.RECT.Caret ebx, D$STRUC.RECT.Caret+TOP ecx
    add ebx 3 | add ecx eax | add ecx D$FontHeight
    Mov D$STRUC.RECT.Caret+RIGHT ebx, D$STRUC.RECT.Caret+BOTTOM ecx

  ; Let Overwrite Dims a special case to let max speed to the normal Caret:
    If D$STRUCT.EditData@Overwrite = &TRUE
        Mov eax D$FontWidth | add eax D$STRUC.RECT.Caret+LEFT | Mov D$STRUC.RECT.Caret+RIGHT eax
        Mov eax D$FontHeight | shr eax 2 | add D$STRUC.RECT.Caret+TOP eax
    End_If

    On D$FL.ShowCaret = &TRUE, Call 'USER32.InvertRect' D$STRUCT.EditData@HDC, STRUC.RECT.Caret

    .If B$Underline = &TRUE
        Move D$STRUC.RECT.UnderLine+LEFT D$STRUC.RECT.Caret+LEFT,
             D$STRUC.RECT.UnderLine+TOP D$STRUC.RECT.Caret+TOP,
             D$STRUC.RECT.UnderLine+RIGHT D$STRUC.RECT.Caret+RIGHT,
             D$STRUC.RECT.UnderLine+BOTTOM D$STRUC.RECT.Caret+BOTTOM

        Mov ebx D$STRUCT.EditData@CurrentWritingPos | dec ebx
        Mov eax D$FontWidth
        While B$ebx > SPC | dec ebx | sub D$STRUC.RECT.UnderLine+LEFT eax | End_While
        Mov eax D$FontHeight | inc eax
        add D$STRUC.RECT.UnderLine+TOP eax | sub D$STRUC.RECT.UnderLine+RIGHT 6
        Mov eax D$STRUC.RECT.UnderLine+TOP | add eax 2 | Mov D$STRUC.RECT.UnderLine+BOTTOM eax

        Call 'USER32.FillRect' D$STRUCT.EditData@HDC, STRUC.RECT.UnderLine D$H.CaretBrush
    .End_If
ret

____________________________________________________________________________________________

[LastCharPosOnScreen: D$ ?]

GetLastCharPosOnScreen:
  ; LineNumber is zero based:
    Mov eax D$STRUCT.EditData@LineNumber | inc eax

    Mov esi D$STRUCT.EditData@UpperLine

L0: .If B$esi < SPC
        If B$esi = CR
            On B$esi+1 <> LF, Mov B$esi SPC
        Else_If B$esi = LF
            On B$esi-1 <> CR, Mov B$esi SPC
        Else
            Mov B$esi SPC
        End_If
    .End_If

    inc esi | cmp B$esi CR | jne L0<
    dec eax | jnz L0<

    inc esi | Mov D$LastCharPosOnScreen esi
ret
____________________________________________________________________________________________

[WantSizeMarkerColor: &TRUE]

Proc SetColorsMap:
    Argument @First, @Last, @Color

        Mov esi D@First, edx D@Last | add edx 100
        Mov edi esi | sub edi D$CodeSource | add edi D$ColorsMap
        Mov bl B@Color | On bl = 0, Mov bl 1

L0:     .While esi < edx
            Mov al B$esi

            ; Normal = 1 // Brackets = 2 // Strings = 3 // Comments = 4 // Selection 5
            ...If al = "'"
                Do
                    If B$esi >= SPC
                        Mov B$edi 3
                    Else
                        Mov B$edi 0
                    End_If
                    inc esi | inc edi | cmp esi edx | je L9>>
                Loop_Until B$esi = "'"
                Mov B$edi 3 | inc esi | inc edi | jmp L0<

            ...Else_If al = '"'
                Mov eax esi
                Do
                    If B$esi >= SPC
                        Mov B$edi 3
                    Else
                        Mov B$edi 0
                    End_If
                    inc esi | inc edi | cmp esi edx | je L9>>
                Loop_Until B$esi = '"'
                Mov B$edi 3 | inc esi | inc edi | jmp L0<<

            ...Else_If al = '['
                Mov bl 2, B$edi 2
                inc esi | inc edi | jmp L0<<

            ...Else_If al = ']'
                Mov B$edi 2, bl 1
                inc esi | inc edi | jmp L0<<

            ...Else_If B$esi = ';'
                .If D$esi-1 = MLC
                    Mov eax esi
                    Do
                        If B$esi < SPC
                            Mov B$edi 0
                        Else
                            Mov B$edi 4
                        End_If
                        inc esi | inc edi | cmp esi edx | je L9>>
                    Loop_Until D$esi = MLC
                    Mov B$edi 0, W$edi+1 0404, B$edi+3 0
                    Mov B@Color 0
                    add esi 4 | add edi 4 | jmp L0<<
                .Else
                    Do
                        Mov B$edi 4
                        inc esi | inc edi | cmp esi edx | je L9>>
                    Loop_Until B$esi < SPC
                    Mov B@Color 0
                    jmp L0<<
                .End_If

            ...Else_If al < SPC
                Do
                    Mov B$edi 0
                    inc esi | inc edi | cmp esi edx | je L9>>
                Loop_Until B$esi >= SPC
                jmp L0<<

            ...Else_If al = 36
                Mov al B$ParagraphChar, B$esi al
                Mov B$edi bl | On B$WantSizeMarkerColor = &TRUE, xor B$edi 0011
                inc esi | inc edi | jmp L0<<

            ...Else_If al = 167
                Mov al B$ParagraphChar, B$esi al
                Mov B$edi bl | On B$WantSizeMarkerColor = &TRUE, xor B$edi 0011
                inc esi | inc edi | jmp L0<<

            ...Else_If al = '@'
                Mov B$edi bl
                On B$WantSizeMarkerColor = &TRUE, xor B$edi 0011
                inc esi | inc edi | jmp L0<<

            ...Else
L1:             Mov B$edi bl | inc esi | inc edi | jmp L0<<

            ...End_If

        .End_While

      ; Arase any remaining color flag at the end of the last line
        Mov ecx 100, al 0 | rep stosb

L9:     If D$FL.BlockInside = &TRUE

            Mov esi D@First,
                edx D@Last,
                eax D$LP.BlockStartText,
                ebx D$LP.BlockEndText

            On eax > ebx, xchg eax ebx

            On eax < esi, Mov eax esi
            On ebx > edx, Mov ebx edx

            sub eax D$CodeSource | add eax D$ColorsMap
            sub ebx D$CodeSource | add ebx D$ColorsMap | inc ebx

          ; Normal = 1 // Brackets = 2 // Strings = 3 // Comments = 4 // Selection 5
            While eax < ebx | On B$eax <> 0, Mov B$eax 5 | inc eax | End_While
        End_If
;;
        ..If B$WantSizeMarkerColor = &TRUE
            Mov esi D@First, edx D@Last, eax esi, ebx edx

            sub eax D$CodeSource | add eax D$ColorsMap
            sub ebx D$CodeSource | add ebx D$ColorsMap

            .While esi < edx
                .If B$esi = 167     ; Paragraph Char
                    If B$eax = 1
                        Mov B$eax 2
                    Else_If B$eax = 2
                        Mov B$eax 1
                    End_If
                .Else_If B$esi = 36 ; Dollar Char
                    If B$eax = 1
                        Mov B$eax 2
                    Else_If B$eax = 2
                        Mov B$eax 1
                    End_If
                .Else_If B$esi = '@'
                    If B$eax = 1
                        Mov B$eax 2
                    Else_If B$eax = 2
                        Mov B$eax 1
                    End_If
                .End_If
                
                inc eax | inc esi
            .End_While
        ..End_If
;;
EndP
____________________________________________________________________________________________

[ColorsMap: D$ ?
 ColorMapSize: D$ ?]

[LP.BlockStartText: D$ ?
 LP.BlockEndText: D$ ?]

TextColorsMap:

    Mov eax D$SourceLen | add eax 300 | AlignOn 01000 eax

    If D$ColorMapSize < eax

        Mov D$ColorMapSize eax

        Call VirtualFree ColorsMap

        Call VirtualAlloc ColorsMap,
                          D$ColorMapSize

    End_If

ret
____________________________________________________________________________________________

[ParagraphChar: 36] ; 36 or 167 (Dollar or Paragraph)

TextOutput:
    Mov esi D$STRUCT.EditData@UpperLine, ebx esi | sub ebx D$CodeSource | add ebx D$ColorsMap
    Move D$STRUCT.EditData@Col D$FontWidth | Mov D$STRUCT.EditData@Line 0

    Push D$STRUCT.EditData@LineNumber
        inc D$STRUCT.EditData@LineNumber

        On D$STRUCT.EditData@RightScroll <> 0, Call AjustForRightScroll

        Push ebx
            Call 'GDI32.TextOutA' D$STRUCT.EditData@HDC, 0, D$STRUCT.EditData@Line, BlankLine, 1
        Pop ebx

      ; Set the Color for a Chunk of Text:
L0:     movzx eax B$ebx
        If al <> 5
            Mov eax D$StatementColor+eax*4-4
            Push esi, ebx
                Push eax
                    Call 'GDI32.SetBkColor' D$STRUCT.EditData@HDC D$ARVB.BackColor
                Pop eax
                Call 'GDI32.SetTextColor' D$STRUCT.EditData@HDC, eax
            Pop ebx, esi
        Else
            Push esi, ebx
                Call 'GDI32.SetBkColor' D$STRUCT.EditData@HDC D$CaretColor
                Call 'GDI32.SetTextColor' D$STRUCT.EditData@HDC D$ARVB.BackColor
            Pop ebx, esi
        End_If

      ; How many Chars in that Color Chunk, into ecx:
        Mov al B$ebx, ecx 0
        If al <> 0
            While B$ebx = al
                inc ebx | inc ecx
            End_While
        Else
          ; CR/LF:
            add ebx 2 | Mov ecx 2 | sub D$STRUCT.EditData@LineNumber 1
        End_If

      ; Output:
        Push esi, ebx, ecx
            ..If al <> 0
              ; Normal output:
                Call RowToX ecx
              ; > eax = Number of Pixels to output.
                Push eax
                  ; Limit to the available number of Chars:
                    add eax D$STRUCT.EditData@Col
                    If eax > D$EditRightPixel
                        Pop ecx
                            Mov ecx D$EditRightPixel | sub ecx D$STRUCT.EditData@Col
                        Push ecx
                        Call XToRow ecx | Mov ecx eax
                    End_If
                    .If ecx <> 1
                        Call 'GDI32.TextOutA' D$STRUCT.EditData@HDC, D$STRUCT.EditData@Col, D$STRUCT.EditData@Line, esi, ecx
                    .Else
                        If B$esi = 36
                            Call 'GDI32.TextOutA' D$STRUCT.EditData@HDC, D$STRUCT.EditData@Col, D$STRUCT.EditData@Line, ParagraphChar, ecx
                        Else_If B$esi = 167
                            Call 'GDI32.TextOutA' D$STRUCT.EditData@HDC, D$STRUCT.EditData@Col, D$STRUCT.EditData@Line, ParagraphChar, ecx
                        Else
                            Call 'GDI32.TextOutA' D$STRUCT.EditData@HDC, D$STRUCT.EditData@Col, D$STRUCT.EditData@Line, esi, ecx
                        End_If
                    .End_If
                Pop eax
                add D$STRUCT.EditData@Col eax

            ..Else
              ; CR/LF:
                Mov eax D$EditRightPixel
                If eax > D$STRUCT.EditData@Col
                  ; Here we "blank" the End of Line:
                    sub eax D$STRUCT.EditData@Col | Call XToRow eax
                    Push ecx
                        Call 'GDI32.TextOutA' D$STRUCT.EditData@HDC, D$STRUCT.EditData@Col, D$STRUCT.EditData@Line, BlankLine, eax
                    Pop ecx
                End_If

              ; And here, we Blank the next Row Zero (DCBP,...):
                Move D$STRUCT.EditData@col D$FontWidth | Mov eax D$FontHeight | add D$STRUCT.EditData@Line eax
                On D$STRUCT.EditData@LineNumber > 0, Call 'GDI32.TextOutA' D$STRUCT.EditData@HDC, 0, D$STRUCT.EditData@Line, BlankLine, 1

                If D$STRUCT.EditData@RightScroll <> 0
                    Pop ecx, ebx, esi
                        Call AjustForRightScroll
                    Push esi, ebx, ecx
                End_If

            ..End_If
        Pop ecx, ebx, esi

        add esi ecx | cmp D$STRUCT.EditData@LineNumber 0 | ja L0<<
    Pop D$STRUCT.EditData@LineNumber
ret
____________________________________________________________________________________________

AjustForRightScroll:
    Mov eax D$STRUCT.EditData@RightScroll

L0: cmp B$ebx 0 | je L9>

    inc esi | inc ebx | dec eax | cmp eax 0 | ja L0<

L9: ret

;;
  We do not search directely for _the_ previous Color (far too complicated). We search
  for an upward Position that will give a proper start point for building the ColorMap.
  
  So, we:
  
  * exclude the Text Color (too many possible cases).
  
  * exclude the Comments cases (because of Multi-Lines Comments complications).
  
  We simply search for the next upper Line starting with either Statement or Data
  color. 'GetStartUpColorPos' return this Color (eax) and the according Pos in the
  user's SourceCode (esi). If Top of File is reached, we return the Statement Color.
;;

[PreviousStartUpColour: D$ ?
 PreviousStartUpColourPos: D$ ?]

GetStartUpColorPos:
    Mov esi D$STRUCT.EditData@UpperLine | sub esi D$CodeSource | add esi D$ColorsMap
    Mov edx D$ColorsMap

  ; CRLF = 0 // Normal = 1 // Brackets = 2 // Strings = 3 // Comments = 4 // Selection 5
    While esi > edx
        .If B$esi = 0
            If B$esi+1 = 1
                Mov eax 1 | jmp L5>
            Else_If B$esi+1 = 2
                Mov eax 2 | jmp L5>
            End_If

L0:         dec esi
        .End_If

        dec esi
    End_While

  ; Top of File reached:
    Move D$PreviousStartUpColourPos D$CodeSource
    Mov D$PreviousStartUpColour 1  | ret

  ; Start point found. Check cases of Local Symbols label at first Row:
L5: inc esi | Mov ebx esi
    sub ebx D$ColorsMap | add ebx D$CodeSource | On B$ebx = '@', jmp L0<

    sub esi D$ColorsMap | add esi D$CodeSource
    Mov D$PreviousStartUpColourPos esi
    Mov D$PreviousStartUpColour eax | ret
____________________________________________________________________________________________

____________________________________________________________________________________________

[PreviousUpperLine: D$ ?]

PrintColorText:
    On D$FL.SourceReady = &FALSE ret
   ; On D$H.TitleFont <> 0, ret

    Call TextColorsMap | Call InitPrintText | On D$STRUCT.EditData@LineNumber <s 1, ret

   ; If D$FL.CaretOnlyRedraw = &TRUE
   ;     Call RemoveCaretAndUnderline | Call CharOutput | Call PrintCaretAndUnderline
   ;     Mov D$FL.CaretOnlyRedraw &FALSE | jmp L9>>
   ; End_If

    Call GetLastCharPosOnScreen

    Mov eax D$PreviousUpperLine
    If eax <> D$STRUCT.EditData@Upperline
        Call SetColorsMap D$CodeSource, D$LastCharPosOnScreen, 1
    Else
        Call GetStartUpColorPos
        Call SetColorsMap D$PreviousStartUpColourPos,
                          D$LastCharPosOnScreen, D$PreviousStartUpColour
    End_If

    Call RemoveCaretAndUnderline | Call TextOutput | Call PrintCaretAndUnderline

    Move D$PreviousUpperLine D$STRUCT.EditData@UpperLine

    ;If D$BreakPointsTables <> 0
    ;    On D$RightScroll = 0, Call DrawTheRedPlots
    ;End_If

L9: ;Call DrawMarginLine

    Call ClosePrint
ret


PrintBreakPoint:
    On D$FL.BreakPointLineDrawn = &FALSE, Call DrawBreakPointLine

    If D$LP.MEM.TABLE.BreakPoints <> &NULL
        Call DrawTheRedPlotsBreakPoint
    Else
        Call BlankMargin
    End_If
ret


[FL.BreakPointLineDrawn: D$ ?]

[STRUCT.RECT.BreakPointLine:
 @X1: D$ ?
 @Y1: D$ ?
 @X2: D$ ?
 @Y2: D$ ?]

DrawBreakPointLine:

    Call 'USER32.BeginPaint' D$H.BreakPointWindow,
                             PAINTSTRUCT

    Mov D$STRUCT.EditData@HDC eax

    Call DrawTheBreakPointLine

    Call 'USER32.EndPaint' D$H.BreakPointWindow,
                           PAINTSTRUCT

    Mov D$FL.BreakPointLineDrawn &TRUE

ret

DrawTheBreakPointLine:

    Call 'USER32.GetClientRect' D$H.BreakPointWindow,
                                STRUCT.RECT.BreakPointLine

    Mov eax D$STRUCT.RECT.BreakPointLine@X2 | dec eax | Mov D$STRUCT.RECT.BreakPointLine@X1 eax

    Call 'USER32.FillRect' D$STRUCT.EditData@HDC,
                           STRUCT.RECT.BreakPointLine,
                           D$H.CaretBrush

ret
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
 Once user has set the caret, let us say, in the middle of a line, and then moves
 up or down, we do not want the caret horizontal position to be reset definitively
 at left if vertical movement crosses some empty lines (or to left if shorter). So:
 Caret has 2 possible horizontal positions: the one we see at screen (Physical)
 and a virtual one (or physical, if the same), that allow keeping a raw displacement
 while jumping on shorter lines. 'PhysicalCaretRow' is set by writing routine;
 'CaretRow' is set by actions routines. When user hits a key driving an horizontal
 mouvement, we clear this virtual difference if any:
;;

[MRealCaretRow
    Move D$STRUCT.EditData@CaretRow D$STRUCT.EditData@PhysicalCaretRow]

[MousePosX: D$ ?
 MousePosY: D$ ?]

[GetMousePos | Push D@Lparam | Pop W$MousePosX, W$MousePosY]

[ClickOnMargin: D$ ?]

MouseTextPos:
    Call YtoLine D$MousePosY | Mov ebx eax
    Call XtoRow D$MousePosX

L9: ;If eax < 1
    ;    Mov B$ClickOnMargin &TRUE | Mov eax 1
    ;Else
    ;    Mov B$ClickOnMargin &FALSE
    ;End_If

    On eax = 0, Mov eax 1

  ; > eax = Row from start of line // ebx = Line
ret


; Same as above, but with no adjustement (this is for the Mouse Blocks Selections):

SimpleMouseTextPos:
   ; Mov eax D$MousePosX, ebx D$MousePosY
   ; shr eax 3 | shr ebx 4
    Call YtoLine D$MousePosY | Mov ebx eax
    Call XtoRow D$MousePosX

    On eax = 0, inc eax
ret                            ; > eax = col from start of line   ebx = line


DownOneLine:
    Push eax, ebx, ecx
        Mov esi D$STRUCT.EditData@UpperLine
L0:     lodsb | cmp al LF | jne L0<                     ; New pos OK:

        Mov ebx esi, ecx D$STRUCT.EditData@LineNumber
L0:     lodsb | On esi > D$STRUCT.EditData@SourceEnd, jmp L9>           ; abort if end of text found
            cmp al LF | jne L0<
        loop L0<
        Mov D$STRUCT.EditData@UpperLine ebx
L9: Pop ecx, ebx, eax
ret


UpOneLine:

    Push eax
        Mov esi D$STRUCT.EditData@UpperLine
        std
            lodsw
L0:         lodsb | cmp al LF | jne L0<
            add esi 2
            If esi >= D$CodeSource
                Mov D$STRUCT.EditData@UpperLine esi
            Else
                Move D$STRUCT.EditData@UpperLine D$CodeSource
            End_If
        cld
    Pop eax

ret


FullDown:
    Move D$STRUCT.EditData@UpperLine D$STRUCT.EditData@SourceEnd

  ; Call OnlyOnePageUp
    Mov ecx D$STRUCT.EditData@LineNumber | On ecx > 1, dec ecx
L0: Call UpOneLine | loop L0<

    Call OnlyOnePageDown
ret


OnlyOnePageDown:
L1: Mov ebx D$STRUCT.EditData@LineNumber

    If D$STRUCT.EditData@CaretLine < ebx
        Mov esi D$STRUCT.EditData@UpperLine, ecx D$STRUCT.EditData@LineNumber, ebx 0
L2:     lodsb | On esi > D$STRUCT.EditData@SourceEnd, jmp L3>
        cmp al LF | jne L2<
        inc ebx
        loop L2<
L3:     Mov D$STRUCT.EditData@CaretLine ebx
    Else
        Mov ecx ebx | On ecx > 1, dec ecx
L4:     Push ecx
            Call DownOneLine
        Pop ecx | loop L4<
    End_If
ret


FullUp:
    Move D$STRUCT.EditData@UpperLine D$CodeSource | Mov D$STRUCT.EditData@CaretLine 0
ret

OnlyOnePageUp:
    Mov eax D$STRUCT.EditData@LineNumber
    If D$STRUCT.EditData@CaretLine > 0
        Mov D$STRUCT.EditData@CaretLine 0
    Else
        Mov ecx eax | On ecx > 1, dec ecx
L0:     Call UpOneLine | loop L0<
    End_If
ret


[BlockAutoDelete: D$ ?]

AutoDeleteBlock:
    If B$OldBlockInside = &TRUE
        .If B$SimulatedBlock <> &TRUE
            Push eax
                Mov D$FL.BlockInside &TRUE | Call ControlD | Call AskForRedrawNow
            Pop eax
        .End_If
    End_If
ret


[RIGHT_FEED 8]

OverwriteSource:
    On B$BlockAutoDelete = &TRUE, Call AutoDeleteBlock

    Mov edi D$STRUCT.EditData@CurrentWritingPos
    On B$edi = CR, jmp InsertSource
  ;  On eax = TAB, jmp TabCarret
    Mov cl B$edi

    On al < 32, ret

    stosb

    Push eax
        Mov eax D$STRUCT.EditData@ColNumber
        If D$STRUCT.EditData@CaretRow < eax
            inc D$STRUCT.EditData@CaretRow
        Else
            add D$STRUCT.EditData@RightScroll RIGHT_FEED
            sub D$STRUCT.EditData@CaretRow 7
        End_If
    Pop eax

    Call DoStoreOverWrite
ret


[InsertedChar: D$ ?]

InsertSource:   ; eax = Char.

    On B$BlockAutoDelete = &TRUE, Call AutoDeleteBlock

InsertSourceOnBlockIndent:

    MRealCaretRow

    Agree  al = 13, al = 10, al = TAB
    Reject  al < 32  ;, al > 126

    Mov esi D$STRUCT.EditData@SourceEnd | add esi 400 | Mov edi esi      ; 400 is security 13/10/...
    Mov ecx esi | sub ecx D$STRUCT.EditData@CurrentWritingPos | inc ecx

    If al = TAB
        Mov B$InsertedChar SPC | jmp L2>
    Else
        Mov B$InsertedChar al
    End_If

L1: inc edi
    std
        rep movsb | stosb
    cld
    Mov ebx 1 | jmp L3>

L2: Mov eax D$STRUCT.EditData@CaretRow | add eax D$STRUCT.EditData@RightScroll
    add eax D$TabIs | dec eax
    Mov ebx D$TabIs | neg ebx | and eax ebx
    Mov ebx eax
    sub ebx D$STRUCT.EditData@CaretRow | sub ebx D$STRUCT.EditData@RightScroll | inc ebx
    add edi ebx
        std
            rep movsb | Mov al SPC, ecx ebx | rep stosb
        cld

L3: add D$SourceLen ebx | add D$STRUCT.EditData@CurrentWritingPos ebx | add D$STRUCT.EditData@SourceEnd ebx

    Mov eax D$STRUCT.EditData@ColNumber

    cmp D$STRUCT.EditData@CaretRow  eax | jae L4>
      add D$STRUCT.EditData@CaretRow ebx | jmp L9>
L4:   Push ebx
      AlignOn RIGHT_FEED ebx | add D$STRUCT.EditData@RightScroll ebx | sub D$STRUCT.EditData@CaretRow ebx | add D$STRUCT.EditData@CaretRow 1
      Pop ebx

L9: Call DoStoreInsert

    .If B$CompletionWanted = &TRUE
      ; To prevent from runing when doing the Substitution:
        If B$CompletionRuning = &FALSE
            Call CodeComplete | Mov B$CompletionRuning &FALSE
        End_If
    .End_If

ret
____________________________________________________________________________________________

InsertDoubleByte:
    cmp ah 0 | jne L1>
    Call InsertSource
    ret

L1: Mov esi D$STRUCT.EditData@SourceEnd | add esi 400 | Mov edi esi
    Mov ecx esi | sub ecx D$STRUCT.EditData@CurrentWritingPos | inc ecx

L2: add edi 2
        std
            rep movsb | stosb | Mov al ah | stosb
        cld
        Mov ebx 2

L3: add D$SourceLen ebx | add D$STRUCT.EditData@CurrentWritingPos ebx | add D$STRUCT.EditData@SourceEnd ebx

    Mov eax D$STRUCT.EditData@ColNumber

    cmp D$STRUCT.EditData@CaretRow  eax | jae L4>
    add D$STRUCT.EditData@CaretRow ebx | jmp L9>
L4: Push ebx
        AlignOn RIGHT_FEED ebx | add D$STRUCT.EditData@RightScroll ebx | sub D$STRUCT.EditData@CaretRow ebx | sub D$STRUCT.EditData@CaretRow 1
    Pop ebx
L9: Call DoStoreInsert
ret
____________________________________________________________________________________________

;;
 [Carriage Return] includes an indent feature. As many spaces may have to be added
 at once, we do not simply Call to "InsertSource" for each but, instead insert all
 spaces at once for speed reasons (we make a Move on the entire tail of file...):
;;

[AutoIndent: 0   AutoIndentFlag: &TRUE]

SetIndent:
    Push eax
        Mov D$AutoIndent 0, esi D$STRUCT.EditData@CurrentWritingPos

L0:     dec esi | cmp B$esi LF | ja L0<

        inc esi                             ; Start of Current Line.

        .If B$esi+2 = ':'
            add esi 3 | Mov D$AutoIndent 3
            If esi > D$STRUCT.EditData@CurrentWritingPos
              ; Cases of CRLF from  a Pos before a Local Label:
                sub esi 3 | sub D$AutoIndent 3
            End_If
        .End_If

        While esi < D$STRUCT.EditData@CurrentWritingPos
            lodsb | cmp al SPC | jne L9>
                inc D$AutoIndent
        End_While
L9: Pop eax
ret


CarriageReturn:
    .If B$BlockAutoDelete = &TRUE
        If B$OldBlockInside = &TRUE
            Call AutoDeleteBlock | ret
        End_If
    .End_If

    On B$AutoIndentFlag = &TRUE, Call SetIndent
    Mov eax CR | Call InsertSource | Mov eax LF | Call InsertSource

    If D$AutoIndent > 0                                ; instead of "InsertSource":
        Mov esi D$STRUCT.EditData@SourceEnd | add esi 400
        Mov edi esi | add edi D$AutoIndent | Mov ecx esi
        sub ecx D$STRUCT.EditData@CurrentWritingPos | inc ecx
        std
            rep movsb | Mov ecx D$AutoIndent, al SPC | rep stosb
        cld
        Mov eax D$AutoIndent
        add D$SourceLen eax | add D$STRUCT.EditData@CurrentWritingPos eax | add D$STRUCT.EditData@SourceEnd eax
    End_If

    Mov D$STRUCT.EditData@RightScroll 0 | Move D$STRUCT.EditData@CaretRow D$AutoIndent
    inc D$STRUCT.EditData@CaretRow | Mov eax D$STRUCT.EditData@LineNumber ;;;| Mov D$AutoIndent 0   ; in case flag changed

    If D$STRUCT.EditData@CaretLine = eax
        Call DownOneLine
    Else
        add D$STRUCT.EditData@CaretLine 1
    End_If

    Mov ebx D$AutoIndent     ; If AutoIndent on, we have to memorize this event now
    If ebx > 0               ; (after CR/LF recording. Undo will hold 2 jobs for this:
        Mov D$InsertedChar SPC
        Call DoStoreInsert   ; one for undo indent and another for undo CR/LF).
    End_If
ret
____________________________________________________________________________________________

;;
 Instead of searching if end of text is on screen, we try to Move one line up: if it
 is possible, we try to Move one line down. If it is unpossible, end of text is on
 screen and the one-line-up mouvement is validate:
;;

[CanGoUp: D$ ?
 CanGoDown: D$ ?]

TryToMove:
    On D$STRUCT.EditData@LineNumber <s 1 ret

L0: Mov B$CanGoUp &FALSE, B$CanGoDown &FALSE,  esi D$STRUCT.EditData@UpperLine     ; try Up One Line:
    std
        lodsw
L1:     lodsb | cmp al LF | ja L1<
        add esi 2
    cld
    Mov edx esi | On esi > D$CodeSource, Mov B$CanGoUp &TRUE

    Mov esi D$STRUCT.EditData@UpperLine, ecx D$STRUCT.EditData@LineNumber       ; try down one line:

L1: lodsb | cmp al LF | ja L1<
    loop L1<
    add esi 2 | On esi < D$STRUCT.EditData@SourceEnd, Mov B$CanGoDown &TRUE

    On B$CanGoDown = &TRUE, ret
    On B$CanGoUp = &FALSE, ret

    Mov D$STRUCT.EditData@UpperLine edx | add D$STRUCT.EditData@CaretLine 1       ; up one line (down false / up true)
    jmp L0<
____________________________________________________________________________________________

ResetCaretOnStripTab:
    pushad
        std
L0:         lodsb | cmp al LF | jne L0<
        cld
        add esi 2 | Mov ecx 0
L0:     lodsb | inc ecx | cmp al 255 | je L9>
            cmp al TAB | jne L0<
                AlignOn 8 ecx | jmp L0<
L9:     inc ecx | Mov D$STRUCT.EditData@CaretRow ecx, D$STRUCT.EditData@PhysicalCaretRow ecx
    popad
ret


StripBackSpace:
    Mov esi D$STRUCT.EditData@CurrentWritingPos
    If B$esi-1 = TAB
        Mov B$esi-1 255 | Call ResetCaretOnStripTab
    End_If
    Mov edi esi | dec edi, D$STRUCT.EditData@CurrentWritingPos, D$SourceLen, D$STRUCT.EditData@SourceEnd
    Mov ecx D$STRUCT.EditData@SourceEnd | sub ecx D$STRUCT.EditData@CurrentWritingPos | add ecx 0100 | rep movsb
ret


BackSpace:
    ..If B$BlockAutoDelete = &TRUE
        .If B$OldBlockInside = &TRUE
            If al <> TAB
                Call AutoDeleteBlock | ret
            End_If
        .End_If
    ..End_If
EraseLastChar:
    MRealCaretRow | On D$SourceLen = 0, ret
    Mov eax D$STRUCT.EditData@CurrentWritingPos | On eax = D$CodeSource, ret
    Mov ebx BACK | Call DoStoreCharDelete
    Call StripBackSpace

    .If D$STRUCT.EditData@RightScroll = 0
        sub D$STRUCT.EditData@CaretRow 1
    .Else
        If D$STRUCT.EditData@CaretRow = 1
            sub D$STRUCT.EditData@RightScroll RIGHT_FEED
            add D$STRUCT.EditData@CaretRow (RIGHT_FEED-1)
        Else
            sub D$STRUCT.EditData@CaretRow 1
        End_If
    .End_If

    ...If D$STRUCT.EditData@CaretRow = 0
        Mov esi D$STRUCT.EditData@CurrentWritingPos
        If D$STRUCT.EditData@CaretLine = 0
            Call UpOneLine
        Else
            sub D$STRUCT.EditData@CaretLine 1
        End_If
        std | lodsb                                        ; strip CR
L0:         lodsb | cmp al LF | jne L0<
        cld
        lodsw                                              ; strip CR/LF
L0:     lodsb | add D$STRUCT.EditData@CaretRow 1 | cmp al TAB | jne L1>
        or D$STRUCT.EditData@CaretRow 00_111 | inc D$STRUCT.EditData@CaretRow | jmp L0<
L1:     cmp al CR | ja L0<
        Mov ebx BACK | Call DoStoreCharDelete | Call StripBackSpace | Call TryToMove
    ...Else
;;
  When called from 'SimulateBlockForBackIndent' / 'IsItBlockIndent' / 'RetrieveBlockIndent'
  don't play: [Shift][Tab] is going on, not [Shift][BackSpace]. The 'OldBlockInside' Flag
  let us know of it:
;;
        ..If B$keys+&VK_SHIFT = &TRUE
            .If B$OldBlockInside = &FALSE
                Mov eax D$STRUCT.EditData@CaretRow | dec eax | Mov ebx D$TabIs | dec ebx | and eax ebx
                If eax <> 0
                    Call AskForRedrawNow
                    Mov eax D$STRUCT.EditData@CurrentWritingPos
                    On B$eax-1 = SPC, jmp BackSpace
                End_If
            .End_If
        ..End_If
    ...End_If
ret


KeyDown:
    Mov eax D$STRUCT.EditData@LineNumber

    If D$STRUCT.EditData@CaretLine >= eax
        Call DownOneLine
    Else
        Mov esi D$STRUCT.EditData@CurrentWritingPos
L0:     lodsb | On esi > D$STRUCT.EditData@SourceEnd, ret
        cmp al LF | ja L0<
            add D$STRUCT.EditData@CaretLine 1
    End_If
ret


KeyUp:
    If D$STRUCT.EditData@CaretLine = 0
      Call UpOneLine
    Else
      sub D$STRUCT.EditData@CaretLine 1
    End_If

ret


StartOfLine:
    Mov D$STRUCT.EditData@RightScroll 0, eax 1

    Mov esi D$STRUCT.EditData@CurrentWritingPos | While B$esi-1 <> LF | dec esi | End_While

    .If B$esi+2 = ':'
        add esi 3 | add eax 3
        If B$esi = ':'
            inc esi | inc eax
        End_If
    .End_If
    While B$esi = SPC | inc esi | inc eax | End_While

    If D$STRUCT.EditData@CaretRow = 1
        Mov D$STRUCT.EditData@CaretRow eax
    Else_If D$STRUCT.EditData@CaretRow = eax
        Mov D$STRUCT.EditData@CaretRow 1
    Else
        Mov D$STRUCT.EditData@CaretRow eax
    End_If
ret


KeyLeft:
    MRealCaretRow
SimpleKeyLeft:
    .If D$STRUCT.EditData@RightScroll > 0
        If D$STRUCT.EditData@CaretRow = 1
            sub D$STRUCT.EditData@RightScroll RIGHT_FEED
            add D$STRUCT.EditData@CaretRow (RIGHT_FEED-1)
        Else
            sub D$STRUCT.EditData@CaretRow 1
        End_If
    .Else_If D$STRUCT.EditData@CaretRow > 1
        sub D$STRUCT.EditData@CaretRow 1
    .End_If
ret
____________________________________________________________________________________________

; When user selects a Block with the KeyBoard, when he goes Down, and the start point of
; the selection is, say, at row 52, when he stops on a Line with 5 Chars, and hits the
; Left Arrow, he does not mean to wait that the Real Carret Col achieves moving back to
; the end of the 5 Chars Line, but, directely to unselect the 5th Char. For normal use,
; this complicated computation is done both by 'KeyLeft' and by 'PrintCaretAndUnderline',
; but, with Block Selection, there is no Call to 'PrintCaretAndUnderline'? So:

SetPhysicalCaretRow:
    Mov esi D$STRUCT.EditData@UpperLine, ecx 0

L0: cmp ecx D$STRUCT.EditData@CaretLine | je L2>                    ; search for Caret line (esi)
L1: lodsb | cmp al LF | jne L1<
    inc ecx | jmp L0<

L2: Mov ecx 0
    On D$STRUCT.EditData@RightScroll > 0 sub ecx D$STRUCT.EditData@RightScroll

L0: cmp ecx D$STRUCT.EditData@CaretRow | je L5>>
L1: lodsb | cmp al CR | ja L2>                      ; search for Caret col (esi too)
        inc ecx
         Mov D$STRUCT.EditData@PhysicalCaretRow ecx | jmp L6>>      ; Caret at end of line
L2: inc ecx | jmp L0<
L6: ret


StartOfWord:  ; KeyLeft
    Mov esi D$STRUCT.EditData@CurrentWritingPos
    While B$esi-1 = SPC | Call SimpleKeyLeft | dec esi | End_While
    While B$esi-1 > SPC | Call SimpleKeyLeft | dec esi | End_While
    Mov D$STRUCT.EditData@CurrentWritingPos esi
ret



EndOfLine:
    Mov esi D$STRUCT.EditData@CurrentWritingPos | Mov ecx D$STRUCT.EditData@ColNumber

L0: While B$esi <> CR
        If D$STRUCT.EditData@CaretRow < ecx
            inc D$STRUCT.EditData@CaretRow
        Else
            inc D$STRUCT.EditData@RightScroll
        End_If
        inc esi
    End_While

    AlignOn RIGHT_FEED D$STRUCT.EditData@RightScroll
ret


KeyRight:
    MRealCaretRow

SimpleKeyRight:
    Mov eax D$STRUCT.EditData@ColNumber

    If D$STRUCT.EditData@CaretRow < eax
        inc D$STRUCT.EditData@CaretRow
    Else
        add D$STRUCT.EditData@RightScroll RIGHT_FEED
        sub D$STRUCT.EditData@CaretRow 7
    End_If

    If D$STRUCT.EditData@CaretEndOfLine = &TRUE
        .If D$STRUCT.EditData@RightScroll > 0
            If D$STRUCT.EditData@CaretRow = 1
                sub D$STRUCT.EditData@RightScroll RIGHT_FEED
            End_If
        .Else
            dec D$STRUCT.EditData@CaretRow
        .End_If
    End_If
ret


EndOfWord:
    Mov esi D$STRUCT.EditData@CurrentWritingPos
    While B$esi = SPC | Call SimpleKeyRight | inc esi | End_While
    While B$esi > SPC | Call SimpleKeyRight | inc esi | End_While
    Mov D$STRUCT.EditData@CurrentWritingPos esi
ret


KeyInsert:
    xor B$CaretColor 00_01101001 | xor D$STRUCT.EditData@Overwrite &TRUE
ret


StripOneChar:
    inc D$STRUCT.EditData@CurrentWritingPos | Mov ebx FORTH | Call DoStoreCharDelete
    sub D$STRUCT.EditData@CurrentWritingPos 1
    Mov esi D$STRUCT.EditData@CurrentWritingPos, edi esi | inc esi | dec D$SourceLen, D$STRUCT.EditData@SourceEnd
    Mov ecx D$STRUCT.EditData@SourceEnd | sub ecx D$STRUCT.EditData@CurrentWritingPos
    add ecx 0100 | rep movsb
ret


KeyDelete:
    .If B$BlockAutoDelete = &TRUE
        If D$FL.BlockInside = &TRUE
            Call ControlD | ret
        End_If
    .End_If

    MRealCaretRow | On D$SourceLen = 0, ret
    Mov eax D$STRUCT.EditData@CurrentWritingPos
    If eax < D$STRUCT.EditData@SourceEnd
        Call StripOneChar | Mov esi D$STRUCT.EditData@CurrentWritingPos
        On B$esi = LF, Call StripOneChar
    End_If
ret

; (CaretPos to Source Pos).
; This is to translate screen line / col coordinates in one text pointer:
; input eax = Row; ebx = Line
; output eax = ptr

SearchTxtPtr:
    Mov esi D$STRUCT.EditData@UpperLine, ecx 0, edx D$STRUCT.EditData@SourceEnd
    Push eax
L0:     cmp ecx ebx | je L2>
L1:
            lodsb | cmp esi edx | ja L2>
            cmp al LF | jne L1<
                inc ecx | jmp L0<

L2: Pop eax | Mov ebx eax, ecx 0               ; switch eax (col Pos) > ebx
    add ebx D$STRUCT.EditData@RightScroll

L3: cmp esi edx | ja L9>
L3: lodsb | cmp esi edx | ja L9>
    cmp B$esi LF | je L8>
            inc ecx | cmp ecx ebx | jb L3<
                jmp L9>

L8: sub ebx ecx | sub D$STRUCT.EditData@CaretRow ebx | inc D$STRUCT.EditData@CaretRow

L9: dec esi | Mov eax esi

    If D$STRUCT.EditData@CaretRow <s 1
        Mov D$STRUCT.EditData@CaretRow 1 | Mov D$STRUCT.EditData@RightScroll 0
    End_If
ret

____________________________________________________________________________________________

; In fact, sets the Caret and the Current Writing Position at the next Char after
; the Parameter.

Proc SetCaret:
    Argument @Location

        Mov esi D$STRUCT.EditData@UpperLine, D$STRUCT.EditData@CaretRow 1, D$STRUCT.EditData@CaretLine 0

      ; Very rude and durty hak: There is a problem when the Search Box is runing and the
      ; user Click on a TITLE Tab... (temporary security >> To do analyze step by step what
      ; is going on when crossing these two...).
        Mov eax D@Location
        If eax < D$CodeSource
            Move D@Location D$CodeSource
        Else_If eax > D$STRUCT.EditData@SourceEnd
            Move D@Location D$STRUCT.EditData@SourceEnd
        End_If

        While esi < D@Location
            If B$esi = LF
                Mov D$STRUCT.EditData@CaretRow 1 | inc D$STRUCT.EditData@CaretLine
            Else
                inc D$STRUCT.EditData@CaretRow
            End_If
            inc esi
        End_While
        inc D$STRUCT.EditData@CaretRow | Mov D$STRUCT.EditData@CurrentWritingPos esi
EndP

[STRUC.RECT.Confined:
 D$ ?
 D$ ?
 D$ ?
 D$ ?]

[UserClickAfterEnd: D$ ?]

LeftButtonSimulation:
    Mov D$FL.BlockInside &FALSE, B$UserClickAfterEnd &FALSE
    Call MouseTextPos |  | jmp L2>>

LeftButton:
    Mov D$FL.BlockInside &FALSE, B$UserClickAfterEnd &FALSE, B$ClickOnMargin &FALSE

    If eax = D$H.EditWindow
        Call MouseTextPos | Mov D$STRUCT.EditData@CaretRow eax, D$STRUCT.EditData@CaretLine ebx
    Else_If eax = D$H.BreakPointWindow
        Mov B$ClickOnMargin &TRUE
        Call MouseTextPos | Mov D$STRUCT.EditData@CaretRow 1, eax 1, D$STRUCT.EditData@CaretLine ebx

    End_If

    .If B$ClickOnMargin = &TRUE
L1:    ;jmp DoubleClickMarginAction

        On D$LP.MEM.TABLE.BreakPoints = &NULL Call InitBreakPointsTables

        Call IsBreakPointHere

        If D$FL.InsideBreakPointTable = &TRUE
            Call DeleteBreakPoint | Call DoStoreRemoveBreakPoint
        Else
            Call SetBreakPoint | Call DoStoreBreakPoint
        End_If

        Mov B$UserClickAfterEnd &TRUE | jmp L9>>
    .End_If

L2: Mov D$STRUCT.EditData@PhysicalCaretRow eax, D$STRUCT.EditData@CaretRow eax

    Mov D$STRUCT.EditData@CaretLine ebx

L1: Call SearchTxtPtr | Mov D$ShiftDown eax  ; Ready for Block Selection

    If eax < D$STRUCT.EditData@SourceEnd
        Mov D$STRUCT.EditData@CurrentWritingPos eax
    Else
        Mov B$UserClickAfterEnd &TRUE
        Call SetCaret D$STRUCT.EditData@SourceEnd
       ; Mov eax D$CaretRow, ebx D$CaretLine | dec ebx | Mov D$CaretLine ebx | jmp L1<
    End_If

    Call 'USER32.GetClientRect' D$H.EditWindow,
                                STRUC.RECT.Confined

    Call 'USER32.ClientToScreen' D$H.EditWindow,
                                 STRUC.RECT.Confined

  ;  lea eax D$STRUC.RECT.Confined+RIGHT

    Call 'USER32.ClientToScreen' D$H.EditWindow, STRUC.RECT.Confined+RIGHT

    Mov eax D$FontWidth | sub D$STRUC.RECT.Confined+LEFT eax

    Call 'USER32.ClipCursor' STRUC.RECT.Confined

L9: ret


[StartBlockCol: D$ ?
 StartBlockLine: D$ ?
 EndBlockCol: D$ ?
 EndBlockLine: D$ ?
 FL.BlockInside: D$ ?
 BlockRedraw: D$ ?
 ShiftBlockInside: D$ ?]

[MovingBlock: D$ ?
 BlockMoveDelay: D$ ?
 BlockMoveTicks: D$ ?]

[PreviousMouseLine: D$ ?
 PreviousMouseCol: D$ ?
 FirstBlockDraw: D$ ?]

SetBlock:
   ; Slow down the Block moving up or down (by mouse action). Speed increases while moving:
    .If B$MovingBlock = &TRUE
        If D$BlockMoveTicks = 0
            Call 'KERNEL32.GetTickCount'
            add eax D$BlockMoveDelay | Mov D$BlockMoveTicks eax
        Else
            Do
                Call 'KERNEL32.GetTickCount'
            Loop_Until eax > D$BlockMoveTicks
            add eax D$BlockMoveDelay | Mov D$BlockMoveTicks eax
            dec D$BlockMoveDelay | jnz L0>
                Mov D$BlockMoveDelay 1
        End_If

    .Else
        Mov D$BlockMoveTicks 0, D$BlockMoveDelay 60

    .End_If

  ; Set the new Block:
L0: If D$FL.BlockInside = &TRUE
        Move D$STRUCT.EditData@PhysicalCaretRow D$STRUCT.EditData@CaretRow
        Mov D$STRUCT.EditData@CaretEndOfLine &FALSE
    Else
      ; D$ShiftDown is now set in 'LeftButton' (from WM_LBUTTONDOWN Case).
        Mov eax D$STRUCT.EditData@CurrentWritingPos

        Mov D$LP.BlockStartText eax,
            D$LP.BlockEndText eax

        Call SimpleMouseTextPos
        Mov D$STRUCT.EditData@CaretLine ebx, D$STRUCT.EditData@CaretRow eax
        Mov D$PreviousMouseLine ebx, D$PreviousMouseCol eax
        Mov D$ShiftBlockLine ebx, D$ShiftBlockCol eax
        Mov B$FirstBlockDraw &TRUE, B$BlockRedraw &TRUE, D$FL.BlockInside &TRUE | ret
    End_If

  ; Do not run for nop with an empty Block:
    Call SimpleMouseTextPos | Call SearchTxtPtr
    If eax = D$ShiftDown
        Mov D$FL.BlockInside &FALSE | ret
    End_If

    Call SimpleMouseTextPos | Mov D$STRUCT.EditData@PhysicalCaretRow eax, D$STRUCT.EditData@CaretRow eax

  ; Vertical Scrolling, if needed:
    Push eax, ebx
        If ebx = 0
            Push D$STRUCT.EditData@UpperLine
                Call UpOneLine
            Pop eax
            On D$STRUCT.EditData@UpperLine < eax, Mov D$MovingBlock &TRUE
        Else_If ebx >= D$STRUCT.EditData@LineNumber
            Push D$STRUCT.EditData@UpperLine
                Call DownOneLine
            Pop eax
            On D$STRUCT.EditData@UpperLine > eax, Mov D$MovingBlock &TRUE
        Else
            Mov B$MovingBlock &FALSE
        End_If
    Pop ebx, eax

  ; Don't redraw for moves after End-of-Line (lazy reuse of SearchTxtPtr to ajust Row):
    Push ebx | Call SearchTxtPtr | Pop ebx | Mov eax D$STRUCT.EditData@CaretRow

  ; Compute and Redraw only if different:
    If B$FirstBlockDraw = &TRUE
        Mov B$FirstBlockDraw &FALSE | jmp L1>
    Else_If B$MovingBlock = &TRUE
        jmp L1>
    Else_If eax <> D$PreviousMouseCol
        jmp L1>
    Else_If ebx <> D$PreviousMouseLine
L1:     Mov D$PreviousMouseLine ebx, D$PreviousMouseCol eax
        Mov D$STRUCT.EditData@CaretRow eax, D$STRUCT.EditData@CaretLine ebx

            Call SetShiftBlock | Mov B$ShiftBlockInside &FALSE

        Mov B$BlockRedraw &TRUE
    Else
        Mov B$BlockRedraw &FALSE
    End_If
ret
____________________________________________________________________________________________

; "On B$ebx = CR, dec D$BlockEndTextPtr" is because when a block-end-pointer points
; to an empty line, it is right upon the CR of next line. I spent much time to understand
; that, but it is normal. If it was a simple Caret, this would really be the good place.

LeftButtonUp:

    Call 'USER32.IsMenu' D$H.MenuFloatBreakPoint

    On eax = &TRUE Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint

    Call 'USER32.ClipCursor' &NULL

    On D$FL.BlockInside = &FALSE ret

    If B$UserClickAfterEnd = &TRUE

        Mov D$FL.BlockInside &FALSE | ret

    End_If

    Mov B$MovingBlock &FALSE

ret

    ; Should be no more use, with new Block Routines:
    Mov eax D$LP.BlockStartText

    cmp eax D$LP.BlockEndText | jna L5>

        Push eax,
             D$LP.BlockEndText

        Pop D$LP.BlockStartText,
            D$LP.BlockEndText

L5: Mov edx D$LP.BlockEndText

    On B$edx = CR sub D$LP.BlockEndText (1*ASCII)

    Mov eax D$STRUCT.EditData@RightScroll | add D$LP.BlockStartText eax | add D$LP.BlockEndText eax

ret
____________________________________________________________________________________________

; Block action routines:

[hBlock: D$ ?
 BlockSize: D$ ?
 ClipBoardPTR: D$ ?
 ClipBoardLen: D$ ?]

ControlC:
    cmp D$FL.BlockInside &FALSE | je L9>>

    Call 'USER32.OpenClipboard' D$H.MainWindow | cmp eax 0 | je L9>>
    Call 'USER32.EmptyClipboard' | cmp eax 0 | je L8>>

    Mov ecx D$LP.BlockEndText | sub ecx D$LP.BlockStartText | add ecx (1*ASCII)

    Mov D$BlockSize ecx | Mov ebx ecx | inc ebx
    Call 'KERNEL32.GlobalAlloc' &GMEM_DDESHARE, ebx | cmp eax 0 | je L8>  ; > eax = handle
    Mov D$hBlock eax
    Call 'KERNEL32.GlobalLock' eax                                       ; > eax = adress
    Mov edi eax, esi D$LP.BlockStartText, ecx D$BlockSize
    rep movsb | Mov al 0 | stosb
    Call 'KERNEL32.GlobalUnlock' D$hBlock
    Call 'USER32.SetClipboardData' &CF_TEXT, D$hBlock

L8: Call 'USER32.CloseClipboard'
L9: ret


ControlY:
    If D$H.DebugDialog <> 0
        Call CloseDebuggerOrIgnore | On eax = &IDNO jmp L9>>
    End_If

    Mov esi D$STRUCT.EditData@CurrentWritingPos
    While esi > D$CodeSource
        dec esi | cmp B$esi CR | je L1>
    End_While

L1: Mov D$LP.BlockStartText esi
    While esi < D$STRUCT.EditData@SourceEnd
        inc esi | cmp B$esi CR | je L1>
    End_While

L1: sub esi (1*ASCII) | Mov D$LP.BlockEndText esi

    If esi > D$LP.BlockStartText
        Push D$STRUCT.EditData@CaretRow
            Mov d$FL.BlockInside &TRUE | Call ControlD | Call KeyDown
        Pop D$STRUCT.EditData@CaretRow
    End_If
ret


ControlD:
    cmp D$FL.BlockInside &FALSE | je L9>>
    jmp L0>

ControlX:
    cmp D$FL.BlockInside &FALSE | je L9>>
    Call ControlC

L0: If D$H.DebugDialog <> 0
        Call CloseDebuggerOrIgnore | On eax = &IDNO jmp L9>>
    End_If

    Call WriteUndoBlockFileFromBlock | Call StoreUserActionOfBlockDeletion

    Mov eax D$STRUCT.EditData@CaretRow, ebx D$STRUCT.EditData@CaretLine | Call SearchTxtPtr

    ...If eax <> D$LP.BlockStartText

        std                                         ; reset cursor at "BlockStartText":
            Mov esi D$LP.BlockEndText
L0:
            cmp esi D$LP.BlockStartText | je L2>

                lodsb
                cmp al LF | jne L0<
                If esi < D$LastCharPosOnScreen         ; do not DEC Caret Line if block bigger
                    sub D$STRUCT.EditData@CaretLine 1 | jc L1>      ; than screen "upward drawn" by user
                End_If
                jmp L0<
L1:         Mov D$STRUCT.EditData@CaretLine 0 | jmp L0<             ; same, but "downward drawn" by user

L2:         Mov D$STRUCT.EditData@CaretRow 1 | dec esi              ; search for Col:
L3:         lodsb | cmp al LF | je L4>              ; count how many chars between start of block
                ;cmp esi D$CodeSource | jbe L4>      ; and left edge
                If esi <= D$CodeSource
                    add D$STRUCT.EditData@CaretRow 2 | jmp L4>
                End_If
                inc D$STRUCT.EditData@CaretRow | jmp L3<

L4:         .If esi < D$STRUCT.EditData@Upperline                   ; rePos screen if block greater than screen:
                Mov eax D$STRUCT.EditData@UpperLine
                If eax > D$CodeSource
                    add esi 2
                    Mov D$STRUCT.EditData@Upperline esi
                    Mov D$STRUCT.EditData@CaretLine 0
                Else
                    inc D$STRUCT.EditData@CaretRow
                End_If
            .End_If

            Move D$STRUCT.EditData@PhysicalCaretRow D$STRUCT.EditData@CaretRow
        cld

        Move D$STRUCT.EditData@CurrentWritingPos D$LP.BlockStartText

    ...End_If

UndoControlV:                                   ; strip text:

    Mov edi D$LP.BlockStartText, esi D$LP.BlockEndText | add esi (1*ASCII)

    Mov eax esi | sub eax edi                   ; eax = Block-to-strip-out length
    Push eax
        Mov ecx D$STRUCT.EditData@SourceEnd | add ecx 100 | sub ecx esi | rep movsb
    Pop eax
    sub D$STRUCT.EditData@SourceEnd eax | sub D$SourceLen eax | jnc L0>
        Mov D$SourceLen 0

  ; Should be no use. just to be absolutely sure no wrong CR/LF after End Of Source:
L0: Mov edi D$STRUCT.EditData@SourceEnd | Mov eax 0A0D0A0D, ecx 100 | rep stosd
    Call TryToMove                              ; ensure screen Pos in all cases.

    Mov D$FL.BlockInside &FALSE

;;
  This rebuild should be no use (???), and switches to the Next TITLE, in case of
  Block Deletions, probably, because the 'BlockEndTextPtr', of the deleted Chunk
  is at a virtual Pos in the next Tab (???) before the Redraw of the Caret (???).
  
  In case this Comment-Out, would produce some un-wished side-effect, restore it,
  and try to redefine the Caret Pos (line and Row), at the 'BlockStartTextPtr',
  immidiately after the Block Deletion, above, in 'ControlX'. It is already "done",
  but seems to be ineffective... :( :(( :(((
;;
L9: ;Call RestoreRealSource | Call SetPartialEditionFromPos
ret


OpenClipBoard:
    Mov D$ClipBoardLen 0
    Call 'USER32.IsClipboardFormatAvailable' &CF_TEXT | cmp eax 0 | je L9>>
    Call 'USER32.OpenClipboard' D$H.MainWindow | cmp eax 0 | je L9>>
    Call 'USER32.GetClipboardData' &CF_TEXT  | cmp eax 0 | je L8>>    ; > eax = handle
    Mov D$hBlock eax
    Call 'KERNEL32.GlobalLock' eax                          ; > eax = pointer

    Mov D$ClipBoardPtr eax
    Mov edi eax, al 0, ecx 0-1 | repne scasb
    Mov ecx edi | sub ecx D$ClipBoardPtr | dec ecx          ; len
    Mov D$ClipBoardLen ecx
    Call ClipBordCleaner
L9: ret
L8: Call 'USER32.CloseClipboard' | ret


ClipBordCleaner:
    Mov esi D$ClipBoardPtr
BlockCleaner:
L0: lodsb | If al = CR
                On B$esi <> LF, Mov B$esi-1 SPC
                inc esi | dec ecx | jecxz L9>
            Else_If al = LF
                Mov B$esi-1 SPC
            Else_If al < SPC
                Mov B$esi-1 SPC
            Else_If al = 255      ;> 127
                Mov B$esi-1 SPC
            End_If
    loop L0<
L9: ret


KillTabs:
    Mov esi D$CodeSource, ecx D$SourceLen

L0: lodsb | cmp al TAB | jne L1>
        Mov B$esi-1 SPC
L1: loop L0<
ret


CloseClipBoard:
    Call 'KERNEL32.GlobalUnlock' D$hBlock
    Call 'USER32.CloseClipboard'
ret

ControlV:
    Call OpenClipBoard | On D$ClipBoardLen = 0, jmp L7>>

    If D$H.DebugDialog <> 0
        Call CloseDebuggerOrIgnore | On eax = &IDNO jmp L9>>
    End_If

    Call ReMapSourceMemoryIfNeeded D$ClipBoardLen | On eax = &IDNO, jmp L7>>

    If B$BlockAutoDelete = &TRUE
        On D$FL.BlockInside = &TRUE, Call ControlD
    End_If

    Call DoStoreBlockPaste

  ; Make room inside our text:
    Mov esi D$STRUCT.EditData@SourceEnd | add esi 400
    Mov edi esi | add edi D$ClipBoardLen
    Mov ecx esi | sub ecx D$STRUCT.EditData@CurrentWritingPos | inc ecx
    std | rep movsb | cld | inc esi

  ; Write from clipboard:
    Mov edi esi, esi D$ClipBoardPtr, ecx D$ClipBoardLen
    pushad | rep movsb | popad

  ; Search for the new Caret Position:
    Mov esi edi, ebx D$STRUCT.EditData@CaretLine
L0: lodsb | inc D$STRUCT.EditData@CaretRow | cmp al CR | jne L1>
        inc ebx | Mov D$STRUCT.EditData@CaretRow 1 | lodsb | dec ecx | jz L0>
L1: loop L0<

L0: cmp ebx D$STRUCT.EditData@LineNumber | jna L6>
        Mov esi D$STRUCT.EditData@UpperLine | Mov ecx ebx | sub ecx D$STRUCT.EditData@CaretLine
L1:     lodsb | cmp al LF | ja L1<
            Mov D$STRUCT.EditData@UpperLine esi | dec ebx | jmp L0<

L6: Mov D$STRUCT.EditData@CaretLine ebx

    Mov eax D$ClipBoardLen
    add D$SourceLen eax | add D$STRUCT.EditData@SourceEnd eax | add D$STRUCT.EditData@CurrentWritingPos eax
L7: Call 'KERNEL32.GlobalUnlock' D$hBlock
L8: Call 'USER32.CloseClipboard'
L9: ret
____________________________________________________________________________________________

[ExtendMemoryString: B$ "This operation requires more Memory than actually reserved:

Extend ?..." EOS]

[UserPeStartEqualCodeSource: D$ ?]

Proc ReMapSourceMemoryIfNeeded:
    Argument @Added
    [@TempoPointer: D$ ?]

        shl D@Added 1
      ; (to care about Tabs-partial-editions !!!)

        Mov eax D$CodeSource, ebx D$UserPeStart
        and eax 0_FFFF_FFF0 | and ebx 0_FFFF_FFF0

        If eax = ebx
            Mov B$UserPeStartEqualCodeSource &TRUE
        Else
            Mov B$UserPeStartEqualCodeSource &FALSE
        End_If

        add eax D$SourceLen | add eax D@Added | add eax 400

        ...If eax >= D$EndOfSourceMemory
            Call 'USER32.MessageBoxA' D$H.MainWindow, ExtendMemoryString, Argh, &MB_YESNO
            .If eax = &IDYES
                Call RestoreRealSource

              ; New User PE Memory size:
                Mov ecx D$EndOfSourceMemory | sub ecx D$UserPeStart
                add ecx D@Added | shl ecx 1 | add ecx 0100_000

                Push ecx
                  ; Allocate to 'TempoPointer':
                    Call VirtualAlloc @TempoPointer,
                                      ecx

                  ; Copy it all:
                    Mov esi D$UserPeStart, edi D@TempoPointer

                    If B$UserPeStartEqualCodeSource = &TRUE
                        Mov D$edi CRLF2, D$edi+4 CRLF2 | add edi 4 | add D@TempoPointer 4
                    End_If

                    Mov ecx D$EndOfSourceMemory | sub ecx D$UserPeStart
                    shr ecx 2 | rep movsd
                Pop ecx
                add ecx D@TempoPointer | Mov D$EndOfSourceMemory ecx

              ; New 'CodeSource', 'SourceEnd', 'CurrentWritingPos', 'UpperLine':
                Mov eax D@TempoPointer | sub eax D$UserPeStart
                add D$CodeSource eax
                add D$STRUCT.EditData@CurrentWritingPos eax
                add D$STRUCT.EditData@UpperLine eax
                add D$STRUCT.EditData@SourceEnd eax

                Push D$STRUCT.EditData@CurrentWritingPos, D$STRUCT.EditData@UpperLine, D$STRUCT.EditData@CaretLine, D$STRUCT.EditData@CaretRow

                  ; Release old Memory:
                    Exchange D$UserPeStart D@TempoPointer

                    Call VirtualFree D@TempoPointer

                  ; SourceLen may be = 0, when pasting after a [File]/[New]:
                    On D$Sourcelen > 0, Call StartEdition

                    Mov eax &IDOK

                Pop D$STRUCT.EditData@CaretRow, D$STRUCT.EditData@CaretLine, D$STRUCT.EditData@UpperLine, D$STRUCT.EditData@CurrentWritingPos

                Call SetPartialEditionFromPos

                Mov eax &IDYES
            .End_If

          ; eax = &IDNO if not &IDYES

        ...Else
            Mov eax &IDOK

        ...End_If
EndP
____________________________________________________________________________________________

; [F8] Separator Line

DrawOneLine:
    MRealCaretRow

    Mov esi D$STRUCT.EditData@SourceEnd | add esi 400 | Mov edi esi      ; 400 is security 13/10/...
    Mov ecx esi, ebx DRAWLINELEN | sub ecx D$STRUCT.EditData@CurrentWritingPos | inc ecx

    add edi ebx
        std
          rep movsb
          Mov al '_', ecx ebx | rep stosb
        cld

    add D$SourceLen ebx | add D$STRUCT.EditData@CurrentWritingPos ebx | add D$STRUCT.EditData@SourceEnd ebx

    Mov D$InsertedChar '_'

    Call DoStoreInsert | Call CarriageReturn
ret

____________________________________________________________________________________________

[WithControlA: D$ ?]

ControlA:
    If B$WithControlA = &TRUE

        Move D$LP.BlockStartText D$CodeSource,
             D$LP.BlockEndText D$STRUCT.EditData@SourceEnd

      ; SourceEnd is the Byte _after_ // BlockEndTextPtr is the last Byte:
        sub D$LP.BlockEndText (1*ASCII)

        Mov D$FL.BlockInside &TRUE

    End_If

ret
____________________________________________________________________________________________

AskForRedraw:

    Call 'USER32.RedrawWindow' D$H.BreakPointWindow,
                               0,
                               0,
                               &RDW_INVALIDATE+&RDW_INTERNALPAINT

    Call 'USER32.RedrawWindow' D$H.EditWindow,
                               0,
                               0,
                               &RDW_INVALIDATE+&RDW_INTERNALPAINT

ret

AskForRedrawNow:

    Call 'USER32.RedrawWindow' D$H.BreakPointWindow,
                               0,
                               0,
                               &RDW_INVALIDATE+&RDW_INTERNALPAINT+&RDW_UPDATENOW

    Call 'USER32.RedrawWindow' D$H.EditWindow,
                               0,
                               0,
                               &RDW_INVALIDATE+&RDW_INTERNALPAINT+&RDW_UPDATENOW

ret
____________________________________________________________________________________________
____________________________________________________________________________________________

;                               Source Edition Routines.
____________________________________________________________________________________________

; The Source Editor does not use any concept of Line / Row for defining the actual
; editing Position. For Status Bar, we need them, and for ScrollBar, the Line too.

[StatusLine: D$ ?
 StatusCol: D$ ?
 TotalNumberOfLines: D$ ?]

[VScroll:
 @VScroll.cbSize: D$ len
 @VScroll.fMask: D$ &SIF_ALL__&SIF_DISABLENOSCROLL ; = &SIF_PAGE+&SIF_POS+&SIF_RANGE // &SIF_DISABLENOSCROLL
 @VScroll.nMin: D$ 1
 VScroll.nMax: D$ 0
 VScroll.nPage: D$ 0
 VScroll.nPos: D$ 0
 VScroll.nTrackPos: D$ 0]

TextPos:
    Mov edi D$CodeSource, ecx 0-1, al CR, D$StatusLine 0, D$StatusCol 0
    Align 32

    Mov ebx D$STRUCT.EditData@UpperLine
    If ebx < D$CodeSource
        Move D$STRUCT.EditData@UpperLine D$CodeSource, D$STRUCT.EditData@CurrentWritingPos D$CodeSource
        Mov D$STRUCT.EditData@CaretRow 1, D$STRUCT.EditData@CaretLine 0, D$STRUCT.EditData@PhysicalCaretRow 1

    Else_If ebx > D$STRUCT.EditData@SourceEnd
        Move D$STRUCT.EditData@UpperLine D$CodeSource, D$STRUCT.EditData@CurrentWritingPos D$CodeSource
        Mov D$STRUCT.EditData@CaretRow 1, D$STRUCT.EditData@CaretLine 0, D$STRUCT.EditData@PhysicalCaretRow 1

    End_If

L0: repne scasb | inc D$StatusLine | cmp edi D$STRUCT.EditData@UpperLine | jb L0<

    Move D$TotalNumberOfLines D$StatusLine
    Mov eax D$STRUCT.EditData@CaretLine | add D$StatusLine eax

    Mov al CR
L0: repne scasb | inc D$TotalNumberOfLines | cmp edi D$STRUCT.EditData@SourceEnd | jb L0<
    Mov eax D$TotalNumberOfLines | dec eax

    Move D$VScroll.nMax eax
    Move D$VScroll.nPage D$STRUCT.EditData@LineNumber
    Mov eax D$statusLine | sub eax D$STRUCT.EditData@CaretLine | inc eax
    Mov D$VScroll.nPos eax

    On D$FL.ScrollBarWanted = &TRUE Call 'USER32.SetScrollInfo' D$H.ScrollBarWindow,
                                                                &SB_VERT,
                                                                VScroll,
                                                                &TRUE
ret


RePosFromScroll:    ; called with eax = Line Number Wanted by user Bar Scrolling.

    Push edi

        Mov edi D$CodeSource, al CR, D$StatusLine 0, D$StatusCol 0

        Comp edx 1 = S1>

        ; Align 32
        Mov ecx D$SourceLen

L0:     repne scasb

            sub edx 1

        Comp edx 1 > L0<

    add edi 1

S1: Mov D$STRUCT.EditData@UpperLine edi

    Pop edi

ret

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc KillTrailingSpaces:

;;

    The Editor may let no use Spaces (between the end of text and CR/LF. This happend, for
    example when you enter blanks Lines on Indentations

    I do not implement it in the Menu, and as this is fast enough i implement it when opening
    a file [OpenSourceOnly] / [OpenBUAsmPE]

;;

    Uses ebx,
         esi,
         edi

    Mov esi D$CodeSource,
        edi esi,
        edx D$STRUCT.EditData@SourceEnd
    ________________________________________

    ; TODO traduction

    ; Correction [CRCR] et [LFLF] en [CRLF]
    ________________________________________

L1: Comp W$esi CRCR = S1>

        Comp W$esi LFLF = S1>

        add esi (2*ASCII)

    Comp esi edx < L1<,
                 => S2>

S1:     Mov W$esi CRLF

        add esi (2*ASCII)

    Comp esi edx < L1<
    __________________________________

    ; TODO traduction

    ; Suppression des [SPC] superflus
    __________________________________

    ; Esi = D$CodeSource
S2: Mov esi edi

    jmp S3>

L1:@Start:

    stosb

S3:     Comp esi edx > S0> ; @End

            lodsb

            Comp al 0_22 = S4> ; " @Clean022

            Comp al 0_27 = S5> ; ' @Clean027

            Comp al 0_3B = S6> ; ; @Clean03B

            Comp al CR = S7>   ;   @Clean020

    jmp L1< ; @Start

S4:@Clean022:

L0:             stosb | lodsb | Comp esi edx = S0> ; @End

                Comp al '"'  <> L0< ; Allow blank Lines in Data Text

    jmp L1< ; @Start

S5:@Clean027:

L0:             stosb | lodsb | Comp esi edx = S0> ; @End

                Comp al "'" <> L0<

    jmp L1< ; @Start

S6:@Clean03B:

            Comp D$esi-2 MLC <> L2> ; LF;;CR

L0:             stosb | lodsb | Comp esi edx = S0> ; @End

                Comp D$esi-(2*ASCII) MLC <> L0<

    jmp L1< ; @Start

L2:             stosb | lodsb | Comp al CR <> L2<

S7:@Clean020:

L0:         Comp B$edi-1 SPC <> L1< ; @Start

                sub edi (1*ASCII) | sub D$SourceLen 1 | sub D$STRUCT.EditData@SourceEnd 1

            jmp L0< ; @Start

S0:@End:   Mov eax D$STRUCT.EditData@SourceEnd

    cmp W$eax-(1*WORD) CRLF | je P9> ; TODO ExitP

    cmp W$eax-(1*WORD) LFCR | je P9> ; TODO ExitP

        Mov W$eax CRLF | add D$STRUCT.EditData@SourceEnd (2*ASCII) | add D$SourceLen (2*ASCII)


EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

WheelMsg:

    Call KillCompletionList

    test W$Wparam+(1*WORD) 0_FFFF NEGATIVE S1>

        Call UpOneLine

ret

S1: Call DownOneLine

ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; Positioning Edition at 'MainWindowProc' or at 'Main' or at Top:

StartEdition:
    Call GetEditWindowClientRectangle

    ;Call ScanSourceForBadChars

    Mov edx CallBackName, ebx D$CallBackNameLen

    Call InternSearch

    On D$FL.BlockInside = &TRUE, jmp L9>
        Mov edx EntryPointLabel, ebx 0, eax edx
        While B$eax <> 0 | inc ebx | inc eax | End_While

        Call InternSearch

L9: Mov B$OnReplaceAll &FALSE, D$FL.BlockInside &FALSE, B$DownSearch &TRUE, D$FL.ReadyToRun &FALSE
    Call StorePosInBackTable

    Mov D$TABLE.Titles &NULL, D$PreviousPartialSourceLen 0

    Call ReplaceParagraphByDollar
ret


GetEditWindowClientRectangle:
    Call 'USER32.GetClientRect' D$H.EditWindow RECT
      Mov eax D$RECTright | sub eax D$RECTleft
      shr eax 3 | dec eax | Mov D$STRUCT.EditData@ColNumber eax
        Mov eax D$RECTbottom | sub eax D$RECTtop
          or eax 00111 | xor eax 00111
            shr eax 4 | dec eax | Mov D$STRUCT.EditData@LineNumber eax
ret


ReplaceParagraphByDollar:
    Mov eax D$CodeSource, ecx D$STRUCT.EditData@SourceEnd

    While eax < ecx
      ; 167 = Code of Paragraph Char (yet available as keyboard input, but no more
      ; available as screen output).
        If D$eax = MLC
            add eax 4
            While D$eax <> MLC
                On eax = ecx, jmp L9>>
                inc eax
            End_While
            add eax 2

        Else_If B$eax = ';'
            While B$eax > CR
                inc eax | On eax = ecx, jmp L9>>
            End_While

        Else_If B$eax = '"'
            inc eax
            While B$eax <> '"'
                inc eax | On eax = ecx, jmp L9>>
            End_While

        Else_If B$eax = "'"
            inc eax
            While B$eax <> "'"
                inc eax | On eax = ecx, jmp L9>>
            End_While

        Else_If B$eax = 167
            Mov B$eax '$'

        End_If

        inc eax
    End_While

L9: ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[H.Help: D$ ?]
[RosAsmHelpClassName: B$ 'RosAsmHelpEditClass' EOS]

; We close B_U_Asm if run from BUAsm:

CloseHelp:

    Call 'KERNEL32.CreateMutexA' &NULL,
                                 &TRUE,
                                 {B$'BaseMutexName' EOS}

    Call 'KERNEL32.GetLastError'

    .If eax = &ERROR_ALREADY_EXISTS

        Call 'USER32.FindWindowA' RosAsmHelpClassName,
                                  &NULL

         Mov D$H.Help eax

        Call 'USER32.GetWindowLongA' eax,
                                     &GWL_EXSTYLE

        If eax <> &WS_EX_WINDOWEDGE  ; WS_EX value if auto-run

            ; If run from RosAsm
            Call 'USER32.SendMessageA' D$H.Help,
                                       &WM_CLOSE,
                                       &NULL,
                                       &NULL

        End_If

    .End_If

ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; Simplified version of 'RightClick' Search (used by 'StartEdition' to point out 'Main' or
; MainWindowProc:

InternSearch:
    Mov B$InsideMLC &FALSE, B$InsideComment &FALSE
    Mov ah B$edx | or ah 32                           ; ah = first char
    inc edx                                           ; edx > second char (> edi)
    sub ebx 1

    ; Now, edi (edx) > start+1 of right clicked word; ebx = len-1. Search fitting:
L0: Mov esi D$CodeSource, ecx D$SourceLen, B$InsideBracket &FALSE, B$InsideComment &FALSE

    jmp L0>

T0: lodsb | jmp L1>                          ; simplified loop for strip texts and comments
T1: loop T0<
      ret

L0: lodsb | cmp al ah | je L3>>              ; test XORed AH each pass in order to handle
            xor ah 32 | cmp al ah | je L3>>  ; case without modifying AL (following tests)
      jmp L1>
L2: loop L0<
        ret

L1: cmp B$InsideMLC &TRUE | jne L1>
      cmp D$esi-2 MLC | jne T1<          ; (LF ; ; CR)
        Mov B$InsideMLC &FALSE | jmp L2<
L1: cmp B$InsideComment &TRUE | jne L1>
      cmp al LF  | jne T1<
        Mov B$InsideComment &FALSE | jmp L2<
L1: cmp B$InsideText &FALSE | je L1>
      cmp al B$InsideText | jne T1<
        Mov B$InsideText &FALSE | jmp L2<
L1: cmp al "'" | jne L1>
      Mov B$InsideText al | jmp T1<
L1: cmp al '"' | jne L1>
      Mov B$InsideText al | jmp T1<
L1: cmp al '[' | jne L1>
      Mov B$InsideBracket &TRUE, B$DataDeclaration &FALSE    ;;;, B$OddWord 1
S0:   cmp B$esi SPC | jne L2<
        inc esi | sub ecx 1 | jnc S0<        ; strip double spaces
          ret
L1: cmp al ']' | jne L1>
      Mov B$InsideBracket &FALSE, B$DataDeclaration &FALSE | jmp L2<<
L1: cmp al ';' | jne L1>                     ; jmp over comments
        If D$esi-2 = MLC   ; (LF ; ; CR)
            Mov B$InsideMLC &TRUE | jmp T1<<
        Else
            Mov B$InsideComment &TRUE | jmp T1<<
        End_If
L1: cmp al '|' | jne L1>
      Mov B$InsideBracket &FALSE | jmp L2<<
L1: cmp al ':' | jne L2<<
      Mov B$DataDeclaration &TRUE

            jmp L2<<                     ; (avoids pointing equates datas).

L3: Mov al B$esi-2 | Call WordEdge | cmp B$Edge &FALSE | je L2<<     ; left edge?

        Mov D$NumberDashLines 0

        pushad | Mov ecx ebx, edi edx
C0:       lodsb | Mov ah B$edi | inc edi | or ax 02020     ; case insensitive comparison

            While B$esi-1 = '_'
                lodsb | or al SPC | inc D$NumberDashLines
            End_While

            While B$edi-1 = '_'
                Mov ah B$edi | or ah SPC | inc edi | dec ecx | jz C1>
            End_While

          cmp ah al | jne C1>
            loop C0<

            Mov al B$esi | Call WordEdge
            If B$Edge = &FALSE
                popad | jmp L2<<
            End_If
            popad | jmp C2>

C1:     popad | jne L2<<

   ; Mov al B$esi+ebx | Call WordEdge | cmp B$Edge &FALSE | je L2<<    ; right edge?

; as we have tested for '|' (> InsideBracket = FALSE), "test B$OddWord 1" applies either
; uppon first word of macro def. or odd word of equate def. But data body could still
; be pointed as odd equate dec. So we finally test 'B$DataDeclaration'.

C2: Push ebx
        add ebx D$NumberDashLines
        cmp B$esi+ebx ':'
    Pop ebx
    je L4>                                 ; Label?
      cmp B$InsideBracket &TRUE | jne L2<<                     ; equ. / macro
          cmp B$DataDeclaration &TRUE | je L2<<  ; avoid pointing data body instead of Equate

L4: dec esi                                                    ; found
    Mov D$LP.BlockStartText esi, D$RCstart esi                 ; RCstart/End used by

    add esi ebx

    Mov D$LP.BlockEndText esi,
        D$RCend esi       ; 'BackClick'

    Mov D$FL.BlockInside &TRUE
    inc esi | Mov D$STRUCT.EditData@CurrentWritingPos esi

    std | Mov ecx 0
L5:     lodsb | inc ecx | cmp al LF | jne L5<                  ; search for start of line
    cld | dec ecx

    add esi 2 | Mov D$STRUCT.EditData@UpperLine esi                            ; and set all needed
    Call UpOneLine | Call UpOneLine | Call UpOneLine           ; variables for Pos, in
    Mov D$STRUCT.EditData@CaretLine 3, D$STRUCT.EditData@CaretRow ecx, D$STRUCT.EditData@PhysicalCaretRow ecx  ; case user wish editing
    Call TryToMove

L9: ret
____________________________________________________________________________________________

; [F11] / [F12] instant BookMark feature

[F11Upperline: D$ ?
 F11CurrentWritingPos: D$ ?
 F11CaretLine: D$ ?
 F11CaretRow: D$ ?]

SavePosOnF11:
    Call ClearF12
    Call RestoreRealSource
    Move D$F11Upperline D$STRUCT.EditData@Upperline, D$F11CurrentWritingPos D$STRUCT.EditData@CurrentWritingPos,
         D$F11CaretLine D$STRUCT.EditData@CaretLine, D$F11CaretRow D$STRUCT.EditData@CaretRow
    Call SetPartialEditionFromPos
ret


[F12Upperline: D$ ?
 F12CurrentWritingPos: D$ ?
 F12CaretLine: D$ ?
 F12CaretRow: D$ ?]

SetPosOnF12:
    ..If D$F11Upperline <> 0
        Call RestoreRealSource

        Mov eax D$STRUCT.EditData@Upperline

      ; If we are not already at the saved F11 Pos, we go to it:
        .If eax <> D$F11Upperline
          ; Save first the actual F12 Pos for On-Off effect:
            Move D$F12Upperline D$STRUCT.EditData@Upperline, D$F12CurrentWritingPos D$STRUCT.EditData@CurrentWritingPos,
                 D$F12CaretLine D$STRUCT.EditData@CaretLine, D$F12CaretRow D$STRUCT.EditData@CaretRow
          ; Go:
            Move D$STRUCT.EditData@Upperline D$F11Upperline, D$STRUCT.EditData@CurrentWritingPos D$F11CurrentWritingPos,
                 D$STRUCT.EditData@CaretLine D$F11CaretLine, D$STRUCT.EditData@CaretRow D$F11CaretRow

        .Else
          ; Pos is the one save by F11: we switch back to the F12 previous Pos:
            If D$F12Upperline <> 0
                Move D$STRUCT.EditData@Upperline D$F12Upperline, D$STRUCT.EditData@CurrentWritingPos D$F12CurrentWritingPos,
                     D$STRUCT.EditData@CaretLine D$F12CaretLine, D$STRUCT.EditData@CaretRow D$F12CaretRow
            End_If

        .End_If

        Call SetPartialEditionFromPos

        Mov esi D$STRUCT.EditData@Upperline
        While B$esi-1 <> LF | dec esi | End_While
        Mov D$STRUCT.EditData@Upperline esi

    ..End_If
ret


ClearF11F12:
    Mov edi F11Upperline, eax 0, ecx 4 | rep stosd
ClearF12:
    Mov edi F12Upperline, eax 0, ecx 4 | rep stosd
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[EditorLOGFONT:
 @lfHeight: D$ 0_FFFF_FFF3
 @lfWidth: D$ 0
 @lfEscapement: D$ 0
 @lfOrientation: D$ 0
 @lfWeight: D$ 02BC
 @lfItalic: B$ 0
 @lfUnderline: B$ 0
 @lfStrikeOut: B$ 0
 @lfCharSet: B$ 0
 @lfOutPrecision: B$ 03
 @lfClipPrecision: B$ 02
 @lfQuality: B$ 01
 @lfPitchAndFamily: B$ 031
 @lfFaceName: B$ 'Courier New' EOS
 @Trailing: B$ 0 # &LF_FACESIZE
 EditorLOGFONT.len: Len]

[EditorCHOOSEFONT:
 @lStructSize: D$ len
 @hwndOwner: D$ 0
 @hDC: D$ &NULL
 @lpLogFont: D$ EditorLOGFONT
 @iPointSize: D$ 0
 @Flags: D$
 &CF_FIXEDPITCHONLY__&CF_SCREENFONTS__&CF_INITTOLOGFONTSTRUCT__&CF_APPLY__&CF_ENABLEHOOK__&CF_NOSIMULATIONS
 @rgbColors: D$ 0
 @lCustData: D$ 0
 @lpfnHook: D$ ChooseFontHook
 @lpTemplateName: D$ 0
 @hInstance: D$ 0
 @lpszStyle: D$ 0
 @nFontType: W$ &SCREEN_FONTTYPE
 @Alignment: W$ 0
 @nSizeMin: D$ 0
 @nSizeMax: D$ 0]

[HDC.EditFont: D$ ?]

[TEXTMETRICA:
 @Height: D$ ?
 @Ascent: D$ ?
 @Descent: D$ ?
 @InternalLeading: D$ ?
 @ExternalLeading: D$ ?
 @AveCharWidth: D$ ?
 @MaxCharWidth: D$ ?
 @Weight: D$ ?
 @Overhang: D$ ?
 @DigitizedAspectX: D$ ?
 @DigitizedAspectY: D$ ?
 @FirstChar: B$ ?
 @LastChar: B$ ?
 @DefaultChar: B$ ?
 @BreakChar: B$ ?
 @Italic: B$ ?
 @Underlined: B$ ?
 @StruckOut: B$ ?
 @PitchAndFamily: B$ ?
 @CharSet: B$ ?]

[FontHeight: D$ 16
 FontWidth: D$ 8]

; React to the [Apply] Button (&CF_APPLY__&CF_ENABLEHOOK, in EditorCHOOSEFONT@Flags):

Proc ChooseFontHook:
    Arguments @hwnd, @msg, @wParam, @lParam

            .If D@msg = &WM_COMMAND
                If D@wParam = 0402
                    Call LoadFont | Call AskForRedrawNow
                    Mov eax &TRUE | ExitP
                End_If
            .End_If

    Mov eax &FALSE
EndP


SelectFont:
    Move D$EditorCHOOSEFONT@hwndOwner D$H.ConfigDialog
    Call 'Comdlg32.ChooseFontA' EditorCHOOSEFONT

    If eax = &TRUE
        Call LoadFont | Call AskForRedrawNow | Call MainResize
    End_If
ret


LoadFont:
    On D$H.Font1 <> 0, Call 'GDI32.DeleteObject' D$H.Font1
    Call 'GDI32.CreateFontIndirectA' EditorLOGFONT | Mov D$H.Font1 eax
    Call 'USER32.GetDC' D$H.EditWindow | Mov D$HDC.EditFont eax
    Call 'GDI32.SetMapMode' eax &MM_TEXT
    Call 'GDI32.SelectObject' D$HDC.EditFont, D$H.Font1
    Call 'GDI32.GetTextMetricsA' D$HDC.EditFont, TEXTMETRICA

    Mov eax D$TEXTMETRICA@AveCharWidth | Mov D$FontWidth eax
    Mov eax D$TEXTMETRICA@Height | Mov D$FontHeight eax
ret


LoadNationalFont:
    Call 'GDI32.CreateFontIndirectA' NATION_LOGFONT | Mov D$H.NationalFont eax
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Undo            ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;;
  Undo feature; 2046 events are stored in UndoTable:
  
  Note: 'DoStoreBP' is in the DCBP TITLE and, as the 'UnDoStoreBP' job is done by
  'AdjustBpTable' and 'AdjustDownwardPointers', there is no 'UnDoStoreBP' Routine.
  
  ____________________
  Undo Table Routines:
  
  'InitUndo', 'KillUndo', 'ReInitUndo', 'ReadUndoRecord'
  
  ______________
  "DoStore" Routines:
  
  'DoStoreInsert', 'DoStoreOverWrite', 'DoStoreCharDelete'
  'DoStoreBlockPaste' (called from 'ControlV', 'AddWizardCode' -???!!!...-)
  'WriteUndoBlockFile' (caled from 'ControlX')
  
  'DoStoreBP' (in DCBP TITLE)
  
  ____________________
  Main "UnDo" Routine: 'ControlZ', calling for:
  
  'ReInsertDeletedChar', 'UndoBlockCopy', 'ReadUndoBlockFile'
  
  __________________________
  Files Managements Routines (for Blocks):
  
  'ResetUndoFileName', 'IncUndoFileName', 'DecUndoFileName', 'DeleteUndoFiles'
  'DeleteOldUndoFiles'
  _____________
  ReDo Routines:
  
  'ControlShiftZ' >>> 'ReInsertSource'

;;
________________________________________________________________________________________
________________________________________________________________________________________

[UndoPtr: D$ ?
 UndoMemory: D$ ?] ; BuildTitleTable
;;
 The Undo Table is a rotary table 010000 sized for 2048 (0800h) records of 8 dWords:
;;

; Undo Flags:

[ACTION_INSERT 1, ACTION_OVERWRITE 2, ACTION_BLOCKCOPY 3, ACTION_BLOCKDELETE 4
 ACTION_DCBP 5, ACTION_DELDCBP 6, ACTION_DEL 7]

;[UNO_N_CHARS ecx  UNDOCHAR ebx  UNDOBLOCKBEGIN ebx  UNDOBLOCKEND edx  UNDOFLAG eax]

; Displacements Equates for pointing into one 'UndoMemory' Record:
; 0FFFF
[RECORD_CARET_ROW 0
 RECORD_CARET_LINE 4
 RECORD_CURRENTWRITINGPOS 8
 RECORD_ACTUALTITLE 12
 RECORD_UPPERLINE 16

 RECORD_PARAM1 20
 RECORD_PARAM2 24

 RECORD_FLAG 28

 UNDO_RECORD 32]
____________________________________________________________________________________________
____________________________________________________________________________________________

; The Undo Buffer Managements:

InitUndo:

    Call VirtualAlloc UndoMemory,
                      01_0000

    Move D$UndoPtr D$UndoMemory

ret


KillUndo:

   Call VirtualFree UndoMemory

ret


ReInitUndo:

    test D$CompletionWanted &TRUE ZERO S1>

    Call VirtualFree CompletionTable

    Call VirtualFree CompletionPointers

S1: Call ClearF11F12

    Mov D$TABLE.Titles &NULL, D$LP.ActualTitle &NULL

ReInitUndoOnly:

    Call DeleteUndoFiles

    Call KillUndo

    Call InitUndo

    Call CloseTree

    Call VirtualFree LP.MEM.TABLE.BreakPoints

ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; The centralized Storing Routines

Proc StoreUserAction:
    Argument @Flag, @Param1, @Param2
    Uses eax, ecx, edi

        Mov edi D$UndoPtr
    ; action_insert

        Move D$edi+RECORD_CARET_ROW D$STRUCT.EditData@CaretRow
        Move D$edi+RECORD_CARET_LINE D$STRUCT.EditData@CaretLine
        Mov eax D$STRUCT.EditData@CurrentWritingPos | sub eax D$CodeSource
        Mov D$edi+RECORD_CURRENTWRITINGPOS eax
        Move D$edi+RECORD_ACTUALTITLE D$LP.ActualTitle
        Mov eax D$STRUCT.EditData@UpperLine | sub eax D$CodeSource | Move D$edi+RECORD_UPPERLINE eax

        Move D$edi+RECORD_PARAM1 D@Param1
        Move D$edi+RECORD_PARAM2 D@Param2

        Move D$edi+RECORD_FLAG D@Flag

        On D$TABLE.BreakPointsOn <> &NULL Call AdjustBreakPointTable D@Flag

      ; Prepare the Undo Table Pointer for next registration:
        Mov edi D$UndoPtr | add di 32 | Mov D$UndoPtr edi
      ; Clear the next Record:
        Mov eax 0, ecx 8 | rep stosd
EndP


DoStoreInsert:
  ; The Callers set the Number of Chars into ebx. (Usefull for Tab Spaces):
    Call StoreUserAction ACTION_INSERT, ebx, D$InsertedChar
ret


DoStoreOverWrite:
  ; The Caller sets the overwritten Char into cl, and the new Char in al:
    and ecx 0FF | and eax 0FF
    Call StoreUserAction ACTION_OVERWRITE, ecx, eax
ret


DoStoreCharDelete:
  ; ebx set to BACK or FORTH by callers: 'BackSpace' 'StripOneChar'
    Mov esi D$STRUCT.EditData@CurrentWritingPos | movzx eax B$esi-1
  ; eax is the deleted Char:
    Call StoreUserAction ACTION_DEL, eax, ebx
ret


DoStoreBlockPaste:
    pushad
        Mov ebx D$STRUCT.EditData@CurrentWritingPos                       ; block start
        Mov edx ebx | add edx D$ClipBoardLen | dec edx    ; block end

        sub ebx D$CodeSource | sub edx D$CodeSource
        Call StoreUserAction ACTION_BLOCKCOPY, ebx, edx

        Call WriteUndoBlockFileFromClipBoard
    popad
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; The Undo Files Managements. (They are only used for the Blocks Selections Operations).

IncUndoFileName:
    Mov eax D$PointerToUndoNumber
    inc B$eax+2 | cmp B$eax+2 '9' | jbe L9>
    Mov B$eax+2 '0'
    inc B$eax+1 | cmp B$eax+1 '9' | jbe L9>
    Mov B$eax+1 '0'
    inc B$eax
L9: ;Showme D$PointerToUndoNumber

    ret

DecUndoFileName:
    ;Call 'KERNEL32.DeleteFileA' UndoFile ; Keep it, now, for Redo!!!!
    Mov eax D$PointerToUndoNumber
    dec B$eax+2 | cmp B$eax+2 '0' | jae L9>
    Mov B$eax+2 '9'
    dec B$eax+1 | cmp B$eax+1 '0' | jae L9>
    Mov B$eax+1 '9'
    dec B$eax
L9: ret


[H.UndoFile: D$ ?]

WriteUndoBlockFileFromBlock: ; ControlV ControlX
L0: Call IncUndoFileName | Mov eax UndoFile
    Call 'KERNEL32.CreateFileA' eax, &GENERIC_WRITE, 0, 0, &CREATE_ALWAYS,
                                &FILE_ATTRIBUTE_NORMAL, 0
    Mov D$H.UndoFile eax

    If eax = &INVALID_HANDLE_VALUE
        Call KillUndo | Call InitUndo
        Call SetUndoDirectory | jmp L0<
    End_If

    Mov ecx D$LP.BlockEndText | sub ecx D$LP.BlockStartText | add ecx (1*ASCII)

    Call 'KERNEL32.WriteFile' D$H.UndoFile, D$LP.BlockStartText, ecx, NumberOfReadBytes, 0
    Call 'KERNEL32.CloseHandle' D$H.UndoFile
ret


WriteUndoBlockFileFromClipBoard: ; ControlV ControlX
L0: Call IncUndoFileName | Mov eax UndoFile
    Call 'KERNEL32.CreateFileA' eax, &GENERIC_WRITE, 0, 0, &CREATE_ALWAYS,
                                &FILE_ATTRIBUTE_NORMAL, 0
    Mov D$H.UndoFile eax

    If eax = &INVALID_HANDLE_VALUE
        Call KillUndo | Call InitUndo
        Call SetUndoDirectory | jmp L0<
    End_If
    Call 'KERNEL32.WriteFile' D$H.UndoFile, D$ClipBoardPtr, D$ClipBoardLen,
                              NumberOfReadBytes, 0

    Call 'KERNEL32.CloseHandle' D$H.UndoFile
ret


[UndoBlockLen: D$ ?]
;;
  Called from 'ControlZ'. A Selection has been Delete, and save into an Undo File. 
  we re-paste this Selection:
;;
ReadUndoBlockFile: ; ControlX

    Mov D$LP.BlockStartText ebx,
        D$LP.BlockEndText ecx

    Call 'KERNEL32.CreateFileA' UndoFile, &GENERIC_READ, 0, 0, &OPEN_EXISTING,
                                &FILE_ATTRIBUTE_NORMAL, 0

    .If eax <> &INVALID_HANDLE_VALUE
        Mov D$H.UndoFile eax, D$NumberOfReadBytes 0

        Call 'KERNEL32.GetFileSize' eax, 0 | Mov D$UndoBlockLen eax
        add D$SourceLen eax | add D$STRUCT.EditData@SourceEnd eax

        Mov esi D$STRUCT.EditData@SourceEnd | add esi 400 | Mov edi esi | add edi eax
        Mov ecx edi | sub ecx D$STRUCT.EditData@CurrentWritingPos | std | rep movsb | cld
        Call 'KERNEL32.ReadFile' D$H.UndoFile, D$STRUCT.EditData@CurrentWritingPos,
                                 D$UndoBlockLen, NumberOfReadBytes, 0

        Call 'KERNEL32.CloseHandle' D$H.UndoFile
    .End_If
ret


StoreUserActionOfBlockDeletion:
    Push D$STRUCT.EditData@CurrentWritingPos
        Move D$STRUCT.EditData@CurrentWritingPos D$LP.BlockStartText
        Mov eax D$LP.BlockStartText | sub eax D$CodeSource

        Mov ebx D$LP.BlockEndText | sub ebx D$CodeSource

        Call StoreUserAction ACTION_BLOCKDELETE, eax, ebx
    Pop D$STRUCT.EditData@CurrentWritingPos
ret


DeleteUndoFiles:
    Mov eax D$PointerToUndoNumber | cmp D$eax '000.' | je L9>
L1:     Call 'KERNEL32.DeleteFileA' UndoFile
            Call DecUndoFileName
            Mov eax D$PointerToUndoNumber | cmp D$eax '000.' | ja L1<
L9: ret


; Undo Files WIN32_FIND_DATA Structure:

[DelUndo:
 @dwFileAttributes: D$ ?
 @ftCreationTime.dwLowDateTime: D$ ?
 @ftCreationTime.dwHighDateTime: D$ ?
 @ftLastAccessTime.dwLowDateTime: D$ ?
 @ftLastAccessTime.dwHighDateTime: D$ ?
 @ftLastWriteTime.dwLowDateTime: D$ ?
 @ftLastWriteTime.dwHighDateTime: D$ ?
 @nFileSizeHigh: D$ ?
 @nFileSizeLow: D$ ?
 @dwReserved0: D$ ?
 @dwReserved1: D$ ?
 @cFileName: B$ ? # &MAX_PATH
 @cAlternate: B$ ? # 14]

[H.DelUndo: D$ ?]

DeleteOldUndoFiles:
    Call 'KERNEL32.FindFirstFileA' AllUndoFiles2 DelUndo

    If eax <> &INVALID_HANDLE_VALUE
        Mov D$H.DelUndo eax
L0:     Call 'KERNEL32.DeleteFileA' DelUndo@cFileName
        Call 'KERNEL32.FindNextFileA' D$H.DelUndo DelUndo
        cmp eax &TRUE | je L0<

        Call 'KERNEL32.FindClose' D$H.DelUndo
    End_If

    Mov edi D$PointerToUndoNumber, eax '000.' | stosd
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; Main undo routine:

[ControlZreRunForCRLF: D$ ?]
[BackOrForth: D$ ?]

ControlZ:
    Mov D$FL.BlockInside &FALSE

    If D$H.DebugDialog <> 0
        Call CloseDebuggerOrIgnore | On eax = &IDNO jmp L9>>
    End_If

    Mov ebx D$UndoPtr | sub bx UNDO_RECORD
    cmp D$ebx+RECORD_FLAG 0 | je L9>>   ; depend on flag > 0 > End
        Mov D$UndoPtr ebx

    If D$TABLE.BreakPointsOn <> &NULL
        pushad
            Call AdjustBreakPointTable, ControlZ
        popad
    End_If

    Call ReadUndoRecord

  ; >>> eax = RECORD_FLAG, ebx = RECORD_PARAM1, ecx = RECORD_PARAM2

    .If eax = ACTION_INSERT
        Mov ecx ebx, ebx D$STRUCT.EditData@CurrentWritingPos
        If B$ebx-1 = LF
            Call StripBackSpace
            Mov ebx D$UndoPtr | sub bx 32 | Mov D$UndoPtr ebx
            Call StripBackSpace
            dec D$STRUCT.EditData@CurrentWritingPos, D$STRUCT.EditData@CaretRow
        Else
L1:         Push ecx
                Call StripBackSpace
            Pop ecx
            dec D$STRUCT.EditData@CaretRow
            loop L1<
        End_If

    .Else_If eax = ACTION_OVERWRITE
        dec D$STRUCT.EditData@CaretRow | Mov edi D$STRUCT.EditData@CurrentWritingPos, eax ebx | stosb

    .Else_If eax = ACTION_DEL
; Why this complicated stuff around 'ControlZreRunForCRLF': We may have to undo a CR/LF
; arasement done either by [BackSpace] or by [Del]. With [backSpace], we have first arased
; the LF and then the CR. With [Del], we have arased in the other way.
        Mov D$BackOrForth ecx
        If ebx = CR
            dec D$STRUCT.EditData@CurrentWritingPos | xor B$ControlZreRunForCRLF &TRUE
            Call ReInsertDeletedChar
            On B$ControlZreRunForCRLF = &TRUE, jmp ControlZ

        Else_If ebx = LF
            dec D$STRUCT.EditData@CurrentWritingPos | xor B$ControlZreRunForCRLF &TRUE
            Call ReInsertDeletedChar
            On B$ControlZreRunForCRLF = &TRUE, jmp ControlZ
        Else
            dec D$STRUCT.EditData@CurrentWritingPos, D$STRUCT.EditData@CaretRow | Call ReInsertDeletedChar
        End_If

        On D$BackOrForth = FORTH, dec D$STRUCT.EditData@CurrentWritingPos, D$STRUCT.EditData@CaretRow

    .Else_If eax = ACTION_BLOCKDELETE
        add ebx D$CodeSource | add ecx D$CodeSource
        Call ReadUndoBlockFile | Call DecUndoFileName

    .Else_If eax = ACTION_BLOCKCOPY
      ; 'DoStoreBlockPaste'
        add ebx D$CodeSource | add ecx D$CodeSource
        Call UndoBlockCopy | Call DecUndoFileName

    .Else_If eax = ACTION_DCBP
      ; 'DoStoreBp', 'DoStoreInsert', 'ReadUndoRecord'
        Mov D$BreakPointLocation ebx
        Call DeleteBreakPoint

    .Else_If eax = ACTION_DELDCBP
        Mov D$BreakPointLocation ebx
        Call SetBreakPoint

    .End_If

    Call AskForRedraw
L9: ret
____________________________________________________________________________________________
;;
All the Pointers in UndoPtr Table are turned into Displacements from the 'CodeSource'
origin. This origin is continuously moving when the Source increases or decreases.
;;
ReadUndoRecord:
    Mov esi D$UndoPtr

  ; When storing BPs, the Sources Pos are the ones of the Real Source. So:
   ; If D$esi+RECORD_FLAG = ACTION_DCBP
   ;     Mov ebx D$esi+RECORD_PARAM1, eax ACTION_DCBP | ret
   ; End_If

    Mov eax D$LP.ActualTitle

    If eax <> D$esi+RECORD_ACTUALTITLE
        Push esi
            Call RestoreRealSource
        Pop esi

        Mov eax D$esi+RECORD_CURRENTWRITINGPOS
        add eax D$esi+RECORD_ACTUALTITLE
        Mov D$STRUCT.EditData@CurrentWritingPos eax
        Move D$STRUCT.EditData@UpperLine D$esi+RECORD_UPPERLINE

        Push esi
            Call SetPartialEdition
        Pop esi
    End_If

    Move D$STRUCT.EditData@CaretRow D$esi+RECORD_CARET_ROW
    Move D$STRUCT.EditData@CaretLine D$esi+RECORD_CARET_LINE
    Mov eax D$esi+RECORD_CURRENTWRITINGPOS | add eax D$CodeSource | Mov D$STRUCT.EditData@CurrentWritingPos eax
    Mov eax D$esi+RECORD_UPPERLINE | add eax D$CodeSource | Mov D$STRUCT.EditData@UpperLine eax

    Mov eax D$esi+RECORD_FLAG, ebx D$esi+RECORD_PARAM1, ecx D$esi+RECORD_PARAM2
ret
____________________________________________________________________________________________

; Called by 'ControlZ':

ReInsertDeletedChar:
    MRealCaretRow

    Mov esi D$STRUCT.EditData@SourceEnd | add esi 400 | Mov edi esi      ; 400 is security 13/10/...
    Mov ecx esi | sub ecx D$STRUCT.EditData@CurrentWritingPos | inc ecx

    Mov eax ebx

    cmp al TAB | jne L1>
        cmp D$TabIs &TRUE | jne L2>
L1:         inc edi
            std
                rep movsb | stosb
            cld
            Mov ebx 1 | jmp L3>

L2:     Mov ebx D$TabIs | add edi ebx
        std
          rep movsb | Mov al SPC, ecx ebx | rep stosb
        cld

L3: add D$SourceLen ebx | add D$STRUCT.EditData@CurrentWritingPos ebx | add D$STRUCT.EditData@SourceEnd ebx

    Mov eax D$STRUCT.EditData@ColNumber

    cmp D$STRUCT.EditData@CaretRow  eax | jae L4>
    add D$STRUCT.EditData@CaretRow ebx | jmp L9>

L4: AlignOn RIGHT_FEED ebx | add D$STRUCT.EditData@RightScroll ebx | sub D$STRUCT.EditData@CaretRow ebx | dec D$STRUCT.EditData@CaretRow

L9: ret


UndoBlockCopy:

    Mov D$LP.BlockStartText ebx,
        D$LP.BlockEndText ecx,
        D$FL.BlockInside &TRUE

    Call UndoControlV
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[BACK 1, FORTH 0]

ControlShiftZ: ; ControlZ
    If D$H.DebugDialog <> 0
        Call CloseDebuggerOrIgnore | On eax = &IDNO jmp L9>>
    End_If

    Mov ebx D$UndoPtr | cmp D$ebx+RECORD_FLAG 0 | je L9>>   ; depend on flag > 0 > End
        Mov D$UndoPtr ebx

    If D$TABLE.BreakPointsOn <> &NULL
        pushad
            Call AdjustBreakPointTable, ControlShiftZ
        popad
    End_If

    Call ReadUndoRecord
  ; >>> eax = RECORD_FLAG, ebx = RECORD_PARAM1, ecx = RECORD_PARAM2

    ..If eax = ACTION_INSERT
      ; RECORD_PARAM1 = Number of Chars // RECORD_PARAM2 = Char
        dec D$STRUCT.EditData@CaretRow | sub D$STRUCT.EditData@CurrentWritingPos ebx
        Mov al cl, ecx ebx

L0:     Push eax, ecx
            If al = CR
                Call ReInsertSource | Mov al LF | add D$UndoPtr UNDO_RECORD
            End_If
            Call ReInsertSource
        Pop ecx, eax
        loop L0<

    ..Else_If eax = ACTION_OVERWRITE
      ; RECORD_PARAM1 = Overwritten Char // RECORD_PARAM2 = New Char
        Mov edi D$STRUCT.EditData@CurrentWritingPos, B$edi cl

    ..Else_If eax = ACTION_DEL ; 'DoStoreCharDelete' <<< 'BackSpace" // 'StripOneChar'
      ; RECORD_PARAM1 = Char // RECORD_PARAM2 = BACK, or FORTH
        .If ecx = FORTH
            If B$STRUCT.EditData@CurrentWritingPos = CR
                Call StripBackSpace
                Call StripBackSpace
                add D$UndoPtr UNDO_RECORD
            Else
                Call StripBackSpace
                dec D$STRUCT.EditData@CurrentWritingPos
            End_If
        .Else
            Call StripBackSpace
            dec D$STRUCT.EditData@CurrentWritingPos
            Mov eax D$STRUCT.EditData@CurrentWritingPos | dec eax
            If B$eax = CR
                Mov D$STRUCT.EditData@CurrentWritingPos eax
                Call StripBackSpace
                Call SetCaret D$STRUCT.EditData@CurrentWritingPos
                add D$UndoPtr UNDO_RECORD
            End_If
        .End_If

    ..Else_If eax = ACTION_BLOCKDELETE

        add ebx D$CodeSource | add ecx D$CodeSource

        Mov D$LP.BlockStartText ebx, D$LP.BlockEndText ecx

        Call WriteUndoBlockFileFromBlock | Call UndoControlV

        Mov ecx D$LP.BlockEndText | sub ecx D$LP.BlockStartText | add ecx (1*ASCII)

        sub D$STRUCT.EditData@CurrentWritingPos ecx | sub D$STRUCT.EditData@CaretRow ecx

    ..Else_If eax = ACTION_BLOCKCOPY
        add ebx D$CodeSource | add ecx D$CodeSource
        Call IncUndoFileName | Call ReadUndoBlockFile
        Mov eax D$UndoBlockLen | add D$STRUCT.EditData@CurrentWritingPos eax | add D$STRUCT.EditData@CaretRow eax

    ..Else_If eax = ACTION_DCBP
        Mov D$BreakPointLocation ebx
        Call SetBreakpoint

    ..Else_If eax = ACTION_DELDCBP
        Mov D$BreakPointLocation ebx
        Call DeleteBreakpoint

    ..End_If

    add D$UndoPtr UNDO_RECORD

    Call AskForRedraw
ret


; Simplified 'InsertSource':

ReInsertSource:
    Mov esi D$STRUCT.EditData@SourceEnd | add esi 400 | Mov edi esi      ; 400 is security 13/10/...
    Mov ecx esi | sub ecx D$STRUCT.EditData@CurrentWritingPos | inc ecx

L1: inc edi
    std
        rep movsb | stosb
    cld
    Mov ebx 1 | jmp L3>

L3: add D$SourceLen ebx | add D$STRUCT.EditData@CurrentWritingPos ebx | add D$STRUCT.EditData@SourceEnd ebx

    Mov eax D$STRUCT.EditData@ColNumber

    cmp D$STRUCT.EditData@CaretRow  eax | jae L4>
    add D$STRUCT.EditData@CaretRow ebx | jmp L9>
L4: Push ebx
        AlignOn RIGHT_FEED ebx | add D$STRUCT.EditData@RightScroll ebx | sub D$STRUCT.EditData@CaretRow ebx | inc D$STRUCT.EditData@CaretRow
    Pop ebx

L9: ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT

TITLE WriteCheck      ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
  Write-Time syntax error checker. First Try&See implementation:
  
  Checks for Mnemonics and Macros evocations in Code.
;;


[WriteCheckPointer: D$ ?
 WriteChar: D$ ?
 WriteCheckerThreadID: D$ ?
 WeAreChecking: D$ ?]

[WriteCheckerWanted: D$ ?
 WriteCheckerRuning: D$ ?]

Proc WriteChecker:
    Argument @Pointer, @Char

        On B$WriteCheckerRuning =  &TRUE, ExitP

      ; BackSpace:
        On eax = 8, ExitP

        Mov B$WriteCheckerRuning &TRUE

        pushad

            Mov eax D@Pointer, D$WriteChar 0

            If B$eax-1 <= SPC
                Mov B$WriteCheckerRuning &FALSE

            Else_If B$eax-1 <> ':'
                Mov D$WriteCheckPointer eax | Move D$WriteChar D@Char

                Call 'KERNEL32.CreateThread' &NULL, 0, WriteCheckerThread, 0,
                                             &THREAD_PRIORITY_IDLE, ;THREAD_PRIORITY_NORMAL,
                                             WriteCheckerThreadID
            Else
                Mov B$WriteCheckerRuning &FALSE

            End_If

        popad
EndP
____________________________________________________________________________________________


Proc WriteCheckerThread: ; 'CharMessage'
    Local @Exit @ContinueStatus @hThread

    pushad

      ; The Pointer is given when user hits CRLF, Space or Comma:
        Mov esi D$WriteCheckPointer | sub esi (1*ASCII) | Mov D$LP.BlockEndText esi

      ; We go to start of the word:
L0:     dec esi | cmp B$esi ',' | je L1>
                  cmp B$esi '|' | je L1>
                  cmp B$esi ':' | je L1>
                  cmp B$esi SPC | ja L0<

      ; Keep track of component case, in eax (Either Instruction or Parameter):
L1:     Mov ebx esi | While B$ebx = SPC | dec ebx | End_While
        If B$ebx = '|'
            Mov eax 1
        Else_If B$ebx < SPC
          ; "1" >>> First Component (Mnemonic or Macro)
            Mov eax 1
        Else
          ; "2" >>> Parameter
            Mov eax 2
        End_If

        inc esi | Mov D$LP.BlockStartText esi

      ; Must be a Statement > Color = Statememts Color (1) ?
        Mov ebx esi | sub ebx D$CodeSource | add ebx D$ColorsMap

      ; If Code Color Statement:
        ...If B$ebx = 1
            ..If D$WriteChar = ':'
                Call CheckUniqueSymbol

          ; If Instruction:
            ..Else_If eax = 1

                Mov ecx D$LP.BlockEndText | sub ecx D$LP.BlockStartText

                Mov eax &FALSE

                If ecx < 15
                    Call CheckMnemonic
                End_If

                If eax = &FALSE
                    Call CheckForMacro
                End_If

                .If eax = &FALSE
                    Mov D$FL.BlockInside &TRUE | Call AskForRedrawNow | Call Beep
                .End_If

            ..End_If

      ; If Data Color Statement:
        ...Else_If B$ebx = 2
            ..If D$WriteChar = ':'
                Call CheckUniqueSymbol

            ..Else

            ..End_If

        ...End_If

    popad

    Mov B$WriteCheckerRuning &FALSE

    Call 'KERNEL32.ExitThread' 0
EndP
____________________________________________________________________________________________

[TrashCode: D$ ? # 8]

CheckMnemonic:
    Mov B$WeAreChecking &TRUE

    Mov edi MnemonicCopy, esi D$LP.BlockStartText, D$LineStart esi

    Mov ecx D$LP.BlockEndText | sub ecx esi | add ecx (1*ASCII)

L0: lodsb | and eax (not 32) | stosb | loop L0<
    Mov B$edi 0

    Mov edi TrashCode | Call Encode

    Mov B$WeAreChecking &FALSE


    .If D$FL.CompileErrorHappend = &TRUE

        If eax = NotAnOpcode

            Mov eax &FALSE

        Else

            Mov eax &TRUE

        End_If

    .Else
        Mov eax &TRUE

    .End_If
ret
____________________________________________________________________________________________

; User entered a Colon Char:

CheckUniqueSymbol:
  ; Compute the lenght of the actualy edited Label into ebx:
    Mov esi D$STRUCT.EditData@CurrentWritingPos, ebx 0 | dec esi

  ; Do not check again Exported Labels:
    cmp B$esi-1 ':' | je L9>>

L0: dec esi | inc ebx
    cmp B$esi SPC | jbe L1>
    cmp B$esi '[' | jne L0<

  ; Do not consider Local Labels:
    cmp ebx 3 | jb L9>>

L1: std
        Mov esi D$CodeSource, edx D$STRUCT.EditData@SourceEnd

        While esi < edx
            inc esi
            If B$esi = ':'
                Push esi
                    Mov edi D$STRUCT.EditData@CurrentWritingPos, ecx ebx
                    dec edi | cmp esi edi | je L1>

                    repe cmpsb | jne L1>
                    cmp B$esi SPC | jbe L0>
                    cmp B$esi '[' | jne L1>

L0:                     cld
                        Pop esi
                        inc edi | Mov D$LP.BlockStartText edi

                        Mov eax D$STRUCT.EditData@CurrentWritingPos | sub eax (1*ASCII) | Mov D$LP.BlockEndText eax

                        Call Beep | ret

L1:             Pop esi
            End_If

        End_While
L8: cld

L9: ret
____________________________________________________________________________________________

CheckForMacro:
    Call IsItaMacro

    .If eax = 0
        If D$TABLE.Titles+DWORD > 0
            Push D$CodeSource, D$STRUCT.EditData@SourceEnd, D$SourceLen
                Move D$CodeSource D$RealCodeSource
                Move D$STRUCT.EditData@SourceEnd D$RealSourceEnd
                Move D$SourceLen D$RealSourceLen
                Call IsItaMacro
            Pop D$SourceLen, D$STRUCT.EditData@SourceEnd, D$CodeSource
        End_If
    .End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Tree            ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;;
 Tree view
 _______________________________________________________________________________________
 _______________________________________________________________________________________

 Building the tree view:

 here we build a simple list of labels encounted in source: label declarations 'Label:'
 and label evocations ('Call label'). A byte flag is used for declarations and for
 evocations. A Declaration record is:         Flag (1) / FLAG_DONE (0/1) / adr / name
                                              ..(Byte)....(Byte)........(dWord)(Bytes)
             An evocation record is:          Flag (2) / name
                                              ..(Byte)..(Bytes)
 Names Strings are NOT zero ended (No need as following byte is either 1 or 2).

 We store everything we find in read order. Local label are not considered; so that
 each main label is followed by its own labels evocations, without any check of
 'ret' statement (that would be too uncertain...).

 No error check here for open text / brackets. We Pop the return adress and return
 to caller of 'CreateTreeViewList'.
;;

[TreeList: D$ ?
 TreeListPtr: D$ ?
 TreeListEnd: D$ ?]

[DeclarationFlag 1  EvocationFlag 2  ListFlagMax 3]

BuildLabelTreeList:
    Mov eax D$STRUCT.EditData@SourceEnd | add eax 400 | Mov D$eax-4 0A0D0A0D
    Mov D$TreeList eax, D$TreeListPtr eax
    Mov esi D$CodeSource, edx D$STRUCT.EditData@SourceEnd

L0: lodsb | cmp esi edx | jae L9>>

    cmp al ';' | jne L1>                     ; jmp over comments
        If D$esi-2 = MLC   ; (LF ; ; CR)
            Do
                inc esi | cmp esi edx | jae L9>>
            Loop_Until D$esi = MLC
            add esi 3 | jmp L0<
        Else
L2:         lodsb | cmp al LF | jne L2<
            jmp L0<
        End_If

L1:   cmp al "'" | jne L1>                   ; jump over 'text'
L2:     lodsb | cmp al CR | je L3>
        cmp al "'" | jne L2<
          jmp L0<
L3:   jmp AbortTree

L1:   cmp al '"' | jne L1>                   ; jump over "text"
L2:     lodsb | cmp al '"' | je L0<
          cmp esi edx | jb L2<
      jmp AbortTree

; __________________________    Inside [brackets]: ________________________________

L1:   cmp al '[' | jne L1>                   ; jump over [Brackets]

L2:     lodsb | cmp al ';' | jne L4>

        If D$esi-2 = MLC   ; (LF ; ; CR)
            Do
                inc esi | cmp esi edx | jae L9>>
            Loop_Until D$esi = MLC
            add esi 3 | cmp esi edx | jae L9>>
        Else
L3:         lodsb | cmp al LF | jne L3<
        End_If
        jmp L2<

L4:     cmp al "'" | jne L4>
L5:       lodsb | cmp al "'" | je L2<        ; 'text' in brackets
          cmp al CR | jne L5<
            jmp L8>

L4:     cmp al '"' | jne L4>
L5:       lodsb | cmp al '"' | je L2<        ; "text" in brackets
          cmp esi edx | jb L5<
            jmp L8>

L4:     cmp al ']' | je L0<<
        cmp esi edx | jb L2<
L8:   jmp AbortTree

L1: cmp al ':' | jne L1>                              ; Label declaration found ?
        cmp B$esi-4 32  | jbe L0<<                         ; local ?
        cmp B$esi-4 '|' | je L0<<

      ; End of Label:
        Mov ecx esi | dec ecx

      ; Case of Exported Functions.
        On B$esi = ':', inc esi

        Push esi
L2:       dec esi | cmp B$esi 32 | ja L2<
            inc esi | Mov edi D$TreeListPtr
            Mov al DeclarationFlag | stosb            ; declaration flag
            Mov al 0 | stosb                          ; done flag
            Mov eax esi | stosd                       ; adress in source
            sub ecx esi | rep movsb                   ; label name
            Mov D$edi 0
            Mov D$TreeListPtr edi
        Pop esi
      jmp L0<<

L1:   or al 32 | cmp al 'a' | je IsItDialogApi        ; >>> down here
      cmp al 'c' | jne L0<<                           ; Label evocation found ?
      cmp B$esi-2 32 | jbe L2>
        cmp B$esi-2 '|' | jne L0<<
L2:   lodsd | or eax 020202020 | cmp eax 'all ' | je L3>
        sub esi 4 | jmp L0<<
L3:   cmp B$esi 32 | jne L4>                          ; strip double spaces
        inc esi | jmp L3<
L4:   If B$esi = "'"                                  ; direct api Call (without 'api' macro)
        Mov ebp esi | dec ebp | inc esi | jmp L3>>
      End_If

L8:           Mov edi D$TreeListPtr                   ; jmp target of successfull 'IsItDialogApi'
                Mov al EvocationFlag | stosb          ; evocation flag
L5:             lodsb | cmp al '0' | jb L6>
                        cmp al 'z' | ja L6>
                stosb | jmp L5<                       ; label name
L6:           Mov D$edi 0
              Mov D$TreeListPtr edi | dec esi
        jmp L0<<

L9: Mov edi D$TreeListPtr
    Mov al DeclarationFlag | stosb         ; security if 'Callback:' is last main label
    Mov al 0 | stosb
    Move D$TreeListEnd D$TreeListPtr
ret


IsItDialogApi:
    cmp B$esi-2 32 | jbe L2>
        cmp B$esi-2 '|' | jne L0<<
L2: Mov ebp esi
    lodsd | or eax 02020 | cmp eax "pi '" | je L3>
L7:     Mov esi ebp | jmp L0<<
L3: add esi 7 | lodsd | cmp eax 'Crea' | jne L4>      ; esi+7 > jumps over 'USER32.'
      lodsd | cmp eax 'teDi' | jne L7<
        lodsd | cmp eax 'alog' | jne L7<
          jmp L5>
L4: cmp eax 'Dial' | jne L7<
      lodsd | cmp eax 'ogBo' | jne L7<

L5: ; We found either Call 'CreateDialog/Indirect/paramA' or 'DialogBox/Indirect/ParamA'.
    ; the pointed Proc is always the fourth following parameter:

    Mov ecx 4

P0: lodsb | cmp al SPC | je P1>                      ; search a separator
            cmp al ',' | jne P0<

P1: lodsb | cmp al SPC | jbe P1<                     ; search start of parameter
            cmp al ';' | jne P4>                     ; jmp over comments
P2:            lodsb | cmp al LF | jne P2<
                   jmp P1<
P4: loop P0<

L6: dec esi | jmp L8<<


; If Building tree fails, we abort: strip previous record in BackTable, Pop the return
; adress of caller and return to Callback.

[TreeAborted: D$ ?]
[AbortTreeMessage: B$ "Unpaired Text delimiter or unpaired Bracket" EOS]

AbortTree:
    Mov ebx D$BackTablePtr | sub bl 4 | Mov D$ebx 0 | Mov D$BackTablePtr ebx
    Call 'USER32.MessageBoxA' D$H.MainWindow, AbortTreeMessage, Argh, &MB_SYSTEMMODAL
    Mov B$TreeAborted &TRUE
ret


;;
 Now the list of labels declarations and of labels evocation (by Call) is done. Let us
 take a short exemple: 'CallBack:' contains three calls (to SubA1/A2/A3); SubA1 contains
 two calls (to SubB1/B2); SubB1 again two calls (SubC1/C2); and at last, SubC2 has one
 Call (to SubD1). The tree we want to print could be:

 > CallBack
 >      SubA1
 >          SubB1
 >              SubC1
 >              SubC2
 >                  SubD1
 >          SubB2
 >      SubA2
 >      SubA3

 The List could be (1 is DeclarationFlag, 2 EvocationFlag, adr is Ptr in source):

 / 1 / adr / CallBack / 2 / SubA1 / 2 / SubA2 / 2 / SubA3 /
 / 1 / adr / SubA3 /
 / 1 / adr / SubA1 / 2 / SubB1 / 2 / SubB2 /
 / 1 / adr / SubA2
 / 1 / adr / SubB1 / 2 / SubC1 / 2 / SubC2 /
 / 1 / adr / SubC1 /
 / 1 / adr / SubC2 / 2 / SubD1 /
 / 1 / adr / SubD1 /
 / 1 / adr / SubB2 /
 / 1 ......

 We are going to get the tree from this list simply with playing with Push/Pop: We first
 Push 0, search for 'MainWindowProc' in the list, read/write; we Push a pointer to next
 evocation, search actual label declaration, write it, and so on until we find a label
 with a declaration flag. In this case, we Pop previous adress and go on. So, we go
 forth and back in the list until the entirely job is done; this is to say, until we
 Pop 0. The 'base' of search (edi) is always an evocation and 'what we search' (esi)
 is always a declaration.

 this entire job is done each time user click on 'Tree'.
;;

[TreeLabelPtr: D$ ?
 DoNotWriteInTree: B$ ?]

SearchListDeclaration:  ; edi(ah) > what to find (evoc.) // esi(al) search ptr (> declar.)

    Mov edx D$TreeListEnd, esi D$TreeList, B$DoNotWriteInTree &FALSE
    Push edi
L0:     lodsb | cmp esi edx | jae L8>
L1:     cmp al DeclarationFlag | ja L0<           ; jump over evocations
        Mov ebx esi | inc esi                     ; ebx = done flag ptr. Jump over
        Mov D$TreeLabelPtr esi | add esi 4 | Pop edi | Push edi
L4:     lodsb | Mov ah B$edi | inc edi
        and eax 00_11011111_11011111              ; ah, al > Upper Case
        cmp eax 0202 | je L7>
        cmp eax 0101 | je L7>
        cmp al 0 | je L8>>
        cmp al ah | je L4<

        cmp al ListFlagMax | ja L0<
L6:     cmp ah ListFlagMax | ja L1<

L7:     If B$ShowLabelsOnce = &TRUE
            On B$ebx = 1, Mov B$DoNotWriteInTree &TRUE
        End_If
        Mov B$ebx &TRUE                           ; write done flag
        dec esi | Mov ecx esi                     ; ecx = size
        Mov esi D$TreeLabelPtr
        lodsd | Mov ebx eax                       ; eax, ebx = declaration ptr in source
        sub ecx esi | jmp L9>

L8:     Mov ecx 0
L9: Pop edi
ret                     ; >>> ecx = 0 if not found,  esi = pointer to name if found


; For RightClick (direct search in tree View), the edge of the text must be defined.

[TreeViewItemEdge: D$ ? ]
[TreeViewItem: D$ ? # 100]

; when In, ecx = size of label name.

WriteTreeView:           ; Page set up of the tree like in Win32 TreeView Lists.
                         ; Here one Item once.
    Push esi, edi, ecx
        Mov edi TreeViewItem
L1:     cmp D$TreeIndent 0 | je L1>
L0:         Push ecx
                Mov ecx D$TreeIndent, ebx ecx
L0:             Mov eax '    ' | stosd
                Mov eax '|   ' | stosd
                loop L0<
            Pop ecx
L1:     rep movsb                   ; ecx still good from 'SearchLabelInTreeList'

L2:     Mov al SPC | stosb | Mov al 0 | stosb
        Call 'USER32.SendDlgItemMessageA' D$H.ShowTree, 100, &LB_ADDSTRING,
                                          0, TreeViewItem
    Pop ecx, edi, esi
ret

;;
 In next routine, reintrant procedure would produce infinite loop; This may append, for
 exemple when a DialogBox routine Closes the Dialog and re-run the same fresh Dialog to
 re-init its values (This is the case in RosAsm Dialog Editor source).

 For such cases, we store all Source Adresses of declarations at each increment of tree
 writting position, and check if new written declaration adress is up there in the same
 tree branching. It yes, we Pop back and go on.

 The checked value (Adress of Declaration in source) is given in eax by "SearchListDeclaration".
 but on "WriteTreeView" exit it is POPed in ebx, so that here, ebx is used instead.

 These adresses are stored in "TreeLevels" table which grows and decreases with indentations.

 What we Push and Pop here until poping 0 is nothing but a pointer to TreeList records.
 What we search in "SearchListDeclaration" is always the source adress of a declaration.
 When we see several following Labels at the same indent in Tree View window, we have
 both Push (for "If Next") and Pop (for "Next was a Declaration")... Difficult to explain
 difficult to understand, ... difficult to write... PUSHing is like going down in Tree
 branching and POPing is like going up. At each leave, we both Push and pop.
;;

[TreeIndent: D$ ?]
[TreeRoot: D$ ? # 120]

[TreeLevels: D$ ? # 30]

ClearTreeLevels: Mov edi TreeLevels, eax 0, ecx 30 | rep stosd | ret

BuildOneTree:
    Push 0                                           ; end search mark on stack first.
    Mov D$TreeIndent 0, edi TreeRoot                 ; Root String set by caller.
    Call SearchListDeclaration
    If ecx = 0                                       ; zero lenght (not found) > abort
        Pop eax | ret
    End_If
    Mov D$TreeLevels ebx

L0: Call WriteTreeView | add esi ecx
                                                     ; Testing NEXT RECORD flag:
L2: .If B$esi = EvocationFlag                        ; ________Evocation Case______________
        inc esi | Mov edi esi
L3:     lodsb | cmp al ListFlagMax | ja L3<          ; Search end of evocation Name
        dec esi | Push esi                           ; Push next possible evocation record Ptr
        inc D$TreeIndent                             ; > esi points to next record Type Flag
    .Else                                            ; ________Declaration Case____________
L4:     dec D$TreeIndent                             ; > No more evocation in that branch
        Pop esi | cmp esi 0 | ja L2<                 ; Pop previous TreeList pointer
            jmp L9>>
    .End_If

    Call SearchListDeclaration | cmp ecx 0 | je L4<  ; Evocation of a non existing Label
    cmp B$DoNotWriteInTree &TRUE | je L4<            ; If "First Call Only" selected

    Push edi, ecx                                    ; Compare new Source Label Adress with
        Mov edi TreeLevels, ecx D$TreeIndent         ; other adresses of the same branch
        inc ecx | repne scasd                        ; to prevent from infine loop in case
    Pop ecx, edi                                     ; of imbricated re-intrant calls.
    je L4<

    Mov eax D$TreeIndent, D$TreeLevels+eax*4 ebx | jmp L0<< ; store source Label Adresses.
                                                            ; for next time upper control
L9: ret


[ContinueOrphans: B$ 'List Orphans Labels?' EOS]
[ManyOrphans: B$ "
   After analyzes, the resulting Tree is found poorly organised,   
   and the amount of Labels is uge.
   
   Listing all of the orphan Labels may take a very long time,
   because the tree Builder will try to recreate a sub-Tree from
   each orphan...
 
                                    Go on listing?" EOS]

ListOrphanLabels:
    Mov D$TreeIndent 0, edx D$TreeListEnd, esi D$TreeList, ecx 0, ebx 0

  ; Count how many Orphan Labels to be listed:
L1: lodsb | cmp esi edx | jae L2>
    cmp al DeclarationFlag | ja L1<                       ; jump over evocations
      lodsb | add esi 4                                   ; jump over adress
        inc ebx
        cmp al &TRUE | je L1<                             ; done flag ?
            inc ecx | jmp L1<

  ; The number of orphans Labels may be uge with Disassemblies:
L2: shr ecx 2
    If ecx > ebx
            Call 'USER32.MessageBoxA' D$H.MainWindow, ManyOrphans, ContinueOrphans,
                                      &MB_SYSTEMMODAL__&MB_YESNO
        On eax = &IDNO, ret
    End_If

    Mov D$TreeIndent 0, edx D$TreeListEnd, esi D$TreeList

L1: lodsb | cmp esi edx | jae L9>
    cmp al DeclarationFlag | ja L1<                       ; jump over evocations
      lodsb | add esi 4                                   ; jump over adress
        cmp al &TRUE | je L1<                             ; done flag ?
        Push esi                                          ; start of name
L4:       lodsb | cmp al ListFlagMax | ja L4<             ; search end of name
          Mov ecx esi
        Pop eax
          sub ecx eax                                     ; ecx = size
          dec esi
        Push esi, edx                                     ; next record
          Mov edi TreeRoot, D$TreeIndent 0, esi eax       ; esi > start of name
          rep movsb | Mov al 0 | stosb
          Call BuildOneTree
        Pop edx, esi                                      ; next record
      jmp L1<
L9: ret


[ShowOrphan: &FALSE  ShowLabelsOnce: &TRUE]    ; keep dWords (evocated both as Bytes and dWords)

BuildTree:             ; build the tree from the List

    Mov D$TreeIndent 0
    Mov esi CallBackName, ecx D$CallBackNameLen, edi TreeRoot
    rep movsb | Mov al 0 | stosb

    Call BuildOneTree

    Mov esi EntryPointLabel, edi TreeRoot, D$TreeIndent 0
    While B$esi <> 0 | movsb | End_While | movsb
    Call BuildOneTree

    On B$ShowOrphan = &TRUE, Call ListOrphanLabels
L9: ret

 _______________________________________________________________________________________
 _______________________________________________________________________________________

; tree view main routines:

; Tag Dialog 22000

CreateTreeViewList:
    If D$H.ShowTree = 0
        Call 'USER32.CreateDialogParamA' D$H.Instance, 22000, D$H.MainWindow, ShowTree, &NULL
        On D$BookMarks > 0, Call ReInsertBookMarks
    Else
        Call 'USER32.SetForegroundWindow' D$H.ShowTree
        Call 'USER32.ShowWindow' D$H.ShowTree, &SW_RESTORE
    End_If
ret


; Called when loading a new file:

CloseTree:
    If D$H.ShowTree > 0
        Call 'USER32.DestroyWindow' D$H.ShowTree
        Mov D$H.ShowTree 0
    End_If
ret


[H.ShowTree: D$ ?]

[TreeWP:
 @TreeWP.iLength: D$ Len
 TreeWP.flags: D$ 0
 TreeWP.showCmd: D$ 0
 TreeWP.ptMinPosition.x: D$ 0
 TreeWP.ptMinPosition.y: D$ 0
 @TreeWP.ptMaxPosition.x: D$ 0
 @TreeWP.ptMaxPosition.y: D$ 0
 TreeWP.rcNormalPosition.left: D$ 0
 TreeWP.rcNormalPosition.top: D$ 0
 TreeWP.rcNormalPosition.right: D$ 0
 TreeWP.rcNormalPosition.bottom: D$ 0]

[ListKeyBoardInput: D$ ?
 AutoHideTreeView: D$ ?
 AutoRebuildTreeView: D$ ?]

Proc ShowTree:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ..If D@msg = &WM_COMMAND
        .If D@wParam = &IDCANCEL
L7:        Mov D$H.ShowTree 0
           Call 'USER32.EndDialog' D@hwnd 0   ; CloseTree

        .Else
            shr D@wParam 16

            If D@wParam = &LBN_KILLFOCUS
                On B$AutoHideTreeView = &TRUE,
                    Call 'USER32.ShowWindow' D@hwnd &SW_MINIMIZE
            Else_If D@wParam = &LBN_SELCHANGE
                On B$ListKeyBoardInput = &FALSE, Call SearchFromTreeListBox D@lParam
                Mov B$ListKeyBoardInput &FALSE
            End_If
        .End_If

    ..Else_If D@msg = &WM_VKEYTOITEM    ; Prevents from searching hundreads of
        If W@wParam <> CR                   ; Label when user is moving through the
            Mov B$ListKeyBoardInput &TRUE   ; List with the KeyBorad.
        Else                                ; But allow Search if [Return] Key depressed.
            Call SearchFromTreeListBox D@lParam
        End_If
        popad | Mov eax 0-1 | jmp L9>>

    ..Else_If D@msg = &WM_INITDIALOG
      ; Does not survive in the Minimized state...:
      ; Call 'USER32.SetWindowLongA' D@hwnd, &GWL_EXSTYLE, &WS_EX_TOOLWINDOW
        Call RestoreRealSource
        Mov D$TreeViewItemEdge '    '
        Move D$H.ShowTree D@hwnd
        Call StorePosInBackTable
        Call 'USER32.SetClassLongA' D$H.ShowTree &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        Call ClearTreeLevels
        Mov B$TreeAborted &FALSE | Push ebp | Call BuildLabelTreeList | Pop ebp
        cmp B$TreeAborted &TRUE | je L7<<
        Call BuildTree
        Call SetPartialEditionFromPos

    ..Else_If D@msg = &WM_SIZE
      ; This is for adjusting the List Control to the Dialog new Size:
        Call 'USER32.GetClientRect' D@hwnd, ListEditRect
        Mov eax D$ListERX | sub D$ListERW eax
        Mov eax D$ListERY | sub D$ListERH eax
        Call 'USER32.GetDlgItem' D@hwnd, 100
        Call 'USER32.MoveWindow' eax D$ListERX D$ListERY D$listERW D$ListERH &FALSE

      ; Save the user's Tree Dialog Width:
        Call 'USER32.GetWindowRect' D@hwnd, ListEditRect
        Mov eax D$ListERW | sub eax D$ListERX | Mov D$TreeWidth eax

L1:     Push D$TreeWP.ptMinPosition.x, D$TreeWP.ptMinPosition.y, D$TreeWP.flags
            Call 'USER32.GetWindowPlacement' D$H.ShowTree TreeWP
        Pop D$TreeWP.flags, D$TreeWP.ptMinPosition.y, D$TreeWP.ptMinPosition.x

    ..Else_If D@msg = &WM_MOVE
        jmp L1<

    ..Else_If D@msg = &WM_CTLCOLORLISTBOX
        Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>

    ..Else_If D@msg = &WM_ACTIVATE
       ; Wanted by... Anvar if i remember, but conflicts with any wish of moving
       ; the reduced Tree Window, with AutoHide Flag set on. So commented out:

       ; On B$AutoHideTreeView = &TRUE, Call 'USER32.ShowWindow' D@hwnd &SW_NORMAL

    ..Else
        popad | Mov eax &FALSE | jmp L9>

    ..End_If

    popad | Mov eax &TRUE

L9: EndP


[TreeCurrentSel: D$ ?
 TreeUpperMainLabElsel: D$ ?]

Proc SearchFromTreeListBox:
    Argument @lParam

    Call RestoreRealSource

    Call 'USER32.SendMessageA' D@lParam, &LB_GETCURSEL, 0, 0
    Mov D$TreeCurrentSel eax, D$TreeUpperMainLabElsel eax

    Call 'USER32.SendMessageA' D@lParam, &LB_GETTEXT, D$TreeUpperMainLabElsel, TreeViewItem
    Mov esi TreeViewItem | On B$esi > SPC, jmp L2>
L1: lodsb | cmp B$esi SPC | je L1<
        cmp B$esi '|' | je L1<

L2: If B$esi = '@'
L0:     dec D$TreeUpperMainLabElsel | jc L9>>
        Call 'USER32.SendMessageA' D@lParam, &LB_GETTEXT, D$TreeUpperMainLabElsel,
                                   TreeViewItem
        Mov esi TreeViewItem | On B$esi > SPC, jmp L2>
L1:     lodsb | cmp B$esi SPC | je L1<
            cmp B$esi '|' | je L1<
L2:             On B$esi = '@', jmp L0<
                    Call InternalRightClick

    Else
        Call InternalRightClick | jmp L9>>

    End_If
;;
  If here, after having a selected Item saying "@Label", we have found out the upper
  MainLabel, which is now a selected Block.  We search downward for the wanted relative
  "@Label":
;;
    Call 'USER32.SendMessageA' D@lParam, &LB_GETTEXT, D$TreeCurrentSel, TreeViewItem
        Mov esi TreeViewItem | On B$esi > SPC, jmp L2>
L1:     lodsb | cmp B$esi SPC | je L1<
            cmp B$esi '|' | je L1<

L2: Push D$LenOfSearchedString
        Mov edi SearchString,
            D$LenOfSearchedString 1

        While B$esi > SPC

            movsb | inc D$LenOfSearchedString

        End_While

        Mov al ':' | stosb | Mov al 0 | stosb

        Push D$DownSearch, D$CaseSearch, D$WholeWordSearch, D$STRUCT.EditData@CurrentWritingPos

            Mov B$DownSearch &TRUE, B$CaseSearch &FALSE, B$WholeWordSearch &TRUE

            Move D$STRUCT.EditData@CurrentWritingPos D$LP.BlockEndText

            Push D$NextSearchPos

                Move D$NextSearchPos D$STRUCT.EditData@CurrentWritingPos

                Call StringSearch

            Pop D$NextSearchPos

        Pop D$STRUCT.EditData@CurrentWritingPos, D$STRUCT.EditData@CurrentWritingPos, D$CaseSearch, D$DownSearch

    Pop D$LenOfSearchedString

L9: Call SetPartialEditionFromPos
EndP



; Set the Tree Window at left of Main Window:

SetTreeDialogPos:
    Call GetTreePlacement

    Call 'USER32.SetWindowPlacement' D$H.ShowTree, TreeWP

    Call 'USER32.GetWindowLongA' D$H.ShowTree, &GWL_STYLE | or eax &WS_VISIBLE
    Call 'USER32.SetWindowLongA' D$H.ShowTree, &GWL_STYLE, eax
ret


[TreePlacementDone: D$ ?
 TreeWidth: D$ ?]

[EditWindowXforTree: D$ ?
 EditWindowYforTree: D$ ?
 EditWindowX2forTree: D$ ?
 EditWindowY2forTree: D$ ?]

GetTreePlacement:
    On B$TreePlacementDone = &TRUE, ret

    Mov B$TreePlacementDone &TRUE

    Call 'USER32.GetWindowRect' D$H.EditWindow, EditWindowXforTree

  ; Default Width if the user never redefined it:
    On D$TreeWidth = 0, Mov D$TreeWidth 250

    Mov eax D$EditWindowX2forTree | Mov D$TreeWP.rcNormalPosition.right eax
    sub eax D$TreeWidth | Mov D$TreeWP.rcNormalPosition.left eax
    Mov eax D$EditWindowYforTree | Mov D$TreeWP.rcNormalPosition.top eax
    Mov eax D$EditWindowY2forTree | Mov D$TreeWP.rcNormalPosition.bottom eax

    Mov D$TreeWP.flags &WPF_SETMINPOSITION
    Mov eax D$TreeWP.rcNormalPosition.right | sub eax 160    ; founded Minimized Width.
    Mov D$TreeWP.ptMinPosition.x eax
    Mov eax D$TreeWP.rcNormalPosition.top
    Move D$TreeWP.ptMinPosition.Y eax
    Mov D$TreeWP.flags &WPF_SETMINPOSITION

    Mov D$TreeWP.showCmd &SW_SHOWNORMAL
ret


____________________________________________________________________________________________

;;
  Simplified version of the &WM_INITDIALOG case in 'ShowTree' Proc. Called from
  'AsmMain' when 'AutoRebuildTreeView' is TRUE.
;;

TreeUpDate:
    Call 'USER32.SendDlgItemMessageA' D$H.ShowTree, 100, &LB_RESETCONTENT, 0, 0

    Mov D$TreeViewItemEdge '    ' | Call ClearTreeLevels

    Mov B$TreeAborted &FALSE | Push ebp | Call BuildLabelTreeList | Pop ebp

    On B$TreeAborted = &FALSE, Call BuildTree
L9: ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Complete        ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
  Flag in [Configuration]: 'CompletionWanted'.

  'BuildCompletionTable' is called after each Compilation. It builds a Table of
  symbols (Labels, Macros and Equates), form the Assembler Lists: 'CompletionTable',
  Where each Record is a zero ended String.
  
  'CompletionPointers' is a Table of Pointers to the 'CompletionTable' Strings Table.
  
  The 'CodeComplete' Routines set the 'Underline' Flag on if one (and only one)
  fitting Symbol has been found.
  
  Once the 'Underline' Flag is set on, if the user hit [Ctrl]/[Space], the 'Completion'
  Routine is called.
  
  
  General Completion Checking: 'CodeComplete'
  
  'Completion' is the default (User symbols) and route to api or Equates when wanted.
  
  User symbols Routines:
  
  'UserSymbolsComplete' > 'CompletionCompare'  >'IsTheSmallerOnePartOfOthers'
  'Completion' > 'TakeCompleteModel' > 'CompleteSubstitute'
  
  Api Routine:
  
  'ApiComplete' > 'ApiCompletion' > 'CompletionListProc' > 'ApiSubstitute' > 'ReadApiForCompletion'

  OS Equates:
  
  'WinEquatesComplete'
  'EquatesCompletion'  > 'CompletionListProc' > 'InitListForEquates' > 'Win32EquatesSubstitute'
  
  'ListAllEquates'
;;
____________________________________________________________________________________________

[CompletionMode: D$ ?] ; either 'Api', 'User', or 'Equ'

[CompletionTable: D$ ?
 CompletionPointers: D$ ?]

BuildCompletionTable:

    Call VirtualFree CompletionTable

    Call VirtualFree CompletionPointers

  ; Count how many Symbols:
    Mov ecx 0, edx 0
    Mov esi D$LabelList | add esi 5
    .While B$esi <> 0
        inc ecx | While B$esi > SPC | inc esi | End_While | add esi 7
    .End_While
    add edx esi | sub edx D$LabelList

    Mov esi D$MacroList | add esi 5
    .While B$esi <> 0
        inc ecx | While B$esi > SPC | inc esi | End_While | add esi 11
    .End_While
    add edx esi | sub edx D$MacroList

    Mov esi D$EquateList | add esi 5
    .While B$esi <> 0
        inc ecx | While B$esi > SPC | inc esi | End_While | add esi 11
    .End_While
    add edx esi | sub edx D$EquateList

  ; Allocate mem for Strings ('CompletionTable')
  ; and for list of pointers to Strings ('CompletionPointers'):

    inc ecx | shl ecx 2 | or ecx 1

    Call VirtualAlloc CompletionPointers,
                      ecx

    Call VirtualAlloc CompletionTable,
                      edx

    add D$CompletionTable 1

  ; Fill the Tables:
    Mov edi D$CompletionTable, ebx D$CompletionPointers

    Mov esi D$LabelList | add esi 5
    .While B$esi > SPC
        Mov D$ebx edi | add ebx 4
        Mov ecx 0
        While B$esi > SPC
            and B$esi 07F
            If B$esi = '@'
                sub ebx 4 | Mov D$ebx 0
L0:             dec edi | cmp B$edi 0 | jne L0<
L0:             inc esi | cmp B$esi SPC | ja L0<
                jmp L2>

            End_If
            movsb | inc ecx

        End_While
      ; Do not store all of Local Labels, and smaller than 4 Chars Labels
        If ecx < 4
            sub ebx 4 | Mov D$ebx 0
L0:         dec edi | cmp B$edi 0 | jne L0<
        End_If

L2:     add esi 7
        Mov B$edi 0 | inc edi
    .End_While

    Mov esi D$MacroList | add esi 5
    .While B$esi > SPC
        Mov D$ebx edi | add ebx 4
        While B$esi > SPC | and B$esi 07F |  movsb | End_While | add esi 11
        Mov B$edi 0 | inc edi
    .End_While

    Mov esi D$EquateList | add esi 5
    .While B$esi > SPC
        Mov D$ebx edi | add ebx 4
        While B$esi > SPC
            and B$esi 07F
            If B$esi = '@'
                sub ebx 4 | Mov D$ebx 0
L0:             dec edi | cmp B$edi 0 | jne L0<
L0:             inc esi | cmp B$esi SPC | ja L0<
                jmp L1>
            End_If
            movsb
        End_While
L1:     add esi 11
        Mov B$edi 0 | inc edi
    .End_While
ret

____________________________________________________________________________________________
____________________________________________________________________________________________


[CompletionWanted: D$ ?
 CompletionFound: D$ ?
 CompletionRuning: D$ ?]

[CompletionMinimumInput: D$ 3]

; Check what the user is typing in:

CodeComplete:
    Mov D$CompletionFound 0, B$Underline &FALSE, B$CompletionRuning &TRUE

    Mov eax D$STRUCT.EditData@CurrentWritingPos

    If B$eax <= SPC
        ; OK
    Else_If B$eax = ','
        ; OK
    Else_If B$eax = "'"
        ; OK
    Else_If B$eax = '"'
        ; OK
    Else_If B$eax = ';'
        ; OK
    Else_If B$eax = '|'
        ; OK
    Else
        jmp L9>>
    End_If

    Mov esi D$STRUCT.EditData@CurrentWritingPos
    Push D$esi, esi
        Mov B$esi 0 | dec esi
        Mov ecx 0 | While B$esi > SPC | dec esi | inc ecx | End_While | inc esi
        On ecx < D$CompletionMinimumInput, jmp L5>

        If B$esi+1 = '$'
            add esi 2 | On B$esi = '@', inc esi
            Call UserSymbolsComplete
        Else_If B$esi+1 = '@'
            add esi 2 | Call UserSymbolsComplete
        Else_If B$esi = "'"
            Call ApiComplete
        Else_If B$esi = '"'
            Call ApiComplete
        Else_If B$esi = '&'
            Call WinEquatesComplete
        Else_If B$esi > SPC
            Call UserSymbolsComplete
        End_If
L5: Pop esi, D$esi

    ..If D$CompletionFound = 1
        Mov B$Underline &TRUE

    ..Else_If D$CompletionFound > 20
      ; Too much > nop

    ..Else_If D$CompletionFound > 1
        .If D$CompletionMode = 'User'
            Call IsTheSmallerOnePartOfOthers

            If eax = &TRUE
                Move D$CompletionPointer D$ShorterSymbolPointer
                Mov B$Underline al
            End_If
        .End_If

    ..End_If

L9: ..If D$H.CompletionList <> 0
        .If B$Underline = &TRUE
            If D$CompletionMode = 'Api'
                Call ApiCompletion
            Else_If D$CompletionMode = 'Equ'
                Call EquatesCompletion
            End_If
        .Else
            Call 'USER32.DestroyWindow' D$H.CompletionList
            Mov D$H.CompletionList 0
        .End_If
    ..End_If
ret


; Search if the user entered text fits with some registred compiled Symbol:

UserSymbolsComplete:
    On D$CompletionTable = 0, ret ; jmp L5>>

    Mov ebx D$CompletionPointers, D$CompletionMode 'User'
    While D$ebx <> 0

        Mov edi D$ebx | add ebx 4
        Call CompletionCompare
        .If al = 0
            If D$CompletionFound = 1
                Move D$CompletionPointersList D$CompletionPointer
            Else_If D$CompletionFound > 20
              ; Too much > nop
            Else_If D$CompletionFound > 1
                Push ebx
                    Mov eax D$CompletionFound, ebx D$CompletionPointer
                    dec eax | Mov D$CompletionPointersList+eax*4 ebx
                Pop ebx
            End_If
        .End_If

    End_While
ret


CompletionCompare:
  ; esi > User Source // edi > CompletionTable
  ; (At esi, the user's text has been temporary zero ended)
    Push esi, edi, ebx
        Mov ecx 0
L0:     Mov bl B$edi | inc edi
L1:     Mov al B$esi | inc esi | cmp al '_' | je L1<

        .If al >= 'a'
            On al <= 'z', sub al SPC
        .Else_If al = 0
            If bl > SPC
                inc D$CompletionFound
                Pop ebx, edi, esi
                Mov D$CompletionPointer edi | ret
            End_If
        .End_If

        cmp al bl | jne L9>

        jmp L0<
L9: Pop ebx, edi, esi
ret


; Several fiting Symbols found:
; Take the smaller one if all others bigger ones have the same prefix:

[ShorterSymbolPointer: D$ ?
 ShorterSymbolSize: D$ ?]

IsTheSmallerOnePartOfOthers:
  ; get the smaller one:
    Mov esi CompletionPointersList

    Mov edx D$CompletionFound, ebx 0, D$ShorterSymbolSize 0-1

    .While ebx < edx
        Mov eax D$esi+ebx*4, ecx 0

        While B$eax > SPC | inc eax | inc ecx | End_While
        If ecx < D$ShorterSymbolSize
            Mov D$ShorterSymbolSize ecx
            Move D$ShorterSymbolPointer D$esi+ebx*4
        End_If

        inc ebx
    .End_While

  ; Now, is this smaller one a valid Prefix for all fitting Symbols:
    Mov ebx 0, edx CompletionPointersList

    .While ebx < D$CompletionFound
        Mov edi D$ShorterSymbolPointer, esi D$edx, ecx D$ShorterSymbolSize
        repe cmpsb
        If ecx <> 0
            Mov eax &FALSE | ret
        End_If
        inc ebx | add edx 4
    .End_While

    Mov eax &TRUE
ret


[CompletionPointer: D$ ?]

; 'Completion' is called when user hit [Ctrl][Space]

Completion:
    If D$CompletionMode = 'Api'
        jmp ApiCompletion
    Else_If D$CompletionMode = 'Equ'
        jmp EquatesCompletion
    End_If

  ; Default case for User Symbols Completion:

    Mov D$CompletionMode 'User'

    Call RestoreRealSource

    Mov esi D$CodeSource, edx D$STRUCT.EditData@SourceEnd

    .While esi < edx
        ...If D$esi = MLC
            add esi 4
            While D$esi <> MLC
                inc esi | On esi >= edx, jmp L9>>
            End_While
            add esi 4

        ...Else_If B$esi = ';'
            While B$esi > CR | inc esi | End_While

        ...Else_If B$esi = '"'
            inc esi
            While B$esi <> '"'
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ...Else_If B$esi = "'"
            inc esi
            While B$esi <> "'"
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ...Else
          ; Not necesserary the Declaration. Any previous evocation will do as well:
            Mov al B$esi-1
            If al = '['
                ; Good
            Else_If al <= SPC
                ; Good
            Else_If al = ','
                ; Good
            Else_If al = '$'
                ; Good
            Else_If al = '|'
                ; Good
            Else
                jmp L5>>
            End_If

          ; > edi > ebx > Edition Pointer  //  esi > ecx > Search Pointer
            Mov edi D$CompletionPointer, ecx esi

L0:         Mov al B$esi
            If al >= 'a'
                On al <= 'z', sub al SPC
            Else_If al = '_'
                inc esi | jmp L0<
            End_If

            If al <> B$edi
                Mov esi ecx | jmp L5>
            End_If

            inc esi | inc edi

            .If B$edi <= SPC
                If B$esi <= SPC
                    ; Good
                Else_If B$esi = ','
                    ; Good
                Else_If B$esi = ':'
                    ; Good
                Else_If B$esi = ';'
                    ; Good
                Else_If B$esi = '|'
                    ; Good
                Else
                    Mov esi ecx | jmp L5>
                End_If

                xchg esi ecx | Mov edi CompletionModel
                While esi < ecx | movsb | End_While | Mov B$edi 0 | jmp L9>

            .Else
                jmp L0<

            .End_If
        ...End_If

L5:     inc esi
    .End_While

L9: Call SetPartialEditionFromPos

    Call CompleteSubstitute
ret


[CompletionPointersList: D$ ? # 20]
[CompletionModel: D$ ? # 20]

; Substitution for User defined Symbols

CompleteSubstitute:
    Mov B$Underline &FALSE, B$Keys+&VK_CONTROL &FALSE
    Mov D$CompletionMode 0, B$CompletionRuning &TRUE

    Mov edi D$STRUCT.EditData@CurrentWritingPos
    dec edi | While B$edi > SPC | dec edi | End_While | inc edi
    If B$edi+1 = '$'
        add edi 2 | On B$edi = '@', inc edi
    Else_If B$edi+1 = '@'
        add edi 2
    End_If

    Mov B$OldBlockInside &FALSE
    While D$STRUCT.EditData@CurrentWritingPos > edi
        Push edi
            Call EraseLastChar
            Call AskForRedrawNow
        Pop edi
    End_While

    Mov esi CompletionModel

    While B$esi <> 0
        Push esi
            movzx eax B$esi | Call InsertSource
            Call AskForRedrawNow
        Pop esi
        inc esi
    End_While

    Mov B$CompletionRuning &FALSE
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; Api Completion

[ApiInput: D$ ? # 20]

; Search if the user entered text fits with some Api Name:

ApiComplete: ; Win32Functions  WinApiFirstPass
    Mov D$CompletionFound 0, D$CompletionMode 'Api'

    Mov eax D$esi-5 | or eax 020202020 | On eax <> 'Call', ret

    inc esi

  ; esi points now after the Text Separator. Is there some '.'?
    Mov ebx D$STRUCT.EditData@CurrentWritingPos
    While ebx > esi
        dec ebx
        If B$ebx = '.'
            inc ebx | Mov esi ebx | jmp L0>
        End_If
    End_While

  ; Make a Copy for the ListBox Edit: ;;; ???!!! What use now?
L0: Push esi
        Mov edi ApiInput
        While esi < D$STRUCT.EditData@CurrentWritingPos | movsb | End_While | Mov B$edi 0
    Pop esi

    Mov ecx D$STRUCT.EditData@CurrentWritingPos | sub ecx esi | On ecx < D$CompletionMinimumInput, ret

    Mov al B$esi, edi Win32Functions, ecx 0

    .While edi < EndOfFunctionsList
        ..If B$edi < al
          ; Next Line:
L2:         While B$edi <> LF | inc edi | End_While | inc edi

        ..Else_If B$edi > al
            ret

        ..Else
            Mov D$CompletionPointer edi
            Mov ebx esi | inc ebx | inc edi
            While ebx < D$STRUCT.EditData@CurrentWritingPos
                Mov cl B$ebx | cmp cl B$edi | jne L2<
                inc ebx | inc edi
            End_While
            Mov D$CompletionFound 1 | ret

        ..End_If

    .End_While
L9: ret

____________________________________________________________________________________________

ApiCompletion:
    Mov D$CompletionMode 'Api'

    If D$H.CompletionList <> 0
        Call 'USER32.DestroyWindow' D$H.CompletionList
    End_If

    Call 'USER32.CreateDialogParamA' D$H.Instance, 1200, D$H.MainWindow, CompletionListProc, 0

    Call 'USER32.SetFocus' D$H.MainWindow

    Mov B$Keys+&VK_CONTROL &FALSE
ret

____________________________________________________________________________________________

Proc ToCompletionList:
    Argument @Key

    Call 'USER32.GetDlgItem' D$H.CompletionList, 10
    Call 'USER32.SetFocus' eax

    Call 'USER32.SendDlgItemMessageA' D$H.CompletionList, 10, &LB_GETCURSEL, 0, 0

    .If D@Key = &VK_UP
        If eax > 0
            dec eax
            Call 'USER32.SendDlgItemMessageA' D$H.CompletionList, 10,
                                              &LB_SETCURSEL, eax, 0
        End_If

    .Else_If D@Key = &VK_DOWN
        inc eax
        Call 'USER32.SendDlgItemMessageA' D$H.CompletionList, 10, &LB_SETCURSEL, eax, 0

    .Else_If D@Key = CR
        Call CompletionListProc D$H.CompletionList, &WM_COMMAND, &IDOK, 0

    .End_If
EndP


[H.CompletionList: D$ ?]

; Tag Dialog 1200

Proc CompletionListProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_INITDIALOG
        On D$H.CompletionList <> 0,
            Call 'USER32.EndDialog' D$H.CompletionList, 0

        Move D$H.CompletionList D@hwnd | Call SetCompletionPos

        .If D$CompletionMode = 'Api'
            Call InitListForApi
        .Else_If D$CompletionMode = 'User'
            Mov ecx 0
        .Else_If D$CompletionMode = 'Equ'
            Call InitListForEquates
            If ecx = 0-1
                Call 'USER32.EndDialog' D$H.CompletionList, 0
                Mov D$H.CompletionList 0
            Else_If ecx = 0
                Call 'USER32.SendDlgItemMessageA' D$H.CompletionList, 10,
                                                  &LB_GETTEXT, 0, CompletionModel
                Mov ecx 0
            End_If
        .End_If

L1:     If ecx = 0
            Mov D$CompletionPointer CompletionModel
            Call AskForRedrawNow
            Call SubstituteFromEitherList
            Call 'USER32.EndDialog' D$H.CompletionList, 0
            Mov B$Underline &FALSE, D$H.CompletionList, 0
        Else
            Call 'USER32.SendDlgItemMessageA' D@hwnd, 10, &LB_SETCURSEL, 0, 0
        End_If

        jmp L8>>

    ...Else_If D@msg = &WM_COMMAND
        If D@wParam = &IDCANCEL
            Call 'USER32.EndDialog' D$H.CompletionList, 0
            Mov D$H.CompletionList 0

        Else_If D@wParam = &IDOK
            Call ListOk

        Else_If W@wParam+2 = &LBN_DBLCLK
            Call ListOk

        End_If

    ...Else_If D@msg = &WM_VKEYTOITEM
        If W@wParam = &VK_RETURN
            Call ListOk
            popad | Mov eax 0-2 | jmp L9>

        Else_If W@wParam = &VK_ESCAPE
            Call 'USER32.EndDialog' D$H.CompletionList, 0
            Mov D$H.CompletionList 0
            popad | Mov eax 0-2 | jmp L9>

        Else
            popad | Mov eax 0-1 | jmp L9>

        End_If

    ...Else_If D@msg = &WM_CHARTOITEM
      ; For Chars inputs to the User's Source. Does not work under 95:
        Call 'USER32.SetFocus' D$H.MainWindow

    ...Else
L8:     popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE
L9: EndP

[ListRectangle:
 @X1: D$ ?
 @Y1: D$ ?
 @X2: @W: D$ ?
 @Y2: @H: D$ ?]

[HwndTitleHight: D$ ?]

SetCompletionPos:

    Call 'USER32.GetWindowRect' D$H.MainWindow,
                                STRUC.RECT.MainWindow

    Mov eax D$WindowX | sub D$WindowW eax

    Mov eax D$WindowY | sub D$WindowH eax

    Call 'USER32.GetClientRect' D$H.MainWindow,
                                ListRectangle

    Mov eax D$WindowH | sub eax D$ListRectangle@H | Mov D$HwndTitleHight eax

    Call 'USER32.GetWindowRect' D$H.CompletionList, ListRectangle

    ; Write the ApiList Window Width and hight, instead of RECTright, RECTbottom:
    Mov eax D$ListRectangle@X2 | sub eax D$ListRectangle@X1

    Mov D$ListRectangle@W eax

    Mov eax D$ListRectangle@Y2 | sub eax D$ListRectangle@Y1

    Mov D$ListRectangle@H eax

    ; Count how many Chars in the Underlinement:
    Mov esi D$STRUCT.EditData@CurrentWritingPos, ecx 0 | dec esi

    While B$esi > SPC | dec esi | inc ecx | End_While

    ; Translate Caret Pos into Pixels Pos:
    Mov eax D$STRUCT.EditData@CaretRow | sub eax ecx | Call RowToX eax | add eax D$WindowX

    Push eax

        Call LineToY D$STRUCT.EditData@CaretLine

        add eax D$WindowY | add eax D$HwndTitleHight

        Push eax

            ; Is the Caret in the upper of lower part of the Screen?
            Call 'USER32.GetSystemMetrics' &SM_CYSCREEN

            Mov ecx eax | shr ecx 1

    Pop ebx, eax

    If ebx < ecx

        ; Upper half: Set ListBox Pos under the user writing Pos:
        add ebx  D$FontHeight

    Else

        ; Lower half: Set ListBox Pos above the user writing Pos:
        sub ebx D$FontHeight | sub ebx D$ListRectangle@H

        On ebx > 0FFFF, Mov ebx 0

    End_If

    Call 'USER32.MoveWindow' D$H.CompletionList,
                             eax,
                             ebx,
                             D$ListRectangle@W,
                             D$ListRectangle@H,
                             &FALSE
ret


InitListForApi:
    Mov esi D$CompletionPointer, ecx 0
L0: Mov edi CompletionModel
    While B$esi > SPC | movsb | End_While | Mov B$edi 0
    Push esi, ecx
        Call 'USER32.SendDlgItemMessageA' D$H.CompletionList, 10, &LB_ADDSTRING,
                                          0, CompletionModel
    Pop ecx esi
    While B$esi <= SPC | inc esi | End_While
    Mov ebx esi, edi ApiInput
    While B$edi <> 0
        Mov al B$ebx | cmp al B$edi | jne L9>
        inc ebx | inc edi
    End_While
    inc ecx | Mov B$edi 0 | jmp L0<
L9: ret


ListOk:
    Call 'USER32.SendDlgItemMessageA' D$H.CompletionList, 10, &LB_GETCURSEL, 0, 0
    Call 'USER32.SendDlgItemMessageA' D$H.CompletionList, 10, &LB_GETTEXT, eax,
                                      CompletionModel
    Mov D$CompletionPointer CompletionModel
    Call SubstituteFromEitherList
    Call 'USER32.EndDialog' D$H.CompletionList, 0
    Mov B$Underline &FALSE, D$H.CompletionList, 0
ret


SubstituteFromEitherList:
    If D$CompletionMode = 'Api'
        Call ApiSubstitute
    Else_If D$CompletionMode = 'User'

    Else_If D$CompletionMode = 'Equ'
        Call Win32EquatesSubstitute
    End_If
Ret


ApiSubstitute:
    Mov B$CompletionRuning &TRUE, B$Underline &FALSE
    Mov esi D$STRUCT.EditData@CurrentWritingPos

    Call ReadApiForCompletion | On B$ApiFileOK = &FALSE, ret

L0: Call EraseLastChar | Call AskForRedrawNow
    Mov eax D$STRUCT.EditData@CurrentWritingPos
    .If B$ApiFound = &FALSE
        If B$eax-1 = '.'
            While B$eax-1 <> "'"
                dec eax | cmp B$eax-1 '"' | je L1>
            End_While
            jmp L1>
        End_If
    .End_If
    cmp B$eax-1 "'" | je L1>
    cmp B$eax-1 '"' | jne L0<

L1: movzx eax B$eax-1
    Push eax
        Mov esi D$CompletionPointer
        While B$esi > SPC
            Push esi
                movzx eax B$esi | Call InsertSource
                Move D$STRUCT.EditData@PhysicalCaretRow D$STRUCT.EditData@CaretRow
            Pop esi
            inc esi
        End_While
    Pop eax

    Mov esi D$STRUCT.EditData@CurrentWritingPos | On B$esi <> al, Call InsertSource
    Call AskForRedrawNow

    Mov B$ApiFound &FALSE, B$CompletionRuning &FALSE, D$CompletionMode 0
ret


ReadApiForCompletion:
    Mov B$ApiFound &FALSE
    Call OpenApiFunctionsFile | On B$ApiFileOK = &FALSE, ret

    Mov esi D$Win32ApiList, ebx D$CompletionPointer

    Mov edx D$ApiFileSize | add edx esi

L1: .While esi < edx
        inc esi
        ...If B$esi = '.'
            Mov edi ebx                 ; edi > Our model  // esi > Win32ApiList
            inc esi

            Do
                Mov al B$esi, ah B$edi

                .If al = '('
                    If ah <= SPC
                        Mov B$ApiFound &TRUE
                        While B$esi-1 > LF | dec esi | End_While
                        Mov edi ebx

                        While B$esi <> '(' | movsb | End_While | Mov B$edi 0 | jmp L9>
                    End_If
                .End_If

                inc esi | inc edi
            Loop_Until al <> ah

        ...End_If
    .End_While

L9:
    Call VirtualFree Win32ApiList

ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; OS Equates Completion

____________________________________________________________________________________________
____________________________________________________________________________________________


; Search if the user entered text fits with some Win32 Equate:

WinEquatesComplete:
    Mov D$CompletionFound 1, D$CompletionMode 'Equ'
ret


EquatesCompletion:
    Call IsEquatesEquThere

    If D$FL.Includes = &TRUE
        Call GetEquFilesMemory
        Call ReadEquatesEqu
        Call 'USER32.CreateDialogParamA' D$H.Instance, 1200, D$H.MainWindow, CompletionListProc, 0
        Call 'USER32.SetFocus' D$H.MainWindow
    End_If

    Call VirtualFree EquateIncMemory

    Mov B$Keys+&VK_CONTROL &FALSE
ret


InitListForEquates:
    Mov esi D$STRUCT.EditData@CurrentWritingPos, ecx 0

  ; Take an Upper Case copy of user input:
    While B$esi-1 > '&' | dec esi | End_While | Mov edi CompletionModel
    While esi < D$STRUCT.EditData@CurrentWritingPos
        lodsb | On al > 'Z', and al 00_11011111
        stosb
    End_While
    Mov B$edi 0

  ; Search fitting Items in Equates.equ:
    Mov edi D$EquateIncMemory, ecx 0, edx edi | add edx D$EquatesIncFileSize

L0: Mov esi CompletionModel, al B$esi
    .If B$edi = al
        While B$edi = al | inc esi | inc edi | Mov al B$esi | End_While
        If al = 0
            While B$edi > SPC | inc edi | End_While
            Push edx, ecx, D$edi, edi
                Mov B$edi 0 | dec edi
                While B$edi > LF
                    dec edi | On edi = D$EquateIncMemory, jmp L1>
                End_While
                inc edi
L1:             Call 'USER32.SendDlgItemMessageA' D$H.CompletionList, 10, &LB_ADDSTRING, 0, edi
            Pop edi, D$edi, ecx, edx
            inc ecx
            jmp L2>

        Else
L2:         While B$edi > LF | inc edi | End_While | inc edi
            On edi >= edx, jmp L9>
            Mov al B$CompletionModel
            On al >= B$edi, jmp L0<

        End_If

    .Else_If B$edi <= al
        jmp L2<

    .End_If

L9: dec ecx | On ecx = 0-1, Call ListAllEquates
ret


; No matching Equate found > propose the full List:

ListAllEquates:
    Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ "Do you want the complete List?

(This may take some time to build the list)" EOS}, {B$ 'No such OS Equate' EOS},
&MB_YESNO__&MB_SYSTEMMODAL

    If eax = &IDNO
        Mov ecx 0-1 | ret
    End_If

    On D$EquateIncMemory = 0, ret
    On D$EquatesIncFileSize = 0, ret

    Mov esi D$EquateIncMemory, edx esi | add edx D$EquatesIncFileSize

L0: Mov edi esi | While B$edi > SPC | inc edi | End_While

    Push edx, esi D$edi, edi
        Mov B$edi 0
        Call 'USER32.SendDlgItemMessageA' D$H.CompletionList, 10, &LB_ADDSTRING, 0, esi
    Pop edi, D$edi, esi, edx

    If eax <> &LB_ERR
        Mov esi edi |  While B$esi-1 <> LF | inc esi | End_While
        On esi < edx, jmp L0<
    End_If
ret


Win32EquatesSubstitute:
    Mov B$CompletionRuning &TRUE, B$Underline &FALSE, D$CompletionMode 0

    Mov esi D$STRUCT.EditData@CurrentWritingPos

L0: Call EraseLastChar | ;Call AskForRedrawNow
    Mov eax D$STRUCT.EditData@CurrentWritingPos
    cmp B$eax-1 '&' | jne L0<

L1: Mov esi D$CompletionPointer
    While B$esi > SPC
        Push esi
            movzx eax B$esi | Call InsertSource
            Move D$STRUCT.EditData@PhysicalCaretRow D$STRUCT.EditData@CaretRow
        Pop esi
        inc esi
    End_While

    Call AskForRedrawNow

    Mov B$CompletionRuning &FALSE
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

KillCompletionList:

    ; While the Completion ListBox is runing, there are many user actions that may
    ; require to close this ListBox (moves of Caret by KeyBoard or Mouse)
    test D$H.CompletionList NA ZERO S1>

        Call 'USER32.SendMessageA' D$H.CompletionList,
                                   &WM_COMMAND,
                                   &IDCANCEL,
                                   0

S1: Mov D$Underline &FALSE

    Call AskForRedraw

ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Search          ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
 _______________________________________________________________________________________
 _______________________________________________________________________________________

;                              Search / replace routines:
 _______________________________________________________________________________________
 _______________________________________________________________________________________


; Dialog Box for Find/Replace and simple search. writing
; "U$ 04 0 0 0CA 03D" at FRdialog+4 turns it simple search

[FRdialog: D$ 090C008C2 0      ; Style
 U$ 0C 0 0 0CB 06A             ; Dim  >>>   U$ 04 0 0 0CA 03D  ; Dim for search only
 0                             ; Menu (not yet)
 0                             ; Class(not yet)
 'Search what' 0               ; Title
 08 'Helv' 0]                  ; Font

[@FRC0: D$ 050000202 0          ; Style
 U$ 02 0 0C8 093               ; Dim
 012C                          ; ID
 0FFFF 085                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data

[@FRC1: D$ 050000001 0          ; Style
 U$ 089 02A 03F 011            ; Dim
 &FR_FINDNEXT                   ; ID
 0FFFF 080                     ; Class
 'Search' 0                    ; Title
 0]                            ; No creation data

[@FRC2: D$ 050000000 0          ; Style
 U$ 089 013 03F 011            ; Dim
 &FR_DIALOGTERM                 ; ID
 0FFFF 080                     ; Class
 'Close' 0                     ; Title
 0]                            ; No creation data

[@FRC3: D$ 050000003 0          ; Style
 U$ 047 029 036 010            ; Dim
 FR_WHOLEWORD                  ; ID
 0FFFF 080                     ; Class
 'Whole word' 0                 ; Title
 0]                            ; No creation data

[@FRC4: D$ 050000007 0          ; Style
 U$ 02 0F 080 02C              ; Dim
 041                           ; ID
 0FFFF 080                     ; Class
 'Search Flags' 0              ; Title
 0]                            ; No creation data

[@FRC5: D$ 050000009 0          ; Style
 U$ 07 019 038 010             ; Dim
 FR_UP                         ; ID
 0FFFF 080                     ; Class
 'Upward' 0                    ; Title
 0]                            ; No creation data

[@FRC6: D$ 050000009 0          ; Style
 U$ 07 029 038 010             ; Dim
 FR_DOWN                       ; ID
 0FFFF 080                     ; Class
 'Downward' 0                  ; Title
 0]                            ; No creation data

[@FRC7: D$ 050000003 0          ; Style
 U$ 047 01B 032 0E             ; Dim
 FR_MATCHCASE                  ; ID
 0FFFF 080                     ; Class
 'Case' 0                      ; Title
 0]                            ; No creation data    <<<<<<<<<<<< end of simple search

[@FRC8: D$ 050000027 0          ; Style
 U$ 0 049 0CC 07               ; Dim
 0133                          ; ID
 0FFFF 080                     ; Class
 'Replace with' 0              ; Title
 0]                            ; No creation data

[@FRC9: D$ 050000000 0          ; Style
 U$ 042 046 040 011            ; Dim
 FR_REPLACEALL                 ; ID
 0FFFF 080                     ; Class
 'Replace all' 0               ; Title
 0]                            ; No creation data

[@FRC10: D$ 050000000 0         ; Style
 U$ 089 046 03F 011            ; Dim
 FR_REPLACE                    ; ID
 0FFFF 080                     ; Class
 'Find/Replace' 0              ; Title
 0]                            ; No creation data

[@FRC11: D$ 050000202 0         ; Style
 U$ 01 05B 0C8 093             ; Dim
 0136                          ; ID
 0FFFF 085                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data



[FR_UP 150    FR_DOWN 151    FR_WHOLEWORD 154    FR_MATCHCASE 155
 FR_REPLACEALL 156    FR_REPLACE 157]

________________________________________________________________________________________

; these setting use the same Dialog Box data for both options:

SetFindReplaceBox:
    Mov B$Replace &TRUE
    Mov edi FRdialog | add edi 8
    Mov ax 0C | stosw | Mov eax 0 | stosd | Mov eax 06A_00CB | stosd  ; U$ 0C 0 0 0CB 06A
    jmp L9>

SetSimpleSearchBox:
    Mov B$Replace &FALSE
    Mov edi FRdialog | add edi 8
    Mov ax 08 | stosw | Mov eax 0 | stosd | Mov eax 0_3D_00CB | stosd  ; U$ 04 0 0 0CB 03D

L9: If D$H.FindReplace = 0
        Call 'USER32.CreateDialogIndirectParamA' D$H.Instance, FRdialog, D$H.MainWindow, FRproc, 0
    Else
        Call Beep
    End_If
ret


[H.UserSearchString: D$ ?
 H.UserReplaceString: D$ ?
 OnReplace: D$ ?
 LenOfSearchedString: D$ ?
 LenOfReplaceString: D$ ?]

[StringChange: D$ ?]

GetUserSearchString:
    Mov edi ControlString, esi SearchString, ecx 120 | rep movsb
    Mov edi SearchString, al 0, ecx 120 | rep stosb
    Call 'USER32.SendMessageA' D$H.UserSearchString &WM_GETTEXTLENGTH 0 0
    Mov D$LenOfSearchedString eax
    On eax = 0, ret
    Mov D$LenOfSearchedString eax
 ; "WM_GETTEXTLENGTH" message does not include end mark. "WM_GETTEXT" does >>> inc eax
    inc eax
    Call 'USER32.SendMessageA' D$H.UserSearchString &WM_GETTEXT eax SearchString
    Mov B$OnReplace &FALSE

  ; Control if user changed the string for FindOrReplace flag in FRproc. (if he changed
  ; between a Find and a Replace, we have to reset to search again):
    Mov B$StringChange &FALSE
    Mov edi ControlString, esi SearchString, ecx 120 | rep cmpsb | je L5>
      Mov B$StringChange &TRUE

  ; add (only new) string to List and delete last one (limit=15 strings):

L5: Call 'USER32.SendMessageA' D$H.UserSearchString  &CB_FINDSTRINGEXACT 0-1 SearchString
    If eax = &CB_ERR
        Call 'USER32.SendMessageA' D$H.UserSearchString &CB_INSERTSTRING 0  SearchString
        Call 'USER32.SendMessageA' D$H.UserSearchString &CB_DELETESTRING 15 0
    End_If
ret

GetUserReplaceString:
    Mov edi ReplaceWithString, al 0, ecx 120 | rep stosb
    Call 'USER32.SendMessageA' D$H.UserReplaceString, &WM_GETTEXTLENGTH, 0, 0
    Mov D$LenOfReplaceString eax
    On eax = 0, ret
    inc eax
    Call 'USER32.SendMessageA' D$H.UserReplaceString, &WM_GETTEXT, eax, ReplaceWithString
    Mov B$OnReplace &TRUE

  ; add (only new) string to List and delete last one (limit=15 strings):
    Call 'USER32.SendMessageA' D$H.UserReplaceString, &CB_FINDSTRINGEXACT, 0-1,
                               ReplaceWithString
    If eax = &CB_ERR
      Call 'USER32.SendMessageA' D$H.UserReplaceString, &CB_INSERTSTRING, 0,
                                 ReplaceWithString
      Call 'USER32.SendMessageA' D$H.UserReplaceString, &CB_DELETESTRING, 15, 0
    End_If
ret


; Set them all to previous state (third parameter) at initialisation time:

SetSearchFlagButtons:
    Call 'USER32.GetDlgItem' D$H.FindReplace, FR_DOWN
    Call 'USER32.SendMessageA' eax, &BM_SETCHECK, D$DownSearch, 0

    Call 'USER32.GetDlgItem' D$H.FindReplace, FR_UP
    Mov ebx D$DownSearch | xor ebx &TRUE
    Call 'USER32.SendMessageA' eax, &BM_SETCHECK, ebx, 0

    Call 'USER32.GetDlgItem' D$H.FindReplace, FR_MATCHCASE
    Call 'USER32.SendMessageA' eax, &BM_SETCHECK, D$CaseSearch, 0

    Call 'USER32.GetDlgItem' D$H.FindReplace, FR_WHOLEWORD
    Call 'USER32.SendMessageA' eax, &BM_SETCHECK, D$WholeWordSearch, 0
ret


[STR01: B$ ? # 120] [@STR02: B$ ? # 120] [@STR03: B$ ? # 120] [@STR04: B$ ? # 120] [@STR05: B$ ? # 120]
[@STR06: B$ ? # 120] [@STR07: B$ ? # 120] [@STR08: B$ ? # 120] [@STR09: B$ ? # 120] [@STR10: B$ ? # 120]
[@STR11: B$ ? # 120] [@STR12: B$ ? # 120] [@STR13: B$ ? # 120] [@STR14: B$ ? # 120] [@STR15: B$ ? # 120]
[@STR16: D$ ?]
[RTR01: B$ ? # 120] [@RTR02: B$ ? # 120] [@RTR03: B$ ? # 120] [@RTR04: B$ ? # 120] [@RTR05: B$ ? # 120]
[@RTR06: B$ ? # 120] [@RTR07: B$ ? # 120] [@RTR08: B$ ? # 120] [@RTR09: B$ ? # 120] [@RTR10: B$ ? # 120]
[@RTR11: B$ ? # 120] [@RTR12: B$ ? # 120] [@RTR13: B$ ? # 120] [@RTR14: B$ ? # 120] [@RTR15: B$ ? # 120]
[RTR16: D$ ?]
[STR_RTR_len: RTR16-STR01]

StoreSearchStrings:
  ; ecx = [(120 bytes * 30) / 4] + 2 (edges) = 902
    Mov edi STR01, eax 0, ecx D$STR_RTR_len | rep stosb                  ; clear all tables
    Call 'USER32.SendMessageA' D$H.UserSearchString, &CB_GETCOUNT, 0, 0
    On eax = &CB_ERR, ret

    Mov edi STR01, ebx 0

    While eax > 0
      Push eax, ebx, edi
        Call 'USER32.SendMessageA' D$H.UserSearchString, &CB_GETLBTEXT, ebx, edi
      Pop edi, ebx, eax
      dec eax | inc ebx | add edi 120
    End_While

    Call 'USER32.SendMessageA' D$H.UserReplaceString, &CB_GETCOUNT, 0, 0
    On eax = &CB_ERR, ret

    Mov edi RTR01, ebx 0

    While eax > 0
      Push eax, ebx, edi
        Call 'USER32.SendMessageA' D$H.UserReplaceString, &CB_GETLBTEXT, ebx, edi
      Pop edi, ebx, eax
      dec eax | inc ebx | add edi 120
    End_While
ret


RestoreSearchStrings:
    Mov esi STR01, ebx 0
    While B$esi > 0
        Push ebx, esi
            Call 'USER32.SendMessageA' D$H.UserSearchString, &CB_INSERTSTRING, ebx, esi
        Pop esi, ebx
        inc ebx | add esi 120
    End_While

    Mov esi RTR01, ebx 0
    While B$esi > 0
        Push ebx, esi
            Call 'USER32.SendMessageA' D$H.UserReplaceString, &CB_INSERTSTRING, ebx, esi
        Pop esi, ebx
        inc ebx | add esi 120
    End_While
ret

_____________________________________________________________________________________

[FinfOrReplace: D$ ?
 H.FindReplace: D$ ?]

Proc FRproc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg  = &WM_INITDIALOG
        Mov B$ShiftBlockInside &FALSE

        Move D$H.FindReplace D@hwnd
        Mov B$FinfOrReplace &FALSE                  ; flag 0 for Search / 1 Replace
        Call 'USER32.GetDlgItem' D@hwnd 012C     ; 012C = our Find Edit Box
        Mov D$H.UserSearchString eax
        Call 'USER32.GetDlgItem' D@hwnd 0136     ; 0136 = our Replace Edit Box
        Mov D$H.UserReplaceString eax
        Call RestoreSearchStrings
        Call SetSearchFlagButtons
        Call 'USER32.SetFocus' D$H.UserSearchString  ; return 0  to
        Call 'USER32.SetClassLongA' D$H.FindReplace &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        jmp L8>>                                        ; keep focus to first edit control

    ...Else_If D@msg = &WM_COMMAND
        Mov eax D@wParam
        .If eax = &FR_DIALOGTERM
L0:         Call StoreSearchStrings
            Mov D$H.FindReplace 0
            Call 'USER32.DestroyWindow' D@hwnd
        .Else_If eax = &FR_FINDNEXT
L1:         Call GetUserSearchString
            On D$LenOfSearchedString = 0, jmp L8>>
                Call RestoreRealSource
                    Call StringSearch
                    On D$FL.BlockInside = &TRUE, Mov B$FinfOrReplace &TRUE ; ready for Replace if whished
                Call SetPartialEditionFromPos
        .Else_If eax = &IDCANCEL
            jmp L0<
        .Else_If eax = &IDOK
            jmp L1<
        .Else_If eax = FR_DOWN
            Mov B$DownSearch &TRUE, B$FinfOrReplace &FALSE
        .Else_If eax = FR_UP
           Mov B$DownSearch &FALSE, B$FinfOrReplace &FALSE
        .Else_If eax = FR_MATCHCASE
           xor B$CaseSearch &TRUE | Mov B$FinfOrReplace &FALSE
        .Else_If eax = FR_WHOLEWORD
           xor B$WholeWordSearch &TRUE | Mov B$FinfOrReplace &FALSE
        .Else_If eax = FR_REPLACE
           Call GetUserSearchString | Call GetUserReplaceString
           ..If B$FinfOrReplace = &TRUE
                If B$StringChange = &TRUE   ; see "StringChange" comment in GetUserSearchString
                    Mov B$FinfOrReplace &FALSE
                    Call RestoreRealSource
                        Call StringSearch
                    Call SetPartialEditionFromPos
                Else
                  On D$LenOfSearchedString > 0, Call StringReplace  ; &TRUE > Replace
                End_If
           ..Else
                Call RestoreRealSource
                    Call StringSearch                               ; false > Search
                Call SetPartialEditionFromPos
           ..End_If
           xor B$FinfOrReplace &TRUE
        .Else_If eax = FR_REPLACEALL
           Call RestoreRealSource
                Call GetUserReplaceString | Call GetUserSearchString
                On D$LenOfSearchedString > 0,  Call StringReplaceAll
           Call SetPartialEditionFromPos
        .Else
           jmp L8>
        .End_If

        Call 'USER32.SetFocus' D@hwnd

    ...Else_If D@msg = &WM_CTLCOLOREDIT
        Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>

    ...Else
L8:     popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE

L9: EndP



[SearchString: B$ ? # 120]
[ReplaceWithString: B$ ? # 120]
[ControlString:B$ ? # 120]

[DownSearch: D$ ?
 CaseSearch: D$ ?
 WholeWordSearch: D$ ?
 SkipDashLines: D$ ?
 Replace: D$ ?
 StringFound: D$ ?]

[StringNotFound: B$ 'String not found' EOS]

[NextSearchPos: D$ ?]

[Lowcase | cmp #1 'A' | jb C9> | cmp #1 'Z' | ja C9> | or #1 SPC | C9:]

; If user change the searched string inside a Find/Replace process, we have to reset
; the "FindOrReplace" flag in FRproc:

StringSearch:
    Mov B$ShiftBlockInside &FALSE, B$StringFound &TRUE

    On D$LenOfSearchedString = 0, ret
    Mov D$FL.BlockInside &FALSE

L0: Mov edi SearchString, esi edi, edx D$LenOfSearchedString
    dec edx                                                     ; - first tested char
    If B$DownSearch = &TRUE
        Mov ah B$edi | inc edi | Mov ebx 1
    Else
        add edi edx | Mov ah B$edi | dec edi | std | Mov ebx 0-1; ebx > inc/dec edi in L4 loop
    End_If

    On B$CaseSearch = &FALSE, LowCase ah

    If D$NextSearchPos = 0
        Mov esi D$STRUCT.EditData@CurrentWritingPos
    Else
        Mov esi D$NextSearchPos
        On esi > D$STRUCT.EditData@SourceEnd, Mov esi D$STRUCT.EditData@CurrentWritingPos       ; case of massive block delete
    End_If

L2: cmp esi D$STRUCT.EditData@SourceEnd | ja L8>>                               ; search for fitting first Char:
    cmp esi D$CodeSource | jb L8>>
        lodsb | On B$CaseSearch = &FALSE, LowCase al
        cmp al ah | jne L2<

    ..If edx = 0                                                ; len = 1 > string found
        Mov D$NextSearchPos esi
    ..Else
       Mov ecx edx                                              ; first letter found:
       Push eax, esi, edi
L4:      .If esi > D$STRUCT.EditData@SourceEnd
             Pop edi, esi, eax | jmp L8>>
         .Else_If esi < D$CodeSource
             Pop edi, esi, eax | jmp L8>>
         .Else
K0:          lodsb | Mov ah al
             If B$SkipDashLines = &TRUE
                cmp ah '_' | je K0<
             End_If
K0:          Mov al B$edi | add edi ebx
             If B$SkipDashLines = &TRUE
                cmp al '_' | je K0<
             End_If
             If B$CaseSearch = &FALSE
                LowCase ah
                LowCase al
             End_If
             If ah = al
                loop L4<
             Else
                 Pop edi, esi, eax | jmp L2<<
             End_If
             Mov D$NextSearchPos esi
         .End_If
L5:   Pop edi, esi, eax
    ..End_If

    Mov eax D$NextSearchPos                                 ; string found

    If B$DownSearch = &TRUE

        Mov bl B$eax | sub eax (1*ASCII) | Mov D$LP.BlockEndText eax

        sub eax edx | Mov D$STRUCT.EditData@CurrentWritingPos eax | Mov D$LP.BlockStartText eax

        Mov bh B$eax-1

    Else
        Mov bl B$eax | inc eax | Mov D$STRUCT.EditData@CurrentWritingPos eax | Mov D$LP.BlockStartText eax
        Mov D$NextSearchPos eax

        add eax edx | Mov D$LP.BlockEndText eax

        Mov bh B$eax+1

    End_If

    .If B$WholeWordSearch = &TRUE
        Mov al bl | Call WordEdge
        If B$Edge = &TRUE
            Mov al bh | Call WordEdge
        End_If
        If B$Edge = &FALSE
            jmp L0<<
        End_If
    .End_If

    std | Mov D$FL.BlockInside &TRUE, D$STRUCT.EditData@RightScroll 0
L6: lodsb | cmp al LF | ja L6<
        dec esi | Mov ebx esi | add ebx 2                     ; for caret h. Pos. count
L6: lodsb | cmp al LF | ja L6<                              ; start printing 2 lines upper
        dec esi
L6: lodsb | cmp al LF | ja L6<
        add esi 2

    If esi >= D$CodeSource
        Mov D$STRUCT.EditData@UpperLine esi
    Else
        Move D$STRUCT.EditData@UpperLine D$CodeSource
    End_If

    Call SetCaret D$LP.BlockEndText | jmp L9>

L8: cld
    If B$OnReplaceAll = &FALSE
        Call MessageBox StringNotFound     ; if not found
        Mov B$StringFound &FALSE
    End_If
    Mov D$NextSearchPos 0

L9: cld | On B$Disassembling = &FALSE, Call AskForRedrawNow
ret


[ReplaceStart: D$ ?]

StringReplace:
    Mov B$ShiftBlockInside &FALSE

    .If D$FL.BlockInside = &TRUE
        Call ControlX

        Mov ecx D$LP.BlockEndText

        Mov D$ReplaceStart ecx

        sub ecx D$LP.BlockStartText | add ecx (1*ASCII)

        dec D$STRUCT.EditData@CaretRow | dec D$STRUCT.EditData@PhysicalCaretRow
        Mov esi ReplaceWithString
        While B$esi <> 0
            lodsb
            pushad
                movzx eax al | Call InsertSource
            popad
            inc D$STRUCT.EditData@CaretRow | inc D$STRUCT.EditData@PhysicalCaretRow
            If al = LF
                Mov D$STRUCT.EditData@CaretRow 1
            End_If
        End_While
    .Else
       jmp StringSearch
    .End_If

    If B$DownSearch = &TRUE
        Move D$NextSearchPos D$STRUCT.EditData@CurrentWritingPos
    Else
        Move D$NextSearchPos D$ReplaceStart
    End_If

    Call AskForRedrawNow
ret


[AllDanger: B$ "

  Are you sure you want 'replace all' ?

" EOS  AllTitle: B$ 'Danger:' EOS]

[OnReplaceAll: SilentSearch: D$ ?]

StringReplaceAll:
    Call 'USER32.MessageBoxA' D$H.MainWindow, AllDanger, AllTitle,
                              &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL

    ..If eax = &IDYES
        Mov B$OnReplaceAll &TRUE

L0:     Call RestoreRealSource
            Call StringSearch
        Call SetPartialEditionFromPos

        cmp D$FL.BlockInside &TRUE | jne L9>

        Call AskForRedrawNow | Call StringReplace | jmp L0<

L9:     Mov B$OnReplaceAll &FALSE
    ..End_If
ret

;StringReplaceAll:
    Mov B$ShiftBlockInside &FALSE

    Call 'USER32.MessageBoxA' D$H.MainWindow, AllDanger, AllTitle,
                              &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL

    ..If eax = &IDYES
        Mov B$OnReplaceAll &TRUE
L0:     Call RestoreRealSource
        Call StringSearch | cmp D$FL.BlockInside &TRUE | jne L9>
        Call StringReplace
        Call SetPartialEditionFromPos | jmp L0<

L9:     Mov B$OnReplaceAll &FALSE
        Call SetPartialEditionFromPos
    ..End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Config          ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
 _______________________________________________________________________________________
 _______________________________________________________________________________________

; Configuration TAB:

[StaticClassName: B$ 'STATIC' EOS
 ButtonClassName: B$ 'BUTTON' EOS]

[H.ConfigTab: D$ ?]

[FirstTab: B$ 'Tree View' EOS];       FirstTabLen: D$ len ; !!! B$ -> D$ non aligned
[SecondTab: B$ 'Sources Editor' EOS];  SecondTabLen: D$ len
[ThirdTab: B$ 'Bad Habits' EOS];       ThirdTabLen: D$ len
[FourthTab: B$ 'Colors' EOS];          FourthTabLen: D$ len
[FifthTab: B$ 'Help Files' EOS];        FifthTabLen: D$ len
[SixthTab: B$ 'Companion Files' EOS];  SixthTabLen: D$ len
[SeventhTab: B$ 'User Menu' EOS];      SeventhTabLen: D$ len
[HeigthTab: B$ 'Pos' EOS];               HeigthTabLen: D$ len
[NinethTab: B$ 'Lang' EOS];              NinethTabLen: D$ len
[DBPMenuTab: B$ 'DBP' EOS];              DBPMenuLen: D$ len
[APItab: B$ 'API' EOS];             APItabLen: D$ len]

[CalcName: B$ 'Calc.exe' EOS @tail: 0 # &MAX_PATH]                       ; If same dir
[EquatesName: B$ 'Equates.equ' EOS @tail: 0 # &MAX_PATH]
[F2Name: D$ ? # &MAX_PATH]
[CalcLinkName: B$ 'C:\Program Files\BaseCalc\BASECALC.EXE' EOS  OnCalc: 0] ; If Link to...

;[Asm32TutName: 'Asm32Help.exe' EOS @tail: 0 # &MAX_PATH]
[Win32HlpName: B$ 'Win32.hlp' EOS @tail: 0 # &MAX_PATH]
[MmediaHlpName: B$ 'Mmedia.hlp' EOS @tail: 0 # &MAX_PATH]
[OpenGlHlpName: B$ 'OpenGl.hlp' EOS @tail: 0 # &MAX_PATH]
;[OpcodeHlpName: B$ 'x86eas.hlp' EOS @tail: 0 # &MAX_PATH]
;[WinDataFileName: B$ 'WindowsData.inc' EOS @tail: 0 # &MAX_PATH]
[DxHlpName:    'directx.chm' EOS @tail: 0 # &MAX_PATH]
[WinsockHlpName: B$ 'Winsock.hlp' EOS @tail: 0 # &MAX_PATH]
[SDLRefName: B$ 'SDLRef.chm' EOS @tail: 0 # &MAX_PATH]
[sqliteName: B$ 'sqlite.hlp' EOS @tail: 0 # &MAX_PATH]
[DevILName: B$ 'DevIL.html' EOS @tail: 0 # &MAX_PATH]
[ClipName: B$ 'Clip.txt' EOS @tail: 0 # &MAX_PATH]
[B_U_AsmName: B$ 'B_U_Asm.exe' EOS @tail: 0 # &MAX_PATH]

[EntryPointLabel: B$ 'MAIN' EOS 0 0 0 0 0 0 0 0 0
 EntryPointLabelLen: len]       ; upper case needed
;;
  Take care, that since the implementation of the "Tag Main NewName" Feature, this 
  'EntryPointLabelLen' can no more be used as such, and must be re-computed:
;;
[CallBackName: B$ 'MainWindowProc'
 CallBackNameLen: len]

[TC_ITEM:
 @TC_imask: &TCIF_TEXT+&TCIF_IMAGE
 @TC_lpReserved1: 0
 @TC_lpReserved2: 0
 TC_pszText: 0
 @TC_cchTextMax: 0
 @TC_iImage: 0-1
 @TC_lParam: 0]

[ITB1: B$ "

Tree view is build by analyze of main labels and of calls to these main labels® If you validate [List orphans], the list will be added all 'non-called' main labels.

If you validate [First Call only],  and some label is called many times, it will be listed at first Call occurence only." EOS ]

 ________________________________________________________________________

[H.ConfigTabbedDialog: D$ ?
 ConfigTabIndex: D$ ?
 CtrlYflag: D$ ?
 FL.SecurityWanted: D$ ?]

[TabIs: D$ 4
 FL.SoundsWanted: D$ &TRUE]
____________________________________________________________________________________________
____________________________________________________________________________________________

; Providing the required Path for "BUAsm Files" (Equates.equ and friends).

[FolderPath: B$ ? # &MAX_PATH]
[PathInfo: B$ 'Choose a Path' EOS]
[PathTitle: B$ 'For BUAsm Files' EOS]

[STRUC.BROWSEINFOA:
 @hwndOwner: D$ 0
 @pidlRoot: D$ 0
 @pszDisplayName: D$ 0
 @lpszTitle: D$ 0
 @ulFlags: D$ &BIF_RETURNONLYFSDIRS+&BIF_DONTGOBELOWDOMAIN+&BIF_USENEWUI
 @lpfn: D$ cbBrowse
 @lParam: D$ PathInfo
 @iImage: D$ 0]

[BrowseForFolderAborted: D$ ?]

Proc BrowseForFolder:

    Arguments @hParent,
              @PathTitle

    Mov D$FolderPath 0

    Move D$STRUC.BROWSEINFOA@hwndOwner D@hParent,
         D$STRUC.BROWSEINFOA@lpszTitle D@PathTitle

    Call 'SHELL32.SHBrowseForFolder' STRUC.BROWSEINFOA

    If eax <> &FALSE

        Push eax

            Call 'SHELL32.SHGetPathFromIDList' eax,
                                               FolderPath
        Pop eax

        Mov B$BrowseForFolderAborted &FALSE

    Else

        Mov B$BrowseForFolderAborted &TRUE

    End_If

    Call 'OLE32.CoTaskMemFree' eax

EndP


Proc cbBrowse:

    Arguments @hWin,
              @uMsg,
              @lParam,
              @lpData

    Call 'USER32.SetWindowTextA' D@hWin,
                                 D@lpData

EndP


; User has selected a Path for BUsmFiles (Equates.equ *must* be there).

[MustHaveEquatesPath: B$ "
You have not provided a Path to Equates.equ.

BUAsm is going to shut down, because it can't do anything       
whithout the OS Equates List.

" EOS]


[BadEquatesPath: B$ "
You have provided a Path for 'Equates.equ',
but this File is not there.

           Try again?


" EOS]


VerifyEquatesPath:
    ..If D$FolderPath = 0
        If D$FL.Includes = &FALSE
L1:         Call 'USER32.MessageBoxA' D$H.MainWindow, MustHaveEquatesPath, Argh, &MB_SYSTEMMODAL
            Call 'KERNEL32.ExitProcess' 0
        End_If

        Mov eax 0-1

    ..Else
        Mov eax FolderPath
        While B$eax <> 0 | inc eax | End_While
        Mov D$eax '\Equ', D$eax+4 'ates', D$eax+8 '.equ', B$eax+12 0
        Mov eax FolderPath

        Call 'KERNEL32.FindFirstFileA' FolderPath, STRUC.FindFile

        .If eax = &INVALID_HANDLE_VALUE
            Call 'USER32.MessageBoxA' D$H.MainWindow, BadEquatesPath, Argh,
                                      &MB_YESNO+&MB_SYSTEMMODAL+&MB_ICONQUESTION
            If eax = &IDNO
                On D$FL.Includes = &FALSE, jmp L1<<
                Mov eax 0-1

            Else
                Mov eax 0

            End_If

        .Else
            Call 'KERNEL32.FindClose' eax

            Mov eax FolderPath

        .End_If

    ..End_If
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; Tag Dialog 3000 >>> Main
; Tag Dialog 4000 >>> ListView
; Tag Dialog 4100 >>> Sources Editor
; Tag Dialog 4200 >>> Bad Habit
; Tag Dialog 4300 >>> Colors
; Tag Dialog 4400 >>> Help Files
; Tag Dialog 4500 >>> Companion Files
; Tag Dialog 4600 >>> User Menu
; Tag Dialog 4700 >>> Pos
; Tag Dialog 4800 >>> National Language
; Tag Dialog 4900 >>> Definition of the BP Menu

Configuration:

    If D$H.ConfigDialog = 0

        Call 'USER32.DialogBoxParamA' D$H.Instance, 3000, &NULL, ConfigTabProc, &NULL

    Else

        Call Beep

    End_If

ret


InitConfigDialogTab:
    Call 'USER32.GetDlgItem' D$H.ConfigDialog, 100 | Mov D$H.ConfigTab eax

    Mov D$TC_pszText FirstTab ;| Move D$TC_cchTextMax, D$FirstTabLen
    Call 'USER32.SendMessageA' D$H.ConfigTab, &TCM_INSERTITEM, 0, TC_ITEM

    Move D$TC_pszText SecondTab ;| Move D$TC_cchTextMax D$SecondTabLen
    Call 'USER32.SendMessageA' D$H.ConfigTab, &TCM_INSERTITEM, 1, TC_ITEM

    Move D$TC_pszText ThirdTab ;| Move D$TC_cchTextMax, D$ThirdTabLen
    Call 'USER32.SendMessageA' D$H.ConfigTab, &TCM_INSERTITEM, 2, TC_ITEM

    Move D$TC_pszText FourthTab ;| Move D$TC_cchTextMax D$FourthTabLen
    Call 'USER32.SendMessageA' D$H.ConfigTab, &TCM_INSERTITEM, 3, TC_ITEM

    Move D$TC_pszText FifthTab ;| Move D$TC_cchTextMax D$FifthTabLen
    Call 'USER32.SendMessageA' D$H.ConfigTab, &TCM_INSERTITEM, 4, TC_ITEM

    Move D$TC_pszText SixthTab ;| Move D$TC_cchTextMax D$SixthTabLen
    Call 'USER32.SendMessageA' D$H.ConfigTab, &TCM_INSERTITEM, 5, TC_ITEM

    Move D$TC_pszText SeventhTab ;| Move D$TC_cchTextMax, D$SeventhTabLen
    Call 'USER32.SendMessageA' D$H.ConfigTab, &TCM_INSERTITEM, 6, TC_ITEM

    Move D$TC_pszText HeigthTab ;| Move D$TC_cchTextMax D$HeigthTabLen
    Call 'USER32.SendMessageA' D$H.ConfigTab, &TCM_INSERTITEM, 7, TC_ITEM

    Move D$TC_pszText NinethTab ;| Move D$TC_cchTextMax D$NinethTabLen
    Call 'USER32.SendMessageA' D$H.ConfigTab, &TCM_INSERTITEM, 8, TC_ITEM

    Move D$TC_pszText DBPMenuTab ;| Move D$TC_cchTextMax D$DBPMenuLen
    Call 'USER32.SendMessageA' D$H.ConfigTab, &TCM_INSERTITEM, 9, TC_ITEM

    Move D$TC_pszText APItab ;| Move D$TC_cchTextMax D$APItabLen
    Call 'USER32.SendMessageA' D$H.ConfigTab, &TCM_INSERTITEM, 10, TC_ITEM
ret

____________________________________________________________________________________________

; The Main Proc for Configuration:

[H.ConfigDialog: D$ ?]

; Tag Dialog 4100 [Text Editor]

Proc ConfigTabProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_INITDIALOG
        .If D$H.ConfigDialog = 0
            Move D$H.ConfigDialog D@hwnd
            Call InitConfigDialogTab
            Call 'USER32.CreateDialogParamA' D$H.Instance, 4000, D$H.ConfigTab,
                                             ConfigTabProc, &NULL
            Mov D$H.ConfigTabbedDialog eax, D$ConfigTabIndex 0
            Call InittabTreeView
            Call 'USER32.SetClassLongA' D$H.ConfigDialog &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        .End_If
        jmp L8>>

    ...Else_If D@msg = &WM_NOTIFY
        Mov esi D@lParam, eax D$esi+8
        ..If eax = &TCN_SELCHANGE
            Call 'USER32.SendMessageA' D$H.ConfigTab, &TCM_GETCURSEL, 0, 0
            Mov D$ConfigTabIndex eax

            Call 'USER32.DestroyWindow' D$H.ConfigTabbedDialog
            Mov eax D$ConfigTabIndex, ecx 100 | mul ecx | add eax 4000
Push D$StringsLanguage ; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            Call 'USER32.CreateDialogParamA' D$H.Instance, eax, D$H.ConfigTab,
                                             ConfigTabProc, &NULL
            Mov D$H.ConfigTabbedDialog eax
Pop D$StringsLanguage  ; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            .If D$ConfigTabIndex = 0
                Call InittabTreeView
            .Else_If D$ConfigTabIndex = 1
                Call InitTabTextEditor
            .Else_If D$ConfigTabIndex = 2
                Call InitBadHabits
            .Else_If D$ConfigTabIndex = 3
                Call InitTabColors
            .Else_If D$ConfigTabIndex = 4
                Call InitTabHelpFiles
            .Else_If D$ConfigTabIndex = 5
                Call InitTabOtherFiles
            .Else_If D$ConfigTabIndex = 6
                Call InitTabUserMenu
            .Else_If D$ConfigTabIndex = 7
                Call InitTabPos
            .Else_If D$ConfigTabIndex = 8
                Call InitTabLang
            .Else_If D$ConfigTabIndex = 9
                Call InitTabdbp
            .Else_If D$ConfigTabIndex = 10
; Tag Dialog 5000
                Call InitTabAPI
            .End_If

        ..End_If

    ...Else_If D@msg = &WM_COMMAND
        Mov eax D@wParam | and D@wParam 0FFFF | shr eax 16

        ..If D@wParam = &IDCANCEL
            jmp L1>

        ..Else_If D@wParam = &IDOK
            Call UpdateRegistry

            If D$H.UserPopUp > 0
                Call 'USER32.DeleteMenu' D$H.MenuMain 7 &MF_BYPOSITION
            End_If
            Call AddUserMenu | Call EnableMenutems | Call EnableHelpMenutems
            Call 'USER32.DrawMenuBar' D$H.MainWindow
L1:         Call 'USER32.DestroyWindow' D@hwnd
            Mov D$H.ConfigDialog 0

        ..Else_If D@wParam = &IDHELP
            Call Help, B_U_AsmName, ConfigHelp, ContextHlpMessage

        ..Else_If eax = &BN_CLICKED
            Mov eax D@wParam
            .If D$ConfigTabIndex = 0                ; Tree View.
                If eax = 11                         ; Check Orphans
                    xor B$ShowOrphan &TRUE
                Else_If eax = 12                    ; Check First Call only
                    xor B$ShowLabelsOnce &TRUE
                Else_If eax = 13                    ; Check Tree View Auto-Hide
                    Call CloseTree
                    xor B$AutoHideTreeView &TRUE
                Else_If eax = 14                    ; Rebuild tree after each Compilation
                    xor B$AutoRebuildTreeView &TRUE
                End_If

            .Else_If D$ConfigTabIndex = 1           ; Text Editor.
                Call GetEditorConfig D@hwnd


            .Else_If D$ConfigTabIndex = 2           ; Bad Habits.
                If eax = 20
                    xor B$CtrlYFlag &TRUE
                Else_If eax = 21
                    xor B$BlockAutoDelete &TRUE
                Else_If eax = 22
                    xor B$NoVirtualLimit &TRUE
                Else_If eax = 23
                    xor B$WithControlA &TRUE
                End_If

L2:         .Else_If D$ConfigTabIndex = 3           ; Colors.
                pushad
                    If eax = 20                     ;D$Color1Handle
                        Mov eax D$ARVB.BackColor | Call SetColor
                        Mov D$ARVB.BackColor eax | Call INIT_BackGroundColors
                    Else_If eax = 10                ; Color 2
                        Mov eax D$StatementColor | Call SetColor | Mov D$StatementColor eax
                    Else_If eax = 11                ; Color 3
                        Mov eax D$CommentColor | Call SetColor | Mov D$CommentColor eax
                    Else_If eax = 12                ; Color 4
                        Mov eax D$TextColor | Call SetColor | Mov D$TextColor eax
                    Else_If eax = 13                ; Color 5
                        Mov eax D$BracketColor | Call SetColor | Mov D$BracketColor eax
                    Else_If eax = 21                ; Color of Edit Controls, List Boxes,...
                        Mov eax D$ARVB.DialogsBackColor | Call SetColor
                        Mov D$ARVB.DialogsBackColor eax | Call INIT_BackGroundColors
                    Else_If eax = 30
                        xor B$WantSizeMarkerColor &TRUE
                    End_If

                    Call AskForRedrawNow
                popad

            .Else_If D$ConfigTabIndex = 4           ; Help Files.
                If eax = 500
                    Call Help, B_U_AsmName, HelPFiles, ContextHlpMessage
                Else
                    Call ConfigHelpFiles
                End_If

            .Else_If D$ConfigTabIndex = 5           ; Other Files

                pushad
                    Push eax
                        If eax = 14
L1:                         Call BrowseForFolder D@hwnd, PathTitle
                            Call VerifyEquatesPath | On eax = &FALSE, jmp L1<
                                                     On eax <> 0-1, jmp L1>
                            Pop eax | jmp L2>
                        Else
                            Call ConfigSearchFile       ; returns Ptr or 0 in eax
                        End_If
L1:                 Pop ebx
                    On eax = 0, jmp L2>>
                    Mov esi eax
                    If ebx = 10
                        Mov edi CalcName
                    Else_If ebx = 11
                        Mov edi ClipName
                    Else_If ebx = 12
                        Mov edi B_U_AsmName
                    Else_If ebx = 13
                        Mov edi F2Name
                    Else_If ebx = 14
                        Mov edi EquatesName
                    Else
                        jmp L2>
                    End_If

                    Do
                        lodsb | stosb
                    Loop_Until al = 0

                    Call InitTabOtherFiles
L2:             popad

            .Else_If D$ConfigTabIndex = 6           ; User Menu
                On eax < 310, jmp L1>
                    On eax > 320, jmp L1>
                        Call StripOneMenuUserItem | jmp L7>>

L1:             pushad
                    Call CheckUserMenuItemText | On eax = 0, jmp L2>>
                popad
                pushad
                    Push eax
                        Call ConfigSearchFile       ; returns Ptr or 0 in eax
                    Pop ebx
                    On eax = 0, jmp L2>>
                    Mov esi eax

                    If ebx = 110
                        Mov edi UserMenu0Path
                    Else_If ebx = 111
                        Mov edi UserMenu1Path
                    Else_If ebx = 112
                        Mov edi UserMenu2Path
                    Else_If ebx = 113
                        Mov edi UserMenu3Path
                    Else_If ebx = 114
                        Mov edi UserMenu4Path | I9: jmp I9>    ; just because no more '.'If
                    Else_If ebx = 115
                        Mov edi UserMenu5Path
                    Else_If ebx = 116
                        Mov edi UserMenu6Path
                    Else_If ebx = 117
                        Mov edi UserMenu7Path
                    Else_If ebx = 118
                        Mov edi UserMenu8Path
                    Else_If ebx = 119
                        Mov edi UserMenu9Path
                    Else
                        jmp L2>
                    End_If

                    Do
                        lodsb | stosb
                    Loop_Until al = 0
                    Call SaveUserMenuTab | Call InitTabUserMenu
L2:             popad

            .Else_If D$ConfigTabIndex = 7           ; Pos
                If eax = 50
                    On D$FL.SaveMainPos = &FALSE Call GetUserPosTab
                Else_If eax = 51
                    On D$FL.SaveMainPos = &FALSE Call SaveUserPosTab
                Else_If eax = 52
                    Call SetMaximized
                Else_If eax = 20
                    xor D$FL.SaveMainPos &TRUE | Call InitTabPos
                End_If

          ; Tag Dialog 4800

             .Else_If D$ConfigTabIndex = 8           ; Lang
                Call SetNationalLanguage

             .Else_If D$ConfigTabIndex = 9           ; DBPMenu
                Call SetDBPMenu

             .Else_If D$ConfigTabIndex = 10          ; API verifications
                sub eax 10 | Mov D$ApiCheckFlag eax

             .End_If

        ..End_If

    ...Else_If D@msg = &WM_CTLCOLOREDIT
        jmp L1>

    ...Else_If D@msg = &WM_CTLCOLORLISTBOX
L1:     Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>

    ...Else
L8:     popad | Mov eax &FALSE | jmp L9>

    ...End_If

L7: popad | Mov eax &TRUE

L9: EndP
____________________________________________________________________________________________

[NATION_CHOOSEFONT: ; EditorCHOOSEFONT
 @lStructSize: D$ len
 @hwndOwner: D$ 0
 @hDC: D$ 0
 @lpLogFont: D$ NATION_LOGFONT
 @iPointSize: D$ 0
 @Flags: D$ &CF_SCREENFONTS__&CF_INITTOLOGFONTSTRUCT
 @rgbColors: D$ 0
 @lCustData: D$ 0
 @lpfnHook: D$ 0
 @lpTemplateName: D$ 0
 @hInstance: D$ 0
 @lpszStyle: D$ &SCREEN_FONTTYPE
 @nFontType: W$ 0
 @Alignment: W$ 0
 @nSizeMin: D$ 0
 @nSizeMax: D$ 0]

[NATION_LOGFONT: ; EditorLOGFONT
 @lfHeight: D$ 0
 @lfWidth: D$ 0
 @lfEscapement: D$ 0
 @lfOrientation: D$ 0
 @lfWeight: D$ 0
 @lfItalic: B$ 0
 @lfUnderline: B$ 0
 @lfStrikeOut: B$ 0
 @lfCharSet: B$ 0
 @lfOutPrecision: B$ 0
 @lfClipPrecision: B$ 0
 @lfQuality: B$ 0
 @lfPitchAndFamily: B$ 0
 @lfFaceName: B$ 0 # &LF_FACESIZE
 NATION_LOGFONTlen: D$ len] ; NATION_LOGFONT@lfFaceName

[H.NationalFont: D$ ?]

GetNationalFont:
    Move D$NATION_CHOOSEFONT@hwndOwner D$H.ConfigDialog
    Call 'Comdlg32.ChooseFontA' NATION_CHOOSEFONT

    If eax = &TRUE
        On D$H.NationalFont <> 0, Call 'GDI32.DeleteObject' D$H.NationalFont
        Call 'GDI32.CreateFontIndirectA' NATION_LOGFONT | Mov D$H.NationalFont eax
    End_If
ret


ConfigHelpFiles:
    pushad
        Push eax
            Call ConfigSearchFile       ; returns Ptr or 0 in eax
        Pop ebx
        On eax = 0, jmp L2>>
        Mov esi eax
        .If ebx = 10
        ;  Mov edi Asm32TutName
        .Else_If ebx = 11
            Mov edi Win32HlpName
        .Else_If ebx = 12
            Mov edi MmediaHlpName
        .Else_If ebx = 13
            Mov edi OpenGlHlpName
        .Else_If ebx = 14
        ; Mov edi OpcodeHlpName
        .Else_If ebx = 15
        ;   Mov edi WinDataFileName ;| I9: jmp I9>
    ; .Else_If ebx = 16
    ;     Mov edi B_U_AsmName    ; Now only in [Other Files]
        .Else_If ebx = 17
            Mov edi DxHlpName
        .Else_If ebx = 18
            Mov edi WinsockHlpName
        .Else_If ebx = 19
            Mov edi SDLRefName
        .Else_If ebx = 20
            Mov edi sqliteName
        .Else_If ebx = 21
            Mov edi DevILName
        .End_If

        Do
            lodsb | stosb
        Loop_Until al = 0
        Call InitTabHelpFiles
L2: popad
ret


Proc GetEditorConfig:
    Argument @Parent

        .If eax = 11                    ; TAB is 2 spaces
            Mov D$TabIs 2
        .Else_If eax = 12                    ; TAB is 4 spaces
            Mov D$TabIs 4
        .Else_If eax = 13                    ; TAB is 8 spaces
            Mov D$TabIs 8

        .Else_If eax = 50
            Call XorScrollBar
        .Else_If eax = 51
            xor D$FL.SecurityWanted &TRUE
        .Else_If eax = 52
            xor B$DollarOnly &TRUE
        .Else_If eax = 53                         ; Indent
            xor D$AutoIndentFlag &TRUE
            On B$AutoIndentFlag = &FALSE, Mov D$AutoIndent 0
        .Else_If eax = 54
            xor B$LoadMRU &TRUE
           ; Call 'USER32.CheckDlgButton' D@Parent 54 D$LoadMRU
        .Else_If eax = 55
            Call XorToolBar
        .Else_If eax = 56
            xor D$FL.SoundsWanted &TRUE
        .Else_If eax = 57
            xor B$CompletionWanted &TRUE
       ; .Else_If eax = 58
       ;     xor B$WriteCheckerWanted &TRUE
        .Else_If eax = 58
            If B$ParagraphChar = 167    ; Paragraph
                Mov B$ParagraphChar 36  ; Dollar
            Else
                Mov B$ParagraphChar 167
            End_If
        .Else_If eax = 201
            Call GetMaxBackUp
        .Else
            Call CheckFontAndBlink
        .End_If
EndP


GetMaxBackUp:
    Mov D$MaxBackUp 0
    Call 'USER32.GetDlgItemTextA' D$H.ConfigTabbedDialog, 200,
                                  MaxBackUp, 5

    On B$MaxBackUp = 0, Mov D$MaxBackUp '0000'

    While B$MaxBackUp+3 = 0
        shl D$MaxBackUp 8 | Mov B$MaxBackUp '0'
    End_While

    Call UpDateRegistry
ret


XorScrollBar:

    xor D$FL.ScrollBarWanted &TRUE | Call RedrawInterface

ret


XorToolBar:

    xor D$FL.ToolBarWanted &TRUE | Call RedrawInterface

ret


InittabTreeView:

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      10,
                                      &WM_SETTEXT,
                                      0,
                                      ITB1

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      11,
                                      &BM_SETCHECK,
                                      D$ShowOrphan,
                                      0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      12,
                                      &BM_SETCHECK,
                                      D$ShowLabelsOnce,
                                      0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      13,
                                      &BM_SETCHECK,
                                      D$AutoHideTreeView,
                                      0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      14,
                                      &BM_SETCHECK,
                                      D$AutoRebuildTreeView,
                                      0

ret

InitTabTextEditor:

    Mov ebx D$TabIs | and ebx 2 | shr ebx 1

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      11,
                                      &BM_SETCHECK,
                                      ebx,
                                      0

    Mov ebx D$TabIs | and ebx 4 | shr ebx 2

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      12,
                                      &BM_SETCHECK,
                                      ebx,
                                      0

    Mov ebx D$TabIs | and ebx 8 | shr ebx 3

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      13,
                                      &BM_SETCHECK,
                                      ebx,
                                      0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      50,
                                      &BM_SETCHECK,
                                      D$FL.ScrollBarWanted,
                                      0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      51,
                                      &BM_SETCHECK,
                                      D$FL.SecurityWanted,
                                      0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      52,
                                      &BM_SETCHECK,
                                      D$DollarOnly,
                                      0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      53,
                                      &BM_SETCHECK,
                                      D$AutoIndentFlag,
                                      0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      54,
                                      &BM_SETCHECK,
                                      D$LoadMRU,
                                      0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      55,
                                      &BM_SETCHECK,
                                      D$FL.ToolBarWanted,
                                      0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      56,
                                      &BM_SETCHECK,
                                      D$FL.SoundsWanted,
                                      0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      57,
                                      &BM_SETCHECK,
                                      D$CompletionWanted,
                                      0

   ; Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 58, &BM_SETCHECK,
   ;                                   D$WriteCheckerWanted, 0

    If B$ParagraphChar = 167

        Mov eax &TRUE

    Else

        Mov eax &FALSE

    End_If

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      58,
                                      &BM_SETCHECK,
                                      eax,
                                      0

    Mov eax MaxBackUp

    While B$eax = '0'

        add eax ASCII

    End_While

    On B$eax = 0 sub eax ASCII

    Call 'USER32.SetDlgItemTextA' D$H.ConfigTabbedDialog,
                                  200,
                                  eax

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      200,
                                      &EM_SETLIMITTEXT,
                                      4,
                                      0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                      301,
                                      &BM_SETCHECK,
                                      D$FL.BlinkingCaretWanted,
                                      0

    Call 'USER32.SetDlgItemInt' D$H.ConfigTabbedDialog,
                                302,
                                D$DU.CaretTime,
                                0

ret
____________________________________________________________________________________________

[BadHabittext: B$ "

A Sources Editor is not a Text Editor. 


This is why i spend much work-time with writing the Sources Editor from scratch instead of doing what most other IDEs Authors do:

Making use of an Edit or Richedit Control.

If you disagree with my choices these Flags are under your own decision.


Again, my recommandation: 

Do not use these Flags. 
These actions are incompatible with Assembly Edition, because they are going to help to corrupt your Sources." EOS]

InitBadHabits:
    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 10, &WM_SETTEXT,
                                      0, BadHabittext

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 20, &BM_SETCHECK,
                                      D$CtrlYFlag, 0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 21, &BM_SETCHECK,
                                      D$BlockAutoDelete, 0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 22, &BM_SETCHECK,
                                      D$NoVirtualLimit, 0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 23, &BM_SETCHECK,
                                      D$WithControlA, 0
ret
____________________________________________________________________________________________


CheckFontAndBlink:
    .If eax > 13
        If eax = 20
            Call SelectFont

        Else
            jmp CheckBlinkCaret

        End_If

    .End_If
ret

CheckBlinkCaret:
    If eax = 301
        Call KillBlinkCursor
        xor D$FL.BlinkingCaretWanted &TRUE
        On B$FL.BlinkingCaretWanted = &TRUE, Call InitBlinkCursor
        Call AskForRedraw

    Else_If eax = 303
        Call 'USER32.GetDlgItemInt' D$H.ConfigTabbedDialog, 302, 0, 0
        Mov D$DU.CaretTime eax
        Call ResetBlinkCursor

    Else_If eax = 320
        xor B$CompletionWanted &TRUE

    End_If
ret


InitTabColors:
    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 30, &BM_SETCHECK,
                                      D$WantSizeMarkerColor, 0
ret


InitTabHelpFiles:
;    Mov esi HelpFilesPathsPtrs, ebx 110
;L0: Push ebx esi
;        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog ebx &WM_SETTEXT 0 D$esi
;    Pop esi ebx
;    add esi 4 | inc ebx | cmp D$esi 0 | ja L0<
    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 111, &WM_SETTEXT 0,
                                      Win32HlpName
    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 112, &WM_SETTEXT 0,
                                      MmediaHlpName
    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 113, &WM_SETTEXT 0,
                                      OpenGlHlpName
    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 117, &WM_SETTEXT 0,
                                      DxHlpName
    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 118, &WM_SETTEXT 0,
                                      WinsockHlpName
    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 119, &WM_SETTEXT 0,
                                      SDLRefName
    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 120, &WM_SETTEXT 0,
                                      sqliteName
    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 121, &WM_SETTEXT 0,
                                      DevILName
ret


[OthersFilesPathsPtrs: CalcName ClipName B_U_AsmName F2Name EquatesName 0]

InitTabOtherFiles:
    Mov esi OthersFilesPathsPtrs, ebx 100
L0: Push ebx esi
        If D$esi = EquatesName
            Push esi
                Mov esi EquatesName
                While B$esi <> 0 | inc esi | End_While
                While D$esi <> 'Equa' | dec esi | End_While
                Mov B$esi 0
            Pop esi
        End_If
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, ebx, &WM_SETTEXT, 0,
                                          D$esi
    Pop esi ebx
    add esi 4 | inc ebx | cmp D$esi 0 | ja L0<

    Mov esi EquatesName
    While B$esi <> 0 | inc esi | End_While
    On D$esi+1 = 'quat', Mov B$esi 'E'
ret

;;
  Note: a Durty hack up there, because i don't want to rewrite all of the Routines
  concerned by 'EquatesName' (providing the Path to all RosAsm Files, now). Previously
  i did not know how to do what 'BrowseForFolder' actually does, and i was retrieving
  the Path by runing a usual 'GetOpenFileName' pointing to Equates.equ.
;;


[UserMenuItemsPtrs: UserMenu0String UserMenu1String UserMenu2String UserMenu3String
                    UserMenu4String UserMenu5String UserMenu6String UserMenu7String
                    UserMenu8String UserMenu9String 0

 UserMenuPathsPtrs: UserMenu0Path UserMenu1Path UserMenu2Path UserMenu3Path
                    UserMenu4Path UserMenu5Path UserMenu6Path UserMenu7Path
                    UserMenu8Path UserMenu9Path 0]

InitTabUserMenu:
    Mov esi UserMenuItemsPtrs, edi UserMenuPathsPtrs, ebx 10, ecx 210

L0: Push edi, ecx, esi, ebx
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, ecx, &WM_SETTEXT,
                                          0, D$edi
        Pop ebx, esi | Push esi, ebx
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, ebx, &WM_SETTEXT,
                                          0, D$esi
    Pop ebx, esi, ecx, edi
    add esi 4 | add edi 4 | inc ebx | inc ecx
    cmp D$esi 0 | ja L0<
ret


; ebx = 310 Based ID of [x] Button.

StripOneMenuUserItem:
    sub eax 310
  ; 'UserMenu0String' length is 8 dWords (32 Bytes per Record)
  ; 'UserMenu0Path' is 64 dWords (256 Bytes per Record)
  ; (sizes for ease of pointing).

    shl eax 5 ; * 32  (8 * dWord)

    lea edi D$UserMenu0String+eax | Mov esi edi | add esi (4*8)
    Mov ecx (8*8) | rep movsd

    shl eax 3  ; this is 3 more times > * 256 (64 * dWord)

    lea edi D$UserMenu0Path+eax | Mov esi edi | add esi (4*64)
    Mov ecx (64*8) | rep movsd

    Call InitTabUserMenu
ret


; Tag Dialog 4700 >>> Pos

InitTabPos:
     Call 'USER32.SetDlgItemInt' D$H.ConfigTabbedDialog, 10, D$WindowX, &NULL
     Call 'USER32.SetDlgItemInt' D$H.ConfigTabbedDialog, 11, D$WindowY, &NULL
     Call 'USER32.SetDlgItemInt' D$H.ConfigTabbedDialog, 12, D$WindowW, &NULL
     Call 'USER32.SetDlgItemInt' D$H.ConfigTabbedDialog, 13, D$WindowH, &NULL

     If B$IsMaximizedFlag = &SW_MAXIMIZE
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 52,
                                          &BM_SETCHECK &TRUE, 0
        Mov eax &FALSE

     Else_If D$FL.SaveMainPos = &TRUE

        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog,
                                          20,
                                          &BM_SETCHECK &TRUE,
                                          0

        Mov eax &FALSE

     End_If

     Push eax
     Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 10, &WM_ENABLE, eax, 0
     Pop eax | Push eax
     Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 11, &WM_ENABLE, eax, 0
     Pop eax | Push eax
     Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 12, &WM_ENABLE, eax, 0
     Pop eax
     Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 13, &WM_ENABLE, eax, 0
ret


SetMaximized:
     If B$IsMaximizedFlag = &SW_SHOWNORMAL
        Mov B$IsMaximizedFlag &SW_MAXIMIZE
     Else
        Mov B$IsMaximizedFlag &SW_SHOWNORMAL
     End_If

     Call 'USER32.ShowWindow'  D$H.MainWindow, D$IsMaximizedFlag
ret

; Tag Dialog 4800

InitTabLang:
    .If D$StringsLanguage = '.en'
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 10, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.fr'
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 11, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.br'
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 12, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.sp'
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 13, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.zh'
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 14, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.it'
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 15, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.de'
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 16, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.no'
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 17, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.ca'
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 18, &BM_SETCHECK, 1, 0
    .Else
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 10, &BM_SETCHECK, 1, 0
    .End_If

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 100, &EM_SETMARGINS,
                                      &EC_LEFTMARGIN__&EC_RIGHTMARGIN, 0100010

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 100, &WM_SETTEXT, 0,
    {B$ "
This Tab is for the definition of the Language to be used for displaying the Errors Messages given at Compile-Time, by the Assembler. The method will be generalized to the other Messages progressively.

Before using, you must have the National Strings Files, in a '.../RosAsmFiles/Lang/' Folder. If you downloaded 'RosAsmFull.zip', you have nothing to do. If you dowloaded the partial Files, unzip 'LangFiles.zip', in such a Folder.

The [National Font] Button is for choosing the Font to be used for dispaying the Error Messages. For the 'Ascii Users', this is just an option, but for the 'Unicode Users', - actualy only the [Chinese] ones -, this Font MUST be defined.

If your Language is missing, in this list, and if you wish to do the translation work, go to your Directory of 'RosAsm Files', and, in the [Lang] Folder, take the 'RosAsmStrings.en' Files, in any Editor.

In this File:

The '$$$$1', '$$$$2', ... Markers are simple Strings IDs, that you have to leave the way they are. These IDs are used by RosAsm to point out what National String subsitution matches with the default one.

In case you would see some '#1', '#2', ... inside a String, let these special Markers, as they are. These ones are used by RosAsm to mark the Positions of some Components of the Strings. For example, if an Error Message includes a Variable Number, these Markers are replaced on the fly, by the wished Numbers.

When you are over with a Translation, send me your work by Mail, at < betov@free.fr >, so that i could include it, and implement the needed Radio Button is this Tab.

" EOS}
ret
____________________________________________________________________________________________

[DOUBLE_CLICK_ACTION 2  RIGHT_CLICK_ACTION 3]

[DBPMenuOn: DOUBLE_CLICK_ACTION]

InitTabdbp:
    If D$DBPMenuOn = DOUBLE_CLICK_ACTION
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 11, &BM_SETCHECK, 1, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 12, &BM_SETCHECK, 0, 0
    Else
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 11, &BM_SETCHECK, 0, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 12, &BM_SETCHECK, 1, 0
    End_If
ret


[ApiCheckFlag: D$ ?] ; 0 // &DONT_RESOLVE_DLL_REFERENCES // No Verifiction

[ApiCheckInfo: B$ "
Beginners: Let this Flag [Normal].

When compiling a Source, RosAsm does several verifications on your API calls, in order to point you to typos, missing DLLs, and so on...

In some exeptional cases (WDM drivers, General Hocks, ...) this may be a problem. So, if you perfectly know what you are doing, two Flags let you define the behaviour of RosAsm:

With the DONT_RESOLVE_DLL_REFERENCES Flag, the verifications of your calls will not address the references inside the concerned DLLS.

The last Flag will completely skip your API calls verifications. You do not need to set it for WDM Drivers, because, in the case of .SYS files, no such verification, is done, anyway." EOS]

InitTabAPI:
    Mov eax 10 | add eax D$ApiCheckFlag

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, eax, &BM_SETCHECK, 1, 0

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 100, &WM_SETTEXT, 0, ApiCheckInfo
ret


SetDBPMenu:
    If eax = 11
        Mov D$DBPMenuOn DOUBLE_CLICK_ACTION
    Else
        Mov D$DBPMenuOn RIGHT_CLICK_ACTION
    End_If
ret
____________________________________________________________________________________________

[ConfigFilesFilters: B$ 'All' EOS  '*.*' EOS 0]
[FullPathUserChoice: B$ ? # &MAX_PATH]
[ConfigInitialDir: B$ ? # &MAX_PATH]
[ConfigFileTitle: B$ 'Choose the file to asign to the Menu' EOS]

[CONFIGOPENFILENAME:
 @lStructSize: D$ LEN
 @hWndOwner: D$ 0
 @hInstance: D$ 0
 @lpstrFilter: D$ ConfigFilesFilters
 @lpstrCustomFilter: D$ 0
 @nMaxCustFilter: D$ 0
 @nFilterIndex: D$ 0
 @lpstrFile: D$ FullPathUserChoice
 @nMaxFile: D$ 260
 @lpstrFileTitle: D$ 0
 @nMaxFileTitle: D$ 0
 @lpstrInitialDir: D$ ConfigInitialDir
 @lpstrTitle: D$ ConfigFileTitle
 @Flags: D$ 0281804
 @nFileOffset: W$ 0
 @nFileExtension: W$ 0
 @lpstrDefExt: D$ 0
 @lCustData: D$ 0
 @lpfnHook: D$ 0
 @lpTemplateName: D$ 0]

ConfigSearchFile:
    Move D$CONFIGOPENFILENAME@hWndOwner D$H.ConfigDialog
    Move D$CONFIGOPENFILENAME@hInstance D$H.Instance
    Mov edi FullPathUserChoice, al 0, ecx 260 | rep stosb
    Call 'COMDLG32.GetOpenFileNameA' CONFIGOPENFILENAME
    If B$FullPathUserChoice <> 0
        Mov eax FullPathUserChoice
    Else
        Mov eax 0
    End_If
ret

____________________________________________________________________________________________

; User ask for a 'ConfigSearchFile'. He must first set the Menu Item text:

[TitleErrorUserMenu: B$ 'User Menu:' EOS]
[ErrorUserMenu: B$ 'Enter the Menu item Text in the EditBox first.' EOS]

CheckUserMenuItemText:
  ; > in: eax = ID of [File...] Button (first one = 110
    Push eax
        sub eax 110 | shl eax 5
        lea edi D$UserMenu0String+eax
    Pop eax
    Push edi
        sub eax 100                             ; Menu Item Edit Control (First one = 10)
        Call 'USER32.GetDlgItem' D$H.ConfigTabbedDialog eax
    Pop edi
    Call 'USER32.SendMessageA' eax &WM_GETTEXT 30 edi
    If eax = 0
        Call 'USER32.MessageBoxA' D$H.MainWindow, ErrorUserMenu, TitleErrorUserMenu, &MB_SYSTEMMODAL
        Mov eax &FALSE
    Else
        Mov eax &TRUE
    End_If
ret


SaveUserMenuTab:
    pushad
        Mov edi UserMenu0String, eax 10
L1:     Push edi, eax
            Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, eax,
                                              &WM_GETTEXT, 30, edi
        Pop eax, edi
        inc eax | add edi 32 | cmp edi UserMenu9String | jbe L1<

        Mov esi UserMenu0String, edi UserMenu0Path
L1:     On B$esi = 0, Mov B$edi 0
        add esi 32 | add edi 256 | cmp edi UserMenu9Path | jbe L1<
    popad
ret



GetUserPosTab:

    Call 'USER32.GetWindowRect' D$H.MainWindow,
                                STRUC.RECT.MainWindow

    If D$WindowX > 0FFF_FFFF

        Mov D$WindowX 0

        Mov D$WindowY 0

        Call 'USER32.GetSystemMetrics' &SM_CXSCREEN | Mov D$WindowW eax

        Call 'USER32.GetSystemMetrics' &SM_CYSCREEN | Mov D$WindowH eax

    Else

        Mov eax D$WindowX | sub D$WindowW eax

        Mov eax D$WindowY | sub D$WindowH eax

    End_If

    Call InitTabPos

ret

SaveUserPosTab:

    Call 'USER32.SendDlgItemMessageA' D$H.ConfigTabbedDialog, 20, &BM_GETCHECK, 0, 0

    Mov D$FL.SaveMainPos eax

    Call 'USER32.GetDlgItemInt' D$H.ConfigTabbedDialog, 10, &NULL, &NULL

    Mov D$WindowX eax

    Call 'USER32.GetDlgItemInt' D$H.ConfigTabbedDialog, 11, &NULL, &NULL

    Mov D$WindowY eax

    Call 'USER32.GetDlgItemInt' D$H.ConfigTabbedDialog, 12, &NULL, &NULL

    Mov D$WindowW eax

    Call 'USER32.GetDlgItemInt' D$H.ConfigTabbedDialog, 13, &NULL, &NULL

    Mov D$WindowH eax

    Call 'USER32.MoveWindow' D$H.MainWindow, D$WindowX, D$WindowY, D$WindowW, D$WindowH, &FALSE

    Mov eax D$WindowX | or eax D$WindowY

    ..If eax = 0

        Call 'USER32.GetSystemMetrics' &SM_CXSCREEN

        .If eax = D$WindowW

            Call 'USER32.GetSystemMetrics' &SM_CYSCREEN

            If eax = D$WindowH

                Call 'USER32.ShowWindow' D$H.MainWindow, &SW_MAXIMIZE

            End_If

        .End_If

    ..End_If

ret
____________________________________________________________________________________________


SetColor:

[@CustomColorsSet: D$ ? # 16]; TODO Structure sur pile

[@STRUC.CHOOSECOLORAPI: ; TODO Structure sur pile
 @lStructSize: D$ len
 @hwndOwner: D$ 0
 @hInstance: D$ 0
 @rgbResult: D$ 0
 @lpCustColors: D$ @CustomColorsSet
 @Flags: D$ &CC_RGBINIT+&CC_FULLOPEN
 @lCustData: D$ 0
 @lpfnHook: D$ 0
 @lpTemplateName: D$ 0]

    Move D@hwndOwner D$H.ConfigDialog,
         D@hInstance D$H.Instance

    Mov D@rgbResult eax

    Push eax ; old color set by caller in eax

            Call 'COMDLG32.ChooseColorA' @STRUC.CHOOSECOLORAPI

    Pop eax ; restore old color if no choice

    If eax <> &FALSE

        Mov eax D@rgbResult

    End_If

ret
____________________________________________________________________________________________

; Registry jobs:

[hRegKey: D$ 0
 Result: D$ 0
 @Datatype: D$ 0
 RegistryDataSize: D$ DWORD]

[BUAsmConfigClass: B$ 'BUAsmConfigClass' EOS]
[BUAsmKey: B$ 'Software\BUAsm' EOS]
[Color1: B$ 'Color1' EOS]
[Color2: B$ 'Color2' EOS]
[Color3: B$ 'Color3' EOS]
[Color4: B$ 'Color4' EOS]
[Color5: B$ 'Color5' EOS]
[Color10: B$ 'Color10' EOS]
[SizeColorFlag: B$ 'SizeMarker Color Flag' EOS]

[UserLanguage: B$ 'Lang' EOS]

[Blink: B$ 'Blink' EOS]
[BlinkTime: B$ 'BlinkTime' EOS]

[Complete: B$ 'Complete' EOS]

[PrinterFont: B$ 'PrinterFont' EOS]
[ScrollBar: B$ 'ScrollBar' EOS]
[ToolBar: B$ 'ToolBar' EOS]

[SourceEditorFont: B$ 'SourceEditorFont' EOS]
[NationalLanguageFont: B$ 'NationalLanguageFont' EOS]
[UnicodeEditorFont: B$ 'UnicodeEditorFont' EOS]

[BackUpLimit: B$ 'MaxBackUp' EOS]

[MainPosX: B$ 'MainPosX' EOS]
[MainPosY: B$ 'MainPosY' EOS]
[MainPosW: B$ 'MainPosW' EOS]
[MainPosH: B$ 'MainPosH' EOS]

[SaveMainPos: B$ 'SaveMainPos' EOS]
[IsMaximized: B$ 'IsMaximized' EOS]

[TreeViewReg: B$ 'TreeViewReg' EOS]
[TreeViewReg2: B$ 'TreeViewReg2' EOS]
[TreeViewAutoHide: B$ 'TreeViewAutoHide' EOS]
[TreeRebuild: B$ 'TreeRebuild' EOS]
[TreeW: B$ 'Tree Width' EOS]

[AutoIndentReg: B$ 'AutoIndentReg' EOS]
[TabReg: B$ 'TabReg' EOS]
; Font: B$ 'Font' EOS
[CtrlYis: B$ 'CtrlYis' EOS]
[LoadMRUis: B$ 'LoadLastMRU' EOS]
[BlockAutoDeleteIs: B$ 'BlockAutoDeleteIs' EOS]
[VirtualLimit: B$ 'VirtualLimit' EOS]
[WithCtrlA: B$ 'With Ctrl A' EOS]
[WithSecurity: B$ 'WithSecurity' EOS]
[WithSounds: B$ 'WithSounds' EOS]
[WithDollarOnly: B$ 'Dollar only' EOS]
[WithChecker: B$ 'Write Checker' EOS]
[ParagrafChar: B$ 'ParagrafChar' EOS]

[CalcPath: B$ 'CalcPath' EOS]
[EquatesPath: B$ 'EquatesPath' EOS]
[F2Path: B$ 'F2Path' EOS]
[RosAsmHelpPath: B$ 'RosAsmHelpPath' EOS]

[WinApiPath: B$ 'WinApiPath' EOS]

[MmediaPath: B$ 'MmediaPath' EOS]
[OpenGlPath: B$ 'OpenGlPath' EOS]
[DxPath: B$ 'DxPath' EOS]
[WinSockPath: B$ 'WinSockPath' EOS]
[SDLRefPath: B$ 'SDLRefPath' EOS]
[sqlitePath: B$ 'sqlitePath' EOS]
[DevILPath: B$ 'DevILPath' EOS]
[ClipPath: B$ 'ClipPath' EOS]

[UserMenu0: B$ 'UserMenu0' EOS]
[UserMenu1: B$ 'UserMenu1' EOS]
[UserMenu2: B$ 'UserMenu2' EOS]
[UserMenu3: B$ 'UserMenu3' EOS]
[UserMenu4: B$ 'UserMenu4' EOS]
[UserMenu5: B$ 'UserMenu5' EOS]
[UserMenu6: B$ 'UserMenu6' EOS]
[UserMenu7: B$ 'UserMenu7' EOS]
[UserMenu8: B$ 'UserMenu8' EOS]
[UserMenu9: B$ 'UserMenu9' EOS]
[UserPath0: B$ 'UserMenuPath0' EOS]
[UserPath1: B$ 'UserMenuPath1' EOS]
[UserPath2: B$ 'UserMenuPath2' EOS]
[UserPath3: B$ 'UserMenuPath3' EOS]
[UserPath4: B$ 'UserMenuPath4' EOS]
[UserPath5: B$ 'UserMenuPath5' EOS]
[UserPath6: B$ 'UserMenuPath6' EOS]
[Userpath7: B$ 'UserMenuPath7' EOS]
[UserPath8: B$ 'UserMenuPath8' EOS]
[UserPath9: B$ 'UserMenuPath9' EOS]

[STR.A.MRU1Title: B$ 'MRU1' EOS]
[STR.A.MRU2Title: B$ 'MRU2' EOS]
[STR.A.MRU3Title: B$ 'MRU3' EOS]
[STR.A.MRU4Title: B$ 'MRU4' EOS]
[DBPMenuString: B$ 'DBPMenu' EOS]
[ApiCheckString: B$ 'ApiCheck' EOS]

[UserMenu0String: D$ ? # 8] [UserMenu1String: D$ ? # 8] [UserMenu2String: D$ ? # 8]
[UserMenu3String: D$ ? # 8] [UserMenu4String: D$ ? # 8] [UserMenu5String: D$ ? # 8]
[UserMenu6String: D$ ? # 8] [UserMenu7String: D$ ? # 8] [UserMenu8String: D$ ? # 8]
[UserMenu9String: D$ ? # 8]
;&MAX_PATH = 0104   (0104/4) = 041 = 65
[UserMenu0Path: D$ ? # 64] [UserMenu1Path: D$ ? # 64] [UserMenu2Path: D$ ? # 64] [UserMenu3Path: D$ ? # 64]
[UserMenu4Path: D$ ? # 64] [UserMenu5Path: D$ ? # 64] [UserMenu6Path: D$ ? # 64] [UserMenu7Path: D$ ? # 64]
[UserMenu8Path: D$ ? # 64] [UserMenu9Path: D$ ? # 64]

[RegistryData:
 Color1          &REG_DWORD  ARVB.BackColor
 ; NEVER INSERT ANYTHING !!!
 Color2          &REG_DWORD  StatementColor
 Color3          &REG_DWORD  CommentColor
 Color4          &REG_DWORD  TextColor
 Color5          &REG_DWORD  BracketColor
 Color10         &REG_DWORD  ARVB.DialogsBackColor
 SizeColorFlag   &REG_DWORD  WantSizeMarkerColor
 ; NEVER INSERT ANYTHING !!!
 UserLanguage    &REG_DWORD  StringsLanguage
 NationalLanguageFont &REG_BINARY NATION_LOGFONT
 UnicodeEditorFont &REG_BINARY UNICODE_EDITION_LOGFONT
 ; NEVER INSERT ANYTHING !!!
 Blink           &REG_DWORD  FL.BlinkingCaretWanted
 BlinkTime       &REG_DWORD  DU.CaretTime
 ; NEVER INSERT ANYTHING !!!
 Complete        &REG_DWORD  CompletionWanted
 ; NEVER INSERT ANYTHING !!!
 PrinterFont     &REG_BINARY cbbuffer
 ScrollBar       &REG_DWORD  FL.ScrollBarWanted
 ToolBar         &REG_DWORD  FL.ToolBarWanted
 ; NEVER INSERT ANYTHING !!!
 SourceEditorFont &REG_BINARY EditorLOGFONT
 ; NEVER INSERT ANYTHING !!!
 BackUpLimit     &REG_DWORD  MaxBackUp
 ; NEVER INSERT ANYTHING !!!
 MainPosX        &REG_DWORD  WindowX
 MainPosY        &REG_DWORD  WindowY
 MainPosW        &REG_DWORD  WindowW
 MainPosH        &REG_DWORD  WindowH
 ; NEVER INSERT ANYTHING !!!
 SaveMainPos     &REG_DWORD  FL.SaveMainPos
 IsMaximized     &REG_DWORD  IsMaximizedFlag
 ; NEVER INSERT ANYTHING !!!
 TreeViewReg     &REG_DWORD  ShowOrphan
 TreeViewReg2    &REG_DWORD  ShowLabelsOnce
 TreeViewAutoHide &REG_DWORD AutoHideTreeView
 TreeRebuild     &REG_DWORD  AutoRebuildTreeView
 TreeW           &REG_DWORD  TreeWidth
 ; NEVER INSERT ANYTHING !!!
 AutoIndentReg   &REG_DWORD  AutoIndentFlag
 TabReg          &REG_DWORD  TabIs
 ; Font            &REG_DWORD  UserFont
 CtrlYis         &REG_DWORD  CtrlYflag
 LoadMRUis       &REG_DWORD  LoadMRU
 BlockAutoDeleteIs &REG_DWORD  BlockAutoDelete
 VirtualLimit    &REG_DWORD  NoVirtualLimit
 WithCtrlA       &REG_DWORD  WithControlA
 WithSecurity    &REG_DWORD  FL.SecurityWanted
 WithSounds      &REG_DWORD  FL.SoundsWanted
 WithDollarOnly  &REG_DWORD  DollarOnly
 WithChecker     &REG_DWORD  WriteCheckerWanted
 ParagrafChar    &REG_DWORD  ParagraphChar
 ; NEVER INSERT ANYTHING !!!
 CalcPath        &REG_SZ     CalcName
 EquatesPath     &REG_SZ     EquatesName
 ; NEVER INSERT ANYTHING !!!
 F2Path          &REG_SZ     F2Name
 ; NEVER INSERT ANYTHING !!!
 RosAsmHelpPath   &REG_SZ    B_U_AsmName
 ; NEVER INSERT ANYTHING !!!
 WinApiPath      &REG_SZ     Win32HlpName
 ;  AsmHelPath      &REG_SZ     OpcodeHlpName
 MmediaPath      &REG_SZ     MmediaHlpName
 OpenGlPath      &REG_SZ     OpenGlHlpName
 DxPath          &REG_SZ     DxHlpName
 WinSockPath     &REG_SZ     WinsockHlpName
 SDLRefPath      &REG_SZ     SDLRefName
 sqlitePath      &REG_SZ     sqliteName
 DevILPath       &REG_SZ     DevILName
 ClipPath        &REG_SZ     ClipName
 ; NEVER INSERT ANYTHING !!!
 UserMenu0       &REG_SZ     UserMenu0String
 UserMenu1       &REG_SZ     UserMenu1String
 UserMenu2       &REG_SZ     UserMenu2String
 UserMenu3       &REG_SZ     UserMenu3String
 UserMenu4       &REG_SZ     UserMenu4String
 UserMenu5       &REG_SZ     UserMenu5String
 UserMenu6       &REG_SZ     UserMenu6String
 UserMenu7       &REG_SZ     UserMenu7String
 UserMenu8       &REG_SZ     UserMenu8String
 UserMenu9       &REG_SZ     UserMenu9String
 UserPath0       &REG_SZ     UserMenu0Path
 UserPath1       &REG_SZ     UserMenu1Path
 UserPath2       &REG_SZ     UserMenu2Path
 UserPath3       &REG_SZ     UserMenu3Path
 UserPath4       &REG_SZ     UserMenu4Path
 UserPath5       &REG_SZ     UserMenu5Path
 UserPath6       &REG_SZ     UserMenu6Path
 UserPath7       &REG_SZ     UserMenu7Path
 UserPath8       &REG_SZ     UserMenu8Path
 UserPath9       &REG_SZ     UserMenu9Path
 ; NEVER INSERT ANYTHING !!!
 STR.A.MRU1Title &REG_SZ     STR.A.MRU1
 STR.A.MRU2Title &REG_SZ     STR.A.MRU2
 STR.A.MRU3Title &REG_SZ     STR.A.MRU3
 STR.A.MRU4Title &REG_SZ     STR.A.MRU4
 ; NEVER INSERT ANYTHING !!!
 DBPMenuString   &REG_DWORD  DBPMenuOn
 ; NEVER INSERT ANYTHING !!!
 ApiCheckString  &REG_DWORD  ApiCheckFlag
 ; ALWAYS ADD AT THE END !!!!!!!!!!!!!!!!!!!!
 0]

OpenRegistry:

    Call 'ADVAPI32.RegCreateKeyExA' &HKEY_CURRENT_USER,
                                    BUAsmKey,
                                    0,
                                    BUAsmConfigClass,
                                    0,
                                    &KEY_READ+&KEY_WRITE+&KEY_QUERY_VALUE,
                                    0,
                                    hRegKey,
                                    Result

ret


ReadRegistry:

    Mov esi RegistryData

    ...If D$Result = &REG_CREATED_NEW_KEY
      ; Case of new installation of the Registry:
L1:     Push esi
            Call GetFieldDataSize esi
            Call 'ADVAPI32.RegSetValueExA' D$hRegKey, D$esi, 0, D$esi+4, D$esi+8, eax
        Pop esi
        On eax <> &ERROR_SUCCESS, jmp AutoInit
        add esi 12 | cmp D$esi 0 | ja L1<<

        Call AutoInit

    ...Else
      ; Case of existing Registry to be read:
L1:     Push esi
            lea ebx D$esi+4 | Mov D$RegistryDataSize 0FF
            Call 'ADVAPI32.RegQueryValueExA' D$hRegKey, D$esi, 0, ebx, D$esi+8,
                                             RegistryDataSize
            .If eax <> &ERROR_SUCCESS
                Pop esi | Push esi
                Call GetFieldDataSize esi
                Call 'ADVAPI32.RegSetValueExA' D$hRegKey, D$esi, 0, D$esi+4, D$esi+8, eax
            .End_If
        Pop esi
        add esi 12 | cmp D$esi 0 | ja L1<<
    ...End_If

    Call CloseRegistry
ret


UpdateRegistry:
    On D$UserConfig = CONFIGFILE, jmp WriteConfigFile

    Call OpenRegistry

    Mov esi RegistryData
  ; either &REG_BINARY // &REG_DWORD // &REG_SZ
L1: Push esi
        Call GetFieldDataSize esi
        Call 'ADVAPI32.RegSetValueExA' D$hRegKey, D$esi, 0, D$esi+4, D$esi+8, eax
    Pop esi
    add esi 12 | cmp D$esi 0 | ja L1<<

    Call CloseRegistry
ret


Proc GetFieldDataSize:

    Argument @Pointer

    Uses esi

        Mov esi D@Pointer
      ; esi >>> One Key in 'RegistryData': PointerToName // &FLAG // RosAsmData
      ; &FLAG can be: &REG_BINARY // &REG_DWORD // &REG_SZ
        If D$esi+4 = &REG_DWORD
            Mov eax 4
      ; cases of Fonts LOGFONT Structures:
        Else_If D$esi = PrinterFont
          ; Static size of cbbuffer (&REG_BINARY):
            Mov eax 60
        Else_If D$esi = SourceEditorFont
            Mov eax D$EditorLOGFONT.len
        Else_If D$esi = NationalLanguageFont
            Mov eax D$NATION_LOGFONTlen
        Else_If D$esi = UnicodeEditorFont
            Move eax D$UNICODE_EDITION_LOGFONTlen
      ; Cases of Strings (&REG_SZ):
        Else
            Push edi
                Mov edi D$esi+8, ecx 0FFFF, al 0 | repne scasb
                sub ecx 0FFFF | neg ecx | Mov eax ecx
            Pop edi
        End_If
      ; eax = Size of the Data to be saved into the Registry Key:
EndP


CloseRegistry:
    Call 'ADVAPI32.RegCloseKey' D$hRegKey
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  Auto initialize the companion Files registries if this is a first install done
  after unzipping the whole Package.
;;


AutoInit:  ; 'RegistryData'

    Call GetDirectory ActualDir

    Mov edi ActualDir | While B$edi <> 0 | inc edi | End_While

    On B$edi-1 <> '\', Mov B$edi '\' | inc edi
  ; ...\RosAsmFiles\
    Mov D$edi 'RosA', D$edi+4 'smFi', D$edi+8 'les\' | add edi 12
    Mov D$ActualDirPointer edi

  ; 'Equates.inc'
    Mov D$edi 'Equa', D$edi+4 'tes.', D$edi+8 'equ'
    Call 'KERNEL32.FindFirstFileA' ActualDir, WIN32_FIND_DATA

    .If eax <> &INVALID_HANDLE_VALUE
        Call 'KERNEL32.FindClose' eax
        Mov esi ActualDir, edi EquatesName
        While B$esi <> 0 | movsb | End_While | Mov B$edi 0

      ; 'B_U_Asm.exe'
        Mov edi D$ActualDirPointer
        Mov D$edi 'B_U_', D$edi+4 'Asm.', D$edi+8 'exe', B$edi+12 0
        Call 'KERNEL32.FindFirstFileA' ActualDir, WIN32_FIND_DATA

        If eax <> &INVALID_HANDLE_VALUE
            Call 'KERNEL32.FindClose' eax
            Mov esi ActualDir, edi B_U_AsmName
            While B$esi <> 0 | movsb | End_While | Mov B$edi 0
        End_If

      ; 'Clip.txt
        Mov edi D$ActualDirPointer
        Mov D$edi 'Clip', D$edi+4 '.txt', B$edi+8 0
        Call 'KERNEL32.FindFirstFileA' ActualDir, WIN32_FIND_DATA
        If eax <> &INVALID_HANDLE_VALUE
            Call 'KERNEL32.FindClose' eax
            Mov esi ActualDir, edi ClipName
            While B$esi <> 0 | movsb | End_While | Mov B$edi 0
        End_If

    .End_If
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; add a User Menu if any.

[H.UserPopUp: D$ ?]
[UserPopMenu: B$ 'User' EOS]

AddUserMenu:
    On B$UserMenu0Path = EOS ret

    On B$UserMenu0String = EOS ret


    Call 'USER32.CreatePopupMenu' | Mov D$H.UserPopUp eax

    Call 'USER32.AppendMenuA' D$H.UserPopUp,
                              &MF_STRING,
                              2000,
                              UserMenu0String

    On B$UserMenu1Path = EOS jmp S1>>

    On B$UserMenu1String = EOS jmp S1>>

        Call 'USER32.AppendMenuA' D$H.UserPopUp,
                                  &MF_STRING,
                                  2001,
                                  UserMenu1String

    On B$UserMenu2Path = EOS jmp S1>>

    On B$UserMenu2String = EOS jmp S1>>

        Call 'USER32.AppendMenuA' D$H.UserPopUp,
                                  &MF_STRING,
                                  2002,
                                  UserMenu2String

    On B$UserMenu3Path = EOS jmp S1>>

    On B$UserMenu3String = EOS jmp S1>>

        Call 'USER32.AppendMenuA' D$H.UserPopUp,
                                  &MF_STRING,
                                  2003,
                                  UserMenu3String

    On B$UserMenu4Path = EOS jmp S1>>

    On B$UserMenu4String = EOS jmp S1>>

        Call 'USER32.AppendMenuA' D$H.UserPopUp,
                                  &MF_STRING,
                                  2004,
                                  UserMenu4String

    On B$UserMenu5Path = EOS jmp S1>>

    On B$UserMenu5String = EOS jmp S1>>

        Call 'USER32.AppendMenuA' D$H.UserPopUp,
                                  &MF_STRING,
                                  2005,
                                  UserMenu5String

    On B$UserMenu6Path = EOS jmp S1>>

    On B$UserMenu6String = EOS jmp S1>>

        Call 'USER32.AppendMenuA' D$H.UserPopUp,
                                  &MF_STRING,
                                  2006,
                                  UserMenu6String

    On B$UserMenu7Path = EOS jmp S1>

    On B$UserMenu7String = EOS jmp S1>

        Call 'USER32.AppendMenuA' D$H.UserPopUp,
                                  &MF_STRING,
                                  2007,
                                  UserMenu7String

    On B$UserMenu8Path = EOS jmp S1>

    On B$UserMenu8String = EOS jmp S1>

        Call 'USER32.AppendMenuA' D$H.UserPopUp,
                                  &MF_STRING,
                                  2008,
                                  UserMenu8String

    On B$UserMenu9Path = EOS jmp S1>

    On B$UserMenu9String = EOS jmp S1>

        Call 'USER32.AppendMenuA' D$H.UserPopUp,
                                  &MF_STRING,
                                  2009,
                                  UserMenu9String

S1: Call 'USER32.InsertMenuA' D$H.MenuMain,
                              7,
                              &MF_BYPOSITION+&MF_STRING+&MF_POPUP,
                              D$H.UserPopUp,
                              UserPopMenu

ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; Using a Config File instead of the Registry. Implemented by Eric, October the 19th of 2006

[ConfigBinaryName: B$ 'config.bin' EOS]
[H.ConfigFile: D$ ?
 ConfigSizeReadWrite: D$ ?]
[ConfigDataSize: D$ ?]
[ConfigFilePath: B$ ? # &MAX_PATH]

SetMainConfigFilePath:

    Push esi

        Call GetDirectory ConfigFilePath

        Mov edi ConfigFilePath,
            eax 0,
            ecx 0-1

        repne scasb | dec edi

        On B$edi-1 <> '\' Mov B$edi '\'

        add edi ASCII

        Mov esi ConfigBinaryName,
            ecx 13

        rep movsb

    Pop esi

ret


WriteConfigFile:

    Push esi,
         edi

    Call 'KERNEL32.CreateFileA' ConfigFilePath,
                                &GENERIC_READ+&GENERIC_WRITE,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE,
                                &NULL,
                                &CREATE_ALWAYS,
                                &FILE_ATTRIBUTE_ARCHIVE,
                                &NULL

    Mov D$H.ConfigFile eax

    Mov esi RegistryData

L0: Call GetFieldDataSize esi

        Mov D$ConfigDataSize eax

        Call 'KERNEL32.WriteFile' D$H.ConfigFile,
                                  ConfigDataSize,
                                  (4*ASCII),
                                  ConfigSizeReadWrite,
                                  &NULL

        Call 'KERNEL32.WriteFile' D$H.ConfigFile,
                                  D$esi+(8*ASCII),
                                  D$ConfigDataSize,
                                  ConfigSizeReadWrite,
                                  &NULL

    add esi (12*ASCII) | Comp D$esi 0 > L0<

    Call 'KERNEL32.CloseHandle' D$H.ConfigFile

    Pop edi,
        esi

ret


ReadConfigFile:

    Push esi

        Call SetMainConfigFilePath

        Call 'KERNEL32.CreateFileA' ConfigFilePath,
                                    &GENERIC_READ+&GENERIC_WRITE,
                                    &FILE_SHARE_READ+&FILE_SHARE_WRITE,
                                    &NULL,
                                    &OPEN_EXISTING,
                                    &FILE_ATTRIBUTE_ARCHIVE,
                                    &NULL

        Mov D$H.ConfigFile eax

        Mov esi RegistryData

        ; The config is  structured like: [dword: sizeof data][data]
        ; So get the first dword and store it in >ConfigDataSize< :
L0:     Call 'KERNEL32.ReadFile' D$H.ConfigFile,
                                 ConfigDataSize,
                                 (4*ASCII),
                                 ConfigSizeReadWrite,
                                 &NULL

            ; Read the block of data the sizeof >ConfigDataSize< and copy into
            ; RegistryData:
            Call 'KERNEL32.ReadFile' D$H.ConfigFile,
                                     D$esi+(8*ASCII),
                                     D$ConfigDataSize,
                                     ConfigSizeReadWrite,
                                     &NULL

        add esi (12*ASCII) | Comp D$esi 0 > L0<

        Call 'KERNEL32.CloseHandle' D$H.ConfigFile

    Pop esi

ret
____________________________________________________________________________________________

;;
  When the Config.bin file is being used on an USB Memory Stick, if the user moves from
  Computer to computer, the Drive may be different, and force to re-initialize if the
  Drive Char is different.
  
  To avoid this problem, we give a try to substitute, with the actual one.
  
  'RegistryData'
;;

CheckPaths:
    Mov al B$ConfigFilePath, bl B$EquatesName

    .If al <> bl
        If D$EquatesName <> 'Equa'
            Mov B$EquatesName al
        End_If

        If D$B_U_AsmName <> 'B_U_'
            Mov B$B_U_AsmName al
        End_If

        ;If D$CalcName <> 'Calc'
        ;    On B$CalcName <> 0, Mov B$CalcName al
        ;End_If

        ;On B$F2Name <> 0, Mov B$F2Name al

        ;If D$Win32HlpName <> 'Win3'
        ;    Mov B$Win32HlpName al
        ;End_If

    .End_If
ret
____________________________________________________________________________________________

; Tag Dialog 3

Proc ConfigProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ..If D@msg = &WM_COMMAND
        and D@wParam 0FFFF

        .If D@wParam = &IDCANCEL
            Mov D$UserConfig 0FF
            Call 'USER32.EndDialog' D@hwnd, 0

        .Else_If D@wParam = &IDOK
            Call 'USER32.SendDlgItemMessageA' D@hwnd, 20, &BM_GETCHECK, 0, 0
            If eax = &TRUE
                Mov D$UserConfig REGISTRY
            Else
                Mov D$UserConfig CONFIGFILE
            End_If

            Call 'USER32.EndDialog' D@hwnd, 0
        .End_If

    ..Else_If D@msg = &WM_INITDIALOG
        Move D$H.ShowApiDialog D@hwnd
        Call 'USER32.SetClassLongA' D@hwnd, &GCL_HICON, D$STRUC.WINDOWCLASS@hIcon

        Call 'USER32.SetDlgItemTextA' D@hwnd, 10, ConfigMessage

        Call 'USER32.SendDlgItemMessageA' D@hwnd, 20, &BM_SETCHECK, 1, 0

    ..Else_If D@msg = &WM_CTLCOLOREDIT
        If B$FirstCTLCOLOREDIT = &TRUE
            Call 'USER32.SendMessageA' D@lParam, &EM_SETSEL, 0, 0
            Mov B$FirstCTLCOLOREDIT &FALSE
        End_If
        Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>

    ..Else
        popad | Mov eax &FALSE | jmp L9>

    ..End_If

    popad | Mov eax &TRUE

L9: EndP
EndP

____________________________________________________________________________________________

Create_Config_bin:
    Call 'USER32.MessageBoxA' D$H.MainWindow, Config.Bin_Message, Config.Bin_Title, &MB_YESNO

    If eax = &IDYES
        Call SetMainConfigFilePath
        Call WriteConfigFile
    End_If
ret

[Config.Bin_Message:
B$ "Do you want to create a 'config.bin' file in the current
Directory?

When a 'config.bin' is found aside RosAsm, this file is
used, instead of the Registry.

If you mean, later to recover the Registry functionalities,    
you will just have to delete this file" EOS]

[Config.Bin_Title: B$ 'Configuration File' EOS]
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Click           ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;;
 Search feature by right-clicking on text: We search for main Labels, macros or
 equates declarations, data declarations. This is to say that, if we are inside
 square brackets, any fitting first word, or odd word, or ':' ended word is good;
 if outside, only ':' ended words.
;;

[InsideText: D$ ?
 RCstart: D$ ?
 RCend: D$ ?
 DataDeclaration: D$ ?
 MacroDeclaration: D$ ?]

[OldEditData: D$ ? # 21]

[OneWordChars: B$ '0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.' EOS
 OneWordCharsLen: D$ len] ; !!! Attention <aligné sur fin chaîne prédédente !!!

[Edge: D$ 0
 BackAnyWhere: D$ &TRUE]

; WordEdge looks if a char is or not inside OneWordChars and tells if word edge or not.
; we preserve the flags because direction flag may be set on or off by caller:

WordEdge:
    pushfd | cld
        Push ecx, esi, edi
            Mov ecx D$OneWordCharsLen, edi OneWordChars, B$Edge &TRUE
            repne scasb | jne L9>
                Mov B$Edge &FALSE
L9:     Pop edi, esi, ecx
    popfd
ret


[ShowEquateTitle: B$ 'Win Equate Value' EOS]

[ShowEquateHexa: D$ ? # 40]

ShowEquate:
     Mov ebx, eax

     Mov edi ShowEquateHexa, esi STR.A.Trash
     While B$esi <> 0
        movsb
     End_While
     Mov eax '   =' | stosd | Mov eax '    ', ecx 3 | rep stosd

     Push edi, ebx
         std
            Mov ecx, 9
L1:         If ecx = 5
                Mov al '_' | stosb
            End_If
            If ecx = 1
                Mov al '_' | stosb
            End_If
            Mov al bl | and al 0F | add al, '0' |  On al > '9', add al 7
            stosb | shr ebx, 4 | loop L1<
         cld
     Pop ebx, edi
     inc edi

     Mov D$edi '_h  ', D$edi+4 '  [' | add edi 7

     Mov eax ebx | Call WriteEaxDecimal

     Mov D$edi ']   ', B$edi+4 0

     Call 'USER32.MessageBoxA' D$H.MainWindow, ShowEquateHexa, ShowEquateTitle, &MB_SYSTEMMODAL
ret

;;
 I suppress OdWord testing for Equates pointing because it is much difficult work for
 NOP: Usually Equates are defined BEFORE they are used. A wrong pointing could only
 append if user define some Equate AFTER reusing it in Equates definitions (???!!!).
 Good for him!
;;

[PossibleWinApi: D$ ?
 PossibleOpCode: D$ ?

 NumberDashLines: D$ ?]

RightClick: ; 'InternSearch'
    Mov B$ShiftBlockInside &FALSE

    Push D$FL.BlockInside
        Call LeftButtonSimulation | Call LeftButtonUp
        Mov eax D$STRUCT.EditData@CurrentWritingPos
    Pop D$FL.BlockInside

    ..If D$FL.BlockInside = &TRUE

       .If eax >= D$LP.BlockStartText

            If eax <= D$LP.BlockEndText

               jmp RightClickOnBlock

            End_If

       .End_If

    ..End_If

    Call LeftButtonSimulation | Call LeftButtonUp | Call AskForRedraw

  ; Save all 'EditData's
    Mov esi STRUCT.EditData, edi OldEditData, ecx 21 | rep movsd

    Mov esi D$STRUCT.EditData@CurrentWritingPos

  ; Special Selections cases when Clicking exactely on '"' or '[':
    If B$esi = '"'
        Call SelectDoubleQuotedText | ret
    Else_If B$esi = '['
        Call SelectDataBlock | ret
    End_If

  ; Is it a Right-Click on 'blank' area for simply routing back?
  ; Or on a DashLine >>> do nothing.
    Mov al B$esi
    If B$esi = '_'
        On B$esi+1 = '_', ret
        On B$esi-1 = '_', ret
    End_If

    Call WordEdge

    .If B$Edge <> &FALSE
        If B$esi <= SPC
            jmp BlankRightClick
        Else_If B$esi = '&'
          ; '&' not considered in the WordEdge Routine, but valid here for Win32 Equates
        Else
          ; Abort on alien Char that could be found, for example, in Strings:
            ret
        End_If
    .End_If

    Mov B$PossibleWinApi &FALSE

; Reused by 'SearchFromTreeListBox' and the Debugger 'DataView_ShowDeclaration':
InternalRightClick: ; 'InternSearch'
    Mov B$InsideMLC &FALSE, B$InsideComment &FALSE

  ; Go to start of Clicked word:
    std
L0:     lodsb | Call WordEdge | cmp B$Edge &TRUE | jne L0<
    cld
    inc esi

  ; Special case for Numbers:
    ..If B$esi+1 >= '0'
        .If B$esi+1 <= '9'
            Call RightClickedNumber | ret
        .End_If
    ..End_If

  ; Special case of Tag Comment:
    Mov eax D$esi+1 | or eax 020202020
    If eax = 'tag '
        Call IsItTag | On eax = &TRUE, jmp TagParser
    End_If

  ; To differenciate for example a Click on 'Mov' (if 'Mov' is a Macro) from '[Mov | ...':
    Push esi
        While B$esi = SPC | dec esi | End_While
        Mov B$PossibleOpCode &FALSE
        On B$esi = '[', Mov B$PossibleOpCode &TRUE
    Pop esi

    inc esi

  ; Special case for OS Equates, plus, take care of Strings Delimiters for Api calls:
    If B$esi-1 = '&'
        Push esi
            Call NewGetEquates | Mov edx esi
        Pop esi
        On B$EquateFound = &TRUE, Call ShowEquate
        ret
    Else_If B$esi-1 = "'"
        Mov B$PossibleWinApi &TRUE
    Else_If B$esi-1 = "'"
        Mov B$PossibleWinApi &TRUE
    End_If

  ; First Char, Low Case into ah:
    Mov ah B$esi | or ah 32

  ; edx > second char (> edi)
    inc esi | Mov ebx 0, edx esi

  ; Search for end of Clicked word:
L0: lodsb | inc ebx | Call WordEdge | cmp B$Edge &TRUE | jne L0<
    sub ebx 1 | jc L9>>             ; ebx = length-1
        cmp ebx 0 | je L9>>
    cmp ebx 1 | ja L0>              ; Abort if local label
    cmp B$esi-2 '9' | ja L0>
        ret

  ; Now, edi (edx) > start+1 of right clicked word; ebx = lenght-1. Search maching Symbol:
L0: Mov esi D$CodeSource, ecx D$SourceLen, B$InsideBracket &FALSE, B$InsideComment &FALSE
    and D$MacroNamePointer 0 ;jE!
;;
  Clean up, in actual Style to be continued from here, when i will have time.
  Old Routines yet here at 'OldRightClick', 'OldInternalRightClick'.
;;
    jmp L0>

T0: lodsb | jmp L1>                         ; simplified loop for strip texts and comments
T1: loop T0<
    On B$InsideMLC = &TRUE, jmp C0>         ; Because unpaired MLC are allowed
      ret

L0: lodsb | cmp al ah | je L3>>             ; test XORed AH each pass in order to handle
            xor ah 32 | cmp al ah | je L3>> ; case without modifying AL (following tests)
        jmp L1>
L2: loop L0<

C0:     .If B$PossibleWinApi = &TRUE
            Call WinApiFirstPass ; SearchWinApi
        .Else
            Mov B$MnemonicHelpFound &FALSE
            Call SearchMneMonic             ; Nothing found > it it a Mnemonic?
            If B$MnemonicHelpFound = &FALSE
                On ebx < 3, Call SearchForReg
            End_If
        .End_If
        ret

L1: cmp B$InsideMLC &TRUE | jne L1>
      cmp D$esi-2 MLC | jne T1<
        Mov B$InsideMLC &FALSE | jmp L2<
L1: cmp B$InsideComment &TRUE | jne L1>
      cmp al LF  | jne T1<<
        Mov B$InsideComment &FALSE | jmp L2<
L1: cmp B$InsideText &FALSE | je L1>
      cmp al B$InsideText | jne T1<<
        Mov B$InsideText &FALSE | jmp L2<<
L1: cmp al "'" | jne L1>
      Mov B$InsideText al | jmp T1<<
L1: cmp al '"' | jne L1>
      Mov B$InsideText al | jmp T1<<
L1: cmp al '[' | jne L1>
        Call ScaningBracket

S0:   cmp B$esi SPC | jne L2<<
        inc esi | sub ecx 1 | jnc S0<        ; strip double spaces
          ret

L1: cmp al ']' | jne L1>
      Mov B$InsideBracket &FALSE, B$DataDeclaration &FALSE, B$MacroDeclaration &FALSE
      jmp L2<<

L1: cmp al ';' | jne L1>                     ; jmp over comments
        If D$esi-2 = MLC   ; (LF ; ; CR)
            Mov B$InsideMLC &TRUE | jmp T1<<
        Else
            Mov B$InsideComment &TRUE | jmp T1<<
        End_If

L1: cmp al '|' | jne L1>
      Mov B$InsideBracket &FALSE | jmp L2<<
L1: cmp al ':' | jne L2<<
      Mov B$DataDeclaration &TRUE

            jmp L2<<                         ; (avoids pointing equates datas).

L3: Mov al B$esi-2 | Call WordEdge | cmp B$Edge &FALSE | je L2<<     ; left edge?

        Mov D$NumberDashLines 0

        pushad | Mov ecx ebx, edi edx

C0:       lodsb | Mov ah B$edi | inc edi

          ; case insensitive comparison:
            If al >= 'A'
                On al <= 'Z', or al SPC
            End_If

            If ah >= 'A'
                On ah <= 'Z', or ah SPC
            End_If

          ; Edi is pointing to the clicked Word. Esi ---> Parsed Source:

            .If B$edi-1 <> '_'
                While B$esi-1 = '_'
                    lodsb
                    If al >= 'A'
                        On al <= 'Z', or al SPC
                    End_If
                    inc D$NumberDashLines | dec ecx | jz X1>
                End_While
            .End_If

            .If B$esi-1 <> '_'
                While B$edi-1 = '_'
                    Mov ah B$edi | inc edi
                    If ah >= 'A'
                        On ah <= 'Z', or ah SPC
                    End_If
                    dec D$NumberDashLines | dec ecx | jz X1>
                End_While
            .End_If

            cmp ah al | jne C1>
            loop C0<

X1:         Mov al B$esi | Call WordEdge
            If B$Edge = &FALSE
                popad | jmp L2<<
            End_If

            popad | jmp C2>

C1:     popad | jne L2<<

   ; Mov al B$esi+ebx | Call WordEdge | cmp B$Edge &FALSE | je L2<<    ; right edge?

C2: If B$MacroDeclaration = &TRUE
      ; Was it first word?
        cmp esi D$MacroNamePointer | jne L2<<
    End_If

    Push ebx
        add ebx D$NumberDashLines
        cmp B$esi+ebx ':'
    Pop ebx
    je L4>                                 ; Label?

; as we have tested for '|' (> InsideBracket = FALSE), "test B$OddWord 1" applies either
; uppon first word of macro def. or odd word of equate def. But data body could still
; be pointed as odd equate dec. So we finally test 'B$DataDeclaration'.

      cmp B$InsideBracket &TRUE | jne L2<<                     ; equ. / macro
          cmp B$DataDeclaration &TRUE | je L2<<  ; avoid pointing data body instead of Equate
              If B$MacroDeclaration = &FALSE
                Call PairedEquate | On B$ValidEquateOrMacro = &FALSE, jmp L2<<
              End_If

L4: dec esi                                                    ; found

    Mov D$LP.BlockStartText esi,
        D$RCstart esi                 ; RCstart/End used by

    add esi ebx

    Mov D$LP.BlockEndText esi,
        D$RCend esi       ; 'BackClick'

    Mov D$FL.BlockInside &TRUE
    inc esi | Mov D$STRUCT.EditData@CurrentWritingPos esi

    std | Mov ecx 0
L5:     lodsb | inc ecx
        cmp al LF | jne L5<                    ; search for start of line
        cld | ;dec ecx

    Call StorePosInBackTable

    add esi 2 | Mov D$STRUCT.EditData@UpperLine esi                            ; and set all needed
    Call UpOneLine | Call UpOneLine | Call UpOneLine           ; variables for Pos, in

  ; Would be a good thing... but doesn't work. The Block seems cleared by 'TryToMove'
  ; when it can't Move any more upward... complicated... later...

  ;  Call UpOneLine | Call UpOneLine | Call UpOneLine
  ;  Call UpOneLine | Call UpOneLine | Call UpOneLine

    Mov D$STRUCT.EditData@CaretLine 3, D$STRUCT.EditData@CaretRow ecx, D$STRUCT.EditData@PhysicalCaretRow ecx  ; case user wish editing
    Call TryToMove
    Mov D$STRUCT.EditData@RightScroll 0 | Call AskForRedraw

    If B$PossibleOpCode = &TRUE

        Mov esi D$LP.BlockStartText,
            ah B$esi,
            edx esi,
            ebx D$LP.BlockEndText

        or ah SPC | add edx (1*ASCII) | sub ebx esi

        Call SearchMneMonic

    End_If

L9: ret


SearchForReg:
    pushad
        dec edx | Mov esi edx, edi MnemonicCopy, ecx ebx | inc ecx
L0:     lodsb | On al > 'Z', and eax (not SPC) | stosb | loop L0<
        Mov B$edi 0
        Mov esi MnemonicCopy
        Call IsItaReg
        On eax <> 0, Call Help B_U_AsmName, {B$ 'Registers' EOS}, ContextHlpMessage
    popad
ret
____________________________________________________________________________________________

[ValidEquateOrMacro: D$ ?]
;;
[LowSigns            31
    TextSign            30
;;

;;
  'PairedEquate' job is to make sure, for the Right-Click feature, that, the pointed
  word is really an Equate Declaration, and not an Evocation.
;;

PairedEquate:
  ; esi points to the Second Char of the pointed word.
    pushad
    Push D$CodeSourceA, D$CodeSourceB
        While B$esi >= '0' | inc esi | End_While
        Mov ecx 2

L0:     While B$esi <> '[' | dec esi | inc ecx | End_While

      ; Case of '[' in Text or Comments:
      cmp D$MacroNamePointer 0 | je L1> ; jE!
        If esi > D$MacroNamePointer
            dec esi | inc ecx | jmp L0<
        End_If
L1:   ;and D$MacroNamePointer 0 ; ?? jE!
        Mov edi Trash1, D$StripLen ecx | rep movsb | Mov D$edi CRLF2

        Move D$CodeSourceA Trash1, D$CodeSourceB Trash2

      ; CoolParsers
        Call KillMultiLineComments
        Call NewKillVirtualCRLF
        Call KillMeaninglessCommas

      ; HotParsers
        Call StripUnderscore
        Call TranslateAsciiToMyAscii
        Call StripUnneededSpaces
        Call ConvertCommasToSpace

        Mov esi D$CodeSourceA, edx D$StripLen | add edx esi

        While esi < edx
            If B$esi < Separators
                Mov B$esi Space
            End_If
            inc esi
        End_While

        Call StripUnneededSpaces

        Mov esi D$CodeSourceA, edx D$StripLen | add edx esi | dec edx
        Mov D$ValidEquateOrMacro &FALSE

      ; Don't know why, but it seems that when stripping un-needed Spaces,
      ; the last one might be lost. Probably when followed by EOI:
        On B$edx <> Space, Mov B$edx Space

        While esi < edx
            inc esi | On B$esi = Space, xor D$ValidEquateOrMacro &TRUE
            On B$esi = Space, inc eax
        End_While
    Pop D$CodeSourceB, D$CodeSourceA
    popad
ret



BlankRightClick:    On B$BackAnyWhere = &TRUE, Call BackClick | ret


[MacroNamePointer: D$ ?]

ScaningBracket:
    Mov B$InsideBracket &TRUE, B$DataDeclaration &FALSE, B$MacroDeclaration &FALSE

  ; Verify that this is not an Alternate Syntax Instruction:
    Push eax
        Mov al B$esi-2 | or al SPC
        If al = 'd'
L0:         Pop eax
            While B$esi > LF | inc esi | End_While
            ret
        Else_If al = 'r'
            jmp L0<
        End_If
    Pop eax

    Push esi

      ; Go to first word and keep pointer as required for final test (+1):
        While B$esi = SPC | inc esi | End_While
        Mov D$MacroNamePointer esi | inc D$MacroNamePointer

      ; Skip first word:
        While B$esi > SPC
            inc esi
            If B$esi = '|'
                Mov B$MacroDeclaration &TRUE | jmp L9>
            End_If
        End_While

      ; What last Char in first word:
        If B$esi-1 = ':'
            Mov B$DataDeclaration &TRUE | jmp L9>
        Else_If B$esi-1 = '|'
            Mov B$MacroDeclaration &TRUE | jmp L9>
        End_If

      ; What is next non space Char:
        While B$esi = SPC | inc esi | End_While | lodsb

        If al = '|'
            Mov B$MacroDeclaration &TRUE
        Else_If al = CR
            Mov B$MacroDeclaration &TRUE
        Else_If al = ';'
            Mov B$MacroDeclaration &TRUE
        End_If
L9: Pop esi
ret

____________________________________________________________________________________________

SelectDoubleQuotedText:
    Mov D$LP.BlockStartText esi | inc D$LP.BlockStartText

    Mov B$TextGoingOn &FALSE | lodsb | Call IsItFirstText

L1: lodsb | On esi >= D$STRUCT.EditData@SourceEnd, ret
            Call IsItFirstText | je L1<

    sub esi (2*ASCII)

    Mov D$LP.BlockEndText esi,
        D$FL.BlockInside &TRUE

    Call AskForRedraw
ret


SelectDataBlock:
    inc esi | Mov D$LP.BlockStartText esi, B$TextGoingOn &FALSE
    .While B$esi <> ']'

        .If B$esi = ';'
            If D$esi-2 = MLC   ; (LF ; ; CR)
                Do
                    inc esi | On esi >= D$STRUCT.EditData@SourceEnd, ret
                Loop_Until D$esi-2 = MLC
            Else
                While B$esi <> LF
                    inc esi
                End_While
            End_If
        .End_If

L1:     lodsb | On esi >= D$STRUCT.EditData@SourceEnd, ret
                Call IsItFirsttext | je L1<
    .End_While

L9: sub esi (1*ASCII)

    Mov D$LP.BlockEndText esi,
        D$FL.BlockInside &TRUE

    Call AskForRedraw
ret

____________________________________________________________________________

; User selected a Block of text and then RightClick uppon it:

[H.MenuFloatBreakPoint: D$ ?]
[Float_Copy_String: B$ 'Copy' EOS]
[Float_Delete_String: B$ 'Delete' EOS]
[Float_Replace_String: B$ 'Replace' EOS]

[Float_SearchFromTop_String: B$ 'Search from Top' EOS]
[Float_SearchUp_String: B$ 'Search Up' EOS]
[Float_SearchDown_String: B$ 'Search Down' EOS]

[Float_Unfold_String: B$ 'Unfold' EOS]
[Float_BookMark_String: B$ 'BookMark' EOS]
[Float_UnBookMark_String: B$ 'UnBookMark' EOS]
[Float_Number_String: B$ 'Number forms' EOS]
[Float_SelReplace_String: B$ 'Replace in Selection' EOS]
[Float_BadDisLabel_String: B$ 'Bad Disassembly' EOS]

[Float_Copy 5500    Float_SearchFromTop 5501    Float_SearchUp 5502    Float_SearchDown 5503
 Float_Unfold 5504  Float_BookMark 5505         Float_UnBookMark 5506  Float_Number 5507
 Float_ReArange 5508 Float_SelReplace 5509         Float_Delete 5510      Float_Replace 5511
 Float_BadDisLabel 5512]

RightClickOnBlock:
    Call 'USER32.CreatePopupMenu' | Mov D$H.MenuFloatBreakPoint eax
    Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint &MF_STRING, Float_Copy, Float_Copy_String
    Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint &MF_STRING, Float_Delete, Float_Delete_String
    Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint &MF_STRING, Float_Replace, Float_Replace_String

    Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint &MF_SEPARATOR &NULL &NUll
    Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint &MF_STRING Float_SearchFromTop,
                             Float_SearchFromTop_String
    Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint &MF_STRING Float_SearchUp Float_SearchUp_String
    Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint &MF_STRING Float_SearchDown Float_SearchDown_String

    Call IsItaNumber
    If eax > 0
        Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint, &MF_SEPARATOR, &NULL, &NUll
        Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint, &MF_STRING, Float_Number, Float_Number_String
    End_If

    Call IsItanEqual | On eax = &TRUE, jmp L0>

    Call IsItaMacro
    If eax > 0
L0:     Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint, &MF_SEPARATOR, &NULL, &NUll
        Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint, &MF_STRING, Float_Unfold, Float_Unfold_String
    End_If

    Call IsItaLabel
    If eax = 1
        Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint, &MF_SEPARATOR, &NULL, &NUll
        Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint, &MF_STRING, Float_BookMark,
                                  Float_BookMark_String
    Else_If eax = 2
        Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint, &MF_SEPARATOR, &NULL, &NUll
        Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint, &MF_STRING, Float_UnBookMark,
                                  Float_UnBookMark_String
    End_If

    .If D$FL.IsDebugging = &FALSE

        Mov ecx D$LP.BlockEndText

        sub ecx D$LP.BlockStartText

        If ecx > 50
            Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint, &MF_SEPARATOR, &NULL, &NUll
            Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint, &MF_STRING, Float_SelReplace,
                                    Float_SelReplace_String
        End_If
    .End_If


    .If B$ThisSourceIsDisassembled = &TRUE
        Call IsItDisassembledLabel
        If eax = &TRUE
            Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint, &MF_SEPARATOR, &NULL, &NUll
            Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint, &MF_STRING, Float_BadDisLabel,
                                      Float_BadDisLabel_String
        End_If
    .End_If


    Call 'USER32.GetWindowRect' D$H.MainWindow RECT
    Mov eax D$RECTleft | add eax 20 | add D$MousePosX eax
    Mov eax D$RECTtop | add D$MousePosY eax

    Call 'KERNEL32.GetCurrentThreadId'
    Call 'USER32.SetWindowsHookExA' &WH_KEYBOARD, FloatMenuProc, &NULL, eax
    Mov D$H.Hook eax

    Mov eax D$MousePosX | add eax D$DU.BreakPointWindowMarginWidth

    Call 'USER32.TrackPopupMenu' D$H.MenuFloatBreakPoint,
                                 0, eax, D$MousePosY, 0,
                                 D$H.EditWindow, &NULL

    Call 'USER32.UnhookWindowsHookEx' D$H.Hook
ret


IsItDisassembledLabel:

    Mov esi D$LP.BlockEndText | On B$esi+1 <> ':' jmp L7>

    Mov esi D$LP.BlockStartText

    If D$esi = 'Code'
        Mov D$DisLabelTypeWas CODEFLAG
        Call GetDisLabelHexaValue
        xor B$GetHexaFromTextError &TRUE | Mov eax D$GetHexaFromTextError

    Else_If D$esi = 'Data'
        Mov D$DisLabelTypeWas DATAFLAG
        Call GetDisLabelHexaValue
        xor B$GetHexaFromTextError &TRUE | Mov eax D$GetHexaFromTextError

    Else
L7:     Mov eax 0

    End_If
ret


GetDisLabelHexaValue:
;;
  The "On B$esi = '_', jmp L1>" are for cases of Label that are appended with a "_Symbol"
  taken from the 'StringsMap'.
;;
    Mov esi D$LP.BlockStartText, edi CopyOfLabelHexa | add esi 4
    While B$esi <> ':'
        movsb | On B$esi = '_', jmp L1>
    End_While
L1: Mov B$edi 0

    Call GetHexaFromText CopyOfLabelHexa

    If B$GetHexaFromTextError = &TRUE
        Mov D$DisAddressWas 0
    Else
        Mov D$DisAddressWas eax
    End_If

    Mov D$CopyOfNextLabelHexa 0
    Mov eax D$CopyOfLabelHexa
    .While esi < D$STRUCT.EditData@SourceEnd
        inc esi
        .If D$esi = eax
            Mov ebx esi
            While B$esi <> ':'
                inc esi | On B$esi <= SPC, jmp L2>
            End_While

            Mov esi ebx, edi CopyOfNextLabelHexa
            While B$esi <> ':'
                movsb | On B$esi = '_', jmp L1>
            End_While
L1:         Mov B$edi 0
            Push D$GetHexaFromTextError
                Call GetHexaFromText CopyOfNextLabelHexa
                If B$GetHexaFromTextError = &TRUE
                    Mov D$NextDisAddressWas 0, D$CopyOfNextLabelHexa 0
                Else
                    Mov D$NextDisAddressWas eax
                End_If
            Pop D$GetHexaFromTextError
        .End_If
L2: .End_While
ret


Proc FloatMenuProc:
    Arguments @nCode, @wParam, @lParam

        ..If D@nCode = &HC_ACTION ; HC_NOREMOVE
            On D@wParam = &VK_ESCAPE
L1:             Mov D$FL.BlockInside &FALSE
            End_If
        ..End_If

L9:     Mov eax &FALSE ; Forwarding
EndP


CopyFromFloatMenu:
    Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint
    Call ControlC
ret


SetFloatSearch:

    Mov esi D$LP.BlockStartText,
        edi SearchString,
        ecx D$LP.BlockEndText

    sub ecx esi | inc ecx

    Mov D$LenOfSearchedString ecx

    rep movsb

ret

SearchUpFromFloatMenu:
    Mov B$DownSearch &FALSE
    Call SetFloatSearch | Call SetCaret D$LP.BlockStartText | Call StringSearch
ret

SearchFromTopFromFloatMenu:
    Mov B$DownSearch &TRUE
    Call SetFloatSearch
    Call FullUp | Mov D$STRUCT.EditData@CaretRow 1, D$STRUCT.EditData@CaretLine 0 | Move D$STRUCT.EditData@CurrentWritingPos D$CodeSource
    Call StringSearch
ret

SearchDownFromFloatMenu:
    Mov B$DownSearch &TRUE
    Call SetFloatSearch | Call StringSearch
ret


RightClickedNumber:

    add esi (1*ASCII)

    Push D$LP.BlockStartText,
         D$LP.BlockEndText

        Mov D$LP.BlockStartText esi

        Push esi

L0:         lodsb | Call WordEdge | cmp B$Edge &TRUE | jne L0<

            sub esi (2*ASCII) | Mov D$LP.BlockEndText esi

        Pop esi

        Call IsItaNumber

    Pop D$LP.BlockEndText,
        D$LP.BlockStartText

    On eax <> 0 Call ViewClickedNumber

ret


[ClickedNumberValue: D$ ?
 HexaInBlock: D$ ?
 BinaryInBlock: D$ ?]

[NumberCopy: D$ ? # 25]

IsItaNumber:
    Mov eax 0, esi D$LP.BlockStartText, bl B$esi
    Mov B$HexaInBlock &FALSE, B$BinaryInBlock &TRUE

    cmp bl '0' | jb L9>>
        cmp bl '9' | ja L9>>

L0: inc esi
    cmp B$esi '_' | je L1>
    cmp B$esi '0' | jb L2>  ; 010_0000_0000
    cmp B$esi 'F' | ja L2>
    cmp B$esi 'A' | jae L1>
    cmp B$esi '9' | ja L2>
L1: jmp L0<

L2: Mov ecx esi | sub ecx D$LP.BlockStartText
    If ecx > 50
        Mov eax 0 | jmp L9>>
    End_If

    Mov esi D$LP.BlockStartText,
        edi NumberCopy

    While esi <= D$LP.BlockEndText

L3:     lodsb
        If al >= 'a'
            On al <= 'f', sub al 32
        End_If

        If al = '_'
            jmp L3<
        Else_If al > 'F'
            Mov eax 0 | jmp L9>>
        Else_If al < '0'
            Mov eax 0 | jmp L9>>
        End_If

        On al > '9',  Mov B$HexaInBlock &TRUE
        On al > '1', Mov B$BinaryInBlock &FALSE

        On al <> '_', stosb
    End_While

    Mov D$OldStackPointer esp
    Mov B$edi 0
    Mov esi NumberCopy
    .If W$esi = '00'
        If B$BinaryInBlock = &TRUE
            Call ClickBinary
        Else
            Mov eax 0
        End_If
    .Else_If B$esi = '0'
        Call ClickHexa
    .Else
        If B$HexaInBlock = &FALSE
            Call ClickDecimal
        Else
            Mov eax 0
        End_If
    .End_If

  ; eax = Number if any (or 0):
L9: Mov D$ClickedNumberValue eax
ret
____________________________________________________________________________________________

; Numbers translations Routines without error report (no Menu Option on failure, instead)

ClickBinary:
    lodsw                                               ; clear first '00'
NackedClickBinary:
    Mov ebx 0, edx 0, ecx 0
L0: lodsb | cmp al Closebracket | jbe L9>
    sub al '0' | shld edx ebx 1 | shl ebx 1 | or bl al
    cmp edx ecx | jb L8>
        Mov ecx edx
            cmp al 2 | jb L0<
L8:             Mov ecx D$BinTypePtr | jmp BadNumberFormat
L9: Mov eax ebx
ret


ClickHexa:
    lodsb                                               ; clear first '0'
NackedClickHexa:
    Mov ebx 0,  edx 0, ecx 0
L0: lodsb | cmp al LowSigns | jbe L9>
        sub al '0' | cmp al 9 | jbe L2>
            sub al 7
L2: shld edx ebx 4 | shl ebx 4 | or bl al
    cmp edx ecx | jb L8>
        Mov ecx edx
            cmp al 0F | jbe L0<
L8: Mov ecx HexType | jmp BadClickFormat
L9: Mov eax ebx
ret


ClickDecimal:
    Mov eax 0, ecx 0

L2: Mov cl B$esi | inc esi                        ; (eax used for result > no lodsb)
    cmp cl LowSigns | jbe  L9>

      Mov edx 10 | mul edx | jo L3>               ; loaded part * 10
                                                  ; Overflow >>> Qword
        sub  ecx '0' | jc L7>
        cmp  ecx 9   | ja L7>

          add  eax ecx | jnc  L2<
            jmp  L4>                              ; carry >>> Qword

                                                  ; if greater than 0FFFF_FFFF:
L3: sub ecx '0' | jc L7>
    cmp ecx 9   | ja L7>

      add eax ecx

L4:   adc edx 0
      Mov cl B$esi | inc  esi
      cmp cl LowSigns | jbe L9>

        Mov ebx eax, eax edx, edx 10 | mul edx    ; high part * 10
          jo L6>                                  ; Qword overflow
            xchg eax ebx | Mov edx 10 | mul edx   ; low part * 10
            add  edx ebx
            jnc   L3<                             ; carry >>> overflow
L6:           Mov eax 0 | ret

L7: Mov ecx D$DezimalTypePtr | jmp BadNumberFormat
L9: ret                                           ; >>> number in EDX:EAX


BadClickFormat:
    dec esi
L0: lodsb | On al = 'X', lodsb

    ..If al = 'H'
        cmp B$esi LowSigns | ja L7>
    ..Else_If al = 'D'
        cmp B$esi LowSigns | ja L7>
    ..Else_If al = 'B'
        cmp B$esi LowSigns | ja L7>
    ..Else
      ; Try to read a Type Marker at the end, and re-run if possible:
L7:     While B$esi > LowSigns | inc esi | End_While | dec esi | lodsb
        .If al = 'H'
            If ecx = HexType
                Mov eax 0 | ret
            End_If
        .Else_If al = 'D'
            If ecx = DezimalType
                Mov eax 0 | ret
            End_If
        .Else_If al = 'B'
            If ecx = BinType
                Mov eax 0 | ret
            End_If
        .Else
            Mov eax 0 | ret
        .End_If
    ..End_If

    dec esi
;;
 esi now points to the last Char of the Number. We overwrite it: We kill the Types Markers
 and we fill at the other end (start), with zeros:
;;
    Push edi
        Mov edi esi | dec esi | On B$esi = 'X', dec esi
        std
            While B$esi > LowSigns | movsb | End_While
        cld
        While B$edi > LowSigns | Mov B$edi '0' | dec edi | End_While
    Pop edi

    inc esi | While B$esi = '0' | inc esi | End_While

    If al = 'H'
        jmp NackedClickHexa
    Else_If al = 'D'
        jmp ClickDecimal
    Else  ; al = 'B'
        jmp NackedClickBinary
    End_If
____________________________________________________________________________________________



[ClickedNumberText: ClickedHexa: B$ "

                                    

                                                               

                                                        



" EOS]

[ClickedNumberTitle: B$ 'Bases forms' EOS]


ViewClickedNumber:
    Mov eax D$ClickedNumberValue | lea edi D$ClickedHexa+8

  ; Write Hexa form:
    Call WriteEax
    Mov al SPC
    While B$edi <> CR
        stosb
    End_While
    add edi 8

  ; Write Decimal form:
    Mov eax D$ClickedNumberValue
    Mov dl 0FF | Push edx                       ; Push stack end mark
    Mov ecx 10
L0: Mov edx 0
    div ecx | Push edx | cmp eax 0 | ja L0<     ; Push remainders
L2: Pop eax                                     ; Retrieve Backward
    cmp al 0FF | je L9>                         ; Over?
       add al '0' | stosb | jmp L2<             ; Write
L9:
    Mov al SPC
    While B$edi <> CR
        stosb
    End_While
    add edi 8

  ; Write Binary form:
    Mov D$edi '00_ ' | add edi 3
    Mov ebx D$ClickedNumberValue, ecx 4
L0: shl ebx 1 | Mov al '0' | adc al 0 | stosb | loop L0<
    Mov al '_' | stosb | Mov ecx 4
L0: shl ebx 1 | Mov al '0' | adc al 0 | stosb | loop L0<
    Mov al '_' | stosb | Mov ecx 4
L0: shl ebx 1 | Mov al '0' | adc al 0 | stosb | loop L0<
    Mov al '_' | stosb | Mov ecx 4
L0: shl ebx 1 | Mov al '0' | adc al 0 | stosb | loop L0<
    Mov al '_' | stosb | Mov ecx 4

    Mov al '_' | stosb | stosb

L0: shl ebx 1 | Mov al '0' | adc al 0 | stosb | loop L0<
    Mov al '_' | stosb | Mov ecx 4
L0: shl ebx 1 | Mov al '0' | adc al 0 | stosb | loop L0<
    Mov al '_' | stosb | Mov ecx 4
L0: shl ebx 1 | Mov al '0' | adc al 0 | stosb | loop L0<
    Mov al '_' | stosb | Mov ecx 4
L0: shl ebx 1 | Mov al '0' | adc al 0 | stosb | loop L0<

    Call 'USER32.MessageBoxA' D$H.MainWindow, ClickedNumberText, ClickedNumberTitle, &MB_SYSTEMMODAL
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; Little feature for "Replace all" in Selected Block: Whole words / Case insensitive

; Tag Dialog 1050

BlockReplaceAll:
    Call 'USER32.DialogBoxParamA' D$H.Instance, 1050, D$H.MainWindow, BlockReplaceAllProc, &NULL
ret


[BlockFrCase: &TRUE    BlockWwSearch: &TRUE]

; Tag Dialog 1050

Proc BlockReplaceAllProc:
    Arguments @hwnd, @msg, @wParam, @lParam
    Local @StartOfBlock, @EndOfBlock

    pushad

    ...If D@msg = &WM_INITDIALOG
       ; Call 'USER32.SendDlgItemMessageA' D@hwnd, 50, &BM_SETCHECK, D$BlockFrCase, 0
       ; Call 'USER32.SendDlgItemMessageA' D@hwnd, 51, &BM_SETCHECK, D$BlockWwSearch, 0
        Call 'USER32.GetDlgItem' D@hwnd, 10
        Call 'USER32.SetFocus' eax
        popad | Mov eax &TRUE

EndP

    ...Else_If D@msg = &WM_COMMAND

        Mov eax D@wParam | and D@wParam 0FFFF | shr eax 16

        ..If D@wParam = &IDCANCEL
            Call 'USER32.EndDialog' D@hwnd, 0

        ..Else_If D@wParam = &IDOK
            Call 'USER32.SendDlgItemMessageA' D@hwnd, 50, &BM_GETCHECK, 0, 0
            Mov D$BlockFrCase eax

            Call 'USER32.SendDlgItemMessageA' D@hwnd, 51, &BM_GETCHECK, 0, 0
            Mov D$BlockWwSearch eax

            Call 'USER32.SendDlgItemMessageA' D@hwnd, 10, &WM_GETTEXT, 80,
                                              SearchString
            Call 'USER32.SendDlgItemMessageA' D@hwnd, 11, &WM_GETTEXT, 80,
                                              ReplaceWithString
            Mov esi SearchString, ecx 0
            While B$esi > 0 | inc esi | inc ecx | End_While
            Mov esi ReplaceWithString, D$LenOfReplaceString 0
            While B$esi > 0 | inc esi | inc D$LenOfReplaceString | End_While

            .If ecx > 0

                Push D$STRUCT.EditData@UpperLine,
                     D$STRUCT.EditData@CaretRow,
                     D$STRUCT.EditData@CaretLine,
                     D$DownSearch,
                     D$CaseSearch,
                     D$WholeWordSearch

                    Mov D$FL.BlockInside &FALSE

                    Mov D$LenOfSearchedString ecx
                    ; No 'String not found" Message at the end:
                    Mov B$OnReplaceAll &TRUE
                    Move D$NextSearchPos D$LP.BlockStartText
                    Move D$CaseSearch D$BlockFrCase, D$WholeWordSearch D$BlockWwSearch
                    Mov B$DownSearch &TRUE

                    Move D@StartOfBlock D$LP.BlockStartText,
                         D@EndOfBlock D$LP.BlockEndText

L0:                 Call StringSearch

                    If D$FL.BlockInside = &TRUE
                        Mov eax D@EndOfBlock | cmp D$LP.BlockStartText eax | ja L1>
                        Call StringReplace | jmp L0<
                    End_If

L1:                 Mov B$OnReplaceAll &FALSE,
                        B$Disassembling &FALSE,
                        D$FL.BlockInside &TRUE

                    Move D$LP.BlockStartText D@StartOfBlock,
                         D$LP.BlockEndText D@EndOfBlock

                Pop D$WholeWordSearch,
                    D$CaseSearch,
                    D$DownSearch,
                    D$STRUCT.EditData@CaretLine,
                    D$STRUCT.EditData@CaretRow,
                    D$STRUCT.EditData@UpperLine

                Call AskForRedraw

            .End_If

            Call 'USER32.EndDialog' D@hwnd, 0
        ..End_If

    ...Else
L8:     popad | Mov eax &FALSE | ExitP

    ...End_If

    popad | Mov eax &TRUE
EndP


____________________________________________________________________________________________
____________________________________________________________________________________________


; If user DoubleClick or RightClick on Block, we check if the pointed thing is a Macro
; evocation (to append an 'Unfold' Item in the Floating Menu). Called from
; 'RightClickOnBlock'.

IsItaMacro:

    Mov esi D$LP.BlockStartText

  ; Verify we are not pointing a Declaration:
    Push esi
        While B$esi-1 = SPC
            dec esi
        End_While
        Mov al B$esi-1
    Pop esi
    If al = '['
        Mov eax 0 | ret
    End_If

    Mov edi D$CodeSource, al '[', ecx D$SourceLen

    Mov edx D$LP.BlockEndText | sub edx D$LP.BlockStartText | add edx (1*ASCII)

  ; Search for '[' in user Source:
L0: repne scasb | jne L8>
        Push eax, ecx, esi, edi
            While B$edi = SPC
                inc edi                     ; Strip possible leading Space(s).
            End_While
            Mov ecx edx
L1:         Mov al B$esi, bl B$edi | inc esi | inc edi | dec ecx
            or al SPC | or bl SPC | cmp al bl | jne L2>          ; No case compare with Block.
            cmp ecx 0 | ja L1<
               jmp L9>
L2:     Pop edi, esi, ecx, eax

L3: cmp ecx 0 | ja L0<

L8: Mov eax 0 | ret                         ; No mach found.

  ; Mach found, but is it a Macro?
L9: While B$edi = SPC
        inc edi                             ; strip trailing Space(s)
    End_While
    cmp B$edi CR | je L9>                   ; Macro.
    cmp B$edi '|' | je L9>                  ; Macro too.
    cmp B$edi ';' | je L9>                  ; Macro too with comment after symbol.
        Pop edi, esi, ecx, eax | jmp L3<         ; Equate, Data or Macro with the same begining

L9: Pop edi, esi, ecx, eax

    dec edi | Mov eax edi
ret


; Checks if we are pointing on an Equal PreParser line.


[ASCII_DOLLAR 024, ASCII_PARAGRAPH 0A7]

IsItAnEqual:
    Mov esi D$LP.BlockStartText eax 0
    If B$esi-1 = ASCII_DOLLAR
        sub esi 2
    Else_If B$esi-1 = ASCII_PARAGRAPH
        sub esi 2
    End_If

    ; Go to the start of the Statement:
L0: dec esi
    If B$esi = '|'
        jmp L1>
    Else_If B$esi = LF
        jmp L1>
    Else_If B$esi = SPC
        je L0<
    Else
        ret
    End_If

    ; OK, the Selection is the first Member of a Statement. Go to next Component:
L1: Mov esi D$LP.BlockEndText

L0: inc esi
    If B$esi = SPC
        jmp L1>
    Else_If B$esi = LF
        ret
    Else_If B$esi = ','
        ret
    End_If
    jmp L0<

L1: While B$esi = SPC | inc esi | End_While

    .If B$esi = '='
        If B$esi+1 = SPC

            Mov eax &TRUE | ret
        End_If
    .End_If
ret
____________________________________________________________________________________________

; Called by User DoubleLefClick. If the Block is a Label, the user can store it as
; BookMarked.

[BookMarks: D$ ?
 BookMarkLen: D$ ?
 BookMarkPtr: D$ ?]

[ToBeBookMarked: D$ ? # 20]

IsItaLabel:
  ; If not a Label, we abort:

    Mov esi D$LP.BlockEndText

    If B$esi+(1*ASCII) <> ':'

        Mov eax 0 | ret

    End_If

  ; Local Label, we abort:
    Mov esi D$LP.BlockStartText
    If B$esi+2 = ':'
        Mov eax 0 | ret
    End_If

  ; If It is a Local Symbol, we extend. If it is a Local Label we abort:
    Mov esi D$LP.BlockStartText edi ToBeBookMarked

    If B$esi-1 = '@'
        Push edi | Call SearchUpperMainLabel | Pop edi | On eax = 0, ret
        Mov esi eax
        While B$esi <> ':'
            movsb
        End_While
        Mov B$edi '@' | inc edi
        Mov esi D$LP.BlockStartText
    End_If

    While esi < D$LP.BlockEndText | movsb | End_While | movsb | Mov B$edi 0

    sub edi ToBeBookMarked | Mov D$BookMarkLen edi
    Mov esi ToBeBookMarked

  ; If the Block is aready BookMarked, we enable the [UnBookMark] option:
    If D$BookMarks > 0
        Mov edi D$BookMarks, ecx D$BookMarkLen
        inc edi
L0:     Push esi, edi, ecx
            Mov D$BookMarkPtr edi
L1:         Mov al B$esi, bl B$edi | or al SPC | or bl SPC | inc esi | inc edi
            cmp al bl | jne L2>
            loop L1<
        Pop ecx, eax, esi                       ; Found.
        cmp B$edi SPC | ja L3>
        Mov eax 2 | ret                         ; Return for [UnBookMark] option.
L2:     Pop ecx, eax, esi                       ; Not yet found.
L3:     Mov edi eax
L3:     cmp B$edi 0 | je L4>
            inc edi | jmp L3<
L4:     inc edi | cmp B$edi 0 | jne L0<         ; Not yet end of Stored BookMarks.
    End_If

  ; If here, the Label is a Main label and is not yet BookMarked:
    Mov eax 1
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

SearchUpperMainLabel:

    Mov edi D$LP.BlockStartText

L0: dec edi
    While B$edi <> ':'
        dec edi
        If B$edi = '"'
            Do
                dec edi | on edi = D$CodeSource, jmp L7>
            Loop_Until B$edi = '"'
            dec edi
        Else_If B$edi = "'"
            Do
                dec edi | on edi = D$CodeSource, jmp L7>
            Loop_Until B$edi = "'"
            dec edi
        End_If
        on edi = D$CodeSource, jmp L7>
    End_While
    While B$edi > SPC
        dec edi | on edi = D$CodeSource, jmp L7>
    End_While
    inc edi
    If B$edi = '@'
        jmp L0<<
    Else_If B$edi+2 = ':'
        jmp L0<<
    Else
        Mov eax edi | ret
    End_If

L7: Mov eax 0
ret


[FullBookMarks: B$ 'No more room to store BookMarks' EOS]
[BookMarksTitle: B$ '               ----------- BookMarks -----------' EOS]
[EndBookMarks: B$ '                 ------------- Tree --------------' EOS]
[NumberOfBookMarks: D$ ?]

StoreBookMark:
    Call CreateTreeViewList
    If D$BookMarks = 0

        Call VirtualAlloc BookMarks,
                          01000

        Mov D$NumberOfBookMarks 2

        Call 'USER32.SendDlgItemMessageA' D$H.ShowTree, 100, &LB_INSERTSTRING, 0,
                                          EndBookMarks

        Call 'USER32.SendDlgItemMessageA' D$H.ShowTree, 100, &LB_INSERTSTRING, 0,
                                          BookMarksTitle
    End_If
    Mov edi D$BookMarks, al 0, ecx 01000
L0: repne scasb | cmp B$edi 0 | jne L0<
    Push edi
        Mov eax ToBeBookMarked
        While B$eax <> 0 | inc eax | End_While
        sub eax ToBeBookMarked
        If ecx <= eax
            Call 'USER32.MessageBoxA' D$H.MainWindow, FullBookMarks, Argh, &MB_SYSTEMMODAL
            Pop edi | jmp L9>
        End_If
        Mov ecx eax, esi ToBeBookMarked
        rep movsb
        Mov al SPC | stosb | Mov al 0 | stosb
    Pop edi

    Call 'USER32.SendDlgItemMessageA' D$H.ShowTree 100  &LB_INSERTSTRING 1 edi
    inc D$NumberOfBookMarks
L9: ret


ReInsertBookMarks:
    Mov D$NumberOfBookMarks 2
    Call 'USER32.SendDlgItemMessageA' D$H.ShowTree 100  &LB_INSERTSTRING 0,
                                     EndBookMarks
    Call 'USER32.SendDlgItemMessageA' D$H.ShowTree 100  &LB_INSERTSTRING 0,
                                     BookMarksTitle

    Mov esi D$BookMarks | inc esi
    .While B$esi > 0
        Call 'USER32.SendDlgItemMessageA' D$H.ShowTree 100  &LB_INSERTSTRING 1 esi
        inc D$NumberOfBookMarks
        While B$esi <> 0
            inc esi
        End_While
        inc esi
    .End_While
ret


DeleteBookMark:
    Call CreateTreeViewList
    Call 'USER32.SendDlgItemMessageA' D$H.ShowTree 100  &LB_FINDSTRING 0-1 D$BookMarkPtr
    Call 'USER32.SendDlgItemMessageA' D$H.ShowTree 100  &LB_DELETESTRING eax 0
    Mov edi D$BookMarkPtr, esi edi
    add esi D$BookMarkLen | While B$esi > 0 | inc esi | End_While | inc esi
    Mov ecx D$BookMarks | add ecx 01000 | sub ecx esi | rep movsb

  ; Delete the 2 added titles if no more BookMarks, delete the .BKM File and release Mem:
    dec D$NumberOfBookMarks
    If D$NumberOfBookMarks = 2
        Call 'USER32.SendDlgItemMessageA' D$H.ShowTree 100  &LB_DELETESTRING 0 0
        Call 'USER32.SendDlgItemMessageA' D$H.ShowTree 100  &LB_DELETESTRING 0 0
        Call DeleteBookMarkFile

        Call VirtualFree BookMarks

    End_If
ret


DeleteBookMarkFile:
    Mov D$NumberOfBookMarks 0
    Mov edi SaveFilter, al 0, ecx 0-1 | repne scasb
    While B$edi <> '.'
        dec edi
    End_While

    Push D$edi, edi
        Mov D$edi '.BKM'

        Call 'KERNEL32.FindFirstFileA' SaveFilter STRUC.FindFile

        .If eax <> &INVALID_HANDLE_VALUE
            Call 'KERNEL32.FindClose' eax
            Call 'KERNEL32.DeleteFileA' SaveFilter
        .End_If
    Pop edi, D$edi
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
           Unfolder's jobs.
           
  'ShowUnfoldMacro' ---> 'ShowUnfoldDialog' ---> 'UnfoldMacro' ---> 'AsmMain'
  
  Both 'AsmMain' and (after final RET), 'UnfoldMacro' Call for 'UnfoldOutput'.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

[LP.EspStackBeforeUnfolding: D$ ?
 FL.WeAreUnfolding: D$ ?]

[H.ShowUnfoldDialog: D$ ?]

[DIALOG_SHOW_UNFLODING_MACRO   23000
 EDIT_UNFOLDIND_DIALOG         101]

; Tag Dialog 23000

ShowUnfoldMacro:

   Test D$H.DebugDialog NA ZERO S1>

        Call CloseDebuggerOrIgnore

        Comp eax &IDNO <> S1>

ret

S1: Test D$H.ShowUnfoldDialog NA NOT_ZERO S2>

        Mov D$FL.CompileErrorHappend &FALSE

        Call 'USER32.DialogBoxParamA' D$H.Instance,
                                      DIALOG_SHOW_UNFLODING_MACRO,
                                      &NULL,
                                      ShowUnfoldDialog,
                                      &NULL

ret

S2: Call Beep

ret
____________________________________________________________________________________________

Proc ShowUnfoldDialog:

    Arguments @hwnd,
              @msg,
              @wParam,
              @lParam

    If D@msg = &WM_INITDIALOG

        Move D$H.ShowUnfoldDialog D@hwnd

        Call SetIconDialog

        Call UnfoldMacro

        On D$FL.UnfoldCompleted = &FALSE Call WM_CLOSE_ShowUnfoldDialog

    Else_If D@msg = &WM_CTLCOLOREDIT

        Call WM_CTLCOLOREDIT | ExitP

    Else_If D@msg = &WM_COMMAND

         On W@wParam = HIDE_PUSHBUTTON_OK Call WM_CLOSE_ShowUnfoldDialog

    Else_If D@msg = &WM_CLOSE

        Call WM_CLOSE_ShowUnfoldDialog

    Else

        Mov eax &FALSE | jmp P9> ; TODO ExitP

    End_If

    Mov eax &TRUE

EndP
____________________________________________________________________________________________

WM_CLOSE_ShowUnfoldDialog:

    Call EndDialog

    Mov D$H.ShowUnfoldDialog &NULL

ret
____________________________________________________________________________________________

[FL.UnfoldCompleted: D$ ?]

UnfoldMacro:

    Call 'USER32.SetCursor' D$H.CursorWAIT

    Mov D$FL.WeAreUnfolding &TRUE,
        B$ID.UnfoldStep '0',
        D$LP.Trash Trash3

    Push D$SourceLen,
         D$STRUCT.EditData@SourceEnd

        Mov D$LP.EspStackBeforeUnfolding esp

        ; [AsmMain] S'arrête si [FL.WeAreUnfolding] TRUE
        Call AsmMain

        Call 'USER32.SetCursor' D$H.CurrentCursor

        Call UnfoldOutput

        Mov D$edi CRLFEOS0,
            eax D$CodeSourceB

        Test D$eax NA NULL S1>

            Call 'USER32.SetDlgItemTextA' D$H.ShowUnfoldDialog,
                                          EDIT_UNFOLDIND_DIALOG,
                                          Trash3

            Mov D$FL.UnfoldCompleted &TRUE

        jmp L1>

S1:     Mov D$FL.UnfoldCompleted &FALSE

L1: Pop D$STRUCT.EditData@SourceEnd,
        D$SourceLen

    Call ReleaseAsmTables

    Mov D$FL.WeAreUnfolding &FALSE,
        D$FL.ReadyToRun &FALSE

    Call ReleaseAsmTables
ret

UnfoldingError:

    Mov D$UnfoldErrorMessage eax,
        D$FL.CompileErrorHappend &TRUE,
        D$FL.UnfoldCompleted &FALSE

    Call 'USER32.SetCursor' D$H.CurrentCursor

    While esp <> D$LP.EspStackBeforeUnfolding

        Pop ebx ; !!! TODO

    End_While

    jmp L1<
____________________________________________________________________________________________

[UnfoldErrorMessage: D$ ?]

GetUnfoldStatement:

    Push esi,
         ebx,
         ecx

        Mov esi D$CodeSourceA,
            eax 0,
            edx esi

        add edx D$SourceLen

        While eax <> ecx

            .If B$esi = EOI

                If B$esi+(1*ASCII) = OpenBracket

                Else_If B$esi+(1*ASCII) = OpenVirtual

                Else

                    add eax 1

                End_If

            .Else_If B$esi = OpenBracket

                add eax 1

            .Else_If B$esi = OpenVirtual

                add eax 1

            .End_If

            add esi (1*ASCII) | On esi > edx jmp S0>

        End_While

        ; Translate into normal Ascii form:
        Mov edi D$LP.Trash

        If B$esi-(1*ASCII) = OpenVirtual ; 016

            sub esi (1*ASCII) | Call TranslateDeclarationToNormalAscii

        Else_If B$esi-(1*ASCII) = OpenBracket ; 014

            sub esi (1*ASCII)| Call TranslateDeclarationToNormalAscii

        Else

            Call TranslateCodeToNormalAscii

        End_If

S0: Pop ecx,
        ebx,
        esi
ret
____________________________________________________________________________________________

TranslateDeclarationToNormalAscii:

L1: lodsb

        .If al = Space

            Mov al SPC

        .Else_If al = EOI

            jmp S0>>

        .Else_If al = meEOI

            Mov al CR | stosb | Mov al LF

        .Else_If al = TextSign

            Mov B$edi '"' | add edi (1*ASCII)

            While B$esi <> TextSign

                lodsb

                If al = CR

                    Mov W$edi CRLF | add edi (2*ASCII) | add esi (2*ASCII)

                Else

                    stosb

                End_If

            End_While

            add esi (1*ASCII) | Mov al '"'

        .Else_If al = MemMarker

            Mov al '$'

        .Else_If al = OpenBracket

            Mov al '['

        .Else_If al = CloseVirtual

            Mov al ']' | stosb

            Mov al CR | stosb | Mov al LF | stosb | jmp S0>>

        .Else_If al = CloseBracket

            Mov al ']' | stosb

            Mov al CR | stosb | Mov al LF | stosb | jmp S0>>

        .Else_If al = OpenVirtual

            Mov al '['

        .Else_If al = AddSign

            Mov al '+'

        .Else_If al = SubSign

            Mov al '-'

        .Else_If al = MulSign

            Mov al '*'

        .Else_If al = DivSign

            Mov al '/'

        .Else_If al = numSign

            Mov al '#'

        .Else_If al = colonSign

            Mov al ':' | stosb | Mov al SPC | stosb

        .End_If

        stosb

        If al = LF

            Mov D$edi '    ' | add edi (4*ASCII)

        End_If

    jmp L1<<

S0: Mov ax CRLF | stosw ;| Mov al 0 | stosb

ret
____________________________________________________________________________________________

TranslateCodeToNormalAscii:
L0: lodsb

    .If al = Space
        Mov al SPC
    .Else_If al = EOI
        jmp L2>>
    .Else_If al = meEOI
        Mov al CR | stosb | Mov al LF
    .Else_If al = TextSign
        Mov B$edi '"' | inc edi
        While B$esi <> TextSign
            lodsb
            If al = CR
                Mov W$edi CRLF | add edi 2 | add esi 2
            Else
                stosb
            End_If
        End_While
        inc esi | Mov al '"'
    .Else_If al = MemMarker
        Mov al '$'
    .Else_If al = OpenBracket
        jmp L2>>
    .Else_If al = CloseVirtual
        Mov al ']'
    .Else_If al = OpenVirtual
        Mov al '['
    .Else_If al = AddSign
        Mov al '+'
    .Else_If al = SubSign
        Mov al '-'
    .Else_If al = MulSign
        Mov al '*'
    .Else_If al = DivSign
        Mov al '/'
    .Else_If al = numSign
        Mov al '#'
    .Else_If al = colonSign
        Mov al ':' | stosb | Mov al CR | stosb | Mov al LF
    .End_If

    stosb

    If al = LF
        Mov D$edi '    ' | add edi 4
    End_If

    jmp L0<<

L2: Mov ax CRLF | stosw ;| Mov al 0 | stosb
ret
____________________________________________________________________________________________

; Pos '0' = 31
[STR.A.UnfoldStepsTitle: B$ "
______________________________________________________________________

                      Unfold Macro Pass "

ID.UnfoldStep: B$ "0 
______________________________________________________________________

    " EOS]

UnfoldOutput:

    add B$ID.UnfoldStep 1

    Mov edi D$LP.Trash,
        esi STR.A.UnfoldStepsTitle

L0: movsb | Test B$esi NA NOT_EOS L0<

    Mov D$LP.Trash edi

    ; Count how many Statements, in the 'StatementsTable', down to our Line:
    Mov ebx D$LP.BlockStartText,
        esi D$StatementsTable

    ; For "some reason", leading Labels must be included in the Statement:
    Mov eax ebx | sub eax (1*ASCII) | While B$eax = SPC | sub eax (1*ASCII) | End_While

    If B$eax = ':'

        While B$eax-(1*ASCII) > SPC | sub eax (1*ASCII) | End_While

        Mov ebx eax

    End_If

    ; Unfold upon an Equal Pre-Parser Statement:
    If B$ebx-(1*ASCII) = 024 ;'$' ; CharMessage

        sub ebx (2*ASCII)

    Else_If B$ebx-(1*ASCII) = 0A7 ;'$'

        sub ebx (2*ASCII)

    End_If

    ; Several Statements are possible. Example, in Data and in Code with a Para-Macro:
    Mov ecx 1

    While D$esi <> EOS

        If D$esi = ebx

            Call GetUnfoldStatement

            Mov D$edi '    ' | add edi (4*ASCII)

            Mov D$LP.Trash edi

        End_If

        add esi (4*ASCII) | inc ecx

    End_While

ret
____________________________________________________________________________________________
____________________________________________________________________________________________

EncodeBoxError:

    Call ErrorMessageBox 0,
                         D$ErrorMessagePtr
    Mov esp D$OldStackPointer | sub esp 4
ret
____________________________________________________________________________________________

MarginRightClick:

    On D$LP.MEM.TABLE.BreakPoints = &NULL Call InitBreakPointsTables

    Call MouseTextPos
    Push ebx
        Call SearchTxtPtr | Mov D$BreakPointLocation eax
    Pop ebx

    Mov D$STRUCT.EditData@PhysicalCaretRow eax, D$STRUCT.EditData@CaretRow eax, D$StartBlockCol eax, D$EndBlockCol eax,
        D$STRUCT.EditData@CaretLine ebx, D$StartBlockLine ebx, D$EndBlockLine ebx

    Mov D$STRUCT.EditData@CaretRow 1

    Mov eax D$BreakPointLocation | Call IsEaxInBreakPointOnTable

    Call BreakPointMenu
ret
____________________________________________________________________________________________

DoubleClick:

    Call MouseTextPos

    Mov D$STRUCT.EditData@PhysicalCaretRow eax,
        D$STRUCT.EditData@CaretRow eax,
        D$StartBlockCol eax,
        D$EndBlockCol eax,
        D$STRUCT.EditData@CaretLine ebx,
        D$StartBlockLine ebx,
        D$EndBlockLine ebx

    If D$DBPMenuOn = DOUBLE_CLICK_ACTION

        On B$ClickOnMargin = &TRUE jmp DoubleClickMarginAction

    End_If

    Call SearchTxtPtr

    Mov al B$esi | Call WordEdge | On B$Edge = &TRUE, ret

    Push esi

        std

L0:       lodsb | Call WordEdge | cmp B$Edge &TRUE | jne L0<         ; search start

        cld

        add esi (2*ASCII) | Mov D$LP.BlockStartText esi

    Pop esi

L0: lodsb | Call WordEdge | cmp B$Edge &TRUE | jne L0<               ; search end

    sub esi (2*ASCII) | Mov D$LP.BlockEndText esi

    Mov D$FL.BlockInside &TRUE | Call SetCaret esi

    Call AskForRedraw | Call RightClickOnBlock

ret
____________________________________________________________________________________________


_________________________________________________________

; See comment for rotary BackTable at "SetBackTableMemory"

ClearBackTable:

    Mov eax D$BackTable, D$BackTablePtr eax

    Call ClearPATH D$BackTablePtr

ret


StorePosInBackTable:
    Mov ebx D$BackTablePtr, eax D$STRUCT.EditData@UpperLine
    Mov D$ebx eax | add bl 4 | Mov D$ebx 0
    Mov D$BackTablePtr ebx, B$MovingBack  &FALSE
ret


[MovingBack: D$ ?]

BackClick:
    Mov eax D$CodeSource | On D$STRUCT.EditData@SourceEnd = eax, ret

    If B$MovingBack = &FALSE              ; BackTable store old pos, not last new one.
      Call StorePosInBackTable            ; here we add last new one to allow Forward
      sub bl 4                            ; moves completion.
      Mov D$BackTablePtr ebx, B$MovingBack &TRUE
    End_If

    Mov ebx D$BackTablePtr | sub bl 4
    If D$ebx = 0                          ; If Start pointer, lock on it
        Call StartEdition | Call AskForRedraw | ret
    End_If

L1: Mov eax D$ebx
    Mov D$BackTablePtr ebx, D$STRUCT.EditData@UpperLine eax
    Mov D$STRUCT.EditData@CaretRow 1, D$STRUCT.EditData@CaretLine 0, D$STRUCT.EditData@CurrentWritingPos eax
    Call TryToMove
    Call ResetUpperline
    Call AskForRedraw
L9: ret


ForwardClick:
    Mov eax D$CodeSource | On D$STRUCT.EditData@SourceEnd = eax, ret

    Mov ebx D$BackTablePtr | add bl 4
    Mov eax D$ebx | cmp eax 0 | je L9>
      Mov D$BackTablePtr ebx, D$STRUCT.EditData@UpperLine eax
      Mov D$STRUCT.EditData@CaretRow 1, D$STRUCT.EditData@CaretLine 0, D$STRUCT.EditData@CurrentWritingPos eax
      Call TryToMove | Call ResetUpperline | Call AskForRedraw
L9: ret


; If text lenght have change between two right-click moves, D$Upperline may point to
; any char in a line. We ensure start of line in D$Upperline:

ResetUpperline:
    Mov esi D$STRUCT.EditData@Upperline
L0: cmp B$esi-1 LF | je L9>
        dec esi | jmp L0<
L9: Mov D$STRUCT.EditData@Upperline esi
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE DCBP            ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
  "DCBP" stands for "Double-Click Break-Points"
  
   Left-Margin Double-Left-Click relative Routines:
  
  * User Double-Left-Click in the left Margin:
  
    'MarginAction', 'IsEaxInBpOnTable', 'BpMenu', 'InitBreakPointsTables'
  
  * User choice in the BP Float Menu:
  
    'SetBreakpoint', ('SortBpOnTable', 'DoStoreBP'),
    'DeleteBreakpoint', 'DeleteAllBreakpoints'
  
  * Routines Call by the Sources Editor (factual Edition):
  
    'AdjustBpTable' ('AdjustDownwardPointers' // 'DeleteBpInBlock') are called by:
    'DoStoreInsert', 'DoStoreCharDelete', 'DoStoreBlockPaste',
    'WriteUndoBlockFile', 'ControlZ'
  
  * Routines called by the Source Editor output:
  
    'DrawOneBreakPoint'
  
  * Temporary example for Pointers translation at the attention of Ludwig:
  
    'GetcodeBreakPointPosFromSourcePointer'
  
  
  The two Tables, 'BpOnTable' and 'BpOffTable' are 512 dWords each (No security
  needed with one 01000 Bytes page).
  Each dword is a Pointer to the user Source: Not to the Code 'CodeListPtr'.
  
  The Call to 'WriteBpOffTable' is actualy commented out for this Static version. 
  I suppose you will need it, for BP deleted by the user during the Debug session.
;;
____________________________________________________________________________________________

; Run by 'DoubleClick'.

[BreakPointLocation: D$ ?]

MarginAction:

    Mov D$FL.ReadyToRun &FALSE

    On D$LP.MEM.TABLE.BreakPoints = &NULL Call InitBreakPointsTables
;;
  eax and ebx have been set to 'MousePosX' and 'MousePosY' by a previous Call to
  'MouseTextPos' in 'DoubleClick. 'SearchTxtPtr' is going to return the Source
  Pointer from these Screen Coordinates.
;;
    Call SearchTxtPtr | Mov D$BreakPointLocation eax | sub D$STRUCT.EditData@CaretRow 1
  ; ('Dec' because 'SearchTxtPtr' forces Row 0 to 1, for usual actions)
  ; eax now the Pointer to Row 1 (Source Pointer form). Is it already recorded or not?

    .If B$Keys+&VK_SHIFT = &TRUE
        Call DeleteAllBreakpoints

    .Else_If B$Keys+&VK_CONTROL = &TRUE
        Call IsEaxInBreakPointOnTable

        Call BreakPointMenu

;;
  The BreakPoints Float Menu may generate Call's to:
  'SetBreakpoint', 'DeleteBreakpoint', 'DeleteAllBreakpoints'
;;
        inc D$STRUCT.EditData@CaretRow

    .Else
        Call IsEaxInBreakPointOnTable

        If D$FL.InsideBreakPointTable = &TRUE
            Call DeleteBreakPoint | Call DoStoreRemoveBreakPoint
        Else
            Call SetBreakPoint | Call DoStoreBreakPoint
        End_If

     .End_If

     Mov B$Keys+&VK_SHIFT &FALSE, B$Keys+&VK_CONTROL &FALSE
ret


DoubleClickMarginAction:
    On D$LP.MEM.TABLE.BreakPoints = &NULL Call InitBreakPointsTables
;;
  eax and ebx have been set to 'MousePosX' and 'MousePosY' by a previous Call to
  'MouseTextPos' in 'DoubleClick. 'SearchTxtPtr' is going to return the Source
  Pointer from these Screen Coordinates.
;;
    Call SearchTxtPtr | Mov D$BreakPointLocation eax | dec D$STRUCT.EditData@CaretRow
  ; ('Dec' because 'SearchTxtPtr' forces Row 0 to 1, for usual actions)
  ; eax now the Pointer to Row 1 (Source Pointer form). Is it already recorded or not?

;;
  The Left Button Double-Click generates: WM_LBUTTONDOWN, WM_LBUTTONUP, WM_LBUTTONDBLCLK,
  and WM_LBUTTONUP. So forth, the 'LeftButton' stuff has already (wrongly) been
  executed and we have to reverse its effect:
;;
    Call IsEaxInBreakPointOnTable

    If D$FL.InsideBreakPointTable = &TRUE
        Call DeleteBreakPoint | Call DoStoreRemoveBreakPoint
    Else
        Call SetBreakPoint | Call DoStoreBreakPoint
    End_If

    xor D$FL.InsideBreakPointTable &TRUE

    Mov D$STRUCT.EditData@CaretRow 1

    Call BreakPointMenu
;;
  The BreakPoints Float Menu may generate Call's to:
  'SetBreakpoint', 'DeleteBreakpoint', 'DeleteAllBreakpoints'
;;
ret


IsBreakPointHere:
    Call RestoreRealSource
        Call SearchTxtPtr
        While B$eax-1 <> LF | dec eax | End_While
        Mov D$BreakPointLocation eax
        Call IsEaxInBreakPointOnTable
    Call SetPartialEditionFromPos
  ; Returns 'InsideBpTable' &TRUE or &FALSE.
ret

____________________________________________________________________________________________

[MenuFloatSetBreakPoint 5600
 MenuFloatDelBreakPoint 5601
 MenuFloatDelAllBreakPoint 5602]

[MenuFloatSetBreakPointString: B$ 'Set BreakPoint [F4]' EOS 0 0 0 0]
[MenuFloatDelBreakPointString: B$ 'Delete BreakPoint [F4]' EOS 0 0 0 0]
[MenuFloatDelAllBreakPointString: B$ 'Delete all BreakPoints [Shift]/[F4]' EOS]

[FirstStrike: D$ ?]

[BreakPointMousePos: D$ ? ?
 BreakPointMouseX: D$ ?
 BreakPointMouseY: D$ ?]

Proc KeyBoardProc:
    Arguments @nCode, @wParam, @lParam

        Inc D$FirstStrike | On D$FirstStrike < 2, jmp L9>>

        pushad
            ..If D@nCode = &HC_NOREMOVE
                .If D@wParam = &VK_F4
L1:                 Call KillBpMenu

                    If D$FL.InsideBreakPointTable = &FALSE
                        Call SetBreakPoint | Call DoStoreBreakPoint
                    Else
                        Call DeleteBreakPoint | Call DoStoreRemoveBreakPoint
                    End_If

                    popad | Mov eax &TRUE | ExitP ; Not forwarding

                .Else_If D@wParam = &VK_RETURN
                    Call 'USER32.GetMenuState' D$H.MenuFloatBreakPoint, 0, &MF_BYPOSITION
                    test eax &MF_HILITE NOT_ZERO L1<

                .End_If
            ..End_If
        popad

L9:     Mov eax &FALSE ; Forwarding
EndP


KillBpMenu:
  ; Forcing the Float Menu to close

  ; Simulate a Left-Click in the middle of the Window:
    Push D$STRUCT.EditData@CaretRow, D$STRUCT.EditData@CaretLine
        Call 'USER32.GetClientRect' D$H.EditWindow, BreakPointMousePos
        shr D$BreakPointMouseX 1 | shr D$BreakPointMouseY 1
        Call 'USER32.ClientToScreen' D$H.EditWindow, BreakPointMouseX
        Call BpClick
    Pop D$STRUCT.EditData@CaretLine, D$STRUCT.EditData@CaretRow

  ; Restore the Caret initial Position:
    Call FromCaretPosToScreen | Mov D$BreakPointMouseX eax, D$BreakPointMouseY ebx
    Call BpClick
ret


; Reurns: eax = X // ebx = Y

FromCaretPosToScreen:
    Push D$STRUC.RECT.EditWindow+LEFT, D$STRUC.RECT.EditWindow+TOP
        Call 'USER32.GetClientRect' D$H.EditWindow, STRUC.RECT.EditWindow
        Call 'USER32.ClientToScreen' D$H.EditWindow, STRUC.RECT.EditWindow
        Mov eax D$STRUCT.EditData@CaretLine, ecx D$FontHeight | mul ecx | Mov ebx eax
        Mov eax D$STRUCT.EditData@CaretRow | Mov ecx D$FontWidth | mul ecx
        add eax D$STRUC.RECT.EditWindow+LEFT | add ebx D$STRUC.RECT.EditWindow+TOP
    Pop D$STRUC.RECT.EditWindow+TOP, D$STRUC.RECT.EditWindow+LEFT
ret


BpClick:
    Call 'USER32.SetCursorPos' D$BreakPointMouseX, D$BreakPointMouseY
    Call 'USER32.mouse_event' &MOUSEEVENTF_LEFTDOWN, D$BreakPointMouseX, D$BreakPointMouseY, 0, 0
    Call 'USER32.mouse_event' &MOUSEEVENTF_LEFTUP, D$BreakPointMouseX, D$BreakPointMouseY, 0, 0
ret

BreakPointMenu:
  ; Build the Foating Menu:
    Call 'USER32.CreatePopupMenu' | Mov D$H.MenuFloatBreakPoint eax

    .If D$FL.InsideBreakPointTable = &FALSE
        Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint &MF_STRING, MenuFloatSetBreakPoint, MenuFloatSetBreakPointString
        Mov eax D$TABLE.BreakPointsOn

        If D$eax <> 0

            Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint, &MF_STRING, MenuFloatDelAllBreakPoint,
                                      MenuFloatDelAllBreakPointString
        End_If

    .Else
        Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint &MF_STRING, MenuFloatDelBreakPoint, MenuFloatDelBreakPointString
        Mov eax D$TABLE.BreakPointsOn
        If D$eax+4 <> 0
            Call 'USER32.AppendMenuA' D$H.MenuFloatBreakPoint, &MF_STRING, MenuFloatDelAllBreakPoint,
                                      MenuFloatDelAllBreakPointString
        End_If

    .End_If

    Call 'USER32.HiliteMenuItem' D$H.EditWindow, D$H.MenuFloatBreakPoint, 0,
                                 &MF_BYPOSITION__&MF_HILITE

  ; Create the KeyBoard Hook:
    Mov D$FirstStrike 0
    Call 'KERNEL32.GetCurrentThreadId'
    Call 'USER32.SetWindowsHookExA' &WH_KEYBOARD, KeyBoardProc, &NULL, eax ; <<<<<<<<<<<
    Mov D$H.Hook eax

  ; Menu Position:
    Push D$STRUCT.EditData@CaretRow
        Mov D$STRUCT.EditData@CaretRow 1 | Call FromCaretPosToScreen
    Pop D$STRUCT.EditData@CaretRow
    Call 'USER32.TrackPopupMenu' D$H.MenuFloatBreakPoint, &TPM_LEFTALIGN , eax, ebx, 0,
                                D$H.EditWindow, &NULL

    Call 'USER32.UnhookWindowsHookEx' D$H.Hook

    Call 'USER32.DestroyMenu' D$H.MenuFloatBreakPoint
ret
____________________________________________________________________________________________

[FL.InsideBreakPointTable: D$ ?]

IsEaxInBreakPointOnTable:

    Mov edx D$TABLE.BreakPointsOn

    While D$edx <> 0

        If D$edx = eax

            Mov D$FL.InsideBreakPointTable &TRUE | ret

        End_If

        add edx DWORD

    End_While

    Mov D$FL.InsideBreakPointTable &FALSE

ret
____________________________________________________________________________________________

; 0_1_000 Bytes (0_400 dwords) >>> 2*512 Dwords

[LP.MEM.TABLE.BreakPoints:
 TABLE.BreakPointsOn: D$ ?]

; No need to ever clear, as, each time a new file is loaded, the Table is released
; by 'ReInitUndo', at the same time other features are reset.

InitBreakPointsTables:

    Call VirtualAlloc LP.MEM.TABLE.BreakPoints,
                      0_1_000

    mov eax D$LP.MEM.TABLE.BreakPoints

ret

____________________________________________________________________________________________
;;
  Routines called on user choice in the BP Float Menu
  
  We reuse 'H.DebugDialog' (set to 1 in case of Mouse BP without Debugger Runing
  and to zero if none), in order to forbid editing Sources with Mouse defined BP inside
;;

SetBreakpoint:
    Call RestoreRealSource

; >>> UPDATED
    If D$BPAnteroom <> 0
        Call AddBPToAnteroom D$BreakPointLocation &TRUE
    End_If
; <<< UPDATED

    ;Call DoStoreBP

    Mov eax D$BreakPointLocation, edi D$TABLE.BreakPointsOn

    While D$edi <> 0
        add edi 4
    End_While

  ; What we are storing is the real pos, in the real Source:

    stosd

    Mov D$FL.ReadyToRun &FALSE

    Call SortBreakPointOnTable

    Call SetPartialEditionFromPos
ret


DeleteBreakpoint:
    Call RestoreRealSource

; >>> UPDATED
    If D$BPAnteroom <> 0
        Call AddBPToAnteroom D$BreakPointLocation &FALSE
    End_If
; <<< UPDATED

    Mov eax D$BreakPointLocation
    Mov esi D$TABLE.BreakPointsOn

    While D$esi <> eax
        add esi 4 | On D$esi = 0, ret
    End_While

    Mov edi esi | add esi 4
    While D$esi <> 0 | movsd | End_While
    Mov D$edi 0
    Mov D$FL.ReadyToRun &FALSE

    Call SetPartialEditionFromPos
ret


DeleteAllBreakpoints:
    Mov edi D$TABLE.BreakPointsOn

    While D$edi <> 0
        Mov eax D$edi
        Call StoreUserAction ACTION_DELDCBP, eax, &NULL
        Mov D$edi 0 | add edi 4
    End_While

    Mov D$FL.ReadyToRun &FALSE
ret


; For the Undo Feature:

DoStoreBreakPoint:
    Call StoreUserAction ACTION_DCBP, D$BreakPointLocation, &NULL
ret

DoStoreRemoveBreakPoint:
    Call StoreUserAction ACTION_DELDCBP, D$BreakPointLocation, &NULL
ret

;;
  The Undo is done without any need of some 'UnDoStoreBP' Routine, as this is done by:
  'AdjustBpTable' and 'AdjustDownwardPointers'.
;;


; This first one is called from 'SetBreakpoint' so that the Pointers are always sorted:

SortBreakPointOnTable:

    ; Sort BpOnTable:
    Mov esi D$TABLE.BreakPointsOn,
        ecx 0

    While D$esi <> 0

        add esi DWORD | add ecx DWORD

    End_While

    Call BubbleSort D$TABLE.BreakPointsOn,
                    ecx

  ; Init the Pointer to 'BpOnTable' for insertions:
  ;  Move D$BpOnTablePtr D$BpOnTable
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  If the user mofifies the Source with BreakPoints inside, we have to modify the
  Table Pointers accordingly.
  
  We make use of the Undo Table ('UndoMemory') Records to achieve this.
  
  This 'AdjustBpTable' Routine is called from:
  
  'DoStoreInsert', 'DoStoreCharDelete'
  'DoStoreBlockPaste', 'WriteUndoBlockFile'
  'ControlZ'
;;

; Called from 'StoreUserAction', 'ControlZ, 'ControlShiftZ'.

Proc AdjustBreakPointTable:
    Argument @Type

    pushad
        Mov esi D$UndoPtr, eax D@Type

        If eax = ACTION_INSERT
            Mov eax D$esi+RECORD_CURRENTWRITINGPOS
;;
  The calls to 'DoStoreInsert' are dones after the Insertion. So, we have to
  substract the Number of inserted Chars:
;;
            sub eax D$esi+RECORD_PARAM1

        Else_If eax = ACTION_BLOCKCOPY
            Mov eax D$esi+RECORD_CURRENTWRITINGPOS

        Else_If eax = ACTION_BLOCKDELETE
            Mov eax D$esi+RECORD_CURRENTWRITINGPOS

        Else_If eax = ACTION_DEL
            Mov eax D$esi+RECORD_CURRENTWRITINGPOS

        Else_If eax = ControlZ
            Mov eax D$esi+RECORD_CURRENTWRITINGPOS

        Else_If eax = ControlShiftZ
            Mov eax D$esi+RECORD_CURRENTWRITINGPOS

        Else ; ACTION_OVERWRITE, ACTION_DCBP, ACTION_DELDCBP
            popad | ExitP

        End_If

        If D$LP.ActualTitle <> &NULL
            add eax D$LP.ActualTitle
        Else
            add eax D$CodeSource
        End_If

        Mov edi D$TABLE.BreakPointsOn

        While D$edi <> 0
            If eax < D$edi
                Call AdjustDownwardPointers, D@Type | popad | ExitP
            End_If
            add edi 4
        End_While
    popad
EndP


Proc AdjustDownwardPointers:
    Argument @Type
      ; esi >>> last record in the UndoTable
      ; edi >>> first 'BpOnTable' Pointer coming downward from the 'CurrentWritingPos'
      ;
      ; Displacement Table are the ones from 'UndoPtr'

        Mov eax D$esi+RECORD_FLAG, ecx 0

        .If eax = ACTION_INSERT
          ;' n Chars':
            Mov ecx D$esi+RECORD_PARAM1

        .Else_If eax = ACTION_DEL
            Call DeleteBreakPointOnDelCRLF
            Mov ecx 0-1

        .Else_If eax = ACTION_BLOCKDELETE
            Call DeleteBreakPointInBlock
           ; Selected Block length:
            Mov ecx D$esi+RECORD_PARAM2 | sub ecx D$esi+RECORD_PARAM1 | inc ecx
            neg ecx

        .Else_If eax = ACTION_BLOCKCOPY
          ; 'ClipBoardLen' used in ControlV
            Mov ecx D$esi+RECORD_PARAM2 | sub ecx D$esi+RECORD_PARAM1 | inc ecx
;;
        .Else_If eax = ACTION_DCBP
          ;; CurrentWritingPos:
          ;  Mov eax D$esi+8
          ;  If D$TABLE.Titles = &NULL
          ;      add eax D$CodeSource
          ;  Else
          ;      add eax D$LP.ActualTitle
          ;  End_If
          ;  Mov D$BreakPointLocation eax
          ;  Call DeleteBreakpoint | ExitP
          
          ExitP
          
        .Else_If eax = ACTION_DELDCBP
            ExitP
;;
        .Else
            ExitP

        .End_If

      ; ControlZ cases:
        If D@Type = ControlZ
            neg ecx
            Mov eax D$STRUCT.EditData@CurrentWritingPos | On B$eax-1 = LF, dec ecx
        End_If

        While D$edi <> 0
            add D$edi ecx | add edi 4
        End_While
EndP


DeleteBreakPointInBlock:
    pushad

        Mov ebx D$LP.BlockStartText,
            edx D$LP.BlockEndText

        add edx (1*ASCII)
;;
  The user is deleting a Selected Block with BreakPoints inside. Remove these BPs.
  
  The Selection Values are the real Edition ones. If TITLEs inside, we have to switch
  to the real Source. If no TITLE inside, the Values are the real Source ones and we
  have nothing to do, even though this Routine is called from:
  
  'StoreUserAction' >>> 'AdjustBpTable'  >>> 'AdjustDownwardPointers'
;;
        If D$TABLE.Titles <> &NULL
            sub ebx D$CodeSource | add ebx D$LP.ActualTitle
            sub edx D$CodeSource | add edx D$LP.ActualTitle
        End_If

        Mov esi D$TABLE.BreakPointsOn

        .While D$esi <> 0
            lodsd
            .If eax >= ebx
                If eax <= edx
                    Push esi
                      ; Direct Delete of concerned BP:
                        Mov edi esi | sub edi 4
                        While D$esi <> 0 | movsd | End_While
                        Mov D$edi 0
                    Pop esi
                End_If
            .End_If
        .End_While
    popad
ret
____________________________________________________________________________________________

; If the user [Del]s a CRLF followed by a DCBP, we remove it:

DeleteBreakPointOnDelCRLF:
    pushad
        Mov ebx D$esi+RECORD_CURRENTWRITINGPOS

        If D$TABLE.Titles <> &NULL
            add ebx D$LP.ActualTitle
        Else
            add ebx D$CodeSource
        End_If

        inc ebx

        Mov esi D$TABLE.BreakPointsOn

        .While D$esi <> 0
            lodsd
            If eax = ebx
              ; Direct Delete of concerned BP:
                Mov edi esi | sub edi 4
                While D$esi <> 0 | movsd | End_While
                Mov D$edi 0 | jmp L9>
            End_If
        .End_While
L9: popad
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; These are the Routines called by the Source Editor (at the end of 'TextOutput')

[RedPlotSize: D$ ?
 RedPlotX: D$ ?]

DrawTheRedPlotsBreakPoint:

    Push esi

    Mov eax D$FontHeight | shl eax 1 | add eax D$FontWidth | shr eax 2

    Mov D$RedPlotSize eax,
        eax D$DU.BreakPointWindowMarginWidth

    sub eax D$RedPlotSize | shr eax 1

    Mov D$RedPlotX eax

    Call 'USER32.BeginPaint' D$H.BreakPointWindow,
                             PAINTSTRUCT

    Mov D$STRUCT.EditData@HDC eax

    Call 'GDI32.SelectObject' D$STRUCT.EditData@HDC,
                              D$H.RedBrush

    Call 'GDI32.SelectObject'  D$STRUCT.EditData@HDC,
                               D$H.Font1

    Mov D$STRUCT.EditData@hfont eax

    Call 'GDI32.SetBkColor' D$STRUCT.EditData@HDC,
                            D$ARVB.BackColor

    Mov ecx D$STRUCT.EditData@LineNumber,
        D$STRUCT.EditData@Line 0

    add ecx 2

L0: Push ecx

        Call 'GDI32.TextOutA' D$STRUCT.EditData@HDC,
                              0,
                              D$STRUCT.EditData@Line,
                              BlankLine,
                              2

    Pop ecx | Mov eax D$FontHeight | add D$STRUCT.EditData@Line eax | sub ecx 1 | jnz L0<

    Mov esi D$STRUCT.EditData@UpperLine,
            D$STRUCT.EditData@Line 0

    While esi < D$LastCharPosOnScreen

        If B$esi-1 = LF

            Call DrawIfEsiInBreakPointsTable

        End_If

        add esi ASCII

        If B$esi = LF

            Mov eax D$FontHeight | add D$STRUCT.EditData@line eax

        End_If

    End_While

    Call DrawTheBreakPointLine

    Call 'USER32.EndPaint' D$H.BreakPointWindow,
                           PAINTSTRUCT

    Pop esi

ret


BlankMargin:

    Call 'USER32.BeginPaint' D$H.BreakPointWindow, PAINTSTRUCT | Mov D$STRUCT.EditData@HDC eax

    Call 'GDI32.SetBkColor' D$STRUCT.EditData@HDC D$ARVB.BackColor

    Call 'GDI32.SelectObject' D$STRUCT.EditData@HDC D$H.Font1

    Mov ecx D$STRUCT.EditData@LineNumber, D$STRUCT.EditData@Line 0 | inc ecx | inc ecx

L0: Push ecx
        Call 'GDI32.TextOutA' D$STRUCT.EditData@HDC, 0, D$STRUCT.EditData@Line, BlankLine, 2
    Pop ecx
    Mov eax D$FontHeight | add D$STRUCT.EditData@Line eax | dec ecx | cmp ecx 0 | jne L0<

    Call DrawTheBreakPointLine

    Call 'USER32.EndPaint' D$H.BreakPointWindow, PAINTSTRUCT
ret


DrawIfEsiInBreakPointsTable:

    Push ebx,
         esi

        Mov ebx D$TABLE.BreakPointsOn

        .If d$FL.RealSourceRestored = &FALSE

            If D$LP.ActualTitle <> &NULL

                sub esi D$CodeSource | add esi D$LP.ActualTitle

            End_If

        .End_If

        .While D$ebx <> 0

            If D$ebx = esi

                    ; Draw one Break-Point
                    Mov eax D$RedPlotX | add eax D$RedPlotSize

                    Mov edx D$STRUCT.EditData@Line | add edx D$RedPlotSize

                    Call 'GDI32.Ellipse' D$STRUCT.EditData@HDC,
                                         D$RedPlotX,
                                         D$STRUCT.EditData@Line,
                                         eax,
                                         edx

            End_If

            add ebx 4

        .End_While

    Pop esi,
        ebx

ret
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  This is a fully _un-tested_ ;) example about the way to switch from a dword found in
  the BP Tables -in form of Pointer to User Source- to a dword pointing to the Debuggee
  App Address space Code.
;;

; UPDATED >>>

Proc GetcodeBreakPointPosFromSourcePointer:
    Argument @SourcePtr

        Mov eax D@SourcePtr, esi D$StatementsTable, edx D$StatementsPtr
        Mov ebx D@SourcePtr

      ; 'edx' (D$StatementsPtr) should still point to the last record of 'StatementsTable'
      ; it doesn't :?

        While D$esi <> 0
            On D$esi >= eax, jmp L1>
;;
  Why '>=', up there? This is because the registred Sources Pointers, in the BP Tables,
  may point, for example, to leading spaces, and such (cases of Indents, Blank lines,
  Square Brackets Declarations,...).
;;
            add esi 4
        End_While

;;
  At 'L1:', edi should point to the Record of the searched Location in the 
  'StatementsTable' dwords Pointers Table. Now, get the Matching Code one:
;;
L1:     sub esi D$StatementsTable | add esi D$IpTable | lodsd
;;
  'eax' should now be a Pointer to Code as viewed by the Encoder. There is an
  adjustement variable called 'DebugBaseOfCode' that should enable with the true
  location inside the Debuggee App real Address space. (It is computed by 'SetCodeRVA')
  To be verified by experiment, but i think you should now say:
;;
        add eax D$DebugBaseOfCode

      ; 'eax' should ready as Return value...
EndP

; <<<
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Tag             ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
  Tag Feature:
  
  When a commented out 'Tag' KeyWord is found out (Right-Click feature), these Parsers
  are run and branced to the according associated action.
  
  First implementation, for test, if:
_________________

; Tag Dialog 1000
_________________

  'WizardTag' 'NewWizardForm'

  is written in some Source, when Right-Clicking on 'Tag', and if the Edited PE Resources
  contain a Dialog with an ID 1000 (Decimal only), the Dialog Editor should be run.
;;

____________________________________________________________________________________________
____________________________________________________________________________________________

; General purpose Routines: B$ 'IsItTag', 'TagParser', 'NoSuchTag', 'TagDecimalToBin', 'NewWizardForm', 'WizardFormTag'

; When called from 'RightClick' > 'InternalRightClick', esi+1 point to 'Tag '

IsItTag:
    Push esi
  ; Is it a Comment?
L0:     If B$esi = ';'
            ; OK
        Else_If B$esi = SPC
            dec esi | jmp L0<
        Else
            Pop esi | Mov eax &FALSE | ret
        End_If

    Pop esi
    Mov eax &TRUE
ret
____________________________________________________________________________________________

TagParser:
  ; Check for the Tag KeyWords:
  ; 'Dialog' or 'Wizard'

  ; esi > 'tag '
    add esi 4 | While B$esi = SPC | inc esi | End_While
    Mov eax D$esi | or eax 020202020
  ; "Tag Dialog DialogID":
    ...If eax = 'dial'
        Mov ax W$esi+4 | or ax 02020
        .If ax = 'og'
            If B$esi+6 = SPC
                Mov D$FL.ReadyToRun &FALSE
                add esi 7 | jmp DialogTag
            End_If
        .End_If
  ; "Tag Wizard WizardName 'Path...........' ":
    ...Else_If eax = 'wiza'
        Mov ax W$esi+4 | or ax 02020
        .If ax = 'rd'
            If B$esi+6 = SPC
                Mov D$FL.ReadyToRun &FALSE
                add esi 6 | jmp WizardTag
            End_If
        .End_If
  ; "Tag Unicode LabelName":
    ...Else_If eax = 'unic'
        Mov eax D$esi+3 | or eax 020202020
        .If eax = 'code'
            If B$esi+7 = SPC
                Mov D$FL.ReadyToRun &FALSE
                add esi 8 | jmp UnicodeTag
            End_If
        .End_If
  ; "Tag Menu MenuID":
    ...Else_If eax = 'menu'
        If B$esi+4 = SPC
            Mov D$FL.ReadyToRun &FALSE
            add esi 5 | jmp MenuTag
        End_If

    ...End_If

    Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'Unknown Tag KeyWord' EOS}, {B$ 'No such Tag' EOS}, 0
ret


TagDecimalToBin:
    Mov ecx 0, eax 0

L0: lodsb
    cmp al SPC | jbe L9>
    cmp al '9' | ja L8>
    cmp al '0' | jb L8>
        sub al '0'                  ; convert Decimal to binary:
        lea ecx D$ecx+ecx*4         ;     ecx = ecx * 5
        lea ecx D$eax+ecx*2         ;     ecx = eax + old ecx * 10
    jmp L0<

L8: Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ "Tags' Numbers are to be provided in Decimal notation" EOS},
                              {B$ 'Bad Number' EOS}, 0
    Mov eax &FALSE | ret

L9: Mov eax &TRUE | ret

____________________________________________________________________________________________

; "Tag Dialog" Routines:

; "; Tag Dialog " found // esi on next possible ID

DialogTag:
    While B$esi = SPC | inc esi | End_While

    Call TagDecimaltoBin

    .If eax = &TRUE
        Mov eax ecx

        If eax = 0
            ; nope
        Else_If eax > 0_FFFF
            ; nope
        Else
            Call GetTagedDialog
        End_If
    .End_If
ret

____________________________________________________________________________________________

; Simplified version of the 'LoadFromResources' executed by Menu Selection:

GetTagedDialog:
    If D$FL.DialogEdition = &TRUE
        Call Beep | ret  ; prevents from multi-runs
    End_If

    Push eax
        Call ReleaseDialogMemories | Call InitDialogMemory
    Pop eax

    Mov esi DialogList, D$MenuListPtr esi      ; 1 record:  ID / Ptr / Size

L0: .If D$esi = eax
        Mov D$WhatDialogListPtr esi | add D$WhatDialogListPtr 4  ;DialogList+4

        Mov ebx D$WhatDialogListPtr, ebx D$ebx
        If W$ebx+18 = 0
            Mov D$ActualMenutestID 0, D$DialogMenuTrueID 0
        Else
            movzx eax W$ebx+20 | Mov D$DialogMenuTrueID eax
            Mov esi MenuList
            While D$esi <> eax
                add esi 12
            End_While
            Mov D$MenuListPtr esi
            add esi 4
            Call 'USER32.LoadMenuIndirectA' D$esi | Mov D$ActualMenutestID eax
        End_If

        Mov B$DialogLoadedFromResources &TRUE
        Call FromBinToTextTemplate
        Call ReInitDialogEdition

    .Else_If D$esi = 0
        Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'No Dialog found with matching ID Number' EOS},
                                  {B$ 'Bad ID' EOS}, 0
    .Else
        add esi 12 | jmp L0<<
    .End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
[WizardCommandLine: D$ ? # 512]

[NewFormPath: B$ ? # &MAX_PATH]
[ProducedCode_BeginWrite: D$ ?
 ProducedCode_Written: D$ ?
 H.ProducedCode: D$ ?
 ProducedCode: D$ ?
 H.WizardSearch: D$ ?]

[WizardName: B$ 'WZRD010Form.exe' EOS]

[WizardSaving:
 @dwFileAttributes: D$ ?
 @ftCreationTime.dwLowDateTime: D$ ?
 @ftCreationTime.dwHighDateTime: D$ ?
 @ftLastAccessTime.dwLowDateTime: D$ ?
 @ftLastAccessTime.dwHighDateTime: D$ ?
 @ftLastWriteTime.dwLowDateTime: D$ ?
 @ftLastWriteTime.dwHighDateTime: D$ ?
 @nFileSizeHigh: D$ ?
 @nFileSizeLow: D$ ?
 @dwReserved0: D$ ?
 @dwReserved1: D$ ?]
[@cFileName: B$ ? # &MAX_PATH]
[@cAlternate: B$ ? # 14]

; tag example :
; >  ; Tag Wizard Form "C\MyPath\MyFolder\MyFile.wwf" -R

; esi points on the space after "; Tag wizard"
WizardTag:

    If D$H.DebugDialog <> 0
          Push esi | Call CloseDebuggerOrIgnore | Pop esi | On eax = &IDNO ret
    End_If

    ;Push D$CurrentWritingPos
    Mov D$STRUCT.EditData@CurrentWritingPos esi
    Call SetPartialEditionFromPos
    Mov esi D$STRUCT.EditData@CurrentWritingPos

    ; selects the wizard
    Mov eax D$esi+1
    or eax 020202020
    If eax = 'form'

        Call WizardFormTag
    ;  ; Temporary add, because of the new 'ControlZ', that does not work on the Full Source:
    ;    Call ReInitUndo
    Else_If eax = 'test'
        ;jmp WizardFormTest
    End_If

    Call RestoreRealSource

    Call ReInitUndoOnly
ret
____________________________________________________________________________________________
WizardFormTag:

    Call CheckTagEndPos | On eax = &FALSE, ret

    ; retrieves Wizard Path :
    Push esi

        Call GetBUAsmFilesPath

        Mov esi BUAsmFilesPath | Mov edi WizardPath
        While B$esi <> 0 | movsb | End_While
        Mov esi WizardName
        While B$esi <> 0 | movsb | End_While | Mov B$edi 0
    Pop esi

    ; set esi on the character after the first double quote following 'Tag Wizard Form'
    While B$esi <> '"' | inc esi | End_While | inc esi

    ; => command line writing:
    Mov edi WizardCommandLine

    ;    * Wizard FileName
    Mov B$edi '"' | inc edi
    Push esi
        Mov esi WizardPath
        While B$esi <> 0 | movsb | End_While
    Pop esi
    Mov B$edi '"' | inc edi

    ;    * File location
    Mov D$edi '-f "'  | add edi 4
    While B$esi <> '"' | movsb | End_While
    Mov W$edi '" ' | add edi 2

    ;    * RosAsm ID
    Mov W$edi '-R'  | add edi 2 | Mov B$edi 0 | inc edi

    Call LoadWizardAndPasteCode esi

ret
____________________________________________________________________________________________
Proc DeleteLastWizardCode:
    Argument @TagBegin
    Uses edx

    Mov esi D@TagBegin
    While B$esi <> LF | dec esi | End_While | inc esi | Mov edx esi
    While esi <= D$STRUCT.EditData@SourceEnd
        .If W$esi = ((59 shl 8) or LF)
            Mov eax D$esi+3 | or eax 0202020
            If eax = 'tag '
                Mov eax D$esi+6 | or eax 020202000
                On eax = ' end', jmp L1>
                ExitP
            End_If
        .End_If
        inc esi
    End_While
    ; should not be accessed ( checked before)
    ExitP

L1: While B$esi <> CR | add esi (1*ASCII) | End_While | sub esi (1*ASCII) | Mov D$LP.BlockEndText esi

    Mov D$LP.BlockStartText edx,
        D$FL.BlockInside &TRUE,
        D$STRUCT.EditData@CaretRow 1,              ; the caret is set at the beginning of the block
        D$STRUCT.EditData@PhysicalCaretRow 1,
        eax D$STRUCT.EditData@CaretRow,
        ebx D$STRUCT.EditData@CaretLine

    Call SearchTxtPtr

    Mov D$STRUCT.EditData@CurrentWritingPos eax

    Call ControlD

    ;ControlZ

EndP
____________________________________________________________________________________________
Proc CheckTagEndPos:
    Uses esi

    While B$esi <> LF | dec esi | End_While | inc esi | Mov edx esi
    While esi <= D$STRUCT.EditData@SourceEnd
        .If W$esi = ((59 shl 8) or LF)
            Mov eax D$esi+3 | or eax 0202020
            If eax = 'tag '
                Mov eax D$esi+6 | or eax 020202000
                On eax = ' end', jmp L1>
                jmp L2>
            End_If
        .End_If
        inc esi
    End_While

L2: Call 'USER32.MessageBoxA' D$H.MainWindow,
{B$ "Can't find '; Tag End' mark.
Write it back and try again ;o)" EOS},  {B$ "Error" EOS}, &MB_ICONERROR
    Mov eax &FALSE
    ExitP

L1: Mov eax &TRUE

EndP
____________________________________________________________________________________________
Proc AddWizardCode:
    Argument @WizardCodePtr @WizardCodeLen
    Uses D$ClipBoardLen

    Move D$ClipBoardLen D@WizardCodeLen

    Call ReMapSourceMemoryIfNeeded D$ClipBoardLen | On eax = &IDNO, ret

    Call DoStoreBlockPaste

    Mov esi D$STRUCT.EditData@SourceEnd | add esi 400                       ; make room inside our text:
    Mov edi esi | add edi D$ClipBoardLen
    Mov ecx esi | sub ecx D$STRUCT.EditData@CurrentWritingPos | inc ecx
    std | rep movsb | cld | inc esi
                                                            ; write from clipboard:
    Mov edi esi, esi D@WizardCodePtr, ecx D$ClipBoardLen
    pushad | rep movsb | popad
                                                            ; position:
    Mov esi edi, ebx D$STRUCT.EditData@CaretLine
L0: lodsb | inc D$STRUCT.EditData@CaretRow | cmp al CR | jne L1>
        inc ebx | Mov D$STRUCT.EditData@CaretRow 1 | lodsb | dec ecx | jz L0>
L1: loop L0<

L0: cmp ebx D$STRUCT.EditData@LineNumber | jna L6>
        Mov esi D$STRUCT.EditData@UpperLine | Mov ecx ebx | sub ecx D$STRUCT.EditData@CaretLine
L1:     lodsb | cmp al LF | jne L1<
            Mov D$STRUCT.EditData@UpperLine esi | dec ebx | jmp L0<

L6: Mov D$STRUCT.EditData@CaretLine ebx

    Mov eax D$ClipBoardLen
    add D$SourceLen eax | add D$STRUCT.EditData@SourceEnd eax | add D$STRUCT.EditData@CurrentWritingPos eax


EndP
____________________________________________________________________________________________
NewWizardForm:

    .If D$H.DebugDialog <> 0
          Call CloseDebuggerOrIgnore | If eax = &IDNO | Pop esi | ret | End_If
    .End_If

    Call 'USER32.MessageBoxA' D$H.MainWindow {B$ 'Set the caret where you want the code to be pasted, and click OK.' EOS},
                              {B$ 'Wait a minute...' EOS}    &MB_ICONEXCLAMATION+&MB_SYSTEMMODAL

    Call GetBUAsmFilesPath

    Mov esi BUAsmFilesPath | Mov edi WizardPath

    While B$esi <> 0 | movsb | End_While
    Mov esi WizardName
    While B$esi <> 0 | movsb | End_While | Mov B$edi 0


    Call GetDirectory NewFormPath
    Mov esi NewFormPath | add esi eax
    Mov D$esi '\Wiz' | add esi 4 | Mov D$esi 'ardF' | add esi 4 | Mov D$esi 'iles' | add esi 4
    Mov B$esi 0

    Push esi | Call 'KERNEL32.CreateDirectoryA' NewFormPath &NULL | Pop esi

    Mov D$esi '\WZR' | add esi 4 | Mov D$esi 'DFor' | add esi 4 | Mov D$esi 'm*.w' | add esi 4
    Mov W$esi 'wf'   | add esi 2 | Mov B$esi 0

  Push esi
    ; looks for existing wizard files in the '\WizardFiles\' sub-directory of the program's directory
    Call 'KERNEL32.FindFirstFileA' NewFormPath WizardSaving
    Mov D$H.WizardSearch eax
    xor ecx ecx
    If eax <> &INVALID_HANDLE_VALUE
L1:     Push ecx | Call 'KERNEL32.FindNextFileA' D$H.WizardSearch WizardSaving | Pop ecx
        inc ecx
        cmp eax 0 | jnz L1<
        Push ecx | Call 'KERNEL32.FindClose' D$H.WizardSearch | Pop ecx
    End_If
  Pop esi

    ; creates the new file name according to the number of already existing files
    Mov ebx ecx | Mov edi esi | sub edi 2
    std
        Mov ecx, 4
L1:     Mov al bl | and al 0F | On al >= 0A, add al 7
        add al, '0' | stosb | shr ebx, 4 | loop L1
    cld
    Mov D$esi-1 '.wwf' | Mov B$esi+3 0


    ; => command line writing:
    Mov edi WizardCommandLine

    ;    * Wizard FileName
    Mov B$edi '"' | inc edi
    Mov esi WizardPath
    While B$esi <> 0 | movsb | End_While
    Mov B$edi '"' | inc edi

    ;    * File location
    Mov D$edi '-f "'  | add edi 4
    Mov esi NewFormPath
    While B$esi <> 0 | movsb | End_While
    Mov W$edi '" ' | add edi 2

    ;    * create the Wizard File
    Mov W$edi '-c'  | add edi 2 | Mov B$edi SPC | inc edi

    ;    * RosAsm ID
    Mov W$edi '-R'  | add edi 2 | Mov B$edi 0 | inc edi

    Call LoadWizardAndPasteCode &FALSE

    Call ReInitUndoOnly
ret

____________________________________________________________________________________________
Proc LoadWizardAndPasteCode:
    Argument @TagBegin

    Call 'KERNEL32.CreateEventA' &NULL &FALSE &FALSE {B$ 'ProducedCode_BeginWrite' EOS}
    Mov D$ProducedCode_BeginWrite eax

    Call 'KERNEL32.CreateProcessA' WizardPath WizardCommandLine 0 0  0  0 0 0  STARTUPINFO  ProcessInfos
    If eax = 0
        Call 'USER32.MessageBoxA' D$H.MainWindow {B$ "The Wizard cannot be loaded." EOS},
                                        ErrorMessageTitle   &MB_ICONEXCLAMATION+&MB_SYSTEMMODAL
        jmp L9>>
    End_If
    Call 'KERNEL32.WaitForSingleObject' D$ProducedCode_BeginWrite &INFINITE  ; wait while the user uses the wizard
    ; open the shared memory where the code has been written.
    ; the first DWord of this data is the code length.
    Call 'KERNEL32.OpenFileMappingA' &FILE_MAP_ALL_ACCESS 0 {B$ 'RosAsmWizardProducedCode' EOS}
    Mov D$H.ProducedCode eax
    Call 'KERNEL32.MapViewOfFile' D$H.ProducedCode &FILE_MAP_ALL_ACCESS 0 0 0 ; jE!
    Mov D$ProducedCode eax | add D$ProducedCode 4

    If D$eax <> 0
        On D@TagBegin <> &FALSE, Call DeleteLastWizardCode D@TagBegin
        Mov eax D$ProducedCode | Mov edx D$eax-4
        Call AddWizardCode eax edx
    Else
        On D@TagBegin = &FALSE, Call 'KERNEL32.DeleteFileA' NewFormPath
    End_If

    sub D$ProducedCode 4
    Call 'KERNEL32.UnmapViewOfFile' D$ProducedCode
    Call 'KERNEL32.CloseHandle' D$H.ProducedCode
    Call 'KERNEL32.OpenEventA' &EVENT_MODIFY_STATE &FALSE {B$ 'ProducedCode_Written' EOS}
    Mov D$ProducedCode_Written eax
    Call 'KERNEL32.SetEvent' D$ProducedCode_Written
    Call 'KERNEL32.CloseHandle' D$ProducedCode_Written
    Call 'KERNEL32.CloseHandle' D$ProcessInfos+4
    Call 'KERNEL32.CloseHandle' D$ProcessInfos
L9: Call 'KERNEL32.CloseHandle' D$ProducedCode_BeginWrite

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

 ; TAG Unicode @MyUnicodeString
; Clic droit sur TAG pour ouvrir l'éditeur !
[@MyUnicodeString: U$ 06D, 06C, 06B, 06D, 06C, 06B, 06D, 06C, 06B, 0D, 0A,
                      06D, 06D, 0
 @MyUnicodeStringNchars: D$ 0D]

UnicodeTag:

    ; Esi points to 'MyUnicodeString', inside "; Tag Unicode MyUnicodeString":
    Call 'USER32.DialogBoxParamW' D$H.Instance,
                                  600,
                                  &NULL,
                                  UnicodeEditorProc,
                                  esi

ret


[H.UnicodeEditor: D$ ?
 UnicodeDataPointer: D$ ?]

; Tag Dialog 600

Proc UnicodeEditorProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_INITDIALOG
        Move D$H.UnicodeEditor D@hwnd, D$UnicodeDataPointer D@lParam

        Call 'USER32.SetClassLongW' D@hwnd, &GCL_HICON, D$STRUC.WINDOWCLASS@hIcon

        Call LoadUnicodeEditorFont

        On D$H.UnicodeEditorFont <> 0,
            Call 'USER32.SendDlgItemMessageW' D@hwnd, 10, &WM_SETFONT,
                                              D$H.UnicodeEditorFont, &TRUE

        Call SetUnicodeDialogContent | jmp L8>>

    ...Else_If D@msg = &WM_COMMAND
        Mov eax D@wParam | and D@wParam 0FFFF | shr eax 16

        .If D@wParam = &IDCANCEL
            If D$H.UnicodeEditorFont <> 0
                Call 'GDI32.DeleteObject' D$H.UnicodeEditorFont
                Mov D$H.UnicodeEditorFont 0
            End_If

            Call 'USER32.DestroyWindow' D@hwnd

        .Else_If D@wParam = &IDOK
          ; The Call is from inside the Right-Click, with full Source restored. So:
            Call SetPartialEditionFromPos
                Call PasteUnicodeDialogContent
            Call RestoreRealSource

            If D$H.UnicodeEditorFont <> 0
                Call 'GDI32.DeleteObject' D$H.UnicodeEditorFont
                Mov D$H.UnicodeEditorFont 0
            End_If

            Call 'USER32.DestroyWindow' D@hwnd

        .Else_If D@wParam = 3
            Call GetUnicodeEditorFont

            If D$H.UnicodeEditorFont <> 0
                Call 'USER32.SendDlgItemMessageW' D@hwnd, 10, &WM_SETFONT,
                                              D$H.UnicodeEditorFont, &TRUE
                Call UpdateRegistry
            End_If
;;
; Does not work, at all:

        .Else_If D@wParam = 4
            Call 'USER32.GetDlgItem' D@hwnd, 10
            Push eax
                Call 'USER32.GetWindowLongW' eax, &GWL_STYLE
                xor eax &ES_AUTOHSCROLL__&WS_HSCROLL
            Pop ebx
            Call 'USER32.SetWindowLongW' ebx, &GWL_STYLE, eax
;;
        .End_If

    ...Else_If D@msg = &WM_CTLCOLOREDIT
        Call 'USER32.SendMessageA' D@lParam, &EM_SETSEL, 0-1, 0
        Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | ExitP


    ...Else
L8:     popad | Mov eax &FALSE | ExitP

    ...End_If

    popad | Mov eax &TRUE
EndP


[UNICODE_EDITION_CHOOSEFONT: ; EditorCHOOSEFONT
 @lStructSize: D$ len
 @hwndOwner: D$ 0
 @hDC: D$ 0
 @lpLogFont: D$ UNICODE_EDITION_LOGFONT
 @iPointSize: D$ 0
 @Flags: D$ &CF_SCREENFONTS__&CF_INITTOLOGFONTSTRUCT
 @rgbColors: D$ 0
 @lCustData: D$ 0
 @lpfnHook: D$ 0
 @lpTemplateName: D$ 0
 @hInstance: D$ 0
 @lpszStyle: D$ &SCREEN_FONTTYPE
 @nFontType: W$ 0
 @Alignment: W$ 0
 @nSizeMin: D$ 0
 @nSizeMax: D$ 0]

[UNICODE_EDITION_LOGFONT:
 @lfHeight: D$ 0
 @lfWidth: D$ 0
 @lfEscapement: D$ 0
 @lfOrientation: D$ 0
 @lfWeight: D$ 0
 @lfItalic: B$ 0
 @lfUnderline: B$ 0
 @lfStrikeOut: B$ 0
 @lfCharSet: B$ 0
 @lfOutPrecision: B$ 0
 @lfClipPrecision: B$ 0
 @lfQuality: B$ 0
 @lfPitchAndFamily: B$ 0
 @lfFaceName: U$ 0 # &LF_FACESIZE
 UNICODE_EDITION_LOGFONTlen: D$ len]

[H.UnicodeEditorFont: D$ ?]

LoadUnicodeEditorFont:
    If D$H.UnicodeEditorFont = 0
        Call 'GDI32.CreateFontIndirectA' UNICODE_EDITION_LOGFONT
        Mov D$H.UnicodeEditorFont eax
    End_If
ret


GetUnicodeEditorFont:
    Move D$UNICODE_EDITION_CHOOSEFONT@hwndOwner D$H.UnicodeEditor
    Call 'Comdlg32.ChooseFontW' UNICODE_EDITION_CHOOSEFONT

    If eax = &TRUE
        On D$H.UnicodeEditorFont <> 0, Call 'GDI32.DeleteObject' D$H.UnicodeEditorFont
        Call 'GDI32.CreateFontIndirectW' UNICODE_EDITION_LOGFONT
        Mov D$H.UnicodeEditorFont eax
    End_If
ret


[AddedCRLF: D$ ?
 UnicodeDataInsertionPoint: D$ ?
 UnicodeValuesAlignment: D$ ?
 NumberOfUnicodeChars: D$ ?]

PasteUnicodeDialogContent:

    Mov esi D$UnicodeDataPointer

    Call InternalRightClick

    If D$FL.BlockInside = &TRUE

        Mov esi D$LP.BlockStartText

        While B$esi <> '[' | sub esi (1*ASCII) | End_While

        Mov D$LP.BlockStartText esi,
            D$UnicodeDataInsertionPoint esi

        Mov esi D$LP.BlockEndText

        While B$esi <> ']' | add esi (1*ASCII) | End_While

        Mov D$LP.BlockEndText esi

        Call ControlD

        Mov B$AddedCRLF &FALSE

    Else

        Mov B$AddedCRLF &TRUE


        Mov esi D$UnicodeDataPointer

        While B$esi >= SPC | add esi (1*ASCII) | End_While

        Mov D$UnicodeDataInsertionPoint esi

    End_If

    ;    Mov ebx D$UnicodeDataPointer
    ;    While B$ebx > CR | inc ebx | End_While | add ebx 2

    Call 'USER32.SendDlgItemMessageW' D$H.UnicodeEditor,
                                      10,
                                      &WM_GETTEXTLENGTH,
                                      D$H.UnicodeEditorFont,
                                      &FALSE

    add eax 100

    shl eax 1

    Call VirtualAlloc Trash1,
                      eax

    Push eax

        Call 'USER32.SendDlgItemMessageW' D$H.UnicodeEditor,
                                          10,
                                          &WM_GETTEXT,
                                          eax,
                                          D$Trash1

    Pop eax

  ; Max = 7 Char ("0FFFF, ") >>> 8 + Alignements (....) >>>> 32
    shl eax 5

    Call VirtualAlloc Trash2,
                      eax

    Mov edi D$Trash2

    If B$AddedCRLF = &TRUE

        Mov D$edi CRLF2 | add edi (4*ASCII)

    End_If

    Mov B$edi '[', ecx edi

    add edi (1*ASCII)

  ; Write the Data Label to the Tempo Buffer:
    Mov esi D$UnicodeDataPointer

    While B$esi > SPC | movsb | End_While

    Mov D$edi ': U$', B$edi+(4*ASCII) SPC | add edi (5*ASCII)

  ; Alignement count:
    sub ecx edi | neg ecx | Mov D$UnicodeValuesAlignment ecx

    Mov esi D$Trash1,
        ecx 0,
        D$NumberOfUnicodeChars 0

    .While W$esi <> 0

        movzx eax W$esi| add esi (2*ASCII) | Call WriteEax | Mov W$edi ', ' | add edi (2*ASCII) | add ecx (1*ASCII)

        add D$NumberOfUnicodeChars (1*ASCII)

      ; New Line when wished:
        If ecx = (11*ASCII)

            Mov ecx 0

            Mov W$edi CRLF | add edi (2*ASCII)

            Mov ecx D$UnicodeValuesAlignment

            While ecx > 0 | Mov B$edi SPC | sub ecx (1*ASCII) | add edi (1*ASCII) | End_While

        End_If

    .End_While

  ; Remove the possible CRLF and ',', at the end of the buffer:
    While B$edi <= SPC | sub edi (1*ASCII) | End_While | On B$edi = ',' sub edi (1*ASCII)

    add edi (1*ASCII)

  ; Cases of empty Edition:
    If W$edi-(2*ASCII) = 'U$'

        Mov W$edi ' 0' | add edi (2*ASCII)

    Else

        Mov D$edi ', 0]' | add edi (3*ASCII)

    End_If

    Mov W$edi CRLF | add edi (2*ASCII)

    Mov esi D$UnicodeDataPointer

    Mov B$edi SPC | add edi (1*ASCII)

    While B$esi > SPC | movsb | End_While

    Mov D$edi 'Ncha', D$edi+(4*ASCII) 'rs: ' | add edi (8*ASCII)

    Mov D$edi 'D$  ' | add edi (3*ASCII)

    Mov eax D$NumberOfUnicodeChars | Call WriteEax

    Mov B$edi ']' | add edi (1*ASCII)

    Move D$LP.BlockStartText D$Trash2,
         D$LP.BlockEndText edi

    Mov D$FL.BlockInside &TRUE

    Call ControlC

    Mov D$FL.BlockInside &FALSE

    Call SetCaret D$UnicodeDataInsertionPoint

    Call ControlV

    Call VirtualFree Trash2

    Call VirtualFree Trash1

ret


SetUnicodeDialogContent:

    Mov esi D$UnicodeDataPointer | Call InternalRightClick

    .If D$FL.BlockInside = &TRUE

        Mov esi D$LP.BlockEndText

        While B$esi <> '0'

            add esi (1*ASCII) | On B$esi = ']' ret

        End_While

        Push esi
        ; Count the number of Words (at least...):

          Mov ecx 0

          While B$esi <> ']'

            On B$esi = '0' add ecx 1

            add esi (1*ASCII)

          End_While

          add ecx 1 | shl ecx 1
        ; Get a mem:
          Call VirtualAlloc Trash1,
                            ecx

        Pop esi

      ; esi >>> first '0' of the first hexa data.
      ; Translate each Hexa Word to Binary:
        Mov edi D$Trash1
      ; strip the leading '0'
L0:     lodsb

        Mov ebx 0
L1:
        lodsb | cmp al ',' | je L8>

                cmp al ']' | je L8>

                    sub al '0' | cmp al 9 | jbe L2>

                        sub al 7

                        cmp al 0F | ja L9>
L2:
        shl ebx 4 | or bl al | jmp L1<

L8:     Mov W$edi bx | add edi (2*ASCII)

        If al <> ']'

            While B$esi < '0'

                add esi (1*ASCII)| On esi >= D$STRUCT.EditData@SourceEnd jmp L9>

            End_While

            On B$esi = '0', jmp L0<

        End_If

L9:     Mov W$edi 0

        Call 'USER32.SendDlgItemMessageW' D$H.UnicodeEditor,
                                          10,
                                          &WM_SETTEXT,
                                          0,
                                          D$Trash1

        Call VirtualFree Trash1

    .End_If

ret

____________________________________________________________________________________________
____________________________________________________________________________________________

MenuTag: ; 'ExistingMenu'
    While B$esi = SPC | inc esi | End_While

    Call TagDecimalToBin

    If eax = &TRUE
        Mov eax ecx | Call GetTagedMenu
    End_If
ret


[TagedEdition: D$ ?]

GetTagedMenu:
    Mov esi MenuList
  ; (ID / Ptr / Size)
    While D$esi <> 0

        If D$esi = eax

            Mov B$TagedEdition &TRUE

            Mov D$MenuListPtr esi

            Call ReEditExistingMenu | jmp L9>

        Else
            add esi (4*3)

        End_If

    End_While

L9: .If B$TagedEdition = 0-1
      ; Delete the Previous Menu Equates Block, and paste the New Menu Equates Block:
        Lea esi D$DataForClipEquates+3 | Call InternalRightClick

        If D$FL.BlockInside = &TRUE

            Mov esi D$LP.BlockStartText

            While B$esi <> '[' | sub esi (1*ASCII) | End_While

            Mov D$LP.BlockStartText esi

            add esi (1*ASCII)

            While B$esi <> ']' | add esi (1*ASCII) | End_While

            Mov D$LP.BlockEndText esi

            Call ControlD | Call ControlV

        End_If

    .End_If

    Mov B$TagedEdition &FALSE

ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Icon            ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;;
                                      icon editor
 
 (To be entirely re-written by who wants to).

 _______________________________________________________________________________________
 _______________________________________________________________________________________
;;

; Dialog Box Template in memory.

[ID_Inew 301  ID_Ipeek 302  ID_Ipoke 303  ID_IfromIco 304  ID_ItoIco 305
 ID_Icancel 306  ID_Ikeep 307  ID_TrackBar 320]

 _______________________________
;;
 The icon editor is set upon a dialog box created at run time (when created
 no dialog resource editor in RosAsm). The only one difficulty i encounted is
 that 'title's must be dWords aligned (doc doesn't tell).

 The predefined classes values are:
 080=button / 081=Edit / 082=Static / 083=ListBox / 084=ScrollBar / 085=ComboBox
;;

[IconDialogData:

; Dialog Box template:

  D$ &DS_SETFONT+&DS_CENTER+&WS_CAPTION+&WS_VISIBLE+&DS_MODALFRAME+&DS_3DLOOK+&WS_SYSMENU  ; style
     0                                                                   ; ext. Style
  U$ 8  0  0  220  200     ; control-number, x, y, width, hight
     0                       ; no menu
     0                       ; class 0 > default
    'Icon Editor' 0 0        ; title
     10 'Helv' 0

; controls (7 button):

  D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 15  40  8            ; x y w h
     ID_Inew                 ; ID
     0FFFF                   ; Predefined class
     080                     ; 080=button
    '> New >' 0                   ; button title
     0                       ; no creation data

  D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 30  40  8            ; x y w h
     ID_Ipeek                ; ID
     0FFFF                   ; Predefined class
     080                     ; button
    '> .exe >' 0 0                  ; button title
     0                       ; no creation data

  D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 45  40  8            ; x y w h
     ID_Ipoke                ; ID
     0FFFF                   ; Predefined class
     080                     ; button
    '< .exe <' 0  0                 ; button title
     0                       ; no creation data

  D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 60  40  8            ; x y w h
     ID_IfromIco             ; ID
     0FFFF                   ; Predefined class
     080                     ; button
    '> .ico >' 0  0          ; button title
     0                       ; no creation data

  D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 75  40  8            ; x y w h
     ID_ItoIco               ; ID
     0FFFF                   ; Predefined class
     080                     ; button
    '< .ico <' 0  0          ; button title
     0                       ; no creation data

  D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 90  40  8           ; x y w h
     &IDCANCEL               ; ID
     0FFFF                   ; Predefined class
     080                     ; button
    '= Cancel =' 0  0        ; button title
     0                       ; no creation data

  D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 105 40  8           ; x y w h
     ID_Ikeep                ; ID
     0FFFF                   ; Predefined class
     080                     ; button
    '* Keep *' 0  0          ; button title
     0]                      ; no creation data

 [@AddToIcon: D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 120 40  8           ; x y w h
     ID_Help                ; ID
     0FFFF                   ; Predefined class
     080                     ; button
    '  Help  ' 0  0          ; button title
     0]                      ; no creation data

 _______________________________

; Icon Edition data

[iIcoFileHeader:

 ; poor little thing for saving a poor little icon alone in a poor little ico file:

 W$    0   ; reserved
       1   ; Type 1
       1   ; entries number
B$   020   ; width
     020   ; hight
     010   ; color count
       0   ; reserved
W$     0   ; planes
       0   ; bits count
D$  02E8   ; size
     016   ; offset from .ico start


; All these data are not the table used to build a PE. Just a temporary table for
; icon edition. In case user compiles a source without having drawn any icon, this
; one is copyied to &TRUE buffer as default. Once user have compiled an application
; reloading it fills this table with previously defined icon.

iIcon:
@iIconHeader:
B$ 028,0,0,0     ; size
   020,0,0,0     ; width
   040,0,0,0     ; height (maybe 40h because of the two masks)
   01,0          ; planes
   04,0          ; bit count
   0,0,0,0       ; compression 0
   080,02,0,0    ; 0280 > size of icon data
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0   ; (dummy)


iIconPalette:
;Blue,green,red,0    (16 color palette -values seams to be fixed ones-)

B$ 0,  0,  0,  0 ; color 0
   0,  0,080,  0 ;       1
   0,080,  0,  0 ;       2
   0,080,080,  0 ;       3
 080,  0,  0,  0 ;       4
 080,  0,080,  0 ;       5
 080,080,  0,  0 ;       6
 0C0,0C0,0C0,  0 ;       7
 080,080,080,  0 ;       8
   0,  0,0FF,  0 ;       9    rouge
   0,0FF,  0,  0 ;       A
   0,0FF,0FF,  0 ;       B
 0FF,  0,  0,  0 ;       C    bleu
 0FF,  0,0FF,  0 ;       D
 0FF,0FF,  0,  0 ;       E
 0FF,0FF,0FF,  0 ;       F


iIconXorMask:
; XOR color mask: (32*16 octets > 2 pixels / byte > 32*32 pixels)

B$    0    0
B$    0    0    0    0    0    0    0    0    0    0    0   0C    0    0   09  099
B$  099  099  099  099  099  099  099  099  099  099  099   0C  0C0    0   09  099
B$  099  099  099  099  099  099  099  099  099  099  099   0C  0CC    0    0    0
B$   09  099  099  099  099  099  099  099  099  099  099   0C  0CC  0C0   03  03B
B$   09  099  099  099  099  099  099  099  099  099  099   0C  0CC  0C0    0  033
B$   09  099  090    0    0    0    0  099  099  099  099   0C  0CC  0C0    0   03
B$   09  099  090  0B$  0BB  0BB  0B0  099  099  099  099   0C  0CC  0C0    0    0
B$   09  099  090  0DD  0BB  0BB  0B0  099  099  099  099   0C  0CC  0C0    0    0
B$   09  099  090  0DD  0B$  0BB  0B0  099  099  099  099   0C  0CC  0C0    0    0
B$   09  099  090  0DD  0DD  033  030  099  099  099  099   0C  0CC  0C0    0    0
B$    0    0    0  0DD  0DD    0    0  099  099  099  099   0C  0CC  0C0    0    0
B$   03  03B  0BB  0BD  0DD    0    0  099  099  099  099   0C  0CC  0C0    0    0
B$    0  033  0BB  0BB  0DD    0    0  099  099  099  099   0C  0CC  0C0    0    0
B$  0C0   03  03B  0BB  0BD    0    0    0    0    0    0   0C  0CC  0C0   0E  0E0
B$  0CC    0  033  033  033    0    0  033  0BB  0BB  0BB  0BB  0CC  0C0   0E  0E0
B$  0CC  0C0    0    0    0    0    0   03  03B  0BB  0BB  0BB  0BC  0C0   0E  0E0
B$  0CC  0CC    0    0    0    0   0C    0  033  0BB  0BB  0BB  0BB  0C0   0E  0E0
B$  0CC  0CC    0   0E  0EE  0EE   0C  0C0   03  033  033  033  033  030   0E  0E0
B$  0CC  0CC    0   0E  0EE  0EE   0C  0CC    0    0    0    0    0    0   0E  0E0
B$  0CC  0CC    0   0E  0EE  0EE   0C  0CC  0C0    0    0    0    0    0   0E  0E0
B$    0    0    0   0E  0EE  0EE   0C  0C0    0    0    0    0    0    0   0E  0EE
B$  0EE  0EE  0EE  0EE  0EE  0EE   0C  0C0  0AA  0AA  0AA  0AA   0C    0   0E  0EE
B$  0EE  0EE  0EE  0EE  0EE  0EE   0C  0C0  0AA  0AA  0AA  0AA   0C  0C0   0E  0EE
B$  0EE  0EE  0EE  0EE  0EE  0EE   0C  0C0  0AA  0AA  0AA  0AA   0C  0CC   0E  0EE
B$  0EE  0EE  0EE  0EE  0EE  0EE   0C  0C0  0AA  0AA  0AA  0AA   0C  0CC    0    0
B$    0    0    0    0    0    0   0C  0C0  0AA  0AA  0AA  0AA   0C  0CC   03  03B
B$  0BB  0BB  0BB  0BB  0BB  0BB  0BB  0C0  0AA  0AA  0AA  0AA   0C  0CC    0  033
B$  0BB  0BB  0BB  0BB  0BB  0BB  0BB  0B0  0AA  0AA  0AA  0AA   0C  0CC    0   03
B$  03B  0BB  0BB  0BB  0BB  0BB  0BB  0B0    0    0    0    0   0C  0CC    0    0
B$  033  033  033  033  033  033  033  033   03  0BB  0BB  0BB  0BB  0CC    0    0
B$    0    0    0    0    0    0    0    0    0  03B  0BB  0BB  0BB  0BC    0    0
B$    0    0    0    0    0    0    0    0    0   03  033  033  033  033


iIconAndMask:
; AND monochrome mask: (8*16 octects > 8 pixels / byte > 32*32 pixels)

B$    0    0
B$    0   0F    0    0    0   07    0    0    0   03    0    0    0   01  080    0
B$    0   01  0C0    0    0   01  0E0    0    0   01  0F0    0    0   01  0F0    0
B$    0   01  0F0    0    0   01  0F0   03  080   01  0F8   03  080   01  0FC   03
B$  080   01   06   03  080   01   03   03  0C0   01   01  0FF  0E0   01    0  0C0
B$  030   01    0  0C0  018   01    0  0C0   0F  0FF    0  0C0   07  0FF    0    0
B$    0   07    0    0    0   03    0    0    0   01    0    0    0    0    0    0
B$    0    0    0    0    0    0  080    0    0    0  0C0    0    0    0  0E0    0
B$    0    0  0F0    0    0    0  0FF  0FF  0F8    0  0FF  0FF  0FC    0

EndiIconAndMask:]

 ______________________________

; RGB (eax) <> RGBquad (eax) (red green blue <> blue red green):

reverseRGB:
    Push ecx, ebx
      Mov ebx eax, ecx eax
      and eax 0FF | and ebx 0FF00 | and ecx 0FF0000
      shl eax 16 | shr ecx 16
      add eax ebx | add eax ecx
    Pop ebx, ecx
ret

 _______________________________

; Routines for drawing on Icon Dialog Box.

[iRECT:
 iRECTx1: D$ 120
 iRECTy1: D$ 20
 iRECTx2: D$ 130
 iRECTy2: D$ 30]

[iPAINTSTRUCT:
 @hdc: D$ ?
 @fErase: D$ ?
 @rcPaint: B$ ?
 @fRestore: D$ ?
 @fIncUpdate: D$ ?
 @rgbReserved: D$ ? ? ? ?  ? ? ? ?]

[iXcount: D$ ?
 iYcount: D$ ?]

; drawing one little box (each 'pixel') in edit icon image. Calculations at
; 'IBrush index' are to translate the "handles'Brushes" (linear dWords) in
; a pointer to "Brushes'structures". DL is used to rotary point to AND mask bits.

iOneRect:
    Mov dh B$iIconAndMask+ecx | and dh dl
    pushad
      If dh <> 0
; blank area box:
        Call 'GDI32.Rectangle' D$iPAINTSTRUCT@hdc  D$iRECTx1  D$iRECTy1  D$iRECTx2  D$iRECTy2
; blank of true size icon at bottom:
        Mov eax D$iRECTx1, ebx D$iRECTy1 ; | sub eax 140 | sub ebx 276
        shr eax 3 | shr ebx 3 | add eax 40 | add ebx 360
        Call 'GDI32.SetPixel' D$iPAINTSTRUCT@hdc eax ebx D$iBackGroundColor
      Else
        Push eax
; One color pixel box of icon :
          Call 'USER32.FillRect' D$iPAINTSTRUCT@hdc iRECT D$H.IBrush0+eax
        Pop ebx
; show true size icon pixel at bottom:
        shr ebx 2                                    ; IBrush index
        Mov ecx ebx | shl ebx 1 | add ecx ebx        ; * 3
        inc ecx                                      ; + 1
        shl ecx 2                                    ; * 4
        Mov ecx D$IBrush0+ecx
      ;  Mov eax D$iRECTx1, ebx D$iRECTy1 | sub eax 140 | sub ebx 276
      ;  shr eax 3 | shr ebx 3 | add eax 40 | add ebx 360

        Mov eax D$iRECTx1, ebx D$iRECTy1
        shr eax 3 | shr ebx 3 | add eax 28 | add ebx 320
      ; Toto fix

        Call 'GDI32.SetPixel' D$iPAINTSTRUCT@hdc eax ebx ecx      ; handle, X, Y, color
; NT > problem: only bottom line drawn (ebx always the same value ???) don't find any
; reason for...
      End_If
    popad
    ror dl 1 | On dl = 00_1000_0000, inc ecx
ret


; Drawing of edition image of icon:

iDrawColorBox:
    Call 'USER32.BeginPaint' D$H.IconEditor, iPAINTSTRUCT
    Call 'USER32.GetDC' D$H.IconEditor | Mov D$iPAINTSTRUCT@hdc eax
    Mov D$iRECTx1 135,  D$iRECTy1 305, D$iRECTx2 0192,  D$iRECTy2 016C
    Call 'USER32.FillRect' D$iPAINTSTRUCT@hdc iRECT D$H.IBackBrush
    Mov D$iRECTx1 140,  D$iRECTy1 310, D$iRECTx2 160,  D$iRECTy2 330, ecx 0
L0: Push ecx
      dec D$iRECTx1 | dec D$iRECTy1 | inc D$iRECTx2 | inc D$iRECTy2
      Call 'GDI32.Rectangle' D$iPAINTSTRUCT@hdc  D$iRECTx1  D$iRECTy1  D$iRECTx2  D$iRECTy2
      inc D$iRECTx1 | inc D$iRECTy1 | dec D$iRECTx2 | dec D$iRECTy2
    Pop ecx
    Push ecx
      Mov al cl | shr al 2 | cmp B$ActualColor, al | jne L1>
        pushad
          Mov eax D$iRECTx1, ebx D$iRECTy1, ecx D$iRECTx2, edx D$iRECTy2
          sub eax 3 | sub ebx 3 | add ecx 3 | add edx 3
          Call 'GDI32.Rectangle' D$iPAINTSTRUCT@hdc  eax ebx ecx edx
        popad
L1:   Call 'USER32.FillRect' D$iPAINTSTRUCT@hdc iRECT D$H.IBrush0+ecx
    Pop ecx
      add ecx 4 | cmp ecx 64 | jae L9>
        add D$iRECTx1 34 | add D$iRECTx2 34
        If ecx = 32
          Mov D$iRECTx1 140,  D$iRECTy1 340, D$iRECTx2 160,  D$iRECTy2 360
        End_If
      jmp L0<<
L9: Call 'USER32.ReleaseDC' D$H.IconEditor, D$iPAINTSTRUCT@hdc
    Call 'USER32.EndPaint' D$H.IconEditor, iPAINTSTRUCT
 ret


; Main Construction of the editor: edit image + true size icon + color selection boxes:

[iBackGroundColor: D$ ?
 DrawIconMessage: D$ ?]

DrawIcon:
    Call 'USER32.BeginPaint' D$H.IconEditor, iPAINTSTRUCT
      Call 'USER32.GetDC' D$H.IconEditor | Mov D$iPAINTSTRUCT@hdc eax
      Call 'GDI32.GetPixel' eax 5 5 | Mov D$iBackGroundColor eax, D$iBackBrush+4 eax
      Call DeleteIconBrushes | Call CreateIconBrushes
        Mov D$iXcount 0, D$iYcount 0
        Mov D$iRECTx1 140,  D$iRECTy1 276,  D$iRECTx2 149,  D$iRECTy2 285
        Mov esi iIconXorMask, ecx 0, edx 00_1000_0000

L0:     Mov ebx 0, eax 0 | lodsb | Mov bl al | and ebx 0F | and eax 0F0 | shr eax 4
          shl eax 2 | shl ebx 2
            Call iOneRect
              inc D$iXcount | add D$iRECTx1 8 | add D$iRECTx2 8
                Mov eax ebx
                  Call iOneRect
                    inc D$iXcount | cmp D$iXcount 32 | je L2>
        add D$iRECTx1 8 | add D$iRECTx2 8 | jmp L0<<

L2:     inc D$iYcount | cmp D$iYcount 32 | je L3>
          Mov D$iRECTx1 140,  D$iRECTx2 149, D$iXcount 0
            sub D$iRECTy1 8 | sub D$iRECTy2 8 | jmp L0<<

L3: Call 'USER32.ReleaseDC' D$H.IconEditor,  D$iPAINTSTRUCT@hdc
    Call 'USER32.EndPaint' D$H.IconEditor, iPAINTSTRUCT
    On D$DrawIconMessage <> &WM_MOUSEMOVE, Call iDrawColorBox
ret

 ______________________________________

; Brushes used by icon editor. 'iBrush0', ... are brushes creation data;
; 'ihBrush0, ... are brushes handles.

; [BS_SOLID 0] = first of 3 members, second is the color

 ; brushes struc
[IBrush0: D$ ? ? ?
 IBrush1: D$ ? ? ?
 IBrush2: D$ ? ? ?
 IBrush3: D$ ? ? ?
 IBrush4: D$ ? ? ?
 IBrush5: D$ ? ? ?
 IBrush6: D$ ? ? ?
 IBrush7: D$ ? ? ?
 IBrush8: D$ ? ? ?
 IBrush9: D$ ? ? ?
 IBrushA: D$ ? ? ?
 IBrushB: D$ ? ? ?
 IBrushC: D$ ? ? ?
 IBrushD: D$ ? ? ?
 IBrushE: D$ ? ? ?
 IBrushF: D$ ? ? ?
 iBrushesEnd:]

; brushes handles
[H.IBrush0: D$ ?
 H.IBrush1: D$ ?
 H.IBrush2: D$ ?
 H.IBrush3: D$ ?
 H.IBrush4: D$ ?
 H.IBrush5: D$ ?
 H.IBrush6: D$ ?
 H.IBrush7: D$ ?
 H.IBrush8: D$ ?
 H.IBrush9: D$ ?
 H.IBrushA: D$ ?
 H.IBrushB: D$ ?
 H.IBrushC: D$ ?
 H.IBrushD: D$ ?
 H.IBrushE: D$ ?
 H.IBrushF: D$ ?]

[iBackBrush: D$ ? ? ?
 H.IBackBrush: D$ ?]

CreateIconBrushes:
    Mov edi iBrush0, esi iIconPalette | add edi 4        ; store icon palette colors
L0: lodsd | Call reverseRGB | stosd | add edi 8          ; in brushes structures
    cmp edi iBrushesEnd | jb L0<

    Call 'GDI32.CreateBrushIndirect' iBrush0 | Mov D$H.IBrush0 eax
    Call 'GDI32.CreateBrushIndirect' iBrush1 | Mov D$H.IBrush1 eax
    Call 'GDI32.CreateBrushIndirect' iBrush2 | Mov D$H.IBrush2 eax
    Call 'GDI32.CreateBrushIndirect' iBrush3 | Mov D$H.IBrush3 eax
    Call 'GDI32.CreateBrushIndirect' iBrush4 | Mov D$H.IBrush4 eax
    Call 'GDI32.CreateBrushIndirect' iBrush5 | Mov D$H.IBrush5 eax
    Call 'GDI32.CreateBrushIndirect' iBrush6 | Mov D$H.IBrush6 eax
    Call 'GDI32.CreateBrushIndirect' iBrush7 | Mov D$H.IBrush7 eax
    Call 'GDI32.CreateBrushIndirect' iBrush8 | Mov D$H.IBrush8 eax
    Call 'GDI32.CreateBrushIndirect' iBrush9 | Mov D$H.IBrush9 eax
    Call 'GDI32.CreateBrushIndirect' iBrushA | Mov D$H.IBrushA eax
    Call 'GDI32.CreateBrushIndirect' iBrushB | Mov D$H.IBrushB eax
    Call 'GDI32.CreateBrushIndirect' iBrushC | Mov D$H.IBrushC eax
    Call 'GDI32.CreateBrushIndirect' iBrushD | Mov D$H.IBrushD eax
    Call 'GDI32.CreateBrushIndirect' iBrushE | Mov D$H.IBrushE eax
    Call 'GDI32.CreateBrushIndirect' iBrushF | Mov D$H.IBrushF eax
    Call 'GDI32.CreateBrushIndirect' iBackBrush | Mov D$H.IBackBrush eax
ret


DeleteIconBrushes:
    Call 'GDI32.DeleteObject'  D$H.IBrush0
    Call 'GDI32.DeleteObject'  D$H.IBrush1
    Call 'GDI32.DeleteObject'  D$H.IBrush2
    Call 'GDI32.DeleteObject'  D$H.IBrush3
    Call 'GDI32.DeleteObject'  D$H.IBrush4
    Call 'GDI32.DeleteObject'  D$H.IBrush5
    Call 'GDI32.DeleteObject'  D$H.IBrush6
    Call 'GDI32.DeleteObject'  D$H.IBrush7
    Call 'GDI32.DeleteObject'  D$H.IBrush8
    Call 'GDI32.DeleteObject'  D$H.IBrush9
    Call 'GDI32.DeleteObject'  D$H.IBrushA
    Call 'GDI32.DeleteObject'  D$H.IBrushB
    Call 'GDI32.DeleteObject'  D$H.IBrushC
    Call 'GDI32.DeleteObject'  D$H.IBrushD
    Call 'GDI32.DeleteObject'  D$H.IBrushE
    Call 'GDI32.DeleteObject'  D$H.IBrushF
    Call 'GDI32.DeleteObject'  D$H.IBackBrush
ret
 ________________________________________

; calculation of icon editor position of some user click:

[InsideEditBox edx  InsideColorBox ecx]

iPos:
    Mov InsideEditBox &FALSE, InsideColorBox &FALSE
    Mov eax D$MousePosX, ebx D$MousePosY
  ;  Mov eax 0, ebx 0 | Push D$Lparam | Pop ax, bx      ; eax > x / ebx > y
    cmp eax 08D  | jbe L9>
    cmp eax 018D | jae L9>
    cmp ebx 01C  | jbe L9>
    cmp ebx 011C | jae L8>
      sub eax 08D | sub ebx 01C                         ; Pos - origin
      Mov InsideEditBox &TRUE | ret
L8: cmp ebx 0135 | jb L9>
    cmp ebx 0167  | ja L9>
      sub eax 08D | sub ebx 0135
      Mov InsideColorBox &TRUE | ret
L9: ret

; Drawing in icon image.

[ActualColor: D$ ?]  ; accessed as byte and as dword.

; In: eax / ebx = indexes x/y to on icon pixel. we really write at iIconXorMask,
; (iIconAndMask used as "iIconXorMaskEnd"). first line is last one.
; When back from iPos, if user clicked on left upper little box, eax=0 / ebx=0
; ... on right lower one: eax=01F / ebx=01F:

EditIcon:
    shr eax 3 | shr ebx 3                                  ; 8 pixels per little box
    Push eax, ebx
      Mov esi iIconAndMask | sub esi 16 | shl ebx 4 | sub esi ebx ; + lines
      Mov ebx eax                                                 ; keep for odd test
      shr eax 1 | add esi eax
      Mov al B$ActualColor | Mov ah 00_1111_0000
      Test ebx 1 NOT_ZERO L2>
        shl al 4 | Mov ah 00_1111
L2:   and B$esi ah | or B$esi al
    Pop ebx, eax
    Mov esi EndiIconAndMask | sub esi 4 | shl ebx 2 | sub esi ebx
    Mov ecx eax
    shr eax 3 | add esi eax
    and ecx 00_111
    Mov al 00_1000_0000 | shr al cl
    or B$esi al | xor B$esi al
    Call DrawIcon
  ret

; Clearing in icon image.

ClearIconPix:
    shr eax 3 | shr ebx 3                               ; 8 pixels per little box
    Push eax, ebx
      Mov esi iIconAndMask | sub esi 16 | shl ebx 4 | sub esi ebx  ; + lines
      Mov ebx eax                                     ; keep for odd test
      shr eax 1 | add esi eax
      Mov al B$ActualColor | Mov ah 00_1111_0000
      Test ebx 1 NOT_ZERO L2>
        shl al 4 | Mov ah 00_1111
L2:   and B$esi ah
    Pop ebx, eax
    Mov esi EndiIconAndMask | sub esi 4 | shl ebx 2 | sub esi ebx
    Mov ecx eax
    shr eax 3 | add esi eax
    and ecx 00_111
    Mov al 00_1000_0000 | shr al cl
    or B$esi al
    Call DrawIcon
ret


; Search what color choice box user clicked on.

WhatColor:
    shr eax 5 | shr ebx 5 | shl ebx 3
    add eax ebx | Mov B$ActualColor al
    Call DrawIcon
ret


; user left click on the square rainbow:

WhatNewColor:
    Call 'GDI32.GetPixel' D$RainbowDC eax ebx | Call ReverseRGB
    Mov edi iIconPalette, ebx D$ActualColor | shl ebx 2 | add edi ebx | stosd
    Call DeleteIconBrushes | Call CreateIconBrushes
    Call iDrawColorBox
ret

; User left Click on selected Color Box while in 'Choose Color':

SetNewColor:
    shr eax 5 | shr ebx 5 | shl ebx 3
    add eax ebx | cmp al B$ActualColor | jne L9>
      Call 'USER32.DestroyWindow' D$H.GreenSlider
      Call DeleteRainbowDC
      Mov B$OnRainbow &FALSE
      Call DrawIcon
L9: ret


iLeft:
    Call iPos
    cmp B$OnRainbow &TRUE | jne L5>

    If InsideEditBox = &TRUE
      Call WhatNewColor
    Else_If InsideColorBox = &TRUE
      Call SetNewColor
    End_If
    ret

L5: If InsideEditBox = &TRUE
      Call EditIcon
    Else_If InsideColorBox = &TRUE
      Call WhatColor
    End_If
L9: ret

 ________________________________________

; Showing Square Rainbow for color choice:

[RedBit 1  BlueBit  00_00000001_00000000_00000000  GreenBit  00_00000001_00000000
 NO_RED 0FFFFFF00  NO_BLUE 0FFFF  NO_GREEN 0FF00FF]

; size, width, height, planes, bitCount, compression imagesize x/meter y/meter 0  0
[RainBowHeader:
 D$ 40 255 255
 W$ 1 32
 D$ 0  65025
 @xMeter: D$ 0
 @yMeter: D$ 0   0  0]

[H.RainBow: D$ ?
 RainbowDC: D$ ?
 RainData: D$ ?
 SlideGreen: D$ ?
 OldRainbowBitMaP: D$ ?]

; Build a 2 dimensions color table in memory (blue/red):

DeleteRainbowDC:
    Call 'GDI32.SelectObject' D$RainBowDC  D$OldRainbowBitMaP
    Call 'GDI32.DeleteObject' D$H.RainBow
    Call 'GDI32.DeleteDC' D$RainbowDC
ret


Rainbow:
    Call 'USER32.BeginPaint' D$H.IconEditor iPAINTSTRUCT

    Call 'USER32.GetDC' D$H.IconEditor | Mov D$iPAINTSTRUCT@hdc eax

    Call 'GDI32.CreateCompatibleDC' D$iPAINTSTRUCT@hdc | Mov D$RainbowDC eax

    Call 'GDI32.CreateDIBSection' D$RainBowDC RainBowHeader,
                                     &DIB_RGB_COLORS RainData 0 0
    Mov D$H.RainBow eax

; filling colors data:

    Mov eax D$SlideGreen, ecx 0FF, edi D$RainData
    shl eax 8
L0: Push ecx
        Mov ecx 0FF
L1:     stosd | add eax RED_BIT | loop L1<
            and eax NO_RED
    Pop ecx
    add eax BLUE_BIT | loop L0<

; Painting at screen (we do not release rainbow DC and object here -needed-):

    Call 'GDI32.SelectObject' D$RainBowDC  D$H.RainBow
        Mov D$OldRainbowBitMaP eax
    Call 'GDI32.BitBlt' D$iPAINTSTRUCT@hdc 140 30  255 255 D$RainbowDC 0  0  &SRCCOPY

    Call 'USER32.ReleaseDC' D$H.IconEditor D$iPAINTSTRUCT@hdc

    Call 'USER32.EndPaint' D$H.IconEditor, iPAINTSTRUCT
ret


; Icon edition area is a little bit larger than 255/255 because of little boxes edges.
; we clean that here, at first 'color box right click':

clearIconArea:
    Call 'USER32.BeginPaint' D$H.IconEditor, iPAINTSTRUCT
      Call 'USER32.GetDC' D$H.IconEditor | Mov D$iPAINTSTRUCT@hdc eax
        Mov D$iRECTx1 135,  D$iRECTy1 25, D$iRECTx2 400,  D$iRECTy2 290
        Call 'USER32.FillRect' D$iPAINTSTRUCT@hdc iRECT D$H.IBackBrush
      Call 'USER32.ReleaseDC' D$H.IconEditor  D$iPAINTSTRUCT@hdc
    Call 'USER32.EndPaint' D$H.IconEditor, iPAINTSTRUCT
ret


[TrackClassName: B$ 'msctls_trackbar32' EOS]
[TrackTitle: B$ 'Green' EOS]
[H.GreenSlider: D$ ?]

GreenSlider:

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  TrackClassName,
                                  TrackTitle,
                                  &WS_CHILD+&WS_VISIBLE+&TBS_LEFT+&TBS_VERT,
                                  410,
                                  25,
                                  20,
                                  265,
                                  D$H.IconEditor,
                                  ID_TRACKBAR,
                                  D$H.Instance,
                                  0
    Mov D$H.GreenSlider eax
    Call 'USER32.SendMessageA' D$H.GreenSlider  &TBM_SETRANGE 1 0FF_0000
    Mov eax D$SlideGreen | not al
    Call 'USER32.SendMessageA' D$H.GreenSlider  &TBM_SETPOS 1  eax
ret


[OnRainbow: D$ ?
 OldSelectedColor: D$ ?]

RestorePreviousColor:
    Mov edi iIconPalette, eax D$ActualColor | shl eax 2
    add edi eax | Mov eax D$OldSelectedColor | stosd
    Call DeleteIconBrushes | Call CreateIconBrushes | Call DrawIcon
ret


SaveActualColor:
    Mov esi iIconPalette, eax D$ActualColor | shl eax 2
    add esi eax | lodsd | Mov D$OldSelectedColor eax
ret


iRight:
    If B$OnRainbow = &TRUE
      Call RestorePreviousColor
      Call 'USER32.DestroyWindow' D$H.GreenSlider
      Call deleteRainbowDC
      Mov B$OnRainbow &FALSE | ret
    End_If

    Call iPos
    If InsideEditBox = &TRUE
      Call ClearIconPix
    Else_If InsideColorBox = &TRUE
      Mov B$OnRainbow &TRUE
      Call WhatColor
      Call SaveActualColor
      Mov esi iIconPalette, eax D$ActualColor | shl eax 2
      add esi eax | inc esi | Mov eax 0, al B$esi | Mov D$SlideGreen eax
      Call clearIconArea | Call GreenSlider | Call RainBow
    End_If
L9: ret


; Retrieve the slider value on user Move and redraw rainbow:

iTrackMove:
      Call 'USER32.SendMessageA' D$H.GreenSlider &TBM_GETPOS 0 0
        not al | Mov D$SlideGreen eax
      Call DeleteRainbowDC | Call Rainbow
L9: ret

 ___________________________________________________________________________________
 ___________________________________________________________________________________

; reading and writing icons from/to files:

 ___________________________________________________________________________________

; Reading and writing an icon from/to a PE:
 ___________________________________________________________________________________

[iStartOfResources: D$ 0
 iExePtr: D$ 0
 iExeLen: D$ 0
 @iResourceRVA: D$ 0
 H.ISource: D$ 0
 iSourceFilterPtr: D$ 1
 iPEFilesFilters:  B$ 'PE files' EOS '*.exe' EOS  0]

[iuFileFilter: B$ ? # &MAX_PATH]
[iSaveFilter: B$ ? # &MAX_PATH]
[iChoosenFile: B$ ? # &MAX_PATH]

[iOpenPEStruc: len
 ihwndPEFileOwner: D$ 0
 iOPESInstance: D$ 0
 D$ iPEFilesFilters
 D$ iuFileFilter
 D$ &MAX_PATH
 D$ iSourceFilterPtr
 D$ iSaveFilter
 D$ &MAX_PATH
 D$ iChoosenFile
 D$ &MAX_PATH
 D$ 0
 D$ 0 ;OpenPEFileTitle
 D$ 0281804 ; !!! WinEquate ?
 D$ 0 0 0 0 0]

[ResourcesRVA: D$ ?
 NoResourcesPE: D$ ?
 PeIconFound: D$ ?]

OpenPeForReadingIcon:
  ; Opening a file:
    Mov B$NoResourcesPE &FALSE

    Call ClearPATH iSaveFilter

    Call 'Comdlg32.GetOpenFileNameA' iOpenPEStruc

    On D$iSaveFilter = 0 ret
 ______________________________________

  ; Loading the entire file in memory:

    On D$H.ISource > 0 Call 'KERNEL32.CloseHandle' D$H.ISource

    Mov esi iSaveFilter

    Call 'KERNEL32.CreateFileA' esi &GENERIC_READ, &FILE_SHARE_READ+&FILE_SHARE_WRITE,
                                0, &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE
        Call MessageBox D$BusyFilePtr ;;;;| Pop eax | ret  ; return to caller of caller
        Mov D$H.ISource 0
    Else
        Mov D$H.ISource eax

        Call 'KERNEL32.GetFileSize'  eax 0
        Mov D$iExeLen eax

        Call VirtualAlloc iExePtr,
                          eax


        Call 'KERNEL32.ReadFile' D$H.ISource D$iExePtr,
                                 eax NumberOfReadBytes 0      ; load headers
    End_If
ret


ReadRosAsmPeIcon:                     ; reused by general purpose RosAsm PE opening.
    Mov B$PeIconFound &FALSE

  ; read dos header:
    Mov esi D$iExePtr
    Mov eax 0 | add esi 8 | lodsw    ; parag. size of dos header end >PE header adress

    shl eax 4 | sub eax 4
    Mov esi D$iExePtr | add esi eax | lodsd      ; eax = PE header

    Mov esi D$iExePtr | add esi eax
    If W$esi <> 'PE'
        Mov esi D$iExePtr | add esi 03C | lodsd | add eax D$iExePtr | Mov esi eax
        cmp W$esi 'PE' | jne PeNotFound
    End_If

 ______________________________________

  ; read data in PE header:

    movzx ecx w$esi+6                     ; word record of section number
    add esi 136 | lodsd | Mov ebx eax     ; RVA of resources from "Image Data Dir..."
    Mov D$ResourcesRVA eax  ; jmp over general purpose headers and reach PE sections headers:

    add esi 120                           ; esi points to RVA of first section header

L0: lodsd | cmp eax ebx | je L1>
        add esi 36 | loop L0<
        On ebx = 0, jmp AbortIconSearch
          jmp SectNotFound

L1: On D$esi-16 <> '.rsr', jmp AbortIconSearch

 ______________________________________

  ; if here, '.rsrc' section found:

L1: add esi 4 | lodsd                            ; > app ptr to resources

    add eax D$iExePtr | Mov D$iStartOfResources eax

DisReadMainIcon:
    Mov B$PeIconFound &FALSE

    Mov esi eax | add esi 14                     ; > number of ID resources
    Mov eax 0 | lodsw | Mov ecx eax              ; > in ecx
    add cx W$esi-4                               ; add number of Named IDs
    On eax = 0, jmp AbortIconSearch      ; if no resources at all

  ; search RT_ICON in resource general header:

L0: lodsd | cmp eax RT_ICON | je L1>
    lodsd | loop L0<
      jmp AbortIconSearch                        ; no icon found (possible naked PE)

L1: lodsd                   ; icon found "Level2Rt_Icon-StartOfRsrc+NodeFlag" in eax
    and eax 0FFFFFFF        ; strip node flag (0_80000000)
    add eax D$iStartOfResources

    add eax 14 | Mov esi eax, edx 0, dx W$esi | sub  esi 2

 ______________________________________

  ; resource TYPEs dir:

NextiRecord:

    add esi 8
    Push esi

    lodsd                              ; "Level3Rt_Icon-StartOfRsrc+NodeFlag" in eax
    and eax 0FFFFFFF
    add eax D$iStartOfResources
    add eax 20 | Mov esi eax

  ; language. dir:
    lodsd                      ; "Level4Rt_Icon-StartOfRsrc" in eax (no NodeFlag here
                                       ; next one is leave ptr to true resources)
    add eax D$iStartOfResources
    Mov esi eax

  ; records of each resource:
    lodsd                              ; ptr to icon data (but RVA - startOfResource)
    Mov ecx D$esi

    If ecx <> 02E8                                       ; 2E8h = size of common icons
      Pop esi | dec edx | On edx > 0, jmp NextiRecord
        jmp BadIcoSize
    Else
      Pop esi
    End_If

    sub eax ebx                              ; - RVA
    add eax D$iStartOfResources              ; eax now points to true icon data
    Mov B$PeIconFound &TRUE
  ret


SectNotFound:    Mov eax SectionNotFound | jmp L9>
AbortIconSearch:

    If D$SavingExtension = '.DLL'
        jmp L7>
    Else_If D$SavingExtension = '.SYS'
        jmp L7>
    End_If

                    Mov eax NoIcon       | jmp L9>
BadIcoSize:      Mov eax BadIconSize     | jmp L9>
PeNotFound:      Mov eax NoPE

L9: ;If B$Disassembling = &TRUE
    ;    Mov D$iExePtr 0 | ret  ; restored by Disassembler Call (used as Flag, here).
    ;End_If
    Call MessageBox eax ;;;;| Call IconSearchOut ;| Pop eax |
    ret     ;;;; return to caller of caller

L7: Mov B$NoResourcesPE &TRUE ;;;;| Call IconSearchOut |
    ret


;IconSearchOut:
;    Mov eax D$UserPeStart | On D$iExePtr <> eax, VirtualFree D$iExePtr
;  ; Don't destroy User Source in any case, if the 'readRosAsmPeIcon' Routine is called
;  ; from some Open PE ,normal Functions.
ret

[SectionNotFound: B$ 'Section not found' EOS]
[BadIconSize: B$ 'Icon size not assumed' EOS]
[NoPE: B$ 'PE signature not found' EOS]
[NoIcon: B$ 'Icon not found in this file' EOS]


; peek from PE:

PeekIcon:
    Call OpenPeForReadingIcon

    .If D$H.ISource <> 0
        Call ReadRosAsmPeIcon                        ; eax > start of icon data

        If B$PeIconFound = &TRUE
            Mov esi eax | Mov edi iIcon | rep movsb  ; Copying to ower buffer
        End_If

        Call 'KERNEL32.CloseHandle' D$H.ISource | Mov D$H.ISource 0

        Call VirtualFree iExePtr

    .End_If
ret


[H.IDestination: D$ ?]
[PokeSure: B$ 'Ready to modify choosen PE?' EOS]
[NullTitle: B$ SPC EOS]

; Poke inside PE:

PokeIcon:
    Call OpenPeForReadingIcon                        ; eax > start of icon data

    ..If D$H.ISource <> 0
        Call ReadRosAsmPeIcon                        ; eax > start of icon data

        .If B$PeIconFound = &TRUE
            Mov edi eax | Mov esi iIcon | rep movsb  ; Copying from ower buffer
            Call 'KERNEL32.CloseHandle' D$H.ISource | Mov D$H.ISource 0
            Call 'USER32.MessageBoxA' D$H.MainWindow  PokeSure  NullTitle,
                                    &MB_YESNO+&MB_ICONEXCLAMATION +&MB_SYSTEMMODAL
            On eax = &IDNO, jmp L9>>

            Call 'KERNEL32.CreateFileA' iSaveFilter &GENERIC_WRITE,
                                        &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                        &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0
            If eax = &INVALID_HANDLE_VALUE

                Call MessageBox D$BusyFilePtr

ret

            Else
                Mov D$H.IDestination eax
            End_If

            Mov D$NumberOfReadBytes  0
            Call 'KERNEL32.WriteFile'   D$H.IDestination D$iExePtr D$iExeLen,
                                        NumberOfReadBytes  0
        .End_If

L9:
        Call VirtualFree iExePtr

        Call 'KERNEL32.CloseHandle' D$H.IDestination

    ..End_If

ret

 _______________________________________________________________________________________

 ; reading and writting .ico files:
 _______________________________________________________________________________________

[IcoFilePtr: D$ ?
 IcoFileLen: D$ ?]

[icoFilesFilters:  B$ 'icon files' EOS '*.ico' EOS 0]
[OpenIcoFileTitle: B$ 'Choose an icon file' EOS]

[icoOpenStruc: len
 icohwndFileOwner: 0  icohInstance:0  icoFilesFilters  iuFileFilter  &MAX_PATH
 iSourceFilterPtr  iSaveFilter  &MAX_PATH  iChoosenFile  &MAX_PATH  0
 OpenIcoFileTitle  IOSflags: 0281804 ; for read
 0  0  0  0  0]            ; 0280006 : for write  .ico



[BadFIsiz: B$ 'No 36/36 icon in this file (or too much colors)' EOS]

BadFIsize: Call MessageBox BadFIsiz

ret


ReadIcoFile:
  ; Opening a .ico file:

    Call ClearPATH iSaveFilter

    Mov D$IOSflags 0281804 | Call 'Comdlg32.GetOpenFileNameA' icoOpenStruc

    On D$iSaveFilter = 0  ret

  ; Loading the entire file in memory:

    Call 'KERNEL32.CreateFileA' iSaveFilter &GENERIC_READ, &FILE_SHARE_READ+&FILE_SHARE_WRITE,
                                0, &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
                                              ; hTemplateFile
    If eax = &INVALID_HANDLE_VALUE

      Call MessageBox D$BusyFilePtr

ret         ; return to caller of caller

    Else
      Mov D$H.ISource eax
    End_If

    Call 'KERNEL32.GetFileSize'  eax 0 | Mov D$icoFileLen eax

    Call VirtualAlloc icoFilePtr,
                      eax



    Call 'KERNEL32.ReadFile' D$H.ISource D$icoFilePtr,
                             eax NumberOfReadBytes 0

    Mov esi D$IcoFilePtr | add esi 4
    lodsw | movzx ecx ax                             ; icons number in ecx
L0: cmp B$esi 020 | je L1>                           ; first size
      add esi 16 | loop L0<                          ; next record
        jmp BadFIsize
L1: On D$esi+8 <> 02E8, jmp BadFIsize
    add esi 12                                       ; ptr to ico data
    Mov esi D$esi, edi iIcon, ecx 02E8
    add esi D$IcoFilePtr | rep movsb                 ; Copying to ower buffer

    Call 'KERNEL32.CloseHandle' D$H.ISource

    Call VirtualFree icoFilePtr

ret


[NewOnly: B$ 'This option saves only new files' EOS]

WriteIcoFile:
  ; Opening a .ico file:

    Call ClearPATH iSaveFilter

    Mov D$IOSflags 0288006 | Call 'Comdlg32.GetSaveFileNameA' icoOpenStruc

    On D$iSaveFilter = 0  ret

    Call 'KERNEL32.CreateFileA' iSaveFilter &GENERIC_WRITE, 0, 0,
                                &CREATE_NEW, &FILE_ATTRIBUTE_NORMAL, 0

    If eax = &INVALID_HANDLE_VALUE

      Call MessageBox eax NewOnly

ret  ; return to caller of caller

    Else
      Mov D$H.IDestination eax
    End_If

    Mov D$NumberOfReadBytes  0
    Call 'KERNEL32.WriteFile'   D$H.IDestination iIcoFileHeader 02FE,
                               NumberOfReadBytes  0
    Call 'KERNEL32.CloseHandle' D$H.IDestination
ret

 ____________________________________________________________________________________


; saving icon data in user stub data for effective compilation:

StoreIcon:
    Mov esi iIcon, edi uIcon, ecx 02E8 | rep movsb
ret

 ____________________________________________________________________________________
 ____________________________________________________________________________________

; Main of icon edition (dialog box Proc):

IconEdition:
    If D$H.IconEditor = 0
        Call 'USER32.DialogBoxIndirectParamA' D$H.Instance, IconDialogData, D$H.MainWindow,
                                              IconEditProc, 0
    Else
        Call Beep
    End_If
ret


[iDraw: D$ ?
 iArase: D$ ?]

[H.IconEditor: D$ ?]

Proc IconEditProc:
  Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    Move D$DrawIconMessage D@msg

    ...If D@msg = &WM_PAINT
        Call DrawIcon

    ...Else_If D@msg = &WM_VSCROLL
        Call iTrackMove

    ...Else_If D@msg = &WM_LBUTTONDOWN
        Mov B$iDraw &TRUE

    ...Else_If D@msg = &WM_LBUTTONUP
        Push D@Lparam | Pop W$MousePosX, W$MousePosY
        Mov B$idraw &FALSE | Call iLeft

    ...Else_If D@msg = &WM_RBUTTONDOWN
        Mov B$iArase &TRUE

    ...Else_If D@msg = &WM_RBUTTONUP
        Push D@Lparam | Pop W$MousePosX, W$MousePosY
        Mov B$iArase &FALSE | Call iRight

    ...Else_If D@msg = &WM_MOUSEMOVE
        Push D@Lparam | Pop W$MousePosX, W$MousePosY
        If B$iDraw = &TRUE
            Call iLeft
        Else_If B$iArase = &TRUE
            Call iRight
        End_If

    ...Else_If D@msg = &WM_COMMAND
        .If D@wParam = &IDCANCEL
            Mov D$H.IconEditor 0
            Call 'USER32.EndDialog' D@hwnd 0
        .Else_If D@wParam = ID_Inew
            Mov edi iIconAndMask, ecx 128, al 0FF | rep stosb
            Mov edi iIconXorMask, ecx 512, al 0   | rep stosb
            Call DrawIcon
        .Else_If D@wParam = ID_Ipeek
            Call PeekIcon | Call DrawIcon
        .Else_If D@wParam = ID_Ipoke
            Call PokeIcon
        .Else_If D@wParam = ID_IfromIco
            Call ReadIcoFile | Call DrawIcon
        .Else_If D@wParam = ID_ItoIco
            Call WriteIcoFile
        .Else_If D@wParam = ID_iKeep
            Move D$H.IconEditor 0
            Call StoreIcon | Call 'USER32.EndDialog' D@hwnd 0
        .Else_If D@wParam = ID_Help
            Call Help, B_U_AsmName, IconHelp, ContextHlpMessage
        .Else
            popad | Mov eax &FALSE | jmp L9>>
        .End_If

    ...Else_If D@msg = &WM_INITDIALOG
        Move D$H.IconEditor D@hwnd
        Move D$icohInstance D$H.Instance
        Move D$iOPESInstance D$H.Instance
        Move D$icohwndFileOwner D@hwnd
        Move D$ihwndPEFileOwner D@hwnd
        Call CreateIconBrushes
        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon

    ...Else_If D@msg = &WM_Close
        Mov D$H.IconEditor 0
        If B$OnRainbow = &TRUE
            Call RestorePreviousColor
            Call 'USER32.DestroyWindow' D$H.GreenSlider
            Call deleteRainbowDC
            Mov B$OnRainbow &FALSE
        End_If
        popad | Call DeleteIconBrushes | Mov eax &FALSE | jmp L9>

    ...Else
        popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE

L9: EndP
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE menu            ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;;
                                  Memus editor

'MenuEditProc'

 There are 2 types of menus for Win i use the newer (EX type) one, with MFT and
 MFS independant flags stored as dwords in Resources, plus ID dWord, plus PopUp
 and End Flags as Words.

 &MF_POPUP value is 010, but, in the Resources Word for this, this value is 01,
 what gives for LastPopUp, 081. As this 1 conflicts with &MF_GRAYED (01) or
 &MFS_GRAYED (3), the translation from 010 to 01 is only done when storing (and
 reverse when loading).

 As i use only one dWord per item to store all the various flags for the Editor
 internal use (MenuItemsFlags table).
;;
 _______________________________________________________________________________________
 _______________________________________________________________________________________


; 080=button / 081=Edit / 082=Static / 083=ListBox / 084=ScrollBar / 085=ComboBox


[MenuDialogData: D$ 090CC08C2 0        ; Style
 U$ 0B 0 0 0FC 0A8             ; Dim
 0                             ; Menu
 0                             ; Class
 'Menu Edition' 0               ; Title
 08 'Helv' 0]                      ; Font

; WS_BORDER|WS_TABSTOP|WS_HSCROLL|WS_VSCROLL| ES_WANTRETURN|ES_NOHIDESEL|ES_AUTOVSCROLL|ES_MULTILINE
[@MDD0000: D$ 050B01144 0       ; Style
 U$ 0 0 0FB 07D                ; Dim
 065                           ; ID
 0FFFF 081                     ; Class  > Edit Control
 '' 0                          ; Title
 0]                            ; No creation data

[@MDD0001: D$ 050000003 0      ; Style
 U$ 0 084 020 0B              ; Dim
 IDR_Grayed                           ; ID  06F
 0FFFF 080                     ; Class
 'Gray' 0                    ; Title
 0]                            ; No creation data

[@MDD0011: D$ 050000003 0      ; Style
 U$ 028 084 020 0B              ; Dim
 IDR_Checked                           ; ID  070
 0FFFF 080                     ; Class
 'Check' 0                   ; Title
 0]                            ; No creation data

[@MDD0111: D$ 050000009 0      ; Style
 U$ 050 084 020 0B              ; Dim
 IDR_Radio                           ; ID
 0FFFF 080                     ; Class
 'Radio' 0                      ; Title
 0]                            ; No creation data

[@MDD1111: D$ 050000003 0      ; Style
 U$ 078 084 020 0B              ; Dim
 IDR_Right                           ; ID
 0FFFF 080                     ; Class
 'Right' 0                      ; Title
 0]                            ; No creation data

[@MDD0002: D$ 050000000 0      ; Style
 U$ 01 098 033 010             ; Dim
 02                            ; ID
 0FFFF 080                     ; Class
 'Cancel' 0                    ; Title
 0]                            ; No creation data

[@MDD0003: D$ 050000000 0      ; Style
 U$ 035 098 033 010            ; Dim
 07B                           ; ID
 0FFFF 080                     ; Class
 'Help' 0                      ; Title
 0]                            ; No creation data

[@MDD0004: D$ 050000000 0      ; Style
 U$ 0C9 098 033 010            ; Dim
 01                            ; ID
 0FFFF 080                     ; Class
 'OK' 0                        ; Title
 0]                            ; No creation data

[@MDD0005: D$ 050000000 0      ; Style
 U$ 069 098 05F 010            ; Dim
 078                           ; ID
 0FFFF 080                     ; Class
 'Store Equates to ClipBoard' 0 ; Title
 0]                            ; No creation data

[@MDD0006: D$ 050802002 0      ; Style
 U$ 0C7 083 033 0C             ; Dim
 06E                           ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data

[@MDD0007: D$ 050000000 0      ; Style
 U$ 0A0 086 020 0B             ; Dim
 016E                           ; ID
 0FFFF 082                     ; Class
 'Id_Menu=' 0                ; Title
 0]                            ; No creation data

[ID_MenuEdit 065
 IDR_Radio 072
 IDR_Right 071
 IDR_Checked 070
 IDR_Grayed 06F
 ID_IDedit 06E
 ID_EquToClip 078  ID_MenuHelp 07B]

[H.Grayed: D$ ?
 H.Checked: D$ ?
 H.Right: D$ ?
 H.Radio: D$ ?]

[FirstMenuID: B$ ' 1000' EOS 0 0 0 0 0 0 0]
[H.MenuIDs: D$ ?]

[MENU_DWORDS 4000]

[eMenu: D$ ? # MENU_DWORDS]  ; temporary table for menu edition
[ceMenu: D$ ? # MENU_DWORDS] ; temporary table for menu edition control routine
[EndOfeMenu: D$ ?]

[H.MenuEdit: D$ ?]

[MenuEdition: B$ ? # 10000]
[MenuItemsFlags: D$ ? # 500 MenuItemsFlagsEnd:]
[IndexToMenuItemsFlags: D$ ?]

; MenuList, like 'DialogList', holds records for each menu to be used by
; 'TemporaryFillRsrcList' to prepare the Resource tree construction. Each record is:
; ID / Ptr / Size > 100 possible menus here:

 _________________________________

; These two basics routines are used for ID base holding (back and forth).
; Input dWord value in eax. Writes Ascii corresponding chain at edi:

[TenTable:  10000 1000  100  10  1 0]

TransDwordToAsciiDecimal:
    Mov ebx TenTable, ecx D$ebx, B$edi '0'
L0: cmp eax ecx | jb L1>
        sub eax ecx | inc B$edi | jmp L0<
L1: inc edi |  Mov B$edi '0' | add ebx 4 | Mov ecx D$ebx | cmp ecx 0 | ja L0<
    Mov B$edi 0
ret


[TranslateDwordToAscii | pushad | Push #1 | Pop eax | Push #2 | Pop edi
                                         Call TransDwordToAsciiDecimal | popad]

TransDecimalAsciiToDword:
    While B$esi = SPC
        inc esi
    End_While
    Mov ebx 0
L0: Mov eax 0
    lodsb | cmp al 0 | je L9>
    sub al '0' | shl ebx 1 | add eax ebx | shl ebx 2 | add ebx eax    ; (EBX * 10) + AL
        jmp L0<
L9: Mov eax ebx
ret

[TranslateAsciiToDword | Push #1 | Pop esi | Call TransDecimalAsciiToDword]
 _________________________________

;;
 Here, we read a resource menu and translate it in formated text for Edit Control and
 in a dWords table of flags (at MenuItemsFlags). Down there, 'StoreMenuEdition' does
 the reverse operation. 'eMenu' is the resource menu, including header. 'MenuEdition'
 is the text table to send to Edit Control.
;;

[uMenu_ID: 1000] [MenuTabsCount: D$ ?]

FillMenuEditData:
    Mov D$MenuTabsCount 0
    Mov esi eMenu, edi MenuEdition, ebx MenuItemsFlags
    add esi 8                                           ; skip header

L0: lodsd | Mov D$ebx eax                               ; MFT Flags
    lodsd | or D$ebx eax                                ; MFS Flags

    lodsd                                               ; jump over ID

    Mov eax 0 | lodsw                                   ; Pop Flags

    .If eax = PopUpFlag
        inc D$MenuTabsCount
        Mov eax &MF_POPUP
    .Else_If eax = LastPopUpFlag
        inc D$MenuTabsCount
        Mov eax &MF_POPUP__&MF_END
    .Else_If eax = LastItemFlag
        On D$MenuTabsCount > 0, dec D$MenuTabsCount
        Push ebx, eax
            sub ebx 4
            .While ebx > MenuItemsFlags
                Mov eax D$ebx | and eax POPMASK
                If eax = &MF_POPUP__&MF_END
                    On D$MenuTabsCount > 0, dec D$MenuTabsCount
                Else_If eax = &MF_POPUP
                   jmp L1>
                End_If
                sub ebx 4
            .End_While
L1:     Pop eax, ebx
        Mov eax &MF_END
    .End_If

    or D$ebx eax                                        ; All Flags

    lodsw                                               ; item first letter
    If ax = 0
      Mov ax 0A0D | stosw                               ; Separator
    Else
      Mov edx 0                                         ; simple counter for read alignement
L1:   stosb | inc edx
      lodsw | cmp ax 0 | jne L1<                        ; write item name
      Mov ax 0A0D | stosw                               ; end mark
      test edx 1 ZERO L2>
        lodsw                                           ; dWord align
L2:   test D$ebx &MF_POPUP ZERO L2>
        lodsd                                           ; + 1 dWord in case of popup
    End_If

L2: Mov ecx D$MenuTabsCount, al TAB
    while ecx > 0
        stosb | dec ecx
    End_While

    add ebx 4 | cmp esi D$EndOfeMenu | jb L0<<

; In case user hit some CR/LF at the end of menu items, some separators are added. This
; 'strip job' should be done at the end of 'StoreMenuEdition' but it is much more easier
; here, as some '0' analyzes are done here.

L8: cmp B$edi-1  SPC | jae L9>
      dec edi | jmp L8<

L9: On B$edi = 0FF, inc edi                          ; edge in case of empty menu
    Mov eax 0 | stosd                                   ; End mark


    Mov esi MenuItemsFlags
ret

____________________________________________________________________________________________

; &MF_POPUP 010   &MF_END 080  > but in resources >>> word value = popup = 1 (my equates)
;
; &MFS_GRAYED 3   &MFS_CHECKED 8   &MF_HELP 04000   &MF_POPUP 010  &MF_END 080
; (grayed=1 + disable=2)
;
; &MFT_MENUBARBREAK  020   &MFT_MENUBREAK 040   &MFT_OWNERDRAW 0100
; &MFT_RADIOCHECK 0200     &MFT_RIGHTJUSTIFY 04000

[MFSMASK 00_1111    MFTMASK 0_FFFF_FF00     POPMASK 090]

[GrayedFlag 2  PopUpFlag 1  LastPopUpFlag 081  ItemFlag 0  LastItemFlag 080]

[SelectionStart: D$ ?
 SelectionEnd: D$ ?
 MenuFlagEnable: D$ ?]


SetMenuItemFlag:
; When user double click on some item with possible spaces in it, we generalise
; one word selection to the whole item line (like in a List box):

    On B$OnMenuEdition = &FALSE, ret

    Call 'USER32.SendMessageA' D$H.MenuEdit &EM_GETSEL SelectionStart SelectionEnd
    Mov ebx D$SelectionStart, eax D$SelectionEnd | sub eax ebx | cmp eax 0 | je L8>>
    Call 'USER32.SendMessageA' D$H.MenuEdit &EM_LINEFROMCHAR D$SelectionStart 0
  ; eax > line number
    Call 'USER32.SendMessageA' D$H.MenuEdit &EM_LINEINDEX    eax   0
  ; eax > first line char
        Mov D$SelectionStart eax
    Call 'USER32.SendMessageA' D$H.MenuEdit &EM_LINELENGTH   eax   0
  ; eax > lenght
        add eax D$SelectionStart | Mov D$SelectionEnd eax
    Call 'USER32.SendMessageA' D$H.MenuEdit &EM_SETSEL D$SelectionStart D$SelectionEnd

; Now, set the according flags:

    .If B$MenuFlagEnable = &FALSE
        Call 'USER32.EnableWindow' D$H.Right &TRUE
        Call 'USER32.EnableWindow' D$H.Checked &TRUE
        Call 'USER32.EnableWindow' D$H.Grayed &TRUE
        Call 'USER32.EnableWindow' D$H.Radio &TRUE
        Call 'USER32.SendMessageA' D$H.Right &BM_SETCHECK 0 0
        Call 'USER32.SendMessageA' D$H.Checked &BM_SETCHECK 0 0
        Call 'USER32.SendMessageA' D$H.Grayed &BM_SETCHECK 0 0
        Call 'USER32.SendMessageA' D$H.Radio &BM_SETCHECK 0 0
        Mov B$MenuFlagEnable &TRUE

        Call 'USER32.SendMessageA' D$H.MenuEdit &EM_LINEFROMCHAR  D$SelectionStart 0
        shl eax 2 | Mov D$IndexToMenuItemsFlags eax
        Mov ebx MenuItemsFlags | add ebx eax | Mov eax D$ebx
        test eax &MFS_GRAYED ZERO L1>
            Push eax
                Call 'USER32.SendMessageA' D$H.Grayed &BM_SETCHECK 1 0
            Pop eax
L1:     test eax &MFS_CHECKED ZERO L1>
            Push eax
                Call 'USER32.SendMessageA' D$H.Checked &BM_SETCHECK 1 0
            Pop eax
L1:   test eax &MFT_RADIOCHECK ZERO L1>
            Push eax
                Call 'USER32.SendMessageA' D$H.Radio &BM_SETCHECK 1 0
            Pop eax
L1:   test eax &MFT_RIGHTJUSTIFY ZERO L9>>
            Push eax
                Call 'USER32.SendMessageA' D$H.Right &BM_SETCHECK 1 0
            Pop eax
    .End_If
    jmp L9>

; sleep:

L8: If B$MenuFlagEnable = &TRUE
        Call 'USER32.EnableWindow' D$H.Right &FALSE
        Call 'USER32.EnableWindow' D$H.Checked &FALSE
        Call 'USER32.EnableWindow' D$H.Grayed &FALSE
        Call 'USER32.EnableWindow' D$H.Radio &FALSE
        Mov B$MenuFlagEnable &FALSE
    End_If

L9: ret


[PreviousEditProc: D$ ?]

Proc InitMenuEdition:
    Argument @hwnd

    Call 'USER32.GetDlgItem' D@hwnd ID_MenuEdit
      Mov D$H.MenuEdit eax

  ; subClassing Edit control for TAB problem:
    Call 'USER32.SetWindowLongA' D$H.MenuEdit  &GWL_WNDPROC mEditProc
      Mov D$PreviousEditProc eax

  ; Limit edition of Equate number to 5 chars and set text at 1000:
    Call 'USER32.GetDlgItem' D@hwnd ID_IDedit
      Mov D$H.MenuIDs eax

    Call 'USER32.SendMessageA' eax  &EM_SETLIMITTEXT 5  0

    Call 'USER32.SendMessageA' D$H.MenuIDs  &WM_SETTEXT 0 FirstMenuID

  ; Disable all the CheckBoxes:
    Call 'USER32.GetDlgItem' D@hwnd IDR_Grayed | Mov D$H.Grayed eax
    Call 'USER32.EnableWindow' D$H.Grayed &FALSE
    Call 'USER32.GetDlgItem' D@hwnd IDR_Checked | Mov D$H.Checked eax
    Call 'USER32.EnableWindow' D$H.Checked &FALSE
    Call 'USER32.GetDlgItem' D@hwnd IDR_Right | Mov D$H.Right eax
    Call 'USER32.EnableWindow' D$H.Right &FALSE
    Call 'USER32.GetDlgItem' D@hwnd IDR_Radio | Mov D$H.Radio eax
    Call 'USER32.EnableWindow' D$H.Radio &FALSE
Endp

____________________________________________________________________________________________

[OneItemString: D$ 160 ]

GetuMenuID:
    Call 'USER32.SendMessageA' D$H.MenuIDs &WM_GETTEXTLENGTH 0 0 | inc eax
    Call 'USER32.SendMessageA' D$H.MenuIDs &WM_GETTEXT eax FirstMenuID
    TranslateAsciiToDword FirstMenuID
    Mov D$FirstMenuId 0                           ; just for abort tests in callers:
    If eax > 32000                                ; 'StoreMenuEdition' / 'MenuEditProc'

      Call MessageBox D$IdTooBigPtr

      Mov D$FirstMenuId 0

ret

    Else_If eax < 1   ;000

      Call MessageBox D$IdTooSmallPtr

      Mov D$FirstMenuId 0

ret

    End_If
    Mov D$uMenu_ID eax
    inc eax | Mov D$FirstMenuId eax
ret

____________________________________________________________________________________________

@EM_GETLINE_Comment:

;;
  EM_GETLINE Message, when applied to a Multi-Lines Edit Control, may fills the Destination
  Buffer with additional corrupted Characters. This seems to happend when a Logitech
  Mouse-Wheel Driver has been installed on the Computer (intellimouse 1.2a (Microsoft) 2 
  buttons + wheel // Win 2000).
  
  Hopefully, the (eax) Return Value, saying the number of written Chars seems good. This is 
  why i add this:
  
  > Mov B$Destination+eax 0
  
  after retrieving a Line by EM_GETLINE Message.
;;




; Here, we save user definition for menu edition. We read Edit Control text and the
; flags table (at MenuItemsFlags). We write at 'eMenu:' a true resource conventional
; menu. Up there, 'FillMenuEditData' does the reverse operation.

[SeparatorsNumber: D$ ?
 PopUpNumber: D$ ?]

StoreMenuEdition:
    Call GetuMenuID | On D$FirstMenuId = 0, ret
   ; "EM_GETLINECOUNT" returns 1 if empty; so, ...:
    Call 'USER32.SendMessageA' D$H.MenuEdit, &EM_GETLINE, 0, OneItemString
    Mov B$OneItemString+eax 0  ; >>> 'EM_GETLINE_Comment'

    If eax = 0
        Mov D$FirstMenuId 0 | ret
    End_If

    Mov edi eMenu, ecx MENU_DWORDS, eax 0 | rep stosd

    Call 'USER32.SendMessageA' D$H.MenuEdit, &EM_GETLINECOUNT, 0, 0

    Mov ecx eax, ebx MenuItemsFlags, edi eMenu, edx 0
    Mov D$SeparatorsNumber 0, D$PopUpNumber 0
    Mov ax 1 | stosw | Mov ax 4 | stosw | Mov eax 0 | stosd     ; header (8 bytes)
L0: pushad
T0:     Mov eax 0, edi OneItemString, ecx 40 | rep stosd        ; GETLINE not zero-ended
        Mov W$OneItemString 160                                 ; max write for GETLINE
        Call 'USER32.SendMessageA' D$H.MenuEdit, &EM_GETLINE, edx, OneItemString
      ; Copied Line may be corrupted at the end with some weird Drivers on Board:
        Mov B$OneItemString+eax 0  ; >>> 'EM_GETLINE_Comment'

        On eax = 0, jmp T1>
        Mov esi OneItemString
        While B$esi = TAB
            inc esi | dec eax                                   ; no header tabs in chars count
        End_While
        On B$esi = 0 , Mov eax 0
        .If eax = 0
T1:         popad
                Mov eax 0 | stosd | stosd | stosd | stosd       ; Separator = 16 zero bytes
                inc edx | inc D$SeparatorsNumber | add ebx 4
                If edx < ecx
                    pushad | jmp T0<<
                Else
                    jmp L9>>
                End_If
        .End_If
    popad

    Mov eax D$ebx | and eax MFTMASK | stosd

    Mov eax D$ebx | and eax MFSMASK | stosd

    Mov eax D$FirstMenuID | add eax edx
    sub eax D$SeparatorsNumber
    sub eax D$PopUpNumber
    test D$ebx &MF_POPUP ZERO F0>
        inc D$PopUpNumber | Mov eax 0                          ; No ID for PopUp
F0: stosd                                                      ; ID number
    Mov eax D$ebx | and eax POPMASK
    If eax = &MF_POPUP
        Mov eax PopUpFlag
    Else_If eax = &MF_POPUP__&MF_END
        Mov eax LastPopUpFlag
    Else_If eax = &MF_END
        Mov eax LastItemFlag
    End_If
    stosw | Mov esi OneItemString

    Push ecx
        Mov ecx 0, eax 0                                      ; align counter
        While B$esi < SPC
           lodsb                                              ; clear tabs if any
        End_While
L1:     lodsb | stosw | inc ecx | cmp al 0 | ja L1<           ; name
        test ecx 1 NOT_ZERO L2>
          stosw                                               ; align
L2: Pop ecx
    test D$ebx &MF_POPUP ZERO L3>
        stosd                                                 ; PopUp padding

L3: inc edx | add ebx 4 | cmp edx ecx | jb L0<<

L9: Mov eax 0 | stosd | stosd

    Mov D$EndOfeMenu edi, eax &TRUE
ret


PackMenuInList:
    Mov eax D$MenuListPtr | add eax 4
    Push eax
        Mov edi D$MenuListPtr | Mov eax D$uMenu_ID | stosd  ; ID

        Push edi

            Mov eax D$EndOfeMenu | sub eax eMenu | inc eax ; !!! TODO Lp +01 !!! -> 0_4_0001 !!!

            Push eax

                Call VirtualAlloc TempoMemPointer,
                                  eax            ; New memory

                Mov ebx D$TempoMemPointer, eax ebx

            Pop ecx

        Pop edi

        stosd                                               ; Ptr (eax from 'AskMem')
        Mov eax ecx                                         ; Size
        stosd
        Mov esi eMenu, edi ebx | rep movsb                  ; store
    Pop eax
  ;  Call FreeMemory                                        ; release previous Listed memory
ret


; Here, we save Memu IDs Equates in CiplBoard 'WriteClipIDvalue' is a SubRoutine of
; 'ClipEquates'

[DataForClipEquates: D$ ? # 1000]
[StartOfItemsLine: D$ ?]

WriteClipIDvalue:
    Mov ax '  ' | stosw
    Mov eax D$FirstMenuID | add eax edx
    sub eax D$SeparatorsNumber | sub eax D$PopUpNumber

    Push ecx
    ; adapted version of 'TransDwordToAsciiDecimal' for ID number:
      Mov ebx TenTable, ecx D$ebx, B$edi '0'
L1:   cmp eax ecx | jae L2>
            add ebx 4 | Mov ecx D$ebx | jmp L1<
L2:   cmp eax ecx | jb L3>
            sub eax ecx | inc B$edi | jmp L2<
L3:   inc edi |  Mov B$edi '0' | add ebx 4 | Mov ecx D$ebx | cmp ecx 0 | ja L2<

      Mov ecx edi | sub ecx D$StartOfItemsLine        ; align items text (3 per line):
      If ecx > 64                                     ; 32 chars each
            Mov ax 0A0D | stosw | Mov al SPC | stosb
            Mov D$StartOfItemsLine edi
      Else
            Mov al SPC | and ecx 00_11111 | xor ecx 00_11111 | inc ecx | rep stosb
      End_If
    Pop ecx


ret

____________________________________________________________________________________________

[MenuEquateIndice: D$ 'M00_']

ClipEquates:
    Mov D$MenuEquateIndice 'M00_'
    Mov eax D$MenulistPtr | sub eax MenuList
    Mov ebx 12, edx 0 | div ebx                 ; > indice = 0, 1, 2, ...
    Mov ebx 10, edx 0 | div ebx
    add B$MenuEquateIndice+2 dl
    Mov edx 0 | div ebx
    add B$MenuEquateIndice+1 dl

    Call GetuMenuID
    Call 'USER32.SendMessageA' D$H.MenuEdit &EM_GETLINECOUNT 0 0
    Mov ecx eax, edi DataForClipEquates, edx 0, D$SeparatorsNumber 0, D$PopUpNumber 0
    Mov al '[' | stosb | Mov D$StartOfItemsLine edi

    Mov eax D$MenuEquateIndice | stosd | Mov eax 'Menu' | stosd
    dec D$FirstMenuID | Call WriteClipIDvalue | inc D$FirstMenuID

L0:
L1: Push edi, ecx
        Mov eax 0, edi OneItemString, ecx 40 | rep stosd        ; GETLINE not zero-ended
    Pop ecx, edi
    Mov W$OneItemString 160                                 ; max write for GETLINE
    pushad
        Call 'USER32.SendMessageA' D$H.MenuEdit, &EM_GETLINE, edx, OneItemString
        Mov B$OneItemString+eax 0  ; >>> 'EM_GETLINE_Comment'
    popad
    Mov esi OneItemString
    While B$esi = TAB
        inc esi
    End_While
    If B$esi = 0
        inc D$SeparatorsNumber | inc edx | cmp edx ecx | je L9>>   ; No Separators
            jmp L1<<
    End_If
    Mov eax D$MenuItemsFlags+edx*4 | test eax &MF_POPUP ZERO T0>   ; No Popup  ; PopUpFlag
    inc D$PopUpNumber | inc edx | jmp L1<<

T0: Mov esi OneItemString, eax 0, eax D$MenuEquateIndice | stosd
    While B$esi <= SPC
        lodsb                                           ; strip leading tabs and spaces
    End_While

L3: lodsb | cmp al 0 | je L4>
       ; On al = SPC, Mov al '_'                         ; link separates words
        On al = '&', jmp L3<                            ; do not write '&'
        On al = TAB  , jmp L4>                          ; do not write 'hot keys'
        On al < '0', Mov al '_'
        If al = '_'
            On B$edi-1 = '_', jmp L3<                   ; only one '_' at a time
        End_If

        stosb | jmp L3<                                 ; name Char writing

L4: Call WriteClipIDvalue

    inc edx | cmp edx ecx | jb L0<<

L9: dec edi | cmp B$edi SPC | jbe L9<                   ; suppress lasting spaces / CR/LF
    inc edi | Mov al ']' | stosb | Mov al 0 | stosb     ; and close Bracket

    dec edi                                             ; reuse 'ControlC' for clip:

    Push D$LP.BlockStartText,
         D$LP.BlockEndText,
         D$FL.BlockInside

        Mov D$LP.BlockStartText DataForClipEquates,
            D$LP.BlockEndText edi

        Mov D$FL.BlockInside &TRUE | Call ControlC

    Pop D$FL.BlockInside,
        D$LP.BlockEndText,
        D$LP.BlockStartText
ret
____________________________________________________________________________________________
; As i get no end problems with this damned Edit Controls when i need to know if there
; are some ending CR/LF or not at the end, i get the text, strip the CR/LF, reset the
; text:

[LenOfMenuText: D$ ?
 TempoMenuTextPtr: D$ ?]

CleanMenuEnd:
    Call 'USER32.SendMessageA' D$H.MenuEdit &WM_GETTEXTLENGTH 0 0
    inc eax | Mov D$LenOfMenuText eax

    Call VirtualAlloc TempoMenuTextPtr,
                      eax

    Call 'USER32.SendMessageA' D$H.MenuEdit, &WM_GETTEXT, eax,
                               D$TempoMenuTextPtr

    Mov esi D$TempoMenuTextPtr

    If D$esi = 0

L1:
        Call VirtualFree TempoMenuTextPtr

        Mov eax &FALSE
ret

    End_If

    add esi D$LenOfMenuText | Mov D$esi+1 0
    While B$esi <= SPC
        Mov B$esi 0 | dec esi | cmp esi D$TempoMenuTextPtr | jb L1<
    End_While
    Call 'USER32.SendMessageA' D$H.MenuEdit &WM_SETTEXT 0 D$TempoMenuTextPtr

    Call VirtualFree TempoMenuTextPtr

    Mov eax &TRUE

ret

____________________________________________________________________________________________
; Here, we set the menu organisation flags (Item / LasItem / PopUp / LastPopUp)
; We use the number of leading tabs to retrieve the tree.

[MAXMENUTABS 500]

[MenuItemTabsList: B$ ? # MAXMENUTABS]
[MenuItemTabsListPtr: D$ ?]

StoreMenuPopFlags:
    Mov D$MenuItemTabsListPtr MenuItemTabsList

    Call 'USER32.SendMessageA' D$H.MenuEdit, &EM_GETLINE, 0, OneItemString
    Mov B$OneItemString+eax 0  ; >>> 'EM_GETLINE_Comment'

    On eax = 0, ret

    Call 'USER32.SendMessageA' D$H.MenuEdit, &EM_GETLINECOUNT, 0, 0

    Mov ecx eax, edx 0

L0: pushad
      Mov eax 0, edi OneItemString, ecx 40 | rep stosd       ; GETLINE not zero-ended
      Mov W$OneItemString 160                                ; max write for GETLINE

      Call 'USER32.SendMessageA' D$H.MenuEdit, &EM_GETLINE, edx, OneItemString
      Mov B$OneItemString+eax 0  ; >>> 'EM_GETLINE_Comment'

      Mov esi OneItemString, edi D$MenuItemTabsListPtr, B$edi 1

      .If eax > 0
          While B$esi = TAB
             lodsb | inc B$edi
          End_While
      .End_If
    popad

    inc D$MenuItemTabsListPtr | inc edx | cmp edx ecx | jb L0<<

    Mov edi D$MenuItemTabsListPtr, D$edi 0

    ; Now, set the Flags in MenuItemsFlags:

    Mov esi MenuItemTabsList, edi MenuItemsFlags

    .While B$esi > 0
        lodsb
        .If al > B$esi
            Mov eax &MF_END
        .Else_If al = B$esi
            Mov eax 0
        .Else
            Push esi
                While B$esi > al
                    inc esi
                End_While
                If B$esi < al
                    Mov eax &MF_POPUP__&MF_END
                Else
                    Mov eax &MF_POPUP
                End_If
            Pop esi
       .End_If
       or D$edi POPMASK | xor D$edi POPMASK | or D$edi eax
       add edi 4
    .End_While
ret


Beep:

    pushad

        Call 'USER32.MessageBeep' &MB_ICONHAND

    popad

ret

;;
0xFFFFFFFF Standard beep using the computer speaker
&MB_ICONASTERISK SystemAsterisk
&MB_ICONEXCLAMATION SystemExclamation
&MB_ICONHAND SystemHand
&MB_ICONQUESTION SystemQuestion
&MB_OK SystemDefault
;;

[ClickMessage: D$ ?
 OnMenuEdition: D$ ?
 H.MenuEditor: D$ ?]

Proc MenuEditProc:

    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    Mov eax D@wParam | shr eax 16 | Mov D$ClickMessage eax

    If D@msg = &WM_CTLCOLOREDIT
        Call SetMenuItemFlag | Mov B$OnMenuEdition &TRUE
    End_If

    ...If D@msg = &WM_COMMAND
        Mov eax D@lParam
        .If eax = D$H.MenuEdit
            Mov eax D@wParam | shr eax 16
            If eax = &EN_CHANGE
                Call MenuLinesControl | popad | Mov eax &TRUE | jmp L9>>
            End_If
        .End_If

        ..If D@wParam = &IDCANCEL
            Mov B$OnMenuEdition &FALSE, D$H.MenuEditor 0
            Call 'USER32.EndDialog' D@hwnd 0

        ..Else_If D@wParam = &IDOK
            Call CleanMenuEnd
            If eax = &FALSE
                Mov D$H.MenuEditor 0 | Call 'USER32.EndDialog' D@hwnd 0
            End_If
            Call StoreMenuPopFlags | Call StoreMenuEdition
            If D$FirstMenuId <> 0
                Call PackMenuInList
                Mov B$OnMenuEdition &FALSE, D$H.MenuEditor 0
                Call 'USER32.EndDialog' D@hwnd 0
            End_If

      ..Else_If D@wParam = ID_EquToClip
            Call CleanMenuEnd
            If eax = &TRUE
                Call StoreMenuPopFlags
                Call StoreMenuEdition
                On D$FirstMenuId <> 0, Call ClipEquates
            End_If

            On B$TagedEdition = &TRUE, Mov B$TagedEdition 0-1

      ..Else_If D@wParam = ID_MenuHelp
            Call Help, B_U_AsmName, MenuHelp, ContextHlpMessage

      ..Else_If D$ClickMessage = &BN_CLICKED
            Mov eax D@lParam, ebx MenuItemsFlags               ; D$lParam = from what
            add ebx D$IndexToMenuItemsFlags

            If eax = D$H.Grayed
                xor D$ebx &MFS_GRAYED
            Else_If eax = D$H.Checked
               xor D$ebx &MFS_CHECKED
            Else_If eax = D$H.Right
               xor D$ebx &MFT_RIGHTJUSTIFY
            Else_If eax = D$H.Radio
                xor D$ebx &MFT_RADIOCHECK
            End_If

      ..Else
            jmp L8>>

      ..End_If

    ...Else_If D@msg = &WM_INITDIALOG
        Call FillMenuEditData | Call InitMenuEdition D@hwnd
        Call 'USER32.SetDlgItemTextA' D@hwnd, 065, MenuEdition
        Call 'USER32.SendMessageA' D$H.MenuEdit, &EM_GETLINECOUNT, 0, 0
        Mov D$NumberOfMenuLines eax
            Call MenuLinesControl
        Move D$H.MenuEditor D@hwnd
        Call 'USER32.SetClassLongA' D@hwnd, &GCL_HICON, D$STRUC.WINDOWCLASS@hIcon

        If B$TagedEdition = &TRUE
            Call 'USER32.SendDlgItemMessageA' D@hwnd, ID_EquToClip,
                                              &WM_SETTEXT, 0, {B$ 'Replace in Source' EOS}
        End_If

    ...Else_If D@msg = &WM_CTLCOLOREDIT
        Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>

    ...Else
L8:   popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE

L9: EndP



NewMenu:
    Mov esi MenuList                               ; (ID / Ptr / Size)
    While D$esi+MEM_LP > 0
        Mov eax D$esi+MEM_LP | add esi MEM_RECORD
    End_While

    Mov D$MenuListPtr esi

    If esi = MenuList
        Mov eax 1000
    Else
        add eax 1000
    End_If
    Mov D$uMenu_ID eax
    Mov ebx 10, edi FirstMenuID | add edi 5
L0: Mov edx 0 | div ebx
    dec edi | add dl '0' | Mov B$edi dl | cmp edi FirstMenuID | ja L0<
    While B$edi = '0'
        Mov B$edi SPC | inc edi
    End_While

    Mov eax 0, ecx MENU_DWORDS, edi eMenu | rep stosd     ; clear temporary table
    Mov D$EndOfeMenu eMenu

    Call MenuEditor
ret


SaveMenuBinaryFile:
  ; Prevent from Multiple Instances:
    If B$OnMenuEdition = &TRUE
        Call Beep | ret
    End_If

    Mov D$MenuListPtr MenuList,  B$UserTellWhatMenu &FALSE
    While B$UserTellWhatMenu = &FALSE
        Call WhatMenu
    End_While
    On D$MenuListPtr = 0, ret

    Mov edi SaveFilter, eax 0, ecx 65 | rep stosd
    Mov D$SaveDlgFilter 'New.', D$SaveDlgFilter+3 '.bmf', D$SaveDlgFilter+7 0

    Call 'Comdlg32.GetSaveFileNameA' OpenDlg | On eax = &FALSE, ret

    Call ForceExtension SaveDlgFilter, '.bmf'

    Call 'KERNEL32.CreateFileA' SaveDlgFilter &GENERIC_WRITE,
                               &FILE_SHARE_READ__&FILE_SHARE_WRITE, 0,
                               &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0

    If eax = &INVALID_HANDLE_VALUE

        Call MessageBox D$BusyFilePtr

ret

    End_If

    Mov D$H.Destination eax, D$NumberOfReadBytes 0

    Mov esi D$MenuListPtr | Mov ecx D$esi+8, esi D$esi+4

    Call 'KERNEL32.WriteFile' D$H.Destination, esi, ecx, NumberOfReadBytes  0

    Call 'KERNEL32.CloseHandle' D$H.Destination | Mov D$H.Destination 0
ret


[BinMenuMemory: D$ ?
 BinMenuLength: D$ ?]

LoadMenuBinaryFile:
    If B$OnMenuEdition = &TRUE
        Call Beep | ret
    End_If

    Mov D$OtherFilesFilters BinMenuFilesFilters
    Mov D$OpenOtherFileTitle DialogFilesTitle

    Move D$OtherhwndFileOwner D$H.MainWindow, D$OtherhInstance D$H.Instance

    Mov edi OtherSaveFilter, ecx 260, eax 0 | rep stosd
    Call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc

    On D$OtherSaveFilter = 0, ret

    Call 'KERNEL32.CreateFileA' OtherSaveFilter &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE

      Call MessageBox D$BusyFilePtr

ret  ; return to caller of caller

    Else
      Mov D$H.OtherSource eax
    End_If

    Call 'KERNEL32.GetFileSize' eax, 0 | Mov D$BinMenuLength eax

    If eax > 0

        Call VirtualAlloc BinMenuMemory,
                          eax


        Call 'KERNEL32.ReadFile' D$H.OtherSource, D$BinMenuMemory,
                                 eax, NumberOfReadBytes, 0
    Else

ret

    End_If

    Call 'KERNEL32.CloseHandle' D$H.OtherSource

    Mov esi MenuList | While D$esi+MEM_LP <> 0 | add esi MEM_RECORD | End_While
    Mov eax D$esi-MEM_RECORD | add eax 1000 | Mov D$esi+MEM_LP eax
    Mov eax D$BinMenuMemory, D$esi+MEM_CHUNK_SIZE eax
    Mov eax D$BinMenuLength, D$esi+MEM_MOTHER_LP eax

ret


ReplaceMenuBinaryFile:
    If B$OnMenuEdition = &TRUE
        Call Beep | ret
    End_If

    Mov D$MenuListPtr MenuList,  B$UserTellWhatMenu &FALSE
    While B$UserTellWhatMenu = &FALSE
        Call WhatMenu
    End_While
    On D$MenuListPtr = 0, ret

    Mov D$OtherFilesFilters BinMenuFilesFilters
    Mov D$OpenOtherFileTitle DialogFilesTitle

    Move D$OtherhwndFileOwner D$H.MainWindow, D$OtherhInstance D$H.Instance

    Mov edi OtherSaveFilter, ecx &MAX_PATH, eax 0 | rep stosd
    Call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc

    On D$OtherSaveFilter = 0, ret

    Call 'KERNEL32.CreateFileA' OtherSaveFilter &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE

      Call MessageBox D$BusyFilePtr

ret  ; return to caller of caller

    Else
      Mov D$H.OtherSource eax
    End_If

    Call 'KERNEL32.GetFileSize' eax, 0 | Mov D$BinMenuLength eax

    If eax > 0

        Call VirtualAlloc BinMenuMemory,
                          eax


        Call 'KERNEL32.ReadFile' D$H.OtherSource, D$BinMenuMemory,
                                 eax, NumberOfReadBytes, 0
    Else
        ret
    End_If

    Call 'KERNEL32.CloseHandle' D$H.OtherSource

    Mov esi D$MenuListPtr

  ;  lea eax D$esi+4

    Call VirtualFree D$esi+MEM_LP ; eax

    Mov eax D$BinMenuMemory, D$esi+4 eax
    Mov eax D$BinMenuLength, D$esi+8 eax
ret


MenuEditor:
    If D$H.MenuEditor = 0
        Call 'USER32.DialogBoxIndirectParamA' D$H.Instance, MenuDialogData, D$H.MainWindow,
                                              MenuEditProc, 0
    Else
        Call Beep
    End_If
ret


[NoResourceMenu: B$ '   There is no Menu in Resources    ' EOS]
[UserTellWhatMenu: D$ ?]

ExistingMenu:
    Mov esi MenuList                                ; (ID / Ptr / Size)
    If D$esi = 0
       Call 'USER32.MessageBoxA' D$H.MainWindow, NoResourceMenu, Argh,
                                 &MB_ICONINFORMATION+&MB_SYSTEMMODAL
       ret
    Else_If D$esi+12 = 0
      Mov D$MenuListPtr MenuList
    Else
      Mov D$MenuListPtr MenuList,  B$UserTellWhatMenu &FALSE
      While B$UserTellWhatMenu = &FALSE
        Call WhatMenu
      End_While

      On D$MenuListPtr = 0, ret
    End_If

    ; MenuListPtr > choosen or alone menu

ReEditExistingMenu:

    Mov esi D$MenuListPtr
    lodsd | Mov D$uMenu_ID eax
      Mov ebx 10, edi FirstMenuID | add edi 5
L0:     Mov edx 0 | div ebx
          dec edi | add dl '0' | Mov B$edi dl | cmp edi FirstMenuID | ja L0<
          While B$edi = '0'
            Mov B$edi SPC | inc edi
          End_While
    lodsd | Mov ebx eax                           ; Ptr
    lodsd | Mov ecx eax                           ; Size
    Mov esi ebx, edi eMenu | rep movsb
    Mov D$EndOfeMenu edi

    Call MenuEditor
ret


[DelteMenuQuestion: B$ 'Suppress choosen Menu from resources?' EOS]
[Sure: B$ 'Are you sure...' EOS]

DeleteMenu:
    Mov esi MenuList                                ; (ID / Ptr / Size)

    If D$esi = 0
       Call 'USER32.MessageBoxA' D$H.MainWindow, NoResourceMenu, Argh,
                                 &MB_ICONINFORMATION+&MB_SYSTEMMODAL
       ret
    Else
        Mov D$MenuListPtr MenuList,  B$UserTellWhatMenu &FALSE
        While B$UserTellWhatMenu = &FALSE
            Call WhatMenu
        End_While

        On D$MenuListPtr = 0, ret
    End_If

    Call 'USER32.MessageBoxA' D$H.MainWindow, DelteMenuQuestion, Sure,
                             &MB_ICONQUESTION+&MB_SYSTEMMODAL+&MB_YESNO
   .If eax = &IDYES
        Call VerifyNotDialogMenu
        If B$CancelDeleteMenu = &FALSE
            Mov esi D$MenuListPtr, edi esi | add esi 12
            Mov ecx MAXMENU, eax esi | sub eax MenuList | sub ecx eax
            rep movsd
        End_If
   .End_If
ret


; User asked for delete a menu. If the menu is used by a Dialog we must ajust the Dialog
; data if user persist:

[CancelDeleteMenu: D$ ?]

VerifyNotDialogMenu:
    Mov B$CancelDeleteMenu &FALSE
    Mov ecx 0, edx D$MenuListPtr, edx D$edx                  ; whished delete Menu ID
    Mov esi DialogList | add esi 4 | Mov D$DialogListPtr esi

    While D$esi > 0
      Mov ebx D$DialogListPtr | Mov ebx D$ebx    ; ebx > DialogData > menu (0 / 0FFFF)
      Mov ax W$ebx+18

      .If ax = 0FFFF                             ; (see ex.: EditedDialogBoxData)
         Mov ax W$ebx+20                         ; Menu ID
         If ax = dx
           Call 'USER32.DialogBoxIndirectParamA' D$H.Instance DelMenuDialog D$H.MainWindow,
                                                DelDialogMenuProc 0
           On B$CancelDeleteMenu = &TRUE, ret
         End_If
      .End_If

      add D$DialogListPtr 12 | Mov esi D$DialogListPtr
    End_While
ret


Proc DelDialogMenuProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_COMMAND

        .If D@wParam = &IDCANCEL
            Mov D$CancelDeleteMenu &TRUE | Call 'USER32.EndDialog' D@hwnd 0

        .Else_If D@wParam = &IDOK
            Mov edi D$DialogListPtr, edi D$edi, eax 0   ; scratch menu record in Dialog Data:
            add edi 18 | stosw                          ; replace 0FFFF by 0
            Mov esi edi | add esi 2                     ; (see ex: EditedDialogBoxData)

          ; We can't copy simply, because of alignement to reset before first control.
            If W$esi = 0                                ; copy Class record
                movsw
            Else_If W$esi = 0FFFF
                movsd
            Else
                While W$esi <> 0 | movsw | End_While | movsw
            End_If

            If W$esi = 0                                ; copy Title record
                movsw
            Else
                While W$esi <> 0 | movsw | End_While | movsw
            End_If

            While W$esi <> 0 | movsw | End_While | movsw; we have strip one Word >

; If aligment is good now , it was not previously and had require the add of a zeroed word
            Test edi 00_111 ZERO L1>
                Mov eax 0 | stosw | jmp L2>

L1:         add esi 2

          ; copy remaining controls:
L2:         Mov eax D$DialogListPtr                     ; > List recorded lenght of Dialog data
            add eax 4 | Mov ecx D$eax                   ; lenght of data do NOT change
            sub ecx 26 | rep movsb                      ; 'about...'

            Call 'USER32.EndDialog' D@hwnd, 0
        .End_If

    ...Else_If D@msg = &WM_INITDIALOG
        Call 'USER32.SetClassLongA' D@hwnd, &GCL_HICON, D$STRUC.WINDOWCLASS@hIcon

    ...Else
        popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE

L9: EndP


[DelMenuDialog: D$ 090C408C2 0 ; Style
 U$ 03 0 0 09C 042             ; Dim  8c
 0                             ; no Menu
 0                             ; Class(not yet)
 'Delete Dialog Menu???...' 0  ; Title
 08 'Helv' 0]                  ; Font

[@DMD0: D$ 050000000 0          ; Style
 U$ 014 015 0100 018           ; Dim
 022B                          ; ID
 0FFFF 082                     ; Class
 'This Menu is used by one or more Dialog(s).' 0 ; Title
 0]                            ; No creation data

[@DMD1: D$ 050000000 0          ; Style
 U$ 02 02D 038 013             ; Dim
 02                            ; ID
 0FFFF 080                     ; Class
 'Abort' 0                     ; Title
 0]                            ; No creation data

[@DMD2: D$ 050000000 0          ; Style
 U$ 03C 02D 04D 013            ; Dim
 01                            ; ID
 0FFFF 080                     ; Class
 'Delete in Dialog too' 0      ; Title
 0]                            ; No creation data

____________________________________________________________


[@WhatMenuData: D$ 090CC08C2 0  ; Style
 U$ 04 0 0 01F9 080            ; Dim 88 > 80
 0                             ; Menu
 0                             ; Class(not yet)
 'WhatMenu Dialog' 0           ; Title
 08 'Helv' 0]                  ; Font

[@WMD0000: D$ 050000000 0       ; Style
 U$ 0 060 044 013              ; Dim
 064                           ; ID
 0FFFF 080                     ; Class
 '<<<<' 0                      ; Title
 0]                            ; No creation data

[@WMD0001: D$ 050000000 0       ; Style
 U$ 0167 060 091 014           ; Dim
 01                            ; IDOK
 0FFFF 080                     ; Class
 'Yeah! This is this one i was searching!' 0 ; Title
 0]                            ; No creation data

[@WMD0002: D$ 050000000 0       ; Style
 U$ 046 060 047 013            ; Dim
 065                           ; ID
 0FFFF 080                     ; Class
 '>>>>' 0                      ; Title
 0]                            ; No creation data

[@WMD0003: D$ 050000000 0       ; Style
 U$ 0B0 060 0B5 014            ; Dim 60 > 90 > 75
 02                            ; IDCancel
 0FFFF 080                     ; Class
 "I don't find it. Maybe i've lost it, i am so stupid..." EOS ; Title
 0]                            ; No creation data

 [IDNextMenu 3  IDPreviousMenu 4]


WhatMenu:
    Call 'USER32.DialogBoxParamA' D$H.Instance, 500, D$H.MainWindow, WhatMenuProc, 0
ret


[ActualMenutestID: D$ ?]

; Tag Dialog 500

Proc WhatMenuProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_COMMAND

        .If D@wParam = &IDCANCEL
            Mov D$MenuListPtr 0, B$UserTellWhatMenu &TRUE
            Call 'USER32.EndDialog' D@hwnd 0

        .Else_If D@wParam = &IDOK
            Mov B$UserTellWhatMenu &TRUE
            Call 'USER32.EndDialog' D@hwnd 0

        .Else_If D@wParam = IDNextMenu
            Mov ebx D$MenuListPtr | add ebx 12
            If D$ebx > 0
                Mov D$MenuListPtr ebx | Call SetTestMenu D@hwnd
                Call 'USER32.EndDialog' D@hwnd 0
            End_If

        .Else_If D@wParam = IDPreviousMenu
            Mov ebx D$MenuListPtr | sub ebx 12
            If ebx >= MenuList
            Mov D$MenuListPtr ebx
            Call 'USER32.DestroyMenu' D$ActualMenutestID
            Call SetTestMenu D@hwnd
            Call 'USER32.EndDialog' D@hwnd 0
            End_If

        .End_If

    ...Else_If D@msg = &WM_INITDIALOG
        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        Call SetTestMenu D@hwnd

    ...Else
L8:     popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE

L9: EndP


Proc SetTestMenu:
    Argument @hwnd

      Mov eax D$MenuListPtr | add eax 4
      Call 'USER32.LoadMenuIndirectA' D$eax
      Mov D$ActualMenutestID eax
      Call 'USER32.SetMenu' D@hwnd eax
EndP


; We associate each user edited line for menu with a table of flag. In case user suppress
; or add one line, we have to ajust the flag table:

; Copy whole user edition to "eMenu" (reuse of final storage area):

MenuCopy:
    Mov edx 0, edi ceMenu, eax 0, ecx MENU_DWORDS | rep stosd
    Mov edi ceMenu
    While edx < D$NumberOfMenuLines
L0:     pushad
            Mov W$edi 160
            Push edi
                Call 'USER32.SendMessageA' D$H.MenuEdit, &EM_GETLINE, edx, edi
            Pop edi
            Mov B$edi+eax 0  ; >>> 'EM_GETLINE_Comment'
        popad
        Mov al 0, ecx 200 | repne scasb
        inc edx
    End_While
ret


[MenuEditCaretPos: D$ ? ?]
SearchMenuLineChange:
    Call 'USER32.GetCaretPos' MenuEditCaretPos
  ; Zero based X/Y in eax: Y >>> High Word // X >>> Low Word:
    Mov eax D$MenuEditCaretPos+4 | shl eax 16 | or eax D$MenuEditCaretPos

    Call 'USER32.SendMessageA' D$H.MenuEdit, &EM_CHARFROMPOS, 0, eax
  ; Line in the high Word:
    shr eax 16 | Mov edx eax
ret

;;
    Mov edx 0, esi ceMenu

L0: Push edx, esi
        Mov eax 0, edi OneItemString, ecx 40 | rep stosd       ; GETLINE not zero-ended
        Mov W$OneItemString 160                                ; max write for GETLINE
        Call 'USER32.SendMessageA' D$H.MenuEdit, &EM_GETLINE, edx, OneItemString
        Mov B$OneItemString+eax 0  ; >>> 'EM_GETLINE_Comment'
    Pop esi, edx

    cmp eax 0 | je L9>
    Mov edi OneItemString, ecx eax | repe cmpsb | jne L9>
    cmp B$esi 0 | jne L9>
        inc edx | inc esi | jmp L0<<
L9: ret
;;

; edx > 0 based index of suppressed item.

DeleteMenuFlagRecord:
    inc edx | Mov edi MenuItemsFlags | shl edx 2 | add edi edx
    lea esi D$edi+4
    While esi < MenuItemsFlagsEnd | movsb | End_While
ret

    Mov ecx MenuItemsFlagsEnd | sub ecx MenuItemsFlags | shr ecx 2
    sub ecx edx    ; Number of dWords to Move backward.

    shl edx 2
    Mov esi MenuItemsFlags | add esi edx | Mov edi esi | add esi 4
    rep movsd
ret


; edx > 0 based index of added item.

InsertMenuFlagRecord:
    Mov edi MenuItemsFlagsEnd, esi edi | sub esi 4
    Mov ecx MenuItemsFlagsEnd | sub ecx MenuItemsFlags | shr ecx 2
    sub ecx edx    ; Number of dWords to Move forward
    std | rep movsd | cld
    Mov eax 0 | stosd
ret


[NumberOfMenuLines: D$ ?]

MenuLinesControl:
    Call 'USER32.SendMessageA' D$H.MenuEdit, &EM_GETLINECOUNT, 0, 0

    If eax = D$NumberOfMenuLines
        Call MenuCopy
    Else_If eax < D$NumberOfMenuLines   ; user has suppressed one item:
        Mov D$NumberOfMenuLines eax
        Call SearchMenuLineChange       ; edx > 0 based index of suppressed line
        Call DeleteMenuFlagRecord
    Else                                ; user has added one item:
        Mov D$NumberOfMenuLines eax
        Call SearchMenuLineChange       ; edx > 0 based index of added line
        Call InsertMenuFlagRecord
        Call IndentMenuItem
    End_If
ret


[ItemLevel: D$ ?] ; = how many tab in previous item

[ItemTab: B$ TAB EOS]

IndentMenuItem:
    Push edx
        dec edx
        Mov eax 0, edi OneItemString, ecx 40 | rep stosd       ; GETLINE not zero-ended
        Mov W$OneItemString 160                                ; max write for GETLINE
        Call 'USER32.SendMessageA' D$H.MenuEdit, &EM_GETLINE, edx, OneItemString
        Mov B$OneItemString+eax 0  ; >>> 'EM_GETLINE_Comment'
        Mov D$ItemLevel 0, esi OneItemString
        While B$esi = TAB
            inc D$ItemLevel | inc esi
            pushad
                Call 'USER32.SendMessageA' D$H.MenuEdit &EM_REPLACESEL &TRUE ItemTab
            popad

        End_While
    Pop edx
ret


; TAB is used by edit controls/dialog box as a selector. We set in normal:

[mEditRet: D$ ?
 mEditAdressee: D$ ?
 mEditMessage: D$ ?
 mEditWparam: D$ ?
 mEditLparam: D$ ?]

mEditProc:
    Pop D$mEditRet, D$mEditAdressee, D$mEditMessage, D$mEditWparam, D$mEditLparam
    Push D$mEditRet

    .If D$mEditMessage = &WM_KEYDOWN
        If D$mEditWparam = TAB
            Call StoreTabInClipBoard
            Call 'USER32.SendMessageA' D$H.MenuEdit &WM_PASTE 0  0
            Mov eax &FALSE | ret
        End_If
    .End_If

L9: Call 'USER32.CallWindowProcA' D$PreviousEditProc D$mEditAdressee,
                                 D$mEditMessage, D$mEditWparam, D$mEditLparam
    ret


[TabForEditControl: D$ TAB]

StoreTabInClipBoard:

    pushad

        Push D$LP.BlockStartText,
             D$LP.BlockEndText,
             D$FL.BlockInside

            Mov D$LP.BlockStartText TabForEditControl,
                D$LP.BlockEndText TabForEditControl

            Mov D$FL.BlockInside &TRUE | Call ControlC | Mov D$FL.BlockInside &FALSE

        Pop D$FL.BlockInside, D$LP.BlockEndText, D$LP.BlockStartText

    popad

ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE String          ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

                            ; Strings Resources Management.
 _______________________________________________________________________________________
 _______________________________________________________________________________________

; Editing Resources Strings. A simple EditBox holds the Strings. Each String begins with
; leading '#n ' 'n' being decimal Ascii. CR/LF are allowed inside Strings:

StringsResources:
    If D$H.StringsEditor = 0
        Call 'USER32.CreateDialogIndirectParamA' D$H.Instance StringsDialog D$H.MainWindow StringsProc 0
    Else
        Call Beep
    End_If
ret


[ID_HELP 3    ID_EDITSTRINGS 4]

[StringsDialog: D$ 090CC08C2 0        ; Style
 U$ 04 0 0 0DC 0C8             ; Dim
 0                             ;      no Menu
 '' 0                          ; Class
 'Strings Resources' 0         ; Title
 08 'Helv' 0]                  ; Font

[@StringC0: D$ 050B000C4 0      ; Style
 U$ 0 0 0DB 0B2                ; Dim
 ID_EDITSTRINGS                ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data

[@strngC1: D$ 050000001 0      ; Style
 U$ 0A1 0B4 039 013            ; Dim
 &IDOK                            ; ID
 0FFFF 080                     ; Class
 'OK' 0                        ; Title
 0]                            ; No creation data

[@StringC2: D$ 050000000 0      ; Style
 U$ 065 0B4 03A 013            ; Dim
 &IDCANCEL                    ; ID
 0FFFF 080                     ; Class
 'Cancel' 0                    ; Title
 0]                            ; No creation data

[@StringC3: D$ 050000000 0      ; Style
 U$ 0 0B4 038 013              ; Dim
 ID_HELP                       ; ID
 0FFFF 080                     ; Class
 'Help' 0                      ; Title
 0]                            ; No creation data

____________________________________________________________________________________________
; Same as CleanMenuEnd.
; As i get no end problems with this damned Edit Controls when i need to know if there
; are some ending CR/LF or not at the end, i get the text, strip the CR/LF, reset the
; text:

[LenOfStringsText: D$ ?
 TempoStringsTextPtr: D$ ?
 H.StringsEdit: D$ ?]

CleanStrings:
    Mov B$ErrorString &FALSE
    Call 'USER32.GetDlgItem' D$H.StringsEditor ID_EDITSTRINGS
    Mov D$H.StringsEdit eax
    Call 'USER32.SendMessageA' D$H.StringsEdit &WM_GETTEXTLENGTH 0 0
    inc eax | Mov D$LenOfStringsText eax

    Call VirtualAlloc TempoStringsTextPtr,
                      eax

    Call 'USER32.SendMessageA' D$H.StringsEdit &WM_GETTEXT,
                              eax D$TempoStringsTextPtr

    Mov ecx eax | On ecx = 0, jmp L8>>

  ; Clean ending bad chars:
    Mov esi D$TempoStringsTextPtr | add esi D$LenOfStringsText | Mov D$esi+1 0
    While B$esi < SPC
        Mov B$esi 0 | dec esi
    End_While

  ; Clean bad first chars too:
    Mov esi D$TempoStringsTextPtr | add ecx esi      ; ecx = end of data
    While B$esi < '#'
        lodsb | cmp esi ecx | ja L1>
    End_While

L1: If B$esi <> '#'
L8:     Call 'USER32.MessageBoxA' D$H.MainWindow, BadStringID, ErrorMessageTitle, &MB_SYSTEMMODAL
        Mov B$ErrorString &TRUE
    Else
        Mov D$TempoStringsTextPtr esi
    End_If

L1: Call 'USER32.SendMessageA' D$H.StringsEdit &WM_SETTEXT 0 D$TempoStringsTextPtr

    Call VirtualFree TempoStringsTextPtr

ret
____________________________________________________________________________________________


[H.StringsEditor: D$ ?
 H.StringsList: D$ ?
 StringEditFirstRun: D$ ?]

Proc StringsProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_INITDIALOG
        Mov B$StringEditFirstRun &TRUE
        Move D$H.StringsEditor D@hwnd
        Call 'USER32.GetDlgItem' D@hwnd ID_EDITSTRINGS | Mov D$H.StringsList eax
        Call InitStringsList
        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon

    ...Else_If D@msg = &WM_CTLCOLOREDIT                           ; Un-selected text at first show:
        .If B$StringEditFirstRun = &TRUE
            Mov eax D$H.StringsList
            If D@lParam = eax
                Call 'USER32.SendMessageA' D$H.StringsList &EM_SETSEL 0 0
                Mov B$StringEditFirstRun &FALSE
            End_If
        .End_If
        Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>>

    ...Else_If D@msg = &WM_COMMAND
        ..If D@wParam = &IDCANCEL
L1:         Mov D$H.StringsEditor 0
            Call 'USER32.DestroyWindow' D@hwnd

        ..Else_If D@wParam = ID_HELP
            Call Help, B_U_AsmName, StringsHelp, ContextHlpMessage

        ..Else_If D@wParam = &IDOK
            Call CleanStrings
            On B$ErrorString = &FALSE, Call StoreStringsList
            If B$ErrorString = &FALSE
                Call ReorderStringsList | Call Group16Strings | jmp L1<<
            End_If

        ..End_If

    ...Else
L8:     popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE

L9: EndP


[TempoAsciiStrings: D$ ?
 OneStringID: D$ ?]

TransDwordToAsciiNakedDecimal:
    Mov dl 0FF | Push edx
    Mov ecx 10
L0: Mov edx 0 | div ecx | Push edx | cmp eax 0 | ja L0<
L2: Pop eax
    cmp al 0FF | je L9>
       add al '0' | stosb | jmp L2<
L9: ret


InitStringsList:
    Mov esi StringsList | On D$esi = 0, ret

    Call VirtualAlloc TempoAsciiStrings,
                      0FFFF

    Mov ebx StringsList, edi D$TempoAsciiStrings           ; ebx points to 'StringsList' ID

    Mov D$StringsListPtr StringsList

    .While D$ebx > 0
        Mov esi D$StringsListPtr
        Mov al '#' | stosb
        lodsd | dec eax | shl eax 4 | Mov D$OneStringID eax
        Call TransDwordToAsciiNakedDecimal | Mov al SPC | stosb
        add D$StringsListPtr 4
        Mov esi D$StringsListPtr, esi D$esi
        While W$esi > 0
            lodsw | movzx ecx ax
L0:         lodsw | stosb | loop L0<
            Mov al CR | stosb | Mov al LF | stosb
            If W$esi > 0
                Mov al '#' | stosb
                inc D$OneStringID | Mov eax D$OneStringID
                Call TransDwordToAsciiNakedDecimal | Mov al SPC | stosb
            End_If
        End_While
        add D$StringsListPtr 8                             ; next record
        Mov ebx D$StringsListPtr
    .End_While
    Mov al 0 | stosb

    Call 'USER32.SendMessageA' D$H.StringsList &WM_SETTEXT 0 D$TempoAsciiStrings

    Call VirtualFree TempoAsciiStrings

ret


[OneStringBuffer: D$ ?
 IndexToStringsLines: D$ ?
 ErrorString: D$ ?
 NumberOfStrings: D$ ?]

[BadStringID: B$  "Bad or missing ID number encounted    
                         or
   missing space separator or String" EOS]

StoreStringsList:
    Mov edi StringsList,  eax 0, ecx MAXSTRINGS | rep stosd

    Mov B$ErrorString &FALSE, D$StringsListPtr, StringsList, D$IndexToStringsLines 0

    Call VirtualAlloc OneStringBuffer,
                      0FFFF

    Call 'USER32.SendMessageA' D$H.StringsList &EM_GETLINECOUNT 0 0
    Mov D$NumberOfStrings eax

  ; Read one Line (supposed beginning with '#n ':
L0: Mov edi D$OneStringBuffer, ecx 0FFFF, al 0 | rep stosb
    Mov edi D$OneStringBuffer, W$edi 0FFFF
    Push edi
    Call 'USER32.SendMessageA' D$H.StringsList, &EM_GETLINE, D$IndexToStringsLines, edi
    Pop edi
    Mov B$edi+eax 0  ; >>> 'EM_GETLINE_Comment'
    cmp eax 0 | je L9>>
L1: Mov edi D$OneStringBuffer, B$edi+eax 0

  ; Read next Line(s), in Case it (they) would not begin with '#', this would be the same
  ; String:
L1: Mov esi D$OneStringBuffer | inc D$IndexToStringsLines         ; Allowing CR/LF:
    while B$esi <> 0
        lodsb
    End_While
    Mov W$esi 0A0D | add esi 2
    Mov W$esi 0FFFF
    Push esi
        Call 'USER32.SendMessageA' D$H.StringsList, &EM_GETLINE, D$IndexToStringsLines,
                                   esi
    Pop esi
    Mov B$esi+eax 0  ; >>> 'EM_GETLINE_Comment'
    Mov ebx D$NumberOfStrings | cmp D$IndexToStringsLines ebx | je L2>
    Mov B$esi+eax 0                     ; clear remaining 0FF / 0FFFF when 1 / 0 char
    cmp B$esi '#' | jne L1<
  ; '#' encounted >>> stop appending:
L2: sub esi 2 | Mov B$esi 0 | dec D$IndexToStringsLines

    Mov esi D$OneStringBuffer
    lodsb | cmp al '#' | jne L8>
    cmp B$esi SPC | je L8>
    Mov ecx 0
    While B$esi > SPC                   ; Compute #n:
        lodsb
        If al > '9'
L8:         Call 'USER32.MessageBoxA' D$H.MainWindow, BadStringID, ErrorMessageTitle, &MB_SYSTEMMODAL
            Mov B$ErrorString &TRUE | ret
        Else_If al < '0'
            jmp L8<
        End_If
        sub al '0'                      ; convert Decimal to binary:
        lea ecx D$ecx+ecx*4             ;     ecx = ecx * 5
        lea ecx D$eax+ecx*2             ;     ecx = eax + old ecx * 10
    End_While

    On B$esi <> SPC, jmp L8<            ; Suppress > Allow TAB and CR/LF
                                        ; > Down there test ecx=0 instead
    Mov eax ecx
    On eax > 0FFFF, jmp L8<
    Mov edi D$StringsListPtr
    stosd                               ; store ID in 'StringsList'
    inc esi | Mov ecx 0
    Push esi
        While B$esi > 0
            lodsb | inc ecx             ; compute lenght
        End_While
        If ecx = 0
            Pop esi | jmp L8<<
        End_If

        inc ecx

        Push ecx

            inc ecx | shl ecx 1         ; Unicode length

            Push ecx

                Call VirtualAlloc TempoMemPointer,
                                  ecx

                Mov eax D$TempoMemPointer

                Mov ebx eax | stosd     ; store Pointer

            Pop eax | stosd             ; store Size

        Pop ecx

        Mov edi ebx, eax 0

    Pop esi

L1: lodsb | stosw | loop L1<            ; Fill Unicode String mem
    add D$StringsListPtr 12
    inc D$IndexToStringsLines | jmp L0<<

    Call VirtualFree OneStringBuffer

ret


[Reordered: D$ ?]

ReorderStringsList:
  ; First, numerical order:
L0: Mov B$Reordered &FALSE
    Mov esi StringsList, edi esi | add edi 12   ; esi > ID  // edi next ID
    While D$edi+4 > 0
        Mov eax D$esi
        If eax > D$edi
            Exchange D$esi D$edi                ; exchange IDs
            Exchange D$esi+4 D$edi+4            ; exchange Ptrs
            Exchange D$esi+8 D$edi+8            ; exchange Sizes
            Mov B$Reordered &TRUE
        End_If
        add esi 12 | add edi 12
   End_While
   cmp B$Reordered &TRUE | je L0<

  ; Now, ensure no identical IDs. If yes, auto_ajust:
L0: Mov esi StringsList, B$Reordered &FALSE
    While D$esi+16 > 0
       Mov eax D$esi
       If D$esi+12 = eax
           Mov B$Reordered &TRUE | inc D$esi+12 | jmp L0<
       End_If
       add esi 12
    End_While
    cmp B$Reordered &TRUE | je L0<
ret


[NextIdNode: D$ ?
 Group16StringsLen: D$ ?
 StringsGroupBoudary: D$ ?
 GroupStringsID: D$ ?]

; Resource tree IDs are not user defined IDs. They are ((User_ID shr 4) +1) and attached
; Resource Pointers point to groups of 16 Stings. Writes the ID high bits:

[StoreStringID | Push eax | shr eax 4 | inc eax | Mov D$GroupStringsID eax | Pop eax]

Group16Strings:

    Call VirtualAlloc OneStringBuffer,
                      0FFFF

    Mov esi StringsList, D$StringsListPtr esi

L0: Mov edi D$OneStringBuffer | cmp D$esi+4 0 | je L9>>

    Mov eax D$esi | StoreStringID | Mov D$Group16StringsLen 0
    Move D$NextIdNode D$GroupStringsID | shl D$NextIdNode 4  ; '+16' is done by (shr 4)+1

  ; Store dummy Strings if the first ID is not at a 00_1_0000 boundary or if Strings IDs
  ; are missing in between:
    Mov ecx D$esi | and ecx 00_1111 | jmp M1> ; first_case in new group, jE!
L1: Mov ecx D$esi | and ecx 00_1111 ; jE!
    .If esi > StringsList
        Mov ebx D$esi-12
        and ebx 00_1111 ; jE!
        If ecx > ebx
            dec ecx | sub ecx ebx
        End_If
    .End_If
M1:
    jecxz L2>
    Mov eax 0200001                                 ; 01 00 SPC 00 (1 wChar: 1 Space).
M0: add D$Group16StringsLen 4 | stosd | loop M0<

  ; Store one String to "OneStringBuffer": >>jE! optimiZZed > copyU_with_count
L2: Push esi
        Mov esi D$esi+4, edx edi | sub ecx ecx | sub eax eax | add edi 2
X0:     lodsw | test eax eax ZERO X1> | inc ecx | stosw | jmp X0<
X1:     Mov W$edx cx | lea ecx D$ecx*2+2 | add D$Group16StringsLen ecx
    Pop esi

  ; Stop grouping if:
  ; - Next ID is 00_10000 aligned (ebx)
  ; - Previous ID includes 00_1111 (eax)
  ; - Next record is greater than next 16 Strings Node
  ; - Next record is empty
    Mov eax D$esi, ecx eax | inc ecx                ; ecx: Next ID should be ID+1
    add esi 12 | Mov ebx D$esi
    and eax 00_1111

    Mov B$StringsGroupBoudary &FALSE
    If D$esi+4 = 0
        Mov B$StringsGroupBoudary &TRUE             ; Next = empty
    Else_If eax = 00_1111
        Mov B$StringsGroupBoudary &TRUE             ; Actual = End of Set
    Else_If ebx >= D$NextIdNode
        Mov B$StringsGroupBoudary &TRUE             ; Next >= Start of Set
    End_If

    .If B$StringsGroupBoudary = &TRUE
        Push esi
            Push edi

                Mov eax D$StringsListPtr | lea eax D$eax+4 | Call VirtualFree eax

                Call VirtualAlloc TempoMemPointer,
                                  D$Group16StringsLen

                Mov eax D$TempoMemPointer

                Push eax
                    Mov edi D$StringsListPtr
                    Mov eax D$GroupStringsID | stosd    ; Write Splitted ID
                Pop eax
                Push eax
                    stosd                               ; Write Ptr
                    Mov eax D$Group16StringsLen | stosd ; Write Lenght
                Pop edi
                Mov ecx eax, esi D$OneStringBuffer | rep movsb; Write Strings group Data
            Pop edi
        Pop esi
        add D$StringsListPtr 12 | jmp L0<<
    .Else_If D$esi = ecx
        jmp L2<<                            ; OK > group
    .Else
        jmp L1<<                            ; Missing records > Pad and group
    .End_If

L9: Mov esi D$StringsListPtr
    While D$esi+4 > 0

        lea eax D$esi+4 | Call VirtualFree eax ; Release possible tail mems.

        Mov D$esi 0, D$esi+4 0, D$esi+8 0   ; Clear Record
        add esi 12
    End_While

    Call VirtualFree OneStringBuffer           ; Release temporary storage.

ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Tools_Exec      ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;;
                               ; run "Calc.exe" and friends...
 _______________________________________________________________________________________
 _______________________________________________________________________________________

 Icons Links are not yet used by RosAsm. I had a look at Win32.hlp for how to use them
 from an app, in order to retrieve the true link. >>> 3 pages of C chiet (!!!!!!).

 So, i will try later to read the link file. It looks like this:


 D:\RosAsm\Calc.exe.lnk  334 bytes

00000000: 4C 00 00 00 01 14 02 00 - 00 00 00 00 C0 00 00 00
00000010: 00 00 00 46 13 00 00 00 - 20 00 00 00 C0 9C 12 13
00000020: 7C D1 BF 01 00 B0 92 B9 - CB D0 BF 01 00 8C FC C4
00000030: F8 CD BC 01 00 82 03 00 - 00 00 00 00 01 00 00 00
00000040: 00 00 00 00 00 00 00 00 - 00 00 00 00 90 00 14 00
00000050: 1F 00 E0 4F D0 20 EA 3A - 69 10 A2 D8 08 00 2B 30
00000060: 30 9D 19 00 23 43 3A 5C - 00 00 00 00 00 00 00 00
00000070: 00 00 00 00 00 00 00 00 - 00 11 EE 25 00 31 00 00
00000080: 00 00 00 6D 28 9A 65 11 - 00 50 72 6F 67 72 61 6D
00000090: 20 46 69 6C 65 73 00 50 - 52 4F 47 52 41 7E 31 00
000000A0: 20 00 31 00 00 00 00 00 - C8 28 4B 98 10 00 42 61
000000B0: 73 65 43 61 6C 63 00 42 - 41 53 45 43 41 4C 43 00
000000C0: 1C 00 32 00 00 82 03 00 - 3E 23 C0 BB 20 80 42 61
000000D0: 73 65 63 61 6C 63 2E 65 - 78 65 00 00 00 00 55 00
000000E0: 00 00 1C 00 00 00 01 00 - 00 00 1C 00 00 00 2D 00
000000F0: 00 00 00 00 00 00 54 00 - 00 00 11 00 00 00 03 00
00000100: 00 00 EE 15 26 16 10 00 - 00 00 00 43 3A 5C 50 72
                                              C  :  \  P  r
00000110: 6F 67 72 61 6D 20 46 69 - 6C 65 73 5C 42 61 73 65
           o  g  r  a  m --  F  i    l  =  s  \  <  a  s  e
00000120: 43 61 6C 63 5C 42 41 53 - 45 43 41 4C 43 2E 45 58
           C  a  l  c  \  <  A  S    =  C  A  L  C  .  =  X
00000130: 45 00 00 19 00 43 3A 5C - 50 72 6F 67 72 61 6D 20
           =              C  :  \    P  r  o  g  r  a  m --
00000140: 46 69 6C 65 73 5C 42 61 - 73 65 43 61 6C 63
           F  i  l  =  s  \  <  a    s  =  C  a  l  c

 So do i think it will be much easier to read this thing down to the end, make

 > std
 >   Mov al ':', ecx 0FFFF | repne scasb | repne scasb   ; >>> edi > C:\Pr...
 > cld

 store a copy in place of default, and go on (3 simple lines instead of 3 uncertain pages).

 i'll see if it works like this later because i do not know if the links files are
 the same in all win32 platforms.... (i am affraid they are not...)

 Right now, if you use a calc that need installation at C:\somewhere\...
 just copy the full path and name down here instead of "CalcName" or "CalcLinkName".
 the "CalcLinkName" down here is the one i use on my computer... do it your own and
 recompile "CopyOfRosAsm.exe".
;;


[CalcMessage: B$ "

    Copy your prefered Calc in this directory

    and rename it 'Calc.exe'

    or have a search for 'Calc.exe' in RosAsm source    
    and read the header comment...

     " EOS]

[FileNotFound: B$ 'Requested file not found' EOS]


[ProcessInfos: D$ ? # 4]

[CalcExitCode: D$ ?]

;;
 Multi-instances Calc are a problem: I would have prefered to put the calc foreground
 in case user clic on RosAsm window without closing the calc. I have never been able to
 get the handle of it to transmit to 'SetForeground'. So i leave it like this: Each
 time [Calc] menu item is clicked, we first kill the calc (even if already dead). It
 works supringly well, but i do not understand why. It seams that Win doesn't reuse
 the same "handles"... help wanted!!!
;;

Calc:
    If B$OnCalc = &TRUE
      Call 'KERNEL32.TerminateProcess' D$ProcessInfos D$CalcExitCode
    End_If

    Call 'KERNEL32.CreateProcessA'  CalcName  0 0 0  0  0 0 0  STARTUPINFO  ProcessInfos

    On eax = 0,
      Call 'KERNEL32.CreateProcessA'  CalcLinkName  0 0 0  0  0 0 0  STARTUPINFO  ProcessInfos

    If eax = 0
      Call 'USER32.MessageBoxA' D$H.MainWindow, CalcMessage, FileNotFound,
                                &MB_ICONINFORMATION+&MB_SYSTEMMODAL
    Else
      Call 'KERNEL32.GetExitCodeProcess' D$ProcessInfos CalcExitCode
      Mov B$OnCalc &TRUE
    End_If
ret
________________________________________________________________________________________
________________________________________________________________________________________

[open: B$ 'open' EOS]

; Same but for OpCodes.hlp / Win32.hlp
;;
[OpCodesMessage: B$ " Copy 'x86eas.hlp' in this directory
or run [Config] menu option" EOS]

Opcodes_Hlp:
    Call 'SHELL32.ShellExecuteA' D$H.MainWindow open  OpcodeHlpName NoParameter &NULL &SW_SHOWDEFAULT
    If eax <= 32
      Call 'USER32.MessageBoxA' D$H.MainWindow OpCodesMessage, FileNotFound, &MB_ICONINFORMATION+&MB_SYSTEMMODAL
    End_If
ret
;;

[WinHlpMessage: B$ "Copy 'Win32.hlp' in this directory
or run [Config] menu option" EOS]

Win32_Hlp:
    Call Help Win32HlpName, NoParameter, WinHlpMessage
ret

;;
[Asm32HlpMessage: B$ "Copy 'Asm32Tut.exe' in this directory
or run [Config] menu option" EOS]

Asm32_Hlp:
    Call 'SHELL32.ShellExecuteA' D$H.MainWindow open Asm32TutName NoParameter &NULL &SW_SHOWDEFAULT
    If eax <= 32
      Call 'USER32.MessageBoxA' D$H.MainWindow Asm32HlpMessage, FileNotFound, &MB_ICONINFORMATION+&MB_SYSTEMMODAL
    End_If
ret
;;

[MmediaHlpMessage: B$ "Copy 'Mmedia.hlp' in this directory
or run [Config] menu option" EOS]

Mmedia_Hlp:
    Call Help MmediaHlpName, NoParameter, MmediaHlpMessage
ret


[OpenGlHlpMessage: B$ "Copy 'OpenGl.hlp' in this directory
or run [Config] menu option" EOS]

OpenGl_Hlp:
    Call Help OpenGlHlpName, NoParameter, OpenGlHlpMessage
ret


[WinSockHlpMessage: B$ "Copy 'WinSock.hlp' in this directory
or run [Config] menu option" EOS]

WinSock_Hlp:
    Call Help WinSockHlpName, NoParameter, WinSockHlpMessage
ret


[SDLRefHlpMessage: B$ "Copy 'SDL.chm' in this directory
or run [Config] menu option" EOS]

SDL_Hlp:
    Call Help SDLRefName, NoParameter, SDLRefHlpMessage
ret


[sqliteHlpMessage: B$ "Copy 'sqlite.hlp' in this directory
or run [Config] menu option" EOS]

sqlite_Hlp:
    Call Help sqliteName, NoParameter, sqliteHlpMessage
ret


DevIL_Hlp:
    Call Help DevILName, NoParameter, DxHlpMessage
ret


[DxHlpMessage: B$ "Copy 'DirectX.hlp' in this directory
or run [Config] menu option" EOS]

Dx_Hlp:
    Call Help DxHlpName, NoParameter, DxHlpMessage
ret

;;
[WinDataFileMessage: B$ "Run [Config] menu option and define a File    " EOS]

WinDataFile:
    Call 'SHELL32.ShellExecuteA' D$H.MainWindow open WinDataFileName NoParameter &NULL &SW_SHOWDEFAULT
    If eax <= 32
      Call 'USER32.MessageBoxA' D$H.MainWindow WinDataFileMessage, FileNotFound, &MB_ICONINFORMATION+&MB_SYSTEMMODAL
    End_If
ret
;;

[BUAsmHlpMessage: B$ "
Copy 'B_U_Asm.exe' in this directory or run:

[Configuration] menu option.


If this is for a first run, select:

[Configuration][Companion Files] and provide the Path to:

* [B_U_Asm.exe]

Then provide the Path to:        

* [Equates Path]

After this BUAsm will shut down and will be ready
for a first Run.

" EOS]

BUAsmHelp:

    Call Help B_U_AsmName,
    B_U_AsmTop,
    BUAsmHlpMessage

ret


[F2HlpMessage: B$ "The File you defined in the [Configuration][Other Files]
to be activated by [F2] is not available" EOS]

F2Help:
    If D$F2Name <> 0
        Call Help F2Name, NoParameter, F2HlpMessage
    End_If
ret


[RosAsmLicenceHelp: B$ 'RosAsm_License' EOS]

LicenseView:
    Call Help, B_U_AsmName, RosAsmLicenceHelp, ContextHlpMessage

    Call 'USER32.MessageBoxA' D$H.MainWindow,
        {B$ "
        RosAsm License viewed       
        
                   Accept?" EOS},
        {B$ 'License' EOS}, &MB_SYSTEMMODAL__&MB_YESNO

    On eax = &IDNO, Call 'KERNEL32.ExitProcess' 0
ret


[GplHelp: B$ 'GPL' EOS]

GPLView:
    Call Help, B_U_AsmName, GplHelp, ContextHlpMessage
ret






[NoParameter: B$ EOS] ;
[B_U_AsmTop: B$ 'Top' EOS]
[StringsHelp: B$ 'Strings_Editor' EOS]
[IconHelp: B$ 'Icon_Editor' EOS]
[MenuHelp: B$ 'Menus_Editor' EOS]
[DialogHelp: B$ 'Dialog_Editor' EOS]
[TempateHelp: B$ 'Reusing_Code' EOS]
[ConfigHelp:  'Configuration_Tab' EOS]
[DisassemblerHelp: B$ 'Disassembling' EOS]
[IncludeFilesHelp: B$ 'Include_Files' EOS]
[SourceEditor: B$ 'Source_Editor' EOS]
[StructuresHelp: B$ 'Structures' EOS]
[HelPFiles: B$ 'HelpFiles' EOS]
[DisMap: B$ 'Disassembler_Flags' EOS]
[UnusedSymbolsHelp: B$ 'Unused_symbols_Scanner' EOS]

[ContextHlpMessage: B$ 'Run [Configuration]/|Files Locations]/[RosAsm]     ' EOS]

;[ContextHelp | Call 'SHELL32.ShellExecuteA' D$H.MainWindow open, B_U_AsmName, #1, &NULL, &SW_SHOWNORMAL
; cmp eax 32 | ja M0>
;    Call 'USER32.MessageBoxA' D$H.MainWindow ContextHlpMessage, FileNotFound, &MB_ICONINFORMATION+&MB_SYSTEMMODAL
; M0:]

Proc Help:
    Arguments @HelpFile, @Page, @ErrorMessage

        Call 'SHELL32.ShellExecuteA' D$H.MainWindow, open, D@HelpFile, D@Page, &NULL,
                                     &SW_SHOWNORMAL
        If eax <= 32
            Push eax
                Call 'USER32.MessageBoxA' D$H.MainWindow, D@ErrorMessage, FileNotFound,
                                          &MB_ICONINFORMATION+&MB_SYSTEMMODAL
            Pop eax
        End_If
EndP


; Menu is build at 'AddUserMenu'

UserDefinedAction:
    sub eax 2000  ; eax = 0 to 8
    Mov ecx (64*4) | mul ecx
    add eax UserMenu0Path

    Call 'SHELL32.ShellExecuteA' D$H.MainWindow, open, eax, NoParameter, &NULL, &SW_SHOWDEFAULT
ret

______________________________________________________________________________________

; Show a Box with Ascii codes in decimal and Hexa:

[AsciiData: B$ ? # 2860]

[AsciiDialog: D$ 090CC08C2 0   ; Style
 U$ 01 0 0 01E6 0109           ; Dim
 0                             ; Menu
 0                             ; Class(not yet)
 "Ascii Table" 0                ; Title
 08 'Helv' 0]                  ; Font

[@AC0: D$ 0508008C4 0           ; Style
 U$ 1 1 01E5 0108              ; Dim
 0100                          ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data


; Build a text table to send to Edit Control:

AsciiTable:
    If D$H.AsciiDialog > 0
        Call Beep | ret
    End_If

    Push ebp
        Mov edi AsciiData, ebx 0, ecx 10, ebp 0
        Mov al TAB | stosb
        .While ebp < 256
            Mov al bl | On al < 32, Mov al 2 | stosb
            Mov al TAB | stosb
            Mov eax ebx | add edi 2
            Mov edx 0 | div ecx
            add dl '0' | Mov B$edi dl
            dec edi
            Mov edx 0 | div ecx
            add dl '0' | Mov B$edi dl
            dec edi
            Mov edx 0 | div ecx
            add dl '0' | Mov B$edi dl
            add edi 3 | Mov al TAB | stosb

            Mov al '0' | stosb
            Mov eax ebx, edx eax | shr eax 4
            and eax 0F | add al '0' | On al > '9', add al 7
            stosb
            Mov eax edx
            and eax 0F | add al '0' | On al > '9', add al 7
            stosb

            add ebx 32
            cmp ebx 255 | jna L2>
            sub ebx 255
            Mov al CR | stosb | Mov al LF | stosb
            Mov al TAB | stosb | jmp L3>
L2:         Mov al TAB | stosb | stosb
L3:         inc ebp
        .End_While

        Mov eax 0 | stosd
       ; Show resulting box:
        Call 'USER32.DialogBoxIndirectParamA' D$H.Instance, AsciiDialog, 0, AsciiProc, 0
    Pop ebp
ret


[TabDimPtr: D$ 10]
[H.AsciiDialog: D$ ?]

Proc AsciiProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    .If D@msg = &WM_COMMAND
        If D@wParam = &IDCANCEL
            Mov D$H.AsciiDialog 0
            Call 'USER32.EndDialog' D@hwnd 0
        Else
            Call 'USER32.GetDlgItem' D@hwnd 0100
            Call 'USER32.SendMessageA' eax &EM_SETSEL  0-1 0
        End_If

    .Else_If D@msg = &WM_INITDIALOG
        Move D$H.AsciiDialog D@hwnd
        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        Call 'USER32.GetDlgItem' D@hwnd 0100
        Call 'USER32.SendMessageA' eax &EM_SETTABSTOPS 1 TabDimPtr
        Call 'USER32.SetDlgItemTextA' D@hwnd 0100 AsciiData

    .Else
       popad | Mov eax &FALSE | jmp L9>

    .End_If

    popad | Mov eax &TRUE

L9: EndP

___________________________________________________________________________________________
___________________________________________________________________________________________

;             Printer job (here, with fixed pitch fonts for sources alignment)
___________________________________________________________________________________________
___________________________________________________________________________________________

; This Structure is for Call 'Comdlg32.PrintDlgA'. We really use only 'PD_Flags' to tell
; if we want/propose a user selected block to print or not:

[PRINTDLG:
 @PD_lStructSize: len
 @PD_hWndOwner: 0
 @PD_hDevMode: 0
 @PD_hDevNames: 0
 @PD_hDC: 0
 @PD_Flags: &PD_RETURNDC+&PD_SELECTION
 @PD_nFromPage: W$ 0
 @PD_nToPage: 0
 @PD_nMinPage: 0
 @PD_nMaxPage: 0
 @PD_nCopies: 1
 @PD_hInstance: D$ 0
 @PD_lCustData: 0
 @PD_lpfnPrintHook: 0
 @PD_lpfnSetupHook: 0
 @PD_lpPrintTemplateName: 0
 @PD_lpPrintSetupTemplateName: 0
 @PD_hPrintTemplate: 0
 @PD_hSetupTemplate: 0]

; Needed for 'GDI32.StartDocA' (no interrest for us):

[DocName: B$ ' - Poor text Printer -' EOS]

[DOCINFO:
 @DI_cbSize: len
 @DI_lpszDocName: DocName
 @DI_lpszOutput: 0
 @DI_lpszDatatype: 0
 @DI_fwType: 0]

; This is for Call 'Comdlg32.ChooseFontA'. Important:

;[CF_PRINTERFONTS 2  CF_FIXEDPITCHONLY 04000  CF_INITTOLOGFONTSTRUCT 040]


; Default font for choose-font-box (Courier new 14).
; LOGFONTA Structure (Pointed by record 4 in CHOOSEFONT):

[CbBuffer:
 @lfHeight: D$ 0FFFF_FFED    ; (-19) (for details, see "LOGFONT" in win32.hlp)
 @lfWidth: D$ 0
 @lfEscapement: D$ 0
 @lfOrientation: D$ 0
 @lfWeight: D$ 0190
 @lfItalic: B$ 0
 @lfUnderline: B$ 0
 @lfStrikeOut: B$ 0
 @lfCharSet: B$ 0
 @lfOutPrecision: B$ 03
 @lfClipPrecision: B$ 02
 @lfQuality: B$ 01
 @lfPitchAndFamily: B$ 031
 @lfFaceName: B$ 'Courier New' EOS
 @CBBsecurityTail: 0 # 5] ; 32 Bytes > Total lenght = 60 Bytes

[PrintTextMetric: D$ ? # 20]

[CHOOSEFONT:
 @CF_lStructSize: Len
 @CF_hWndOwner: 0
 @CF_hDC: 0
 @CF_lpLogFont: cbbuffer
 @CF_iPointSize: 0
 @CF_Flags: &CF_PRINTERFONTS+&CF_FIXEDPITCHONLY+&CF_INITTOLOGFONTSTRUCT
 @CF_rgbColors: 0
 @CF_lCustData: 0
 @CF_lpfnHook: 0
 @CF_lpTemplateName: 0
 @CF_hInstance: 0
 @CF_lpszStyle: 0
 @CF_nFontType: W$ 0
 @CF_Alignment:  0
 @CF_nSizeMin: D$ 3
 @CF_nSizeMax: 0ff]

[UserChoosenPrinterFont: D$ ?]

; Our pointers:
[PrintStartPtr: D$ ?
 PrintEndPtr: D$ ?
 CharHight: D$ ?
 PageHight: D$ ?
 PrinterDCavailable: D$ ?]

Print:
    On D$SourceLen = 0, ret

    If B$PrinterDCavailable = &TRUE
        Call 'GDI32.DeleteDC' D$PRINTDLG@PD_hDC
        Call 'GDI32.DeleteObject' D$UserChoosenPrinterFont
    End_If

    If D$FL.BlockInside = &TRUE
        Mov D$PRINTDLG@PD_Flags &PD_RETURNDC+&PD_SELECTION
    Else
        Mov D$PRINTDLG@PD_Flags &PD_RETURNDC+&PD_NOSELECTION
    End_If

    Call 'Comdlg32.PrintDlgA' PRINTDLG | On eax = 0, ret    ; The Printer dialog sets
    Move D$CHOOSEFONT@CF_hDC D$PRINTDLG@PD_hDC,  D$CHOOSEFONT@CF_hWndOwner D$H.MainWindow          ; the DC handle in PRINTDLG struc
    If D$PRINTDLG@PD_Flags = &PD_RETURNDC+&PD_SELECTION

        Move D$PrintStartPtr D$LP.BlockStartText,
             D$PrintEndPtr D$LP.BlockEndText

    Else

        Mov eax D$STRUCT.EditData@UpperLine,
            D$PrintStartPtr eax

        add eax D$SourceLen | Mov D$PrintEndPtr eax

    End_If

    Call 'Comdlg32.ChooseFontA' CHOOSEFONT | On eax = 0, ret    ; user sets the font:
    Call 'GDI32.CreateFontIndirectA' cbbuffer
        Mov D$UserChoosenPrinterFont eax

    Call UpdateRegistry                                 ; To save last used Printer Font.

StartControlP:
    Call 'GDI32.GetDeviceCaps' D$PRINTDLG@PD_hDC &VERTRES | Mov D$PageHight eax   ; we set the sizes:
    Call 'GDI32.GetTextMetricsA' D$PRINTDLG@PD_hDC PrintTextMetric
        Mov eax D$PrintTextMetric, D$CharHight eax
        shl eax 4 | sub D$PageHight eax                 ; sub 16 lines for top/bottom blanks

    Call 'GDI32.StartDocA' D$PRINTDLG@PD_hDC  DOCINFO | On eax le 0, jmp L7>>; we print:
        Call 'GDI32.StartPage' D$PRINTDLG@PD_hDC | On eax le 0, jmp L7>>
            Call 'GDI32.SelectObject' D$PRINTDLG@PD_hDC D$UserChoosenPrinterFont

          Mov esi D$PrintStartPtr, edx 0
L0:       Mov ebx esi, ecx 0
L1:       cmp B$esi SPC | jb L2>
            lodsb | inc ecx | cmp esi D$PrintEndPtr | jae L3>
              jmp L1<
L2:       add esi 2                                                      ; strip CR/LR
L3:       Push esi, edx
            On ecx > 0
              Call 'USER32.TabbedTextOutA'  D$PRINTDLG@PD_hDC 0 edx ebx ecx 0,0,0
            End_If
          Pop edx esi
          add edx D$CharHight
          If edx >= D$PageHight                                          ; Next page?:
            pushad
              Call 'GDI32.EndPage' D$PRINTDLG@PD_hDC | On eax le 0, jmp L7>>
                Call 'GDI32.StartPage' D$PRINTDLG@PD_hDC | On eax le 0, jmp L7>>
                  Call 'GDI32.SelectObject' D$PRINTDLG@PD_hDC D$UserChoosenPrinterFont
            popad
            Mov edx 0
          End_If
          On esi < D$PrintEndPtr, jmp L0<<

        Call 'GDI32.EndPage' D$PRINTDLG@PD_hDC | On eax le 0, jmp L7>>
      Call 'GDI32.EndDoc' D$PRINTDLG@PD_hDC
    Mov B$PrinterDCavailable &TRUE | ret

L7: Call 'GDI32.AbortDoc' D$PRINTDLG@PD_hDC
    Call 'GDI32.DeleteObject' D$UserChoosenPrinterFont
    Call 'GDI32.DeleteDC' D$PRINTDLG@PD_hDC

    Mov B$PrinterDCavailable &FALSE
ret


ControlP:

    If D$FL.BlockInside = &FALSE

        ret

    Else_If B$PrinterDCavailable = &FALSE

        jmp Print

    Else

        Move D$PrintStartPtr D$LP.BlockStartText,
             D$PrintEndPtr D$LP.BlockEndText

        jmp StartControlP

    End_If
____________________________________________________________________________________________
____________________________________________________________________________________________

; Tool for viewing the System Resources and retrieving the IDs.

ViewSysResources:
    If D$H.ViewSysResources = 0
        Call 'USER32.DialogBoxParamA' D$H.Instance 29000 &NULL ViewSysResourcesProc &NULL
    Else
        Call Beep
    End_If
ret


[H.ViewSysResources: D$ ?
 H.SysBitMaps: D$ ?
 H.SysIcons: D$ ?
 H.SysCursors: D$ ?]

Proc ViewSysResourcesProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_INITDIALOG
        Move D$H.ViewSysResources D@hwnd
        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        Call 'USER32.GetDlgItem' D@hwnd 10 | Mov D$H.SysBitMaps eax
        Call 'USER32.GetDlgItem' D@hwnd 11 | Mov D$H.SysIcons eax
        Call 'USER32.GetDlgItem' D@hwnd 12 | Mov D$H.SysCursors eax
        Call InitViewSysResourcesListBoxes
        Mov D$SysButtonText 0 | jmp L8>>

    ...Else_If D@msg = &WM_COMMAND
        Mov eax D@wParam | and D@wParam 0FFFF | shr eax 16

        ..If eax = &LBN_SELCHANGE
            Call 'USER32.SendDlgItemMessageA' D@hwnd D@wParam &LB_GETCURSEL 0 0

            add D@wParam 10     ; Listy Box ID + 10 >>> Static Control ID

            If D@wParam = 20
                SetOKButtonSysText SysBitMapsStrings SysBitMapsIDs
                lea ebx D$SysBitMapsIDs+eax*4
                Call 'USER32.LoadBitmapA' &NULL D$ebx
                Mov ecx &IMAGE_BITMAP
            Else_If D@wParam = 21
                SetOKButtonSysText SysIconsStrings SysIconsIDs
                lea ebx D$SysIconsIDs+eax*4
                Call 'USER32.LoadIconA' &NULL D$ebx
                Mov ecx &IMAGE_ICON
            Else_If D@wParam = 22
                SetOKButtonSysText SysCursorsStrings SysCursorsIDs
                lea ebx D$SysCursorsIDs+eax*4
                Call 'USER32.LoadCursorA' &NULL D$ebx
                Mov ecx &IMAGE_CURSOR
            End_If

            Call 'USER32.SendDlgItemMessageA' D@hwnd D@wParam &STM_SETIMAGE ecx eax
            Call 'USER32.SendDlgItemMessageA' D@hwnd 1 &WM_SETTEXT 0 SysButtonText

        ..Else_If D@wParam = &IDCANCEL
            jmp L1>

        ..Else_If D@wParam = &IDOK
            If B$SysButtonText <> 0
                Mov esi SysButtonText, edi SysButtonText
                While B$esi > 0
                    movsb
                    On W$esi = '&&', inc esi
                End_While
                Mov B$edi 0

                Mov eax SysButtonText, D$LP.BlockStartText eax

                While B$eax > 0 | inc eax | End_While

                dec eax

                Mov D$LP.BlockEndText eax,
                    D$FL.BlockInside &TRUE

                Call ControlC | Mov D$FL.BlockInside &FALSE

            End_If

L1:         Mov D$H.ViewSysResources 0
            Call 'USER32.EndDialog' D@hwnd 0

        ..End_If

    ...Else_If D@msg = &WM_CTLCOLOREDIT
        jmp L1>

    ...Else_If D@msg = &WM_CTLCOLORLISTBOX
L1:     Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>

    ...Else
L8:     popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE

L9: EndP


[SetOKButtonSysText | Mov edi #1 | Mov edx #2 | Call OKButtonSysText]

; Example: edi > SysBitMapsStrings // eax = zero Based Indice

[SysButtonText: D$ ? # 12]
[SysBitMapApiCall: B$ "Call 'USER32.LoadBitmapA' &&NULL &&" EOS
 SysIconApiCall: B$ "Call 'USER32.LoadIconA' &&NULL &&" EOS
 SysCursorApiCall: B$ "Call 'USER32.LoadCursorA' &&NULL &&" EOS]

OKButtonSysText:
    Push eax, ebx
        .While eax > 0
            While B$edi <> 0 | inc edi | End_While
            inc edi | dec eax
        .End_While

        Push edi
            Mov edi SysButtonText
            If edx = SysBitMapsIDs
                Mov esi SysBitMapApiCall
            Else_If edx = SysIconsIDs
                Mov esi SysIconApiCall
            Else
                Mov esi SysCursorApiCall
            End_If
            While B$esi <> 0 | movsb | End_While
        Pop esi

      ; Copy the Equate in the Button Buffer:
        inc esi
        While B$esi <> 0 | movsb | End_While
        Mov D$edi ' ; =', B$edi+4 SPC | add edi 5

    Pop ebx, eax
    Push eax, ebx
        Mov eax D$edx+eax*4 | Call WriteEax | Mov B$edi 0
    Pop ebx, eax
ret

[SysBitMapsStrings:
 B$ '&OBM_CLOSE' EOS
 B$ '&OBM_UPARROW' EOS
 B$ '&OBM_DNARROW' EOS
 B$ '&OBM_RGARROW' EOS
 B$ '&OBM_LFARROW' EOS
 B$ '&OBM_REDUCE' EOS
 B$ '&OBM_ZOOM' EOS
 B$ '&OBM_RESTORE' EOS
 B$ '&OBM_REDUCED' EOS
 B$ '&OBM_ZOOMD' EOS
 B$ '&OBM_RESTORED' EOS
 B$ '&OBM_UPARROWD' EOS
 B$ '&OBM_DNARROWD' EOS
 B$ '&OBM_RGARROWD' EOS
 B$ '&OBM_LFARROWD' EOS
 B$ '&OBM_MNARROW' EOS
 B$ '&OBM_COMBO' EOS
 B$ '&OBM_UPARROWI' EOS
 B$ '&OBM_DNARROWI' EOS
 B$ '&OBM_RGARROWI' EOS
 B$ '&OBM_LFARROWI' EOS
 B$ '&OBM_SIZE' EOS
 B$ '&OBM_BTSIZE' EOS
 B$ '&OBM_CHECK' EOS
 B$ '&OBM_CHECKBOXES' EOS
 B$ '&OBM_BTNCORNERS' EOS
 B$ 0]

[SysBitMapsIDs:
 &OBM_CLOSE
 &OBM_UPARROW
 &OBM_DNARROW
 &OBM_RGARROW
 &OBM_LFARROW
 &OBM_REDUCE
 &OBM_ZOOM
 &OBM_RESTORE
 &OBM_REDUCED
 &OBM_ZOOMD
 &OBM_RESTORED
 &OBM_UPARROWD
 &OBM_DNARROWD
 &OBM_RGARROWD
 &OBM_LFARROWD
 &OBM_MNARROW
 &OBM_COMBO
 &OBM_UPARROWI
 &OBM_DNARROWI
 &OBM_RGARROWI
 &OBM_LFARROWI
 &OBM_SIZE
 &OBM_BTSIZE
 &OBM_CHECK
 &OBM_CHECKBOXES
 &OBM_BTNCORNERS]

[SysIconsStrings:
 B$ '&IDI_APPLICATION' EOS
 B$ '&IDI_HAND' EOS
 B$ '&IDI_QUESTION' EOS
 B$ '&IDI_EXCLAMATION' EOS
 B$ '&IDI_ASTERISK' EOS
 B$ '&IDI_WINLOGO' EOS
 B$ 0]

[SysIconsIDs:
 &IDI_APPLICATION
 &IDI_HAND
 &IDI_QUESTION
 &IDI_EXCLAMATION
 &IDI_ASTERISK
 &IDI_WINLOGO]

[SysCursorsStrings:
 B$ '&IDC_ARROW' EOS
 B$ '&IDC_IBEAM' EOS
 B$ '&IDC_WAIT' EOS
 B$ '&IDC_CROSS' EOS
 B$ '&IDC_UPARROW' EOS
 B$ '&IDC_SIZENWS' EOS
 B$ '&IDC_SIZENESW' EOS
 B$ '&IDC_SIZEWE' EOS
 B$ '&IDC_SIZENS' EOS
 B$ '&IDC_SIZEALL' EOS
 B$ '&IDC_NO' EOS
 B$ '&IDC_APPSTARTING' EOS
 B$ '&IDC_HELP' EOS
 0]

[SysCursorsIDs:
 &IDC_ARROW
 &IDC_IBEAM
 &IDC_WAIT
 &IDC_CROSS
 &IDC_UPARROW
 &IDC_SIZENWSE
 &IDC_SIZENESW
 &IDC_SIZEWE
 &IDC_SIZENS
 &IDC_SIZEALL
 &IDC_NO
 &IDC_APPSTARTING
 &IDC_HELP]

InitViewSysResourcesListBoxes:
    Mov edi SysBitMapsStrings
    While B$edi <> 0
        Push edi
        Call 'USER32.SendMessageA' D$H.SysBitMaps &LB_ADDSTRING 0 edi
        Pop edi
        Mov al 0, ecx 0FF | repne scasb
    End_While

    Mov edi SysIconsStrings
    While B$edi <> 0
        Push edi
        Call 'USER32.SendMessageA' D$H.SysIcons &LB_ADDSTRING 0 edi
        Pop edi
        Mov al 0, ecx 0FF | repne scasb
    End_While

    Mov edi SysCursorsStrings
    While B$edi <> 0
        Push edi
        Call 'USER32.SendMessageA' D$H.SysCursors &LB_ADDSTRING 0 edi
        Pop edi
        Mov al 0, ecx 0FF | repne scasb
    End_While
ret

;;
____________________________________________________________________________________________
____________________________________________________________________________________________

 Used DLL in the actual Source.
;;


ShowSourceImports:
    If D$H.ImportDialog = 0
        Call 'USER32.DialogBoxParamA' D$H.Instance, 1100, &NULL,
                                      ViewSourceImportsProc, &NULL
    End_If
ret


ShowSourceExports:
    If D$H.ExportDialog = 0
        Call 'USER32.DialogBoxParamA' D$H.Instance, 1101, &NULL,
                                      ViewSourceExportsProc, &NULL
    End_If
ret


[H.DLLsProcList: D$ ?
 H.DLLsProcFunctionsList: D$ ?]

Proc Enable:

    Arguments @H.Parent,
              @ID

    Call 'USER32.GetDlgItem' D@H.Parent,
                             D@ID

    Call 'USER32.EnableWindow' eax,
                               &TRUE

EndP

Proc Disable:

    Arguments @H.Parent,
              @ID

    Call 'USER32.GetDlgItem' D@H.Parent,
                             D@ID

    Call 'USER32.EnableWindow' eax,
                               &FALSE

EndP


[H.ImportDialog: D$ ?]

; Tag Dialog 1100

Proc ViewSourceImportsProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_COMMAND
        Mov eax D@wParam | and eax 0FFFF
        ..If eax = &IDCANCEL
            Mov D$H.ImportDialog 0
            Call 'USER32.EndDialog' D@hwnd, 0

        ..Else
            .If W@wParam = 10
                If W@wParam+2 = &LBN_SELCHANGE
                    Call RestoreRealSource
                    Call ViewDllFunctionList
                    Call SetPartialEditionFromPos
                End_If
                Call 'USER32.SetDlgItemInt' D@hwnd, 12, 0, &FALSE
                Call Disable D@hwnd, 3
                Call Disable D@hwnd, 4

            .Else_If W@wParam = 11
                If W@wParam+2 = &LBN_SELCHANGE
                    Call 'USER32.SendMessageA' D$H.DLLsProcFunctionsList,
                                               &LB_GETCURSEL, 0, 0

                    Call 'USER32.SendMessageA' D$H.DLLsProcFunctionsList,
                                               &LB_GETITEMDATA, eax, 0

                    Call 'USER32.SetDlgItemInt' D@hwnd, 12, eax, &FALSE
                    Call 'USER32.SendDlgItemMessageA' D@hwnd, 3, &WM_ENABLE,
                                                      &TRUE, 0
                    Call Enable D@hwnd, 3
                    Call Disable D@hwnd, 4

                End_If

            .Else_If W@wParam = 3
                Call ImportFunctionFindFirst

                Call 'USER32.SendMessageA' D$H.DLLsProcFunctionsList, &LB_GETCURSEL, 0, 0
                Call 'USER32.SendMessageA' D$H.DLLsProcFunctionsList, &LB_GETITEMDATA,
                                           eax, 0
                On eax > 1, Call Enable D@hwnd, 4

            .Else_If W@wParam = 4
                Call ImportFunctionFindNext

            .End_If
        ..End_If

    ...Else_If D@msg = &WM_INITDIALOG
        Move D$H.ImportDialog D@hwnd

        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon

        Call 'USER32.GetDlgItem' D@hwnd, 10 | Mov D$H.DLLsProcList eax
        Call 'USER32.GetDlgItem' D@hwnd, 11 | Mov D$H.DLLsProcFunctionsList eax

        Call Disable D@hwnd, 3
        Call Disable D@hwnd, 4

        Call RestoreRealSource
        Call InitImportsProcList
        Call SetPartialEditionFromPos

        If B$DLLsFoundInSource = &FALSE
            Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'No Import Function found in this Source' EOS},
                                     {B$ 'Failure:' EOS}, 0
            Call 'USER32.EndDialog' D@hwnd, 0
        End_If

        popad | Mov eax &FALSE | ExitP

    ...Else
        popad | Mov eax &FALSE | ExitP

    ...End_If

L8: popad | Mov eax &TRUE
EndP


ExportFunctionFindFirst:
    Call 'USER32.SendMessageA' D$H.DLLsProcList, &LB_GETCURSEL, 0, 0
    Call 'USER32.SendMessageA' D$H.DLLsProcList, &LB_GETTEXT, eax, SearchString

    .If eax <> &LB_ERR
        Mov W$SearchString+eax '::' | add eax 2 | jmp L1>

ImportFunctionFindFirst:
    Call 'USER32.SendMessageA' D$H.DLLsProcFunctionsList, &LB_GETCURSEL, 0, 0
    Call 'USER32.SendMessageA' D$H.DLLsProcFunctionsList, &LB_GETTEXT, eax, SearchString

    .If eax <> &LB_ERR
        Mov D$SearchString+eax "'" | inc eax
L1:     Mov D$LenOfSearchedString eax

        Call RestoreRealSource

        Push D$DownSearch, D$CaseSearch, D$WholeWordSearch
            Mov B$DownSearch &TRUE, B$CaseSearch &TRUE, B$WholeWordSearch &FALSE
            Move D$STRUCT.EditData@CurrentWritingPos D$CodeSource
            Call SetCaret D$CodeSource | Move D$STRUCT.EditData@UpperLine D$CodeSource
            Call AskForRedrawNow

                Mov D$NextSearchPos 0

                Call StringSearch

        Pop D$WholeWordSearch, D$CaseSearch, D$DownSearch

        Call SetPartialEditionFromPos

    .End_If
ret


ImportFunctionFindNext:

    Call RestoreRealSource
        Push D$DownSearch, D$CaseSearch, D$WholeWordSearch
            Call StringSearch
        Pop D$WholeWordSearch, D$CaseSearch, D$DownSearch
    Call SetPartialEditionFromPos
ret


[DLLsFoundInSource: D$ ?]

InitImportsProcList:
    Mov esi D$CodeSource, edx D$STRUCT.EditData@SourceEnd, B$DLLsFoundInSource &FALSE

    .While esi < edx
        Mov eax D$esi
        ..If al = '"'
            inc esi
            While B$esi <> '"'
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ..Else_If al = "'"
            inc esi
            While B$esi <> "'"
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ..Else_If eax = MLC
            add esi 4
            While D$esi <> MLC
                inc esi | On esi = edx, jmp L9>>
            End_While
            add esi 4

        ..Else_If al = ';'
                While B$esi >= SPC | inc esi | End_While

        ..Else
            or eax 020202020
            If eax = 'Call'
                add esi 4
            Else_If eax = 'jmp '
                add esi 3
            Else
                jmp L8>>
            End_If

            While B$esi = SPC | inc esi | End_While
            Mov al B$esi
            .If al = '"'
                jmp L1>
            .Else_If al = "'"
L1:             inc esi | Mov ebx esi
                While B$esi <> al
                    On B$esi <= SPC, jmp L2>
                    If B$esi = '.'
                        Mov B$DLLsFoundInSource &TRUE
                        Push eax, edx, D$esi, esi
                            Mov B$esi 0
                            Push ebx
                             Call Lb_FindString D$H.DLLsProcList, ebx
         ; Call 'USER32.SendMessageA' D$H.DLLsProcList, &LB_FINDSTRING, 0, ebx
                            Pop ebx
                            On eax = &LB_ERR,
                            Call 'USER32.SendMessageA' D$H.DLLsProcList,
                                                       &LB_ADDSTRING, 0, ebx
                        Pop esi, D$esi, edx, eax
                        jmp L2>
                    End_If

                    inc esi
                End_While

L2:             While B$esi <> al
                    inc esi | On esi >= edx, jmp L9>
                End_While

            .End_If

        ..End_If

L8:     inc esi

    .End_While

L9: ret


InitExportsProcList:
    Mov esi D$CodeSource, edx D$STRUCT.EditData@SourceEnd, B$DLLsFoundInSource &FALSE

    .While esi < edx
        Mov eax D$esi
        ..If al = '"'
            inc esi
            While B$esi <> '"'
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ..Else_If al = "'"
            inc esi
            While B$esi <> "'"
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ..Else_If eax = MLC
            add esi 4
            While D$esi <> MLC
                inc esi | On esi = edx, jmp L9>>
            End_While
            add esi 4

        ..Else_If al = ';'
                While B$esi >= SPC | inc esi | End_While

        ..Else_If ax = '::'
                        Mov B$DLLsFoundInSource &TRUE
                        Push eax, edx, D$esi, esi
                            Mov B$esi 0
                            While B$esi-1 > SPC | dec esi | End_While

                            Call 'USER32.SendMessageA' D$H.DLLsProcList,
                                                       &LB_ADDSTRING, 0, esi
                        Pop esi, D$esi, edx, eax
        ..End_If

        inc esi

    .End_While
L9: ret


[CurrentSelectionInDLLsList: D$ ?]

ViewDllFunctionList:
    Call 'USER32.SendMessageA' D$H.DLLsProcFunctionsList, &LB_RESETCONTENT, 0, 0

    Call 'USER32.SendMessageA' D$H.DLLsProcList, &LB_GETCURSEL, 0, 0
    Mov D$CurrentSelectionInDLLsList eax

    Mov esi D$CodeSource, edx D$STRUCT.EditData@SourceEnd

    ..While esi < edx
        Mov eax D$esi
        On al = 'C', or eax 020202020 | On al = 'c', or eax 020202020
        On al = 'J', or eax 020202020 | On al = 'j', or eax 020202020
        ...If al = '"'
            inc esi
            While B$esi <> '"'
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ...Else_If al = "'"
            inc esi
            While B$esi <> "'"
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ...Else_If eax = MLC
            add esi 4
            While D$esi <> MLC
                inc esi | On esi = edx, jmp L9>>
            End_While
            add esi 4

        ...Else_If al = ';'
                While B$esi >= SPC | inc esi | End_While

        ...Else_If eax = 'jmp '
            add esi 3 | jmp L1>

        ...Else_If eax = 'Call'
            add esi 4
L1:         While B$esi = SPC | inc esi | End_While
            Mov al B$esi
            ..If al = "'"
L1:             inc esi | Mov ebx esi
                .While B$esi <> al
                    On B$esi <= SPC, jmp L2>>
                    .If B$esi = '.'
                        Push eax, ebx, edx, D$esi, esi
                            Mov B$esi 0
                                Call Lb_FindString D$H.DLLsProcList, ebx
                            Mov ecx eax
                        Pop esi, D$esi, edx, ebx, eax

                        On ecx <> D$CurrentSelectionInDLLsList, jmp L2>>

                            inc esi | Mov ebx esi

                            While B$esi <> al
                                inc esi | On esi >= edx, jmp L9>>
                            End_While
                            Push D$esi, esi, edx
                                Mov B$esi 0
                                Push ebx
                                    Call Lb_FindString D$H.DLLsProcFunctionsList, ebx
                                Pop ebx

                                If eax = &LB_ERR
                                    Call 'USER32.SendMessageA' D$H.DLLsProcFunctionsList,
                                                               &LB_ADDSTRING, 0, ebx
                                    Call 'USER32.SendMessageA' D$H.DLLsProcFunctionsList,
                                                               &LB_SETITEMDATA, eax, 1
                                Else
                                    Push eax
                                    Call 'USER32.SendMessageA' D$H.DLLsProcFunctionsList,
                                                               &LB_GETITEMDATA, eax, 0
                                    inc eax
                                    Pop edx
                                    Call 'USER32.SendMessageA' D$H.DLLsProcFunctionsList,
                                                               &LB_SETITEMDATA, edx, eax
                                End_If

                            Pop edx, esi, D$esi
                            jmp L3>
                    .End_If

                    inc esi
                .End_While

L2:             While B$esi <> al
                    inc esi | On esi >= edx, jmp L9>
                End_While

            ..Else_If al = '"'
                jmp L1<<

            ..End_If

        ...End_If

L3:     inc esi

    ..End_While

L9: ret


Proc Lb_FindString:

    Argument @H.Lb, @Pointer
    Local @FirstFound
    Uses esi, edi, edx

        Mov edx 0-1, D@FirstFound edx

L0:     Push edx
            Call 'USER32.SendMessageA' D@H.Lb, &LB_FINDSTRING, edx, D@Pointer
        Pop edx

        .If eax <> &LB_ERR
            Push eax
                Call 'USER32.SendMessageA' D@H.Lb, &LB_GETTEXT, eax, SearchString
            Pop edx

            Mov esi D@Pointer, edi SearchString | lodsb
            and al UPPERCASEMASK | and B$edi UPPERCASEMASK

            While al = B$edi
                If al = 0
                    Mov eax edx | ExitP
                End_If

                lodsb | inc edi
                and al UPPERCASEMASK | and B$edi UPPERCASEMASK
            End_While

            If D@FirstFound = 0-1
                Mov D@FirstFound edx | inc edx | jmp L0<
            Else_If edx = D@FirstFound
                Mov eax &LB_ERR
            Else
                inc edx | jmp L0<
            End_If

        .End_If
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[H.ExportDialog: D$ ?]

; Tag Dialog 1101

Proc ViewSourceExportsProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_COMMAND
        Mov eax D@wParam | and eax 0FFFF

        ..If eax = &IDCANCEL
            Mov D$H.ExportDialog 0
            Call 'USER32.EndDialog' D@hwnd, 0

        ..Else
            .If W@wParam = 10
                If W@wParam+2 = &LBN_SELCHANGE
                    Call ExportFunctionFindFirst
                End_If

            .End_If

        ..End_If

    ...Else_If D@msg = &WM_INITDIALOG
        Move D$H.ExportDialog D@hwnd

        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon

        Call 'USER32.GetDlgItem' D@hwnd, 10 | Mov D$H.DLLsProcList eax

        Call RestoreRealSource
        Call InitExportsProcList
        Call SetPartialEditionFromPos

        If B$DLLsFoundInSource = &FALSE
            Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'No Export Function found in this Source' EOS},
                                     {B$ 'Failure:' EOS}, 0
            Call 'USER32.EndDialog' D@hwnd, 0
        End_If

        popad | Mov eax &FALSE | ExitP

    ...Else
        popad | Mov eax &FALSE | ExitP

    ...End_If

L8: popad | Mov eax &TRUE
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; DLLs Scan.

ExportScanner:
    Call GetExportScannerFile

    ..If D$SfFileMemory <> 0
        Push D$UserPeStart
            Move D$UserPeStart D$SfFileMemory

            Call StartScan

            .If eax <> 0
                Call ReAlignPE | Call GetExportDirPointer

                If D$NumberOfDisExportedFunctions <> 0
                    Call 'USER32.DialogBoxParamA' D$H.Instance, 30500, &NULL,
                                                  ViewExport, &NULL

                Else
                    jmp L7>

                End_If
            .Else
L7:             Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'No Export found in this File' EOS}, SfFile, 0

            .End_If

            Call VirtualFree UserPeStart
          ; D$UserPeStart and not D$SfFileMemory, because of the switch in 'ReAlignPE'

        Pop D$UserPeStart

    ..End_If
ret


; Simplified version of 'StartNewDisFile', reuse the same Variables:

StartScan:
    Mov edi FirstDisVirtualData, eax 0 | while edi < LastDisVirtualData | stosd | End_While

    Mov D$DisPeOrigine 0 | GetPeHeader PeHeaderPointer
    Mov eax D$eax | sub eax 080 | Mov D$DisPeOrigine eax
  ; (080 is the RosAsm Data 'PeHeaderPointer')

    GetPeHeader PeHeader

    ..If eax < D$SfFileMemory
        Mov eax 0

    ..Else_If eax > D$SfFileMemoryEnd
        Mov eax 0

    ..Else
        Mov eax D$eax

        .If eax = D$PeHeader
            GetPeHeader NumberOfSections | movzx eax W$eax

            If eax <> 0
                Mov D$DisNumberOfSections eax
                GetPeHeader ImageBase | Mov ebx D$eax, D$DisImageBase ebx
                Move D$DisRvaSectionAlignment D$eax+4, D$DisFileSectionAlignment D$eax+8
            End_If

        .Else
            Mov eax 0

        .End_If

    ..End_If
ret


; SImplified version of 'CheckExport':

GetExportDirPointer:
    GetPeHeader SectionTable | Mov edx D$eax

    Mov D$NumberOfDisExportedFunctions 0

    If edx <> 0
        Mov ecx D$DisNumberOfSections

        GetPeHeader SectionsHeaders

L0:     Mov ebx D$eax+SECTION_RVA |  cmp edx ebx | jb L1>
            add ebx D$eax+SECTION_FILESIZE | cmp edx ebx | jb L2>

L1:     add eax SECTIONHEADERSIZE | loop L0<
            ret

L2:     add edx D$UserPeStart | Mov eax D$edx+(5*4), ebx D$edx+(6*4)
        On ebx > eax, Mov eax ebx
        Move D$NumberOfDisExportedFunctions eax
    End_If
ret


[OPENFILENAME.SF:
 @lStructSize: D$ len
 @hwndOwner: D$ 0
 @hInstance: D$ 0
 @lpstrFilter: D$ SfFilter
 @lpstrCustomFilter: D$ 0
 @nMaxCustFilter: D$ 0
 @nFilterIndex: D$ 1
 @lpstrFile: D$ SfFile
 @nMaxFile: D$ &MAX_PATH
 @lpstrFileTitle: D$ 0
 @nMaxFileTitle: D$ 0
 @lpstrInitialDir: D$ 0
 @lpstrTitle: D$ 0
 @Flags: D$ &OFN_CREATEPROMPT__&OFN_EXPLORER__&OFN_HIDEREADONLY__&OFN_LONGNAMES__&OFN_NONETWORKBUTTON__&OFN_OVERWRITEPROMPT__&OFN_PATHMUSTEXIST
 @nFileOffset: W$ 0
 @nFileExtension: W$ 0
 @lpstrDefExt: D$ 0
 @lCustData: D$ 0
 @lpfnHook: D$ 0
 @lpTemplateName: D$ 0]

[SfFilter: B$ 'Module Name' EOS, '*.*' EOS, 0]
[SfFile: B$ ? # &MAX_PATH]
[H.SfFile: D$ ?
 SfFileLen: D$ ?
 SfFileMemory: D$ ?
 SfFileMemoryEnd: D$ ?]

GetExportScannerFile:
    Mov D$SfFile 0, D$SfFileMemory 0
    Move D$OPENFILENAME.SF@hwndOwner D$H.MainWindow, D$OPENFILENAME.SF@hInstance D$H.Instance
    Call 'Comdlg32.GetOpenFileNameA' OPENFILENAME.SF

    ..If D$SfFile <> 0
        Call 'KERNEL32.CreateFileA' SfFile,
                                    &GENERIC_READ, &FILE_SHARE_READ__&FILE_SHARE_WRITE,
                                    0, &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, &NULL

        .If eax = &INVALID_HANDLE_VALUE

            Call MessageBox D$BusyFilePtr

ret

        .Else
            Mov D$H.SfFile eax
            Call 'KERNEL32.GetFileSize' eax, 0 | Mov D$SfFileLen eax

            Call VirtualAlloc SfFileMemory,
                              D$SfFileLen

            Mov eax D$SfFileMemory | add eax D$SfFileLen | Mov D$SfFileMemoryEnd eax

            Call 'KERNEL32.ReadFile' D$H.SfFile, D$SfFileMemory D$SfFileLen,
                                     NumberOfReadBytes, 0

            Call 'KERNEL32.CloseHandle' D$H.SfFile

          ; Is it a PE?
            Mov eax D$SfFileMemory | On W$eax <> 'MZ', jmp L7>
            sub eax DosHeader | add eax PeHeaderPointer
            Mov ebx D$eax, eax D$SfFileMemory | add eax ebx
            On eax > D$SfFileMemoryEnd, jmp L7>
            On eax < D$SfFileMemory, jmp L7>
            On W$eax <> 'PE', jmp L7>

        .End_If
    ..End_If
ret

L7: Call MessageBox D$NotPeExePtr

    Call VirtualFree SfFileMemory

ret


[LV_COLUMN:
 @imask: D$ &LVCF_TEXT__&LVCF_WIDTH__&LVCF_FMT  ;__&LVCF_SUBITEM
 @fmt: D$ &LVCFMT_LEFT
 @cx: D$ 0
 @pszText: D$ 0
 @cchTextMax: D$ 0
 @iSubItem: D$ 0
 @iImage: D$ 0
 @iOrder: D$ 0]

[LV_ITEM:
 @imask: D$ &LVIF_TEXT
 @iItem: D$ 0
 @iSubItem: D$ 0
 @state: D$ 0
 @stateMask: D$ 0
 @pszText: D$ ExportViewBuffer
 @cchTextMax: D$ 0
 @iImage: D$ 0
 @lParam: D$ 0
 @iIndent: D$ 0]

[H.SfList: D$ ?]

[ExportViewBuffer: D$ ? # 20]

[AfterExportViewBuffer: D$ ?]

; Tag Dialog 30500

Proc ViewExport:
    Arguments @hwnd, @msg, @wParam, @lParam
    Structure @RECT 16, @leftDis 0,  @topDis 4,  @rightDis 8,  @bottomDis 12

    pushad

    ...If D@msg = &WM_COMMAND
        Mov eax D@wParam | and eax 0FFFF
        ..If eax = &IDCANCEL
            Call 'USER32.EndDialog' D@hwnd, 0

        ..Else
            Call 'USER32.SendDlgItemMessageA' D@hwnd, 10, &EM_SETSEL, 0-1, 0

        ..End_If

    ...Else_If D@msg = &WM_INITDIALOG

        Call 'USER32.GetDlgItem' D@hwnd, 10 | Mov D$H.SfList eax

        Call 'USER32.GetClientRect' D$H.SfList D@RECT
        Mov eax D@rightDis | sub eax D@leftDis | Mov D@bottomDis eax
        shr eax 3 | Mov D$LV_COLUMN@cx eax | sub D@bottomDis eax

        Push eax
            Mov D$LV_COLUMN@pszText {B$ 'Ordinal' EOS}
            Call 'USER32.SendMessageA' D$H.SfList, &LVM_INSERTCOLUMN, 0, LV_COLUMN

            shl D$LV_COLUMN@cx 1 | Mov eax D$LV_COLUMN@cx | sub D@bottomDis eax
            Mov D$LV_COLUMN@pszText {B$ 'Relative Address' EOS}
            Call 'USER32.SendMessageA' D$H.SfList, &LVM_INSERTCOLUMN, 1, LV_COLUMN

            Move D$LV_COLUMN@cx D@bottomDis
        Pop eax

        Mov D$LV_COLUMN@pszText {B$ 'Name' EOS}
        Call 'USER32.SendMessageA' D$H.SfList, &LVM_INSERTCOLUMN, 2, LV_COLUMN

      ; 'ExportSectionComments'

        GetPeHeader SectionTable | Mov eax D$eax | add eax D$UserPeStart

        Push eax
            Mov eax D$eax+(3*4) | add eax D$UserPeStart
            If eax > D$UserPeStart
                On eax < D$UserPeEnd,
                        Call 'USER32.SendMessageA', D@hwnd, &WM_SETTEXT, 0, eax
            End_If
        Pop eax

        Push eax
            Mov ebx D$eax+(5*4), eax D$eax+(6*4)
            On ebx > eax, Mov eax ebx
            Call 'USER32.SendMessageA' D$H.SfList, &LVM_SETITEMCOUNT, eax, 0
        Pop eax

      ; Number of Functions:
        Mov ecx D$eax+(5*4) | On D$eax+(6*4) > ecx, Mov ecx D$eax+(6*4)
      ; Pointer to ExportAdressesTable:
        Mov ebx D$eax+(7*4) | On ebx <> 0, add ebx D$UserPeStart
      ; Pointer to ExportNamesTable:
        Mov esi D$eax+(8*4) | On esi <> 0, add esi D$UserPeStart
      ; Pointer to ExportOrdinals:
        Mov edx D$eax+(9*4) | On edx <> 0, add edx D$UserPeStart

        On esi = edx, Mov esi 0

        Mov D$LV_ITEM@iItem 0

L0:   ; Write the Ordinal:
        ..If edx <> 0
            Mov edi ExportViewBuffer, D$LV_ITEM@iSubItem 0
            Push eax, ebx
                movzx eax W$edx | add edx 2 | Call WriteEax | Mov B$edi 0
            Pop ebx, eax
            pushad
                Call 'USER32.SendMessageA' D$H.SfList, &LVM_INSERTITEM, 0, LV_ITEM
            popad
        ..End_If

      ; Write the Relative Address:
        ..If ebx <> 0
            Mov edi ExportViewBuffer
            Mov eax D$ebx
            If eax = 0
                Call 'USER32.SendMessageA' D$H.SfList, &LVM_DELETEITEM,
                                           D$LV_ITEM@iItem, 0
                jmp L7>>
            End_If
            add ebx 4  | Push ebx | Call WriteEax | Pop ebx
            Mov B$edi 0

            pushad
                Mov D$LV_ITEM@iSubItem 1
                Call 'USER32.SendMessageA' D$H.SfList, &LVM_SETITEM, 0, LV_ITEM
            popad
        ..End_If

      ; Write the Function Name:
        ..If esi <> 0
            Push esi
                Mov esi D$esi, edi ExportViewBuffer | add esi D$UserPeStart
                .If esi =< D$UserPeStart
                    Mov D$edi '???'
                .Else_If esi >= D$UserPeEnd
                    Mov D$edi '???'
                .Else
                    While B$esi <> 0
                        If B$esi < SPC
                           ; Call 'USER32.SendMessageA' D$H.SfList, &LVM_DELETEITEM,
                           ;                            D$LV_ITEM@iItem, 0
                           ; Pop esi | jmp L7>>
                           Mov D$ExportViewBuffer '???' | jmp L2>
                        End_If
                        movsb
                        If edi = AfterExportViewBuffer
                            Mov D$edi-3 '...' | jmp L2>
                        End_If
                        If esi = D$UserPeEnd
                            Mov D$edi '???' | jmp L2>
                        End_If
                    End_While | Mov B$edi 0
                .End_If
L2:         Pop esi
            add esi 4
            pushad
                Mov D$LV_ITEM@iSubItem 2
                Call 'USER32.SendMessageA' D$H.SfList, &LVM_SETITEM, 0, LV_ITEM
            popad
        ..End_If

        inc D$LV_ITEM@iItem | dec ecx | jnz L0<<

L7:     popad | Mov eax &FALSE | ExitP

    ...Else
        popad | Mov eax &FALSE | ExitP

    ...End_If

L8: popad | Mov eax &TRUE
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; GUIDs Stuff

[H.ShowGUIDs: D$ ?]

; All of this GUIDs stuff and the associated GUD file is to be used with:
;
; [COMCall | Mov eax D$#1 eax D$eax | Push #L>3 | Call D$eax+#1.#2 D$#1]

ViewGUIDs:
    If D$H.ShowGUIDs = 0
        Call 'USER32.CreateDialogParamA' D$H.Instance, 35, D$H.MainWindow, ShowGUIDsProc, &NULL
    End_If
ret


[GUIDsHelp: B$ 'GUIDs' EOS]

; Tag Dialog 35

Proc ShowGUIDsProc:
     Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ..If D@msg = &WM_COMMAND
        .If D@wParam = &IDCANCEL
L7:        Mov D$H.ShowGUIDs 0

           Call VirtualFree GUIDsFileMemory

           Call 'USER32.EndDialog' D@hwnd, 0

        .Else_If D@wParam = &IDOK
L8:         Call 'USER32.SendDlgItemMessageA' D@hwnd, 10, &LB_GETCURSEL, 0, 0
            Call 'USER32.SendDlgItemMessageA' D@hwnd, 10, &LB_GETTEXT, eax,
                                              STR.A.Trash

            Call GetGUID eax | On D$GUIDsPastingType <> 101, jmp L7<<

        .Else_If D@wParam = &IDHELP
            Call Help, B_U_AsmName, GUIDsHelp, ContextHlpMessage

        .Else_If D@wParam = 100
            Mov D$GUIDsPastingType 100

        .Else_If D@wParam = 101
            Mov D$GUIDsPastingType 101

        .Else
            Mov eax D@wParam | shr eax 16
            On eax = &LBN_DBLCLK, jmp L8<<

        .End_If

    ..Else_If D@msg = &WM_INITDIALOG
        Move D$H.ShowGUIDs D@hwnd
        Call 'USER32.GetDlgItem' D@hwnd, 10
        Call InitGUIDsView eax | On B$GUIDsInit = &FALSE, jmp L7<<

        If D$FL.SourceReady = &FALSE
            Call Disable D@hwnd 100
            Call Disable D@hwnd 101
        End_If

        On D$GUIDsPastingType = 0, Mov D$GUIDsPastingType 101

        If D$GUIDsPastingType = 100
            Call 'USER32.SendDlgItemMessageA' D@hwnd, 100, &BM_SETCHECK, &TRUE, 0
        Else
            Call 'USER32.SendDlgItemMessageA' D@hwnd, 101, &BM_SETCHECK, &TRUE, 0
        End_If

    ..Else_If D@msg = &WM_VKEYTOITEM
            If W@wParam = &VK_RETURN
                jmp L8<<

            Else_If W@wParam = &VK_ESCAPE
                jmp L7<<

            End_If

    ..Else_If D@msg = &WM_CTLCOLORLISTBOX
        Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>

    ..Else
        popad | Mov eax &FALSE | jmp L9>

    ..End_If

    popad | Mov eax &TRUE
L9: EndP
____________________________________________________________________________________________

[GUIDsFilePath: B$ ? # &MAX_PATH]

[GUIDsFileNamePointer: D$ ?
 H.GUIDsFile: D$ ?
 GUIDsFileLength: D$ ?
 GUIDsFileMemory: D$ ?
 GUIDsInit: D$ ?]

[MissingGUIDsFile: B$ "
Before using this Tool,
you have to save the GUIDs File(s)
in the RosAsmFiles Directory
(aside Equates.equ)
" EOS]

Proc InitGUIDsView:
    Argument @hwnd

    Mov esi IncludeFileName, edi GUIDsFilePath
    While B$esi <> 0 | movsb | End_While
    While B$edi-1 <> '\' | dec edi | End_While
    Mov D$GUIDsFileNamePointer edi
    Mov W$edi '*.', D$edi+2 'GUD'

    Call 'KERNEL32.FindFirstFileA' GUIDsFilePath, STRUC.FindFile

    ...If eax <> &INVALID_HANDLE_VALUE
        Call 'KERNEL32.FindClose' eax

        Mov esi STRUC.FindFile@cFileName, edi D$GUIDsFileNamePointer
        While B$esi <> 0 | movsb | End_While | Mov B$edi 0

        Call 'KERNEL32.CreateFileA' GUIDsFilePath, &GENERIC_READ,
                                    &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                    &FILE_ATTRIBUTE_NORMAL, 0
        Mov D$H.GUIDsFile eax

        Call 'KERNEL32.GetFileSize' eax, 0 | Mov D$GUIDsFileLength eax

        Call VirtualAlloc GUIDsFileMemory,
                          eax

        Call 'KERNEL32.ReadFile' D$H.GUIDsFile, D$GUIDsFileMemory,
                                 eax, NumberOfReadBytes, 0

        Call 'KERNEL32.CloseHandle' D$H.GUIDsFile

        Mov esi D$GUIDsFileMemory, edx esi | add edx D$GUIDsFileLength

        .While esi < edx
            .If B$esi = '['
                inc esi
                If B$esi = '&'
                    ;While B$esi <> '_' | inc esi | End_While |
                    inc esi
                    Mov edi STR.A.Trash
                    While B$esi <> ':' | movsb | End_While | Mov B$edi 0
                    Push edx
                        Call 'USER32.SendMessageA' D@hwnd, &LB_ADDSTRING, 0, STR.A.Trash
                    Pop edx
                End_If
            .End_If

            inc esi

        .End_While

        Mov B$GUIDsInit &TRUE

    ...Else
        Call 'USER32.MessageBoxA' D$H.MainWindow, MissingGUIDsFile, {B$ 'File not found' EOS}, 0

    ...End_If
EndP
____________________________________________________________________________________________

[GUID_MotherNamePointer: D$ ?
 SourceComment: D$ ?
 GUIDsPastingType: D$ ?]

Proc GetGUID:
    Argument @Length

    Mov D$SourceComment 0
    Mov esi D$GUIDsFileMemory, edx esi | add edx D$GUIDsFileLength

    .While esi < edx
        .If B$esi = '['
            Mov ebx esi
            inc esi
            If B$esi = '&' ;'IID_'
                ;While B$esi <> '_' | inc esi | End_While |
                inc esi
                Mov D$GUID_MotherNamePointer STR.A.Trash
                Mov edi STR.A.Trash, ecx D@Length | repe cmpsb | je L5>

            End_If

        .Else_If B$esi = ';'
          ; Example: "; SOURCE FILE -> strmf.h"
            If D$esi+2 = 'SOUR'
                On D$esi+6 = 'CE F', Mov D$SourceComment esi
            End_If

        .End_If

        inc esi

    .End_While

EndP

L5:

  ; ebx pointing to the wanted GUID.
    Mov esi ebx, edi STR.A.Trash

    If D$SourceComment <> 0
        Push esi
            Mov esi D$SourceComment
            While B$esi <> CR | movsb | End_While
            Mov D$edi CRLF2 | add edi 4
        Pop esi
    End_If

  ; Copy the GUID Data, with the Sizes Markers:
    Mov B$edi '[' | inc edi | add esi 2
    While B$esi <> ':' | movsb | End_While | Movsb

    Mov D$edi ' D$ ' | add edi 4
    While B$esi = SPC | inc esi | End_While
    Call MovsbHexa

    Mov D$edi ' W$ ' | add edi 4
    While B$esi = SPC | inc esi | End_While
    Call MovsbHexa

    Mov D$edi ' W$ ' | add edi 4
    While B$esi = SPC | inc esi | End_While
    Call MovsbHexa

    Mov D$edi ' B$ ' | add edi 4
    .While B$esi <> ']'
        While B$esi = SPC | inc esi | End_While
        Call MovsbHexa
        Mov B$edi SPC | inc edi
    .End_While
    Mov B$edi-1 ']'
    While B$esi <> CR | inc esi | End_While

    Mov D$edi CRLF2 | add edi 4
    While B$esi <= SPC  | inc esi | End_While

  ; Copy the other stuff:
    .While esi < edx
        If W$esi = '[.'
            Push edx
              ; Skip the "IID_" thingies:
                Mov eax D$GUID_MotherNamePointer
                While B$eax <> '_' | inc eax | End_While | inc eax
                Mov D$GUID_MotherNamePointer eax
                Call BuildGUIDvTable | Call InsertGUIDsObjectHandle
            Pop edx
        Else_If W$esi = '[&'
            jmp L5>
        Else_If B$esi = ';'
            While B$esi <> CR | inc esi | End_While | add esi 2
        Else
            movsb
        End_If
    .End_While

L5: Mov B$edi 0

    Push D$FL.BlockInside,
         D$LP.BlockEndText,
         D$LP.BlockStartText

        Mov D$FL.BlockInside &TRUE,
            D$LP.BlockStartText STR.A.Trash

        sub edi (1*ASCII) | Mov D$LP.BlockEndText edi

        Call ControlC

        If D$GUIDsPastingType = 101

            Mov D$FL.BlockInside &FALSE

            Call ControlV | Call AskForRedrawNow

        End_If

    Pop D$LP.BlockStartText,
        D$LP.BlockEndText,
        D$FL.BlockInside

EndP


InsertGUIDsObjectHandle:
  ; Insert the Object Handle Declaration:
    Mov D$edi CRLF2 | add edi 4

    Mov B$edi '[' | inc edi
    Push esi
        Mov esi D$GUID_MotherNamePointer
        ;While B$esi <> '_' | inc esi | End_While | inc esi
        While B$esi <> 0 | movsb | End_While
        Mov B$edi ':' | inc edi
    Pop esi
    Mov D$edi ' ?]' | add edi 3
ret
____________________________________________________________________________________________

; Just to turn all GUIDs' hexa numbers upper cases:

MovsbHexa:
L0: lodsb
    .If al > SPC
        If al = ']'
            dec esi | ret
        Else_If al < 'Z'

        Else
            sub al SPC
        End_If

        stosb | jmp L0<
    .End_If
ret
____________________________________________________________________________________________

[vTableQueryInterface: B$ '.QueryInterface' EOS]
[vTableAddRef: B$ '.AddRef' EOS]
[vTableRelease: B$ '.Release' EOS]

BuildGUIDvTable:
    Mov D$GUIDDisplacementEquate 0
  ; Copy the '[':
    movsb
    Push esi

        Push esi | Mov esi D$GUID_MotherNamePointer | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi

        Push esi | Mov esi vTableQueryInterface | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi

        Call WriteGUIDDisplacementEquate
        Mov B$edi SPC | inc edi

        Push esi | Mov esi D$GUID_MotherNamePointer | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi

        Push esi | Mov esi vTableAddRef | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi

        Call WriteGUIDDisplacementEquate
        Mov B$edi SPC | inc edi

        Push esi | Mov esi D$GUID_MotherNamePointer | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi

        Push esi | Mov esi vTableRelease | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi

        Call WriteGUIDDisplacementEquate
    Pop esi

    .While B$esi <> ']'
        Mov B$edi SPC | inc edi

        Push esi | Mov esi D$GUID_MotherNamePointer | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi

        While B$esi <> CR
            Mov al B$esi, B$edi al | inc edi | inc esi
            If al = ']'
                dec edi | Call WriteGUIDDisplacementEquate
                sub edi 2 | Mov B$edi ']' | inc edi | ret
            End_If
        End_While

        Call WriteGUIDDisplacementEquate

        While B$esi <= SPC | inc esi | End_While
    .End_While
ret
____________________________________________________________________________________________

[GUIDDisplacementEquate: D$ ?]

WriteGUIDDisplacementEquate:
    Push ebx, edx, esi
        Mov B$edi SPC | inc edi
        Mov eax D$GUIDDisplacementEquate
        Call WriteEax
        add D$GUIDDisplacementEquate 4
    Pop esi, edx, ebx
    Mov W$edi CRLF | add edi 2
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Dialog          ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

@DialogMenuComment:
;;
 Main at: 'InitDialogEdition' / 'EditDialogBoxProc' / 'EditedDialogBoxProc'
          'CloseDialogEdition'
          'HelpDialog' / 'HelpDialogProc'

'InstallHook' 'MouseProc' 'ShowDialogResult'


                                  Dialog Editor

 Menus in Dialogs are stored either as "0" (no menu) or as, for exemple, "FFFF 0D8F"
 (menu with ID 0D8F). When Win runs a Dialog, it read the ID according menu in resources.
 As the "runing resources" in RosAsm Dialog Editor is nothing but RosAsm resources itselves
 (and not the futur resources of the futur PE we are writing), we can't set the wished
 value in the edited dialog template. Instead, we have to "LoadMenuIndirectA" / "SetMenu"
 inside the "EditedDialogBoxProc". (So do we in 'WhatMenu' > 'WhatMenuProc' > 'SetTestMenu'
 routine). So, we have a difficult job to do with 2 menus IDs instead of one (and hide any
 in "EditedDialogBoxData"):

 - When an existing Dialog is loaded, we save the true menu ID in D$DialogMenuTrueID.
   Then we ask Win for a handle for the menu template (for "SetMenu")
   The Dialog box template, then, has menu set at "0"...
 - In the Dialog-Main-Edit-Control (Editor), we show to the user the 'true' ID
 - As Menu are usually choosen by "WhatMenu" routine, we store the 'runing ID' in
   'D$ActualMenutestID'.

 So:  >  ActualMenutestID = Menu ID used by RosAsm to activate a menu.
      >  DialogMenuTrueID = Menu ID really saved in Editied PE Resources.

 A similar problem arises for Dialog Class. As soon as a class is written by user inside
 the template, the Dialog would desappear from screen (as not registered by RosAsm...).
 So, have we to hide this record from the editor internal Template and restore it before
 saving either in ClipBoard or in Resources. As the record is a string -and not a number-
 i choose to simply save it in a string table ('ClassRecord'), to restored it at saving
 time.
;;
 _______________________________________________________________________________________
 _______________________________________________________________________________________
 _______________________________________________________________________________________

[DialogMenuTrueID: D$ ?]

[TypeFace: B$ 'Arial' EOS]
[Helv: B$ 'Helv' EOS]

[H.MyFont: D$ ?]

CreateFontForDialogEdition:
    Call 'GDI32.CreateFontA' 10, 5, 0, 0, 400, 0, 0, 0, 1,   ;  DEFAULT_CHARSET 1  OEM_CHARSET 255
                             0, 0, 0, 0, TypeFace
    Mov D$H.MyFont eax
ret

_______________________________________________________________________________________
_______________________________________________________________________________________

[MaxTemplateText 0FFFF]

[D_button 080  D_Edit 081  D_Static 082  D_ListBox 083  D_ScrollBar 084  D_ComboBox 085]

[ID_Ilist 101  ID_IpopUpMenu 102]

; 080=button / 081=Edit / 082=Static / 083=ListBox / 084=ScrollBar / 085=ComboBox

; This is the text default template that user can see in in the main editor list:

[NewDialogTemplateText: D$ ?]
[ClassRecord: D$ ? # 20]

[DefaultDialogTemplateText:
 B$
 'D$ 90C408C2 ; Style' 0                 ; style
 'D$ 00000000 ; ExStyle' 0               ; extended style
 'U$ 0000 0000 0000 00DC 00C8 ; Dim' 0   ; control-number, x, y, width, hight
 '0 ;      no Menu' 0                    ; no menu >>> 0. If Menu > 0FFFF ID
 '"" 0 ; Class' 0                        ; class 0 > default
 '"New Dialog" 0 ; Title' 0              ; title
 '08 "Helv" 0 ; Font'  0 0 255           ; font

 DefaultDialogTemplateTextLen: len]

; Default Visible text in Editor when adding/inserting a new Control:

[NewDialogControlText: B$
 'D$ 50000000 ; Style' 0          ; style
 'D$ 00000000 ; ExStyle' 0        ; extended style
 'U$ 0000 0000 0038 0018 ; Dim' 0 ; x y w h
 '0000 ; ID' 0                    ; ID
 'FFFF 0080 ; Class' 0            ; Predefined class / 080=button
 '"New Control" 0 ; Title' 0      ; title
 '0 ; No creation data' 0 0 255   ; no creation data
 DefaultControlLenght: len]
; len = 07E 126 Octets // 'D$NewDialogTemplateText' = 010000 // 010000/07E = 520

; This is the template for edition (THE Editor):

[DialogBoxData:
 @DialogStyle: D$ &WS_VISIBLE+&WS_THICKFRAME+&DS_SYSMODAL+&DS_SETFONT+&DS_3DLOOK+&DS_MODALFRAME+&WS_POPUP+&WS_CAPTION
 @DialogExtStyle: 0

 @ControlsNumber: U$ 1
 @DialogX: 3
 @DialogY: 3
 @DialogW: 100
 @DialogH: 340                       ; control-number, x, y, width, hight
    0                               ; no menu
    0                               ; class 0 > default
 @DialogTitle: 'Dialogs Editor' EOS    ; title
 @DialogFontSize: 8
 @DialogFont: 'Helv' EOS

; controls:
; main editor list:

D$ &WS_CHILD&WS_VISIBLE+&LBS_HASSTRINGS+&LBS_NOTIFY+&WS_VSCROLL+&WS_HSCROLL+&ES_AUTOVSCROLL+&ES_AUTOHSCROLL+&WS_BORDER;+&WS_THICKFRAME

    0                        ; style / ext.style
   U$ 2 2  96 75             ; x y w h
     ID_Ilist                ; ID
     0FFFF                   ; Predefined class
     D_ListBox               ; List control for main editor
    '  ' EOS 0                 ; button title
     0]

[BaseUnits:
 BaseUnitX1: D$ ?
 BaseUnitY1: D$ ?
 BaseUnitX2: D$ ?
 BaseUnitY2: D$ ?]

[IDFstring: B$ "

    You must set the ID number of last created control.

    Unlike the Menu Editor, the Dialog Editor will not do this for you    
    and let you free of your equates choices.

    1) You are allowed to give the same ID number to several controls

    2) The Dialog Editor have no way to save your Equates Names
        nor to set them for you as the names MUST be unique.

    So >>> paper / pencil...

    " EOS]

;;
 Of no use now, but of some interrest:

 I wrote this at a time when the two dialogs (editior and edited) were redrawn after
 each modification. Now, only edited dialog is redrawn and all this is of no more use.
 But, as it have been some work..., i let it here (in case of need). This is a trick
 that gives the base unit (absolute need if we want to know where to set a dialog, but
 the direct function do NOT exist in Win api (!!!!!!!!)).
;;

;SaveDialogUserPosition:
;    ; MapDialog do this to BaseUnits values:
;    ;
;    ; left   = (left   * baseunitX) / 4
;    ; right  = (right  * baseunitX) / 4
;    ; top    = (top    * baseunitY) / 8
;    ; bottom = (bottom * baseunitY) / 8
;    ;
;    ; i only want to know baseUnits. So:
;
;    Mov D$BaseUnitX1 4, D$BaseUnitY1 8, D$BaseUnitX2 0, D$BaseUnitY2, 0     ; <<< the
;    Call 'USER32.MapDialogRect' D$Adressee BaseUnits                        ; <<< trick
;
;    Call 'USER32.GetWindowRect' D$Adressee DialogBoundingRectangle
;   ; Call 'USER32.GetDialogBaseUnits'   ; of no need
;
;   ; dialogUnitX = (pixelX * 4) / baseunitX
;   ; dialogUnitY = (pixelY * 8) / baseunitY
;
;    Mov eax D$DBRX1, edx 0
;    shl eax 2 | div D$BaseUnitX1
;    Mov W$DialogX ax
;
;    Mov eax D$DBRY1, edx 0
;    shl eax 3 | div D$BaseUnitY1
;    Mov W$DialogY ax
;ret


[PreviousControlID: 0FFFF]

; If user selected a blank separator line, we do not add > we insert:

AddOneControl:
    If W$PreviousControlID = 0
        Call 'USER32.MessageBoxA' D$H.MainWindow, IDFstring, CCFtitle, &MB_SYSTEMMODAL | ret
    Else
        Mov W$PreviousControlID 0            ; for next time test (filled -or not- by user)
    End_If

    Call 'USER32.SendMessageA' D$H.DialogList &LB_GETCURSEL eax 0
    Mov D$DialogListIndex eax

    On D$DialogListIndex > 0FFFF, Mov D$DialogListIndex 0      ; no sel. > OK  > add

    Mov eax D$DialogListIndex
    While eax >= Line_empty+1 | sub eax Line_empty+1 | End_While

    Push eax

    If eax = Line_empty
      ; Insert 'DefaultControlLenght' of 'NewDialogControlText':
        dec D$DefaultControlLenght                                  ; no 255 end mark
        Call SearchDialogLine | inc edi | Mov edx edi               ; > start of next control
        Mov al 255, ecx MaxTemplateText | repne scasb | dec edi     ; actual end
        Mov esi edi | add edi D$DefaultControlLenght                ; new end
        Mov ecx esi | sub ecx edx | inc ecx                         ; count moveable chars
        std | rep movsb | cld                                       ; make room
        Mov edi edx, esi NewDialogControlText                       ; ready for copy
        Mov ecx D$DefaultControlLenght                              ; how much
        rep movsb                                                   ; copy default control
        inc D$DefaultControlLenght                                  ; restore full lenght
    Else
      ; add:
        Mov edi D$NewDialogTemplateText, al 255, ecx MaxTemplateText
        repne scasb | dec edi
        Mov esi NewDialogControlText, ecx D$DefaultControlLenght
        rep movsb
    End_If

    Call FromTextToBinTemplate | Call ShowDialogResult | Call FillDialogListBox
    Pop eax

    If eax = Line_empty                                             ; if "insert":
        Call ScrollToInsertedControl
    Else                                                            ; if "add":
        Call ScrollDownToLastControl
    End_If

    Mov edi D$NewDialogTemplateText, al 0, ecx 200 | repne scasb
    Mov al '0' | repne scasb | add edi 2 | inc B$edi
    On B$edi > '9', add B$edi 7
    .If B$edi > 'F'
        Mov B$edi '0' | inc B$edi-1
        On B$edi-1 > '9', add B$edi-1 7
        If B$edi-1 > 'F'
            Mov B$edi-1 '0' | inc B$edi-2
            On B$edi-2 > '9', add B$edi-2 7       ; >>> up to FFF (4095 controls -enough?-)
        End_If
    .End_If
ret


ShowDialogResult:
  ; Under 98, impossible to destroy the old Window *after* having created the new one.
  ; (Works fine under 2000... too bad... ).

    Mov eax D$EditedDialogBoxData
    Push D$eax
        and D$eax 0FFF_FFFF | or D$eax &WS_VISIBLE__&WS_POPUP

        Call 'USER32.DestroyWindow' D$H.EditedDialog
        Call 'USER32.CreateDialogIndirectParamA' D$H.Instance, D$EditedDialogBoxData,
                                                 D$H.MainWindow, EditedDialogBoxProc, 0
        Mov D$H.EditedDialog eax

        Mov eax D$EditedDialogBoxData
    Pop D$eax
ret

________________________________________________________________________________________

; This is the default 'StartUp' Dialog Data you see when cliclng on [New Dialog]:
; WS_THICKFRAME turns it 'sizeable' (for editing only, striped from savings).

[EditedDialogBoxData: D$ ?]

[DefaultEditedDialogBoxData:
 D$ &WS_VISIBLE+&WS_THICKFRAME+&DS_SETFONT+&DS_SYSMODAL+&DS_MODALFRAME+&WS_POPUP+&WS_CAPTION+&DS_CENTER
    0                       ; style / extended style
 U$ 0 0 0 220 200           ; control-number, x, y, width, hight
    0                       ; no menu
    0                       ; class 0 > default
    "New Dialog" 0          ; title
    8 "Helv" 0              ; font

 DefaultEditedDialogBoxDataLenght: len]


;;
 Dialog proc for the result of edition. Clicking on a control select the dim record
 of the according Main list template part. Works only with controls that send
 some WM_COMMAND message > doesn't work on static controls. Another problem is that
 selection must not run at initialisation time > Nothing works at all until user didn't
 click on a Button. Exemple: if user first click on an Edit Control, nothing happends.
 see if we can do better later.
;;

[H.DialogEditor: D$ ?
 H.EditedDialog: D$ ?
 EditionInitFlag: D$ ?]

Proc EditedDialogBoxProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

  ; while opening and closing this dialog to show work progress to user, after
  ; some time, the menu seems destroyed (must be by Win -as bound to dialog-)
  ; > so, reinitialise. But then, the menu (visible) do not work any more
  ; in the editor. Saved data work fine....
    ...If D@msg = &WM_INITDIALOG
        Move D$H.EditedDialog D@hwnd
        Call MakeControlIDList
        Mov B$EditionInitFlag &TRUE

        Call GetDialoBaseUnits

        If D$ActualMenutestID <> 0
            Call 'USER32.DestroyMenu' D$ActualMenutestID
            Mov eax D$MenuListPtr | add eax 4
            Call 'USER32.LoadMenuIndirectA' D$eax
            Mov D$ActualMenutestID eax
            Call 'USER32.SetMenu' D@hwnd eax
        End_If

  ;  ...Else_If D@msg = &WM_CLOSE
  ;      Call 'USER32.DestroyWindow' D@hwnd

    ...Else
L8:     popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE

L9: EndP


[Text12345: B$ '1234567890' EOS]

UpdateControlDims:
    Mov eax D$Control@rcNormalPosition.left, edx 0
    shl eax 2 | div D$BaseUnitX1
    On edx >= 5, inc eax
    Mov edi Text12345 | Call DecimalToAscii
    Call 'USER32.SendMessageA' D$TABLE.H.DialogControls+4, &WM_SETTEXT, 0, Text12345
    Mov ecx D$TABLE.H.DialogControls+4 | Call WriteDimOnly

    Mov eax D$Control@rcNormalPosition.Top, edx 0
    shl eax 3 | div D$BaseUnitY1
    On edx >= 5, inc eax
    Mov edi Text12345 | Call DecimalToAscii
    Call 'USER32.SendMessageA' D$TABLE.H.DialogControls+12+4, &WM_SETTEXT, 0, Text12345
    Mov ecx D$TABLE.H.DialogControls+12+4 | Call WriteDimOnly

    Mov eax D$Control@rcNormalPosition.Right, edx 0
    sub eax D$Control@rcNormalPosition.left
    shl eax 2 | div D$BaseUnitX1
    On edx >= 5, inc eax
    Mov edi Text12345 | Call DecimalToAscii
    Call 'USER32.SendMessageA' D$TABLE.H.DialogControls+24+4, &WM_SETTEXT, 0, Text12345
    Mov ecx D$TABLE.H.DialogControls+24+4 | Call WriteDimOnly

    Mov eax D$Control@rcNormalPosition.Bottom, edx 0
    sub eax D$Control@rcNormalPosition.Top
    shl eax 3 | div D$BaseUnitY1
    On edx >= 5, inc eax
    Mov edi Text12345 | Call DecimalToAscii
    Call 'USER32.SendMessageA' D$TABLE.H.DialogControls+36+4, &WM_SETTEXT, 0, Text12345
    Mov ecx D$TABLE.H.DialogControls+36+4 | Call WriteDimOnly

    Call FromTextToBinTemplate | Call ShowDialogResult | Call FillDialogListBox
ret


;;
  For the Dialog itself, only Sizing modifications are allowed. We only set the Hight
  and width.
;;

UpdateDialogDims:
    Mov B$ModifiedControl &FALSE

    Call 'USER32.GetClientRect' D$H.EditedDialog, Control@rcNormalPosition.left

  ; Result of '.GetClientRect' >>> right > Weidth // Bottom > Hight:
    Mov eax D$Control@rcNormalPosition.Right, edx 0
    shl eax 2 | div D$BaseUnitX1
    On edx >= 5, inc eax
    Mov edi Text12345 | Call DecimalToAscii
    Call 'USER32.SendMessageA' D$TABLE.H.DialogControls+24+4, &WM_SETTEXT, 0, Text12345
    Mov ecx D$TABLE.H.DialogControls+24+4 | Call WriteDimOnly

    Mov eax D$Control@rcNormalPosition.Bottom, edx 0
    shl eax 3 | div D$BaseUnitY1
    On edx >= 5, inc eax
    Mov edi Text12345 | Call DecimalToAscii
    Call 'USER32.SendMessageA' D$TABLE.H.DialogControls+36+4, &WM_SETTEXT, 0, Text12345
    Mov ecx D$TABLE.H.DialogControls+36+4 | Call WriteDimOnly

    Call FromTextToBinTemplate | Call ShowDialogResult | Call FillDialogListBox
ret


;;
  This is the trick for retrieving the Values needed for translating Screen Coordinates
  into DialogBoxes coordinates. It take account of the Font.
  
  For X Dim, the formula is:   shl eax 2 | div D$BaseUnitX1
  For Y Dim, the formula is:   shl eax 3 | div D$BaseUnitY1
;;

GetDialoBaseUnits:
    Mov D$BaseUnitX1 4, D$BaseUnitY1 8, D$BaseUnitX2 0, D$BaseUnitY2, 0
    Call 'USER32.MapDialogRect' D$H.EditedDialog BaseUnits
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

@HookComments:
;;
  'InstallHook' is called from the Init of 'ReInitDialogEdition'. Its purpose is to
  install a Mouse Hook Procedure, 'MouseProc', that enable the Direct Mouse Edition
  of Dialog Controls Coordinates.
  
  The Coordinates of the target Cotrol are directely modified by 'MouseProc' and, for
  avoiding blinckering they are made effective only when user release the Button.
  
  Left Button is for Pos. Right Button is for Dim.
  
  When moving a Control, the Cursor is confined to the Dialog Client Rectangle.
  (not when re-sizing).
  
  As this would not mean a thing, if user left-Click on the Dialog (instead of a Control)
  Right-Click is silently subtituted, in that case.
  
  'KickDims' is run when the user releases the Mouse Button. It first select the proper
  ListBox Item for Dims, according with the target Control or with the Dialog. Then it
  runs 'SetDialogTools', that shows the Size and Pos Edition Controls in the Editor,
  and finaly calls either for 'UpdateControlDims' or for 'UpdateDialogDims'.
  
  When drawing a Control, it is replaced by a Static Control with SS_BLACKFRAME Style.
  This is for viewing, for example, the real sizes of Radio Buttons.
;;

[Control:
 @iLength: D$ len
 @flags: D$ 0
 @showCmd: D$ 0
 @ptMinPosition.x: D$ 0
 @ptMinPosition.y: D$ 0
 @ptMaxPosition.x: D$ 0
 @ptMaxPosition.y: D$ 0
 @rcNormalPosition.left: D$ 0
 @rcNormalPosition.top: D$ 0
 @rcNormalPosition.right: D$ 0
 @rcNormalPosition.bottom: D$ 0]

[H.Hook: D$ ?
 H.Hooked: D$ ?
 UserClickedOnControl: D$ ?
 UserRightClickedOnControl: D$ ?
 FromPointX: D$ ?
 FromPointY: D$ ? ? ?
 ClickFromPointX: D$ ?
 ClickFromPointY: D$ ?
 ModifiedControl: D$ ?]

[EditedDialogRectangle:
 D$ ?
 D$ ?
 D$ ?
 D$ ?]

; 'HookComments'.


Proc MouseProc:
    Arguments @nCode, @wParam, @lParam
;;
  Win Doc: 
  
  * If nCode is less than zero, the hook procedure must pass the message 
  to the CallNextHookEx function without further processing and should return the 
  value returned by CallNextHookEx. 
  
  * To enable the system to process the message, the return value must be zero. 
  To discard the message, the return value must be a nonzero value. 
  
  * If the 'CallNextHookEx' function succeeds, the return value is the value returned
  by the next hook procedure in the chain. The current hook procedure must also
  return this value.
  __________________
  
  In fact, under 98, if the MouseProc processes the Message, it *must* return a non
  zero value. Otherwise, the App hangs randomaly.
;;
    pushad

    ..If D@nCode > 07FFF_FFFF
        jmp L9>>

    ..Else_If D$H.EditedDialog = 0
      ; All of this should be no use. Just added security...
L0:     Mov al B$UserClickedOnControl | or al B$UserRightClickedOnControl
        If al <> &FALSE
            Mov B$UserClickedOnControl &FALSE, B$UserRightClickedOnControl &FALSE
            Call 'USER32.ClipCursor' &NULL
        End_If
        jmp L9>>

    ..Else
        Mov al B$UserClickedOnControl | or al B$UserRightClickedOnControl
        .If al = &FALSE
            Mov ebx D@lParam, eax D$ebx, ebx D$ebx+4
            Mov D$FromPointX eax, D$FromPointY ebx
            Mov D$ClickFromPointX eax, D$ClickFromPointY ebx
            Call 'USER32.WindowFromPoint' eax, ebx | On eax = &FALSE, jmp L0<<
            If eax <> D$H.EditedDialog
                Call 'USER32.IsChild' D$H.EditedDialog, eax | On eax = &FALSE, jmp L0<<
            End_If
        .End_If

    ..End_If
    _______________________________

    If D@wParam = &WM_LBUTTONDOWN
        Call SearchForWhatControl

    Else_If D@wParam = &WM_RBUTTONDOWN
        Call SearchForWhatControl

    End_If

    ...If D$H.Hooked <> 0
        ..If D@wParam = &WM_LBUTTONDOWN
            Mov ebx D@lParam, eax D$ebx, ebx D$ebx+4
            Mov D$FromPointX eax, D$FromPointY ebx
            Mov D$ClickFromPointX eax, D$ClickFromPointY ebx

            Mov eax D$H.EditedDialog
            If D$H.Hooked = eax
                Mov B$UserRightClickedOnControl &TRUE
            Else
                Mov B$UserClickedOnControl &TRUE
            End_If

            Call 'USER32.GetWindowPlacement' D$H.Hooked, Control

            Call ClipCursorInDialog

            popad | Mov eax &TRUE

EndP


        ..Else_If D@wParam = &WM_RBUTTONDOWN
            Mov ebx D@lParam, eax D$ebx, ebx D$ebx+4
            Mov D$FromPointX eax, D$FromPointY ebx
            Mov D$ClickFromPointX eax, D$ClickFromPointY ebx

            Mov B$UserRightClickedOnControl &TRUE

            Call 'USER32.GetWindowPlacement' D$H.Hooked, Control

            Call ClipCursorInSelected

            popad | Mov eax &TRUE

EndP

        ..Else_If D@wParam = &WM_LBUTTONUP
            Mov B$UserClickedOnControl &FALSE, B$UserRightClickedOnControl &FALSE
            Call KickDims
            Mov D$H.Hooked 0
            Call 'USER32.ClipCursor' &NULL

            popad | Mov eax &TRUE

EndP

        ..Else_If D@wParam = &WM_RBUTTONUP
L1:         Mov B$UserRightClickedOnControl &FALSE, B$UserClickedOnControl &FALSE
            Call KickDims
            Mov D$H.Hooked 0
            Call 'USER32.ClipCursor' &NULL

            popad | Mov eax &TRUE

EndP

        ..Else_If D@wParam = &WM_MOUSEMOVE
            Mov ebx D@lParam, eax D$ebx, ebx D$ebx+4
            Mov D$FromPointX eax, D$FromPointY ebx

            .If B$UserClickedOnControl = &TRUE
                Mov eax D$FromPointX | sub eax D$ClickFromPointX
                add D$Control@rcNormalPosition.left eax
                add D$Control@rcNormalPosition.right eax
                add D$ClickFromPointX eax

                Mov ebx D$FromPointY | sub ebx D$ClickFromPointY
                add D$Control@rcNormalPosition.Top ebx
                add D$Control@rcNormalPosition.Bottom ebx
                add D$ClickFromPointY ebx

                Call 'USER32.SetWindowPlacement' D$H.Hooked, Control
                Mov B$ModifiedControl &TRUE

            .Else_If B$UserRightClickedOnControl = &TRUE
                Mov eax D$FromPointX | sub eax D$ClickFromPointX
                add D$Control@rcNormalPosition.right eax
                add D$ClickFromPointX eax

                Mov eax D$FromPointY | sub eax D$ClickFromPointY
                add D$Control@rcNormalPosition.Bottom eax
                add D$ClickFromPointY eax

                Call 'USER32.SetWindowPlacement' D$H.Hooked, Control
                Mov B$ModifiedControl &TRUE

            .End_If

            popad | Mov eax &TRUE | ExitP

        ..End_If

    ...End_If

L9: popad
    Call 'USER32.CallNextHookEx' D$H.Hook D@nCode D@wParam D@lParam
EndP


; User Left-Clicked on the Edited Dialog. The 'Control' Structure contains the
; 'H.Hooked' Window dimentions.

ClipCursorInDialog:
    Call 'USER32.GetClientRect' D$H.EditedDialog RECT
    Call 'USER32.ClientToScreen' D$H.EditedDialog RECTleft
    Call 'USER32.ClientToScreen' D$H.EditedDialog RECTright

    Mov eax D$H.Hooked
    If eax = D$H.EditedDialog
      ; Target = Dialog >>> Bottom-Right limits = Screen limits, (for resizing Dialog):
        Call 'USER32.GetSystemMetrics' &SM_CXSCREEN | Mov D$RECTright eax
        Call 'USER32.GetSystemMetrics' &SM_CYSCREEN | Mov D$RECTbottom eax

    Else
      ; Target = Control
      ; >>> Bottom-Right limits = Dialog limits
      ; >>> Top-Left limits = Dialog limits - (Mouse Pos - Control Top-Left)
        Move D$STRUC.POINT+POINTX D$Control@rcNormalPosition.left
        Move D$STRUC.POINT+POINTY D$Control@rcNormalPosition.top
        Call 'USER32.ClientToScreen' D$H.EditedDialog STRUC.POINT
        Mov eax D$FromPointX | sub eax D$STRUC.POINT+POINTX
        Mov ebx D$FromPointY | sub ebx D$STRUC.POINT+POINTY
        add D$RECTleft eax | add D$RECTtop ebx

    End_If

    Call 'USER32.ClipCursor' RECT
ret


[STRUC.POINT:
 D$ ?
 D$ ?]

[EditedDialogX: D$ ?
 EditedDialogY: D$ ?]

ClipCursorInSelected:
    Mov eax D$H.Hooked | On eax = D$H.EditedDialog, jmp ClipCursorInDialog

  ; Dialog Dims:
    Call 'USER32.GetClientRect' D$H.EditedDialog RECT
    Move D$EditedDialogX D$RECTleft, D$EditedDialogY D$RECTtop
    Call 'USER32.ClientToScreen' D$H.EditedDialog EditedDialogX

  ; Control Left-Top Dims:
    Move D$RECTleft D$Control@rcNormalPosition.left
    Move D$RECTtop D$Control@rcNormalPosition.top
    Call 'USER32.ClientToScreen' D$H.EditedDialog RECTleft
    Call 'USER32.ClientToScreen' D$H.EditedDialog RECTright

  ; Target = Control >>> Limit resizing to 25/25:
    Move D$STRUC.POINT+POINTX D$Control@rcNormalPosition.right
    Move D$STRUC.POINT+POINTY D$Control@rcNormalPosition.bottom
    Call 'USER32.ClientToScreen' D$H.EditedDialog STRUC.POINT
;;
  For sizing, if the user Right-Clicks rigth upon the lower right corner, OK, but, if
  he Clicks, say, in the middle of the Control, we have to substract that 'Half-Size'
  of the control from the upper-left limit of the ClipCursor Call, to let the modification
  go down to the minimum allowed size:
;;
    Mov ebx D$EditedDialogX
    Mov eax D$STRUC.POINT+POINTX | sub eax D$FromPointX
    sub eax D$MinimumX
    sub D$RECTleft eax ;| add D$RECTleft 25
  ; Don't let the Mouse go outside the Dialog, in cases of compensation.
    On D$RECTleft < ebx, Mov D$RECTleft ebx

    Mov ebx D$EditedDialogY
    Mov eax D$STRUC.POINT+POINTY | sub eax D$FromPointY
    sub eax D$MinimumY
    sub D$RECTtop eax ;| add D$RECTtop 25
  ; Don't let the Mouse go outside the Dialog, in cases of compensation.
    On D$RECTtop < ebx, Mov D$RECTtop ebx

    Call 'USER32.ClipCursor' RECT
ret

____________________________________________________________________________________________

; 'HookComments'

Proc InstallHook:
    Call 'KERNEL32.GetCurrentThreadId'
    Call 'USER32.SetWindowsHookExA' &WH_MOUSE, MouseProc, &NULL, eax
    Mov D$H.Hook eax
EndP


Proc UninstallHook:
    On D$H.Hook <> 0, Call 'USER32.UnhookWindowsHookEx' D$H.Hook
    Mov D$H.Hook 0
EndP


;;
  Force the New Dims and Pos (by Mouse action) to be displayed and updated (by calling
  either 'UpdateControlDims' or 'UpdateDialogDims':
;;

KickDims:
    Mov eax D$H.Hooked

    .If eax <> D$H.EditedDialog
        Call 'USER32.GetDlgCtrlID' D$H.Hooked

        Mov edi ControlsIDlist, ecx ControlsIDlistdWords
        repne scasd

L1:     If ecx > 0
            Mov eax ControlsIDlistdWords
            sub eax ecx                         ; eax = ID list position (in ControlsIDlist)
            Mov ecx Line_empty+1 | imul eax ecx ; what control dim
            Push eax
            Call 'USER32.SendMessageA' D$H.DialogList &LB_SETTOPINDEX eax 0 ; Pos
            Pop eax | add eax Line_Dim
            Call 'USER32.SendMessageA' D$H.DialogList &LB_SETCURSEL eax 0   ; select
            Call SetDialogTools
            On B$ModifiedControl = &TRUE, Call UpdateControlDims
        End_If

    .Else
        Call 'USER32.SendMessageA' D$H.DialogList &LB_SETTOPINDEX 0 0
        Call 'USER32.SendMessageA' D$H.DialogList &LB_SETCURSEL Line_Dim 0

        Call SetDialogTools

        On B$ModifiedControl = &TRUE, Call UpdateDialogDims
    .End_If
ret

____________________________________________________________________________________________

;;
  User has Clicked down on a Control in the Edited Dialog. We search in 
  'D$EditedDialogBoxData' for what Control.
  
  D$FromPointX, D$FromPointY hold the Mouse coordinates.
;;

[HookedID: D$ ?
 HookedControlStyle: D$ ?
  HookedControlClass: D$ ?]

[HookedControlStylePtr: D$ ?
 HookedControlClassPtr: D$ ?
 ClassNameInside: D$ ?]

SearchForWhatControl:
    Push D$FromPointX, D$FromPointY

        Call 'USER32.GetWindowRect' D$H.EditedDialog EditedDialogRectangle

        Mov eax D$FromPointX
        cmp eax D$EditedDialogRectangle | jb L9>>
        cmp eax D$EditedDialogRectangle+8 | ja L9>>
        Mov eax D$FromPointY
        cmp eax D$EditedDialogRectangle+4 | jb L9>>
        cmp eax D$EditedDialogRectangle+12 | ja L9>>

        Mov eax D$EditedDialogRectangle | sub D$FromPointX eax
        Mov eax D$EditedDialogRectangle+4 | sub D$FromPointY eax
        Mov ebx D$EditedDialogRectangle+12 | sub ebx eax
        Push ebx
        Call 'USER32.GetClientRect' D$H.EditedDialog EditedDialogRectangle
        Pop ebx
        sub ebx D$EditedDialogRectangle+12 | sub D$FromPointY ebx


        Mov D$BaseUnitX1 4, D$BaseUnitY1 8, D$BaseUnitX2 0, D$BaseUnitY2, 0     ; <<< the

        Call 'USER32.MapDialogRect' D$H.EditedDialog BaseUnits               ; <<< trick

        Mov eax D$FromPointX, edx 0 | shl eax 2 | div D$BaseUnitX1 | Mov D$FromPointX eax
        Mov eax D$FromPointY, edx 0 | shl eax 3 | div D$BaseUnitY1 | Mov D$FromPointY eax

        Mov D$HookedID 0, D$H.Hooked 0

        Mov esi D$EditedDialogBoxData

        add esi 8  ; Style // Extended Style.

        Mov eax 0 | lodsw | Mov ecx eax | cmp ecx 0 | je L8>>   ; How many Controls
        add esi (4*2)                                           ; Dims
        While W$esi <> 0 | add esi 2 | End_While | add esi 2    ; Menu.
        While W$esi <> 0 | add esi 2 | End_While | add esi 2    ; Class.
        While W$esi <> 0 | add esi 2 | End_While | add esi 2    ; Title.
        While W$esi <> 0 | add esi 2 | End_While | add esi 2    ; Font.

        AlignOn 4, esi

      ; Parse Controls (last good one = top one at that coordinate):

L0:     add esi 8  ; Style // Extended Style.

      ; Here are the searched Dims: X, Y, W, H (Words).
        Mov ax W$esi   | cmp D$FromPointX eax | jb L2>>
        Mov ax W$esi+2 | cmp D$FromPointY eax | jb L2>>
        Mov ax W$esi+4 | add ax W$esi | cmp D$FromPointX eax | ja L2>
        Mov ax W$esi+6 | add ax W$esi+2 | cmp D$FromPointY eax | ja L2>
            Move W$HookedID W$esi+8

            Mov eax esi | sub eax 8 | Mov D$HookedControlStylePtr eax
            Move D$HookedControlStyle D$eax

            add eax 18 | Mov D$HookedControlClassPtr eax
            Move D$HookedControlClass D$eax

            Mov B$ClassNameInside &FALSE
            If W$eax <> 0FFFF
                Push esi
                    Mov esi eax, edi HookedControlClass
                    While W$esi <> 0
                        movsw
                    End_While
                    movsw
                Pop esi
                Mov B$ClassNameInside &TRUE
            End_If

            Mov eax 0

L2:     Call NextControl | dec ecx | jnz L0<<

        If D$HookedID <> 0
            Push ebx | Call GetSmallerReSize | Pop ebx

            Mov ebx D$HookedControlStylePtr
            Mov D$ebx &BS_PUSHBUTTON__&BS_BITMAP__&BS_FLAT__&WS_CHILD__&WS_VISIBLE
            Mov ebx D$HookedControlClassPtr, D$ebx 080_FFFF ; Button.
            On B$ClassNameInside = &TRUE, Call AdjustTitle
            Call ShowDialogResult
            Call 'USER32.GetDlgItem' D$H.EditedDialog, D$HookedID
            Mov D$H.Hooked eax

        Else
L8:         Move D$H.Hooked D$H.EditedDialog
            Mov D$MinimumX 200, D$MinimumY 50

        End_If

L9:     Pop D$FromPointY, D$FromPointX
ret


[MinimumX: D$ ?
 MinimumY: D$ ?]

GetSmallerReSize:
    Mov D$MinimumX 10, D$MinimumY 10

    Mov esi D$HookedControlStylePtr

    .If D$esi+18 = 0_81_FFFF  ; +18 >>> Class = 0FFFF 081 >>> Edit Control
        test D$esi &WS_VSCROLL ZERO L1>
            add D$MinimumX 30
L1:     test D$esi &WS_HSCROLL ZERO L2>
            add D$MinimumY 30
    .Else_If D$esi+18 = 0_83_FFFF  ; +18 >>> Class = 0FFFF 083 >>> ListBox
        add D$MinimumX 30 | add D$MinimumY 30
    .Else_If D$esi+18 = 0_85_FFFF  ; +18 >>> Class = 0FFFF 083 >>> ComboBox
        add D$MinimumX 30 | add D$MinimumY 30
    .End_If

L2: ret



; jump over Dims and search for end of Control Data. Pointer in esi:

NextControl:
  ; esi > Dims: X, Y, W, H (Words)
  ;             ID
  ;             0FFFF 0080 ou "msctls_progress32", 0
  ;             "Title", 0
  ;             0
    add esi 10

    If W$esi = 0FFFF
        add esi 4
    Else
        While W$esi <> 0 | add esi 2 | End_While | add esi 2
    End_If

    While W$esi <> 0 | add esi 2 | End_While | add esi 4

    AlignOn 4, esi
ret


; If Class Name, recover the whole length with a simulated Title (the old part of the
; Classe Name, is simply made one sigle Title with the real Title, by inserting an 'X'
; instead of the zero Class string termination:

AdjustTitle:
    Mov ebx D$HookedControlClassPtr
    While W$ebx <> 0 | add ebx 2 | End_While | Mov B$ebx 'X'
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; This is for the edited dialog proc. Used to know what control user clicked on, and
; after, make the according "dim" controls appear in the editor:

[ControlsIDlist: D$ ? # 1000]

[ControlsIDlistdWords 1000]

MakeControlIDList:
    Mov edi ControlsIDlist, eax 0, ecx ControlsIDlistdWords | rep stosd ; clear ID table
    Mov ebx ControlsIDlist
    Mov edi D$EditedDialogBoxData
    Mov edx 0, dx W$edi+8                       ; number of controls in edx
    On edx = 0, ret
    add edi 22
    Mov ax 0, ecx 100 | repne scasw
    Mov ecx 100 | repne scasw                   ; edi > end of dialog data
L0: test edi 00_11 ZERO L1>
        add edi 2                               ; > start of Control data
L1: On edx = 0, jmp L9>
    add edi 16                                  ; > ID number
    Move W$ebx W$edi | add ebx 4 | add edi 2
    If W$edi = 0FFFF                            ; type by number
        add edi 4
    Else
        Mov ax 0, ecx 100 | repne scasw         ; type by name
    End_If
    Mov ax 0, ecx 100 | repne scasw             ; control title
    add edi 2                                   ; > end of Control data
    dec edx | jmp L0<
L9: ret

_______________________________________________________________________________

; Menu for Dialog-Edition Dialog:

[H.DialogMenu: D$ ?
 DialogPopUpMenuTemplate: D$ ?
 DialogPopUpMenuExit: D$ ?]

[DETemplates: B$ 'Templates' EOS
    DEadd: B$ 'Add Control' EOS
    DEdel: B$ 'Delete Control' EOS

    DEdelMenu: B$ 'Delete Menu' EOS
    DEreplaceMenu: B$ 'Replace Menu' EOS

    DEreset: B$ 'New Dialog' EOS

 DEExit: B$ 'Exit' EOS
    DEsaveToResources: B$ 'Save to Resources and Exit' EOS
    DEsaveToClipBoard: B$ 'Save to Clipboard and Exit' EOS
    DEsaveToDisk: B$ 'Save to Disk and Exit' EOS

    DEabort: B$ 'Abort' EOS

 DEhelp: B$ 'Help' EOS]

[ID_DETemplates 500
    ID_DEadd 501
    ID_DEdel 502

    ID_DEdelMenu 503
    ID_DEreplaceMenu 504

    ID_DEreset 505

 ID_DEExit 510
    ID_DEsaveToResources 511
    ID_DEsaveToClipBoard 512
    ID_DEsaveToDisk 513

    ID_DEabort 514

 ID_DEhelp 520]

; Creates and Dispatch the menu for Dialog Edition:

CreateDialogMenu:
  ; Main Menu:
    Call 'USER32.CreateMenu' | Mov D$H.DialogMenu eax

  ; Templates PopUp:
    Call 'USER32.CreatePopupMenu' | Mov D$DialogPopUpMenuTemplate eax

    Call 'USER32.AppendMenuA' D$DialogPopUpMenuTemplate, 0, ID_DEadd, DEadd
    Call 'USER32.AppendMenuA' D$DialogPopUpMenuTemplate, 0, ID_DEdel, DEdel
    Call 'USER32.AppendMenuA' D$DialogPopUpMenuTemplate, &MF_SEPARATOR, &NULL, &NUll
    Call 'USER32.AppendMenuA' D$DialogPopUpMenuTemplate, 0, ID_DEdelMenu, DEdelMenu
    Call 'USER32.AppendMenuA' D$DialogPopUpMenuTemplate, 0, ID_DEreplaceMenu, DEreplaceMenu
    Call 'USER32.AppendMenuA' D$DialogPopUpMenuTemplate, &MF_SEPARATOR, &NULL, &NUll
    Call 'USER32.AppendMenuA' D$DialogPopUpMenuTemplate, 0, ID_DEreset, DEreset

    Call 'USER32.InsertMenuA' D$H.DialogMenu, 0,
                              &MF_BYCOMMAND__&MF_POPUP__&MF_STRING,
                              D$DialogPopUpMenuTemplate, DETemplates

  ; Exit PopUp:
    Call 'USER32.CreatePopupMenu' | Mov D$DialogPopUpMenuExit eax

    Call 'USER32.AppendMenuA' D$DialogPopUpMenuExit, 0, ID_DEsaveToResources, DEsaveToResources
    Call 'USER32.AppendMenuA' D$DialogPopUpMenuExit, 0, ID_DEsaveToClipBoard, DEsaveToClipBoard
    Call 'USER32.AppendMenuA' D$DialogPopUpMenuExit, 0, ID_DEsaveToDisk, DEsaveToDisk
    Call 'USER32.AppendMenuA' D$DialogPopUpMenuExit, &MF_SEPARATOR, &NULL, &NUll
    Call 'USER32.AppendMenuA' D$DialogPopUpMenuExit, 0, ID_DEabort, DEabort

    Call 'USER32.InsertMenuA' D$H.DialogMenu, 1,
                              &MF_BYCOMMAND__&MF_POPUP__&MF_STRING,
                              D$DialogPopUpMenuExit, DEExit

  ; Menu Help:
    Call 'USER32.AppendMenuA' D$H.DialogMenu, 0, ID_DEhelp, DEhelp

    Call 'USER32.SetMenu' D$H.DialogEditor, D$H.DialogMenu
ret

_______________________________________________________________________________
________________________________________________________________________________


FillDialogListBox:
    ; preserv Pos and Selection
    Call 'USER32.SendMessageA' D$H.DialogList &LB_GETTOPINDEX D$DialogListIndex 0
    Push eax

    Call 'USER32.SendMessageA' D$H.DialogList &LB_GETCURSEL D$DialogListIndex 0
    Push eax

    Call 'USER32.SendMessageA' D$H.DialogList &LB_RESETCONTENT 0 0     ; makes list empty

    Mov edi D$NewDialogTemplateText

L1: Push edi
      Call 'USER32.SendMessageA' D$H.DialogList &LB_ADDSTRING  0  edi   ; fill
    Pop edi
    Mov al 0, ecx 200 | repne scasb
    cmp B$edi 255 | jne L1<

    ; restore Selection and Pos:
    Pop ebx, eax
    Push ebx
    Call 'USER32.SendMessageA' D$H.DialogList &LB_SETTOPINDEX eax 0
    Pop eax
    Call 'USER32.SendMessageA' D$H.DialogList &LB_SETCURSEL eax 0
L9: ret


; Restore end mark, in case of second run:

ResetDialogListBox:
    Mov edi D$NewDialogTemplateText, ecx Line_empty+1, al 0

L0: Push ecx
        Mov ecx 200 | repne scasb
    Pop ecx
    loop L0<

    Mov B$edi 255
ret

____________________________________________________________________________________
___________________________________________________________________________________

; Main routines for dialog edition.
_____________________________________________________________________________________
_____________________________________________________________________________________

ReleaseDialogMemories:

    Call VirtualFree NewDialogTemplateText

    Call VirtualFree EditedDialogBoxData

ret


InitDialogMemory:

    Call VirtualFree NewDialogTemplateText

    Call VirtualAlloc NewDialogTemplateText,
                      010000

    Call VirtualFree EditedDialogBoxData

    Call VirtualAlloc EditedDialogBoxData,
                      010000

ret


; missing the &ICC_LINK_CLASS ?
InitDialogEdition:

    Call 'ComCtl32.InitCommonControlsEx' CodeAddressFormClassName@Init_All_Common_Controls ; added by Guga

    If D$FL.DialogEdition = &TRUE
        Call Beep | ret
    End_If
    Call InitDialogMemory

    Mov edi D$NewDialogTemplateText,
        esi DefaultDialogTemplateText,
        ecx D$DefaultDialogTemplateTextLen
    rep movsb
    Mov D$edi 0FFFFFFFF                          ; End mark

    Mov edi D$EditedDialogBoxData,
        esi DefaultEditedDialogBoxData,
        ecx D$DefaultEditedDialogBoxDataLenght
    rep movsb

    Mov edi DialogList, eax 0, ecx 300
    repne scasd | sub edi 4
    Mov D$DialogListPtr edi

    Mov D$DialogMenutrueID 0, D$ActualMenutestID 0

ReInitDialogEdition:
    Call InstallHook

    Call FromTextToBinTemplate
;;
 Little difficulty: User can check either "POPUP" or "CHILD". Results visible dialog
 must remain "POPUP/VISIBLE" because created with "CreateDialogIndirectParamA"
 (either "CHILD" or not "VISIBLE" would make it unvisible for edition. So do we
 save true Dialog Style value and set the fitting one for edition:
;;
    Mov eax D$EditedDialogBoxData
    Push D$eax
        and D$eax 0FFF_FFFF | or D$eax 0_9000_0000

        Call 'USER32.CreateDialogIndirectParamA' D$H.Instance, D$EditedDialogBoxData,
                                                 D$H.EditWindow, EditedDialogBoxProc, 0
        Mov D$H.EditedDialog eax

        Call 'USER32.DialogBoxIndirectParamA' D$H.Instance,      ; "create..." > modeless
                    DialogBoxData, 0, EditDialogBoxProc, 0      ; "Dialog..." > modal
      ; Editor Handle in 'H.DialogEditor'.

        Mov eax D$EditedDialogBoxData
    Pop D$eax

    Mov W$PreviousControlID 0FFFF

    Call UninstallHook

    Call SortDialogs
ret


[DoubleID: B$ ? # 20]

SortDialogs:
  ; ID / Ptr / Size // ...
L0: Mov esi DialogList, edi esi | add edi 12

    While D$edi <> 0
        Mov eax D$esi
        If eax > D$edi
            Exchange D$esi D$edi
            Exchange D$esi+4 D$edi+4
            Exchange D$esi+8 D$edi+8 | jmp L0<
        End_If
        add esi 12 | add edi 12
    End_While
ret

; Verify that all Dialogs have unique IDs:

[SameIdAllowed: D$ ?]

Proc CheckNotUsedId:
    Argument @ID, @Parent
    Uses esi

        On B$SameIdAllowed = &TRUE, ExitP

L0:     Mov esi DialogList

        While D$esi <> 0
            Mov eax D$esi
            If eax = D@ID
                Call WriteDecimalID, eax, DoubleID
                Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'This Dialog ID already exist' EOS},
                                          DoubleID, &MB_OK
                Mov eax &IDCANCEL | ExitP
            Else
                add esi 12 | add edi 12
            End_If
        End_While

        Mov eax &IDOK
EndP


Proc WriteDecimalID:
    Argument @Value, @Destination

    pushad
        Mov eax D@Value, edi D@Destination, ecx 10

        Mov D$edi ' ID ' | add edi 4

        Push 0-1
L0:     Mov edx 0 | div ecx | Push edx | cmp eax 0 | ja L0<

L0:     Pop eax | cmp eax 0-1 | je L9>
        add al '0' | stosb | jmp L0<

L9:     Mov B$edi 0
    popad
EndP

____________________________________________________________________________________________

[H.DialogList: D$ ?
 LastDialogListItem: D$ ?]

ScrollDownToLastControl:
  ; Scroll full down to last new added control edition:
    Call 'USER32.SendMessageA' D$H.DialogList &LB_GETCOUNT 0 0
    dec eax | Mov D$LastDialogListItem eax
    Push eax
        Call 'USER32.SendMessageA' D$H.DialogList &LB_SETTOPINDEX eax 0
    Pop eax
    sub eax 2
    Call 'USER32.SendMessageA' D$H.DialogList &LB_SETCURSEL  eax 0
ret


ScrollToInsertedControl:
    Call 'USER32.SendMessageA' D$H.DialogList &LB_GETCOUNT 0 0
    dec eax | Mov D$LastDialogListItem eax
    Mov eax D$DialogListIndex | add eax Line_Font
    Call 'USER32.SendMessageA' D$H.DialogList &LB_SETCURSEL  eax 0  ; select title
ret

[UpDownEndScroll 8]

[UserModifiedDim: D$ ?]

[FL.DialogEdition: D$ ?
 DialogLoadedFromResources: D$ ?]

; D$ControlIndex values (set by "SetDialogTools"):
;   0 > Style  1 > exStyle 2 > Dim   3 > ID   4 > Class   5 > Title   6 > Font
;   0_FFFF_FFFF if not yet or blank line.
[Line_Style 0 | Line_exStyle 1 | Line_Dim 2 | Line_ID 3 | Line_Class 4 | Line_Title 5 | Line_Font 6 | Line_empty 7]
[ProposedUpDowmChange: D$ ?] ; The UDN_DELTAPOS WM_NOTIFY Message is sent before the
; Edit Control update. I use this Message to ease differenciating between all the
; Various Edit Controls. Immidiately after 'WriteDim' has used it, it reset it to
; zero. The Value is a signed dWord.

Proc EditDialogBoxProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    .If B$OnMenuEdition = &TRUE
        If D@msg = &WM_NOTIFY
            jmp L1>
        Else_If D@msg = &WM_VSCROLL
            jmp L1>
        Else_If D@msg = &WM_COMMAND
L1:         Call 'USER32.SendMessageA' D$H.MenuEditor, &WM_COMMAND, &IDCANCEL, 0
        End_If
    .End_If

    If D$UserModifiedDim <> &FALSE
        Mov ecx D$UserModifiedDim | Call WriteDim
        Mov D$UserModifiedDim &FALSE
    End_If

    ...If D@msg = &WM_NOTIFY
        Mov ebx D@lParam, eax D$ebx+8     ; user click and hold on Updown in Dim edition
        If eax = &UDN_DELTAPOS
            Mov eax D$ebx, edi TABLE.H.DialogControls, ecx 12 | repne scasd
            sub edi 8 | Mov ecx D$edi               ; each "dim": string / edit / UpDown
            Move D$ProposedUpDowmChange D$ebx+16    ; This is the proposed change (signed dWord)
            Call WriteDim
            Call 'USER32.SetForegroundWindow' D$H.DialogEditor
            popad | Mov eax &FALSE | jmp L9>>
        End_If

    ...Else_If D@msg = &WM_VSCROLL        ; user clicked and release Updown in Dim edition
        Mov eax D@wParam | and eax UpDownEndScroll | jz C9>
          Mov eax D@lParam, edi TABLE.H.DialogControls, ecx 12 | repne scasd
          sub edi 8 | Mov ecx D$edi           ; each "dim": string / edit / UpDown
          Mov D$UserModifiedDim ecx
          Call WriteDim
          Call 'USER32.SetForegroundWindow' D$H.DialogEditor

; ID_DEadd 3  ID_DEdel 4  ID_DEreset 5  ID_DEexit 6  ID_DEhelp 7

; D$StyleHelpButtonsHandles > List of Styles Help
C9:
    ...Else_If D@msg = &WM_COMMAND
        .If D@wParam = ID_DEadd
            Call AddOneControl
            Call 'USER32.SendMessageA' D$H.DialogList, &LB_GETCURSEL, 0, 0
            sub eax 2
            Call 'USER32.SendMessageA' D$H.DialogList, &LB_SETCURSEL, eax, 0
            Call SetDialogTools
            Call 'USER32.SetForegroundWindow' D$H.DialogEditor
            jmp L7>>

        .Else_If D@wParam = ID_DEdel
            Call DelOneControl
            Call 'USER32.SetForegroundWindow' D$H.DialogEditor
            jmp L7>>

        .Else_If D@wParam = ID_DEdel_Menu
            Call SearchDialogLine
            If D$edi = 'FFFF'
                Mov D$ActualMenutestID 0, D$DialogMenuTrueID 0

                Push esi | Mov esi {B$ "0 ;      no Menu" EOS} | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi

                Call FromTextToBinTemplate | Call ShowDialogResult
                Call FillDialogListBox
            Else
                Call NoDialogMenu
            End_If
            jmp L7>>

        .Else_If D@wParam = ID_DEreplaceMenu
            Call SearchDialogLine
            If D$edi = 'FFFF'
                Call AddMenuToDialog
            Else
                Call NoDialogMenu
            End_If
            jmp L7>>

        .Else_If D@wParam = ID_DEreset
            Call ResetDialogListBox | Call FillDialogListBox
            Call 'USER32.SetForegroundWindow' D$H.DialogEditor
            Mov W$PreviousControlID 0FFFF
            Call FromTextToBinTemplate | Call ShowDialogResult | Call FillDialogListBox
            jmp L7>>

        .Else_If D@wParam = ID_DEhelp
L1:         Call Help, B_U_AsmName, DialogHelp, ContextHlpMessage | jmp L7>>

        .Else_If D@wParam = ID_DEsaveToResources
            Mov ebx 4 | Call ExitDialog | jmp L7>>

        .Else_If D@wParam = ID_DEsaveToClipBoard
            Mov ebx 0 | Call ExitDialog | jmp L7>>

        .Else_If D@wParam = ID_DEsaveToDisk
            Mov ebx 8 | Call ExitDialog | jmp L7>>

        .Else_If D@wParam = ID_DEabort
            Mov ebx 12 | Call ExitDialog | jmp L7>>

        .Else_If D@wParam = &IDCANCEL
            Call 'USER32.EndDialog' D@hwnd 0
            Call 'USER32.DestroyWindow' D$H.EditedDialog
            Mov D$H.DialogEditor 0, D$H.EditedDialog 0
            Mov D$FL.DialogEdition &FALSE, B$DialogLoadedFromResources &FALSE | jmp L7>>
        .End_If

        Mov eax D@wParam, ebx eax, ecx D@lParam
      ; buttons handles in ecx
        shr eax 16 | and ebx 0FFFF

        ..If ecx = D$H.DialogList
            On eax = &LBN_SELCHANGE, Call SetDialogTools

        ..Else
            .If eax = &BN_CLICKED
              ; Check button?
                On ebx = 1, jmp L7>>
              ; case of user hit [Return]
                Mov esi TABLE.H.DialogControls, ebx 0
L0:             lodsd
                If eax = ecx
                   Call WriteStyle
                Else_If eax <> 0
                  ; stop on 0 (user click, but not on a 'moveable' control)
                    add ebx 4 | jmp L0<
                End_If

                On ecx = 0, jmp L2>
                    Mov esi TABLE.H.StyleHelpButtons, ebx 0
L0:                 lodsd

              ; Ready for Styles Help ('RunDialogHelp' / 'HelpDialogProc'):
                    If eax = ecx
                        Call ShowStyleInfo
                    Else_If eax <> 0      ; stop on 0 (user click, but not on a 'moveable' control)
                        add ebx 4 | jmp L0<
                    End_If
                ;  Call 'USER32.SetForegroundWindow' D$H.DialogEditor

            .Else_If eax = &EN_CHANGE           ; Edit Box?
                If D$ControlIndex = Line_Title
                    Call WriteTitle
                Else_If D$ControlIndex = Line_ID
                    Call WriteID
                Else_If D$ControlIndex = Line_Class
                    Call WriteTitle              ; reuse for Dialog Class
                End_If
L2:             Call 'USER32.SetForegroundWindow' D$H.DialogEditor

            .Else_If eax = &LBN_SELCHANGE       ; List Box >>> font syze or type, or Class
                If D$TABLE.H.DialogControls+4 = 0
                    Call WriteClass
                Else_If ecx = D$TABLE.H.DialogControls
                    Call WriteFontType
                Else
                    Call WriteFontSize
                End_If
                Call 'USER32.SetForegroundWindow' D$H.DialogEditor

            .Else_If eax = &EN_UPDATE                  ; direct input in Dim edit control
                On D$ControlIndex = Line_Dim, Call WriteDim
                Call 'USER32.SetForegroundWindow' D$H.DialogEditor

            .End_If

        ..End_If

    ...Else_If D@msg = &WM_INITDIALOG
        Move D$H.DialogEditor D@hwnd

        Call 'USER32.GetDlgItem' D@hwnd ID_Ilist | Mov D$H.DialogList eax

        Call CreateDialogMenu

        If B$OnClipDialog = &FALSE
            Call ResetDialogListBox | Call FillDialogListBox
            Call ScrollDownToLastControl
        Else
            Call FillDialogListBox | Call ScrollDownToLastControl
            Mov B$OnClipDialog &FALSE
        End_If
        Mov D$FL.DialogEdition &TRUE

        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon

    ...Else_If D@msg = &WM_CTLCOLORLISTBOX
        jmp L1>

    ...Else_If D@msg = &WM_CTLCOLOREDIT
L1:     Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>

    ...Else
L8:     popad | Mov eax &FALSE | jmp L9>
    ...End_If

L7: popad | Mov eax &TRUE

L9: EndP

_____________________________________________________________________________________
_____________________________________________________________________________________

; Routine to show particular controls on the editor dialog, depending on what main list
; line user click.
_____________________________________________________________________________________
_____________________________________________________________________________________

[TABLE.H.DialogControls: D$ ? # 40]
[TABLE.H.StyleHelpButtons: D$ ? # 40]
[EditClass: B$ 'EDIT' EOS]

; these tables are used to set contents and pos of controls for style edition:

; Dialog window styles:

[DialogCheckingMask:
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[DialogExcludeBitTable:
 D$ 0C0000000
 D$ 0C0000000
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[DialogMustHaveBItTable:
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0C00000
 D$ 0C80000
 D$ 0C80000
 D$ 0C80000
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[DialogTextTable:
 B$ 'WS_CHILD' EOS
 B$ 'WS_POPUP' EOS
 B$ 'WS_VISIBLE' EOS
 B$ 'WS_DISABLED' EOS
 B$ 'WS_BORDER' EOS
 B$ 'WS_CAPTION' EOS
 B$ 'WS_HSCROLL' EOS
 B$ 'WS_VSCROLL' EOS
 B$ 'WS_SYSMENU' EOS
 B$ 'WS_MAXIMIZEBOX' EOS
 B$ 'WS_MINIMIZEBOX' EOS
 B$ 'DS_CONTEXTHELP' EOS
 B$ 'DS_ABSALING' EOS
 B$ 'DS_CENTER' EOS
 B$ 'WS_THICKFRAME' EOS
 B$ 'DS_CONTROL' EOS
 B$ 'DS_MODALFRAME' EOS
 B$ 'DS_NOFAILCREATE' EOS
 B$ 'DS_NOIDLEMSG' EOS
 B$ 'DS_SETFOREGROUND' EOS
 B$ 'DS_SYSMODAL' EOS 0]

[DialogBitTable:
 D$ &WS_CHILD
 D$ &WS_POPUP
 D$ &WS_VISIBLE
 D$ &WS_DISABLED
 D$ &WS_BORDER
 D$ &WS_CAPTION
 D$ &WS_HSCROLL
 D$ &WS_VSCROLL
 D$ &WS_SYSMENU
 D$ &WS_MAXIMIZEBOX
 D$ &WS_MINIMIZEBOX
 D$ &DS_CONTEXTHELP
 D$ &DS_ABSALIGN
 D$ &DS_CENTER
 D$ &WS_THICKFRAME
 D$ &DS_CONTROL
 D$ &DS_MODALFRAME
 D$ &DS_NOFAILCREATE
 D$ &DS_NOIDLEMSG
 D$ &DS_SETFOREGROUND
 D$ &DS_SYSMODAL] ; &DS_CENTERMOUSE

[WS_CHILDhelp: B$ "WS_CHILD:

> Child window.

Cannot be used with the WS_POPUP style." EOS]

[WS_POPUPhelp: B$ "WS_POPUP:

> Pop-up window.

Cannot be used with the WS_CHILD style." EOS]

[WS_VISIBLEhelp: B$ "WS_VISIBLE:

window is initially visible." EOS]

[WS_DISABLEDhelp: B$ "WS_DISABLED:

The window is initially disabled and can't receive input from the user." EOS]

[WS_BORDERhelp: B$ "WS_BORDER:

The window has a thin-line border." EOS]

[WS_CAPTIONhelp: B$ "WS_CAPTION:

The window has a title bar (includes WS_BORDER)." EOS]

[WS_HSCROLLhelp: B$ "WS_HSCROLL:

The window has an horizontal scroll bar." EOS]

[WS_VSCROLLhelp: B$ "WS_VSCROLL:

The window has a vertical scroll bar." EOS]

[WS_SYSMENUhelp: B$ "WS_SYSMENU:

The window has a System-menu box in the title bar.

Must be WS_CAPTION too." EOS]

[WS_MAXIMIZEBOXhelp: B$ "WS_MAXIMIZEBOX:

Adds the Maximize button to the title bar." EOS]

[WS_MINIMIZEBOXhelp: B$ "WS_MINIMIZEBOX:

Adds the Minimize button to the title bar." EOS]

[DS_CONTEXTHELPhelp: B$ "DS_CONTEXTHELP:

Adds a question mark in the title bar" EOS]

[DS_ABSALINGhelp: B$ "DS_ABSALIGN:

The coordinates of the dialog box will be screen coordinates instead of client area ones." EOS]

[DS_CENTERhelp: B$ "DS_CENTER:

Centers the dialog box in the working area." EOS]

[WS_THICKFRAMEhelp: B$ "WS_THICKFRAME:

The window has a sizing border.

Same as WS_SIZEBOX." EOS]

[DS_CONTROLhelp: B$ "DS_CONTROL:

The dialog will works as a child window of another dialog (example: A page in a Tabbed Dialog)." EOS]

[DS_MODALFRAMEhelp: B$ "DS_MODALFRAME:

The dialog will have a modal dialog-box frame." EOS]

[DS_NOFAILCREATEhelp: B$ "DS_NOFAILCREATE:

Creates the dialog even if an error occur, for example, if a child window cannot be created." EOS]

[DS_NOIDLEMSGhelp: B$ "DS_NOIDLEMSG:

Blocks the WM_ENTERIDLE messages that Windows would otherwise send to the owner of the dialog box when the dialog box is displayed." EOS]

[DS_SETFOREGROUNDhelp: B$ "DS_SETFOREGROUND:

Brings the dialog box to the foreground, like it could be done with a Call to SetForegroundWindow" EOS]

[DS_SYSMODALhelp: B$ "DS_SYSMODAL:

> System-modal dialog box.

The dialog will have the WS_EX_TOPMOST style." EOS
 0]


[DialogStylesHelp:
 D$ WS_CHILDhelp
 D$ WS_POPUPhelp
 D$ WS_VISIBLEhelp
 D$ WS_DISABLEDhelp
 D$ WS_BORDERhelp
 D$ WS_CAPTIONhelp
 D$ WS_HSCROLLhelp
 D$ WS_VSCROLLhelp
 D$ WS_SYSMENUhelp
 D$ WS_MAXIMIZEBOXhelp
 D$ WS_MINIMIZEBOXhelp
 D$ DS_CONTEXTHELPhelp
 D$ DS_ABSALINGhelp
 D$ DS_CENTERhelp
 D$ WS_THICKFRAMEhelp
 D$ DS_CONTROLhelp
 D$ DS_MODALFRAMEhelp
 D$ DS_NOFAILCREATEhelp
 D$ DS_NOIDLEMSGhelp
 D$ DS_SETFOREGROUNDhelp
 D$ DS_SYSMODALhelp
 D$ 0]
___________________________________________________________________________________

ShowDialogStyleControl:
    ShowSetOfCheckBoxes DialogTextTable
ret

__________________________________________________________________________________

; very simplified version of TranslateHexa
; (esi >>> first text hexa number char after leading '0'):

TranslateDialogHexa:
    Mov ebx 0
L0: lodsb | cmp al SPC | je L9>
            cmp al ';' | je L9>
            cmp al CR | jbe L9>
      sub al '0' | On al > 9, sub al 7
      shl ebx 4 | or bl al | jmp L0<
L9: ret                                     ; >>> ebx = binary value

TranslateDialogText8:
    Mov ecx 8
L0: Mov eax ebx | and eax 0_F000_0000 | shr eax 28
    add al '0' | On al > '9', add al 7
    shl ebx 4
    stosb | loop L0<
ret

TranslateDialogText4:
    shl ebx 16
    Mov ecx 4 | jmp L0<

TranslateDialogText2:
    shl ebx 24
    Mov ecx 2 | jmp L0<

____________________________________________________________________________________

ShowDialogStyles:
    Mov esi D$NewDialogTemplateText | add esi 3
    Call TranslateDialogHexa | Mov D$CheckActual ebx

    Move D$CheckingMask DialogCheckingMask
    Mov esi DialogBitTable

    Push ebp
        Call CheckControlStyles
    Pop ebp
ret


[CheckBit: D$ ?
 CheckActual: D$ ?
 CheckExclude: D$ ?
 CheckMust: D$ ?
 ;CheckBitPtr: D$ ?
; CheckResult: D$ ?
 CheckingMask: D$ ?]
____________________________________________________________________________________

CheckControlStyles:
;;
 check / uncheck the controls:

 Set by caller (WriteStyle):

      D$CheckActual = Actual value for style (full value)
      D$CheckingMask = Bits table adress of checking masks (the main difficulty)

      esi = ptr to Style Bits table
;;
    Mov edi TABLE.H.DialogControls, ecx 0
    While D$edi > 0
       add edi 4 | inc ecx                ; number of check boxes at screen in ecx
    End_While
;;
 Very killing problem: This routine MUST be able to Check/UnCheck the edition CheckBoxes
 according with the value of "Style" (D$CheckActual). The fact is that we can have, for
 exemple, for buttons styles, values sets like:

 BS_3STATE 5         BS_AUTO3STATE 6     BS_AUTOCHECKBOX 3  BS_AUTORADIOBUTTON 9
 BS_CHECKBOX 2       BS_DEFPUSHBUTTON 1  BS_GROUPBOX 7      BS_PUSHBUTTON 0
 BS_RADIOBUTTON 4

 ... what makes it impossible to trust any bit value for checking. For exemple, if user
 click on "BS_GROUPBOX" (= 00_111), we must not check 00_001 (BS_DEFPUSHBUTTON), 00_010
 (BS_CHECKBOX), and so on... Sorry, next lines are very very difficult to understand. The
 only readable solution would be to write a no end cases selections routine for each
 control class, but i have choosen this shorter way. A second difficulty is that zero
 may be significant - and Check / UnCheck- (exemple: BS_PUSHBUTTON) and that we have to
 discriminate 00_10 (BS_CHECKBOX, for exemple) from 00_10... Killing:
;;
    Mov edx D$CheckingMask, ebp 0              ; ebp = handles index for 'SendMessage'

L0: lodsd                                      ; loads one style value from Styles list
    pushad
      Mov edx D$edx                            ; CheckingMask  !!!!!!!!!!!!!!!!!!!!!!!!
      ; eax Style bit value from list
        ; (Style and eax) <> eax >>> false?:
      Mov ebx D$CheckActual | and ebx eax | cmp eax ebx | jne L6>
        ; (eax and CheckingMask) = 0  > next line
      Mov ebx eax | and ebx edx | cmp ebx 0 | jne L4>
        ; check only if really 0 wanted:
        cmp eax 0 | jne L5>
          ; true zero?:
          Mov eax D$CheckActual | and eax 00_111 | cmp eax 0 | je L5>
            jmp L6>
        ; last test for 'true', only if: bit value = (Bit value and CheckingMask):
L4:     Mov eax D$CheckActual | and eax edx | cmp ebx eax | jne L6>

L5:   Mov eax &TRUE | jmp L7>    ; check

L6:   Mov eax &FALSE             ; UnCheck

L7:   Call 'USER32.SendMessageA' D$TABLE.H.DialogControls+ebp &BM_SETCHECK eax 0
    popad | add ebp 4 | add edx 4 | loop L0<
ret


; Same as above, but for showing the checkboxes set at first time (user did'nt yet click
; at any check box, we just need actual style value and according checking mask table):

ShowControlStyles:
    Call SearchDialogLine | Mov esi edi | add esi 3
    Call TranslateDialogHexa | Mov D$CheckActual ebx

    add D$DialogListIndex Line_Class
        Call SearchWhatControlClass             ; ebx = indice of class (0 / 1 / 2 / 3...)
    sub D$DialogListIndex Line_Class

    ..If edi = ControlClassByNumber             ; >>> class by Number
        .If ebx = 0
            Move D$CheckingMask ButtonCheckingMask
            Mov esi ButtonBitTable
        .Else_If ebx = 1
            Move D$CheckingMask EditCheckingMask
            Mov esi EditBitTable
        .Else_If ebx = 2
            Move D$CheckingMask StaticCheckingMask
            Mov esi StaticBitTable
        .Else_If ebx = 3
            Move D$CheckingMask ListCheckingMask
            Mov esi ListBitTable
        .Else_If ebx = 4
            Move D$CheckingMask ScrollCheckingMask
            Mov esi ScrollBitTable
        .Else_If ebx = 5
            Move D$CheckingMask ComboCheckingMask
            Mov esi ComboBitTable
        .End_If
    ..Else                                      ; >>> class by Name
        .If ebx = 0
            Move D$CheckingMask UpDownCheckingMask
            Mov esi UpDownBitTable
        .Else_If ebx = 1
            ret                                 ; msctls_progress32 (no controls)
        .Else_If ebx = 2
            Move D$CheckingMask TrackCheckingMask
            Mov esi TrackBitTable
        .Else_If ebx = 3
            Move D$CheckingMask TreeCheckingMask
            Mov esi TreeBitTable
        .Else_If ebx = 4
            Move D$CheckingMask TabCheckingMask
            Mov esi TabBitTable
        .Else_If ebx = 5
            Move D$CheckingMask ListViewCheckingMask
            Mov esi ListViewBitTable
        .Else_If ebx = 6
            Move D$CheckingMask ToolBarCheckingMask
            Mov esi ToolBarBitTable
        .Else_If ebx = 7
            Move D$CheckingMask RichEdit20aCheckingMask
            Mov esi RichEdit20aBitTable
        .Else_If ebx = 8
            Move D$CheckingMask SysHeader32CheckingMask
            Mov esi SysHeader32BitTable
        .Else_If ebx = 9
            Move D$CheckingMask ReBarWindow32CheckingMask
            Mov esi ReBarWindow32BitTable
        .Else_If ebx = 10
            Move D$CheckingMask Tooltips_class32CheckingMask
            Mov esi Tooltips_class32BitTable
        .Else_If ebx = 11
            Move D$CheckingMask msctls_statusbar32CheckingMask
            Mov esi msctls_statusbar32BitTable
        .Else_If ebx = 12
            Move D$CheckingMask msctls_hotkey32CheckingMask
            Mov esi msctls_hotkey32BitTable
        .Else_If ebx = 13
            Move D$CheckingMask ComboBoxEx32CheckingMask
            Mov esi ComboBoxEx32BitTable
        .Else_If ebx = 14
            Move D$CheckingMask SysAnimate32CheckingMask
            Mov esi SysAnimate32BitTable
        .Else_If ebx = 15
            Move D$CheckingMask SysMonthCal32CheckingMask
            Mov esi SysMonthCal32BitTable
        .Else_If ebx = 16
            Move D$CheckingMask SysDateTimePick32CheckingMask
            Mov esi SysDateTimePick32BitTable
        .Else_If ebx = 17
            Move D$CheckingMask SysIPAddress32CheckingMask
            Mov esi SysIPAddress32BitTable
        .Else_If ebx = 18
            Move D$CheckingMask SysPagerCheckingMask
            Mov esi SysPagerBitTable
        .Else_If ebx = 19
            Move D$CheckingMask SysLinkCheckingMask
            Mov esi SysLinkBitTable
        .End_If
    ..End_If

    Call CheckControlStyles
ret

_______________________________________________________________________________________

[XdimText: B$ 'X position:' EOS]
[YdimText: B$ 'Y position:' EOS]
[WdimText: B$ 'Width:' EOS]
[HdimText: B$ 'Hight:' EOS]

; This Table is an array of 2 UDACCEL structures. First dWord is the delay before next
; Array runing, dWord 2 is the displacement:
[UDACCEL:
 @n1Sec: D$ 0
 @n1Inc: D$ 1
 @n2Sec: D$ 2
 @n2Inc: D$ 5]

[DialogDimTable:
 XdimText D$ 200 D$ 0
 YdimText D$ 240 D$ 0
 WdimText D$ 280 D$ 0
 HdimText D$ 320 D$ 0]

;;
 In "display edit box", ES_RIGHT (to align text number to the left, works only with
 ES_MULTILINE edit control style. (the box is de facto mono-line, of course). Without
 this, it sends a EN_CHANGE message at first display.
;;
ShowDimControls:
  ; First retrieve values from user text dim:
    Call SearchDialogLine
    Mov al SPC | Mov ecx 200 | repne scasb  ; space used as separator > count of data
    If D$DimIsForDialogWindow = &TRUE
        repne scasb                         ; jump over n (number of controls)
    End_If
    Mov esi edi | inc esi
    Call TranslateDialogHexa | Mov D$DialogDimTable+ 8 ebx

    Call TranslateDialogHexa | Mov D$DialogDimTable+20 ebx

    Call TranslateDialogHexa | Mov D$DialogDimTable+32 ebx

    Call TranslateDialogHexa | Mov D$DialogDimTable+44 ebx

    Mov ecx 4, esi DialogDimTable, ebx 0
L0: Push ecx
      ; display text:
        Push esi, ebx
            Mov eax D$esi+4 | add eax 6

            Call 'USER32.CreateWindowExA'  &WS_EX_LEFT,
                                           StaticClassName,
                                           &NULL,
                                           &WS_CHILD+&WS_VISIBLE+&SS_SIMPLE,
                                           2,
                                           eax,
                                           120,
                                           20,
                                           D$H.DialogEditor,
                                           &NULL,
                                           D$H.Instance,
                                           0

        Pop ebx, esi
        Mov D$TABLE.H.DialogControls+ebx eax
        Push esi, ebx
            Call 'USER32.SendMessageA' eax &WM_SETFONT D$H.MyFont &FALSE
            Call 'USER32.SetWindowTextA' D$TABLE.H.DialogControls+ebx D$esi
        Pop ebx esi

      ; display edit box:
        Push esi, ebx

            Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                          EditClass,
                                          &NULL,
                                          &WS_CHILD+&WS_VISIBLE+&WS_BORDER+&ES_NUMBER+&ES_RIGHT+&ES_MULTILINE,
                                          80,
                                          D$esi+4,
                                          45,
                                          20,
                                          D$H.DialogEditor,
                                          &NULL,
                                          D$H.Instance,
                                          0
        Pop ebx, esi
        Mov D$TABLE.H.DialogControls+ebx+4 eax

      ; display Up and down control:                     +&UDS_ARROWKEYS
        Push esi, ebx
            Call 'Comctl32.CreateUpDownControl',
              &WS_CHILD+&WS_BORDER+&WS_VISIBLE+&UDS_SETBUDDYINT+&UDS_NOTHOUSANDS+&UDS_HORZ,
                      130 D$esi+4 20 20, D$H.DialogEditor, 102, D$H.Instance,
                      eax  2000 0  D$esi+8
        Pop ebx, esi
        Mov D$TABLE.H.DialogControls+ebx+8 eax

      ; Set the speed (repeat speeds) of the UpDown Controls:
        Push esi, eax, ebx
            Call 'USER32.SendMessageA' eax &UDM_SETACCEL 2 UDACCEL
        Pop ebx, eax, esi

        Push esi, ebx
            Call 'USER32.SendMessageA' eax &UDM_SETBUDDY D$TABLE.H.DialogControls+ebx+4 0
        Pop ebx, esi

        add ebx 12 | add esi 12
    Pop ecx

    sub ecx 1 | jnz L0<<
ret

____________________________________________________________________________________

[ActualFontName: B$ ? # 20]
[ActualFontSize: D$ ? ?]

; +ES_MULTILINE because it work better at message flow point of view.
; (used as mono-line, of course). Without this, it sends a EN_CHANGE message
; at first display.

ShowTitleControl:

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  EditClass,
                                  0,
                                  &WS_CHILD+&WS_VISIBLE+&WS_BORDER+&ES_AUTOHSCROLL+&ES_MULTILINE,
                                  2,
                                  200,
                                  145,
                                  20,
                                  D$H.DialogEditor,
                                  &NULL,
                                  D$H.Instance,
                                  0

    Mov D$TABLE.H.DialogControls eax

  ; Copy data title (without quotes and comments) in TitleEditText:
    Call SearchDialogLine | inc edi | Mov esi edi
    Mov al '"', ecx 200, ebx 200 | repne scasb                      ; search "Text lenght"
    sub ebx ecx | xchg ecx ebx | dec ecx
    Mov edi ActualFontName | rep movsb | Mov al 0 | stosb           ; copy + end mark

    Call 'USER32.GetDlgCtrlID' D$TABLE.H.DialogControls
    Call 'USER32.SetDlgItemTextA' D$H.DialogEditor eax ActualFontName  ; show edition text
    Call 'USER32.SetFocus' D$TABLE.H.DialogControls
    Call 'USER32.SendMessageA' D$TABLE.H.DialogControls  &EM_SETSEL  0  0-1
ret

[ComboClass: B$ 'COMBOBOX' EOS]  ; EditClass


; table of fonts names for dialog fonts:

[DialogFonts:
 B$ 'Arial' EOS
 B$ 'Arial Black' EOS
 B$ 'Comic Sans MS' EOS
 B$ 'Courier' EOS
 B$ 'Courier New' EOS
 B$ 'Fixedsys' EOS
 B$ 'Helv' EOS
 B$ 'Impact' EOS
 B$ 'Marlett' EOS
 B$ 'Modern' EOS
 B$ 'MS Sans Serif' EOS
 B$ 'MS Serif' EOS
 B$ 'Small Fonts' EOS
 B$ 'Symbol' EOS
 B$ 'System' EOS
 B$ 'Terminal' EOS
 B$ 'Times New Roman' EOS
 B$ 'Verdana' EOS
 B$ 'Webdings' EOS
 B$ 'Wingdings' EOS
 0]

; Differents set of fonts sizes available for upper fonts list:

[T1F:
 B$ '08' EOS
 B$ '09' EOS
 B$ '0A' EOS
 B$ '0B' EOS
 B$ '0C' EOS
 B$ '0E' EOS
 B$ '10' EOS
 B$ '12' EOS
 B$ '14' EOS
 B$ '16' EOS
 B$ '18' EOS
 B$ '1A' EOS
 B$ '1C' EOS
 B$ '24' EOS
 B$ '30' EOS
 B$ '48' EOS
 B$ 0]

[T2F:
 B$ '0A' EOS
 B$ '0C' EOS
 B$ '0F' EOS
 B$ 0]

[T3F:
 B$ '09' EOS
 B$ 0]

[T4F:
 B$ '08' EOS
 B$ '0A' EOS
 B$ '0C' EOS
 B$ '0E' EOS
 B$ '12' EOS
 B$ '18' EOS
 B$ 0]

[T5F:
 B$ '06' EOS
 B$ '07' EOS
 B$ '08' EOS
 B$ '0A' EOS
 B$ '0C' EOS
 B$ '0E' EOS
 B$ '12' EOS
 B$ '18' EOS
 B$ 0]

[T6F:
 B$ '02' EOS
 B$ '03' EOS
 B$ '04' EOS
 B$ '05' EOS
 B$ '06' EOS
 B$ '07' EOS
 B$ 0]

[T7F:
 B$ '0A' EOS
 0]

; Table of pointers: font index of upper names >>> pointer to upper sizes table:

[FontSizesTable:
 D$ T1F
 D$ T1F
 D$ T1F
 D$ T2F
 D$ T1F
 D$ T3F
 D$ T4F
 D$ T1F
 D$ T1F
 D$ T1F
 D$ T4F
 D$ T5F
 D$ T6F
 D$ T7F
 D$ T3F
 D$ T1F
 D$ T1F
 D$ T1F
 D$ T1F]

; Search for the actual font in font name list to retrieve the index for sizes table:

SearchFontIndex:
    Mov edi DialogFonts, edx 0-4

    While B$edi > 0
        Mov esi ActualFontName | add edx 4
        Push edi
            Mov ecx 200, ebx 200, al 0 | repne scasb | sub ebx ecx | dec ebx
        Pop edi
        If ebx = D$ComboFontNameLenght
            Mov esi edi, ecx ebx | repe cmpsb | je L9>
                Mov edi esi | add edi ebx | inc edi
        Else
            add edi ebx | inc edi
        End_If
    End_While
    Mov eax 0 | ret

L9: Mov eax edx | ret


[ComboFontNameLenght: D$ ?]

ShowFontControls:
  ; Font Type edition combo box:

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  ComboClass,
                                  &NULL,
                                  &WS_CHILD+&WS_VISIBLE+&WS_BORDER+&CBS_HASSTRINGS+&CBS_AUTOHSCROLL+&CBS_DROPDOWNLIST+&WS_VSCROLL+&ES_AUTOVSCROLL,
                                  2,
                                  240,
                                  145,
                                  220,
                                  D$H.DialogEditor,
                                  &NULL,
                                  D$H.Instance,
                                  0

    Mov D$TABLE.H.DialogControls eax

  ; Copy data font text (without quotes and comments) in TitleEditText:
    Call SearchDialogLine
    Mov esi edi, edi ActualFontSize
    while B$esi > SPC
        movsb
    End_While
    Mov al 0 | stosb
    add esi 2 | Mov edi esi
    Mov al '"', ecx 200, ebx 200 | repne scasb                      ; search "Text lenght"
    sub ebx ecx | xchg ecx ebx | dec ecx
    Mov D$ComboFontNameLenght ecx
    Mov edi ActualFontName | rep movsb | Mov al 0 | stosb           ; copy + end mark

    Mov edi DialogFonts
    While B$edi > 0
        Push edi
            Call 'USER32.SendMessageA' D$TABLE.H.DialogControls &CB_ADDSTRING 0  edi
        Pop edi
        Mov al 0, ecx 200 | repne scasb
    End_While

    Call 'USER32.SendMessageA' D$TABLE.H.DialogControls &CB_SELECTSTRING  0  ActualFontName

  ; Font size edition box:

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  ComboClass,
                                  0,
                                  &WS_CHILD+&WS_VISIBLE+&WS_BORDER+&CBS_HASSTRINGS+&CBS_AUTOHSCROLL+&CBS_DROPDOWNLIST+&WS_VSCROLL+&ES_AUTOVSCROLL,
                                  100,
                                  200,
                                  47,
                                  150,
                                  D$H.DialogEditor,
                                  &NULL,
                                  D$H.Instance,
                                  0

    Mov D$TABLE.H.DialogControls+4 eax

    Call SearchFontIndex

    If eax > 0
        Mov edi D$FontSizesTable+eax
        While B$edi > 0
            Push edi
                Call 'USER32.SendMessageA' D$TABLE.H.DialogControls+4 &CB_ADDSTRING 0  edi
            Pop edi
            Mov al 0, ecx 200 | repne scasb
        End_While
    End_If

    Call 'USER32.SendMessageA' D$TABLE.H.DialogControls+4  &CB_SELECTSTRING  0  ActualFontSize
ret

________________________________________________________________________________________
________________________________________________________________________________________
;;
 All the controls specificaly used for one record edition have these data tables
 associated with: (one for equates), one for texts proposed as different choices, one
 for the bit values of each possible choice, one for the bit values that can not be
 fitting with a choice and one for the bits that must be associated with one choice.

 Some win equates are not bit values but ordinals values (1, 2, 3, ..., 0100, 0200, 0300,...)
 in one same set of equates. This is to say that, having the binary value for some 'Style',
 it is impossible to find the signification by simply analysing each bit of 'Style' value.
 So must we have an additionnal set of mask to be able to Check / UnCheck the check
 boxes, either at first screen show or after user modifications, according with
 exclusions and 'must have' rules. These additionnal tables are named 'xxxxCheckingMask'.

 "xxxxExcludeBitTable" is used by 'WriteStyle' to compute the style value (only one value
 per operation)
 "xxxxCheckingMask" is used by 'CheckControlStyles' to set the check boxes (all the set
 per operation).
;;
________________________________________________________________________________________
________________________________________________________________________________________
; Button tables:


[ButtonCheckingMask:
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F0
 D$ &BS_CENTER
 D$ &BS_CENTER
 D$ &BS_CENTER
 D$ &BS_VCENTER
 D$ &BS_VCENTER
 D$ &BS_VCENTER
 D$ 0F
 D$ 0F0
 D$ 0F0
 D$ &BS_MULTILINE
 D$ &BS_NOTIFY
 D$ &BS_PUSHLIKE
 D$ &BS_FLAT
 D$ 010000
 D$ 020000
 D$ 08000000
 D$ &WS_CHILD
 D$ &WS_VISIBLE
 D$ &WS_BORDER
 D$ &WS_CLIPSIBLINGS]

[ButtonExcludeBitTable:
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0
 D$ &BS_CENTER
 D$ &BS_CENTER
 D$ &BS_CENTER
 D$ &BS_VCENTER
 D$ &BS_VCENTER
 D$ &BS_VCENTER
 D$ 0F
 D$ 0F0
 D$ 0F0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[ButtonTextTable:
 B$ 'BS_PUSHBUTTON' EOS
 B$ 'BS_DEFPUSHBUTTON' EOS
 B$ 'BS_CHECKBOX' EOS
 B$ 'BS_3STATE' EOS
 B$ 'BS_AUTOCHECKBOX' EOS
 B$ 'BS_AUTO3STATE' EOS
 B$ 'BS_RADIOBUTTON' EOS
 B$ 'BS_AUTORADIOBUTTON' EOS
 B$ 'BS_GROUPBOX' EOS
 B$ 'BS_LEFTTEXT' EOS
 B$ 'BS_LEFT' EOS
 B$ 'BS_RIGHT' EOS
 B$ 'BS_CENTER' EOS
 B$ 'BS_BOTTOM' EOS
 B$ 'BS_TOP' EOS
 B$ 'BS_VCENTER' EOS
 B$ 'BS_OWNERDRAW' EOS
 B$ 'BS_BITMAP' EOS
 B$ 'BS_ICON' EOS
 B$ 'BS_MULTILINE' EOS
 B$ 'BS_NOTIFY' EOS
 B$ 'BS_PUSHLIKE' EOS
 B$ 'BS_FLAT' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 'WS_GROUP' EOS
 B$ 'WS_DISABLED' EOS
 B$ 'WS_CHILD' EOS
 B$ 'WS_VISIBLE' EOS
 B$ 'WS_BORDER' EOS
 B$ 'WS_CLIPSIBLINGS' EOS
 B$ 0]

[ButtonBitTable:
 D$ &BS_PUSHBUTTON
 D$ &BS_DEFPUSHBUTTON
 D$ &BS_CHECKBOX
 D$ &BS_3STATE
 D$ &BS_AUTOCHECKBOX
 D$ &BS_AUTO3STATE
 D$ &BS_RADIOBUTTON
 D$ &BS_AUTORADIOBUTTON
 D$ &BS_GROUPBOX
 D$ &BS_LEFTTEXT
 D$ &BS_LEFT
 D$ &BS_RIGHT
 D$ &BS_CENTER
 D$ &BS_BOTTOM
 D$ &BS_TOP
 D$ &BS_VCENTER
 D$ &BS_OWNERDRAW
 D$ &BS_BITMAP
 D$ &BS_ICON
 D$ &BS_MULTILINE
 D$ &BS_NOTIFY
 D$ &BS_PUSHLIKE
 D$ &BS_FLAT
 D$ &WS_TABSTOP
 D$ &WS_GROUP
 D$ &WS_DISABLED
 D$ &WS_CHILD
 D$ &WS_VISIBLE
 D$ &WS_BORDER
 D$ &WS_CLIPSIBLINGS] ; &BS_RIGHTBUTTON &BS_TEXT

[ButtonMustHaveBitTable: D$ ? # 30]

[BS_PUSHBUTTONhelp: B$ "BS_PUSHBUTTON:

The button posts a WM_COMMAND message to its parent when pushed." EOS]

[BS_DEFPUSHBUTTONhelp: B$ "BS_DEFPUSHBUTTON:

The button behaves like with BS_PUSHBUTTON, but has a enhanced border and reacts as default OK, when user hits Return." EOS]

[BS_CHECKBOXhelp: B$ "BS_CHECKBOX: 

Empty check box with text.

The default text Pos (at right) may be changed with BS_LEFTTEXT." EOS]

[BS_3STATEhelp: B$ "BS_3STATE:

Same as check box, but it can be grayed, checked or unchecked." EOS]

[BS_AUTOCHECKBOXhelp: B$ "BS_AUTOCHECKBOX:

Same as check box, but the state automatically toggles on user action." EOS]

[BS_AUTO3STATEhelp: B$ "BS_AUTO3STATE:

Same as Three-state check box, but the state automatically toggles on user action." EOS]

[BS_RADIOBUTTONhelp: B$ "BS_RADIOBUTTON:

Small circle with text. The default text Pos (at right) may be changed with BS_LEFTTEXT." EOS]

[BS_AUTORADIOBUTTONhelp: B$ "BS_AUTORADIOBUTTON:

Same as a radio button, but the state automatically toggles on user action." EOS]

[BS_GROUPBOXhelp: B$ "BS_GROUPBOX:

Not really a button. Creates a rectangle in which other controls can be grouped, with eventually a common title.

If you want, for example to have several sets of Auto-Radio-Buttons, you may also need the WS_GROUP style" EOS]

[BS_LEFTTEXThelp: B$ "BS_LEFTTEXT:

Places text on the left side of the radio button or check box." EOS]

[BS_LEFThelp: B$ "BS_LEFT:

Left-justified the text in the button rectangle.

Note: If the button is a check box or radio button without BS_RIGHTBUTTON, the text is left justified on the right side of the control." EOS]

[BS_RIGHThelp: B$ "BS_RIGHT:

Right-justified text in the button rectangle.

Note: If the button is a check box or radio button without BS_RIGHTBUTTON, the text is right justified on the right side of the control." EOS]

[BS_CENTERhelp: B$ "BS_CENTER:

Centers the text horizontally in the button rectangle." EOS]

[BS_BOTTOMhelp: B$ "BS_BOTTOM:

Places the text at the bottom of the button rectangle." EOS]

[BS_TOPhelp: B$ "BS_TOP:

Places the text at the top of the button rectangle." EOS]

[BS_VCENTERhelp: B$ "BS_VCENTER:

Centers vertically the text on the button rectangle." EOS]

[BS_OWNERDRAWhelp: B$ "BS_OWNERDRAW:

The owner window will receives a WM_MEASUREITEM message at creation time and a WM_DRAWITEM message after the visual aspect change is done.

Can't be combined with any other button styles." EOS]

[BS_BITMAPhelp: B$ "BS_BITMAP:

The button will display a bitmap. You set it in your Proc." EOS]

[BS_ICONhelp: B$ "BS_ICON:

The button will display an Icon. You set it in your Proc." EOS]

[BS_MULTILINEhelp: B$ "BS_MULTILINE:

Allows multiple lines if the text string is too long to fit with the button width." EOS]

[BS_NOTIFYhelp: B$ "BS_NOTIFY:

The button will send BN_DBLCLK / BN_KILLFOCUS / BN_SETFOCUS notification messages to its parent. 

Note: BN_CLICKED is always send, even without this style. " EOS]

[BS_PUSHLIKEhelp: B$ "BS_PUSHLIKE:

Makes a check box or a radio button look like a button, with a state holding behaviour." EOS]

[BS_FLAThelp: B$ "BS_FLAT:

The button borders are visible only when activated" EOS]

[WS_GROUPhelp: B$ "WS_GROUP:

To be used with BS_GROUPBOX.

The next coming Controls, for example, a serie of Radio Buttons will behave as a group" EOS]

[ButtonStylesHelp:
 D$ BS_PUSHBUTTONhelp
 D$ BS_DEFPUSHBUTTONhelp
 D$ BS_CHECKBOXhelp
 D$ BS_3STATEhelp
 D$ BS_AUTOCHECKBOXhelp
 D$ BS_AUTO3STATEhelp
 D$ BS_RADIOBUTTONhelp
 D$ BS_AUTORADIOBUTTONhelp
 D$ BS_GROUPBOXhelp
 D$ BS_LEFTTEXThelp
 D$ BS_LEFThelp
 D$ BS_RIGHThelp
 D$ BS_CENTERhelp
 D$ BS_BOTTOMhelp
 D$ BS_TOPhelp
 D$ BS_VCENTERhelp
 D$ BS_OWNERDRAWhelp
 D$ BS_BITMAPhelp
 D$ BS_ICONhelp
 D$ BS_MULTILINEhelp
 D$ BS_NOTIFYhelp
 D$ BS_PUSHLIKEhelp
 D$ BS_FLAThelp
 D$ WS_TABSTOPhelp
 D$ WS_GROUPhelp
 D$ WS_DISABLEDhelp
 D$ WS_CHILDhelp
 D$ WS_VISIBLEhelp
 D$ WS_BORDERhelp
 D$ WS_CLIPSIBLINGShelp]
____________________________________

; Edit control tables:

[EditCheckingMask:
 D$ 03
 D$ 03
 D$ 03
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[EditTextTable:
 B$ 'ES_LEFT' EOS
 B$ 'ES_CENTER' EOS
 B$ 'ES_RIGHT' EOS
 B$ 'ES_MULTILINE' EOS
 B$ 'ES_AUTOVSCROLL' EOS
 B$ 'ES_AUTOHSCROLL' EOS
 B$ 'ES_LOWERCASE' EOS
 B$ 'ES_UPPERCASE' EOS
 B$ 'ES_PASSWORD' EOS
 B$ 'ES_OEMCONVERT' EOS
 B$ 'ES_NOHIDESEL' EOS
 B$ 'ES_READONLY' EOS
 B$ 'ES_NUMBER' EOS
 B$ 'ES_WANTRETURN' EOS
 B$ 'WS_VSCROLL' EOS
 B$ 'WS_HSCROLL' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 'WS_BORDER' EOS
 B$ 0]

[EditBitTable:
 D$ &ES_LEFT
 D$ &ES_CENTER
 D$ &ES_RIGHT
 D$ &ES_MULTILINE
 D$ &ES_AUTOVSCROLL
 D$ &ES_AUTOHSCROLL
 D$ &ES_LOWERCASE
 D$ &ES_UPPERCASE
 D$ &ES_PASSWORD
 D$ &ES_OEMCONVERT
 D$ &ES_NOHIDESEL
 D$ &ES_READONLY
 D$ &ES_NUMBER
 D$ &ES_WANTRETURN
 D$ &WS_VSCROLL
 D$ &WS_HSCROLL
 D$ &WS_TABSTOP
 D$ &WS_BORDER]

[EditExcludeBitTable:
 D$ 03
 D$ 02
 D$ 01
 D$ 0
 D$ 0
 D$ 0
 D$ 08
 D$ 010
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[EditMustHaveBitTable:
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ &WS_VSCROLL
 D$ &WS_HSCROLL
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[ES_LEFThelp: B$ "ES_LEFT:

Text will be Left-aligned." EOS]

[ES_CENTERhelp: B$ "ES_CENTER:

For multiline edit control:

Text will be centered" EOS]

[ES_RIGHThelp: B$ "ES_RIGHT:

For multiline edit control:

Text wil be right-aligned." EOS]

[ES_MULTILINEhelp: B$ "ES_MULTILINE:

Multiline edit control. Default is single-line. Whith multi-lines, by default, when pressing ENTER, the default button is activated. To use the ENTER key as a real carriage return, add the ES_WANTRETURN style.

With the ES_AUTOHSCROLL style, the multiline edit control automatically scrolls horizontally when the caret reaches the right edge. To start a new line, the user must press the ENTER key. Without ES_AUTOHSCROLL, the control automatically wraps the words to the beginning of the next line when needed. A new line is also started if the user presses the ENTER key. The word wrap vary with the window size.

With multiline edit you can have scroll bars, and the edit control will process its own scroll bar messages." EOS]

[ES_AUTOVSCROLLhelp: B$ "ES_AUTOVSCROLL:

Automatically scrolls text up or down on user action." EOS]

[ES_AUTOHSCROLLhelp: B$ "ES_AUTOHSCROLL:

Automatically scrolls text to the right by 10 chars when needed (on user action)." EOS]

[ES_LOWERCASEhelp: B$ "ES_LOWERCASE:

Converts all imputs to lowercase." EOS]

[ES_UPPERCASEhelp: B$ "ES_UPPERCASE:

Converts all Inputs to uppercase." EOS]

[ES_PASSWORDhelp: B$ "ES_PASSWORD:

Shows asterisks instead of imputed chars. You can change the (*)s to something Else with the EM_SETPASSWORDCHAR message." EOS]

[ES_OEMCONVERThelp: B$ "ES_OEMCONVERT:

Converts text entered, from the Windows character set to the OEM character set and then back to the Windows set. This ensures proper character conversion when the application calls the CharToOem function to convert a string to OEM. Useful for retrieving filenames." EOS]

[ES_NOHIDESELhelp: B$ "ES_NOHIDESEL:

The selected text will remain selected, even if the control looses the focus. (as opposed to the default behaviour)." EOS]

[ES_READONLYhelp: B$ "ES_READONLY:

User can't modify the actual text." EOS]

[ES_NUMBERhelp: B$ "ES_NUMBER:

Allows only decimal digits inputs." EOS]

[ES_WANTRETURNhelp: B$ "ES_WANTRETURN:

For multi-lines edit: The carriage return be inserted in response to ENTER.

Otherwise, ENTER would be considered as a default Push button actions." EOS]
; WS_VSCROLLhelp: '' EOS
; WS_HSCROLLhelp: '' EOS

[WS_TABSTOPhelp: B$ "WS_TABSTOP:

Pressing the TAB key changes the keyboard focus to the next control having this style. 

The order of Controls is the one in the Dialog Data." EOS]

; WS_BORDERhelp: '' EOS


[EditStylesHelp:
 D$ ES_LEFThelp
 D$ ES_CENTERhelp
 D$ ES_RIGHThelp
 D$ ES_MULTILINEhelp
 D$ ES_AUTOVSCROLLhelp
 D$ ES_AUTOHSCROLLhelp
 D$ ES_LOWERCASEhelp
 D$ ES_UPPERCASEhelp
 D$ ES_PASSWORDhelp
 D$ ES_OEMCONVERThelp
 D$ ES_NOHIDESELhelp
 D$ ES_READONLYhelp
 D$ ES_NUMBERhelp
 D$ ES_WANTRETURNhelp
 D$ WS_VSCROLLhelp
 D$ WS_HSCROLLhelp
 D$ WS_TABSTOPhelp
 D$ WS_BORDERhelp]
____________________________________


; Static Controls tables:

[StaticCheckingMask:
 D$ 0F
 D$ 0FFF
 D$ 0FFF
 D$ 0FFF
 D$ 0FFF
 D$ 0FFF
 D$ 0FFF
 D$ 0FFF
 D$ 0FFF
 D$ 03
 D$ 03
 D$ 03
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[StaticTextTable:
 B$ 'SS_SIMPLE' EOS
 B$ 'SS_BITMAP' EOS
 B$ 'SS_ICON' EOS
 B$ 'SS_BLACKRECT' EOS
 B$ 'SS_GRAYRECT' EOS
 B$ 'SS_WHITERECT' EOS
 B$ 'SS_BLACKFRAME' EOS
 B$ 'SS_GRAYFRAME' EOS
 B$ 'SS_WHITEFRAME' EOS
 B$ 'SS_CENTER' EOS
 B$ 'SS_LEFT' EOS
 B$ 'SS_RIGHT' EOS
 B$ 'SS_CENTERIMAGE' EOS
 B$ 'SS_LEFTNOWORDWRAP' EOS
 B$ 'SS_NOPREFIX' EOS
 B$ 'SS_NOTIFY' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 'WS_BORDER' EOS
 B$ 0]

[StaticBitTable:
 D$ &SS_SIMPLE
 D$ &SS_BITMAP
 D$ &SS_ICON
 D$ &SS_BLACKRECT
 D$ &SS_GRAYRECT
 D$ &SS_WHITERECT
 D$ &SS_BLACKFRAME
 D$ &SS_GRAYFRAME
 D$ &SS_WHITEFRAME
 D$ &SS_CENTER
 D$ &SS_LEFT
 D$ &SS_RIGHT
 D$ &SS_CENTERIMAGE
 D$ &SS_LEFTNOWORDWRAP
 D$ &SS_NOPREFIX
 D$ &SS_NOTIFY
 D$ &WS_TABSTOP
 D$ &WS_BORDER] ; &SS_METAPICT &SS_RIGHTIMAGE

[StaticExcludeBitTable:
 D$ 0FFF
 D$ 0FF
 D$ 0FFF
 D$ 0FF
 D$ 0FF
 D$ 0FF
 D$ 0FF
 D$ 0FF
 D$ 0FF
 D$ 03
 D$ 03
 D$ 03
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[StaticMustHaveBitTable: D$ ? # 18]

[SS_SIMPLEhelp: B$ "SS_SIMPLE:

A simple short line of left-aligned text in a rectangle." EOS]

[SS_BITMAPhelp: B$ "SS_BITMAP:

Room where to display a bitmap.

The Name (Title), when given is for targetting a Bitmap Resource save by Name. Actually RosAsm does not assume this way for saving Resources (only Resources by Number).

You have to defined your BitMap at Run Time from your CallBack Initialisation.

The width and Hight of the Control are dummy: The control automatically resizes to accommodate to the bitmap size." EOS]

[SS_ICONhelp: B$ "SS_ICON:

Room where to display an icon.

The Name (Title), when given is for targetting a Bitmap Resource save by Name. Actually RosAsm does not assume this way for saving Resources (only Resources by Number).

You have to defined your BitMap at Run Time from your CallBack Initialisation.

The width and Hight of the Control are dummy: The control automatically resizes to accommodate to the bitmap size" EOS]

[SS_BLACKRECThelp: B$ "SS_BLACKRECT:

A rectangle filled with the current window frame color.

Default is black." EOS]

[SS_GRAYRECThelp: B$ "SS_GRAYRECT:

A rectangle filled with the current screen background color.

Default is gray." EOS]

[SS_WHITERECThelp: B$ "SS_WHITERECT:

A rectangle filled with the current window background color.

Defauilt is white." EOS]

[SS_BLACKFRAMEhelp: B$ "SS_BLACKFRAME:

A box with a frame drawn in the color of window frames.

Default is black." EOS]

[SS_GRAYFRAMEhelp: B$ "SS_GRAYFRAME:

A box with a frame drawn in the color of screen background.

Default is gray." EOS]

[SS_WHITEFRAMEhelp: B$ "SS_WHITEFRAME:

A box with a frame drawn with the color of window backgrounds.

Default is white." EOS]

[SS_CENTERhelp: B$ "SS_CENTER: 

A rectangle with centered text inside.

Includes wordwrap." EOS]

[SS_LEFThelp: B$ "SS_LEFT:

A rectangle with left-aligned text inside.

Includes wordwrap." EOS]

[SS_RIGHThelp: B$ "SS_RIGHT:

A rectangle with right-aligned text inside.

Includes wordwrap." EOS]

[SS_CENTERIMAGEhelp: B$ "SS_CENTERIMAGE:

With SS_BITMAP or SS_ICON, when resizing to accomodate the image size, the control pos will refer to its center instead of its upper rigth corner." EOS]

[SS_LEFTNOWORDWRAPhelp: B$ "SS_LEFTNOWORDWRAP:

Clips past extended text instead of wrapping when too long" EOS]

[SS_NOPREFIXhelp: B$ "SS_NOPREFIX:

By default ampersand (&) indicates the next Char as a hot key (accelerator). This style negates this behaviour.

You can do the same by simply stating 2 ampersands (&&) instead." EOS]

[SS_NOTIFYhelp: B$ "SS_NOTIFY:

Sends STN_CLICKED and STN_DBLCLK notification messages to the parent when the user clicks or double clicks the control." EOS]
 ;WS_BORDERhelp: '' EOS
 ;
[StaticStylesHelp:
 D$ SS_SIMPLEhelp
 D$ SS_BITMAPhelp
 D$ SS_ICONhelp
 D$ SS_BLACKRECThelp
 D$ SS_GRAYRECThelp
 D$ SS_WHITERECThelp
 D$ SS_BLACKFRAMEhelp
 D$ SS_GRAYFRAMEhelp
 D$ SS_WHITEFRAMEhelp
 D$ SS_CENTERhelp
 D$ SS_LEFThelp
 D$ SS_RIGHThelp
 D$ SS_CENTERIMAGEhelp
 D$ SS_LEFTNOWORDWRAPhelp
 D$ SS_NOPREFIXhelp
 D$ SS_NOTIFYhelp
 D$ WS_TABSTOPhelp
 D$ WS_BORDERhelp]
____________________________________


; List box tables:

[ListCheckingMask:
 D$ 0
 D$ 0
 D$ 0
 D$ 0_FF_FFFF
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 030
 D$ 030
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[ListTextTable:
 B$ 'LBS_HASSTRINGS' EOS
 B$ 'LBS_NOTIFY' EOS
 B$ 'LBS_SORT' EOS
 B$ 'LBS_STANDARD' EOS
 B$ 'LBS_USETABSTOPS' EOS
 B$ 'LBS_WANTKEYBOARDINPUT' EOS
 B$ 'LBS_DISABLENOSCROLL' EOS
 B$ 'LBS_EXTENDEDSEL' EOS
 B$ 'LBS_MULTICOLUMN' EOS
 B$ 'LBS_MULTIPLESEL' EOS
 B$ 'LBS_NODATA' EOS
 B$ 'LBS_NOINTEGRALHEIGHT' EOS
 B$ 'LBS_NOSEL' EOS
 B$ 'LBS_NOREDRAW' EOS
 B$ 'LBS_OWNERDRAWFIXED' EOS
 B$ 'LBS_OWNERDRAWVARIABLE' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 'WS_BORDER' EOS
 B$ 'WS_VSCROLL' EOS
 B$ 'WS_HSCROLL' EOS
 B$ 0]

[ListBitTable:
 D$ &LBS_HASSTRINGS
 D$ &LBS_NOTIFY
 D$ &LBS_SORT
 D$ &LBS_STANDARD
 D$ &LBS_USETABSTOPS
 D$ &LBS_WANTKEYBOARDINPUT
 D$ &LBS_DISABLENOSCROLL
 D$ &LBS_EXTENDEDSEL
 D$ &LBS_MULTICOLUMN
 D$ &LBS_MULTIPLESEL
 D$ &LBS_NODATA
 D$ &LBS_NOINTEGRALHEIGHT
 D$ &LBS_NOSEL
 D$ &LBS_NOREDRAW
 D$ &LBS_OWNERDRAWFIXED
 D$ &LBS_OWNERDRAWVARIABLE
 D$ &WS_TABSTOP
 D$ &WS_BORDER
 D$ &WS_VSCROLL
 D$ &WS_HSCROLL]

[ListExcludeBitTable:
 D$ 02000
 D$ 0
 D$ 0
 D$ 0FF_FFFF
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 042
 D$ 0
 D$ 0808
 D$ 0
 D$ 030
 D$ 030
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[ListMustHaveBitTable: D$ ? # 20]

[LBS_HASSTRINGShelp: B$ "LBS_HASSTRINGS:

List of strings." EOS]

[LBS_NOTIFYhelp: B$ "LBS_NOTIFY:

Notifies the parent, when the user clicks or double-clicks on a listed item." EOS]

[LBS_SORThelp: B$ "LBS_SORT:

Auto-Sorts the strings in alphabetic order." EOS]

[LBS_STANDARDhelp: B$ "LBS_STANDARD:

Auto-Sorts the strings in alphabetic order.

Notify parent of user cicks and double-clicks.

Plus side borders" EOS]

[LBS_USETABSTOPShelp: B$ "LBS_USETABSTOPS:

Tab are drawn with the string, if any." EOS]

[LBS_WANTKEYBOARDINPUThelp: B$ "LBS_WANTKEYBOARDINPUT:

Send the owner of the box a WM_VKEYTOITEM messages when user depresses a key.

Enables an application to control keyboard inputs." EOS]

[LBS_DISABLENOSCROLLhelp: B$ "LBS_DISABLENOSCROLL:

When the vertical scroll bar is not required for viewing all of the ListBox Items, this style negates the default behaviour, which is to *not* display the scroll bar." EOS]

[LBS_EXTENDEDSELhelp: B$ "LBS_EXTENDEDSEL:

Allows multiple items selections by use of the SHIFT key or of the mouse." EOS]

[LBS_MULTICOLUMNhelp: B$ "LBS_MULTICOLUMN:

Multicolumn list box, scrolled horizontally.

You set the columns width with LB_SETCOLUMNWIDTH message." EOS]

[LBS_MULTIPLESELhelp: B$ "LBS_MULTIPLESEL:

Turns string selection on or off at each clicks on a string. 

The user can select several strings." EOS]

[LBS_NODATAhelp: B$ "LBS_NODATA:

Does not work with LBS_SORT or LBS_HASSTRINGS style. A no-data list box is to be used when the number of items is over 1000. Must have the LBS_OWNERDRAWFIXED style. 

See Win Help for more information. You should not use this." EOS]

[LBS_NOINTEGRALHEIGHThelp: B$ "LBS_NOINTEGRALHEIGHT:

Block the adaption of the list box size on the Items length." EOS]

[LBS_NOSELhelp: B$ "LBS_NOSEL:
 
 The Items viewed in list box cannot be selected" EOS]

[LBS_NOREDRAWhelp: B$ "LBS_NOREDRAW:

Prevents from updating when changes are made. May be changed with WM_SETREDRAW message." EOS]

[LBS_OWNERDRAWFIXEDhelp: B$ "LBS_OWNERDRAWFIXED:

The items are fixed height.

The owner of the list box redraws its contents when it receives the WM_MEASUREITEM (on creation) or WM_DRAWITEM (on change) messages." EOS]

[LBS_OWNERDRAWVARIABLEhelp: B$ "LBS_OWNERDRAWVARIABLE:

Items are variable heights.

The owner of the list box redraws its contents when it receives the WM_MEASUREITEM (on creation) or WM_DRAWITEM (on change) messages." EOS]
; WS_BORDERhelp: SPC EOS
; WS_VSCROLLhelp: SPC EOS
; WS_HSCROLLhelp: SPC EOS

[ListBoxStyles:
 D$ LBS_HASSTRINGShelp
 D$ LBS_NOTIFYhelp
 D$ LBS_SORThelp
 D$ LBS_STANDARDhelp
 D$ LBS_USETABSTOPShelp
 D$ LBS_WANTKEYBOARDINPUThelp
 D$ LBS_DISABLENOSCROLLhelp
 D$ LBS_EXTENDEDSELhelp
 D$ LBS_MULTICOLUMNhelp
 D$ LBS_MULTIPLESELhelp
 D$ LBS_NODATAhelp
 D$ LBS_NOINTEGRALHEIGHThelp
 D$ LBS_NOSELhelp
 D$ LBS_NOREDRAWhelp
 D$ LBS_OWNERDRAWFIXEDhelp
 D$ LBS_OWNERDRAWVARIABLEhelp
 D$ WS_TABSTOPhelp
 D$ WS_BORDERhelp
 D$ WS_VSCROLLhelp
 D$ WS_HSCROLLhelp]
____________________________________

; Scroll Controls tables:

[ScrollCheckingMask:
 D$ 01
 D$ 06
 D$ 06
 D$ 01
 D$ 06
 D$ 06
 D$ 010
 D$ 08
 D$ 06
 D$ 06
 D$ 0]

[ScrollTextTable:
 B$ 'SBS_HORZ' EOS
 B$ 'SBS_TOPALIGN' EOS
 B$ 'SBS_BOTTOMALIGN' EOS
 B$ 'SBS_VERT' EOS
 B$ 'SBS_LEFTALIGN' EOS
 B$ 'SBS_RIGHTALIGN' EOS
 B$ 'SBS_SIZEBOX' EOS
 B$ 'SBS_SIZEGRIP' EOS
 B$ 'SBS_SIZEBOXBOTTOMRIGHTALIGN' EOS
 B$ 'SBS_SIZEBOXTOPLEFTALIGN' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 0]

[ScrollBitTable:
 D$ &SBS_HORZ
 D$ &SBS_TOPALIGN
 D$ &SBS_BOTTOMALIGN
 D$ &SBS_VERT
 D$ &SBS_LEFTALIGN
 D$ &SBS_RIGHTALIGN
 D$ &SBS_SIZEBOX
 D$ &SBS_SIZEGRIP
 D$ &SBS_SIZEBOXBOTTOMRIGHTALIGN
 D$ &SBS_SIZEBOXTOPLEFTALIGN
 D$ &WS_TABSTOP]

[ScrollExcludeBitTable:
 D$ 019
 D$ 019
 D$ 019
 D$ 018
 D$ 018
 D$ 018
 D$ 010
 D$ 08
 D$ 0
 D$ 0
 D$ 0]

[ScrollMustHaveBitTable:
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 1
 D$ 1
 D$ 0
 D$ 0
 D$ 8
 D$ 8
 D$ 0]

[SBS_HORZhelp: B$ "SBS_HORZ:

The scroll bar will be horizontal." EOS]

[SBS_TOPALIGNhelp: B$ "SBS_TOPALIGN:

To be used with SBS_HORZ, to align the scroll bar top edge with the bounding rectangle." EOS]

[SBS_BOTTOMALIGNhelp: B$ "SBS_BOTTOMALIGN:

To be used with SBS_HORZ, to align the scroll bar bottom edge with the bounding rectangle." EOS]

[SBS_VERThelp: B$ "SBS_VERT:

The scroll bar will be vertical." EOS]

[SBS_LEFTALIGNhelp: B$ "SBS_LEFTALIGN:

To be used with SBS_VERT, to align the scroll bar left edge with the bounding rectangle." EOS]

[SBS_RIGHTALIGNhelp: B$ "SBS_RIGHTALIGN:

To be used with SBS_VERT, to align the scroll bar right edge with the bounding rectangle." EOS]

[SBS_SIZEBOXhelp: B$ "SBS_SIZEBOX:

Features the scroll bar with a size box style.

Does not seem to work, at least under 95.

See SBS_SIZEGRIP." EOS]

[SBS_SIZEGRIPhelp: B$ "SBS_SIZEGRIP:

Adds a resize bitmap left bottom corner of the scroll bar." EOS]

[SBS_SIZEBOXBOTTOMRIGHTALIGNhelp: B$ "SBS_SIZEBOXBOTTOMRIGHTALIGN:

to be used with SBS_SIZEBOX.

Like SBS_SIZEBOX, does not seem to work." EOS]

[SBS_SIZEBOXTOPLEFTALIGNhelp: B$ "SBS_SIZEBOXBOTTOMRIGHTALIGN:

To be used with SBS_SIZEBOX.

Like SBS_SIZEBOX, does not seem to work." EOS]

[ScrollStylesHelp:
 D$ SBS_HORZhelp
 D$ SBS_TOPALIGNhelp
 D$ SBS_BOTTOMALIGNhelp
 D$ SBS_VERThelp
 D$ SBS_LEFTALIGNhelp
 D$ SBS_RIGHTALIGNhelp
 D$ SBS_SIZEBOXhelp
 D$ SBS_SIZEGRIPhelp
 D$ SBS_SIZEBOXBOTTOMRIGHTALIGNhelp
 D$ SBS_SIZEBOXTOPLEFTALIGNhelp
 D$ WS_TABSTOPhelp]
____________________________________

; Combo Box tables:

[ComboCheckingMask:
 D$ &CBS_DROPDOWNLIST
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0F000
 D$ 0F000
 D$ &CBS_DROPDOWNLIST
 D$ &CBS_DROPDOWNLIST
 D$ 0
 D$ 0
 D$ 0F0
 D$ 0F0
 D$ 0
 D$ 0
 D$ 0]

[ComboTextTable:
 B$ 'CBS_SIMPLE' EOS
 B$ 'CBS_HASSTRINGS' EOS
 B$ 'CBS_SORT' EOS
 B$ 'CBS_AUTOHSCROLL' EOS
 B$ 'CBS_DISABLENOSCROLL' EOS
 B$ 'CBS_LOWERCASE' EOS
 B$ 'CBS_UPPERCASE' EOS
 B$ 'CBS_DROPDOWN' EOS
 B$ 'CBS_DROPDOWNLIST' EOS
 B$ 'CBS_NOINTEGRALHEIGHT' EOS
 B$ 'CBS_OEMCONVERT' EOS
 B$ 'CBS_OWNERDRAWFIXED' EOS
 B$ 'CBS_OWNERDRAWVARIABLE' EOS
 B$ 'WS_VSCROLL' EOS
 B$ 'WS_HSCROLL' EOS
 B$ 'WS_TABSTOP' EOS 0]

[ComboBitTable:
 D$ &CBS_SIMPLE
 D$ &CBS_HASSTRINGS
 D$ &CBS_SORT
 D$ &CBS_AUTOHSCROLL
 D$ &CBS_DISABLENOSCROLL
 D$ &CBS_LOWERCASE
 D$ &CBS_UPPERCASE
 D$ &CBS_DROPDOWN
 D$ &CBS_DROPDOWNLIST
 D$ &CBS_NOINTEGRALHEIGHT
 D$ &CBS_OEMCONVERT
 D$ &CBS_OWNERDRAWFIXED
 D$ &CBS_OWNERDRAWVARIABLE
 D$ &WS_VSCROLL
 D$ &WS_HSCROLL
 D$ &WS_TABSTOP]

[ComboExcludeBitTable:
 D$ 0FF
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ &CBS_UPPERCASE
 D$ &CBS_LOWERCASE
 D$ &CBS_DROPDOWNLIST
 D$ 0
 D$ 0
 D$ 0
 D$ &CBS_OWNERDRAWVARIABLE
 D$ &CBS_OWNERDRAWFIXED
 D$ 0
 D$ 0
 D$ 0]

[ComboMustHaveBitTable:
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ &CBS_AUTOHSCROLL
 D$ &CBS_HASSTRINGS
 D$ &CBS_HASSTRINGS
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[CBS_SIMPLEhelp: B$ "CBS_SIMPLE:

The list box is always displayed.

The current selection is displayed in the edit control." EOS]

[CBS_HASSTRINGShelp: B$ "CBS_HASSTRINGS:

The combo box items are strings.

The application makes use of CB_GETLBTEXT for retrieving one text item." EOS]

[CBS_SORThelp: B$ "CBS_SORT:

When you will fill the list box, the items will be Automatically sorted." EOS]

[CBS_AUTOHSCROLLhelp: B$ "CBS_AUTOHSCROLL:

In the edit control, the text will scroll Automatically when needed." EOS]

[CBS_DISABLENOSCROLLhelp: B$ "CBS_DISABLENOSCROLL:

Does not hide the scroll bar when it is useless." EOS]

[CBS_LOWERCASEhelp: B$ "CBS_LOWERCASE:

All Chars entered in the edit control will be turned lower case." EOS]

[CBS_UPPERCASEhelp: B$ "CBS_UPPERCASE:

All Chars entered in the edit control will be turned upper case." EOS]

[CBS_DROPDOWNhelp: B$ "CBS_DROPDOWN:

Same as CBS_SIMPLE, but the list box will only be displayed after the user selects the down arrow of the edit control." EOS]

[CBS_DROPDOWNLISThelp: B$ "CBS_DROPDOWNLIST:

Same as CBS_SIMPLE, but the list box will only be displayed after the user selects the down arrow of the edit control, just like with CBS_DROPDOWN, but the Edit Control is replaced by a static control." EOS]

[CBS_NOINTEGRALHEIGHThelp: B$ "CBS_NOINTEGRALHEIGHT:

Blocks automatic resizing depending on the size of items." EOS]

[CBS_OEMCONVERThelp: B$ "CBS_OEMCONVERT:

Converts text entered, from the Windows character set to the OEM character set and then back to the Windows set. This ensures proper character conversion when the application calls the CharToOem function to convert a string to OEM.

Useful for retrieving filenames." EOS]

[CBS_OWNERDRAWFIXEDhelp: B$ "CBS_OWNERDRAWFIXED:

All items are same hight.

The owner of the list box redraws its contents when it receives the WM_MEASUREITEM (on creation) or WM_DRAWITEM (on change) messages." EOS]

[CBS_OWNERDRAWVARIABLEhelp: B$ "CBS_OWNERDRAWVARIABLE:

The items are variable hights.

The owner of the list box redraws its contents when it receives the WM_MEASUREITEM (on creation) or WM_DRAWITEM (on change) messages." EOS]
; WS_VSCROLLhelp:
; WS_HSCROLLhelp:

[ComboStylesHelp:
 D$ CBS_SIMPLEhelp
 D$ CBS_HASSTRINGShelp
 D$ CBS_SORThelp
 D$ CBS_AUTOHSCROLLhelp
 D$ CBS_DISABLENOSCROLLhelp
 D$ CBS_LOWERCASEhelp
 D$ CBS_UPPERCASEhelp
 D$ CBS_DROPDOWNhelp
 D$ CBS_DROPDOWNLISThelp
 D$ CBS_NOINTEGRALHEIGHThelp
 D$ CBS_OEMCONVERThelp
 D$ CBS_OWNERDRAWFIXEDhelp
 D$ CBS_OWNERDRAWVARIABLEhelp
 D$ WS_VSCROLLhelp
 D$ WS_HSCROLLhelp
 D$ WS_TABSTOPhelp]
____________________________________

; UpDown controls tables:

[UpDownCheckingMask: D$ ? # 9]

[UpDownTextTable:
 B$ 'UDS_ALIGNLEFT' EOS
 B$ 'UDS_ALIGNRIGHT' EOS
 B$ 'UDS_SETBUDDYINT' EOS
 B$ 'UDS_NOTHOUSANDS' EOS
 B$ 'UDS_ARROWKEYS' EOS
 B$ 'UDS_HORZ' EOS
 B$ 'UDS_WRAP' EOS
 B$ 'UDS_AUTOBUDDY' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 0]

[UpDownBitTable:
 D$ &UDS_ALIGNLEFT
 D$ &UDS_ALIGNRIGHT
 D$ &UDS_SETBUDDYINT
 D$ &UDS_NOTHOUSANDS
 D$ &UDS_ARROWKEYS
 D$ &UDS_HORZ
 D$ &UDS_WRAP
 D$ &UDS_AUTOBUDDY
 D$ &WS_TABSTOP]

[UpDownExcludeBitTable:
 D$ 4
 D$ 8
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[UpDownMustHaveBitTable: D$ ? # 9]

[UDS_ALIGNLEFThelp: B$ "UDS_ALIGNLEFT:

The up-down control will be at the left edge of the buddy window." EOS]

[UDS_ALIGNRIGHThelp: B$ "UDS_ALIGNRIGHT:

The up-down control will be at the right edge of the buddy window." EOS]

[UDS_SETBUDDYINThelp: B$ "UDS_SETBUDDYINT:

The up-down control will set the text of the buddy window when needed (numbers only).

The buddy window may be set by UDS_AUTOBUDDY." EOS]

[UDS_NOTHOUSANDShelp: B$ "UDS_NOTHOUSANDS:

Reverses default, which is to insert a thousands'separator between each three digits." EOS]

[UDS_ARROWKEYShelp: B$ "UDS_ARROWKEYS:

Allows keyboard UP ARROW and DOWN ARROW keys alternate inputs." EOS]

[UDS_HORZhelp: B$ "UDS_HORZ:

Default is vertical..." EOS]

[UDS_WRAPhelp: B$ "UDS_WRAP:

Restarts at other end, when moving out of range." EOS]

[UDS_AUTOBUDDYhelp: B$ "UDS_AUTOBUDDY:
 
Automatically selcts the previous Z order window as the associated buddy window.
The 'previous Z order Window' is the previous one in the Template." EOS]

[UpDownStylesHelp:
 D$ UDS_ALIGNLEFThelp
 D$ UDS_ALIGNRIGHThelp
 D$ UDS_SETBUDDYINThelp
 D$ UDS_NOTHOUSANDShelp
 D$ UDS_ARROWKEYShelp
 D$ UDS_HORZhelp
 D$ UDS_WRAPhelp
 D$ UDS_AUTOBUDDYhelp
 D$ WS_TABSTOPhelp]
____________________________________

; Progress bar have nothing to edit:

[ProgressTextTable: D$ ? ?]
____________________________________

; Track Bars controls tables:

[TrackCheckingMask: D$ ? # 13]

[TrackTextTable:
 B$ 'TBS_HORZ' EOS
 B$ 'TBS_BOTTOM' EOS
 B$ 'TBS_TOP' EOS
 B$ 'TBS_VERT' EOS
 B$ 'TBS_RIGHT' EOS
 B$ 'TBS_LEFT' EOS
 B$ 'TBS_AUTOTICKS' EOS
 B$ 'TBS_NOTICKS' EOS
 B$ 'TBS_BOTH' EOS
 B$ 'TBS_ENABLESELRANGE' EOS
 B$ 'TBS_FIXEDLENGTH' EOS
 B$ 'TBS_NOTHUMB' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 0]

[TrackBitTable:
 D$ &TBS_HORZ
 D$ &TBS_BOTTOM
 D$ &TBS_TOP
 D$ &TBS_VERT
 D$ &TBS_RIGHT
 D$ &TBS_LEFT
 D$ &TBS_AUTOTICKS
 D$ &TBS_NOTICKS
 D$ &TBS_BOTH
 D$ &TBS_ENABLESELRANGE
 D$ &TBS_FIXEDLENGTH
 D$ &TBS_NOTHUMB
 D$ &WS_TABSTOP]

[TrackExcludeBitTable:
 D$ 2
 D$ 2
 D$ 2
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[TrackMustHaveBitTable:
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 2
 D$ 2
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[TBS_HORZhelp: B$ "TBS_HORZ:

The trackbar will be horizontal." EOS]

[TBS_BOTTOMhelp: B$ "TBS_BOTTOM:

Position of the tick marks in an horizontal trackbar." EOS]

[TBS_TOPhelp: B$ "TBS_TOP:

Position of the tick marks in an horizontal trackbar." EOS]

[TBS_VERThelp: B$ "TBS_VERT:

The trackbar will be vertical." EOS]

[TBS_RIGHThelp: B$ "TBS_RIGHT:

Position of the tick marks in a vertical trackbar." EOS]

[TBS_LEFThelp: B$ "TBS_LEFT:

Position of the tick marks in a vertical trackbar." EOS]

[TBS_AUTOTICKShelp: B$ "TBS_AUTOTICKS:

The tick mark will be added automatically when your application will send the TBM_SETRANGE message.

Otherwise, you can send the TBM_SETTIC and TBM_SETTICFREQ, to specify these positions." EOS]

[TBS_NOTICKShelp: B$ "TBS_NOTICKS:

Does not display the tick marks." EOS]

[TBS_BOTHhelp: B$ "TBS_BOTH:

Displays tick marks on both side of the track bar (left/right with TBS_VERT.Down top with TBS_HORZ)." EOS]

[TBS_ENABLESELRANGEhelp: B$ "TBS_ENABLESELRANGE:

Displays edge ticks as triangles and the selection range is highlighted." EOS]

[TBS_FIXEDLENGTHhelp: B$ "TBS_FIXEDLENGTH:

The slider size will not vary with the size of range, as it does by default." EOS]

[TBS_NOTHUMBhelp: B$ "TBS_NOTHUMB:

Disables the slider." EOS]

[TrackStylesHelp:
 D$ TBS_HORZhelp
 D$ TBS_BOTTOMhelp
 D$ TBS_TOPhelp
 D$ TBS_VERThelp
 D$ TBS_RIGHThelp
 D$ TBS_LEFThelp
 D$ TBS_AUTOTICKShelp
 D$ TBS_NOTICKShelp
 D$ TBS_BOTHhelp
 D$ TBS_ENABLESELRANGEhelp
 D$ TBS_FIXEDLENGTHhelp
 D$ TBS_NOTHUMBhelp
 D$ WS_TABSTOPhelp]
____________________________________

; TreeView Controls tables:

[TreeCheckingMask: D$ ? # 17]

[TreeTextTable:
 B$ 'TVS_HASLINES' EOS
 B$ 'TVS_LINESATROOT' EOS
 B$ 'TVS_HASBUTTONS' EOS
 B$ 'TVS_EDITLABELS' EOS
 B$ 'TVS_SHOWSELALWAYS' EOS
 B$ 'TVS_DISABLEDRAGDROP ' EOS
 B$ 'TVS_RTLREADING ' EOS
 B$ 'TVS_NOTOOLTIPS ' EOS
 B$ 'TVS_CHECKBOXES ' EOS
 B$ 'TVS_TRACKSELECT ' EOS
 B$ 'TVS_SINGLEEXPAND ' EOS
 B$ 'TVS_INFOTIP ' EOS
 B$ 'TVS_FULLROWSELECT ' EOS
 B$ 'TVS_NOSCROLL ' EOS
 B$ 'TVS_NONEVENHEIGHT ' EOS
 B$ 'TVS_NOHSCROLL ' EOS
 B$ 'WS_TABSTOP' EOS
 B$  0]

[TreeBitTable:
 D$ &TVS_HASLINES
 D$ &TVS_LINESATROOT
 D$ &TVS_HASBUTTONS
 D$ &TVS_EDITLABELS
 D$ &TVS_SHOWSELALWAYS
 D$ &TVS_DISABLEDRAGDROP
 D$ &TVS_RTLREADING
 D$ &TVS_NOTOOLTIPS
 D$ &TVS_CHECKBOXES
 D$ &TVS_TRACKSELECT
 D$ &TVS_SINGLEEXPAND
 D$ &TVS_INFOTIP
 D$ &TVS_FULLROWSELECT
 D$ &TVS_NOSCROLL
 D$ &TVS_NONEVENHEIGHT
 D$ &TVS_NOHSCROLL
 D$ &WS_TABSTOP]

[TreeExcludeBitTable:
 D$ &TVS_FULLROWSELECT
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ &TVS_INFOTIP
 D$ 0
 D$ 0
 D$ 0
 D$ &TVS_NOTOOLTIPS
 D$ &TVS_HASLINES
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[TreeMustHaveBitTable: D$ ? # 17]

[TVS_HASLINEShelp: B$ "TVS_HASLINES:

Draws lines showing the items hierarchy." EOS]

[TVS_LINESATROOThelp: B$ "TVS_LINESATROOT:

Draws lines between root and items.

Does not work with TVS_HASLINES." EOS]

[TVS_HASBUTTONShelp: B$ "TVS_HASBUTTONS:

Displays plus and minus buttons aside the parent items.

They are used to open / close the lists of  child items." EOS]

[TVS_EDITLABELShelp: B$ "TVS_EDITLABELS:

Allows edition of the items by user." EOS]

[TVS_SHOWSELALWAYShelp: B$ "TVS_SHOWSELALWAYS:

When lossing the focus, the tree-view will maintain the actual selection." EOS]

[TVS_DISABLEDRAGDROPhelp: B$ "TVS_DISABLEDRAGDROP:

Prevents the tree-view control from sending TVN_BEGINDRAG notification messages. " EOS]

[TVS_RTLREADINGhelp: B$ "TVS_RTLREADING:

Version 4.70. Causes text to be displayed from right-to-left (RTL).
Usually, windows display text left-to-right (LTR). Windows can be mirrored to display languages such
as Hebrew or Arabic that read RTL. Typically, tree-view text is displayed in the same direction as the text
in its parent window. If TVS_RTLREADING is set, tree-view text reads in the opposite direction from the text in
the parent window." EOS]

[TVS_NOTOOLTIPShelp: B$ "TVS_NOTOOLTIPS:

Version 4.70. Disables ToolTips." EOS]

[TVS_CHECKBOXEShelp: B$ "TVS_CHECKBOXES:

Version 4.70. Enables check boxes for items in a tree-view control. A check box is displayed only if an image is
associated with the item. When set to this style, the control effectively uses DrawFrameControl to create and set
a state image list containing two images. State image 1 is the unchecked box and state image 2 is the checked box.
Setting the state image to zero removes the check box altogether.

Version 5.80. Displays a check box even if no image is associated with the item. Once a tree-view control is created
with this style, the style cannot be removed. Instead, you must destroy the control and create a new one in its place.
Destroying the tree-view control does not destroy the check box state image list. You must destroy it explicitly.
Get the handle to the state image list by sending the tree-view control a TVM_GETIMAGELIST message.
Then destroy the image list with ImageList_Destroy.
     
If you want to use this style, you must set the TVS_CHECKBOXES style with SetWindowLong after you create the
treeview control, and before you populate the tree. Otherwise, the checkboxes might appear unchecked, depending
on timing issues." EOS]

[TVS_TRACKSELECThelp: B$ "TVS_TRACKSELECT:

Version 4.70. Enables hot tracking in a tree-view control." EOS]

[TVS_SINGLEEXPANDhelp: B$ "TVS_SINGLEEXPAND:

Version 4.71. Causes the item being selected to expand and the item being unselected to collapse upon selection
in the tree view. If the mouse is used to single-click the selected item and that item is closed, it will be expanded.
If the user holds down the CTRL key while selecting an item, the item being unselected will not be collapsed.

Version 5.80. Causes the item being selected to expand and the item being unselected to collapse upon selection in
the tree view. If the user holds down the CTRL key while selecting an item, the item being unselected will not be
collapsed." EOS]

[TVS_INFOTIPhelp: B$ "TVS_INFOTIP:

Version 4.71. Obtains ToolTip information by sending the TVN_GETINFOTIP notification." EOS]

[TVS_FULLROWSELECThelp: B$ "TVS_FULLROWSELECT:

Version 4.71. Enables full-row selection in the tree view. The entire row of the selected item is highlighted,
and clicking anywhere on an item's row causes it to be selected. This style cannot be used in conjunction with
the TVS_HASLINES style." EOS]

[TVS_NOSCROLLhelp: B$ "TVS_NOSCROLL:

Version 5.80. Disables horizontal scrolling in the control. The control will not display any horizontal scroll bars." EOS]

[TVS_NONEVENHEIGHThelp: B$ "TVS_NONEVENHEIGHT:

Version 4.71 Sets the height of the items to an odd height with the TVM_SETITEMHEIGHT message. By default, the height
of items must be an even value." EOS]

[TVS_NOHSCROLLhelp: B$ "TVS_NOHSCROLL:

Version 5.80. Disables horizontal scrolling in the control. The control will not display any horizontal scroll bars." EOS]

[TreeViewStylesHelp:
 D$ TVS_HASLINEShelp
 D$ TVS_LINESATROOThelp
 D$ TVS_HASBUTTONShelp
 D$ TVS_EDITLABELShelp
 D$ TVS_SHOWSELALWAYShelp
 D$ TVS_DISABLEDRAGDROPhelp
 D$ TVS_RTLREADINGhelp
 D$ TVS_NOTOOLTIPShelp
 D$ TVS_CHECKBOXEShelp
 D$ TVS_TRACKSELECThelp
 D$ TVS_SINGLEEXPANDhelp
 D$ TVS_INFOTIPhelp
 D$ TVS_FULLROWSELECThelp
 D$ TVS_NOSCROLLhelp
 D$ TVS_NONEVENHEIGHThelp
 D$ TVS_NOHSCROLLhelp
 D$ WS_TABSTOPhelp]
____________________________________

; Tabs Controls tables:

[TabCheckingMask: D$ ? # 19]

[TabTextTable:
 B$ 'TCS_SCROLLOPPOSITE' EOS
 B$ 'TCS_RIGHT/TCS_BOTTOM' EOS
 B$ 'TCS_MULTISELECT' EOS
 B$ 'TCS_FLATBUTTONS' EOS
 B$ 'TCS_FORCEICONLEFT' EOS
 B$ 'TCS_FORCELABELLEFT' EOS
 B$ 'TCS_HOTTRACK' EOS
 B$ 'TCS_VERTICAL' EOS
 B$ 'TCS_BUTTONS' EOS
 B$ 'TCS_MULTILINE' EOS
 B$ 'TCS_FIXEDWIDTH' EOS
 B$ 'TCS_RAGGEDRIGHT' EOS
 B$ 'TCS_FOCUSONBUTTONDOWN' EOS
 B$ 'TCS_OWNERDRAWFIXED' EOS
 B$ 'TCS_TOOLTIPS' EOS
 B$ 'TCS_FOCUSNEVER' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 'WS_CHILD' EOS
 B$ 'WS_VISIBLE' EOS
 B$ 0]

[TabBitTable:
 D$ &TCS_SCROLLOPPOSITE
 D$ &TCS_RIGHT
 D$ &TCS_MULTISELECT
 D$ &TCS_FLATBUTTONS
 D$ &TCS_FORCEICONLEFT
 D$ &TCS_FORCELABELLEFT
 D$ &TCS_HOTTRACK
 D$ &TCS_VERTICAL
 D$ &TCS_BUTTONS
 D$ &TCS_MULTILINE
 D$ &TCS_FIXEDWIDTH
 D$ &TCS_RAGGEDRIGHT
 D$ &TCS_FOCUSONBUTTONDOWN
 D$ &TCS_OWNERDRAWFIXED
 D$ &TCS_TOOLTIPS
 D$ &TCS_FOCUSNEVER
 D$ &WS_TABSTOP
 D$ &WS_CHILD
 D$ &WS_VISIBLE]

[TabExcludeBitTable:
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ &TCS_FORCELABELLEFT
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ &TCS_FOCUSNEVER
 D$ 0
 D$ 0
 D$ &TCS_FOCUSONBUTTONDOWN
 D$ 0
 D$ 0
 D$ 0]

[TabMustHaveBitTable:
 D$ 0
 D$ 0
 D$ 0
 D$ &TCS_BUTTONS
 D$ &TCS_FIXEDWIDTH
 D$ &TCS_FIXEDWIDTH+&TCS_FORCEICONLEFT
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ &TCS_FORCELABELLEFT
 D$ 0
 D$ &TCS_BUTTONS
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[TCS_SCROLLOPPOSITEhelp: B$ " TCS_SCROLLOPPOSITE:

Scrolls the Tab Control" EOS]

[TCS_RIGHThelp: B$ "TCS_RIGHT:

Places the Tab control vertically at the right corner of the control. It must be used with TCS_VERTICAL to display the tabs at the right corner.

This equate is the same as TCS_BOTTOM. But if it is used alone, the tab itens are placed horizontally at the bottom of the control." EOS]

[TCS_MULTISELECThelp: B$ "TCS_MULTISELECT:

Enables multi-selection mode of the tab itens" EOS]

[TCS_FLATBUTTONShelp: B$ "TCS_FLATBUTTONS:

The tab itens are in Flat mode" EOS]

[TCS_FORCEICONLEFThelp: B$ "TCS_FORCEICONLEFT:

Only with TCS_FIXEDWIDTH.

Icons will be aligned to the left of each tab." EOS]

[TCS_FORCELABELLEFThelp: B$ "TCS_FORCELABELLEFT:

Only with TCS_FIXEDWIDTH.

Labels will be be aligned to the left of each tab." EOS]

[TCS_HOTTRACKhelp: B$ "TCS_HOTTRACK:

Highlite the Text Label of the Tab." EOS]

[TCS_VERTICALhelp: B$ "TCS_VERTICAL:

Places the Tab itens vertically. By default the itens are places in the left corner of the Control. To display them in the right corner, use this equate with TCS_RIGHT." EOS]

[TCS_BUTTONShelp: B$ "TCS_BUTTONS:

Tabs are shown in the form of buttons." EOS]

[TCS_MULTILINEhelp: B$ "TCS_MULTILINE:

Allows multiple rows of tabs, when needed." EOS]

[TCS_FIXEDWIDTHhelp: B$ "TCS_FIXEDWIDTH:

Cannot be combined with TCS_RIGHTJUSTIFY.

All tabs will be the same width." EOS]

[TCS_RAGGEDRIGHThelp: B$ "TCS_RAGGEDRIGHT:

By default, Tabs are extended to entire fill the with of their control.

TCS_RAGGEDRIGHT prevents from this if unwanted." EOS]

[TCS_FOCUSONBUTTONDOWNhelp: B$ "CS_FOCUSONBUTTONDOWN:

Tabs receive the focus when clicked." EOS]

[TCS_OWNERDRAWFIXEDhelp: B$ "TCS_OWNERDRAWFIXED:

The parent window will draw the tabs." EOS]

[TCS_TOOLTIPShelp: B$ "TCS_TOOLTIPS:

The tabs control will display tooltips.

See Tooltip Controls in Win Help." EOS]

[TCS_FOCUSNEVERhelp: B$ "TCS_FOCUSNEVER:

Tabs never receive the focus (the Dialog does)." EOS]

[CCS_BOTTOMhelp: B$ "CCS_BOTTOM:

Common Controls style:

Inverts the vertical apearance of the control." EOS]


[TabStylesHelp:
 D$ TCS_SCROLLOPPOSITEhelp
 D$ TCS_RIGHThelp
 D$ TCS_MULTISELECThelp
 D$ TCS_FLATBUTTONShelp
 D$ TCS_FORCEICONLEFThelp
 D$ TCS_FORCELABELLEFThelp
 D$ TCS_HOTTRACKhelp
 D$ TCS_VERTICALhelp
 D$ TCS_BUTTONShelp
 D$ TCS_MULTILINEhelp
 D$ TCS_FIXEDWIDTHhelp
 D$ TCS_RAGGEDRIGHThelp
 D$ TCS_FOCUSONBUTTONDOWNhelp
 D$ TCS_OWNERDRAWFIXEDhelp
 D$ TCS_TOOLTIPShelp
 D$ TCS_FOCUSNEVERhelp
 D$ WS_TABSTOPhelp
 D$ WS_CHILDhelp
 D$ WS_VISIBLEhelp]
____________________________________


; ListView Controls tables:

;[ListViewCheckingMask: &LVS_LIST &LVS_LIST &LVS_LIST &LVS_LIST 0
[ListViewCheckingMask:
 D$ 0
 D$ 03
 D$ 03
 D$ 03
 D$ 0
 D$ 0F0
 D$ 0F0
 D$ 0
 D$ 0F000
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 ;0F0 0
 D$ 0
 D$ 0F000
 D$ 0]

[ListViewTextTable:
 B$ 'LVS_ICON' EOS
 B$ 'LVS_SMALLICON' EOS
 B$ 'LVS_LIST' EOS
 B$ 'LVS_REPORT' EOS
 B$ 'LVS_NOCOLUMNHEADER' EOS
 B$ 'LVS_SORTASCENDING' EOS
 B$ 'LVS_SORTDESCENDING' EOS
 B$ 'LVS_NOSORTHEADER' EOS
 B$ 'LVS_AUTOARRANGE' EOS
 B$ 'LVS_OWNERDRAWFIXED' EOS
 B$ 'LVS_OWNERDATA' EOS
 B$ 'LVS_EDITLABELS' EOS
 B$ 'LVS_NOLABELWRAP' EOS
 B$ 'LVS_NOSCROLL' EOS
 B$ 'LVS_SINGLESEL' EOS
 B$ 'LVS_SHOWSELALWAYS' EOS
 B$ 'LVS_SHAREIMAGELISTS' EOS
 B$ 'LVS_ALIGNLEFT' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 0]

[ListViewBitTable:
 D$ &LVS_ICON
 D$ &LVS_SMALLICON
 D$ &LVS_LIST
 D$ &LVS_REPORT
 D$ &LVS_NOCOLUMNHEADER
 D$ &LVS_SORTASCENDING
 D$ &LVS_SORTDESCENDING
 D$ &LVS_NOSORTHEADER
 D$ &LVS_AUTOARRANGE
 D$ &LVS_OWNERDRAWFIXED
 D$ &LVS_OWNERDATA
 D$ &LVS_EDITLABELS
 D$ &LVS_NOLABELWRAP
 D$ &LVS_NOSCROLL
 D$ &LVS_SINGLESEL
 D$ &LVS_SHOWSELALWAYS
 D$ &LVS_SHAREIMAGELISTS
 D$ &LVS_ALIGNLEFT
 D$ &WS_TABSTOP]
; &LVS_ALIGNLEFT &LVS_ALIGNTOP &LVS_AUTOARRANGE &LVS_BUTTON &LVS_EDITLABELS &LVS_NOLABELWRAP
; &LVS_NOSCROLL &LVS_NOSORTHEADER &LVS_OWNERDRAWFIXED &LVS_SHAREIMAGELISTS &LVS_SHOWSELALWAYS
; &LVS_SINGLESEL &LVS_SORTASCENDING &LVS_SORTDESCENDING

;[ListViewExcludeBitTable: &LVS_LIST  &LVS_LIST  &LVS_LIST  &LVS_LIST__&LVS_ALIGNLEFT  0
[ListViewExcludeBitTable:
 D$ &LVS_SMALLICON+&LVS_LIST+&LVS_REPORT
 D$ &LVS_LIST+&LVS_REPORT+&LVS_ICON
 D$ &LVS_SMALLICON+&LVS_REPORT+&LVS_ICON
 D$ &LVS_ICON+&LVS_SMALLICON+&LVS_LIST+&LVS_ALIGNLEFT
 D$ 0
 D$ &LVS_SORTDESCENDING+&LVS_NOSORTHEADER+&LVS_AUTOARRANGE
 D$ &LVS_SORTASCENDING+&LVS_NOSORTHEADER+&LVS_AUTOARRANGE
 D$ &LVS_SORTASCENDING+&LVS_SORTDESCENDING
 D$ &LVS_SORTASCENDING+&LVS_SORTDESCENDING
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ &LVS_REPORT
 D$ 0]

[ListViewMustHaveBitTable: D$ ? # 19]

[LVS_ICONhelp: B$ "LVS_ICON:

Indicates an Icon view." EOS]

[LVS_SMALLICONhelp: B$ "LVS_SMALLICON:

Indicates a small Icon view." EOS]

[LVS_LISThelp: B$ "LVS_LIST:

Simple list view." EOS]

[LVS_REPORThelp: B$ "LVS_REPORT:

Report view: The first column is always left-aligned, and you cannot use LVCFMT_RIGHT to change this." EOS]

[LVS_NOCOLUMNHEADERhelp: B$ "LVS_NOCOLUMNHEADER:

A column header is not displayed (as it would be by default)." EOS]

[LVS_SORTASCENDINGhelp: B$ "LVS_SORTASCENDING:

Sorts the List View in ascendent order accordying to the 1st item of your list view." EOS]

[LVS_SORTDESCENDINGhelp: B$ "LVS_SORTDESCENDING:

Sorts the List View in descendent order." EOS]

[LVS_NOSORTHEADERhelp: B$ "LVS_NOSORTHEADER:

Disables the Sort ordering of the header of the ListView Control." EOS]

[LVS_AUTOARRANGEhelp: B$ "LVS_AUTOARRANGE:

Auto-Organize the List View Control Itens. This is used by default." EOS]

[LVS_OWNERDRAWFIXEDhelp: B$ "LVS_OWNERDRAWFIXED:
The items are fixed height.

The owner of the list box redraws its contents when it receives the WM_MEASUREITEM (on creation) or WM_DRAWITEM (on change) messages." EOS]

[LVS_OWNERDATAhelp: B$ "LVS_OWNERDATA:
The owner of the list box redraws its contents when it receives the WM_MEASUREITEM (on creation) or WM_DRAWITEM (on change) messages." EOS]

[LVS_EDITLABELShelp: B$ "LVS_EDITLABELS:
Allows editing the item Label. To allow edition all you have to do is press the left button of the mouse over a selected item for a couple of seconds to allow the edition mode" EOS]

[LVS_NOLABELWRAPhelp: B$ "LVS_NOLABELWRAP:
Disables the wrapping mode of the item label" EOS]

[LVS_NOSCROLLhelp: B$ "LVS_NOSCROLL:
Disables the scrollbar of the ListView Control" EOS]

[LVS_SINGLESELhelp: B$ "LVS_SINGLESEL:
Allows selection of a row" EOS]

[LVS_SHOWSELALWAYShelp: B$ "LVS_SHOWSELALWAYS:
Always displays the selection mode" EOS]

[LVS_SHAREIMAGELISTShelp: B$ "LVS_SHAREIMAGELISTS:
Allows using images or icons with the ListView Control" EOS]

[ListViewStylesHelp:
 D$ LVS_ICONhelp
 D$ LVS_SMALLICONhelp
 D$ LVS_LISThelp
 D$ LVS_REPORThelp
 D$ LVS_NOCOLUMNHEADERhelp
 D$ LVS_SORTASCENDINGhelp
 D$ LVS_SORTDESCENDINGhelp
 D$ LVS_NOSORTHEADERhelp
 D$ LVS_AUTOARRANGEhelp
 D$ LVS_OWNERDRAWFIXEDhelp
 D$ LVS_OWNERDATAhelp
 D$ LVS_EDITLABELShelp
 D$ LVS_NOLABELWRAPhelp
 D$ LVS_NOSCROLLhelp
 D$ LVS_SINGLESELhelp
 D$ LVS_SHOWSELALWAYShelp
 D$ LVS_SHAREIMAGELISTShelp
 D$ WS_TABSTOPhelp]
____________________________________

; ToolBar Control Tables:

[ToolBarCheckingMask:
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F0
 D$ 0F0
 D$ 0F0
 D$ 0F0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0F
 D$ 0F
 D$ 0F0
 D$ 0F0
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0F
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[ToolBarTextTable:
 B$ 'TBSTYLE_BUTTON' EOS
 B$ 'TBSTYLE_SEP' EOS
 B$ 'TBSTYLE_CHECK' EOS
 B$ 'TBSTYLE_GROUP' EOS
 B$ 'TBSTYLE_CHECKGROUP' EOS
 B$ 'TBSTYLE_DROPDOWN' EOS
 B$ 'TBSTYLE_AUTOSIZE' EOS
 B$ 'TBSTYLE_NOPREFIX' EOS
 B$ 'BTNS_SHOWTEXT' EOS
 B$ 'BTNS_WHOLEDROPDOWN' EOS
 B$ 'TBSTYLE_TOOLTIPS' EOS
 B$ 'TBSTYLE_WRAPABLE' EOS
 B$ 'TBSTYLE_ALTDRAG' EOS
 B$ 'TBSTYLE_FLAT' EOS
 B$ 'TBSTYLE_LIST' EOS
 B$ 'TBSTYLE_CUSTOMERASE' EOS
 B$ 'TBSTYLE_REGISTERDROP' EOS
 B$ 'TBSTYLE_TRANSPARENT' EOS
 B$ 'TBSTYLE_EX_DRAWDDARROWS' EOS
 B$ 'TBSTYLE_EX_MIXEDBUTTONS' EOS
 B$ 'TBSTYLE_EX_HIDECLIPPEDBUTTONS' EOS
 B$ 'TBSTYLE_EX_DOUBLEBUFFER' EOS
 B$ 'CCS_TOP' EOS
 B$ 'CCS_NOMOVEY' EOS
 B$ 'CCS_BOTTOM' EOS
 B$ 'CCS_NORESIZE' EOS
 B$ 'CCS_NOPARENTALIGN' EOS
 B$ 'CCS_ADJUSTABLE' EOS
 B$ 'CCS_NODIVIDER' EOS
 B$ 'CCS_VERT' EOS
 B$ 'CCS_LEFT' EOS
 B$ 'CCS_NOMOVEX' EOS
 B$ 'CCS_RIGHT' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 'WS_GROUP' EOS
 B$ 'WS_DISABLED' EOS
 B$ 'WS_CHILD' EOS
 B$ 'WS_VISIBLE' EOS
 B$ 'WS_BORDER' EOS
 B$ 'WS_CLIPSIBLINGS' EOS
 B$ 0]

[ToolBarBitTable:
 D$ &TBSTYLE_BUTTON
 D$ &TBSTYLE_SEP
 D$ &TBSTYLE_CHECK
 D$ &TBSTYLE_GROUP
 D$ &TBSTYLE_CHECKGROUP
 D$ &TBSTYLE_DROPDOWN
 D$ &TBSTYLE_AUTOSIZE
 D$ &TBSTYLE_NOPREFIX
 D$ &BTNS_SHOWTEXT
 D$ &BTNS_WHOLEDROPDOWN
 D$ &TBSTYLE_TOOLTIPS
 D$ &TBSTYLE_WRAPABLE
 D$ &TBSTYLE_ALTDRAG
 D$ &TBSTYLE_FLAT
 D$ &TBSTYLE_LIST
 D$ &TBSTYLE_CUSTOMERASE
 D$ &TBSTYLE_REGISTERDROP
 D$ &TBSTYLE_TRANSPARENT
 D$ &TBSTYLE_EX_DRAWDDARROWS
 D$ &TBSTYLE_EX_MIXEDBUTTONS
 D$ &TBSTYLE_EX_HIDECLIPPEDBUTTONS
 D$ &TBSTYLE_EX_DOUBLEBUFFER
 D$ &CCS_TOP
 D$ &CCS_NOMOVEY
 D$ &CCS_BOTTOM
 D$ &CCS_NORESIZE
 D$ &CCS_NOPARENTALIGN
 D$ &CCS_ADJUSTABLE
 D$ &CCS_NODIVIDER
 D$ &CCS_VERT
 D$ &CCS_LEFT
 D$ &CCS_NOMOVEX
 D$ &CCS_RIGHT
 D$ &WS_TABSTOP
 D$ &WS_GROUP
 D$ &WS_DISABLED
 D$ &WS_CHILD
 D$ &WS_VISIBLE
 D$ &WS_BORDER
 D$ &WS_CLIPSIBLINGS]

[ToolBarExcludeBitTable:
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0FFFF
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[ToolBarMustHaveBitTable:
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ &TBSTYLE_LIST+&TBSTYLE_EX_MIXEDBUTTONS
 D$ 0
 D$ 0
 D$ 0
 D$ &CCS_ADJUSTABLE
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]


[TBSTYLE_BUTTONhelp: B$ "TBSTYLE_BUTTON:

Default ToolBar Style. Initialize the Control as a Button." EOS]

[CCS_TOPhelp: B$ "CCS_TOP:

Common Controls style:

Inverts the Horizontal appearance of the control." EOS]

[TBSTYLE_CHECKhelp: B$ "TBSTYLE_CHECK:

Allows using a CheckBox on the ToolBar." EOS]
;;
CCS_BOTTOMhelp: B$ "CCS_BOTTOM:
 
Common Controls style:

Inverts the vertical appearance of the control." EOS
;;
[TBSTYLE_GROUPhelp: B$ "TBSTYLE_GROUP:

Uses the ToolBar as Group." EOS]

[TBSTYLE_CHECKGROUPhelp: B$ "TBSTYLE_CHECKGROUP:

Uses the ToolBar as a CheckBox Group." EOS]

[TBSTYLE_DROPDOWNhelp: B$ "TBSTYLE_DROPDOWN:

 Enables the dropdown mode on the ToolBar." EOS]

[TBSTYLE_AUTOSIZEhelp: B$ "TBSTYLE_AUTOSIZE:

AutoSize the ToolBar to fit the window width." EOS]

[CCS_ADJUSTABLEhelp: B$ "CCS_ADJUSTABLE:
 
Common Controls style:

Enables the customization mode of the control." EOS]

[CCS_LEFThelp: B$ "CCS_LEFT:
 
Common Controls style:

Place the Control at the Left Corner of the window." EOS]

[CCS_RIGHThelp: B$ "CCS_RIGHT:
 
Common Controls style:

Place the Control at the Right Corner of the window." EOS]

[TBSTYLE_TOOLTIPShelp: B$ "TBSTYLE_TOOLTIPS:
 
Enables showing tooltips on the ToolBar." EOS]

[TBSTYLE_WRAPABLEhelp: B$ "TBSTYLE_WRAPABLE:
 
Allows warp mode on the ToolBar." EOS]

[TBSTYLE_ALTDRAGhelp: B$ "TBSTYLE_ALTDRAG:
 
Allows dragging and drop the ToolBar.

To do this, press the key Alt and the left mouse button and drag a certain Button in the ToolBar." EOS]

[TBSTYLE_FLAThelp: B$ "TBSTYLE_FLAT:

Shows the ToolBar as Flat." EOS]

[TBSTYLE_LISThelp: B$ "TBSTYLE_LIST:
 
Enables using a List Control on the ToolBar." EOS]

[TBSTYLE_CUSTOMERASEhelp: B$ "TBSTYLE_CUSTOMERASE:
 
Allows customizatino of the ToolBar." EOS]

[TBSTYLE_REGISTERDROPhelp: B$ "TBSTYLE_REGISTERDROP:

Allows registering the drag and drop mode." EOS]

[TBSTYLE_TRANSPARENThelp: B$ "TBSTYLE_TRANSPARENT:
 
Shows the toolbar button as transparent to insert masked images." EOS]

[TBSTYLE_SEPhelp: B$ "TBSTYLE_SEP:

version 4.72 and earlier. This is equivalent to BTNS_SEP (for version 5.80 and later).

Creates a separator, providing a small gap between button groups.

A button that has this style does not receive user input." EOS]

[TBSTYLE_NOPREFIXhelp: B$ "TBSTYLE_NOPREFIX:

version 4.72 and earlier. This is equivalent to BTNS_NOPREFIX  (for version 5.80 and later).

Specifies that the button text will not have an accelerator prefix associated with it." EOS]

[BTNS_SHOWTEXThelp: B$ "BTNS_SHOWTEXT:

Version 5.81. Specifies that button text should be displayed.

All buttons can have text, but only those buttons with the BTNS_SHOWTEXT button style will display it.

This button style must be used with the TBSTYLE_LIST style and the TBSTYLE_EX_MIXEDBUTTONS extended style.

If you set text for buttons that do not have the BTNS_SHOWTEXT style, the toolbar control will automatically display it as a ToolTip when the cursor hovers over the button.

This feature allows your application to avoid handling the TBN_GETINFOTIP notification for the toolbar." EOS]

[BTNS_WHOLEDROPDOWNhelp: B$ "BTNS_WHOLEDROPDOWN:

Version 5.80. Specifies that the button will have a drop-down arrow, but not as a separate section.

Buttons with this style behave the same, regardless of whether the TBSTYLE_EX_DRAWDDARROWS extended style is set." EOS]

[TBSTYLE_EX_DRAWDDARROWShelp: B$ "TBSTYLE_EX_DRAWDDARROWS:

Version 4.71. This style allows buttons to have a separate dropdown arrow.

Buttons that have the BTNS_DROPDOWN style will be drawn with a drop-down arrow in a separate section, to the right of the button.

If the arrow is clicked, only the arrow portion of the button will depress, and the toolbar control will send a TBN_DROPDOWN notification to prompt the application to display the dropdown menu.

If the main part of the button is clicked, the toolbar control sends a WM_COMMAND message with the button's ID. The application normally responds by launching the first command on the menu.

There are many situations where you may want to have only some of the dropdown buttons on a toolbar with separated arrows. To do so, set the TBSTYLE_EX_DRAWDDARROWS extended style. Give those buttons that will not have separated arrows the BTNS_WHOLEDROPDOWN style. Buttons with this style will have an arrow displayed next to the image.

However, the arrow will not be separate and when any part of the button is clicked, the toolbar control will send a TBN_DROPDOWN notification.

To prevent repainting problems, this style should be set before the toolbar control becomes visible.

Note :

    To set an extended style, send the toolbar control a TB_SETEXTENDEDSTYLE message. To determine what extended styles are currently set, send a TB_GETEXTENDEDSTYLE message." EOS]

[TBSTYLE_EX_HIDECLIPPEDBUTTONShelp: B$ "TBSTYLE_EX_HIDECLIPPEDBUTTONS:

Version 5.81. This style hides partially clipped buttons.

The most common use of this style is for toolbars that are part of a rebar control. If an adjacent band covers part of a button, the button will not be displayed.
However, if the rebar band has the RBBS_USECHEVRON style, the button will be displayed on the chevron's dropdown menu.

Note :

    To set an extended style, send the toolbar control a TB_SETEXTENDEDSTYLE message. To determine what extended styles are currently set, send a TB_GETEXTENDEDSTYLE message." EOS]

[TBSTYLE_EX_DOUBLEBUFFERhelp: B$ "TBSTYLE_EX_DOUBLEBUFFER:

Version 6. This style requires the toolbar to be double buffered. Double buffering is a mechanism that detects when the toolbar has changed.
Comctl32.dll version 6 is not redistributable but it is included in Microsoft Windows XP or later. To use Comctl32.dll version 6, specify it in a manifest.

Note :

    To set an extended style, send the toolbar control a TB_SETEXTENDEDSTYLE message. To determine what extended styles are currently set, send a TB_GETEXTENDEDSTYLE message." EOS]

[TBSTYLE_EX_MIXEDBUTTONShelp: B$ "TBSTYLE_EX_MIXEDBUTTONS:

Version 5.81. This style allows you to set text for all buttons, but only display it for those buttons with the BTNS_SHOWTEXT button style.

The TBSTYLE_LIST style must also be set. Normally, when a button does not display text, your application must handle TBN_GETINFOTIP to display a ToolTip.

With the TBSTYLE_EX_MIXEDBUTTONS extended style, text that is set but not displayed on a button will automatically be used as the button's ToolTip text.

Your application only needs to handle TBN_GETINFOTIP if it needs more flexibility in specifying the ToolTip text.

Note :

    To set an extended style, send the toolbar control a TB_SETEXTENDEDSTYLE message. To determine what extended styles are currently set, send a TB_GETEXTENDEDSTYLE message." EOS]

[CCS_NOMOVEYhelp: B$ "CCS_NOMOVEY:

Causes the control to resize and Move itself horizontally, but not vertically, in response to a WM_SIZE message.

Header windows have this style by default. This style does not apply if your control has the CCS_NORESIZE style." EOS]

[CCS_NORESIZEhelp: B$ "CCS_NORESIZE:
 
Prevents the control from using the default width and height when setting its initial size or a new size.

Instead, the control uses the width and height that is specified in the request for creation or sizing." EOS]

[CCS_NOPARENTALIGNhelp: B$ "CCS_NOPARENTALIGN:
 
Prevents the control from automatically moving to the top or bottom of the parent window.

Instead, the control keeps its position within the parent window despite changes to the size of the parent.
If the application also uses the CCS_TOP or CCS_BOTTOM styles, it adjusts the height to the default, but does not change the position and width of the control." EOS]

[CCS_NODIVIDERhelp: B$ "CCS_NODIVIDER:

Prevents a 2-pixel highlight from being drawn at the top of the control." EOS]

[CCS_VERThelp: B$ "CCS_VERT:

Causes the control to display vertically." EOS]

[CCS_NOMOVEXhelp: B$ "CCS_NOMOVEX:

Version 4.70. Causes the control to resize and Move itself vertically, but not horizontally, in response to a WM_SIZE message.

If CCS_NORESIZE is used, this style does not apply." EOS]

[WS_CLIPSIBLINGShelp: B$ "WS_CLIPSIBLINGS:

Clips child windows relative to each other; that is, when a particular child window receives a paint message, the WS_CLIPSIBLINGS style clips all other overlapped child windows out of the region of the child window to be updated.
(If WS_CLIPSIBLINGS is not given and child windows overlap, when you draw within the client area of a child window, it is possible to draw within the client area of a neighboring child window.) For use with the WS_CHILD style only." EOS]

[ToolBarStylesHelp:
 D$ TBSTYLE_BUTTONhelp
 D$ TBSTYLE_SEPhelp
 D$ TBSTYLE_CHECKhelp
 D$ TBSTYLE_GROUPhelp
 D$ TBSTYLE_CHECKGROUPhelp
 D$ TBSTYLE_DROPDOWNhelp
 D$ TBSTYLE_AUTOSIZEhelp
 D$ TBSTYLE_NOPREFIXhelp
 D$ BTNS_SHOWTEXThelp
 D$ BTNS_WHOLEDROPDOWNhelp
 D$ TBSTYLE_TOOLTIPShelp
 D$ TBSTYLE_WRAPABLEhelp
 D$ TBSTYLE_ALTDRAGhelp
 D$ TBSTYLE_FLAThelp
 D$ TBSTYLE_LISThelp
 D$ TBSTYLE_CUSTOMERASEhelp
 D$ TBSTYLE_REGISTERDROPhelp
 D$ TBSTYLE_TRANSPARENThelp
 D$ TBSTYLE_EX_DRAWDDARROWShelp
 D$ TBSTYLE_EX_MIXEDBUTTONShelp
 D$ TBSTYLE_EX_HIDECLIPPEDBUTTONShelp
 D$ TBSTYLE_EX_DOUBLEBUFFERhelp
 D$ CCS_TOPhelp
 D$ CCS_NOMOVEYhelp
 D$ CCS_BOTTOMhelp
 D$ CCS_NORESIZEhelp
 D$ CCS_NOPARENTALIGNhelp
 D$ CCS_ADJUSTABLEhelp
 D$ CCS_NODIVIDERhelp
 D$ CCS_VERThelp
 D$ CCS_LEFThelp
 D$ CCS_NOMOVEXhelp
 D$ CCS_RIGHThelp
 D$ WS_TABSTOPhelp
 D$ WS_GROUPhelp
 D$ WS_DISABLEDhelp
 D$ WS_CHILDhelp
 D$ WS_VISIBLEhelp
 D$ WS_BORDERhelp
 D$ WS_CLIPSIBLINGShelp]

; &CCS_VERT We don't need this because when it is set to Left or Right, it already uses the CCS_VERT
; &TBSTYLE_SEP The same as TBSTYLE_SEP
; &TBSTYLE_NOPREFIX iS THE SAME AS &CCS_ADJUSTABLE
____________________________________

; RichEdit20a control tables:


[RichEdit20aCheckingMask:
 D$ 03
 D$ 03
 D$ 03
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[RichEdit20aTextTable:
 B$ 'ES_LEFT' EOS
 B$ 'ES_CENTER' EOS
 B$ 'ES_RIGHT' EOS
 B$ 'ES_MULTILINE' EOS
 B$ 'ES_AUTOVSCROLL' EOS
 B$ 'ES_AUTOHSCROLL' EOS
 B$ 'ES_LOWERCASE' EOS
 B$ 'ES_UPPERCASE' EOS
 B$ 'ES_PASSWORD' EOS
 B$ 'ES_OEMCONVERT' EOS
 B$ 'ES_NOHIDESEL' EOS
 B$ 'ES_READONLY' EOS
 B$ 'ES_NUMBER' EOS
 B$ 'ES_WANTRETURN' EOS
 B$ 'WS_VSCROLL' EOS
 B$ 'WS_HSCROLL' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 'WS_BORDER' EOS
 B$ 'WS_VISIBLE' EOS
 B$ 'WS_CHILD' EOS
 B$ 0]

[RichEdit20aBitTable:
 D$ &ES_LEFT
 D$ &ES_CENTER
 D$ &ES_RIGHT
 D$ &ES_MULTILINE
 D$ &ES_AUTOVSCROLL
 D$ &ES_AUTOHSCROLL
 D$ &ES_LOWERCASE
 D$ &ES_UPPERCASE
 D$ &ES_PASSWORD
 D$ &ES_OEMCONVERT
 D$ &ES_NOHIDESEL
 D$ &ES_READONLY
 D$ &ES_NUMBER
 D$ &ES_WANTRETURN
 D$ &WS_VSCROLL
 D$ &WS_HSCROLL
 D$ &WS_TABSTOP
 D$ &WS_BORDER
 D$ &WS_VISIBLE
 D$ &WS_CHILD]

[RichEdit20aExcludeBitTable:
 D$ 03
 D$ 02
 D$ 01
 D$ 0
 D$ 0
 D$ 0
 D$ 08
 D$ 010
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[RichEdit20aMustHaveBitTable:
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ &WS_VSCROLL
 D$ &WS_HSCROLL
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[RichEdit20aStylesHelp:
 D$ ES_LEFThelp
 D$ ES_CENTERhelp
 D$ ES_RIGHThelp
 D$ ES_MULTILINEhelp
 D$ ES_AUTOVSCROLLhelp
 D$ ES_AUTOHSCROLLhelp
 D$ ES_LOWERCASEhelp
 D$ ES_UPPERCASEhelp
 D$ ES_PASSWORDhelp
 D$ ES_OEMCONVERThelp
 D$ ES_NOHIDESELhelp
 D$ ES_READONLYhelp
 D$ ES_NUMBERhelp
 D$ ES_WANTRETURNhelp
 D$ WS_VSCROLLhelp
 D$ WS_HSCROLLhelp
 D$ WS_TABSTOPhelp
 D$ WS_BORDERhelp
 D$ WS_VISIBLEhelp
 D$ WS_CHILDhelp]

____________________________________

; SysHeader32 control tables:

; use this on: ShowControlStyles ,  ShowControlStyleControl , ControlClassByNames , SearchWhatControlClass , WriteStyle,
; ShowStyleInfo
  ;&WS_GROUP &WS_DISABLED
  ; &BS_RIGHTBUTTON &BS_TEXT

[SysHeader32CheckingMask: D$ ? # 19]


[SysHeader32TextTable:
 B$ 'HDS_BUTTONS' EOS
 B$ 'HDS_DRAGDROP' EOS
 B$ 'HDS_FILTERBAR' EOS
 B$ 'HDS_FLAT' EOS
 B$ 'HDS_FULLDRAG' EOS
 B$ 'HDS_HIDDEN' EOS
 B$ 'HDS_HORZ' EOS
 B$ 'HDS_HOTTRACK' EOS
 B$ 'HDS_CHECKBOXES' EOS
 B$ 'HDS_NOSIZING' EOS
 B$ 'HDS_OVERFLOW' EOS
 B$ 'WS_VSCROLL' EOS
 B$ 'WS_HSCROLL' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 'WS_BORDER' EOS
 B$ 'WS_VISIBLE' EOS
 B$ 'WS_CHILD' EOS
 B$ 'WS_GROUP' EOS
 B$ 'WS_DISABLED' EOS
 B$ 0]

[SysHeader32BitTable:
 D$ &HDS_BUTTONS
 D$ &HDS_DRAGDROP
 D$ &HDS_FILTERBAR
 D$ &HDS_FLAT
 D$ &HDS_FULLDRAG
 D$ &HDS_HIDDEN
 D$ &HDS_HORZ
 D$ &HDS_HOTTRACK
 D$ &HDS_CHECKBOXES
 D$ &HDS_NOSIZING
 D$ &HDS_OVERFLOW
 D$ &WS_VSCROLL
 D$ &WS_HSCROLL
 D$ &WS_TABSTOP
 D$ &WS_BORDER
 D$ &WS_VISIBLE
 D$ &WS_CHILD
 D$ &WS_GROUP
 D$ &WS_DISABLED]

[SysHeader32ExcludeBitTable:
 D$ &HDS_CHECKBOXES
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ &HDS_BUTTONS
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[SysHeader32MustHaveBitTable: D$ ? # 19]

[SysHeader32StylesHelp:
 D$ HDS_BUTTONShelp
 D$ HDS_DRAGDROPhelp
 D$ HDS_FILTERBARhelp
 D$ HDS_FLAThelp
 D$ HDS_FULLDRAGhelp
 D$ HDS_HIDDENhelp
 D$ HDS_HORZhelp
 D$ HDS_HOTTRACKhelp
 D$ HDS_CHECKBOXEShelp
 D$ HDS_NOSIZINGhelp
 D$ HDS_OVERFLOWhelp
 D$ WS_VSCROLLhelp
 D$ WS_HSCROLLhelp
 D$ WS_TABSTOPhelp
 D$ WS_BORDERhelp
 D$ WS_VISIBLEhelp
 D$ WS_CHILDhelp
 D$ WS_GROUPhelp
 D$ WS_DISABLEDhelp]

[HDS_BUTTONShelp: B$ "HDS_BUTTONS:

Each item in the control looks and behaves like a Push button.
This style is useful if an application carries out a task when the user clicks an item in the header control.
For example, an application could sort information in the columns differently depending on which item the user clicks." EOS]

[HDS_DRAGDROPhelp: B$ "HDS_DRAGDROP:

Version 4.70. Allows drag-and-drop reordering of header items." EOS]

[HDS_FILTERBARhelp: B$ "HDS_FILTERBAR:

Version 5.80. Include a filter bar as part of the standard header control.
This bar allows users to conveniently apply a filter to the display.
Calls to HDM_LAYOUT will yield a new size for the control and cause the list view to update." EOS]

[HDS_FLAThelp: B$ "HDS_FLAT:

Version 6.0. Causes the header control to be drawn flat when Microsoft Windows XP is running in classic mode.

Note:  Comctl32.dll version 6 is not redistributable but it is included in Windows XP or later.
To use Comctl32.dll version 6, specify it in a manifest windows style" EOS]

[HDS_FULLDRAGhelp: B$ "HDS_FULLDRAG:

Version 4.70. Causes the header control to display column contents even while the user resizes a column." EOS]

[HDS_HIDDENhelp: B$ "HDS_HIDDEN:

Indicates a header control that is intended to be hidden.
This style does not hide the control.
Instead, when you send the HDM_LAYOUT message to a header control with the HDS_HIDDEN style, the control returns zero in the cy member of the WINDOWPOS structure.
You would then hide the control by setting its height to zero.
This can be useful when you want to use the control as an information container instead of a visual control." EOS]

[HDS_HORZhelp: B$ "HDS_HORZ:

Creates a header control with a horizontal orientation." EOS]

[HDS_HOTTRACKhelp: B$ "HDS_HOTTRACK:

Version 4.70. Enables hot tracking." EOS]

[HDS_CHECKBOXEShelp: B$ "HDS_CHECKBOXES:

(0x0400)" EOS]

[HDS_NOSIZINGhelp: B$ "HDS_NOSIZING:

(0x0800)" EOS]

[HDS_OVERFLOWhelp: B$ "HDS_OVERFLOW:

(0x1000)" EOS]

____________________________________

; ReBarWindow32 controls

[ReBarWindow32CheckingMask:
 D$ &CCS_BOTTOM
 D$ &CCS_VERT+&CCS_BOTTOM
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ &CCS_VERT
 D$ &CCS_RIGHT
 D$ &CCS_LEFT
 D$ 0
 D$ 0
 D$ 0]


[ReBarWindow32TextTable:
 B$ 'CCS_TOP' EOS
 B$ 'CCS_BOTTOM' EOS
 B$ 'RBS_AUTOSIZE' EOS
 B$ 'CCS_ADJUSTABLE' EOS
 B$ 'RBS_BANDBORDERS' EOS
 B$ 'RBS_DBLCLKTOGGLE' EOS
 B$ 'RBS_FIXEDORDER' EOS
 B$ 'RBS_REGISTERDROP' EOS
 B$ 'RBS_TOOLTIPS' EOS
 B$ 'RBS_VARHEIGHT' EOS
 B$ 'RBS_VERTICALGRIPPER' EOS
 B$ 'CCS_LEFT' EOS
 B$ 'CCS_RIGHT' EOS
 B$ 'WS_BORDER' EOS
 B$ 'WS_VISIBLE' EOS
 B$ 'WS_CHILD' EOS
 B$ 0]

[ReBarWindow32BitTable:
 D$ &CCS_TOP
 D$ &CCS_BOTTOM
 D$ &RBS_AUTOSIZE
 D$ &CCS_ADJUSTABLE
 D$ &RBS_BANDBORDERS
 D$ &RBS_DBLCLKTOGGLE
 D$ &RBS_FIXEDORDER
 D$ &RBS_REGISTERDROP
 D$ &RBS_TOOLTIPS
 D$ &RBS_VARHEIGHT
 D$ &RBS_VERTICALGRIPPER
 D$ &CCS_LEFT
 D$ &CCS_RIGHT
 D$ &WS_BORDER
 D$ &WS_VISIBLE &WS_CHILD]

[ReBarWindow32ExcludeBitTable:
 D$ &CCS_VERT+&CCS_BOTTOM
 D$ &CCS_VERT+&CCS_TOP
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ &CCS_RIGHT+&CCS_BOTTOM+&CCS_TOP
 D$ &CCS_LEFT+&CCS_TOP+&CCS_BOTTOM
 D$ 0
 D$ 0
 D$ 0]

[ReBarWindow32MustHaveBitTable: D$ ? # 16]

[ReBarWindow32StylesHelp:
 D$ CCS_TOPhelp
 D$ CCS_BOTTOMhelp
 D$ RBS_AUTOSIZEhelp
 D$ CCS_ADJUSTABLEhelp
 D$ RBS_BANDBORDERShelp
 D$ RBS_DBLCLKTOGGLEhelp
 D$ RBS_FIXEDORDERhelp
 D$ RBS_REGISTERDROPhelp
 D$ RBS_TOOLTIPShelp
 D$ RBS_VARHEIGHThelp
 D$ RBS_VERTICALGRIPPERhelp
 D$ CCS_LEFThelp
 D$ CCS_RIGHThelp
 D$ WS_BORDERhelp
 D$ WS_VISIBLEhelp
 D$ WS_CHILDhelp]


[RBS_AUTOSIZEhelp: B$ "RBS_AUTOSIZE:

Version 4.71. The rebar control will automatically change the layout of the bands when the size or position of the control changes. An RBN_AUTOSIZE notification will be sent when this occurs." EOS]

[RBS_BANDBORDERShelp: B$ "RBS_BANDBORDERS:

Version 4.71. The rebar control displays narrow lines to separate adjacent bands." EOS]

[RBS_DBLCLKTOGGLEhelp: B$ "RBS_DBLCLKTOGGLE:

Version 4.71. The rebar band will toggle its maximized or minimized state when the user double-clicks the band. Without this style, the maximized or minimized state is toggled when the user single-clicks on the band." EOS]

[RBS_FIXEDORDERhelp: B$ "RBS_FIXEDORDER:

Version 4.70. The rebar control always displays bands in the same order. You can Move bands to different rows, but the band order is static." EOS]

[RBS_REGISTERDROPhelp: B$ "RBS_REGISTERDROP:

Version 4.71. The rebar control generates RBN_GETOBJECT notification messages when an object is dragged over a band in the control. To receive the RBN_GETOBJECT notifications, initialize OLE with a Call to OleInitialize or CoInitialize." EOS]

[RBS_TOOLTIPShelp: B$ "RBS_TOOLTIPS:

Version 4.71. Not yet supported." EOS]

[RBS_VARHEIGHThelp: B$ "RBS_VARHEIGHT:

Version 4.71. The rebar control displays bands at the minimum required height, when possible. Without this style, the rebar control displays all bands at the same height, using the height of the tallest visible band to determine the height of other bands." EOS]

[RBS_VERTICALGRIPPERhelp: B$ "RBS_VERTICALGRIPPER:

Version 4.71. The size grip will be displayed vertically instead of horizontally in a vertical rebar control. This style is ignored for rebar controls that do not have the CCS_VERT style." EOS]

____________________________________

; tooltips_class32
;note: A ToolTip control always has the WS_POPUP and WS_EX_TOOLWINDOW window styles,
; regardless of whether you specify them when creating the control.

[Tooltips_class32CheckingMask: D$ ? # 12]
 ;&WS_POPUP  &WS_EX_TOOLWINDOW]

[Tooltips_class32TextTable:
 B$ 'TTS_ALWAYSTIP' EOS
 B$ 'TTS_BALLOON' EOS
 B$ 'TTS_NOANIMATE' EOS
 B$ 'TTS_NOFADE' EOS
 B$ 'TTS_NOPREFIX' EOS
 B$ 'TTS_USEVISUALSTYLE' EOS
 B$ 'TTS_CLOSE' EOS
 B$ 'WS_BORDER' EOS
 B$ '&WS_VISIBLE' EOS
 B$ 'WS_CHILD' EOS
 B$ 'WS_POPUP' EOS
 B$ 'WS_EX_TOOLWINDOW' EOS
 B$ 0]

[Tooltips_class32BitTable:
 D$ &TTS_ALWAYSTIP
 D$ &TTS_BALLOON
 D$ &TTS_NOANIMATE
 D$ &TTS_NOFADE
 D$ &TTS_NOPREFIX
 D$ &TTS_USEVISUALSTYLE
 D$ &TTS_CLOSE
 D$ &WS_BORDER
 D$ &WS_VISIBLE
 D$ &WS_CHILD
 D$ &WS_POPUP
 D$ &WS_EX_TOOLWINDOW]

[Tooltips_class32ExcludeBitTable: D$ ? # 12]


[Tooltips_class32MustHaveBitTable:
 D$ &WS_POPUP+&WS_EX_TOOLWINDOW
 D$ &WS_POPUP+&WS_EX_TOOLWINDOW
 D$ &WS_POPUP+&WS_EX_TOOLWINDOW
 D$ &WS_POPUP+&WS_EX_TOOLWINDOW
 D$ &WS_POPUP+&WS_EX_TOOLWINDOW
 D$ &WS_POPUP+&WS_EX_TOOLWINDOW
 D$ &WS_POPUP+&WS_EX_TOOLWINDOW
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0];&WS_POPUP  &WS_EX_TOOLWINDOW];  0]

[Tooltips_class32StylesHelp:
 D$ TTS_ALWAYSTIPHelp
 D$ TTS_BALLOONHelp
 D$ TTS_NOANIMATEHelp
 D$ TTS_NOFADEHelp
 D$ TTS_NOPREFIXHelp
 D$ TTS_USEVISUALSTYLEHelp
 D$ TTS_CLOSEHelp
 D$ WS_BORDERhelp
 D$ WS_VISIBLEhelp
 D$ WS_CHILDhelp
 D$ WS_POPUPhelp
 D$ WS_EX_TOOLWINDOWhelp]

[TTS_ALWAYSTIPHelp: B$ "TTS_ALWAYSTIP:

Indicates that the ToolTip control appears when the cursor is on a tool, even if the ToolTip control's owner window is inactive.
Without this style, the ToolTip appears only when the tool's owner window is active." EOS]

[TTS_BALLOONHelp: B$ "TTS_BALLOON:

Version 5.80. Indicates that the ToolTip control has the appearance of a cartoon 'balloon,' with rounded corners and a stem pointing to the item." EOS]

[TTS_NOANIMATEHelp: B$ "TTS_NOANIMATE:

Version 5.80. Disables sliding ToolTip animation on Microsoft Windows 98 and Windows 2000 systems.
This style is ignored on earlier systems." EOS]

[TTS_NOFADEHelp: B$ "TTS_NOFADE:

Version 5.80. Disables fading ToolTip animation on Windows 2000 systems.
This style is ignored on earlier Microsoft Windows NT systems, and on Windows 95 and Windows 98." EOS]

[TTS_NOPREFIXHelp: B$ "TTS_NOPREFIX:

Prevents the system from stripping the ampersand character from a string.
Without this style, the system automatically strips ampersand characters.
This allows an application to use the same string as both a menu item and as text in a ToolTip control." EOS]

[TTS_USEVISUALSTYLEHelp: B$ "TTS_USEVISUALSTYLE:

Uses themed hyperlinks. The theme will define the styles for any links in the tooltip.
This style always requires TTF_PARSELINKS to be set." EOS]

[TTS_CLOSEHelp: B$ "TTS_CLOSE:

Displays a Close button on the tooltip." EOS]

[WS_EX_TOOLWINDOWhelp: B$ "WS_EX_TOOLWINDOW:

Creates a tool window; that is, a window intended to be used as a floating toolbar.
A tool window has a title bar that is shorter than a normal title bar, and the window title is drawn using a smaller font.
A tool window does not appear in the taskbar or in the dialog box that appears when the user presses ALT+TAB.
If a tool window has a system menu, its icon is not displayed on the title bar.
However, you can display the system menu by typing ALT+SPACE." EOS]
____________________________________

; msctls_statusbar32

[msctls_statusbar32CheckingMask: D$ ? # 6]

[msctls_statusbar32TextTable:
 B$ 'SBARS_SIZEGRIP' EOS
 B$ 'SBT_TOOLTIPS' EOS
 B$ 'WS_BORDER' EOS
 B$ '&WS_VISIBLE' EOS
 B$ 'WS_CHILD' EOS
 B$ 'WS_POPUP' EOS
 B$ 0]



[msctls_statusbar32BitTable:
 D$ &SBARS_SIZEGRIP
 D$ &SBT_TOOLTIPS
 D$ &WS_BORDER
 D$ &WS_VISIBLE
 D$ &WS_CHILD
 D$ &WS_POPUP]


[msctls_statusbar32ExcludeBitTable: D$ ? # 6]

[msctls_statusbar32MustHaveBitTable: D$ ? # 6]

[msctls_statusbar32StylesHelp:
 D$ SBARS_SIZEGRIPHelp
 D$ SBT_TOOLTIPSHelp
 D$ WS_BORDERhelp
 D$ WS_VISIBLEhelp
 D$ WS_CHILDhelp
 D$ WS_POPUPhelp]

[SBARS_SIZEGRIPHelp: B$ "SBARS_SIZEGRIP:

The status bar control will include a sizing grip at the right end of the status bar.
A sizing grip is similar to a sizing border; it is a rectangular area that the user can click and drag to resize the parent window." EOS]

[SBT_TOOLTIPSHelp: B$ "SBT_TOOLTIPS:

Version 4.71.Use this style to enable ToolTips.
This is exactly the same as SBARS_TOOLTIPS" EOS]
____________________________________

; msctls_hotkey32

[msctls_hotkey32CheckingMask: D$ ? # 2]

[msctls_hotkey32TextTable:
 B$ 'WS_BORDER' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 0]

[msctls_hotkey32BitTable:
 D$ &WS_BORDER
 D$ &WS_TABSTOP]


[msctls_hotkey32ExcludeBitTable: D$ ? # 2]

[msctls_hotkey32MustHaveBitTable: D$ ? # 2]

[msctls_hotkey32StylesHelp:
 D$ WS_BORDERhelp
 D$ WS_TABSTOPhelp]
____________________________________

; ComboBoxEx32

[ComboBoxEx32CheckingMask: D$ ? # 9]

[ComboBoxEx32TextTable:
 B$ 'CBS_OWNERDRAWFIXED' EOS
 B$ 'CBES_EX_CASESENSITIVE' EOS
 B$ 'CBES_EX_NOEDITIMAGE' EOS
 B$ 'CBES_EX_NOEDITIMAGEINDENT' EOS
 B$ 'CBES_EX_NOSIZELIMIT' EOS
 B$ 'CBES_EX_PATHWORDBREAKPROC' EOS         ;'CBES_EX_TEXTENDELLIPSIS' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 'WS_VSCROLL' EOS
 B$ 'WS_HSCROLL' EOS
 B$ 0]


[ComboBoxEx32BitTable:
 D$ &CBS_OWNERDRAWFIXED
 D$ &CBES_EX_CASESENSITIVE
 D$ &CBES_EX_NOEDITIMAGE
 D$ &CBES_EX_NOEDITIMAGEINDENT
 D$ &CBES_EX_NOSIZELIMIT
 D$ &CBES_EX_PATHWORDBREAKPROC  ;  &CBES_EX_TEXTENDELLIPSIS (For Windows Vista. we need this equate later :) )
 D$ &WS_TABSTOP
 D$ &WS_VSCROLL
 D$ &WS_HSCROLL]

[ComboBoxEx32ExcludeBitTable: D$ ? # 9]

[ComboBoxEx32MustHaveBitTable: D$ ? # 9]

[ComboBoxEx32StylesHelp:
 D$ CBS_OWNERDRAWFIXEDhelp
 D$ CBES_EX_CASESENSITIVEhelp
 D$ CBES_EX_NOEDITIMAGEhelp
 D$ CBES_EX_NOEDITIMAGEINDENThelp
 D$ CBES_EX_NOSIZELIMIThelp
 D$ CBES_EX_PATHWORDBREAKPROChelp ; CBES_EX_TEXTENDELLIPSIShelp
 D$ WS_TABSTOPhelp
 D$ WS_VSCROLLhelp
 D$ WS_HSCROLLhelp]

[CBES_EX_CASESENSITIVEhelp: B$ "CBES_EX_CASESENSITIVE:

BSTR searches in the list will be case sensitive.
This includes searches as a result of text being typed in the edit box and the CB_FINDSTRINGEXACT message." EOS]

[CBES_EX_NOEDITIMAGEhelp: B$ "CBES_EX_NOEDITIMAGE:

The edit box and the dropdown list will not display item images." EOS]

[CBES_EX_NOEDITIMAGEINDENThelp: B$ "CBES_EX_NOEDITIMAGEINDENT:

The edit box and the dropdown list will not display item images." EOS]

[CBES_EX_NOSIZELIMIThelp: B$ "CBES_EX_NOSIZELIMIT:

Allows the ComboBoxEx control to be vertically sized smaller than its contained combo box control.
If the ComboBoxEx is sized smaller than the combo box, the combo box will be clipped." EOS]

[CBES_EX_PATHWORDBREAKPROChelp: B$ "CBES_EX_PATHWORDBREAKPRO:

Microsoft Windows NT only.
The edit box will use the slash (/), backslash (\), and period (.) characters as word delimiters.
This makes keyboard shortcuts for word-by-word cursor movement () effective in path names and URLs." EOS]
____________________________________

;SysAnimate32


[SysAnimate32CheckingMask: D$ ? # 8]

[SysAnimate32TextTable:
 B$ 'ACS_AUTOPLAY' EOS
 B$ 'ACS_CENTER' EOS
 B$ 'ACS_TIMER' EOS
 B$ 'ACS_TRANSPARENT' EOS
 B$ 'WS_BORDER' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 'WS_VSCROLL' EOS
 B$ 'WS_HSCROLL' EOS
 B$ 0]

[SysAnimate32BitTable:
 D$ &ACS_AUTOPLAY
 D$ &ACS_CENTER
 D$ &ACS_TIMER
 D$ &ACS_TRANSPARENT
 D$ &WS_BORDER
 D$ &WS_TABSTOP
 D$ &WS_VSCROLL
 D$ &WS_HSCROLL]

[SysAnimate32ExcludeBitTable: D$ ? # 8]

[SysAnimate32MustHaveBitTable: D$ ? # 8]

[SysAnimate32StylesHelp:
 D$ ACS_AUTOPLAYhelp
 D$ ACS_CENTERhelp
 D$ ACS_TIMERhelp
 D$ ACS_TRANSPARENThelp
 D$ WS_BORDERhelp
 D$ WS_TABSTOPhelp
 D$ WS_VSCROLLhelp
 D$ WS_HSCROLLhelp]

[ACS_AUTOPLAYhelp: B$ "ACS_AUTOPLAY:

Starts playing the animation as soon as the AVI clip is opened." EOS]

[ACS_CENTERhelp: B$ "ACS_CENTER:

Centers the animation in the animation control's window." EOS]

[ACS_TIMERhelp: B$ "ACS_TIMER:

By default, the control creates a thread to play the AVI clip.
If you set this flag, the control plays the clip without creating a thread; internally the control uses a Win32 timer to synchronize playback.
Comctl32.dll version 6 and later: This style is not supported. By default, the control plays the AVI clip without creating a thread.
Note:  Comctl32.dll version 6 is not redistributable, but it is included in Microsoft Windows XP.
To use Comctl32.dll version 6, specify it in a manifest." EOS]

[ACS_TRANSPARENThelp: B$ "ACS_TRANSPARENT:

Allows you to match an animation's background color to that of the underlying window, creating a 'transparent' background.
The parent of the animation control must not have the WS_CLIPCHILDREN style.
The control sends a WM_CTLCOLORSTATIC message to its parent.
Use SetBkColor to set the background color for the device context to an appropriate value.
The control interprets the upper-left pixel of the first frame as the animation's default background color.
It will remap all pixels with that color to the value you supplied in response to WM_CTLCOLORSTATIC." EOS]
____________________________________

; SysMonthCal32

[SysMonthCal32CheckingMask: D$ ? # 9]

[SysMonthCal32TextTable:
 B$ 'MCS_DAYSTATE' EOS
 B$ 'MCS_MULTISELECT' EOS
 B$ 'MCS_WEEKNUMBERS' EOS
 B$ 'MCS_NOTODAYCIRCLE' EOS
 B$ 'MCS_NOTODAY' EOS   ; 'MCS_NOTRAILINGDATES' EOS 'MCS_SHORTDAYSOFWEEK' EOS     'MCS_NOSELCHANGEONNAV' EOS
 B$ 'WS_BORDER' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 'WS_VSCROLL' EOS
 B$ 'WS_HSCROLL' EOS
 B$ 0]


[SysMonthCal32BitTable:
 D$ &MCS_DAYSTATE
 D$ &MCS_MULTISELECT
 D$ &MCS_WEEKNUMBERS
 D$ &MCS_NOTODAYCIRCLE
 D$ &MCS_NOTODAY   ; &MCS_NOTRAILINGDATES &MCS_SHORTDAYSOFWEEK     &MCS_NOSELCHANGEONNAV (these are Vista equates.. need to get them later)
 D$ &WS_BORDER
 D$ &WS_TABSTOP
 D$ &WS_VSCROLL
 D$ &WS_HSCROLL]

[SysMonthCal32ExcludeBitTable: D$ ? # 9]

[SysMonthCal32MustHaveBitTable: D$ ? # 9]

[SysMonthCal32StylesHelp:
 D$ MCS_DAYSTATEhelp
 D$ MCS_MULTISELECThelp
 D$ MCS_WEEKNUMBERShelp
 D$ MCS_NOTODAYCIRCLEhelp
 D$ MCS_NOTODAYhelp    ;MCS_NOTRAILINGDATEShelp MCS_SHORTDAYSOFWEEKhelp     MCS_NOSELCHANGEONNAVhelp
 D$ WS_BORDERhelp
 D$ WS_TABSTOPhelp
 D$ WS_VSCROLLhelp
 D$ WS_HSCROLLhelp]

[MCS_DAYSTATEhelp: B$ "MCS_DAYSTATE:

Version 4.70. The month calendar will send MCN_GETDAYSTATE notifications to request information about which days should be displayed in bold." EOS]

[MCS_MULTISELECThelp: B$ "MCS_MULTISELECT:

Version 4.70. The month calendar will allow the user to select a range of dates within the control.
By default, the maximum range is one week. You can change the maximum range that can be selected by using the MCM_SETMAXSELCOUNT message." EOS]

[MCS_WEEKNUMBERShelp: B$ "MCS_WEEKNUMBERS:

Version 4.70. The month calendar control will display week numbers (1-52) to the left of each row of days.
Week 1 is defined as the first week that contains at least four days." EOS]

[MCS_NOTODAYCIRCLEhelp: B$ "MCS_NOTODAYCIRCLE:

Version 4.70. The month calendar control will not circle the 'today' date." EOS]

[MCS_NOTODAYhelp: B$ "MCS_NOTODAY:

Version 4.70.The month calendar control will not display the 'today' date at the bottom of the control." EOS]
____________________________________

; SysDateTimePick32

[SysDateTimePick32CheckingMask:
 D$ &DTS_APPCANPARSE
 D$ &DTS_LONGDATEFORMAT
 D$ &DTS_RIGHTALIGN
 D$ &DTS_SHOWNONE
 D$ &DTS_SHORTDATEFORMAT
 D$ &DTS_SHORTDATECENTURYFORMAT
 D$ &DTS_TIMEFORMAT
 D$ &DTS_UPDOWN
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[SysDateTimePick32TextTable:
 B$ 'DTS_APPCANPARSE' EOS
 B$ 'DTS_LONGDATEFORMAT' EOS
 B$ 'DTS_RIGHTALIGN' EOS
 B$ 'DTS_SHOWNONE' EOS
 B$ 'DTS_SHORTDATEFORMAT' EOS
 B$ 'DTS_SHORTDATECENTURYFORMAT' EOS
 B$ 'DTS_TIMEFORMAT' EOS
 B$ 'DTS_UPDOWN' EOS
 B$ 'WS_BORDER' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 'WS_VSCROLL' EOS
 B$ 'WS_HSCROLL' EOS
 B$ 0]

[SysDateTimePick32BitTable:
 D$ &DTS_APPCANPARSE
 D$ &DTS_LONGDATEFORMAT
 D$ &DTS_RIGHTALIGN
 D$ &DTS_SHOWNONE
 D$ &DTS_SHORTDATEFORMAT
 D$ &DTS_SHORTDATECENTURYFORMAT
 D$ &DTS_TIMEFORMAT
 D$ &DTS_UPDOWN
 D$ &WS_BORDER
 D$ &WS_TABSTOP
 D$ &WS_VSCROLL
 D$ &WS_HSCROLL]

[SysDateTimePick32ExcludeBitTable:
 D$ &DTS_LONGDATEFORMAT+&DTS_RIGHTALIGN+&DTS_SHOWNONE+&DTS_SHORTDATEFORMAT+&DTS_SHORTDATECENTURYFORMAT+&DTS_TIMEFORMAT+&DTS_UPDOWN
 D$ &DTS_APPCANPARSE+&DTS_RIGHTALIGN+&DTS_SHOWNONE+&DTS_SHORTDATEFORMAT+&DTS_SHORTDATECENTURYFORMAT+&DTS_TIMEFORMAT+&DTS_UPDOWN
 D$ &DTS_APPCANPARSE+&DTS_LONGDATEFORMAT+&DTS_SHOWNONE+&DTS_SHORTDATEFORMAT+&DTS_SHORTDATECENTURYFORMAT+&DTS_TIMEFORMAT+&DTS_UPDOWN
 D$ &DTS_APPCANPARSE+&DTS_LONGDATEFORMAT+&DTS_RIGHTALIGN+&DTS_SHORTDATEFORMAT+&DTS_SHORTDATECENTURYFORMAT+&DTS_TIMEFORMAT+&DTS_UPDOWN
 D$ &DTS_APPCANPARSE+&DTS_LONGDATEFORMAT+&DTS_RIGHTALIGN+&DTS_SHOWNONE+&DTS_SHORTDATECENTURYFORMAT+&DTS_TIMEFORMAT+&DTS_UPDOWN
 D$ &DTS_APPCANPARSE+&DTS_LONGDATEFORMAT+&DTS_RIGHTALIGN+&DTS_SHOWNONE+&DTS_SHORTDATEFORMAT+&DTS_TIMEFORMAT+&DTS_UPDOWN
 D$ &DTS_APPCANPARSE+&DTS_LONGDATEFORMAT+&DTS_RIGHTALIGN+&DTS_SHOWNONE+&DTS_SHORTDATEFORMAT+&DTS_SHORTDATECENTURYFORMAT+&DTS_UPDOWN
 D$ &DTS_APPCANPARSE+&DTS_LONGDATEFORMAT+&DTS_RIGHTALIGN+&DTS_SHOWNONE+&DTS_SHORTDATEFORMAT+&DTS_SHORTDATECENTURYFORMAT+&DTS_TIMEFORMAT
 D$ 0
 D$ 0
 D$ 0
 D$ 0]

[SysDateTimePick32MustHaveBitTable: D$ ? # 12]

[SysDateTimePick32StylesHelp:
 D$ DTS_APPCANPARSEhelp
 D$ DTS_LONGDATEFORMAThelp
 D$ DTS_RIGHTALIGNhelp
 D$ DTS_SHOWNONEhelp
 D$ DTS_SHORTDATEFORMAThelp
 D$ DTS_SHORTDATECENTURYFORMAThelp
 D$ DTS_TIMEFORMAThelp
 D$ DTS_UPDOWNhelp
 D$ WS_BORDERhelp
 D$ WS_TABSTOPhelp
 D$ WS_VSCROLLhelp
 D$ WS_HSCROLLhelp]

[DTS_APPCANPARSEhelp: B$ "DTS_APPCANPARSE:

Allows the owner to parse user input and take necessary action.
It enables users to edit within the client area of the control when they press the F2 key.
The control sends DTN_USERSTRING notification messages when users are finished." EOS]

[DTS_LONGDATEFORMAThelp: B$ "DTS_LONGDATEFORMAT:

Displays the date in long format.
The default format string for this style is defined by LOCALE_SLONGDATEFORMAT, which produces output like 'Friday, April 19, 1996'." EOS]

[DTS_RIGHTALIGNhelp: B$ "DTS_RIGHTALIGN:

The drop-down month calendar will be right-aligned with the control instead of left-aligned, which is the default." EOS]

[DTS_SHOWNONEhelp: B$ "DTS_SHOWNONE:

It is possible to have no date currently selected in the control.
With this style, the control displays a check box that users can check once they have entered or selected a date.
Until this check box is checked, the application will not be able to retrieve the date from the control because, in essence, the control has no date.
This state can be set with the DTM_SETSYSTEMTIME message or queried with the DTM_GETSYSTEMTIME message." EOS]

[DTS_SHORTDATEFORMAThelp: B$ "DTS_SHORTDATEFORMAT:

Displays the date in short format.
The default format string for this style is defined by LOCALE_SSHORTDATE, which produces output like '4/19/96'." EOS]

[DTS_SHORTDATECENTURYFORMAThelp: B$ "DTS_SHORTDATECENTURYFORMAT:

Version 5.80. Similar to the DTS_SHORTDATEFORMAT style, except the year is a four-digit field.
The default format string for this style is based on LOCALE_SSHORTDATE. The output looks like: '4/19/1996'." EOS]

[DTS_TIMEFORMAThelp: B$ "DTS_TIMEFORMAT:

Displays the time. The default format string for this style is defined by LOCALE_STIMEFORMAT, which produces output like '5:31:42 PM'." EOS]

[DTS_UPDOWNhelp: B$ "DTS_UPDOWN:

Places an up-down control to the right of the DTP control to modify date-time values.
This style can be used in place of the drop-down month calendar, which is the default style." EOS]
____________________________________

; SysIPAddress32 . No ipaddress style exists.. we must set the minimum of WS_CHILD.

[SysIPAddress32CheckingMask: D$ ? # 5]

[SysIPAddress32TextTable:
 B$ 'WS_CHILD' EOS
 B$ 'WS_BORDER' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 'WS_VSCROLL' EOS
 B$ 'WS_HSCROLL' EOS
 B$ 0]


[SysIPAddress32BitTable:
 D$ &WS_CHILD
 D$ &WS_BORDER
 D$ &WS_TABSTOP
 D$ &WS_VSCROLL
 D$ &WS_HSCROLL]

[SysIPAddress32ExcludeBitTable: D$ ? # 5]

[SysIPAddress32MustHaveBitTable: D$ ? # 5]

[SysIPAddress32StylesHelp:
 D$ WS_CHILDhelp
 D$ WS_BORDERhelp
 D$ WS_TABSTOPhelp
 D$ WS_VSCROLLhelp
 D$ WS_HSCROLLhelp]
____________________________________

; SysPager

[SysPagerCheckingMask: D$ ? # 9]

[SysPagerTextTable:
 B$ 'PGS_AUTOSCROLL' EOS
 B$ 'PGS_DRAGNDROP' EOS
 B$ 'PGS_HORZ' EOS
 B$ 'PGS_VERT' EOS
 B$ 'WS_CHILD' EOS
 B$ 'WS_BORDER' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 'WS_VSCROLL' EOS
 B$ 'WS_HSCROLL' EOS
 B$ 0]

[SysPagerBitTable:
 D$ &PGS_AUTOSCROLL
 D$ &PGS_DRAGNDROP
 D$ &PGS_HORZ
 D$ &PGS_VERT
 D$ &WS_CHILD
 D$ &WS_BORDER
 D$ &WS_TABSTOP
 D$ &WS_VSCROLL
 D$ &WS_HSCROLL]

[SysPagerExcludeBitTable:
 D$ 0
 D$ 0
 D$ &PGS_VERT
 D$ &PGS_HORZ
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0]


[SysPagerMustHaveBitTable: D$ ? # 9]

[SysPagerStylesHelp:
 D$ PGS_AUTOSCROLLhelp
 D$ PGS_DRAGNDROPhelp
 D$ PGS_HORZhelp
 D$ PGS_VERThelp
 D$ WS_CHILDhelp
 D$ WS_BORDERhelp
 D$ WS_TABSTOPhelp
 D$ WS_VSCROLLhelp
 D$ WS_HSCROLLhelp]

[PGS_AUTOSCROLLhelp: B$ "PGS_AUTOSCROLL:

The pager control will scroll when the user hovers the mouse over one of the scroll buttons." EOS]

[PGS_DRAGNDROPhelp: B$ "PGS_DRAGNDROP:

The contained window can be a drag-and-drop target.
The pager control will automatically scroll if an item is dragged from outside the pager over one of the scroll buttons." EOS]

[PGS_HORZhelp: B$ "PGS_HORZ:

Creates a pager control that can be scrolled horizontally.
This style and the PGS_VERT style are mutually exclusive and cannot be combined." EOS]

[PGS_VERThelp: B$ "PGS_VERT:

Creates a pager control that can be scrolled vertically.
This is the default direction if no direction style is specified.
This style and the PGS_HORZ style are mutually exclusive and cannot be combined." EOS]

____________________________________

; SysLink

; Guga note:
; missing the &ICC_LINK_CLASS ? . The dialog is not showing.
; InitDialogEdition:

[SysLinkCheckingMask: D$ ? # 6]

[SysLinkTextTable:
; 'LIS_FOCUSED' EOS  'LIS_ENABLED' EOS   'LIS_VISITED' EOS
 B$ 'WS_VISIBLE' EOS
 B$ 'WS_CHILD' EOS
 B$ 'WS_BORDER' EOS
 B$ 'WS_TABSTOP' EOS
 B$ 'WS_VSCROLL' EOS
 B$ 'WS_HSCROLL' EOS
 B$ 0]

[SysLinkBitTable:
 ;&LIS_FOCUSED   &LIS_ENABLED   &LIS_VISITED
 D$ &WS_VISIBLE
 D$ &WS_CHILD
 D$ &WS_BORDER
 D$ &WS_TABSTOP
 D$ &WS_VSCROLL
 D$ &WS_HSCROLL]

[SysLinkExcludeBitTable: D$ ? # 6]

[SysLinkMustHaveBitTable: D$ ? # 6]

[SysLinkStylesHelp:
 ;LIS_FOCUSEDhelp     LIS_ENABLEDhelp     LIS_VISITEDhelp
 D$ WS_VISIBLEhelp
 D$ WS_CHILDhelp
 D$ WS_BORDERhelp
 D$ WS_TABSTOPhelp
 D$ WS_VSCROLLhelp
 D$ WS_HSCROLLhelp]
____________________________________

[QuestionMark: B$ '?' EOS]
; General routine for showing the checkboxes under the main edition:

SSCkeckBoxes:
    Mov eax 170, ebx 0

    .While B$esi > 0
        Push eax, ebx, esi

            Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                          ButtonClassName,
                                          esi,
                                          &WS_CHILD+&WS_VISIBLE+&BS_AUTOCHECKBOX,
                                          16,
                                          eax,
                                          140,
                                          10,
                                          D$H.DialogEditor,
                                          &NULL, D$H.Instance,
                                          0

            Pop esi, ebx | Push ebx, esi
            Mov D$TABLE.H.DialogControls+ebx eax
            Call 'USER32.SendMessageA' eax &WM_SETFONT D$H.MyFont &TRUE
        Pop esi, ebx, eax

        Push eax, ebx, esi
          ; This is the little Style [?] Buttons:

            Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                          ButtonClassName,
                                          QuestionMark,
                                          &WS_CHILD+&WS_VISIBLE,
                                          2,
                                          eax,
                                          12,
                                          12,
                                          D$H.DialogEditor,
                                          &NULL,
                                          D$H.Instance,
                                          0

            Mov D$TABLE.H.StyleHelpButtons+ebx eax

            Call 'USER32.SendMessageA' eax &WM_SETFONT D$H.MyFont &TRUE
        Pop edi
            Mov al 0, ecx 200 | repne scasb | Mov esi edi
        Pop ebx, eax

        add eax 14 | add ebx 4
    .End_While
ret

____________________________________________________________________________________________

; Little Dialog for viewing the Styles Help:

[HelpDialog: D$ 090CC00C2 0   ;  090CC00C2 0 ; Style
 U$ 01 09 08 0DB 033        ; Dim 01 040 090
 0                          ;      no Menu
 0                          ; Class
 0                          ; Title
 08 'Helv' 0]               ; Font

[@HelpDialogEdit: D$
 &WS_VISIBLE__&WS_CHILD__&ES_CENTER__&ES_MULTILINE__&ES_AUTOVSCROLL__&WS_VSCROLL__&WS_BORDER
 0

 U$ 0 0 0DB 033             ; Dim
 01                         ; ID
 0FFFF 081                  ; Class
 0                          ; TitleV.
 0]                         ; No creation data

____________________________________________________________________________________________

Proc HelpDialogProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    .If D@msg = &WM_INITDIALOG
      ; lParam >>> InitValue >>> set Text...
        Call 'USER32.SetDlgItemTextA' D@hwnd, 1, D@lParam

    .Else_If D@msg = &WM_CTLCOLOREDIT
        Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        Call 'USER32.SendMessageA' D@lParam &EM_SETSEL 0 0
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>>

    .Else_If D@msg = &WM_PARENTNOTIFY
        jmp L4>

    .Else_If D@msg = &WM_LBUTTONDOWN
        jmp L4>

    .Else_If D@msg = &WM_RBUTTONDOWN
        jmp L4>

    .Else_If D@msg = &WM_COMMAND
        Mov eax D@wParam, ebx eax | shr eax 16 | and ebx 0FFFF

        If ebx = &IDCANCEL
            jmp L4>
        Else_If eax = &EN_CHANGE
            jmp L4>
        Else_If eax = &EN_UPDATE
L4:         Call 'USER32.SetFocus' D$H.DialogList
            jmp L5>
        Else_If eax = &EN_KILLFOCUS
L5:         Call 'USER32.EndDialog' D@hwnd 0
        End_If

    .Else
L8:     popad | Mov eax &FALSE | jmp L9>
    .End_If

    popad | Mov eax &TRUE

L9: EndP


[ShowSetOfCheckBoxes | Mov esi #1 | Call SSCkeckBoxes]

[CCFstring: B$
"

  Style settings depend on what Class you choose    
  (line 4 of each control).

  Set the Class first

  " EOS]

[CCFtitle: B$ "Arghhhhhh!!!!... " EOS]


ControlClassFirst:
    Call 'USER32.MessageBoxA' D$H.MainWindow, CCFstring, CCFtitle, &MB_SYSTEMMODAL
ret

; from line pointed by user, searches what class and return in edi:ebx
; adress_of_table: index_of_string:

ShowControlStyleControl:
    Push D$DialogListIndex
       add D$DialogListIndex Line_Class | Call SearchWhatControlClass

       ..If edi = ControlClassByNumber
            If ebx = 0      | ShowSetOfCheckBoxes ButtonTextTable
            Else_If ebx = 1 | ShowSetOfCheckBoxes EditTextTable
            Else_If ebx = 2 | ShowSetOfCheckBoxes StaticTextTable
            Else_If ebx = 3 | ShowSetOfCheckBoxes ListTextTable
            Else_If ebx = 4 | ShowSetOfCheckBoxes ScrollTextTable
            Else_If ebx = 5 | ShowSetOfCheckBoxes ComboTextTable
            Else
                Call ControlClassFirst
            End_If
       ..Else                                                   ; (edi = ControlClassByNames)
            .If ebx = 0      | ShowSetOfCheckBoxes UpDownTextTable
            .Else_If ebx = 1 | ShowSetOfCheckBoxes ProgressTextTable
            .Else_If ebx = 2 | ShowSetOfCheckBoxes TrackTextTable
            .Else_If ebx = 3 | ShowSetOfCheckBoxes TreeTextTable
            .Else_If ebx = 4 | ShowSetOfCheckBoxes TabTextTable
            .Else_If ebx = 5 | ShowSetOfCheckBoxes ListViewTextTable
            .Else_If ebx = 6 | ShowSetOfCheckBoxes ToolBarTextTable
            .Else_If ebx = 7 | ShowSetOfCheckBoxes RichEdit20aTextTable
            .Else_If ebx = 8 | ShowSetOfCheckBoxes SysHeader32TextTable
            .Else_If ebx = 9 | ShowSetOfCheckBoxes ReBarWindow32TextTable
            .Else_If ebx = 10 | ShowSetOfCheckBoxes Tooltips_class32TextTable
            .Else_If ebx = 11 | ShowSetOfCheckBoxes msctls_statusbar32TextTable
            .Else_If ebx = 12 | ShowSetOfCheckBoxes msctls_hotkey32TextTable
            .Else_If ebx = 13 | ShowSetOfCheckBoxes ComboBoxEx32TextTable
            .Else_If ebx = 14 | ShowSetOfCheckBoxes SysAnimate32TextTable
            .Else_If ebx = 15 | ShowSetOfCheckBoxes SysMonthCal32TextTable
            .Else_If ebx = 16 | ShowSetOfCheckBoxes SysDateTimePick32TextTable
            .Else_If ebx = 17 | ShowSetOfCheckBoxes SysIPAddress32TextTable
            .Else_If ebx = 18 | ShowSetOfCheckBoxes SysPagerTextTable
            .Else_If ebx = 19 | ShowSetOfCheckBoxes SysLinkTextTable
            .End_If
       ..End_If

    Pop D$DialogListIndex
ret

[ID_Message: B$ "==== Set the ID first ====





==== Mouse Edition ====


    Move: Left button.

    Resize: Right Button." EOS]

ShowIDcontrols:
    Call SearchDialogLine | Mov esi edi | Call TranslateDialogHexa
    Push ebx

        Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                      EditClass,
                                      &NULL,
                                      &WS_CHILD+&WS_VISIBLE+&WS_BORDER+&ES_NUMBER+&ES_RIGHT+&ES_MULTILINE,
                                      80,
                                      200,
                                      45,
                                      20,
                                      D$H.DialogEditor,
                                      &NULL,
                                      D$H.Instance,
                                      0

        Mov D$TABLE.H.DialogControls eax

        Call 'USER32.GetDlgCtrlID' eax

    Pop ebx

    Call 'USER32.SetDlgItemInt' D$H.DialogEditor, eax, ebx, &FALSE

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  EditClass,
                                  &NULL,
                                  &WS_CHILD+&WS_VISIBLE+&ES_MULTILINE+&ES_READONLY,
                                  4,
                                  250,
                                  140,
                                  200,
                                  D$H.DialogEditor,
                                  &NULL,
                                  D$H.Instance,
                                  0

    Mov D$TABLE.H.DialogControls+4 eax

    Call 'USER32.SendMessageA' eax, &WM_SETTEXT, 0, ID_Message

    Call 'USER32.SendMessageA' D$TABLE.H.DialogControls+4, &WM_SETFONT, D$H.MyFont, &TRUE


    Call 'USER32.SetFocus' D$TABLE.H.DialogControls

    Call 'USER32.SendMessageA' D$TABLE.H.DialogControls ,&EM_SETSEL, 0, 0-1
ret

[ControlClassByNumber:
 B$ 'Button' EOS
 B$ 'Edit control' EOS
 B$ 'Static Control' EOS
 B$ 'ListBox' EOS
 B$ 'ScrollBar' EOS
 B$ 'ComboBox' EOS
 B$ 0]

;[D_button 080  D_Edit 081  D_Static 082  D_ListBox 083  D_ScrollBar 084  D_ComboBox 085]

[ControlClassByNames:
 B$ 'msctls_updown32' EOS
 B$ 'msctls_progress32' EOS
 B$ 'msctls_trackbar32' EOS
 B$ 'SysTreeView32' EOS
 B$ 'SysTabControl32' EOS
 B$ 'SysListView32' EOS
 B$ 'ToolbarWindow32' EOS,
 B$ 'RichEdit20A' EOS
 B$ 'SysHeader32' EOS
 B$ 'ReBarWindow32' EOS
 B$ 'tooltips_class32' EOS
 B$ 'msctls_statusbar32' EOS
 B$ 'msctls_hotkey32' EOS
 B$ 'ComboBoxEx32' EOS
 B$ 'SysAnimate32' EOS
 B$ 'SysMonthCal32' EOS
 B$ 'SysDateTimePick32' EOS
 B$ 'SysIPAddress32' EOS
 B$ 'SysPager' EOS
 B$ 'SysLink' EOS
 B$ 0]

[ActualClassName: D$ ? # 10]

; From line pointed by user, searches what class and return in edi:ebx
; adress_of_table: index_of_string. ebx value is 0 to 5, edi either "ControlClassByNumber"
; or "ControlClassByNumber" (6 classes 'by number', 6 classes 'by name'):

SearchWhatControlClass:
    Call SearchDialogLine
    ..If D$edi = 'FFFF'
        Mov esi edi | add esi 5 | Call TranslateDialogHexa  ; > ebx = 080 / 081 / ...
        sub ebx 080 | Mov edi ControlClassByNumber          ; > ebx = 0 / 1 / 2...
    ..Else
        Mov eax D$edi+8
        .If D$edi+8 = 'updo'         ; msctls_updown32
            Mov ebx 0
        .Else_If D$edi+8 = 'prog'    ; msctls_progress32
            Mov ebx 1
        .Else_If D$edi+8 = 'trac'    ; msctls_trackbar32
            Mov ebx 2
        .Else_If D$edi+4 = 'Tree'    ; SysTreeView32
            Mov ebx 3
        .Else_If D$edi+4 = 'List'    ; SysListView32
            Mov ebx 5
        .Else_If D$edi+8 = 'ontr'    ; SysTabControl32
            Mov ebx 4
        .Else_If D$edi+1 = 'Tool'    ; ToolbarWindow32
            Mov ebx 6
        .Else_If D$edi+8 = 't20A'    ; RichEdit20a
            Mov ebx 7
        .Else_If D$edi+1 = 'SysH'    ; SysHeader32
            Mov ebx 8
        .Else_If D$edi+1 = 'ReBa'   ; ReBarWindow32
            Mov ebx 9
        .Else_If D$edi+5 = 'tips'  ;tooltips_class32
            Mov ebx 10
        .Else_If D$edi+8 = 'stat' ; msctls_statusbar32
            Mov ebx 11
        .Else_If D$edi+8 = 'hotk'; msctls_hotkey32
            Mov ebx 12
        .Else_If D$edi+1 = 'Comb' ;ComboBoxEx32
            Mov ebx 13
        .Else_If D$edi+1 = 'SysA'; SysAnimate32
            Mov ebx 14
        .Else_If D$edi+1 = 'SysM' ;SysMonthCal32
            Mov ebx 15
        .Else_If D$edi+1 = 'SysD' ;SysDateTimePick32
            Mov ebx 16
        .Else_If D$edi+1 = 'SysI' ;SysIPAddress32
            Mov ebx 17
        .Else_If D$edi+1 = 'SysP'  ;SysPager
            Mov ebx 18
        .Else_If D$edi+1 = 'SysL'  ; SysLink
            Mov ebx 19
        .End_If

      Mov edi ControlClassByNames
    ..End_If
ret


ShowClassControls:

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  ComboClass,
                                  &NULL,
                                  &WS_CHILD+&WS_VISIBLE+&WS_BORDER+&CBS_HASSTRINGS+&CBS_AUTOHSCROLL+&CBS_DROPDOWNLIST+&WS_VSCROLL+&ES_AUTOVSCROLL,
                                  2,
                                  200,
                                  145,
                                  320,
                                  D$H.DialogEditor,
                                  &NULL,
                                  D$H.Instance,
                                  0

    Mov D$TABLE.H.DialogControls eax

    ; Copy data font text (without quotes and comments) in TitleEditText:

    Call SearchWhatControlClass

    Mov al 0, ecx 0FFFF
    While ebx > 0                       ; setting edi > start of whatever class
        repne scasb | dec ebx           ; name, either by number or by name
    End_While
    Mov esi edi, ecx 200 , al 0
    Mov edi ActualClassName

L0: lodsb | stosb | cmp al 0 | ja L0<   ; copying actual name for next 'CB_SELECTSTRING'

    Mov edi ControlClassByNumber        ; build list name from class by numbers:
    While B$edi > 0
        Push edi
            Call 'USER32.SendMessageA' D$TABLE.H.DialogControls &CB_ADDSTRING 0  edi
        Pop edi
        Mov al 0, ecx 200 | repne scasb
    End_While

    Mov edi ControlClassByNames         ; build list name from class by names:
    While B$edi > 0
        Push edi
            Call 'USER32.SendMessageA' D$TABLE.H.DialogControls &CB_ADDSTRING 0  edi
        Pop edi
        Mov al 0, ecx 200 | repne scasb
    End_While

  ; setting actual choice in edit control of ComboBox:
    Call 'USER32.SendMessageA' D$TABLE.H.DialogControls &CB_SELECTSTRING  0  ActualClassName
ret
____________________________________________________________________________________

; used by many 'user modifications' writting inside the edited template:

SearchDialogLine:
    Mov ecx MaxTemplateText, edi D$NewDialogTemplateText, ebx 0, al 0

    While ebx < D$DialogListIndex
        repne scasb | inc ebx
    End_While
ret


NoDialogMenu:
    Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'There is no Menu in this Dialog' EOS},
                              {B$ ' Dialog Menu' EOS}, &MB_SYSTEMMODAL
ret


; At same time: reset the table of controls handles and close these controls:

KillPreviousDialogControls:
    Mov esi TABLE.H.DialogControls
    While D$esi > 0
        lodsd | Mov D$esi-4 0
        Push esi
            Call 'USER32.DestroyWindow' eax
        Pop esi
    End_While

    Mov esi TABLE.H.StyleHelpButtons
    While D$esi > 0
        lodsd | Mov D$esi-4 0
        Push esi
            Call 'USER32.DestroyWindow' eax
        Pop esi
    End_While
ret

;;
;[NewMenuForDialog: B$ "
;    Do you want to create a new menu?    
;     " EOS]

OldAddMenuToDialog:
    Mov esi MenuList

   ..If D$esi = 0                               ; no Menu:
        Call 'USER32.MessageBoxA' D$H.MainWindow  NewMenuForDialog  argh,
                                &MB_SYSTEMMODAL+&MB_ICONQUESTION+&MB_YESNO
        If eax = &IDYES
            Call NewMenu
            Mov eax D$MenuListPtr               ; either 0 or ID
        Else
            Mov eax 0
        End_If
   ..Else                                       ; menu(s) exist in rsrc:
        Call 'USER32.MessageBoxA' D$H.MainWindow NewMenuForDialog  argh,
                                &MB_SYSTEMMODAL+&MB_ICONQUESTION+&MB_YESNO
        .If eax = &IDYES
            Call NewMenu | Mov D$ActualMenutestID 0
            Mov esi D$MenuListPtr
            If D$esi = 0
                Mov eax 0
            Else
                Mov eax D$MenuListPtr
            End_If
        .Else
            Mov D$MenuListPtr MenuList,  B$UserTellWhatMenu &FALSE
            While B$UserTellWhatMenu = &FALSE   ; even if only 1 menu because we do
                Call WhatMenu                   ; not set here the true user menu ID but
            End_While                           ; intead the 'D$ActualMenutestID'
            If D$MenuListPtr = 0
                Mov eax 0
            Else
                Mov eax D$MenuListPtr
            End_If
        .End_If
   ..End_If

   ; now, eax = Menu ID or 0.
   .If eax = 0
        Mov D$ActualMenutestID 0, D$DialogMenuTrueID 0
   .Else
        Move D$DialogMenuTrueID D$eax
        If D$DialogMenuTrueID <> 0              ; happends if user abort menu edition
            add eax 4 | Call 'USER32.LoadMenuIndirectA' D$eax ; menu Id (from resources)
            Mov D$ActualMenutestID eax
            Call SearchDialogLine
            Mov eax 'FFFF' | stosd | Mov al SPC | stosb
            Mov ebx D$DialogMenuTrueID
            Call TranslateDialogText4 | Mov al SPC | stosb | Mov ax '; ' | stosw
            Call FromTextToBinTemplate | Call ShowDialogResult | Call FillDialogListBox
        End_If
   .End_If
ret
;;

AddMenuToDialog:
    Call 'USER32.DialogBoxParamA' D$H.Instance 31555 &NULL NewOrExistingMenuProc &NULL

    .If B$NewOrExistingMenuChoice = 6           ; New.
        Call NewMenu | Mov D$ActualMenutestID 0
        Mov esi D$MenuListPtr
        If D$esi = 0
            Mov eax 0
        Else
            Mov eax D$MenuListPtr
        End_If

    .Else_If B$NewOrExistingMenuChoice = 5       ; Existing.
        Mov D$MenuListPtr MenuList,  B$UserTellWhatMenu &FALSE
        While B$UserTellWhatMenu = &FALSE   ; even if only 1 menu because we do
            Call WhatMenu                   ; not set here the true user menu ID but
        End_While                           ; intead the 'D$ActualMenutestID'
        If D$MenuListPtr = 0
            Mov eax 0
        Else
            Mov eax D$MenuListPtr
        End_If

    .End_If

 ; now, eax = Menu ID or 0.
   .If eax = 0
        Mov D$ActualMenutestID 0, D$DialogMenuTrueID 0
   .Else
        Move D$DialogMenuTrueID D$eax
        If D$DialogMenuTrueID <> 0              ; happends if user abort menu edition
            add eax 4 | Call 'USER32.LoadMenuIndirectA' D$eax ; menu Id (from resources)
            Mov D$ActualMenutestID eax
            Call SearchDialogLine
            Mov eax 'FFFF' | stosd | Mov al SPC | stosb
            Mov ebx D$DialogMenuTrueID
            Call TranslateDialogText4 | Mov al SPC | stosb | Mov ax '; ' | stosw
            Call FromTextToBinTemplate | Call ShowDialogResult | Call FillDialogListBox
        End_If
   .End_If
ret


[NewOrExistingMenuChoice: D$ ?]

Proc NewOrExistingMenuProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_INITDIALOG
      ; If no Menu >>> Disable the [Load Existing] Button:
        Mov esi MenuList
        If D$esi = 0
            Call 'USER32.GetDlgItem' D@hwnd, 5
            Call 'USER32.EnableWindow' eax &FALSE
        End_If

    ...Else_If D@msg = &WM_COMMAND
        Mov eax D@wParam | and D@wParam 0FFFF | shr eax 16

        If D@wParam = &IDCANCEL
            Mov B$NewOrExistingMenuChoice 0
            Call 'USER32.DestroyWindow' D@hwnd

        Else_If D@wParam = 5            ; Existing.
            Mov B$NewOrExistingMenuChoice 5
            Call 'USER32.DestroyWindow' D@hwnd

        Else_If D@wParam = 6            ; New.
            Mov B$NewOrExistingMenuChoice 6
            Call 'USER32.DestroyWindow' D@hwnd

        Else_If D@wParam = &IDHELP
            Call Help, B_U_AsmName, DialogHelp, ContextHlpMessage

        End_If

    ...Else
L8:     popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE
L9: EndP
____________________________________________________________________________________________



EditDialogMenu:
    Push D$DialogMenuTrueID
        Mov esi MenuList, eax D$DialogMenuTrueID
        While D$esi <> eax
            add esi 12
        End_While
        Mov D$MenuListPtr esi | Call ReEditExistingMenu
    Pop eax

    If D$uMenu_ID <> eax
      Move D$DialogMenuTrueID D$uMenu_ID
    End_If

    Mov eax D$MenuListPtr | add eax 4          ; ptr to menu data
    Call 'USER32.LoadMenuIndirectA' D$eax | Mov D$ActualMenutestID eax
    Call SearchDialogLine
    Mov eax 'FFFF' | stosd | Mov al SPC | stosb
    Mov ebx D$DialogMenuTrueID
    Call TranslateDialogText4 | Mov al SPC | stosb | Mov ax '; ' | stosw
    Call FromTextToBinTemplate | Call ShowDialogResult | Call FillDialogListBox
ret

______________________________________________________________________________________
;;
 Setting of the wished controls under main list box for editing user dialog. (User
 have click on some item >>> which one >>> what controls to be set). As these controls
 may be many or few (or none), i choose a dynamic storage for the handles, whatever
 they are: One simgle table ("TABLE.H.DialogControls") is used to store all the handles
 as they come, without any visible symbolic name for further identification. To know
 what user is doing, we use the index (selected item) of the main list. In some cases
 (Dialog Callback checking), we scan the number of handles written in the List.
;;

[DialogListIndex: D$ ?           ; true 0 based line number in main list
 ControlIndex: D$ ?]             ; 0 based index of line in one control

[NoDialogControl | Mov D$DialogListIndex 0_FFFF_FFFF | Mov D$ControlIndex 0_FFFF_FFFF]

SetDialogTools:
    Call KillPreviousDialogControls
    NoDialogControl
    Call 'USER32.SendMessageA' D$H.DialogList, &LB_GETCURSEL, eax, 0
    Mov D$DialogListIndex eax

    ..If eax < Line_empty
        Mov D$ControlIndex eax
        .If eax = Line_Style
            Call ShowDialogStyleControl | Call ShowDialogStyles
        .Else_If eax = Line_Dim
            Mov D$DimIsForDialogWindow &TRUE | Call ShowDimControls
        .Else_If eax = Line_ID
            Call SearchDialogLine
            If D$edi = 'FFFF'
                Call EditDialogMenu
            Else
                Call AddMenuToDialog
            End_If
        .Else_If eax = Line_Class
            Call ShowTitleControl          ; reuse for dialog class
         ;  NoDialogControl  ; not yet
        .Else_If eax = Line_Class
            NoDialogControl  ; not yet
        .Else_If eax = Line_Title
            Call ShowTitleControl
        .Else_If eax = Line_Font
            Call ShowFontControls
        .End_If
    ..Else_If eax = Line_empty
        NoDialogControl    ; separator
    ..Else_If eax < D$LastDialogListItem
L1:     sub eax Line_empty+1 | cmp eax Line_empty+1 | jae L1<
        Mov D$ControlIndex eax
        If eax = Line_Style
            Call ShowControlStyleControl | Call ShowControlStyles
        Else_If eax = Line_ExStyle
            NoDialogControl   ; not yet
        Else_If eax = Line_Dim
            Mov D$DimIsForDialogWindow &FALSE | Call ShowDimControls
        Else_If eax = Line_ID
            Call ShowIDcontrols
        Else_If eax = Line_Class
            Call ShowClassControls
        Else_If eax = Line_Title
            Call ShowTitleControl
        Else_If eax = Line_Font
            NoDialogControl   ; not yet
        End_If
    ..End_If
ret

____________________________________________________________________________________
____________________________________________________________________________________

; Showing user modifications result:
____________________________________________________________________________________
____________________________________________________________________________________

[NextTemplateLine | xchg esi edi | Mov al 0 | Mov ecx 200 | repne scasb | xchg esi edi]

[ControlNumberPtr: D$ ?]            ; user doesn't have to set this record (before Dims)

; Translate the text template (visible in Editor Edit Control) into a Binary Template
; run by RosAsm (without the menu and the class, if any). (see 'DialogMenuComment')
;
; 'FromBinToTextTemplate' doesn't do the reverse operation...

FromTextToBinTemplate:
    Mov esi D$NewDialogTemplateText, edi D$EditedDialogBoxData

    add esi 3 | Call TranslateDialogHexa | Mov eax ebx | stosd  ; Style
    NextTemplateLine
    add esi 3 | Call TranslateDialogHexa | Mov eax ebx | stosd  ; extended style
    NextTemplateLine | add esi 3
    Mov D$ControlNumberPtr edi                                  ; used down there to
    Call TranslateDialogHexa | Mov eax 0 | stosw                ; set dummy control number
    Call TranslateDialogHexa | Mov eax ebx | stosw              ; X pos
    Call TranslateDialogHexa | Mov eax ebx | stosw              ; Y pos
    Call TranslateDialogHexa | Mov eax ebx | stosw              ; width
    Call TranslateDialogHexa | Mov eax ebx | stosw              ; hight
    NextTemplateLine | Call TranslateDialogHexa
  ; Why the commented out lines? >>> DialogMenuComment
  ;  If ebx = 0
      Mov ax 0 | stosw                                          ; no menu
  ;  Else
  ;    Mov eax ebx | stosw                                      ; 0FFFF in ebx > menu
  ;    Call TranslateDialogHexa
  ;    Mov eax ebx | stosw                                      ; menu ID
  ;  End_If
    NextTemplateLine | inc esi
    Mov eax 0 | stosw                                           ; no class in edition
  ;  Mov al 0FF
    Push edi
        Mov edi ClassRecord
L0:     cmp B$esi '"' | je L1>
        cmp B$esi "'" | je L1>
            lodsb | stosb                                       ; preserve Class for savings
        jmp L0<
L1:     Mov eax 0 | stosd                                       ; end mark at our string
    Pop edi
    NextTemplateLine | inc esi | Mov eax 0
L0: cmp B$esi '"' | je L1>
    cmp B$esi "'" | je L1>
        lodsb | stosw                                            ; title
    jmp L0<
L1: Mov ax 0 | stosw |  NextTemplateLine
    Call TranslateDialogHexa | Mov eax ebx | stosw               ; font size
    inc esi | Mov ax 0
L0: cmp B$esi '"' | je L1>
    cmp B$esi "'" | je L1>
        lodsb | stosw                                            ; font name
    jmp L0<
L1: Mov ax 0 | stosw
    Test edi 00_11 ZERO L1>                                      ; Dword aligned?
        stosw                                                    ; no > align!
L1: NextTemplateLine | NextTemplateLine                          ; + 1 blank line in text

    .While B$esi <> 255                                          ; Controls data:
        Mov ebx D$ControlNumberPtr | inc W$ebx
        add esi 3
        Call TranslateDialogHexa | Mov eax ebx | stosd           ; style
        NextTemplateLine | add esi 3
        Call TranslateDialogHexa | Mov eax ebx | stosd           ; extended style
        NextTemplateLine | add esi 3

        Call TranslateDialogHexa | Mov eax ebx | stosw           ; X pos
        Call TranslateDialogHexa | Mov eax ebx | stosw           ; Y pos
        Call TranslateDialogHexa | Mov eax ebx | stosw           ; width
        Call TranslateDialogHexa | Mov eax ebx | stosw           ; hight
        NextTemplateLine
        Call TranslateDialogHexa | Mov eax ebx | stosw           ; ID
        NextTemplateLine
        If D$esi = 'FFFF'                                        ; class by number:
            Mov ax 0FFFF | stosw | add  esi 5
            Call TranslateDialogHexa | Mov eax ebx | stosw       ; class
        Else
            inc esi | Mov eax 0
L0:         cmp B$esi '"' | je L1>
            cmp B$esi "'" | je L1>
            lodsb | stosw
            jmp L0<
L1:         Mov ax 0 | stosw
        End_If
        NextTemplateLine | inc esi | Mov ax 0
L0:     cmp B$esi '"' | je L1>
        cmp B$esi "'" | je L1>
            lodsb | stosw                                       ; title
        jmp L0<
L1:     Mov ax 0 | stosw                                        ; end mark
        NextTemplateLine | stosw                                ; no creation dat
        Test edi 00_11 ZERO L1>                                 ; Dword aligned?
            stosw                                               ; no > align!
L1:     NextTemplateLine  | NextTemplateLine                    ; + 1 blank line in text

    .End_While
ret
______________________________________________________________________________________

; User have click some 'Style' CheckBox. Called by 'EditDialogBoxProc' with
;  buttons handles in ecx, tables index in ebx

[H.ClickedCheckBox: D$ ?
 FlagCheck: D$ ?]

WriteStyle:
    Mov eax D$DialogListIndex, D$H.ClickedCheckBox ecx

    ...If eax = D$ControlIndex              ; >>> this is for Dialog Style:
        Move D$CheckMust D$DialogMustHaveBitTable+ebx
        Move D$CheckExclude D$DialogExcludeBitTable+ebx
        Move D$CheckingMask DialogCheckingMask
        Move D$CheckBit D$DialogBitTable+ebx
        Mov esi DialogBitTable

    ...Else                                  ; >>> this is for Control Style:
        Push ebx                                ; table indice (0 / 4 / 8 / 12...)
            add D$DialogListIndex Line_Class
            Call SearchWhatControlClass             ; ebx = indice of class (0 / 1 / 2 / 3...)
            sub D$DialogListIndex Line_Class
        Pop eax                                       ; table indice in eax
        ..If edi = ControlClassByNumber               ; >>> class by Number
            .If ebx = 0
                Move D$CheckMust D$ButtonMustHaveBitTable+eax      ; Button
                Move D$CheckExclude D$ButtonExcludeBitTable+eax
                Move D$CheckingMask ButtonCheckingMask
                Move D$CheckBit D$ButtonBitTable+eax
                Mov esi ButtonBitTable
            .Else_If ebx = 1
                Move D$CheckMust D$EditMustHaveBitTable+eax        ; Edit control
                Move D$CheckExclude D$EditExcludeBitTable+eax
                Move D$CheckingMask EditCheckingMask
                Move D$CheckBit D$EditBitTable+eax
                Mov esi EditBitTable
            .Else_If ebx = 2
                Move D$CheckMust D$StaticMustHaveBitTable+eax      ; Static Control
                Move D$CheckExclude D$StaticExcludeBitTable+eax
                Move D$CheckingMask StaticCheckingMask
                Move D$CheckBit D$StaticBitTable+eax
                Mov esi StaticBitTable
            .Else_If ebx = 3
                Move D$CheckMust D$ListMustHaveBitTable+eax        ; ListBox
                Move D$CheckExclude D$ListExcludeBitTable+eax
                Move D$CheckingMask ListCheckingMask
                Move D$CheckBit D$ListBitTable+eax
                Mov esi ListBitTable
            .Else_If ebx = 4
                Move D$CheckMust D$ScrollMustHaveBitTable+eax      ; ScrollBar
                Move D$CheckExclude D$ScrollExcludeBitTable+eax
                Move D$CheckingMask ScrollCheckingMask
                Move D$CheckBit D$ScrollBitTable+eax
                Mov esi ScrollBitTable
            .Else_If ebx = 5
                Move D$CheckMust D$ComboMustHaveBitTable+eax       ; ComboBox
                Move D$CheckExclude D$ComboExcludeBitTable+eax
                Move D$CheckingMask ComboCheckingMask
                Move D$CheckBit D$ComboBitTable+eax
                Mov esi ComboBitTable
            .End_If
        ..Else                                         ; >>> class by Name
            .If ebx = 0
                Move D$CheckMust D$UpDownMustHaveBitTable+eax      ; msctls_updown32
                Move D$CheckExclude D$UpDownExcludeBitTable+eax
                Move D$CheckingMask UpDownCheckingMask
                Move D$CheckBit D$UpDownBitTable+eax
                Mov esi UpDownBitTable
            .Else_If ebx = 1
                ret                                    ; msctls_progress32 (no controls)
            .Else_If ebx = 2
                Move D$CheckMust D$TrackMustHaveBitTable+eax       ; msctls_trackbar32
                Move D$CheckExclude D$TrackExcludeBitTable+eax
                Move D$CheckingMask TrackCheckingMask
                Move D$CheckBit D$TrackBitTable+eax
                Mov esi TrackBitTable
            .Else_If ebx = 3
                Move D$CheckMust D$TreeMustHaveBitTable+eax        ; SysTreeView32
                Move D$CheckExclude D$TreeExcludeBitTable+eax
                Move D$CheckingMask TreeCheckingMask
                Move D$CheckBit D$TreeBitTable+eax
                Mov esi TreeBitTable
            .Else_If ebx = 4
                Move D$CheckMust D$TabMustHaveBitTable+eax         ; SysTabControl32
                Move D$CheckExclude D$TabExcludeBitTable+eax
                Move D$CheckingMask TabCheckingMask
                Move D$CheckBit D$TabBitTable+eax
                Mov esi TabBitTable
            .Else_If ebx = 5
                Move D$CheckMust D$ListViewMustHaveBitTable+eax    ; SysListView32
                Move D$CheckExclude D$ListViewExcludeBitTable+eax
                Move D$CheckingMask ListViewCheckingMask
                Move D$CheckBit D$ListViewBitTable+eax
                Mov esi ListViewBitTable
            .Else_If ebx = 6
                Move D$CheckMust D$ToolBarMustHaveBitTable+eax    ; ToolbarWindow32
                Move D$CheckExclude D$ToolBarExcludeBitTable+eax
                Move D$CheckingMask ToolBarCheckingMask
                Move D$CheckBit D$ToolBarBitTable+eax
                Mov esi ToolBarBitTable

            .Else_If ebx = 7
                Move D$CheckMust D$RichEdit20aMustHaveBitTable+eax    ; RichEdit20a
                Move D$CheckExclude D$RichEdit20aExcludeBitTable+eax
                Move D$CheckingMask RichEdit20aCheckingMask
                Move D$CheckBit D$RichEdit20aBitTable+eax
                Mov esi RichEdit20aBitTable

            .Else_If ebx = 8
                Move D$CheckMust D$SysHeader32MustHaveBitTable+eax    ; SysHeader32
                Move D$CheckExclude D$SysHeader32ExcludeBitTable+eax
                Move D$CheckingMask SysHeader32CheckingMask
                Move D$CheckBit D$SysHeader32BitTable+eax
                Mov esi SysHeader32BitTable

            .Else_If ebx = 9
                Move D$CheckMust D$ReBarWindow32MustHaveBitTable+eax    ; ReBarWindow32
                Move D$CheckExclude D$ReBarWindow32ExcludeBitTable+eax
                Move D$CheckingMask ReBarWindow32CheckingMask
                Move D$CheckBit D$ReBarWindow32BitTable+eax
                Mov esi ReBarWindow32BitTable

            .Else_If ebx = 10
                Move D$CheckMust D$tooltips_class32MustHaveBitTable+eax    ; tooltips_class32
                Move D$CheckExclude D$tooltips_class32ExcludeBitTable+eax
                Move D$CheckingMask tooltips_class32CheckingMask
                Move D$CheckBit D$tooltips_class32BitTable+eax
                Mov esi tooltips_class32BitTable

            .Else_If ebx = 11
                Move D$CheckMust D$msctls_statusbar32MustHaveBitTable+eax    ; msctls_statusbar32
                Move D$CheckExclude D$msctls_statusbar32ExcludeBitTable+eax
                Move D$CheckingMask msctls_statusbar32CheckingMask
                Move D$CheckBit D$msctls_statusbar32BitTable+eax
                Mov esi msctls_statusbar32BitTable

            .Else_If ebx = 12
                Move D$CheckMust D$msctls_hotkey32MustHaveBitTable+eax    ; msctls_hotkey32
                Move D$CheckExclude D$msctls_hotkey32ExcludeBitTable+eax
                Move D$CheckingMask msctls_hotkey32CheckingMask
                Move D$CheckBit D$msctls_hotkey32BitTable+eax
                Mov esi msctls_hotkey32BitTable

            .Else_If ebx = 13
                Move D$CheckMust D$ComboBoxEx32MustHaveBitTable+eax    ; ComboBoxEx32
                Move D$CheckExclude D$ComboBoxEx32ExcludeBitTable+eax
                Move D$CheckingMask ComboBoxEx32CheckingMask
                Move D$CheckBit D$ComboBoxEx32BitTable+eax
                Mov esi ComboBoxEx32BitTable

            .Else_If ebx = 14
                Move D$CheckMust D$SysAnimate32MustHaveBitTable+eax    ; SysAnimate32
                Move D$CheckExclude D$SysAnimate32ExcludeBitTable+eax
                Move D$CheckingMask SysAnimate32CheckingMask
                Move D$CheckBit D$SysAnimate32BitTable+eax
                Mov esi SysAnimate32BitTable

            .Else_If ebx = 15
                Move D$CheckMust D$SysMonthCal32MustHaveBitTable+eax    ; SysMonthCal32
                Move D$CheckExclude D$SysMonthCal32ExcludeBitTable+eax
                Move D$CheckingMask SysMonthCal32CheckingMask
                Move D$CheckBit D$SysMonthCal32BitTable+eax
                Mov esi SysMonthCal32BitTable

            .Else_If ebx = 16
                Move D$CheckMust D$SysDateTimePick32MustHaveBitTable+eax    ; SysDateTimePick32
                Move D$CheckExclude D$SysDateTimePick32ExcludeBitTable+eax
                Move D$CheckingMask SysDateTimePick32CheckingMask
                Move D$CheckBit D$SysDateTimePick32BitTable+eax
                Mov esi SysDateTimePick32BitTable

            .Else_If ebx = 17
                Move D$CheckMust D$SysIPAddress32MustHaveBitTable+eax    ; SysIPAddress32
                Move D$CheckExclude D$SysIPAddress32ExcludeBitTable+eax
                Move D$CheckingMask SysIPAddress32CheckingMask
                Move D$CheckBit D$SysIPAddress32BitTable+eax
                Mov esi SysIPAddress32BitTable

            .Else_If ebx = 18
                Move D$CheckMust D$SysPagerMustHaveBitTable+eax    ; SysPager
                Move D$CheckExclude D$SysPagerExcludeBitTable+eax
                Move D$CheckingMask SysPagerCheckingMask
                Move D$CheckBit D$SysPagerBitTable+eax
                Mov esi SysPagerBitTable

            .Else_If ebx = 19
                Move D$CheckMust D$SysLinkMustHaveBitTable+eax    ; SysLink
                Move D$CheckExclude D$SysLinkExcludeBitTable+eax
                Move D$CheckingMask SysLinkCheckingMask
                Move D$CheckBit D$SysLinkBitTable+eax
                Mov esi SysLinkBitTable
            .End_If
        ..End_If

    ...End_If

    Push esi
        Call SearchDialogLine | add edi 3           ; edi > "NewDialogTemplateText": Style
        Mov esi edi | Call TranslateDialogHexa      ; Style value in ebx
    Pop esi
;;
 Now: D$CheckBit = bit value of the clicked checkbox
      ebx            = previous value for style
      D$CheckExclude = Excluded Bits
      D$CheckMust    = Must Have Bits
      esi            = ptr to Bit table
      edi            = "NewDialogTemplateText" concerned line +3 ("D$ "xxxxxxxx)

 We take care of "required" / "exclude" bits only if we are setting the bits:
;;
    Push esi, edi, ebx
        Call 'USER32.SendMessageA' D$H.ClickedCheckBox &BM_GETCHECK 0 0
        Mov D$FlagCheck eax
    Pop ebx, edi, esi


    On B$FlagCheck = &FALSE, jmp L1>                    ; Only if user is "checking"
        or ebx D$CheckExclude | xor ebx D$CheckExclude  ; excluded bit(s)
        or ebx D$CheckMust                              ; required bit(s)
L1: xor ebx D$CheckBit                                  ; new set bit

; or ebx &WS_THICKFRAME  (for my tests)

    Mov D$CheckActual ebx
    pushad
        Call TranslateDialogText8  ; write ebx (text) at "NewDialogTemplateText": Style
    popad

    Call CheckControlStyles

    Call FromTextToBinTemplate | Call ShowDialogResult | Call FillDialogListBox
ret

____________________________________________________________________________________________

; esi just found a valid [?] Help Butoon Handle:

ShowStyleInfo:
    .If D$CheckingMask = DialogCheckingMask
        Mov eax DialogStylesHelp
    .Else_If D$CheckingMask = ButtonCheckingMask
        Mov eax ButtonStylesHelp
    .Else_If D$CheckingMask = EditCheckingMask
        Mov eax EditStylesHelp
    .Else_If D$CheckingMask = StaticCheckingMask
        Mov eax StaticStylesHelp
    .Else_If D$CheckingMask = ListCheckingMask
        Mov eax ListBoxStyles
    .Else_If D$CheckingMask = ScrollCheckingMask
        Mov eax ScrollStylesHelp
    .Else_If D$CheckingMask = ComboCheckingMask
        Mov eax ComboStylesHelp
    .Else_If D$CheckingMask = UpDownCheckingMask
        Mov eax UpDownStylesHelp
    .Else_If D$CheckingMask = TrackCheckingMask
        Mov eax TrackStylesHelp
    .Else_If D$CheckingMask = TreeCheckingMask
        Mov eax TreeViewStylesHelp
    .Else_If D$CheckingMask = TabCheckingMask
        Mov eax TabStylesHelp
    .Else_If D$CheckingMask = ListViewCheckingMask
        Mov eax ListViewStylesHelp
    .Else_If D$CheckingMask = ToolBarCheckingMask
        Mov eax ToolBarStylesHelp
    .Else_If D$CheckingMask = RichEdit20aCheckingMask
        Mov eax RichEdit20aStylesHelp
    .Else_If D$CheckingMask = SysHeader32CheckingMask
        Mov eax SysHeader32StylesHelp
    .Else_If D$CheckingMask = ReBarWindow32CheckingMask
        Mov eax ReBarWindow32StylesHelp
    .Else_If D$CheckingMask = tooltips_class32CheckingMask
        Mov eax tooltips_class32StylesHelp
    .Else_If D$CheckingMask = msctls_statusbar32CheckingMask
        Mov eax msctls_statusbar32StylesHelp
    .Else_If D$CheckingMask = msctls_hotkey32CheckingMask
        Mov eax msctls_hotkey32StylesHelp
    .Else_If D$CheckingMask = ComboBoxEx32CheckingMask
        Mov eax ComboBoxEx32StylesHelp
    .Else_If D$CheckingMask = SysAnimate32CheckingMask
        Mov eax SysAnimate32StylesHelp
    .Else_If D$CheckingMask = SysMonthCal32CheckingMask
        Mov eax SysMonthCal32StylesHelp
    .Else_If D$CheckingMask = SysDateTimePick32CheckingMask
        Mov eax SysDateTimePick32StylesHelp
    .Else_If D$CheckingMask = SysIPAddress32CheckingMask
        Mov eax SysIPAddress32StylesHelp
    .Else_If D$CheckingMask = SysPagerCheckingMask
        Mov eax SysPagerStylesHelp
    .Else_If D$CheckingMask = SysLinkCheckingMask
        Mov eax SysLinkStylesHelp
    .End_If

    sub esi 4 | sub esi TABLE.H.StyleHelpButtons | add esi eax

    Call 'USER32.CreateDialogIndirectParamA' D$H.Instance, HelpDialog, ecx,
                                             HelpDialogProc, D$esi

ret
____________________________________________________________________________________

; Called by next routine only (to suppress the class by number before wirting a new
; class by name. edi, ecx set by caller:

StripFFFF0080:
    Mov B$edi '"' | inc edi
    Push edi
        add edi 8                                   ; edi after 'FFFF 0080'
        Push edi
            Mov al 255 | repne scasb | Mov ecx edi  ; edi > End of template
        Pop esi
        sub ecx esi                                 ; how many char to Move backward
    Pop edi                                         ; esi > first char
    rep movsb
ret


[DefaultNumberClass: B$ 'xxxx' EOS]

WriteClass: ;need LINES_!!
    Call 'USER32.SendMessageA' D$TABLE.H.DialogControls, &CB_GETCURSEL, 0, 0 | Mov ebx eax

    Mov edx D$DialogListIndex, edi D$NewDialogTemplateText, al 0, ecx MaxTemplateText
    sub edx Line_Class

L0: repne scasb | dec edx | jnz L0<                          ; to point to upper Style
    add edi 4 | Mov B$edi-1 '5', al '0', ecx 7 | rep stosb   ; reset Style record to default
    Mov edx Line_Class, al 0, ecx 0FFFFFFFF
L0: repne scasb | dec edx | jnz L0<                          ; point to Class record

    ..If D$edi = 'FFFF'
        .If ebx < 6
            add edi 8 | Mov B$edi '0' | add B$edi bl         ; new 'FFFF 008x' value
        .Else
          ; strip "text", make 9 chars room, copy 'FFFF 008x' value:
            Push edi
                Push ebx
                    Call StripFFFF0080
                Pop ebx
                sub ebx 6
                Mov edi ControlClassByNames, ecx 0FFFF, al 0
                While ebx > 0
                    repne scasb | dec ebx
                End_While                                ; edi > choosen Class by name text
            Pop esi
            inc esi                     ; "StripFFFF0080" have written first quote
            Call ResetTemplateClass
        .End_If
    ..Else                              ; edi point to "msctls_...."
      ; Strip "text":
        Push ebx, edi
            inc edi | Call StripTemplateText
        Pop edi, ebx
        .If ebx < 6
          ; make 9 chars room (including <" 0>, copy 'FFFF 008x' value):
            Push ebx
                Mov esi edi, edi DefaultNumberClass | Call ResetTemplateClass
                sub edi 7 | Mov D$edi 'FFFF', D$edi+4 ' 008'
            Pop ebx
            add bl '0' | Mov B$edi+8 bl, B$edi+9 SPC
        .Else
            Push edi
                sub ebx 6
              ; make whished lenght room, copy new Class text
                Mov edi ControlClassByNames, ecx 0FFFF, al 0
                While ebx > 0
                    repne scasb | dec ebx
                End_While
            Pop esi
            inc esi
            Call ResetTemplateClass
        .End_If
    ..End_If

    Call FromTextToBinTemplate | Call ShowDialogResult | Call FillDialogListBox
ret
_________________________________________________________________________________

WriteFontSize:
    Mov edi D$NewDialogTemplateText al 0, ecx MaxTemplateText
    repne scasb | repne scasb | repne scasb | repne scasb | repne scasb
    Push edi
        Call 'USER32.SendMessageA' D$TABLE.H.DialogControls+4  &CB_GETCURSEL  0  0
    Pop edi
    Push edi
        Call 'USER32.SendMessageA' D$TABLE.H.DialogControls+4 &CB_GETLBTEXT eax edi
    Pop edi
    Mov B$edi+2 SPC
    Call FromTextToBinTemplate | Call ShowDialogResult | Call FillDialogListBox
ret
_____________________________________________________________________________________

; 2 routines to replace some text inside template:

StripTemplateText:
    Push edi
        Mov al '"', ecx MaxTemplateText | repne scasb | dec edi ; edi > lasting '"'
        Push edi
            Mov al 255 | repne scasb                            ; edi > End of template
            Mov ecx edi
        Pop esi
        sub ecx esi                                    ; how many char to Move backward
    Pop edi                                                     ; esi > first char
    rep movsb
ret


ResetTemplateText:
    Push edi
        Push esi                                                ; > where to write
            Mov al 0, ecx 120, ebx 120 | repne scasb
            sub ecx 120 | neg ecx | Mov ebx ecx                 ; new string lenght
            Mov edi D$NewDialogTemplateText, al 255, ecx MaxTemplateText
            repne scasb | Mov esi edi | add edi ebx             ; edi, esi ready for room
        Pop eax
        Push eax
            Mov ecx esi | sub ecx eax | dec edi
            std
                rep movsb                   ; make empty room
            cld
        Pop edi
    Pop esi                                 ; adress of new string

L0: lodsb | cmp al 0 | je L9>
    stosb | jmp L0<                         ; write new string

L9: Mov al '"' | stosb
ret
______________________________________________________________________________________

ResetTemplateClass:
    Push edi
        Push esi                                                   ; > where to write
            Mov al 0, ecx 120, ebx 120 | repne scasb
            sub ecx 120 | neg ecx | Mov ebx ecx                    ; new string lenght
            add ebx 2                                              ; for ' 0'
            Mov edi D$NewDialogTemplateText, al 255, ecx MaxTemplateText
            repne scasb | Mov esi edi | add edi ebx                ; edi, esi ready for room
        Pop eax
        Push eax
            Mov ecx esi | sub ecx eax | dec edi
            std
                rep movsb                ; make empty room
            cld
        Pop edi
    Pop esi                              ; adress of new string set in edi by caller.

L0: lodsb | cmp al 0 | je L9>
    stosb | jmp L0<                      ; write new string

L9: Mov al '"' | stosb
    Mov ax ' 0' | stosw
ret

__________________________________________________________________________________

[LBbuffer: D$ ? # 30] ;[LBbufferLen 120]

ClearLBbuffer:
    Mov eax 0, ecx 30, edi LBbuffer | rep stosd
ret


WriteFontType:
    Call ClearLBbuffer
    Mov edi D$NewDialogTemplateText al 0, ecx MaxTemplateText
    repne scasb | repne scasb | repne scasb | repne scasb | repne scasb
    add edi 4
    Push edi
        Call StripTemplateText
        Call 'USER32.SendMessageA' D$TABLE.H.DialogControls  &CB_GETCURSEL  0  0
        Call 'USER32.SendMessageA' D$TABLE.H.DialogControls &CB_GETLBTEXT eax LBbuffer
    Pop esi
    Mov edi LBbuffer | Call ResetTemplateText
    Call FromTextToBinTemplate | Call ShowDialogResult | Call FillDialogListBox
ret
________________________________________________________________________________________
;;
 For some unknown reason, none of the usual working messages to retrieve text or
 value from an edit control (what work everywhere Else in this source) doesn't
 work with these boxes. So i have to use "WM_GETTEXT" instead, translate it to Bin,
 then to hexa, then to hexa text !!!!!!!!............ These Edit boxes no not seam to
 have a valid ID. They are created by:

     Call 'USER32.CreateWindowExA'  0  EditClass  0,
             WS_CHILD+WS_VISIBLE+WS_BORDER+ES_NUMBER+ES_RIGHT+ES_MULTILINE,
             80 D$esi+4  45 20, D$EDBPadressee 0 D$H.Instance 0

 ... just like any other ones...
;;

[DimIsForDialogWindow: D$ ?] ; used as +0 / +1 (true / false) to jump over n (number of controls)

WriteDimOnly:
    Push ecx                          ; edit control handle ( > edx )
        Call 'USER32.SendMessageA' ecx, &WM_GETTEXT, 0F, LBbuffer
    Pop edx
    Call SearchDialogLine           ; Edi is set there.
    Mov esi TABLE.H.DialogControls, ebx 1
    while D$esi <> edx | add esi 4 | inc ebx | End_While  ; search for what control
  ; 3 handles (text, edit, UpDown). So: 2 > 1   5 > 2   8 > 3   11 > 4
    shr ebx 1 | On ebx > 2, dec ebx
    add ebx D$DimIsForDialogWindow                       ; jump over n (number of controls)
    Mov al SPC
    While ebx > 0 | repne scasb | dec ebx | End_While    ; edi > dim to overwrite
    Push edi

      ; Translate decimal to binary (simplified version):
        Mov eax 0, ecx 0, esi LBbuffer
L2:     Mov cl B$esi | inc  esi              ; (eax used for result > no lodsb)
        cmp cl 0 | jbe  L9>
            Mov edx 10 | mul edx | sub  ecx '0'
            add  eax ecx | jmp  L2<          ; >>> number in EAX
L9:         Mov ebx eax
            add ebx D$ProposedUpDowmChange | Mov D$ProposedUpDowmChange 0
      ; Store text hexa at "DimTempo":
        Mov edi LBbuffer | Call TranslateDialogText8 | Mov al 0 | stosb
    Pop edi
    Mov eax '0000' | stosd | dec edi | Mov esi LBbuffer
    While B$esi+1 > 0 | inc esi | End_While
    std | Mov ecx 4
L0:     lodsb
        stosb | On esi < LBbuffer, jmp L9>
        loop L0<
L9: cld
ret

WriteDim:
    Call WriteDimOnly
    Call FromTextToBinTemplate | Call ShowDialogResult | Call FillDialogListBox
ret
__________________________________________________________________________________

WriteTitle:
    Call SearchDialogLine | inc edi        ; points to Class record
    Push edi
        Call StripTemplateText
        Call 'USER32.GetDlgCtrlID' D$TABLE.H.DialogControls
        Call 'USER32.GetDlgItemTextA' D$H.DialogEditor eax LBbuffer 100
                                        ; fix limit (100) here
                                        ; (sendmessage for text limitation doesn't work)
    Pop esi

    Mov edi LBbuffer | Call ResetTemplateText

    Call FromTextToBinTemplate | Call ShowDialogResult | Call FillDialogListBox
ret
_____________________________________________________________________________________

WriteID:
    Call SearchDialogLine

    Push edi
      Call 'USER32.GetDlgCtrlID' D$TABLE.H.DialogControls
      Call 'USER32.GetDlgItemInt' D$H.DialogEditor eax  0  0
    Pop edi

    Mov ebx eax, ecx 4  | On eax > 0, Mov W$PreviousControlID ax

L0: Mov eax ebx | and eax 0_F000 | shr eax 12
    add al '0' | On al > '9', add al 7
    shl ebx 4
    stosb | loop L0<

    Call FromTextToBinTemplate | Call ShowDialogResult | Call FillDialogListBox
ret
____________________________________________________________________________________

[DelMessage: B$ "

    To delete a control:

      Select any record in the control you want to delete.       
      Do not select a separator empty line.
      Do not select a Dialog box record.
    " EOS]

[Wahoo: B$ ' Whahooo!!!...' EOS]

OutDelOneControl:
    Call 'USER32.MessageBoxA' D$H.MainWindow, DelMessage, Wahoo, &MB_SYSTEMMODAL
ret


DelOneControl:
    Call 'USER32.SendMessageA' D$H.DialogList &LB_GETCURSEL eax 0
    Mov D$DialogListIndex eax

    .If D$DialogListIndex < Line_empty+1
        jmp OutDelOneControl

    .Else_If D$DialogListIndex > 0FFFF
        jmp OutDelOneControl

    .Else
        Call SearchDialogLine
        On B$edi = 0, jmp OutDelOneControl

        Mov al 0, ecx MaxTemplateText          ; edi > one record inside one control
        While B$edi > 0
            repne scasb
        End_While
        Mov esi edi | sub edi 2                ; esi > end of control records
        std
            While B$edi > 0
                repne scasb
            End_While
        cld
        add edi 2                              ; edi > start of control records

; If user delete some control before defining the ID, we reset the flag for new "Add":
        Push edi
            repne scasb | repne scasb
            On D$edi = '0000', Mov W$PreviousControlID 0FFFF  ; ID at +52 octets from start

            Mov al 255, edi esi | repne scasb  ; search for the end
            Mov ecx edi
        Pop edi | dec edi | sub ecx edi        ; ecx = lenght of data to Move upward
        rep movsb
        Call FromTextToBinTemplate | Call ShowDialogResult | Call FillDialogListBox

    .End_If
ret
____________________________________________________________________________________

; Called by Dialog Edition CallBack with buttons handles in ecx, controls table index in ebx:

ExitDialog:
    .If ebx = 0
        Call SaveClipDialog | Call CloseDialogEdition
    .Else_If ebx = 4
        If B$DialogLoadedFromResources = &TRUE
            Call SaveResourceDialog | Call CloseDialogEdition
        Else
            Call SaveNewResourceDialog | Call CloseDialogEdition
        End_If
        Mov D$FL.SourceHasChanged &TRUE
    .Else_If ebx = 8
       Call CloseDialogEdition |  Call SaveDialogToDisk
    .Else   ;_If ebx = 12
       Call CloseDialogEdition
    .End_If
ret

CloseDialogEdition:
    Call 'USER32.ClipCursor' &NULL
    Call UninstallHook
    Call 'USER32.EndDialog' D$H.DialogEditor 0
    Call 'USER32.DestroyWindow' D$H.EditedDialog
    Mov D$H.DialogEditor 0, D$H.EditedDialog 0
    Mov D$FL.DialogEdition &FALSE, B$DialogLoadedFromResources &FALSE
ret

_______________________________________________________________________________________
;;
 saving the template in ClipBoard. The main job is to make it clean and pretty source.
 (aligned comments, formated hexa numbers, ...). "B$InsideText" is used to know where
 to set leading hexa zeros (to preserve both texts and comments).
;;

[ClipTemplate: D$ ?
 ClipTemplateLength: D$ ?]

BuildDialogTemplate:

    Call VirtualAlloc ClipTemplate,
                      60_000

    Mov edi D$ClipTemplate , esi D$NewDialogTemplateText
    Mov al '[' | stosb
    Mov eax 'Dial' | stosd | Mov eax 'og: ' | stosd
    Mov ebx 0, edx 8, B$InsideText &FALSE

L0: lodsb
    ..If al = 0                                     ; line end:
        Mov edx 0
        .If B$esi = 0                               ; block end (dialog or control)
            inc esi
            Push edi
                std
                    Mov al ';', ecx 200 | repne scasb      ; write ']' before comment
                    Mov al SPC | repe scasb | add edi 2    ; search last non space char
                    Mov al ']' | stosb
                cld
            Pop edi
            Mov al CR, ah LF | stosw | stosw
            On B$esi = 255, jmp L9>>
            Mov al '[' | stosb
            Mov eax 'Cont' | stosd | Mov eax 'rol0' | stosd | dec edi
            Push ebx
                Call TranslateDialogText4
            Pop ebx
            inc ebx
            Mov ax ': ' | stosw | add edx 10
        .Else
            Mov al CR, ah LF | stosw | Mov al SPC | stosb
        .End_If
        Mov B$InsideText &FALSE

    ..Else
        .If al = '"'
            Mov al "'" | Mov B$InsideText &TRUE
        .End_If
        .If al <> '0'
            If al = ';'
                Mov ecx 30 | cmp edx 28 | ja L2>
                sub ecx edx | Mov al SPC | rep stosb
                Mov al ';', B$InsideText &TRUE
            End_If
            On B$InsideText = &TRUE, jmp L2>
            If B$esi <> '$'                         ; set a leading '0'
                cmp B$edi-1 SPC | jne L2>           ; for naked hexa
                cmp al '1' | jb L2>
                cmp al 'F' | ja L2>
                    Mov B$edi '0' | inc edi | inc edx  ; numbers (not before 'U$'/'D$')
            End_If
L2:         stosb | inc edx
        .Else
            If W$edi-2 <> ' 0'
                stosb | inc edx                     ; no double zeros for hexa numbers
            End_If
        .End_If

    ..End_If
    jmp L0<<

L9: sub edi D$ClipTemplate | Mov D$ClipTemplateLength edi
ret


SaveClipDialog:

    Push D$LP.BlockStartText,
         D$LP.BlockEndText,
         D$FL.BlockInside

        Call BuildDialogTemplate

        Move D$LP.BlockStartText D$ClipTemplate

L9:     Mov eax D$LP.BlockStartText | add eax D$ClipTemplateLength | sub eax (1*ASCII)

        Mov D$LP.BlockEndText eax

        Mov D$FL.BlockInside &TRUE | Call ControlC | Mov D$FL.BlockInside &FALSE

        Call VirtualFree ClipTemplate

        Mov B$InsideText &FALSE

    Pop D$FL.BlockInside,
        D$LP.BlockEndText,
        D$LP.BlockStartText

ret


[DlgFilesFilters: B$ 'RosAsm Dialog Template' EOS '*.dlgl' EOS 0]
[RcFilesFilters: B$ 'RosAsm RC Template' EOS '*.*' EOS, 0]
[SaveDlgFilter: B$ ? # &MAX_PATH]
[ChoosenDlgFile: B$ ? # &MAX_PATH]

[OpenDlg:
 @lStructSize: D$ len
 @hwndOwner: D$ 0
 @hInstance: D$ 0
 @lpstrFilter: D$ DlgFilesFilters
 @lpstrCustomFilter: D$ &NULL ; uFileFilter
 @nMaxCustFilter: D$ 0 ; &MAX_PATH
 @nFilterIndex: D$ 1
 @lpstrFile: D$ SaveDlgFilter
 @nMaxFile: D$ &MAX_PATH
 @lpstrFileTitle: D$ ChoosenDlgFile
 @nMaxFileTitle: D$ &MAX_PATH
 @lpstrInitialDir: D$ 0
 @lpstrTitle: D$ SaveDlgNameTitle
 @Flags: D$ &OFN_CREATEPROMPT+&OFN_EXPLORER+&OFN_HIDEREADONLY+&OFN_LONGNAMES+&OFN_NONETWORKBUTTON+&OFN_OVERWRITEPROMPT+&OFN_PATHMUSTEXIST
 ; 0281804
 ; &OFN_CREATEPROMPT__&OFN_EXPLORER__&OFN_HIDEREADONLY__&OFN_LONGNAMES
 ; &OFN_NONETWORKBUTTON__&OFN_OVERWRITEPROMPT__&OFN_PATHMUSTEXIST
 ;  0_2000
 ; 08_0000
 ;       4
 ; 20_0000
 ;  2_0000
 ;       2
 ;     800
 @nFileOffset: W$ 0
 @nFileExtension: W$ 0
 @lpstrDefExt: D$ 0
 @lCustData: D$ 0
 @lpfnHook: D$ 0
 @lpTemplateName: D$ 0]

;[OpenPEStruc: len
; hwndPEFileOwner: 0  OPESInstance: 0  PEFilesFilters  uFileFilter  260
; 1 SaveFilter  260  ChoosenFile  260  0
; OpenPEFileTitle  OpenPEStrucFlags: 0281804
; 0  0  0  0  0]

SaveDialogToDisk:
    Call BuildDialogTemplate

    Mov edi SaveFilter, eax 0, ecx 65 | rep stosd
    Mov D$SaveDlgFilter 'New.', D$SaveDlgFilter+3 '.dlg', D$SaveDlgFilter+7 0

    Call 'Comdlg32.GetSaveFileNameA' OpenDlg | On eax = &FALSE, jmp L9>>

    Call ForceExtension SaveDlgFilter, '.dlg'

    Call 'KERNEL32.CreateFileA' SaveDlgFilter &GENERIC_WRITE,
                               &FILE_SHARE_READ__&FILE_SHARE_WRITE, 0,
                               &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE

        Call MessageBox D$BusyFilePtr | jmp L9>>

    End_If

    Mov D$H.Destination eax, D$NumberOfReadBytes 0

    Call 'KERNEL32.WriteFile' D$H.Destination, D$ClipTemplate, D$ClipTemplateLength,
                              NumberOfReadBytes  0

    Call 'KERNEL32.CloseHandle' D$H.Destination | Mov D$H.Destination 0

L9: Call VirtualFree ClipTemplate

    Mov B$InsideText &FALSE

ret


Proc ForceExtension:
    Argument @FileName, @Ext

        Mov eax D@FileName, ebx D@Ext
        While B$eax <> 0 | inc eax | End_While | sub eax 4

        ..If D$eax <> ebx
            .If B$eax = '.'
L1:             Mov D$eax ebx, B$eax+4 0
            .Else
                If B$eax+1 = '.'
                    inc eax | jmp L1<
                Else_If B$eax+2 = '.'
                    add eax 2 | jmp L1<
                Else_If B$eax+3 = '.'
                    add eax 3 | jmp L1<
                Else
                    add eax 4 | jmp L1<
                End_If
            .End_If
        ..End_If
EndP

; Reuse of the ClipBoard Naming because reuse of the Routine for Loading from ClipBoard.

OpenDlgFile:
    Mov D$OtherFilesFilters DialogFilesFilters
    Mov D$OpenOtherFileTitle DialogFilesTitle

    Move D$OtherhwndFileOwner D$H.MainWindow, D$OtherhInstance D$H.Instance

    Mov edi OtherSaveFilter, ecx 260, eax 0 | rep stosd
    Call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc

    If D$OtherSaveFilter = 0
        Pop eax | ret
    End_If

    Call 'KERNEL32.CreateFileA' OtherSaveFilter &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE

      Call MessageBox D$BusyFilePtr

    Pop eax

ret  ; return to caller of caller

    Else
      Mov D$H.OtherSource eax
    End_If

    Call 'KERNEL32.GetFileSize'  eax 0 | Mov D$ClipBoardLen eax

    If eax > 0

        Call VirtualAlloc ClipBoardPTR,
                          eax

        Mov eax D$ClipBoardPTR | add eax D$ClipBoardLen | Mov D$ClipBoardEnd eax


        Call 'KERNEL32.ReadFile' D$H.OtherSource D$ClipBoardPTR,
                                 D$ClipBoardLen NumberOfReadBytes 0
    End_If

    Call 'KERNEL32.CloseHandle' D$H.OtherSource
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[argh: B$ 'Arghhh!!!...' EOS]

[ClipBoardEnd: D$ ?
 OnClipDialog: D$ ?]
___________________________________________________________________________________
;;
 Saving the template for .rsrc:

 'DialogList' table holds the records for each Dialog resource (ID / Ptr / Size). This
 table is used at building time by 'TemporaryFillRsrcList' to prepare the Resource tree
 construction.
;;

SearchLenghtOfDialogData:
    Mov ebx D$LastDialogListItem, esi D$EditedDialogBoxData
    inc ebx                                     ; ex: 7+7+7+6 (last line not account)
    lodsd | lodsd                               ; styles
    lodsw | lodsw | lodsw | lodsw | lodsw       ; n, X, Y, W, H
    lodsw                                       ; menu?
    On ax > 0, lodsw                            ; menu ID
    lodsw                                       ; class? > 0 for edition

    Mov edi esi
        Mov ax 0, ecx 200 | repne scasw | repne scasw   ; title / font
    Mov esi edi

    sub ebx Line_empty+1
    while ebx > 0
        test esi 00_11 ZERO L1>
            lodsw                               ; align
L1:     lodsd | lodsd                           ; styles
        lodsw | lodsw | lodsw | lodsw           ; X, Y, W, H
        lodsw | lodsw                           ; ID / Class
        If ax <> 0FFFF
            Mov edi esi
                Mov ax 0, ecx 200 | repne scasw ; Text form Class (zero ended)
            Mov esi edi
        End_If
        Mov edi esi
            Mov ax 0, ecx 200 | repne scasw     ; title
        Mov esi edi
        lodsw

        sub ebx Line_empty+1
    End_While

    Mov ecx esi | sub ecx D$EditedDialogBoxData ; lenght of dialog data

    Mov esi ClassRecord
    While B$esi > 0
        lodsb | add ecx 2
    End_While
ret


[WhatDialogIDData: D$ 090C408C2 0  ; Style
 U$ 03 0 0 09C 01A             ; Dim
 0                             ; Menu
 0                             ; Class
 'Give an ID number for this Dialog' 0 ; Title
 08 'Helv' 0]                  ; Font

[@WDIDC1: D$ 050042000 0        ; Style
 U$ 02A 05 049 0F              ; Dim
 0DE                           ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data

[@WDIDC2: D$ 050000001 0        ; Style
 U$ 075 05 023 0E              ; Dim
 0DF                           ; ID
 0FFFF 080                     ; Class
 'OK' 0                        ; Title
 0]                            ; No creation data

[@WDIDC3: D$ 050000000 0        ; Style
 U$ 03 05 024 0F               ; Dim
 0E0                           ; ID
 0FFFF 080                     ; Class
 'Abort' 0                     ; Title
 0]                            ; No creation data


[OK_ID 0DF  IDNumberEdit 0DE  Abort_ID 0E0]


[EIDNMessage: B$ "

    Dialog ID numbers can't be greater than 0FFFF (65535)    

" EOS]


ErrorIDnumber:
    Call 'USER32.MessageBoxA' D$H.MainWindow, EIDNMessage, Wahoo, &MB_SYSTEMMODAL
ret


[UserAbortID: D$ ?]
[IDstring: B$ '        ' EOS]

Proc WhatDialogIdProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_INITDIALOG
        Mov B$UserAbortID &FALSE
        Call 'USER32.GetDlgItem' D@hwnd, IDNumberEdit
        Push eax
            Call 'USER32.SendMessageA' eax, &EM_SETLIMITTEXT, 5, 0
        Pop eax
        If B$DialogLoadedFromResources = &TRUE
            Mov eax D$WhatDialogListPtr, edi IDString, ebx 10          ; translate ID to
            sub eax 4 | Mov eax D$eax
            add edi 9                                                    ; decimal text
L0:         Mov edx 0 | div ebx
            dec edi | add dl '0' | Mov B$edi dl | cmp eax 0 | ja L0<
            Call 'USER32.SetDlgItemTextA' D@hwnd, IDNumberEdit, edi

        Else
            Mov esi DialogList
            While D$esi+12 > 0
                add esi 12
            End_While
            Mov D$DialogListPtr esi | On D$esi <> 0, add D$DialogListPtr 12

            lodsd | add eax 10
            Mov edi IDString, ebx 10 | add edi 9 | jmp L0<
        End_If

        Call 'USER32.SetClassLongA' D@hwnd, &GCL_HICON, D$STRUC.WINDOWCLASS@hIcon

    ...Else_If D@msg = &WM_COMMAND
        ..If W@wParam = OK_ID
            Call 'USER32.GetDlgItemInt' D@hwnd, IDNumberEdit, 0, 0

            .If eax > 0FFFF
                Call ErrorIDnumber
            .Else
                If B$DialogLoadedFromResources = &FALSE
                    Push eax
                        Call CheckNotUsedId eax, D@hwnd
                    Pop ebx
                    On eax = &IDCANCEL, jmp L5>
                    Mov eax ebx
                End_If

                If B$DialogLoadedFromResources = &TRUE
                    Mov edi D$WhatDialogListPtr | sub edi 4 | stosd
                Else
                    Mov edi D$DialogListPtr | stosd | add D$DialogListPtr 4
                End_If
                Call 'USER32.EndDialog' D@hwnd, 0
            .End_If

        ..Else_If W@wParam = Abort_ID
            Mov B$UserAbortID &TRUE
            Call 'USER32.EndDialog' D@hwnd, 0
        ..End_If

    ...Else
        popad | Mov eax &FALSE | jmp L9>

    ...End_If

L5: popad | Mov eax &TRUE

L9: EndP
____________________________________________________________________________________________
;;
 this does only save temporary a resource template in a fitting memory. It will
 remain there until compile time fills the resource tree. "ExitDialog" clear the
 editions chunks of memory. "ReleaseResourceDialogMemory" will be called by "MainWindowProc"
 exit case
;;

SaveNewResourceDialog:
    Call SearchLenghtOfDialogData
    Push ecx

        Call VirtualAlloc TempoMemPointer,
                          ecx                  ; new memory for dialog data

        Call 'USER32.DialogBoxIndirectParamA' D$H.Instance,
               WhatDialogIDData, 0, WhatDialogIdProc, 0 ; write ID in list <<<<<<<<

        If B$UserAbortID = &TRUE
            Call VirtualFree TempoMemPointer

Pop eax, eax  | ret                 ; return to caller of 'ExitDialog'

        End_If

        Mov eax D$TempoMemPointer
        Mov edi D$DialogListPtr | stosd         ; write ptr to data in list <<<<<<<<
        add D$DialogListPtr 4
        Mov edi eax                             ; ready for fill
    Pop ecx
    Mov esi D$DialogListPtr | Mov D$esi ecx     ; write size in list <<<<<<<<
    add D$DialogListPtr 4
    Call SaveDialogDataToResources
ret

____________________________________________________________________________________________
; In with ecx = Length as given by 'SearchLenghtOfDialogData'.
;         edi = Ptr to a Mem in DialogList.

SaveDialogDataToResources:
    Mov esi D$EditedDialogBoxData

    movsd | movsd                           ; Style / Ext.Style

    movsw | movsw | movsw | movsw | movsw   ; n / X / Y / W / H

    lodsw                                   ; +2 for '0' menu in edition

    sub ecx 20                              ; >>> 20 Bytes read / 18 Bytes written

    If D$DialogMenuTrueID = 0
        stosw                               ; '0' menu
    Else
        Mov eax 0FFFF | stosw
        Mov eax D$DialogMenuTrueID | stosw  ; See comments at 'DialogMenuComment'
    End_If

    lodsw
    Push esi
        Mov esi ClassRecord, eax 0
        Do
            lodsb | stosw                   ; write preserved Class
        loop_Until al = 0
    Pop esi
    sub ecx 2

    Do
        lodsw | stosw | sub ecx 2           ; write Title
    loop_Until ax = 0

    Do
        lodsw | stosw | sub ecx 2           ; write Font
    loop_Until ax = 0

;;
    Now, if edi is un-aligned, we have to align for the next Control.

    But: If esi is also un-aligned, the required alignement has already be done previously
        (at least for viewing the Dialog, when Editing). So:

    * esi un-aligned // edi un-aligned  >>> do nothing.
    * esi aligned    // edi aligned     >>> do nothing.
    * esi unaligned  // edi aligned     >>> kill previous alignment.
    * esi aligned    // edi un-aligned  >>> do the alignment.

   (The difference between esi and edi may come from addition of the Class
    Record, which is cleared off from the 'EditedDialogBoxData' for edition).
;;
    jecxz L9>

    Mov eax esi, ebx edi | and eax 00_11 | and ebx 00_11
    .If eax <> ebx
        If eax = 0
            Mov W$edi 0 | add edi 2
        Else
            lodsw | sub ecx 2 | jecxz L9>
        End_If
    .End_If

    rep movsb                               ; Write all Controls at once.
L9: ret

____________________________________________________________________________________________


SaveResourceDialog:

    Call 'USER32.DialogBoxIndirectParamA' D$H.Instance,
                                          WhatDialogIDData,
                                          0,
                                          WhatDialogIdProc,
                                          0   ; write ID in list <<<<<<<<

    If B$UserAbortID = &TRUE

          Pop eax | ret

    End_If

    Mov eax D$WhatDialogListPtr, eax D$eax

    Call VirtualFree eax                                     ; free previous mem ptr in List

    Call SearchLenghtOfDialogData

    Push ecx

        Call VirtualAlloc TempoMemPointer,
                          ecx

        Mov eax D$TempoMemPointer

        Mov edi D$WhatDialogListPtr | stosd             ; write ptr to data in list <<<<<<<<

        Mov edi eax                                     ; ready for fill

    Pop ecx

    Mov esi D$WhatDialogListPtr | add esi 4

    Mov D$esi ecx                                       ; write size in list <<<<<<<<

    Call SaveDialogDataToResources
ret

ReleaseResourceMemory:

    ; All Lists are: ID / Pointer to Mem / Size  ???/!!!
    ; MEM_LP / MEM_CHUNK_SIZE / MEM_MOTHER_LP

;        Mov edx MenuList,
;            D$MenuListPtr MenuList

;        Call ReleaseOneResourceMemory ; TODO à traiter

    Mov edx DialogList,
        D$DialogListPtr DialogList

    Call ReleaseOneResourceMemory

    Mov edx IconList,
        D$IconListPtr IconList

    Call ReleaseOneResourceMemory

    Mov edx GroupIconList,
        D$GroupIconListPtr GroupIconList

    Call ReleaseOneResourceMemory

    Mov edx CursorList,
        D$CursorListPtr CursorList

    Call ReleaseOneResourceMemory

    Mov edx GroupCursorList,
        D$GroupCursorListPtr GroupCursorList

    Call ReleaseOneResourceMemory

    Mov edx BitMapList,
        D$BitMapListPtr BitMapList

    Call ReleaseOneResourceMemory

    Mov edx WaveList,
        D$WaveListPtr WaveList

    Call ReleaseOneResourceMemory

    Mov edx AviList,
        D$AviListPtr AviList

    Call ReleaseOneResourceMemory

    Mov edx RcDataList,
        D$RcDataListPtr RcDataList

    Call ReleaseOneResourceMemory

    Push edi

        Mov edi uRsrcList,
            D$uRsrcListPtr edi,
            ecx 1000

        ; Clear uRsrcList
        xor eax eax | rep | stosd

    pop edi

ret

ReleaseOneResourceMemory:

L1: Test D$edx NA ZERO S1>   ; ID

        Mov D$edx &NULL       ; Clear BitMapList table

        Call VirtualFree D$edx+4 ; ptr

        Mov D$edx+8 &NULL

    jmp L1< ; size

S1:

ret
____________________________________________________________________________________

; 'NamedIdList' Records are: [NumberID / StringLength with 2 "'" / 'String'] / [...] / ...

[NamedIdList: D$ ?]

;;
  1) Search the Data 'Name'
  2) Get Back and read the Data Label
  3) Replace all Evocations of this Label by the Direct Numbered ID
;;
NamedIdSubstitution:  ; 'SymbolicAnalyzes' 'FRproc' 'StringReplaceAll'
    ...If D$NamedIdList <> 0
        Mov esi D$NamedIdList
        Mov B$DownSearch &TRUE, B$CaseSearch &FALSE, B$SilentSearch &TRUE

        ..While D$esi <> 0
          ; Create a Copy of the NumberID in Text form:
            lodsd | Mov edi ReplaceWithString | Call WriteEax | Mov B$edi 0

          ; Copy the User Source IDName into the 'SearchString' Buffer:
            lodsd | Mov D$LenOfSearchedString eax, ecx eax
            Mov edi SearchString | rep movsb | Mov al 0 | stosb

          ; esi ready for next Record:
            add esi ebx
            Push esi
                Mov D$NextSearchPos 0
                Move D$STRUCT.EditData@CurrentWritingPos D$CodeSource
                Call StringSearch
                ..If D$FL.BlockInside = &TRUE
                  ; The Text of the IdName has been found. Search back for the Data Label:

                    Mov esi D$LP.BlockStartText

                    While D$esi <> 'Data' | dec esi | End_While

                  ; Copy the 'DATAXXXXXX' into the 'SearchString' Buffer:
                    Mov edi SearchString, ecx 0
                    While B$esi <> ':' | movsb | inc ecx | End_While | Mov al 0 | stosb
                    Mov D$LenOfSearchedString ecx

                  ; Search Evocations of 'DATAXXXXXX', replace by the ID Number Text:
L0:                 Call StringSearch

                    If D$FL.BlockInside = &TRUE

                        Mov eax D$LP.BlockEndText

                        On B$eax+1 <> ':', Call IDReplace

                        jmp L0<

                    End_If

                ..End_If

            Pop esi

        ..End_While

        Call VirtualFree NamedIDList

    ...End_If

ret


IDReplace:
    Mov esi ReplaceWithString, edi D$LP.BlockStartText

    While B$esi <> 0 | movsb | End_While
    While B$edi > SPC | Mov B$edi SPC | inc edi | End_While
ret
 ______________________________________

  ; resource TYPEs dir:

  ; Resources (ID / Ptr / Size)

; in: ebx = Prt variable to a List (DialogListPtr, MenuListPtr, ...)
; (ebx is the adress, not the value -we Move it in here-)
; edx is the Number of Resources in a Type

ReadResourcesRecord:
    lodsd | and eax 0FFFF | Mov edi D$ebx | stosd   ; Write ID.
    Mov D$ebx edi                                   ; Adjust D$XxxxxxListPtr.
    lodsd                                  ; "Level3Rt_Menu-StartOfRsrc+NodeFlag" in eax

    Push esi, edx
        test eax 08000_0000 NOT_ZERO L1>
            add eax D$UserPEStartOfResources | Mov esi eax | jmp L5>>

L1:     and eax 0FFFFFFF | add eax D$UserPEStartOfResources | add eax 20 | Mov esi eax
      ; Language. dir:
        lodsd                    ; "Level4Rt_Menu-StartOfRsrc" in eax (no NodeFlag here
                                 ; next one is leafe ptr to true resources)
        add eax D$UserPEStartOfResources
        Mov esi eax

      ; Records of each resource:
L5:     lodsd                                   ; ptr to menu data (but RVA - startOfResource)
L1:     Mov ecx D$esi
        sub eax D$ResourcesRVA                  ; - RVA
        add eax D$UserPEStartOfResources        ; eax now points to true menu data

        If eax < D$UserPeStart
            jmp DisFail
        Else_If eax > D$UserPeEnd
            jmp DisFail
        End_If

        Push eax

            Call VirtualAlloc TempoMemPointer,
                              ecx

        Pop esi

        Mov edi D$TempoMemPointer
        Push edi, ecx
            rep movsb                           ; copy bin template to temporary mem
        Pop ecx, eax

        Mov edi D$ebx | stosd
        Mov eax ecx | stosd | Mov D$ebx edi

    Pop edx, esi
    dec edx | cmp edx 0 | ja ReadResourcesRecord; next resource TYPEs dir record > ID ready
L9: Mov eax &TRUE
ret
_____________________________________________________________________________________
;;
 All routines for dialog edition are first based on text version of templates. Here,
 we got first a bin template > translation back to text needed. All dialog resources
 have been uploaded in memories chuncks stored in "DialogList" (/ID/Ptr/Size). The
 Naming "LoadFromResouce" is only to echoe what user clicked on in main menu, but,
 in fact, upload job was previously done by "ReadRosAsmPeDialogs" when file is open.
 We now simply translate to text version before runing edition:
;;

[NoResourceDialog: B$ "

    There is no Resources Dialog in this PE      

" EOS]

LoadFromResources:
    If D$FL.DialogEdition = &TRUE
        Call Beep | ret  ; prevents from multi-runs
    End_If
    Call InitDialogMemory

    Mov esi DialogList
    .If D$esi  = 0                    ; empty? > out
        Call 'USER32.MessageBoxA' D$H.MainWindow, NoResourceDialog, Argh, &MB_SYSTEMMODAL | ret

    .Else_If D$esi+12 = 0               ; only one resource? > OK
        Mov D$WhatDialogListPtr DialogList+4

        Mov ebx D$WhatDialogListPtr, ebx D$ebx
        If W$ebx+18 = 0
            Mov D$ActualMenutestID 0, D$DialogMenuTrueID 0
        Else
            movzx eax W$ebx+20 | Mov D$DialogMenuTrueID eax
            Mov esi MenuList
            While D$esi <> eax
                add esi 12
            End_While
            Mov D$MenuListPtr esi
            add esi 4
            Call 'USER32.LoadMenuIndirectA' D$esi | Mov D$ActualMenutestID eax
        End_If

    .Else                               ; several resources? > wich one?
        Mov D$H.DialogList 0, D$H.DialogEditor 0
        Call WhatResourceTemplate       ; > D$WhatDialogListPtr > Data pointer

    .End_If

    Mov B$DialogLoadedFromResources &TRUE
    Call FromBinToTextTemplate
    Call ReInitDialogEdition
ret

____________________________________________________________________________________________

; The following routines have been rewritten to loose the dependency on the old routines.
; They are not rewritten in an intelligent way. They are just rewritten so they will do
; exactly the same thing as before (no matter how stupid that was/is).
____________________________________________________________________________________________

[DialogFromFile: D$ ?]

LoadDialogFromFile:
    If D$FL.DialogEdition = &TRUE
        Call Beep | ret
    End_If

    Mov B$DialogFromFile &TRUE

    Call InitDialogMemory

    Call OpenDlgFile | jmp L0>


LoadDialogFromClipBoard:
    If D$FL.DialogEdition = &TRUE
        Call Beep | ret
    End_If

    Mov B$DialogFromFile &FALSE

    Call InitDialogMemory

    Call OpenClipBoard


L0: On D$ClipBoardPtr = 0, ret
    On D$ClipBoardlen = 0, ret

    Mov B$WeAreInTheCodeBox &TRUE
    Mov eax esp, D$OldStackPointer eax

    Push D$CodeSourceA, D$CodeSourceB

        Mov ecx D$ClipBoardlen | add ecx 010

        Call VirtualAlloc CodeSourceA,
                          ecx

        add D$CodeSourceA 010

        Mov ecx D$ClipBoardlen | add ecx 010

        Call VirtualAlloc CodeSourceB,
                          ecx

        add D$CodeSourceB 010

        Call NewCopyToCodeSourceA D$ClipBoardPtr, D$ClipBoardlen

        If B$DialogFromFile = &TRUE

            Call VirtualFree ClipBoardPTR

        Else
            Call CloseClipBoard
        End_If

        Mov esi D$CodeSourceA | While B$esi > 0 | inc esi | End_While
        Mov W$esi CRLF | add esi 2 | add D$StripLen 2

        Call ClearQwordCheckSum

        Call CoolParsers

        Call NewCountStatements | On D$FL.CompileErrorHappend = &TRUE jmp L9>>

        Call HotParsers | On D$FL.CompileErrorHappend = &TRUE jmp L9>>

        Call InitIndex1 | Call InitIndex2

        Exchange D$CodeSourceA D$CodesourceB

        Push D$SourceLen
            Move D$SourceLen D$StripLen
            Move D$AsmTablesLength D$SourceLen
            Call ReuseSourceAForCodeList
        Pop D$SourceLen

        ;Call ClearQwordCheckSum

        Call InitIndex3

        Call SaveCheckSumTable

        Mov eax D$CodeListPtr | Mov D$DataList eax | Mov D$DataListPtr eax
        Call StoreDatas

        Call RestoreCheckSumTable

L9:     Mov B$WeAreInTheCodeBox &FALSE | On D$FL.CompileErrorHappend = &TRUE jmp L9>>

        Mov B$OnClipDialog &TRUE

        Mov esi D$DataList, edi D$NewDialogTemplateText, D$ActualEditedDialogID 0
        Mov eax D$DataListPtr | sub eax D$DataList | inc eax
        Mov D$ResourceDialogSize eax

        .If W$esi+18 = 0FFFF
            movzx eax W$esi+20 | Mov D$DialogMenuTrueID eax
            Push esi
                Mov esi MenuList
                While D$esi <> eax
                    add esi 12
                    If D$esi = 0
                        Pop esi | Call NoSuchMenu | jmp L9>
                    End_If
                End_While
            Pop esi
        .End_If

        Call FromClipBoardBinToText | Call ReInitDialogEdition

L9:     Call VirtualFree CodeSourceA

        Call VirtualFree CodeSourceB

    Pop D$CodeSourceB, D$CodeSourceA

ret
____________________________________________________________________________________________

[NoMenuMessage: B$ "
This Dialog Template cannot be loaded because it    
includes a Menu that is not found in the actual
Resources.

                            Menu"

MissingMenuID: B$ "         " EOS]

NoSuchMenu:
    Call WriteDecimalID eax, MissingMenuID
    Call 'USER32.MessageBoxA' D$H.MainWindow, NoMenuMessage, Argh, &MB_OK
ret
____________________________________________________________________________________________


[WhatDialogListPtr: D$ ?
 OkDialogFlag: D$ ?
 H.ChoiceDialog: D$ ?]

WhatResourceTemplate:
  ; 'DialogList' structure is (dWords): ID / Ptr / Size // ...
  ; D$WhatDialogListPtr >>> Ptr to Dialog Mem in the form of 'DefaultDialogTemplateText').
    Mov D$OkDialogFlag &FALSE, D$WhatDialogListPtr DialogList+4
    .While B$OkDialogFlag = &FALSE

        Mov ebx D$WhatDialogListPtr, ebx D$ebx
        If W$ebx+18 = 0
            Mov D$ActualMenutestID 0, D$DialogMenuTrueID 0
        Else
          ; If Menu, W$ebx+18 = 0FFFF // W$ebx+20 = ID Number.
            movzx eax W$ebx+20 | Mov D$DialogMenuTrueID eax
            Mov esi MenuList
            While D$esi <> eax
                add esi 12
            End_While
            Mov D$MenuListPtr esi | add esi 4
            Call 'USER32.LoadMenuIndirectA' D$esi | Mov D$ActualMenutestID eax
        End_If

        Call FromBinToTextTemplate | Call FromTextToBinTemplate

        Call 'USER32.CreateDialogIndirectParamA' D$H.Instance, D$EditedDialogBoxData,
                                                 D$H.EditWindow, EditedDialogBoxProc, 0
        Mov D$H.ChoiceDialog eax

        Call SetNextChoiceID
        Call 'USER32.DialogBoxIndirectParamA' D$H.Instance, ChoiceBar, D$H.MainWindow, ChoiceDialogBoxProc, DialogList
      ; This is the deletion of the viewed Dialog (not of the Choice Bar Dialog):
        Call 'USER32.EndDialog' D$H.ChoiceDialog 0

        .If B$OkDialogFlag = &VK_ESCAPE
            Pop eax | ret                          ; abort "LoadFromResources" caller
        .Else_If D$WhatDialogListPtr < DialogList
            Mov D$WhatDialogListPtr DialogList+4
            Call SetNextChoiceID
        .Else
            Mov esi D$WhatDialogListPtr
            If D$esi = 0
                sub D$WhatDialogListPtr 12 | Mov esi D$WhatDialogListPtr
                Call SetNextChoiceID
            End_If
        .End_If
    .End_While
ret
____________________________________________________________________________________________
;                       _______   _______   _______
; The tool:            [  <<<  ] [  OK   ] [  >>>  ]       at 'ChoiceBar'
;                       -------   -------   -------

[H.ChoiceDialogBox: D$ ?]

SetNextChoiceID:
L1: Mov eax D$WhatDialogListPtr, eax D$eax-4
    Mov ecx 10, edi ChoiceDecimalID+10, D$edi 0200020, D$edi+4 0200020,
    D$edi+8 0200020, D$edi+12 0200020
    add edi 18
L2: Mov edx 0 | div ecx | dec edi | add dl '0'
    Mov B$edi 0 | dec edi | Mov B$edi dl | cmp eax 0 | ja L2<
ret

[ListOrigin: D$ ?]
Proc ChoiceDialogBoxProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_COMMAND
        Mov eax D@wParam | and eax 0FFFF
        .If eax = CHOICEFORTH
            add D$WhatDialogListPtr 12 | Call SetNextChoiceID

        .Else_If eax = CHOICEBACK
            sub D$WhatDialogListPtr 12 | Call SetNextChoiceID

        .Else_If eax = CHOICEFIRST
            Move D$WhatDialogListPtr D$ListOrigin  ;DialogList+4 |
            add D$WhatDialogListPtr 4
            Call SetNextChoiceID

        .Else_If eax = CHOICELAST
L0:         add D$WhatDialogListPtr 12 | Mov eax D$WhatDialogListPtr
            cmp D$eax 0 | ja L0<
            sub D$WhatDialogListPtr 12 | Call SetNextChoiceID

        .Else_If eax = CHOICEOK
            Mov B$OkDialogFlag &TRUE

        .Else_If eax = &IDCANCEL
            Mov B$OkDialogFlag &VK_ESCAPE

        .Else
            jmp L8>>
        .End_If

        Mov D$H.ChoiceDialogBox 0
        Call 'USER32.EndDialog' D@hwnd 0

    ...Else_If D@msg = &WM_INITDIALOG
        Move D$H.ChoiceDialogBox D@hwnd, D$ListOrigin D@lParam

        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        Call 'USER32.GetWindowPlacement' D@hwnd Control
        Mov eax D$Control@rcNormalPosition.top | shr eax 2
        add D$Control@rcNormalPosition.top eax
        add D$Control@rcNormalPosition.bottom eax
        Call 'USER32.SetWindowPlacement' D@hwnd Control

    ...Else
        If D$H.ChoiceDialogBox <> 0
            Call 'USER32.GetFocus'
            On eax <> D@hwnd, Call 'USER32.SetForegroundWindow' D@hwnd
        End_If
        popad | Mov eax &FALSE | jmp L9>

    ...End_If

L8: popad | Mov eax &TRUE

L9: EndP

[SureDeleteDialog: B$ 'Kill this Dialog?' EOS]

DeleteDialog:
    If D$FL.DialogEdition = &TRUE
        Call Beep | ret                    ; prevents from multi-runs
    End_If
    Call InitDialogMemory
    Mov esi DialogList
    .If D$esi  = 0                                          ; empty? > out
        Call 'USER32.MessageBoxA' D$H.MainWindow, NoResourceDialog, Argh, &MB_SYSTEMMODAL | ret
    .Else                                                   ; Wich resources to kill?
        Call WhatResourceTemplate
    .End_If
    Mov eax D$WhatDialogListPtr
    Call 'USER32.CreateDialogIndirectParamA' D$H.Instance, D$eax, D$H.MainWindow, EditedDialogBoxProc 0
        Mov D$H.ChoiceDialog eax

    Call 'USER32.MessageBoxA' D$H.MainWindow, SureDeleteDialog, Argh, &MB_SYSTEMMODAL+&MB_YESNO
    Push eax
        Call 'USER32.DestroyWindow' D$H.ChoiceDialog
    Pop eax

    If eax = &IDYES
        sub D$WhatDialogListPtr 4                       ; > ID / Ptr /Size
        Mov esi D$WhatDialogListPtr, edi esi
        add esi 12
        Mov eax esi | sub eax DialogList | shr eax 2

        Mov ecx MAXDIALOG | sub ecx eax                 ; tail to Move
        rep movsd                                       ; scratch
    End_If

    Call VirtualFree NewDialogTemplateText

    Call VirtualFree EditedDialogBoxData
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

SimplyGetDialog:
    Call InitDialogMemory

    Mov esi DialogList
    If D$esi  = 0
        Call 'USER32.MessageBoxA' D$H.MainWindow, NoResourceDialog, Argh, &MB_SYSTEMMODAL
        Mov eax 0 | ret
    Else
        Call WhatResourceTemplate
    End_If
ret


SaveToBinaryFile:
  ; Prevent from Multiple Instances:
    If D$FL.DialogEdition = &TRUE
        Call Beep | ret
    End_If

    Call SimplyGetDialog | On B$OkDialogFlag = &VK_ESCAPE, ret

  ; Similar to SaveDialogToDisk:

    Mov edi SaveFilter, eax 0, ecx 65 | rep stosd
    Mov D$SaveDlgFilter 'New.', D$SaveDlgFilter+3 '.dlf', D$SaveDlgFilter+7 0

    Call 'Comdlg32.GetSaveFileNameA' OpenDlg | On eax = &FALSE, ret

    Call ForceExtension SaveDlgFilter, '.bdf'

    Call 'KERNEL32.CreateFileA' SaveDlgFilter &GENERIC_WRITE,
                               &FILE_SHARE_READ__&FILE_SHARE_WRITE, 0,
                               &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0

    If eax = &INVALID_HANDLE_VALUE

        Call MessageBox D$BusyFilePtr

ret

    End_If

    Mov D$H.Destination eax, D$NumberOfReadBytes 0

    Mov esi D$WhatDialogListPtr | sub esi 4 | Mov ecx D$esi+8, esi D$esi+4

    Call 'KERNEL32.WriteFile' D$H.Destination, esi, ecx, NumberOfReadBytes  0

    Call 'KERNEL32.CloseHandle' D$H.Destination | Mov D$H.Destination 0
ret


[BinDialogMemory: D$ ?
 BinDialogLength: D$ ?]

LoadFromBinaryFile:
    If D$FL.DialogEdition = &TRUE
        Call Beep | ret
    End_If

    Mov D$OtherFilesFilters BinDialogFilesFilters
    Mov D$OpenOtherFileTitle DialogFilesTitle

    Move D$OtherhwndFileOwner D$H.MainWindow, D$OtherhInstance D$H.Instance

    Mov edi OtherSaveFilter, ecx 260, eax 0 | rep stosd
    Call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc

    On D$OtherSaveFilter = 0, ret

    Call 'KERNEL32.CreateFileA' OtherSaveFilter &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE

      Call MessageBox D$BusyFilePtr

ret  ; return to caller of caller

    Else
      Mov D$H.OtherSource eax
    End_If

    Call 'KERNEL32.GetFileSize' eax, 0 | Mov D$BinDialogLength eax

    If eax > 0

        Call VirtualAlloc BinDialogMemory,
                          eax


        Call 'KERNEL32.ReadFile' D$H.OtherSource, D$BinDialogMemory,
                                 eax, NumberOfReadBytes, 0
    Else
        ret
    End_If

    Call 'KERNEL32.CloseHandle' D$H.OtherSource

    Mov esi DialogList | While D$esi <> 0 | add esi 12 | End_While
    Mov D$DialogListPtr esi
    Mov eax D$BinDialogMemory, D$esi+4 eax
    Mov eax D$BinDialogLength, D$esi+8 eax

    Mov B$DialogLoadedFromResources &FALSE
    Call 'USER32.DialogBoxIndirectParamA' D$H.Instance, WhatDialogIDData, 0,
                                          WhatDialogIdProc, 0

    If B$UserAbortID = &TRUE
        Mov esi DialogList | While D$esi+4 <> 0 | add esi 12 | End_While
        Mov D$esi-4 0, D$esi-8 0, D$esi-12 0

        Call VirtualFree BinDialogMemory

    End_If

ret


ReplaceFromBinaryFile:
    If D$FL.DialogEdition = &TRUE
        Call Beep | ret
    End_If

    Call SimplyGetDialog | On B$OkDialogFlag = &VK_ESCAPE, ret

    Mov D$OtherFilesFilters BinDialogFilesFilters
    Mov D$OpenOtherFileTitle DialogFilesTitle

    Move D$OtherhwndFileOwner D$H.MainWindow, D$OtherhInstance D$H.Instance

    Mov edi OtherSaveFilter, ecx 260, eax 0 | rep stosd
    Call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc

    On D$OtherSaveFilter = 0, ret

    Call 'KERNEL32.CreateFileA' OtherSaveFilter &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE

      Call MessageBox D$BusyFilePtr

ret  ; return to caller of caller

    Else
      Mov D$H.OtherSource eax
    End_If

    Call 'KERNEL32.GetFileSize' eax, 0 | Mov D$BinDialogLength eax

    If eax > 0

        Call VirtualAlloc BinDialogMemory,
                          eax


        Call 'KERNEL32.ReadFile' D$H.OtherSource, D$BinDialogMemory,
                                 eax, NumberOfReadBytes, 0
    Else
        ret
    End_If

    Call 'KERNEL32.CloseHandle' D$H.OtherSource

    Mov edi D$WhatDialogListPtr | sub edi 4

    lea eax D$edi+4 | Call VirtualFree eax

    Mov eax D$BinDialogMemory, D$edi+4 eax

    Mov eax D$BinDialogLength, D$edi+8 eax

ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[CHOICEBACK 0136  CHOICEOK 01  CHOICEFORTH 0138  CHOICEID 010   CHOICEFIRST 037
 CHOICELAST 038]

[ChoiceBar: D$ 0900408C2 0        ; Style
 U$ 06 0 0 0C7 017             ; Dim
 0                             ;      no Menu
 '' 0                          ; Class
 'New Dialog' 0                ; Title
 08 'Helv' 0]                  ; Font

[@CGroup: D$ 050000307 0      ; Style
 U$ 0 0 0C8 019                ; Dim
 010                           ; ID
 0FFFF 080                     ; Class
 ChoiceDecimalID:
 'ID =          ' 0            ; Title
 0]                            ; No creation data

[@CBack: D$ 050000000 0      ; Style
 U$ 0E 09 038 0E               ; Dim
 0136                          ; ID
 0FFFF 080                     ; Class
 '<<<<<' 0                     ; Title
 0]                            ; No creation data

[@COK: D$ 050000000 0      ; Style
 U$ 047 09 038 0E              ; Dim
 01                            ; ID
 0FFFF 080                     ; Class
 'OK' 0                        ; Title
 0]                            ; No creation data

[@CForth: D$ 050000000 0      ; Style
 U$ 080 09 038 0E              ; Dim
 0138                          ; ID
 0FFFF 080                     ; Class
 '>>>>>' 0                     ; Title
 0]                            ; No creation data

[@Cfirst: D$ 050000000 0      ; Style
 U$ 02 09 0B 0E                ; Dim
 037                           ; ID
 0FFFF 080                     ; Class
 '[<' 0                        ; Title
 0]                            ; No creation data

[@Clast: D$ 050000000 0      ; Style
 U$ 0B9 09 0B 0E               ; Dim
 038                           ; ID
 0FFFF 080                     ; Class
 '>]' 0                        ; Title
 0]                            ; No creation data


;;
"Load_Dialog_from_Resources" effective Translation for bin to text template.
 Called only in case of 'Load Existing Resource Dialog' and 'Search for what Dialog '.
 So we can find in the Dialog data some menu ID. We set it in 'D$DialogMenuTrueID'
 (to see DialogMenuComment, < Right Click).

 'FromTextToBinTemplate' doesn't do the reverse operation...
;;

[ActualEditedDialogID: D$ ?
 ResourceDialogSize: D$ ?
 DialogNcontrol: D$ ?]

[isDLGEX: D$ ?
 InjectFont: D$ ?]

FromBinToTextTemplate:
    Call InitDialogMemory
    Mov B$OnClipDialog &TRUE              ; reuse of this flag for initialisation in proc

    Mov eax D$WhatDialogListPtr, esi D$eax, edi D$NewDialogTemplateText  ; esi > ptr
    Move D$ActualEditedDialogID D$eax-4                                  ; ID
    Move D$ResourceDialogSize D$eax+4                                    ; size

FromClipBoardBinToText:
    cmp D$esi 0FFFF0001 | setz B$isDLGEX

    Mov eax 'D$  ' | stosd | dec edi
    If B$isDLGEX = &TRUE
       Mov ebx D$esi+0C
    Else
       Mov ebx D$esi
    End_If

    Test ebx &DS_SETFONT NOT_ZERO S1>

    or B$InjectFont 1

    S1: or ebx &DS_SETFONT | Call TranslateDialogText8
    Mov eax ' ; S' | stosd | Mov eax 'tyle' | stosd | Mov al 0 | stosb
    Mov eax 'D$  ' | stosd | dec edi
    Mov ebx D$esi+08
    If B$isDLGEX = &TRUE
       Mov ebx D$esi+08
    Else
       Mov ebx D$esi+04
    End_If
    Call TranslateDialogText8
    Mov eax ' ; E' | stosd | Mov eax 'xSty' | stosd |Mov eax 'le' | stosd | dec edi
    If B$isDLGEX = &TRUE
;      Mov eax 'D$ 0' | stosd | dec edi
;      Mov ebx D$esi+04 | Call TranslateDialogText8; HelpID
;      Mov eax ' ; H' | stosd | Mov eax 'elpI' | stosd| Mov ax 'D' | stosw
       add esi 08
    End_If
    add esi 08

    Mov eax 'U$  ' | stosd | dec edi
    lodsw | Mov W$DialogNcontrol ax
            Mov ebx eax | Call TranslateDialogText4 | Mov al SPC| stosb  ; n
    lodsw | Mov ebx eax | Call TranslateDialogText4 | Mov al SPC| stosb  ; X
    lodsw | Mov ebx eax | Call TranslateDialogText4 | Mov al SPC| stosb  ; Y
    lodsw | Mov ebx eax | Call TranslateDialogText4 | Mov al SPC| stosb  ; W
    lodsw | Mov ebx eax | Call TranslateDialogText4 | Mov al SPC| stosb  ; H
    Mov eax ' ; D' | stosd | Mov ax 'im' | stosw | Mov al 0 | stosb

    lodsw    ; always 0 in RosAsm edition but 0 or 'FFFF ID' in resources:

    If D$DialogMenuTrueID = 0
        Mov eax '0 ; ' | stosd | Mov eax '    ' | stosd |
        Mov eax ' no ' | stosd | Mov eax 'Menu' | stosd | Mov al 0 | stosb  ; No menu
      ; beware: this is room for "FFFF ID ; menu" when menu added!
    Else
        Mov ebx 0FFFF | Call TranslateDialogText4 | Mov al SPC | stosb       ; Menu
        lodsw
        Mov ebx D$DialogMenuTrueID |  Call TranslateDialogText4
        Mov eax ' ; M' | stosd | Mov ax 'en' | stosw | Mov al 'u' | stosb | Mov al 0 | stosb
    End_If

    Mov al '"' | stosb | Mov bx W$esi | inc bx | jne L0> | add esi 4 | jmp L1> ; can Id
L0: lodsw | cmp ax 0 | je L1>
        stosb | jmp L0<
L1: Mov al '"' | stosb
    Mov eax ' 0 ;' | stosd | Mov eax ' Cla' | stosd | Mov ax 'ss' | stosw
    Mov al 0 | stosb

    Mov al '"' | stosb
L0: lodsw | cmp ax 0 | je L1>
        stosb | jmp L0<
L1: Mov al '"' | stosb
    Mov eax ' 0 ;' | stosd | Mov eax ' Tit' | stosd | Mov ax 'le' | stosw
    Mov al 0 | stosb

    cmp B$InjectFont 0 | je F0>
    Mov eax '08 "' |stosd| Mov eax 'Helv' |stosd| jmp L1> ; Inject font!
F0:
    lodsw | Mov ebx eax | Call TranslateDialogText2 ;pointsize
    If B$isDLGEX = &TRUE
;       Mov al SPC | stosb
;       lodsw | Mov ebx eax | Call TranslateDialogText4 ;weight
;       Mov al SPC | stosb
;       lodsw | Mov ebx eax | Call TranslateDialogText4 ;bItalic
       add esi 04 ; or above
    End_If
    Mov ax ' "' | stosw
L0: lodsw | cmp ax 0 | je L1>
        stosb | jmp L0<
L1: Mov al '"' | stosb
    Mov eax ' 0 ;' | stosd | Mov eax ' Fon' | stosd | Mov al 't' | stosb
    Mov al 0 | stosb | stosb

    AlignOn 4 esi

L1: .While W$DialogNcontrol > 0
       dec W$DialogNcontrol
       Mov eax 'D$  ' | stosd | dec edi
       If B$isDLGEX = &TRUE
          Mov ebx D$esi+08
       Else
          Mov ebx D$esi
       End_If
       Call TranslateDialogText8
       Mov eax ' ; S' | stosd | Mov eax 'tyle' | stosd | Mov al 0 | stosb
       Mov eax 'D$  ' | stosd | dec edi
       Mov ebx D$esi+04
       Call TranslateDialogText8
       Mov eax ' ; E' | stosd | Mov eax 'xSty' | stosd |Mov eax 'le' | stosd | dec edi
       If B$isDLGEX = &TRUE
;         Mov eax 'D$  ' | stosd | dec edi
;         Mov ebx D$esi | Call TranslateDialogText8; HelpID
;         Mov eax ' ; H' | stosd | Mov eax 'elpI' | stosd| Mov ax 'D' | stosw
          add esi 04
       End_If
       add esi 08

       Mov eax 'U$  ' | stosd | dec edi
       lodsw | Mov ebx eax | Call TranslateDialogText4 | Mov al SPC| stosb ; X
       lodsw | Mov ebx eax | Call TranslateDialogText4 | Mov al SPC| stosb ; Y
       lodsw | Mov ebx eax | Call TranslateDialogText4 | Mov al SPC| stosb ; W
       lodsw | Mov ebx eax | Call TranslateDialogText4 | Mov al SPC| stosb ; H
       Mov eax ' ; D' | stosd | Mov eax 'im' | stosd | dec edi

       lodsw | Mov ebx eax | Call TranslateDialogText4
       If B$isDLGEX = &TRUE
          add esi 2
       End_If
       Mov eax ' ; I' | stosd | Mov ax 'D' | stosw

       lodsw
       If ax = 0FFFF
          Mov ebx eax | Call TranslateDialogText4 | Mov al SPC| stosb
          lodsw | Mov ebx eax | Call TranslateDialogText4
       Else
          sub esi 2 | Mov al '"' | stosb
L0:       lodsw | cmp ax 0 | je L1>
          stosb | jmp L0<
L1:       Mov al '"' | stosb | Mov ax ' 0' | stosw
       End_If
       Mov eax ' ; C' | stosd | Mov eax 'lass' | stosd | Mov al 0 | stosb

      Mov al '"' | stosb | Mov bx W$esi | inc bx | jne L0> | add esi 4 | jmp L1> ; can ResId
L0:   lodsw | cmp ax 0 | je L1>
      stosb | jmp L0<
L1:   Mov al '"' | stosb
      Mov eax ' 0 ;' | stosd | Mov eax ' Tit' | stosd | Mov ax 'le' | stosw
      Mov al 0 | stosb

      movzx eax W$esi
      If B$isDLGEX = &FALSE
         Mov ah 0
      End_If
      add esi eax ; skip CreationData; NoAlign!
L1:
      Mov eax '0 ; ' | stosd | Mov eax 'No c' | stosd | Mov eax 'reat' | stosd
      Mov eax 'ion ' | stosd | Mov eax 'data' | stosd | Mov al 0 | stosb | stosb

      add esi 5 | and esi 0-4;AlignOn 4 esi
L1:
    .End_While
    Mov al 255 | stosb
ret
;DLGTEMPLATEEX
;[0FFFF0001, D$helpID, D$EXSTYLE, D$STYLE, W$Ncntrls, W$X, W$Y, W$Width, W$Height
;{W$0 | W$-1_W$MENUID | uMENU} {W$0 | W$-1_W$CLASS | uSTRING} {W$0 | uTITLE}
;if &DS_SETFONT {W$pointsize, W$weight, W$bItalic, uFontName}] ALIGN 4
;DLGITEMTEMPLATEEX
;[D$helpID, D$exStyle, D$style, W$x, W$Y, W$w, W$h, W$id
;{W$-1_W$CLASS | uSTRING} {W$0 | W$-1_W$ResID | uTITLE}
;W$extraCount] ALIGN 4
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE BitMap          ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;;
                                 BitMaps jobs.

 All-in-One organisation have some limits: I do not see what interrest it could be to
 implement a full BitMap Editor inside RosAsm... Maybe one day. Now, as we NEED BitMaps
 and as there are so many BitMaps Editors available for free, i only implement a BitMaps
 Import feature.
;;
___________________________________________________________________________________________
___________________________________________________________________________________________

[BmFileLen: D$ ?
 H.BmpFile: D$ ?]

[BmFilterPtr: D$ 1]

[BmFilesFilters:  B$ 'BitMap files' EOS  '*.bmp' EOS 0]
[OpenBitMapFileTitle: B$ 'Choose a BitMap File to open' EOS]


[BmuFileFilter: B$ ? # &MAX_PATH]
[BmSaveFilter: B$ ? # &MAX_PATH]
[BmChoosenFile: B$ ? # &MAX_PATH]

[BmOpenStruc:
 D$ len
 BmhwndFileOwner: D$ 0
 BmOpenInstance: D$ 0
 D$ BmFilesFilters
 D$ BmuFileFilter
 D$ &MAX_PATH
 D$ BmFilterPtr
 D$ BmSaveFilter
 D$ &MAX_PATH
 D$ BmChoosenFile
 D$ &MAX_PATH
 D$ 0
 D$ OpenBitMapFileTitle
 D$ 0281804 ; Win Equate ?!
 D$ 0  0  0  0  0]

[PointerToData: D$ ?]

LoadBitMap:
  ; Opening a .bmp file:
    Call SearchEmptyBitMapListRecord

    Call ClearPATH BmSaveFilter

    Call 'Comdlg32.GetOpenFileNameA' BmOpenStruc | On D$BmSaveFilter = 0,  ret

    On D$H.BmpFile > 0, Call 'KERNEL32.CloseHandle' D$H.BmpFile

    Call 'KERNEL32.CreateFileA' BmSaveFilter, &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE

        Call MessageBox D$BusyFilePtr

ret

    Else
        Mov D$H.BmpFile eax
    End_If

    Call 'KERNEL32.GetFileSize' eax 0 | sub eax 14
    Mov edi D$BitMapListPtr | add edi 8 | stosd         ; write BitMap lenght in List
    add eax 14
    Mov D$BmFileLen eax                                 ; > eax = adress for asked memory

    Call VirtualAlloc TempoMemPointer,
                      eax

    Mov edi D$BitMapListPtr | add edi 4 | Move D$edi D$TempoMemPointer ; write BitMap mem adress in List
    Push edi

        Call 'KERNEL32.ReadFile' D$H.BmpFile D$TempoMemPointer,
                              14 NumberOfReadBytes 0    ; jump over BitMapFile header.
    Pop edi

    Mov esi D$edi
    lodsw | cmp ax 'BM' | jne BadBitMapFileHeader
    lodsd | cmp eax D$BmFileLen | jne BadBitMapFileHeader
    lodsd | cmp eax 0 | jne BadBitMapFileHeader
    lodsd | Mov D$PointerToData eax

  ; Load BitMap Data in same table (overwrite no more use header):
    Mov ecx D$BmFileLen | sub ecx 14  ; 14 Bytes = len of File Header
  ; (File header is: W$ Style // D$ Size // D$ 0 // D$ Ptr to Data).

    Push edi
        Call 'KERNEL32.ReadFile' D$H.BmpFile D$edi ecx NumberOfReadBytes 0
    Pop edi

  ; Ajust image size if this record is missing:
    Mov edi D$edi
    If D$edi+20 = 0
        Mov eax D$BmFileLen | sub eax D$PointerToData
        Mov D$edi+20 eax
    End_If

  ; Ask user for what BitMap ID number:
L1: Call 'USER32.DialogBoxIndirectParamA' D$H.Instance  BMIDDialog  0  BMIDDialogProc  0

    If B$UserValidateBitMap = &TRUE
        Call ReOrderBitMapList
    Else
        Mov edi D$BitMapListPtr, eax 0 | stosd | stosd | stosd
    End_If
ret


[ConflictIDs: B$ 'This ID number is already in Use' EOS]

[ReorderFlag: D$ ?]

ReOrderBitMapList:
    Mov B$ReorderFlag &FALSE
    Mov esi BitMapList, edi esi | add edi 12
    While D$edi > 0
        Mov eax D$esi
        If eax > D$edi
            Exchange D$esi D$edi, D$esi+4 D$edi+4, D$esi+8 D$edi+8
            Mov B$ReorderFlag &TRUE
        End_If
        add esi 12 | add edi 12
    End_While
    cmp B$ReorderFlag &TRUE | je ReOrderBitMapList
ret

SearchEmptyBitMapListRecord:
    Push esi
        Mov esi BitMapList
        While D$esi > 0
            add esi 12
        End_While
        Mov D$BitMapListPtr esi
    Pop esi
ret


[BadBitMapFile: B$ 'Bad BitMap file header' EOS]

BadBitMapFileHeader:
    Call 'USER32.MessageBoxA' D$H.MainWindow, BadBitMapFile, Argh, &MB_SYSTEMMODAL
L8: Mov edi D$BitMapListPtr, eax 0, ecx 3 | rep stosd
ret


[BMIDDialog: D$ 090C408C2 0    ; Style
 U$ 03 0 0 0B9 018             ; Dim
 0                             ; no Menu
 '' 0                          ; Class
 'What ID number for new BitMap?' 0 ; Title
 08 'Helv' 0]                  ; Font

[@BMID0: D$ 050000000 0         ; Style
 U$ 07E 03 038 013             ; Dim
 01                            ; ID
 0FFFF 080                     ; Class
 'OK' 0                        ; Title
 0]                            ; No creation data

[@BMID1: D$ 050000000 0         ; Style
 U$ 03 03 038 013              ; Dim
 02                            ; ID
 0FFFF 080                     ; Class
 'Abort' 0                     ; Title
 0]                            ; No creation data

[@BMID2: D$ 050802000 0         ; Style
 U$ 040 05 038 0F              ; Dim
 03                            ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data


[H.BmpIDEdit: D$ ?]
[uBitMapID: B$ '                   ' EOS]

; Previously, i had set a test to prevent from IDs numbers smaller than 1000 and bigger than
; 32000. I do not remember why. May be an old wrong idea about unique IDs across Types.
; Suppress...

Proc BMIDDialogProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_COMMAND
       ..If D@wParam = &IDCANCEL
            Call 'USER32.EndDialog' D@hwnd 0

       ..Else_If D@wParam = &IDOK
           Call 'USER32.GetDlgItem' D@hwnd 3 | Mov D$H.BmpIDEdit eax
           Call 'USER32.SendMessageA' D$H.BmpIDEdit &WM_GETTEXTLENGTH 0 0 | inc eax
           Call 'USER32.SendMessageA' D$H.BmpIDEdit &WM_GETTEXT eax uBitMapID
           TranslateAsciiToDword uBitMapID
           Mov D$uBitMapID 0                         ; just for abort tests in callers:
           .If eax > 0FFFF    ; 32000                 ; 'StoreMenuEdition' / 'MenuEditProc'

             Call MessageBox D$IdTooBigPtr

           .Else_If eax < 1   ; 000

             Call MessageBox D$IdTooSmallPtr

           .Else
                Mov esi BitMapList
                While D$esi > 0
                    On D$esi = eax, Mov eax 0
                    add esi 12
                End_While
                If eax = 0
                    Call 'USER32.MessageBoxA' D$H.MainWindow, ConflictIDs, Argh, &MB_SYSTEMMODAL
                Else
                    Mov edi D$BitMapListPtr, D$edi eax
                    Mov B$UserValidateBitMap &TRUE
                    Call 'USER32.EndDialog' D@hwnd 0
                End_If
           .End_If

       ..End_If

    ...Else_If D@msg = &WM_INITDIALOG
        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        Mov B$UserValidateBitMap &FALSE
        Call 'USER32.GetDlgItem' D@hwnd 3
        Call 'USER32.SendMessageA' eax &EM_SETLIMITTEXT 5  0
           Mov esi D$BitMapListPtr | On esi > BitMapList, sub esi 12
           If D$esi = 0
             Mov eax 1   ; 30000
           Else
             lodsd | inc eax
           End_If
           Call 'USER32.SetDlgItemInt' D@hwnd 3 eax 0

    ...Else
       popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE

L9: EndP



[HCDC.Bitmap: D$ ?]

[H.Bitmap: D$ ?]

[NoBitMap: B$ 'No BitMap in This file' EOS]

[DeleteBitMapTitle: U$ 'Delete'  ShowBitMapTitle: U$ 'Exit  '] ; UNICODE ? EOS...

DeleteBitMap:
    Mov edi BMPEXIT, esi DeleteBitMapTitle, ecx 12 | rep movsb
    Mov W$BitMapDialogControlsNumber 5 | Call BitMapView

    If B$UserValidateBitMap = &TRUE
        Mov edi D$BitMapListPtr, esi edi | add esi 12
        While D$edi > 0
            movsd | movsd |movsd
        End_While
    End_If
ret


ShowBitMapsIds:
    Mov edi BMPEXIT, esi ShowBitMapTitle, ecx 12 | rep movsb
    Mov W$BitMapDialogControlsNumber 4 | Call BitMapView
ret


BitMapView:
    Mov D$BitMapListPtr BitMapList, eax D$BitMapListPtr

    If D$eax = 0
        Mov B$UserValidateBitMap &FALSE
        Call 'USER32.MessageBoxA' D$H.MainWindow, NoBitMap, Argh, &MB_SYSTEMMODAL
    Else
        Call 'USER32.DialogBoxIndirectParamA' D$H.Instance, BitMapDialog, 0, BitMapProc, 0
    End_If
ret


[UserValidateBitMap: D$ ?]
[BitMapIdText: D$ ? ? ? ?]

Proc BitMapProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_COMMAND
         ..If D@wParam = &IDOK
             Mov B$UserValidateBitMap &TRUE
             Call 'USER32.EndDialog' D@hwnd 0

         ..Else_If D@wParam = &IDCANCEL
             Mov B$UserValidateBitMap &FALSE
             Call 'USER32.EndDialog' D@hwnd 0

         ..Else_If D@wParam = 3                        ; >>>>
             Mov eax D$BitMapListPtr | add eax 12
             Mov ebx MAXBITMAP | shl ebx 2 | add ebx BitMapList
             .If eax < ebx                             ; ebx = end of BitMapList
                If D$eax > 0
                    Mov D$BitMapListPtr eax
                    Call 'USER32.RedrawWindow' D@hwnd 0  0,
                                           &RDW_ERASE+&RDW_INVALIDATE+&RDW_INTERNALPAINT
                End_If
             .End_If

         ..Else_If D@wParam = 4                        ; <<<<
             If D$BitMapListPtr > BitMapList
                 sub D$BitMapListPtr 12
                 Call 'USER32.RedrawWindow' D@hwnd 0  0,
                                           &RDW_ERASE+&RDW_INVALIDATE+&RDW_INTERNALPAINT
             End_If
       ..End_If

    ...Else_If D@msg = &WM_PAINT

         Call 'USER32.BeginPaint'  D@hwnd  PAINTSTRUCT
             Mov D$STRUCT.EditData@HDC eax
             Call 'GDI32.CreateCompatibleDC' D$STRUCT.EditData@HDC | Mov D$HCDC.Bitmap eax

             Mov esi D$BitMapListPtr | lodsd          ; ID
             Call SetBitMapIdText D@hwnd
             lodsd | Mov edi eax                      ; > edi > adress
             lodsd                                    ; eax = lenght
             Mov esi edi, ebx D$esi+20                ; ebx = image size
             sub eax ebx | add eax edi                ; eax > ptr to bmp data

             Call 'GDI32.CreateDIBitmap' D$STRUCT.EditData@HDC  edi  &CBM_INIT  eax  edi  &DIB_RGB_COLORS
                 Mov D$H.Bitmap eax
                 Call 'GDI32.SelectObject' D$HCDC.Bitmap D$H.Bitmap
                 Call 'USER32.GetClientRect' D@hwnd RECT
                 Call 'GDI32.BitBlt' D$STRUCT.EditData@HDC 0 0 D$Rect_Right D$Rect_bottom D$HCDC.Bitmap 0 0 &SRCCOPY
             Call 'GDI32.DeleteDC' D$HCDC.Bitmap
         Call 'USER32.EndPaint' D@hwnd PAINTSTRUCT
         Call 'GDI32.DeleteObject' D$H.Bitmap

    ...Else_If D@msg = &WM_INITDIALOG
        Mov D$BitMapListPtr BitMapList
        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon

    ...Else
       popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE

L9: EndP


Proc SetBitMapIdText:
    Argument @hwnd

    pushad
        Push 0_FFFF_FFFF
        Mov edi BitMapIdText, ecx 10
L0:     Mov edx 0 | div ecx | cmp eax 0 | je L2>
            Push edx | jmp L0<
L2:         Push edx
L2:     Pop eax | cmp eax 0_FFFF_FFFF | je L3>
            add al '0' | stosb | jmp L2<
L3:     Mov al 0 | stosb
        Call 'USER32.GetDlgItem' D@hwnd 5
        Call 'USER32.SetWindowTextA' eax BitMapIdText
    popad
EndP


[BitMapDialog: D$ 0900408C2 0  ; Style
 BitMapDialogControlsNumber:
 U$ 02 0 0 0DC 0C8             ; Dim
 0                             ; Menu
 '' 0                           ; Class
 'New Dialog' 0                ; Title
 08 'Helv' 0]                  ; Font

[@BMD0: D$ 050000001 0      ; Style
 U$ 0AB 0B9 030 0F             ; Dim
 01                            ; ID
 0FFFF 080                     ; Class
 BMPEXIT:
 'Delete' 0                        ; Title
 0]                            ; No creation data

[@BMD2: D$ 050000000 0      ; Style
 U$ 04E 0B9 029 0F             ; Dim
 03                            ; ID
 0FFFF 080                     ; Class
 '>>>>' 0                      ; Title
 0]                            ; No creation data

[@BMD3: D$ 050000000 0      ; Style
 U$ 0 0B8 029 010              ; Dim
 04                            ; ID
 0FFFF 080                     ; Class
 '<<<<' 0                      ; Title
 0]                            ; No creation data

[@BMD4: D$ 050000307 0      ; Style
 U$ 02B 0B7 01F 010            ; Dim
 05                            ; ID
 0FFFF 080                     ; Class
 '65000' 0                     ; Title
 0]                            ; No creation data

[@BMD1: D$ 050000000 0      ; Style
 U$ 079 0B9 030 0F             ; Dim
 02                            ; ID
 0FFFF 080                     ; Class
 'Abort' 0                     ; Title
 0]                            ; No creation data
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Command         ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;;
  Allows to pass commandlines to the debuggee. Command line options are loaded from text 
  files that have the same path and filename (with the extension '.CLO') as the destination 
  file. If there is no such file the app path is just copied to the buffer. 

  e.g. If DestinationFile is "D:\ping.EXE" and 'D:\ping.CLO' contains 
  "111.42.23.17" then CommandLine is set to "D:\ping.EXE 111.42.23.17". 
  If no CLO file exists CommandLine is set to "D:\ping.EXE".
  
  23-Oct-03 Ludwig Haehne - wkx@gmx.li
  
  28-Jun-04 - ExeName put in brackets
  
  11-Nov-04 - Complete rewrite - no 16k limit, deals with dll's
  
  26-Dec-04 - Separate the command line from the executable path and filename
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

; Setup the command line. The address of the string or zero is returned in eax.
; The buffer for the command line is allocated by SetupCommandLine and must be freed by the
; caller after use. Attention: Only free CommandLinePtr! The address returned in eax
; might point to a static buffer!

[CommandLinePtr: D$ ?]
[ScreensaverCommandLine: B$ '/S' EOS]
[BytesTransfered: D$ ?]

Proc SetupCommandLine:

    Local @H.File

    Uses esi edi

        Call GetCLOFilename
        Call 'KERNEL32.CreateFileA' CommandLineFile, &GENERIC_READ, &FILE_SHARE_READ,
                        &NULL, &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, &NULL

        ; In general no clo file will be provided, if we deal with a screensaver put
        ; a /S command as a default command and exit proc
        .If eax = &INVALID_HANDLE_VALUE
            If D$SavingExtension = '.SCR'
                Mov eax ScreensaverCommandLine
            Else
                Mov eax 0
            End_If
            ExitP
        .End_If

        Mov D@H.File eax

        ; Allocate buffer for commandline (must be freed by caller)
        Call 'KERNEL32.GetFileSize' D@H.File, 0
        If eax = 0_FFFF_FFFF
            Call ReportWinError {B$ 'SetupCommandLine: GetFileSize' EOS}
            Call 'KERNEL32.CloseHandle' D@H.File
            Mov eax 0
            ExitP
        End_If

        Call VirtualAlloc CommandLinePtr,
                          eax

        Mov edi D$CommandLinePtr

        ; Read the command line parameters from the file
        Call 'KERNEL32.ReadFile' D@H.File, edi, eax, BytesTransfered, &NULL
        add edi D$BytesTransfered
        Mov B$edi EOS

        Call 'KERNEL32.CloseHandle' D@H.File
        Mov eax D$CommandLinePtr
EndP
____________________________________________________________________________________________

[CommandLineFile: B$ ? # &MAX_PATH]

GetCLOFilename:

    Mov esi MainName,
        edi CommandLineFile

    While B$esi <> EOS

        movsb

    End_While

    Mov D$edi '.clo', B$edi+(4*ASCII) EOS ; append extension
ret
____________________________________________________________________________________________

; To allow to set the commandline inside the IDE I added an edit control in the output
; dialog and this code in section Format.
;
; These two are called at 'InitOutputDialog' and 'SaveOutputFormat':

Proc LoadCommandLine:

    Local @H.File

        Call GetCLOFilename ; Copy filename to buffer
        Call 'KERNEL32.CreateFileA' CommandLineFile, &GENERIC_READ, &FILE_SHARE_READ,
                        &NULL, &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, &NULL
        Mov D@H.File eax
        .If eax = &INVALID_HANDLE_VALUE
            Call 'USER32.SetDlgItemTextA' D$H.Output, 214, 0 ; clear edit
        .Else
            Call 'KERNEL32.GetFileSize' D@H.File, 0
            On eax = 0_FFFF_FFFF ExitP

            Call VirtualAlloc CommandLinePtr,
                              eax

                Call 'KERNEL32.ReadFile' D@H.File, D$CommandLinePtr, eax, BytesTransfered, &NULL
                Mov eax D$CommandLinePtr | add eax D$BytesTransfered | Mov B$eax 0
                Call 'KERNEL32.CloseHandle' D@H.File
                Call 'USER32.SetDlgItemTextA' D$H.Output, 214, D$CommandLinePtr

                Call VirtualFree CommandLinePtr

        .End_If

EndP
____________________________________________________________________________________________

Proc SaveCommandLine:

    Local @H.File, @Size

        ; If string is empty, delete CLO file if it exists
        Call 'USER32.SendDlgItemMessageA' D$H.Output, 214, &WM_GETTEXTLENGTH, 0, 0
        Mov D@Size eax
        If eax = 0
            Call GetCLOFilename
            Call 'KERNEL32.DeleteFileA' CommandLineFile

EndP

        End_If

        Call VirtualAlloc CommandLinePtr,
                          D@Size

        Call GetCLOFilename ; Copy filename
        Call 'KERNEL32.CreateFileA' CommandLineFile, &GENERIC_WRITE, &FILE_SHARE_READ,
                        &NULL, &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, &NULL
        Mov D@H.File eax
        If eax <> &INVALID_HANDLE_VALUE
            ; Copy commandline from edit to buffer and write it into the file
            Mov eax D@Size | add eax (1*ASCII)
            Call 'USER32.GetDlgItemTextA' D$H.Output, 214, D$CommandLinePtr, eax
            Call 'KERNEL32.WriteFile' D@H.File, D$CommandLinePtr, eax, BytesTransfered, &NULL
            Call 'KERNEL32.CloseHandle' D@H.File
        End_If

        Call VirtualFree CommandLinePtr

EndP

____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE DebugGUI        ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
_____________________________________________________________________________________________

                                  Debugger GUI - Ludwig Haehne
 
 Split from the debugger title for better readability.
   
 TODO:

    * Save upper & lower TAB selection
    * Memory inspector address edit should handle expressions (mouse hint code reuse)    
    * Hints for toolbar buttons    
    * Context menu in address space tree (?)
    * Next instruction indicator in source editor    
    * Separate the debug dialog from the main window (but stay on top)
    * Log Exceptions (also auto-forwarded)
    * Save to file for log (from context menu)
    * Watch TAB (expression-entry; add,remove&clear button; list/tree view)
    * Disassembly TAB
    * Restore defaults (set flag to delete debug.cfg at the end)
    * Recover toolbar when all bands are hidden
    * Nice FPU box
    * Nice CPU Info
    * Review code address form
    * Q$ / X$ / U$ (+string) support in mousehint
    * Sane menu/combo font (registry?) (test under wine)    
    * Address Space Tree vs. Nessie
____________________________________________________________________________________________

 Paragraphs
  
  * 'CreateDebugWindow' 'DebuggerMENU' 'DebuggerTOOLBAR' 'DebuggerMOUSEHINT' 
    'DebuggerSTRINGS'
  
 Dialogs
 
  * 'DebugDlgProc', 'DataViewProc', 'MemoryInspectorProc', 'PageTableProc', 'CallStackProc',
    'MouseOverDataHint', 'ExceptionInfoProc', 'AddressSpaceFormProc', 'LogFormProc'
 
 Window handling
 
  * 'AdjustControlSize', 'AdjustControlPos', 'SelectTab', 'ReportWinError'
  
 Misc routines
 
  * 'SourceDebugPos', 'NextInstructionDecode', 'IsMultiStepInstruction', 'TestCPUFeatures'    
   
 Format Conversion Procs
 
  * 'toHex', ...

;;
____________________________________________________________________________________________

; GENERAL WINDOW HANDLING PROCS
____________________________________________________________________________________________

[WINDOW_RESIZE  &SWP_NOMOVE+&SWP_NOZORDER+&SWP_NOACTIVATE]
[WINDOW_MOVE    &SWP_NOSIZE+&SWP_NOZORDER+&SWP_NOACTIVATE]

Proc AdjustControlSize:
    Arguments @hwnd, @ID, @dX, @dY
    Structure @RECT 16, @left 0, @top 4, @right 8, @bottom 12
    Uses ebx, esi, edi

        Mov edi D@RECT
        Call 'USER32.GetDlgItem' D@hwnd D@ID | Mov ebx eax
        ; Compute current width (eax) & height (esi) and add delta's
        Call 'USER32.GetWindowRect' ebx edi
        Mov eax D@right
        sub eax D@left
        add eax D@dX
        Mov esi D@bottom
        sub esi D@top
        add esi D@dY
        Call 'USER32.SetWindowPos' ebx, 0, 0, 0, eax, esi, WINDOW_RESIZE
        ; Return height error for listboxes.
        Call 'USER32.GetWindowRect' ebx edi
        Mov eax D@bottom
        sub eax D@top
        sub eax esi
EndP
____________________________________________________________________________________________

Proc AdjustControlPos:
    Arguments @hwnd, @ID, @dX, @dY
    Structure @RECT 16, @left 0, @top 4, @right 8, @bottom 12
    Uses ebx, edi

        Mov edi D@RECT
        Call 'USER32.GetDlgItem' D@hwnd D@ID | Mov ebx eax
        ; Compute current xpos (eax) & ypos (ecx) and add delta's
        Call 'USER32.GetWindowRect' ebx, edi
        Call 'USER32.ScreenToClient' D@hwnd, edi
        Mov eax D@left
        add eax D@dX
        Mov ecx D@top
        add ecx D@dY
        Call 'USER32.SetWindowPos' ebx, 0, eax, ecx, 0, 0, WINDOW_MOVE
EndP
____________________________________________________________________________________________

Proc ReportWinError:
    Arguments @Caption
    Local @String

        Call 'KERNEL32.GetLastError'
        Mov edx (&SUBLANG_DEFAULT shl 16 or &LANG_NEUTRAL)
        lea ecx D@String
        Call 'KERNEL32.FormatMessageA' &FORMAT_MESSAGE_ALLOCATE_BUFFER+&FORMAT_MESSAGE_FROM_SYSTEM,
            &NULL, eax, edx, ecx, 256, &NULL
        Call 'USER32.MessageBoxA' D$H.MainWindow, D@String, D@Caption, &MB_ICONERROR
        Call 'KERNEL32.LocalFree' D@String
EndP
____________________________________________________________________________________________

Proc SelectTab:

    Arguments @H.Dlg,
              @TabCtrlID,
              @Index

    Structure @NotifyMsg 12, @hwnd 0, @ID 4, @Code 8

    Uses ebx

    Call 'USER32.GetDlgItem' D@H.Dlg,
                             D@TabCtrlID
    Mov ebx eax

    SendMessage ebx, &TCM_SETCURSEL, D@Index, 0

    Mov D@hwnd ebx

    Move D@ID D@TabCtrlID

    Mov D@Code &TCN_SELCHANGE

    SendMessage D@H.Dlg, &WM_NOTIFY, D@TabCtrlID, D@NotifyMsg ; for Win9x!

    Call 'USER32.PostMessageA' D@H.Dlg, &WM_NOTIFY, D@TabCtrlID, D@NotifyMsg

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; ADDRESS SPACE TREE
____________________________________________________________________________________________
____________________________________________________________________________________________

[H.ASForm: D$ ?]

[H.ASFormTree: D$ ?]

Proc CreateNewForm_AddressSpaceForm:
    Arguments @H.Parent

    Call 'USER32.RegisterClassExA' ASFormClass

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
                                  ASFormClassName,
                                  {B$ "Main Window" EOS},
                                  &WS_CHILD,
                                  0,
                                  0,
                                  100,
                                  200,
                                  D@H.Parent,
                                  &NULL,
                                  D$H.Instance,
                                  0

    Mov D$H.ASForm eax

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT+&WS_EX_CLIENTEDGE+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
                                  {B$ "SysTreeView32" EOS},
                                  {B$ "New Control" EOS},
                                  &WS_CHILD+&WS_CLIPSIBLINGS+&WS_VISIBLE+&TVS_FULLROWSELECT+&TVS_HASBUTTONS+&TVS_HASLINES+&TVS_LINESATROOT+&TVS_TRACKSELECT,
                                  0,
                                  0,
                                  100,
                                  200,
                                  D$H.ASForm,
                                  2,
                                  D$H.Instance,
                                  0

    Mov D$H.ASFormTree eax

EndP

[ASFormClass:
 @cbSize:        D$ len
 @style:         D$ 0
 @lpfnWndProc:   D$ AddressSpaceFormProc
 @cbClsExtra:    D$ 0
 @cbWndExtra:    D$ 0
 @hInstance:     D$ 0
 @hIcon:         D$ 0
 @hCursor:       D$ 0
 @hbrBackground: D$ 1
 @lpszMenuName:  D$ 0
 @lpszClassName: D$ ASFormClassName
 @hIconSm:       D$ 0]
[ASFormClassName: B$ "AddressSpaceForm" EOS]

Proc AddressSpaceFormProc:
    Arguments @hwnd @msg @wParam @lParam
    Uses esi edi ebx

    .If D@msg = &WM_CREATE
        Mov D$AddressSpace.TVProc 0
        Mov eax 0

    .Else_If D@msg = &WM_CLOSE
        Call 'USER32.DestroyWindow' D@hwnd

    .Else_if D@msg = &WM_SIZE
        movzx ecx W@lParam
        movzx edx W@lParam+2

        Call 'USER32.SetWindowPos' D$H.ASFormTree, 0, 0, 0, ecx, edx, WINDOW_RESIZE

    .Else_if D@msg = &WM_SETFONT
        SendMessage D$H.ASFormTree, &WM_SETFONT, D@wParam, D@lParam

    .Else_if D@msg = WM_REFRESH_CONTENT
        Call AddressSpaceTree_Build

    .Else_if D@msg = &WM_SHOWWINDOW
        If D$AddressSpace.TVProc = 0
            Call AddressSpaceForm_OverrideTreeProc
        End_If
        If D@wParam = &TRUE
            Call AddressSpaceTree_Build
        End_If

    .Else_if D@msg = &WM_NOTIFY
        Mov eax D@lParam, edx D$H.ASFormTree
        If D$eax = edx
            Call AddressSpaceForm_OnTreeNavigate eax
        End_If
        Mov eax 0

    .Else
        Call 'USER32.DefWindowProcA' D@hwnd D@msg D@wParam D@lParam
    .End_If
EndP
____________________________________________________________________________________________

[ASForm.CurrentItem: D$ ?
 ASForm.CurrentAddress: D$ ?]

Proc AddressSpaceForm_OnTreeNavigate:
    Arguments @NotifyInfo
    Uses esi ebx

    Mov esi D@NotifyInfo
    On D$esi+8 <> &TVN_SELCHANGED, ExitP
    add esi 12 ; skip notify header
    add esi 4 ; skip action flag
    add esi 40 ; skip old item
    Mov eax D$esi+4 ; H.Item
    Mov D$ASForm.CurrentItem eax
    Mov ebx D$esi+36 ; lParam of new item
    Mov D$ASForm.CurrentAddress ebx

EndP

____________________________________________________________________________________________

; To allow rightclick inside the treeview we override the window proc.

AddressSpaceForm_OverrideTreeProc:
    Mov D$AddressSpace.TVProc 0
    Call 'USER32.SetWindowLongA' D$H.ASFormTree, &GWL_WNDPROC, AddressSpace_HandleMouseProc
    Mov D$AddressSpace.TVProc eax
ret

[AddressSpace.TVProc: D$ ?]

Proc AddressSpace_HandleMouseProc:
    Arguments @hwnd, @msg, @wParam, @lParam
    Uses ebx esi edi

    .If D@msg = &WM_LBUTTONDBLCLK
      ; Simulate left click (select item) before showing the popup menu
        SendMessage D@hwnd, &WM_LBUTTONDOWN, D@wParam, D@lParam
        SendMessage D@hwnd, &WM_LBUTTONUP, D@wParam, D@lParam
      ; Is this a page item?
        cmp D$ASForm.CurrentAddress 0 | je L0>
      ; Check if the user clicked onto the item
        Move D$DebugRect D$ASForm.CurrentItem
        SendMessage D@hwnd, &TVM_GETITEMRECT, 1, DebugRect
        movzx eax W@lParam
        cmp eax D$DebugRect@left  | jl L0>
        cmp eax D$DebugRect@right | ja L0>
        movzx eax W@lParam+2
        cmp eax D$DebugRect@top    | jl L0>
        cmp eax D$DebugRect@bottom | ja L0>
      ; Show the popup menu at the position of the mouse-click
        SendMessage D$H.MemoryInspector, WM_SET_PAGE, D$ASForm.CurrentAddress, 0
    .End_If
L0: Call 'USER32.CallWindowProcA' D$AddressSpace.TVProc, D@hwnd, D@msg, D@wParam, D@lParam
EndP
____________________________________________________________________________________________

[PageDesc: B$ ? # 64]

Proc AddressSpaceTree_WritePageDescription:
    Arguments @Address, @Protect
    Uses esi, edi

      ; Write address
        Mov eax D@Address, edi PageDesc, ecx 4
        DwordToHex eax

      ; Write protection "XRWC GN"
        Mov al SPC | stosb
        Mov ecx D@Protect

        Mov D$edi '----', D$edi+4 ' -- '
        If ecx = &PAGE_READONLY
            Mov B$edi+1 'R'
        Else_if ecx = &PAGE_READWRITE
            Mov W$edi+1 'RW'
        Else_if ecx = &PAGE_EXECUTE
            Mov B$edi 'X'
        Else_if ecx = &PAGE_EXECUTE_READ
            Mov W$edi 'XR'
        Else_if ecx = &PAGE_EXECUTE_READWRITE
            Mov D$edi 'XRW-'
        Else_if ecx = &PAGE_EXECUTE_WRITECOPY
            Mov D$edi 'XRWC'
        Else_if ecx = &PAGE_WRITECOPY
            Mov D$edi '-RWC'
        End_If
        test ecx &PAGE_GUARD ZERO L0>
        Mov B$edi+5 'G'
L0:     test ecx &PAGE_NOCACHE ZERO L0>
        Mov B$edi+6 'N'

L0:     add edi 8
        Mov D$edi 0
EndP
____________________________________________________________________________________________

Proc AddressSpaceTree_AddPages:
    Arguments @Base, @Size, @Protect, @Type
    Uses esi, edi

      ; Add item for each commited page in region
        Mov esi D@Base, edi esi
        add edi D@Size

        While esi < edi
            Call AddressSpaceTree_WritePageDescription esi, D@Protect
            Mov D$TVI@Item.lParam esi
            Mov D$TVI@Item.pszText PageDesc
            SendMessage D$H.ASFormTree, &TVM_INSERTITEM, 0, TVI
            add esi 01000
        EndWhile
EndP
____________________________________________________________________________________________

Proc AddressSpaceTree_AddModule:
    Arguments @ModEntry
    Local @LowerBound, @UpperBound, @hModItem
    Uses esi, ebx

        Mov esi D@ModEntry

        Mov D$TVI@hParent &TVI_ROOT
        Mov eax D$esi+ME_Name
        Mov D$TVI@Item.pszText eax
        Move D$TVI@Item.lParam 0

        SendMessage D$H.ASFormTree, &TVM_INSERTITEM, 0, TVI
        Mov D@hModItem eax

        Mov eax D$esi+ME_Base
        Mov D@LowerBound eax
        add eax D$esi+ME_Size
        Mov D@UpperBound eax

        Mov ebx D@LowerBound
        .While ebx < D@UpperBound
            Call VirtualQuery ebx
            .If eax = &TRUE
                If ebx = D$esi+ME_CodeBase
                    Mov D$TVI@Item.pszText {B$ 'Code Section' EOS}
                    Mov D$TVI@Item.lParam 0
                    SendMessage D$H.ASFormTree, &TVM_INSERTITEM, 0, TVI
                    Mov D$TVI@hParent eax
                Else
                    Move D$TVI@hParent D@hModItem
                End_If
                Call AddressSpaceTree_AddPages ebx, D$MemoryInformation@RegionSize, D$MemoryInformation@Protect, D$MemoryInformation@Type
            .Else_If eax = 0-1
                ExitP
            .End_If
            add ebx D$MemoryInformation@RegionSize
        .EndWhile

;;
        Mov D$TVI@Item.pszText {B$ 'Code Section' EOS}
        Move D$TVI@Item.lParam D$esi+ME_CodeBase
        

        Mov D$TVI@Item.pszText {B$ 'Export Section' EOS}
        Mov eax D$esi+ME_ExportBase
        add eax D$esi+ME_Base
        Mov D$TVI@Item.lParam eax
        SendMessage D$H.ASFormTree, &TVM_INSERTITEM, 0, TVI
;;

      ; The AS scanner should continue behind the module mapping area
        Move D$MemoryInformation@RegionSize D$esi+ME_Size
EndP
____________________________________________________________________________________________

Proc AddressSpaceTree_AddGeneralRegion:
    Arguments @Base, @Size, @Protect, @Type

    [@LastAllocBase: D$ ?]

      ; Check if the region belongs to the last added allocation block, otherwise
      ; add a new top-level item.
        Mov eax D$MemoryInformation@AllocationBase
        If D@LastAllocBase <> eax
            Mov D@LastAllocBase eax
            Call IntToHexString
            Mov D$TVI@hParent &TVI_ROOT
            Mov D$TVI@Item.pszText HexString
            Mov D$TVI@Item.lParam 0
            SendMessage D$H.ASFormTree, &TVM_INSERTITEM, 0, TVI
            Mov D$TVI@hParent eax
        End_If

      ; Add item for each commited page in region
        Call AddressSpaceTree_AddPages D@Base, D@Size, D@Protect, D@Type
EndP
____________________________________________________________________________________________

; Add a memory region returned by VirtualQuery

Proc AddressSpaceTree_AddRegion:
    Arguments @Base, @Size, @Protect, @Type

        Mov eax D$MemoryInformation@BaseAddress
        Mov D$TVI@Item.lParam eax

      ; Check if this region is a mapped module
        Call GetModuleName eax
        If eax <> 0
            Call AddressSpaceTree_AddModule edx
        Else
            Call AddressSpaceTree_AddGeneralRegion D@Base, D@Size, D@Protect, D@Type
        End_If
EndP
____________________________________________________________________________________________

Proc AddressSpaceTree_Build:

    SendMessage D$H.ASFormTree, &TVM_DELETEITEM, 0, &TVI_ROOT
    SendMessage D$H.ASFormTree, &WM_SETREDRAW, 0, 0

    Mov D$TVI@hParent &TVI_ROOT
    Mov D$TVI@hInsertAfter &TVI_LAST
    Mov D$TVI@Item.imask &TVIF_TEXT+&TVIF_PARAM

    Mov esi D$AddressLowerBound
    While esi < D$AddressUpperBound
        Call VirtualQuery esi
        If eax = 1
            Call AddressSpaceTree_AddRegion esi, ecx,
                D$MemoryInformation@Protect, D$MemoryInformation@Type
        Else_If eax = 0-1
            ExitP
        End_If
        add esi D$MemoryInformation@RegionSize
    EndWhile

    SendMessage D$H.ASFormTree, &WM_SETREDRAW, 1, 0
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; EVENT LOG
____________________________________________________________________________________________
____________________________________________________________________________________________

[H.LogForm: D$ ?]

Proc CreateNewForm_LogForm:
    Arguments @Parent

    Call 'USER32.RegisterClassExA' LogFormClass

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
                                  LogFormClassName,
                                  {B$ "Main Window" EOS},
                                  &WS_CHILD+&WS_VISIBLE,
                                  0,
                                  0,
                                  100,
                                  200,
                                  D@Parent,
                                  &NULL,
                                  D$H.Instance,
                                  0

    Mov D$H.LogForm eax

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT+&WS_EX_CLIENTEDGE+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
                                  {B$ "LISTBOX" EOS},
                                  {B$ "New Control" EOS},
                                  &WS_CHILD+&WS_CLIPSIBLINGS+&WS_OVERLAPPED+&WS_VISIBLE+&WS_VSCROLL+&LBS_NOINTEGRALHEIGHT,
                                  0,
                                  0,
                                  100,
                                  200,
                                  D$H.LogForm,
                                  2,
                                  D$H.Instance,
                                  0

EndP
____________________________________________________________________________________________
[LogFormClass:
 @cbSize:        D$ len
 @style:         D$ 0
 @lpfnWndProc:   D$ LogFormProc
 @cbClsExtra:    D$ 0
 @cbWndExtra:    D$ 0
 @hInstance:     D$ 0
 @hIcon:         D$ 0
 @hCursor:       D$ 0
 @hbrBackground: D$ 1
 @lpszMenuName:  D$ 0
 @lpszClassName: D$ LogFormClassName
 @hIconSm:       D$ 0]
[LogFormClassName: B$ "LogForm" EOS]
____________________________________________________________________________________________

Proc LogFormProc:

    Arguments @hwnd,
              @msg,
              @wParam,
              @lParam

    Uses ebx,
         esi,
         edi

  ;  .If D@msg = &WM_CREATE

   ;     xor eax eax

    .If D@msg = &WM_CLOSE

        Call 'USER32.DestroyWindow' D@hwnd

    .Else_If D@msg = &WM_SIZE

        movzx ecx W@lParam

        movzx edx W@lParam+2

        Call 'USER32.SetWindowPos' D$H.LogForm,
                                   0,
                                   0,
                                   0,
                                   ecx,
                                   edx,
                                   WINDOW_RESIZE

    .Else_If D@msg = WM_LOG

        Mov edi LogString

        Call TimeToStr

        Mov al SPC | stosb

        Mov esi D@wParam, ecx D@lParam

        On ecx > 255 Mov ecx 255 ; !!! cmov..

        If ecx = 0 ; !!! Ou Else >255

            While B$esi+ecx <> 0 | inc ecx | EndWhile

        End_If

        While ecx > 0

            lodsb

            On al <> 0A, stosb

            dec ecx

        EndWhile

        ;rep movsb

        Mov B$edi 0

        SendMessage D$H.LogForm, &LB_ADDSTRING, 0, LogString

        SendMessage D$H.LogForm, &LB_SETCURSEL, eax, 0

;    .Else_If D@msg = &WM_DESTROY

  ;  .Else_If D@msg = &WM_SETFONT ; !!! TODO il semble y avoir une boucle sans fin ici

     ;   Call 'USER32.SendMessageA' D$H.LogForm,
     ;                              &WM_SETFONT,
     ;                              D@wParam,
     ;                              D@lParam

    .Else

        Call 'USER32.DefWindowProcA' D@hwnd,
                                     D@msg,
                                     D@wParam,
                                     D@lParam

    .End_If

EndP

[LogString: B$ ? # 256]
____________________________________________________________________________________________
____________________________________________________________________________________________

; ADDRESS INPUT
____________________________________________________________________________________________
____________________________________________________________________________________________

[H.CodeAddressFormFont: D$ ?]

[CodeAddressForm_LOGFONTSTRUCT:
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 0
 D$ 536870912 ; WinEquate !!!
 B$ 'MS Sans Serif' EOS 0 0 0 0 0 ]

[H.CodeAddressForm: D$ ?]

[H.CodeAddressFormGotoButton: D$ ?]

;[CodeAddressForm.GotoButtonFont_handle: D$ ?]

[CodeAddressForm.GotoButton_LOGFONTSTRUCT:
 D$ -11
 D$ 0
 D$ 0
 D$ 0
 D$ 400 ; WinEquate !!!
 D$ 0
 D$ 570491393 ; !!! WinEquate
 B$ 'MS Sans Serif' EOS 0 0 0 0 0 ]

[H.CodeAddressFormAddressEdit: D$ ?]

[H.CodeAddressForm.AddressEditFont: D$ ?]

[CodeAddressForm.AddressEdit_LOGFONTSTRUCT:
 D$ -13
 D$ 0
 D$ 0
 D$ 0
 D$ 400 ; !!! WinEquate
 D$ 0
 D$ 822149635 ; !!! WinEquate
 B$ 'Courier New' EOS 0 0 0 0 0 ]

; Tag Wizard Form "J:\Projects\RosAsm\WizardFiles\WZRDForm0000.wwf"
CreateNewForm_CodeAddressForm:
    Call 'ComCtl32.InitCommonControlsEx' CodeAddressFormClassName@Init_All_Common_Controls
    Call 'USER32.RegisterClassExA' CodeAddressFormClass

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
                                  CodeAddressFormClassName,
                                  {B$ "Show code at address ..." EOS},
                                  &WS_BORDER+&WS_CAPTION+&WS_DLGFRAME+&WS_OVERLAPPED+&WS_POPUP+&WS_VISIBLE+&NULL,
                                  82,
                                  35,
                                  282,
                                  100,
                                  0,
                                  &NULL,
                                  D$H.Instance,
                                  0

    Mov D$H.CodeAddressForm eax

    Call 'GDI32.CreateFontIndirectA' CodeAddressForm_LOGFONTSTRUCT | Mov D$H.CodeAddressFormFont eax
    Call 'USER32.SendMessageA' D$H.CodeAddressForm  &WM_SETFONT eax &TRUE

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT+&WS_EX_CLIENTEDGE+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
                                  {B$ "BUTTON" EOS},
                                  {B$ "Show statement" EOS},
                                  &WS_CHILD+&WS_CLIPSIBLINGS+&WS_OVERLAPPED+&WS_VISIBLE+&BS_PUSHBUTTON+&BS_TEXT,
                                  159,
                                  22,
                                  101,
                                  28,
                                  D$H.CodeAddressForm,
                                  2,
                                  D$H.Instance,
                                  0

    Mov D$H.CodeAddressFormGotoButton eax

    Call 'GDI32.CreateFontIndirectA' CodeAddressForm.GotoButton_LOGFONTSTRUCT | Mov D$H.CodeAddressFormGotoButton eax
    Call 'USER32.SendMessageA' D$H.CodeAddressFormGotoButton  &WM_SETFONT eax &TRUE

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT+&WS_EX_CLIENTEDGE+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
                                  STR.A.EditWindowClassName,
                                  &NULL,
                                  &WS_CHILD+&WS_CLIPSIBLINGS+&WS_OVERLAPPED+&WS_VISIBLE+&ES_LEFT+&ES_RIGHT+&ES_UPPERCASE,
                                  22,
                                  25,
                                  125,
                                  21,
                                  D$H.CodeAddressForm,
                                  3,
                                  D$H.Instance,
                                  0

    Mov D$H.CodeAddressFormAddressEdit eax

    Call 'GDI32.CreateFontIndirectA' CodeAddressForm.AddressEdit_LOGFONTSTRUCT | Mov D$H.CodeAddressForm.AddressEditFont eax

    Call 'USER32.SendMessageA' D$H.CodeAddressFormAddressEdit  &WM_SETFONT eax &TRUE

ret
____________________________________________________________________________________________
[CodeAddressFormClass:
 @cbSize:        D$ len
 @style:         D$ 0
 @lpfnWndProc:   D$ CodeAddressFormProc
 @cbClsExtra:    D$ 0
 @cbWndExtra:    D$ 0
 @hInstance:     D$ 0
 @hIcon:         D$ 0
 @hCursor:       D$ 0
 @hbrBackground: D$ 1
 @lpszMenuName:  D$ 0
 @lpszClassName: D$ CodeAddressFormClassName
 @hIconSm:       D$ 0]
[CodeAddressFormClassName: B$ "CodeAddressForm" EOS]
[@Init_All_Common_Controls:
 @Init_All_Common_Controls_dwSize: D$ len
 @Init_All_Common_Controls_dwICC:  D$ &ICC_COOL_CLASSES+&ICC_DATE_CLASSES+&ICC_INTERNET_CLASSES+&ICC_NATIVEFNTCTL_CLASS,
             +&ICC_PAGESCROLLER_CLASS+&ICC_USEREX_CLASSES+&ICC_WIN95_CLASSES]
____________________________________________________________________________________________

Proc CodeAddressFormProc:
    Arguments @hwnd @msg @wParam @lParam

    pushad

    ...If D@msg = &WM_CREATE

    ...Else_If D@msg = &WM_CLOSE
        Call 'GDI32.DeleteObject' D$H.CodeAddressFormFont
        Call 'GDI32.DeleteObject' D$H.CodeAddressFormGotoButton
        Call 'GDI32.DeleteObject' D$H.CodeAddressForm.AddressEditFont
        Call 'USER32.DestroyWindow' D@hwnd

    ...Else_if D@msg = &WM_COMMAND
        Mov eax D@lParam
        If eax = D$H.CodeAddressFormGotoButton
            Call CodeAddressForm_Goto
        End_If

    ...Else
        popad
        Call 'USER32.DefWindowProcA' D@hwnd D@msg D@wParam D@lParam
        ExitP

    ...End_If

    popad
    Mov eax &FALSE

EndP
; Tag End
;;
    ...Else_if D@msg = &WM_COMMAND
        Mov eax D@lParam
        If eax = D$H.CodeAddressFormGotoButton
            Call CodeAddressForm_Goto
        End_If
;;


CodeAddressForm_Goto:
    Call 'USER32.GetWindowTextA' D$H.CodeAddressFormAddressEdit, HexString, 10
    Mov esi HexString
    Call HexStringToInt
    Mov ebx eax

    Call IsProcessCode ebx
    If eax = &TRUE
        Call SourceDebugPos ebx
    Else
        Call 'USER32.MessageBoxA' D$H.CodeAddressForm, {B$ 'This is not a valid code address!' EOS},
            {B$ 'Invalid address' EOS}, &MB_ICONWARNING
    End_If
    SendMessage D$H.CodeAddressForm, &WM_CLOSE, 0, 0
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; Call STACK
____________________________________________________________________________________________
____________________________________________________________________________________________

Proc CreateNewForm_CallStackForm:
    Arguments @Parent

    Call 'USER32.RegisterClassExA' CSFormClass

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
                                  CSFormClassName,
                                  {B$ "Callstack" EOS},
                                  &WS_CHILD,
                                  0,
                                  0,
                                  100,
                                  200,
                                  D@Parent,
                                  &NULL,
                                  D$H.Instance,
                                  0

    Mov D$H.CallStackForm eax

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT+&WS_EX_CLIENTEDGE+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
                                  {B$ "SysTreeView32" EOS},
                                  {B$ "New Control" EOS},
                                  &WS_CHILD+&WS_CLIPSIBLINGS+&WS_VISIBLE+&TVS_FULLROWSELECT+&TVS_HASBUTTONS+&TVS_HASLINES+&TVS_LINESATROOT+&TVS_TRACKSELECT,
                                  0,
                                  0,
                                  100,
                                  200,
                                  D$H.CallStackForm,
                                  CALLSTACK_TREE,
                                  D$H.Instance,
                                  0

    Mov D$H.CallStackTree eax

    Call CallStack_OverrideTreeProc

EndP

[CSFormClass:
 @cbSize:        D$ len
 @style:         D$ 0
 @lpfnWndProc:   D$ CallStackProc
 @cbClsExtra:    D$ 0
 @cbWndExtra:    D$ 0
 @hInstance:     D$ 0
 @hIcon:         D$ 0
 @hCursor:       D$ 0
 @hbrBackground: D$ 1
 @lpszMenuName:  D$ 0
 @lpszClassName: D$ CSFormClassName
 @hIconSm:       D$ 0]
[CSFormClassName: B$ "CallStackForm" EOS]
____________________________________________________________________________________________

; Process WM_CREATE message.

Proc CallStackDialog_OnCreate:
    Arguments @hwnd

        Move D$H.CallStackForm D@hwnd

        Call 'USER32.GetClientRect' D@hwnd, DebugRect
        Move W$CallStackForm.Width W$DebugRect@width
        Move W$CallStackForm.Height W$DebugRect@height

        Call CallStack_CreatePopupMenu

        Mov eax &TRUE
EndP
____________________________________________________________________________________________

; Process WM_SIZE message.

Proc CallStackDialog_OnSize:
    Arguments @hwnd, @WidthHeight

        movzx eax W$CallStackForm.Width
        movzx esi W@WidthHeight
        sub esi eax
        movzx eax W$CallStackForm.Height
        movzx edi W@WidthHeight+2
        sub edi eax
        Call AdjustControlSize D@hwnd, CALLSTACK_TREE, esi, edi
        ;Call AdjustControlPos D@hwnd, CALLSTACK_SHOWDECLARATION, 0, edi
        ;Call AdjustControlPos D@hwnd, CALLSTACK_SHOWEVOKE, 0, edi
        Call 'USER32.InvalidateRect' D@hwnd, &NULL, &TRUE

        Move D$CallStackFormSize D@WidthHeight
        Mov eax 0
EndP
____________________________________________________________________________________________

; Process WM_COMMAND message.

Proc CallStackDialog_OnCommand:
    Arguments @hwnd, @wParam, @lParam

        movzx ecx W@wParam
        movzx eax W@wParam+2
        Mov ebx D$CallStack.PopupMenu

        .If ecx = MCS_SHOW_INVOKE
            Call CallStackForm_ShowEvoke

        .Else_if ecx = MCS_SHOW_DECL
            Call CallStackForm_ShowDeclaration

        .Else_If ecx = MCS_SHOW_ALL
            Mov D$CallStackFilter ecx
            Call 'USER32.CheckMenuRadioItem' ebx, MCS_SHOWALL, MCS_HIDE_INTRA,
               ecx, &MF_BYCOMMAND
            Call CallStackForm_Refresh

        .Else_If ecx = MCS_HIDE_EXTERNAL
            Mov D$CallStackFilter ecx
            Call 'USER32.CheckMenuRadioItem' ebx, MCS_SHOWALL, MCS_HIDE_INTRA,
               ecx, &MF_BYCOMMAND
            Call CallStackForm_Refresh

        .Else_If ecx = MCS_HIDE_INTRA
            Mov D$CallStackFilter ecx
            Call 'USER32.CheckMenuRadioItem' ebx, MCS_SHOWALL, MCS_HIDE_INTRA,
               ecx, &MF_BYCOMMAND
            Call CallStackForm_Refresh

        .Else_If ecx = MCS_SHOWLOCALS
            xor B$CallStackShowLocal 1
            Mov eax D$CallStackShowLocal | shl eax 3
            Call 'USER32.CheckMenuItem' ebx, MCS_SHOWLOCALS, eax
            Call CallStackForm_Refresh

        .End_If
        Mov eax 0
EndP
____________________________________________________________________________________________

; Process CDDS_ITEMPREPAINT notification. ebx > NMTVCUSTOMDRAW

CallStackDialog_OnPaintItem:
    Mov eax D$ebx+44 ; item param
    If eax <> 0

        Mov al B$eax+CSE_Flags
        test al CSEF_EXTERNAL ZERO L0>

        Mov D$ebx+48 0_66_66_66 ; set text color to gray
    End_If
L0: Mov eax &CDRF_NEWFONT
ret
____________________________________________________________________________________________

; Process WM_NOTIFY message.

Proc CallStackDialog_OnNotify:
    Arguments @NotifyMsg

        Mov ebx D@NotifyMsg

        .If D$ebx+8 = &NM_CUSTOMDRAW

            Mov eax D$ebx+12 ; draw stage
            If eax = &CDDS_PREPAINT
                Mov eax &CDRF_NOTIFYITEMDRAW
            Else eax = &CDDS_ITEMPREPAINT
                Call CallStackDialog_OnPaintItem
            Else
                Mov eax 0
            End_If

        .Else_If D$ebx+8 = &TVN_SELCHANGED
            Call CallStackForm_OnTreeNavigate ebx
            Mov eax 0

        .Else
            Mov eax 0
        .End_If
EndP
____________________________________________________________________________________________

; Tag Dialog 1015

[CallStackFormSize:
 CallStackForm.Width: W$ ?
 CallStackForm.Height: W$ ?]

[H.CallStackForm: D$ ?
 H.CallStackTree: D$ ?]

[CALLSTACK_TREE 20]

Proc CallStackProc:
    Arguments @hwnd @msg @wParam @lParam
    Uses ebx, esi, edi

    .If D@msg = &WM_CREATE
        Call CallStackDialog_OnCreate D@hwnd
        Mov eax 0

    .Else_if D@msg = &WM_SHOWWINDOW
        If D@wParam = &TRUE
            Call CallStackForm_Refresh
        End_If

    .Else_if D@msg = &WM_CLOSE
        Call 'USER32.DestroyWindow' D@hwnd

    .Else_If D@msg = &WM_DESTROY
        Call DestroyCallStack
        Mov D$H.CallStackForm 0

    .Else_If D@msg = &WM_SIZE
        Call CallStackDialog_OnSize D@hwnd, D@lParam

    .Else_if D@msg = &WM_COMMAND
        Call CallStackDialog_OnCommand D@hwnd, D@wParam, D@lParam

    .Else_if D@msg = &WM_NOTIFY
        Call CallStackDialog_OnNotify D@lParam

    .Else_if D@msg = WM_REFRESH_CONTENT
        Call CallStackForm_Refresh

    .Else_if D@msg = &WM_SETFONT
        SendMessage D$H.CallStackTree, &WM_SETFONT, D@wParam, D@lParam

    .Else_if D@msg = &WM_DRAWITEM
        If D@wParam = 0
            Call DebugDialog_OnDrawMenuItem D@lParam
        End_If
        Mov eax 1

    .Else_if D@msg = &WM_MEASUREITEM
        Mov eax D@lParam
        If D@wParam = 0
          ; menu
            Call DebugDialog_OnMeasureMenuItem D@lParam
        End_If
        Mov eax 1

    .Else
        Call 'USER32.DefWindowProcA' D@hwnd D@msg D@wParam D@lParam
    .End_If
EndP
____________________________________________________________________________________________

; To allow rightclick inside the treeview we override the window proc.

CallStack_OverrideTreeProc:
    Mov D$CallStack.TVProc 0
    Call 'USER32.SetWindowLongA' D$H.CallStackTree, &GWL_WNDPROC, CallStack_InterceptRightClick
    Mov D$CallStack.TVProc eax
ret

[CallStack.TVProc: D$ ?]

Proc CallStack_InterceptRightClick:
    Arguments @hwnd, @msg, @wParam, @lParam
    Uses ebx esi edi

    .If D@msg = &WM_RBUTTONDOWN
      ; Simulate left click (select item) before showing the popup menu
        SendMessage D@hwnd, &WM_LBUTTONDOWN, D@wParam, D@lParam
        SendMessage D@hwnd, &WM_LBUTTONUP, D@wParam, D@lParam
      ; Is this a proc name item? (don't show menu for sub items)
        cmp D$CallStackForm.CurrentEntry 0 | jz L0>>
      ; Check if the user right-clicked onto the item
        Move D$DebugRect D$CallStackForm.CurrentItem
        SendMessage D@hwnd, &TVM_GETITEMRECT, 1, DebugRect
        movzx eax W@lParam
        cmp eax D$DebugRect@left  | jl L0>
        cmp eax D$DebugRect@right | ja L0>
        movzx eax W@lParam+2
        cmp eax D$DebugRect@top    | jl L0>
        cmp eax D$DebugRect@bottom | ja L0>
      ; Show the popup menu at the position of the mouse-click
        movzx eax W@lParam
        movzx ecx W@lParam+2
        Mov D$STRUC.POINT+POINTX eax, D$STRUC.POINT+POINTY ecx
        Call 'USER32.ClientToScreen' D@hwnd, STRUC.POINT
        Call 'USER32.TrackPopupMenu' D$CallStack.PopupMenu, &TPM_LEFTALIGN, D$STRUC.POINT+POINTX, D$STRUC.POINT+POINTY, 0, D$H.CallStackForm, 0 ; << TODO
    .Else_If D@msg = &WM_LBUTTONDBLCLK
        Call CallStackForm_ShowDeclaration ; *TODO* strange effect in source editor
    .End_If
L0: Call 'USER32.CallWindowProcA' D$CallStack.TVProc, D@hwnd, D@msg, D@wParam, D@lParam
EndP
____________________________________________________________________________________________

[CallStack.PopupMenu: D$ ?]

[MCS_SHOW_INVOKE    3200
 MCS_SHOW_DECL      3201
 MCS_SHOW_ALL       3202
 MCS_HIDE_EXTERNAL  3203
 MCS_HIDE_INTRA     3204
 MCS_SHOW_LOCALS    3205]

;[CALLSTACK_SHOWALL 30 CALLSTACK_HIDE_EXTERNAL 31 CALLSTACK_HIDE_INTRA 32
; CALLSTACK_SHOWLOCALS 35]

CallStack_CreatePopupMenu:
    Call 'USER32.CreatePopupMenu' | Mov ebx eax, D$CallStack.PopupMenu eax
    Call AppendMenu ebx, &MF_OWNERDRAW, MCS_SHOW_INVOKE, D$StrShowInvokePtr
    Call AppendMenu ebx, &MF_OWNERDRAW, MCS_SHOW_DECL, D$StrShowDeclPtr
    Call 'USER32.AppendMenuA' ebx, &MF_SEPARATOR, 0, 0
    Call AppendMenu ebx, &MF_OWNERDRAW, MCS_SHOW_ALL, D$StrShowAllCallsPtr
    Call AppendMenu ebx, &MF_OWNERDRAW, MCS_HIDE_EXTERNAL, D$StrHideModCallsPtr
    Call AppendMenu ebx, &MF_OWNERDRAW, MCS_HIDE_INTRA, D$StrHideIMCallsPtr
    Call 'USER32.AppendMenuA' ebx, &MF_SEPARATOR, 0, 0
    Call AppendMenu ebx, &MF_OWNERDRAW+&MF_CHECKED, MCS_SHOWLOCALS, D$StrShowLocalsPtr

    Call 'USER32.CheckMenuRadioItem' ebx, MCS_SHOWALL, MCS_HIDE_INTRA,
        MCS_SHOWALL, &MF_BYCOMMAND
ret
____________________________________________________________________________________________

[TVI:
 @hParent: D$ ?
 @hInsertAfter: D$ ?
 @Item:
 @Item.imask: D$ ?
 @Item.hItem: D$ ?
 @Item.state: D$ ?
 @Item.stateMask: D$ ?
 @Item.pszText: D$ ?
 @Item.cchTextMax: D$ ?
 @Item.iImage: D$ ?
 @Item.iSelectedImage: D$ ?
 @Item.cChildren: D$ ?
 @Item.lParam: D$ ?]
____________________________________________________________________________________________

; ebx = dword parameter / local number (starts with zero)
; edi > Param string (must have room for 100 bytes)

SearchLocalName:
  ; The first local is the parent frame pointer at offset 0.
    lea eax D$ebx*4
    If eax <> 0
        neg eax | jmp SearchStackFrameSymbol
    Else
        Mov eax ' [Ca' | stosd
        Mov eax 'ller' | stosd
        Mov eax ' EBP' | stosd
        Mov eax ']'    | stosd
    End_If
ret

SearchParameterName:
  ; The first param is at EBP+8
    lea eax D$ebx*4+8

SearchStackFrameSymbol:
    Mov edx StackFrameSymbols, ecx D$NumStackFrameSymbols
    jecxz L9>

  ; Search correspondance table - cmp the offset
L0: cmp D$edx+4 eax | je L1>
        add edx 8
    loop L0<
    jmp L9>

  ; Copy the name to the buffer at EDI > " [name]"
L1: Mov edx D$edx
    Mov ecx 97
    Mov al SPC | stosb
    Mov al '['
    Do
        stosb
        Mov al B$edx
        inc edx
        dec ecx | jz L8>
    Loop_Until al < LowSigns
L8: Mov al ']' | stosb
L9: ret
____________________________________________________________________________________________

; edi > CSE (CallStack Entry)

Proc CallStackForm_InsertParameters:

  ; Parameter string reserved on stack
    sub esp 128

    Mov D$TVI@Item.pszText {B$ 'Parameter' EOS}, D$TVI@Item.lParam 0
    SendMessage D$H.CallStackTree, &TVM_INSERTITEM, 0, TVI
    Mov D$TVI@hParent eax

    Mov ebx 0
    Mov esi D$edi+CSE_Address

  ; esi > first parameter
    While ebx < D$edi+CSE_NumParams
        lodsd
        Push edi
            lea edi D$esp+4
            DwordToHex eax
            Call SearchParameterName
            Mov al 0 | stosb
        Pop edi
        Mov D$TVI@Item.pszText esp
        SendMessage D$H.CallStackTree, &TVM_INSERTITEM, 0, TVI
        inc ebx
    EndWhile

    SendMessage D$H.CallStackTree, &TVM_EXPAND, &TVE_EXPAND, D$TVI@hParent
EndP
____________________________________________________________________________________________

; edi > CSE (CallStack Entry)

Proc CallStackForm_InsertLocals:

  ; Local string reserved on stack
    sub esp 128

    Mov D$TVI@Item.pszText {B$ 'Local data' EOS}, D$TVI@Item.lParam 0
    SendMessage D$H.CallStackTree, &TVM_INSERTITEM, 0, TVI
    Mov D$TVI@hParent eax

    Mov ebx 0
    Mov esi D$edi+CSE_Address | sub esi 8

  ; esi > caller ebp
    While ebx < D$edi+CSE_NumLocals
        Mov eax D$esi | sub esi 4
        Push edi
            lea edi D$esp+4
            DwordToHex eax
            Call SearchLocalName
            Mov al 0 | stosb
        Pop edi
        Mov D$TVI@Item.pszText esp
        SendMessage D$H.CallStackTree, &TVM_INSERTITEM, 0, TVI
        inc ebx
    EndWhile

    SendMessage D$H.CallStackTree, &TVM_EXPAND, &TVE_EXPAND, D$TVI@hParent
EndP
____________________________________________________________________________________________

; Check equate contents at ESI for stack frame symbols (relative to EBP). ECX is length.
; Return the signed offset in EAX if a string of the form "EBP+xx" / "EBP-xx" was found,
; zero otherwise. All registers are preserved (messy).

; Note: Only simple expressions with one offset and one op (+/-) are supported (not "EBP+8-4")

ParseFrameOffset:
    Mov eax 0
    cmp ecx 5 | jb L9>

    lodsd | sub ecx 4
    cmp eax 'EBP'+0A00_0000 | je L0>
    cmp eax 'EBP'+0900_0000 | je L0>

L9: ret

L0: shr eax 24 ; Move operator (+/-) in AL

    Push edi ebx edx
      ; Save the byte behind the string in AH and replace with 0
        Mov ah B$esi+ecx, B$esi+ecx 0
        Push eax
            Push esi ecx
                Call TranslateAny
            Pop ecx esi
        Pop edx
      ; DL = operator, DH = saved byte
        Mov B$esi+ecx dh
        On dl = subSign, neg eax
    Pop edx ebx edi
ret
____________________________________________________________________________________________

; Scan the equates table for symbols local to the current callstack entry at EDI and
; fill the table 'StackFrameSymbols'.

[StackFrameSymbols: D$ ? # 128 ; correspondance table [ Symbol name | signed offset ] (dwords)
 NumStackFrameSymbols: D$ ?]     ; number of table entries
[MAX_STACK_FRAME_SYMBOLS 64]

Proc FindStackFrameSymbols:
    Local @PlainLabel, @LabelLen
    Uses edi

    Mov D$NumStackFrameSymbols 0

    Mov al B$edi+CSE_FLAGS

    test al CSEF_HAS_STACKFRAME ZERO  P9>>
    ;test al CSEF_FUZZY_ADDRESS  NOT_ZERO P9>>
    test al CSEF_EXTERNAL NOT_ZERO P9>>

  ; Get symbol name / len
    Mov edi D$edi+CSE_ProcName, D@PlainLabel edi
    Mov ecx 0-1, al 0
    repne scasb
    Mov eax 0-2 | sub eax ecx
    Mov D@LabelLen eax

  ; search the label list for symbols "THISLABEL@..."
    Mov edi D$EquateList, edx D$EquateListLimit
    add edi 5
    While edi < edx
        Mov esi D@PlainLabel, ecx D@LabelLen
        repe cmpsb | jne L0>

            cmp B$edi '@' | jne L0>
            inc edi

          ; Save address of local name without preceding '@'
            Mov ebx D$NumStackFrameSymbols
            Mov D$StackFrameSymbols+ebx*8 edi

          ; Scan to the end of the label name
            Mov al EOI
            Mov ecx edx | sub ecx edi
            repne scasb

          ; Parse equate contents
            Mov esi D$edi, ecx D$edi+4
            Call ParseFrameOffset
            cmp eax 0 | je L1>

          ; Save entry in correspondance table
            Mov D$StackFrameSymbols+ebx*8+4 eax
            inc D$NumStackFrameSymbols

            On D$NumStackFrameSymbols = MAX_STACK_FRAME_SYMBOLS, ExitP

            jmp L1>

L0:     Mov al EOI
        Mov ecx edx | sub ecx edi
        repne scasb
L1:     add edi 10
    EndWhile
EndP
____________________________________________________________________________________________

Proc CallStackForm_BuildTree:
    Local @hProcItem
    Uses edi, ebx, esi

    Call GenerateCallStack

    SendMessage D$H.CallStackTree, &WM_SETREDRAW, &FALSE, 0
    SendMessage D$H.CallStackTree, &TVM_DELETEITEM, 0, &TVI_ROOT

    Mov D$TVI@hParent &TVI_ROOT
    Mov D$TVI@hInsertAfter &TVI_LAST
    Mov D$TVI@Item.imask &TVIF_TEXT+&TVIF_PARAM

    Mov edi D$FirstCallStackEntry
    .While edi <> 0

        If D$CallStackFilter = MCS_HIDE_EXTERNAL
            test B$edi+CSE_Flags CSEF_EXTERNAL NOT_ZERO L0>>
        Else_If D$CallStackFilter = MCS_HIDE_INTRA
          ; filter module internal calls, this is when the current CSE was called
          ; by a function in the same (external) module
            test B$edi+CSE_Flags CSEF_EXTERNAL ZERO L1>
            Mov eax D$edi+CSE_Next
            test B$eax+CSE_Flags CSEF_EXTERNAL ZERO L1>
            Call IsModuleCode D$eax+CSE_ProcAddress
            Mov ebx eax
            Call IsModuleCode D$edi+CSE_ProcAddress
            cmp eax ebx | je L0>>
        End_If

L1:     Mov D$TVI@hParent &TVI_ROOT
        Mov D$TVI@Item.lParam edi
        Mov eax D$edi+CSE_ProcName
        Mov D$TVI@Item.pszText eax
        SendMessage D$H.CallStackTree, &TVM_INSERTITEM, 0, TVI
        Mov D$TVI@hParent eax, D@hProcItem eax

        Call FindStackFrameSymbols
        On D$edi+CSE_NumParams > 0,
            Call CallStackForm_InsertParameters

        Move D$TVI@hParent D@hProcItem

        If D$CallStackShowLocal = 1
            On D$edi+CSE_NumLocals > 0,
                Call CallStackForm_InsertLocals
        End_If

        test B$edi+CSE_Flags CSEF_EXTERNAL NOT_ZERO L0>
            SendMessage D$H.CallStackTree, &TVM_EXPAND, &TVE_EXPAND, D@hProcItem
L0:     Mov edi D$edi+CSE_Next
    .EndWhile

    SendMessage D$H.CallStackTree, &WM_SETREDRAW, &TRUE, 0
    Call 'USER32.InvalidateRect' D$H.CallStackTree, &NULL, &TRUE

EndP

Proc CallStackForm_OnTreeNavigate:
    Arguments @NotifyInfo
    Uses esi ebx

    Mov esi D@NotifyInfo
    On D$esi+8 <> &TVN_SELCHANGED, ExitP
    add esi 12 ; skip notify header
    add esi 4 ; skip action flag
    add esi 40 ; skip old item
    Mov eax D$esi+4 ; H.Item
    Mov D$CallStackForm.CurrentItem eax
    Mov ebx D$esi+36 ; lParam of new item
    Mov D$CallStackForm.CurrentEntry ebx

    Mov eax 0
    On ebx <> 0, Mov eax D$ebx+CSE_ProcAddress
    Call IsProcessCode eax
    xor eax 1
    Call 'USER32.EnableMenuItem' D$CallStack.PopupMenu, MCS_SHOW_DECL, eax
    If ebx <> 0
        Mov ebx D$ebx+CSE_Address
        On ebx <> 0, Mov ebx D$ebx-4
    End_If
    Call IsProcessCode ebx
    xor eax 1
    Call 'USER32.EnableMenuItem' D$CallStack.PopupMenu, MCS_SHOW_INVOKE, eax

EndP

[CallStackShowLocal: 1
 CallStackFilter: MCS_SHOWALL]

Proc CallStackForm_Refresh:

    Call CallStackForm_BuildTree
EndP

[CallStackForm.CurrentEntry: D$ ?
 CallStackForm.CurrentItem: D$ ?]

Proc CallStackForm_ShowEvoke:

    Mov eax D$CallStackForm.CurrentEntry
    On eax = 0, ExitP
    Mov edx D$eax
    Mov ecx D$edx-4 ; get return address from the stack-copy
    dec ecx
    Call SourceDebugPos ecx
EndP

Proc CallStackForm_ShowDeclaration:

    Mov eax D$CallStackForm.CurrentEntry
    On eax = 0, ExitP
    Call SourceDebugPos D$eax+4
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; DEBUGGER MAIN DIALOG (Registers & Execution Control)
____________________________________________________________________________________________
____________________________________________________________________________________________


[SendMessage | #=4 | Call 'USER32.SendMessageA' #1 #2 #3 #4]
[CopyString | #=1 | Mov esi #1 | R9: | cmp B$esi 0 | je R9> | movsb | jmp R9< | R9:]
____________________________________________________________________________________________

[GPRRegMap: CONTEXT@regEax CONTEXT@regEbx CONTEXT@regEcx CONTEXT@RegEdx CONTEXT@regEsi CONTEXT@regEdi CONTEXT@regEbp CONTEXT@regEsp]
[SegRegMap: CONTEXT@regCs CONTEXT@regDs CONTEXT@regEs CONTEXT@regFs CONTEXT@regGs CONTEXT@regSs]
[DbgRegMap: CONTEXT@regEip CONTEXT@iDr0 CONTEXT@iDr1 CONTEXT@iDr2 CONTEXT@iDr3 CONTEXT@iDr6 CONTEXT@iDr7]

; Format / Conversion tables
[GPRFormats: D$ 9 FmtHexPtr FmtUDecPtr FmtSDecPtr FmtBinaryPtr FmtPUBPtr FmtPSBPtr FmtPUWPtr FmtPSWPtr FmtAsciiPtr]
[GPRConvert: toHex toUDword toSDword toBinary toUByte toSByte toUWord toSWord toAscii]
[FPUFormats: D$ 3 FmtFloatPtr FmtHexPtr FmtBinaryPtr]
[FPUConvert: toExtended toHex toBinary]
[MMXFormats: D$ 9 FmtHexPtr FmtBinaryPtr FmtPUBPtr FmtPSBPtr FmtPUWPtr FmtPSWPtr FmtPUDPtr FmtPSDPtr FmtPFPtr]
[MMXConvert: toHex toBinary toUByte toSByte toUWord toSWord toUDword toSDword toFloat]
[SSEFormats: D$ 10 FmtHexPtr FmtBinaryPtr FmtPFPtr FmtPDPtr FmtPUBPtr FmtPSBPtr FmtPUWPtr FmtPSWPtr FmtPUDPtr FmtPSDPtr FmtPUQPtr FmtPSQPtr]
[SSEConvert: toHex toBinary toFloat toDouble toUByte toSByte toUWord toSWord toUDword toSDword toHex toHex]
[SegFormats: D$ 1 FmtHexPtr]
[@SegConvert: toSegHex]
[DbgFormats: D$ 1 FmtHexPtr]
[DbgConvert: toHex]
[MemFormats: D$ 5 FmtHexAnsiPtr FmtHexDWPtr FmtHexWPtr FmtFloatsPtr FmtHexCookedPtr]
[MemConvert: toHexWithAnsi toHexDwords toHexWords toFloats toHexWithCookedAnsi]

; Buffers that hold the converted strings, used as sources while drawing the items
[ValueReg0: B$ ? # 256
 ValueReg1: B$ ? # 256
 ValueReg2: B$ ? # 256
 ValueReg3: B$ ? # 256
 ValueReg4: B$ ? # 256
 ValueReg5: B$ ? # 256
 ValueReg6: B$ ? # 256
 ValueReg7: B$ ? # 256]

[RegValues:
 D$ ValueReg0
 D$ ValueReg1
 D$ ValueReg2
 D$ ValueReg3
 D$ ValueReg4
 D$ ValueReg5
 D$ ValueReg6
 D$ ValueReg7]

Proc DebugDialog_OnFormatChange:
    Arguments @hwnd @Index

        Mov B$HexSeparator 1
        Mov ebx 0
        .While ebx < 8
            Mov eax D$TabID, edx D@Index
            .If eax = 0 ; GPR
                Mov esi D$GPRRegMap+ebx*4
                Mov ecx 4
                Call D$GPRConvert+edx*4
            .Else_If eax = 1 ; FPU
                ; test for empty register slots
                Mov eax D$CONTEXT@FloatSave.TagWord
                ; get top of stack (ecx = TOS * 2)
                Mov ecx D$CONTEXT@FloatSave.StatusWord
                shr ecx 10 | and ecx 00_1110
                lea ecx D$ebx*2+ecx
                and ecx 0F
                shr eax cl | and eax 3
                ;shl eax 2 | lea ecx D$ebx*2 | shl eax cl
                ;shr eax 16 | and eax 3 ; eax = TagBits for register (11: empty)
                If eax = 0011
                    Mov edi StringBuf
                    Mov D$edi 'EMPT', W$edi+4 'Y'
                Else
                    Mov esi CONTEXT@FloatSave.RegisterArea
                    imul eax ebx 10
                    add esi eax
                    Mov ecx 10
                    Call D$FPUConvert+edx*4
                End_If
            .Else_If eax = 2 ; MMX [V2.1b]
                imul esi ebx 10
                add esi CONTEXT@FloatSave.RegisterArea
                ;Mov esi ebx | shl esi 4
                ;add esi C.regMM
                Mov ecx 8
                Call D$MMXConvert+edx*4
            .Else_If eax = 3 ; SSE
                Mov esi ebx | shl esi 4
                add esi CONTEXT@regXMM
                Mov ecx 16
                Call D$SSEConvert+edx*4
            .Else_If eax = 4 ; Segment
                If ebx < 6
                    Mov esi D$SegRegMap+ebx*4
                    lea edi D$LinearSegmentAddresses+ebx*8
                    Call toSegHex
                    ;Call D$SegConvert+edx*4
                Else
                    Mov edi StringBuf
                    Mov B$edi 0
                End_If
            .Else_if eax = 5 ; Debug & EIP
                If ebx < 7
                    Mov esi D$DbgRegMap+ebx*4
                    Mov ecx 4
                    Call D$DbgConvert+edx*4
                Else
                    Mov edi StringBuf
                    Mov B$edi 0
                End_If
            .End_If

            Mov esi edi, edi D$RegValues+ebx*4
            Do | movsb | Loop_Until B$esi-1 = 0

            inc ebx
        .End_While

        Mov ecx D$TabID, eax D@Index, D$TabFormats+ecx*4 eax
        Call 'USER32.InvalidateRect' D$H.RegList, &NULL, &TRUE
        Call DebugDialog_RedrawRegisterButtons D@hwnd
EndP
____________________________________________________________________________________________

; Output register-name/value pair. The name is chosen by the tab-index, the value
; by the index provided in the DrawItemStructure passed by WM_DRAWITEM.

[ARVB.Background.Name:
 B$ 0_BB 0_BB 0_BB 0_00
 B$ 0_CC 0_CC 0_CC 0_00
 B$ 0_FF 0_FF 0_CC 0_00
 ARVB.Background.Value:
 B$ 0_DD 0_DD 0_DD 0_00
    0_FF 0_FF 0_FF 0_00
    0_00 0_00 0_CC 0_00]

[GPRegs:
 B$ 'EAX' EOS
 B$ 'EBX' EOS
 B$ 'ECX' EOS
 B$ 'EDX' EOS
 B$ 'ESI' EOS
 B$ 'EDI' EOS
 B$ 'EBP' EOS
 B$ 'ESP' EOS]

[STRegs:
 B$ 'ST0' EOS
 B$ 'ST1' EOS
 B$ 'ST2' EOS
 B$ 'ST3' EOS
 B$ 'ST4' EOS
 B$ 'ST5' EOS
 B$ 'ST6' EOS
 B$ 'ST7' EOS]

[MMXRegs:
 B$ 'MM0' EOS
 B$ 'MM1' EOS
 B$ 'MM2' EOS
 B$ 'MM3' EOS
 B$ 'MM4' EOS
 B$ 'MM5' EOS
 B$ 'MM6' EOS
 B$ 'MM7' EOS]

[SSERegs:
 B$ 'XMM0' EOS
 B$ 'XMM1' EOS
 B$ 'XMM2' EOS
 B$ 'XMM3' EOS
 B$ 'XMM4' EOS
 B$ 'XMM5' EOS
 B$ 'XMM6' EOS
 B$ 'XMM7' EOS]

[SegRegs:
 B$ 'CS' EOS
 B$ 'DS' EOS
 B$ 'ES' EOS
 B$ 'FS' EOS
 B$ 'GS' EOS
 B$ 'SS' EOS
 B$ SPC EOS
 B$ SPC EOS]

[DbgRegs:
 B$ 'EIP' EOS
 B$ 'DR0' EOS
 B$ 'DR1' EOS
 B$ 'DR2' EOS
 B$ 'DR3' EOS
 B$ 'DR6' EOS
 B$ 'DR7' EOS
 B$ SPC EOS]

[RegSets:
 D$ GPRegs
 D$ STRegs
 D$ MMXRegs
 D$ SSERegs
 D$ SegRegs
 D$ DbgRegs]

[ItemRect:
 @x1: D$ ?
 @y1: D$ ?
 @x2: D$ ?
 @y2: D$ ?]

[ItemString: B$ ? # 128]

[DRAWITEM_CTLTYPE 0
 DRAWITEM_CTLID 4
 DRAWITEM_ITEMID 8
 DRAWITEM_ITEMACTION 12
 DRAWITEM_ITEMSTATE 16
 DRAWITEM_HWNDITEM 20
 DRAWITEM_HDC 24
 DRAWITEM_RCITEM_LEFT 28
 DRAWITEM_RCITEM_TOP 32
 DRAWITEM_RCITEM_RIGHT 36
 DRAWITEM_RCITEM_BOTTOM 40
 DRAWITEM_ITEMDATA 44]

Proc DebugDialog_OnDrawRegisterItem:
    Arguments @DrawItemStruc
    Local @Brush
    Uses ebx edi

    Mov ebx D@DrawItemStruc

    Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0

  ; Print Register name
    Mov eax D$ebx+DRAWITEM_RCITEM_LEFT | Mov D$ItemRect@x1 eax
    add eax 35 | Mov D$ItemRect@x2 eax
    Move D$ItemRect@y1 D$ebx+DRAWITEM_RCITEM_TOP
    Move D$ItemRect@y2 D$ebx+DRAWITEM_RCITEM_BOTTOM

    Mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    Call 'GDI32.CreateSolidBrush' D$ARVB.Background.Name+edi*4 | Mov D@Brush eax
    Call 'USER32.FillRect' D$ebx+DRAWITEM_HDC, ItemRect, D@Brush
    Call 'GDI32.DeleteObject' D@Brush
    Call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, D$ARVB.Background.Name+edi*4

    Mov ecx D$TabID, edi D$RegSets+ecx*4
    Mov edx 0, al 0
    While edx < D$ebx+DRAWITEM_ITEMID ; item index
        Mov ecx 0-1
        repne scasb
        inc edx
    EndWhile

    Call 'USER32.DrawTextA' D$ebx+DRAWITEM_HDC, edi, 0-1, ItemRect,
         (&DT_SINGLELINE+&DT_CENTER+&DT_VCENTER)

  ; Hilite changed regs
    If D$TabId = 0 ; GPR
        Mov ecx D$ebx+DRAWITEM_ITEMID
        bt D$GPR_Modified_Mask ecx | jnc L0>
        Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0C0
L0: End_If

  ; Print value
    Move D$ItemRect@x1 D$ItemRect@x2
    Move D$ItemRect@x2 D$ebx+DRAWITEM_RCITEM_RIGHT

    Mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    Call 'GDI32.CreateSolidBrush' D$ARVB.Background.Value+edi*4 | Mov D@Brush eax
    Call 'USER32.FillRect' D$ebx+DRAWITEM_HDC, ItemRect, D@Brush
    Call 'GDI32.DeleteObject' D@Brush
    Call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, D$ARVB.Background.Value+edi*4

    Mov ecx D$ebx+DRAWITEM_ITEMID | Mov edi D$RegValues+ecx*4
    Call 'USER32.DrawTextA' D$ebx+DRAWITEM_HDC, edi, 0-1, ItemRect,
         (&DT_SINGLELINE+&DT_CENTER+&DT_VCENTER)

EndP
____________________________________________________________________________________________

; Create the tabs for the different register types. First check if they are available.

[STR.A.RegistreGeneral: B$ 'General' EOS]
[STR.A.RegistreFPU: B$ 'FPU' EOS]
[STR.A.RegistreMMX: B$ 'MMX' EOS]
[STR.A.RegistreSSE: B$ 'SSE' EOS]

[STR.A.RegistreSegment: B$ 'Segment' EOS]
[STR.A.RegistreDebug: B$ 'Debug' EOS]

[H.DebugFormatCombo: D$ ?]

Proc DebugDialog_CreateRegisterTabs:
    Arguments @hwnd
    Local @Index
    ; Tag Dialog 1010

      ; Create register listbox
        movzx ecx W$DebugDialog.Width | sub ecx 6
        Mov edx 53 ;Mov edx D$DebugDialog.RebarHeight | add edx 50

        Call 'USER32.CreateWindowExA' &WS_EX_LEFT+&WS_EX_CLIENTEDGE,
                                      {B$ 'LISTBOX' EOS},
                                      {B$ 'Register' EOS},
                                      &WS_CHILD+&WS_CLIPSIBLINGS+&WS_VISIBLE+&LBS_NOSEL+&LBS_OWNERDRAWFIXED,
                                      3,
                                      edx,
                                      ecx,
                                      138,
                                      D$H.DebugDialog,
                                      DEBUGDLG_REG_LIST,
                                      D$H.Instance,
                                      0

        Mov D$H.RegList eax

      ; Create format combo
        movzx ecx W$DebugDialog.Width | sub ecx 122
        Mov edx 29 ;Mov edx D$DebugDialog.RebarHeight | add edx 26

        Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                      {B$ 'COMBOBOX' EOS},
                                      {B$ 'Representation' EOS},
                                      &WS_CHILD+&WS_CLIPSIBLINGS+&WS_VISIBLE+&CBS_DROPDOWNLIST+&CBS_HASSTRINGS,
                                      120,
                                      edx,
                                      ecx,
                                      200,
                                      D$H.DebugDialog,
                                      DEBUGDLG_FORMAT_COMBO,
                                      D$H.Instance,
                                      0

        Mov D$H.DebugFormatCombo eax

        SendMessage eax, &WM_SETFONT, D$H.DialogFont, &TRUE

      ; Create static control
        Mov edx 32 ;Mov edx D$DebugDialog.RebarHeight | add edx 29

        Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                      {B$ 'STATIC' EOS},
                                      D$StrDataFmtPtr,
                                      &WS_CHILD+&WS_CLIPSIBLINGS+&WS_VISIBLE+&SS_LEFT,
                                      7,
                                      edx,
                                      140,
                                      16,
                                      D$H.DebugDialog,
                                      3,
                                      D$H.Instance,
                                      0

        SendMessage eax, &WM_SETFONT, D$H.DialogFont, &TRUE

      ; Create tab control
        movzx ecx W$DebugDialog.Width
        Mov edx 6 ;Mov edx D$DebugDialog.RebarHeight | add edx 4

        Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                      {B$ "SysTabControl32" EOS},
                                      {B$ "RegisterTab" EOS},
                                      &WS_CHILD+&WS_CLIPSIBLINGS+&WS_VISIBLE, ;+&TCS_FLATBUTTONS+&TCS_HOTTRACK+&TCS_BUTTONS,
                                      0,
                                      edx,
                                      ecx,
                                      184,
                                      D$H.DebugDialog,
                                      DEBUGDLG_REGISTER_TAB,
                                      D$H.Instance,
                                      0

        Mov ebx eax

        SendMessage eax, &WM_SETFONT, D$H.DialogFont, &TRUE

      ; Add tabs
        Mov D@Index 0
        Mov D$TabItem@imask &TCIF_TEXT+&TCIF_PARAM

        Mov D$TabItem@pszText STR.A.RegistreGeneral
        Mov D$TabItem@lParam 0
        SendMessage ebx, &TCM_INSERTITEM, D@Index, TabItem
        On eax = 0-1, Call ReportWinError {B$ 'TCM_INSERTITEM' EOS}
        inc D@Index

        test D$CPUFlags FLAG_FPU ZERO L0>

        Mov D$TabItem@pszText STR.A.RegistreFPU
        Mov D$TabItem@lParam 1
        SendMessage ebx, &TCM_INSERTITEM, D@Index, TabItem
        inc D@Index

L0:     test D$CPUFlags FLAG_MMX ZERO L0>

        Mov D$TabItem@pszText STR.A.RegistreMMX
        Mov D$TabItem@lParam 2
        SendMessage ebx, &TCM_INSERTITEM, D@Index, TabItem
        inc D@Index

L0:     test D$CPUFlags FLAG_SSE ZERO L0>

        Mov D$TabItem@pszText STR.A.RegistreSSE
        Mov D$TabItem@lParam 3
        SendMessage ebx, &TCM_INSERTITEM, D@Index, TabItem
        inc D@Index

L0:     Call SelectTab ebx, DEBUGDLG_REGISTER_TAB, 0

        Call DebugDialog_InitRegisterListBox D@hwnd
        Call DebugDialog_CreateRegisterButtons D@hwnd
EndP
____________________________________________________________________________________________

; Show/Hide tabs for advanced registers (segments, debug).

Proc DebugDialog_ShowAdvancedTabs:
    Arguments @hwnd @Show
    Local @H.Tab @Index

        Call 'USER32.GetDlgItem' D@hwnd, DEBUGDLG_REGISTER_TAB
        Mov D@H.Tab eax

        SendMessage D@H.Tab, &TCM_GETITEMCOUNT, 0, 0
        Mov D@Index eax

        .If D@Show = &TRUE
            Mov D$TabItem@imask &TCIF_TEXT+&TCIF_PARAM

            Mov D$TabItem@pszText STR.A.RegistreSegment
            Mov D$TabItem@lParam 4
            SendMessage D@H.Tab, &TCM_INSERTITEM, D@Index, TabItem
            inc D@Index

            Mov D$TabItem@pszText STR.A.RegistreDebug
            Mov D$TabItem@lParam 5
            SendMessage D@H.Tab, &TCM_INSERTITEM, D@Index, TabItem
        .Else
            SendMessage D@H.Tab, &TCM_GETCURSEL, 0, 0 | Mov ebx eax
            dec D@Index
            SendMessage D@H.Tab, &TCM_DELETEITEM, D@Index, 0
            dec D@Index
            SendMessage D@H.Tab, &TCM_DELETEITEM, D@Index, 0
            On ebx >= D@Index, Mov ebx 0
            Call SelectTab D@hwnd, DEBUGDLG_REGISTER_TAB, ebx
        .End_If
        Call 'USER32.InvalidateRect' D@hwnd &NULL &TRUE
EndP
____________________________________________________________________________________________

; Initially fill the listbox with eight items. The listbox does NOT contain strings, so
; we just set the address of the buffer as item data. Another issue: When the listbox
; is enabled it blocks the mouse from clicking on the register buttons, therefore it is
; disabled.

Proc DebugDialog_InitRegisterListBox:
    Arguments @hwnd

        Mov eax D$H.RegList
        Call 'USER32.EnableWindow' eax, &FALSE
        Mov esi RegValues, ebx 0
        While ebx < 8
            lodsd
            Mov B$eax 0
            SendMessage D$H.RegList, &LB_ADDSTRING, 0, eax
            inc ebx
        EndWhile
EndP
____________________________________________________________________________________________

; Create the buttons for the general purpose registers.

Proc DebugDialog_CreateRegisterButtons:
    Arguments @hwnd

        Mov ebx 0, esi GPRegs
        .While ebx < 8
            ; Get position of item and transform in debug dialogs client coordinates
            SendMessage D$H.RegList, &LB_GETITEMRECT, ebx, DebugRect
            Mov ecx D$DebugRect@bottom
            sub ecx D$DebugRect@top
            Mov D$DebugRect@height ecx
            Call 'USER32.ClientToScreen' D$H.RegList, DebugRect
            Call 'USER32.ScreenToClient' D@hwnd, DebugRect
            ; Create a button
            Mov eax DEBUGDLG_FIRSTREG_BUTTON
            add eax ebx

            Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                          ButtonClassName,
                                          esi,
                                          &WS_CHILD,
                                          D$DebugRect@left,
                                          D$DebugRect@top,
                                          35,
                                          D$DebugRect@height,
                                          D@hwnd,
                                          eax,
                                          D$H.Instance,
                                          &NULL

            add esi 4

            inc ebx

        .EndWhile

EndP
____________________________________________________________________________________________

; The dialog has been resized, adjust the width and height of the controls.

Proc DebugDialog_OnSize:
    Arguments @hwnd, @WidthHeight

      ; calculate the delta values (pixel difference old -> new size)
        movzx eax W$DebugDialog.Width
        movzx esi W@WidthHeight
        sub esi eax
        movzx eax W$DebugDialog.Height
        movzx edi W@WidthHeight+2
        sub edi eax

        Move D$DebugDialogSize D@WidthHeight

        Call AdjustControlSize D@hwnd, DEBUGDLG_REGISTER_TAB, esi, 0
        Call AdjustControlSize D@hwnd, DEBUGDLG_FORMAT_COMBO, esi, 0
        Call AdjustControlSize D@hwnd, DEBUGDLG_REG_LIST, esi, 0
        Call AdjustControlSize D@hwnd, DEBUGDLG_DATA_TAB, esi, edi
        Call DebugDialog_AdjustDataTabSize D@hwnd
        Call 'USER32.InvalidateRect' D@hwnd &NULL &TRUE

      ; notify rebar
        movzx eax W$DebugDialog.Width
        SendMessage D$H.DebugRebar, &WM_SIZE, eax, 0

        Mov eax 0
EndP
____________________________________________________________________________________________

; The tab-selection has changed, refill format combo.

[TabFormats: D$ ? # 6]
[RegFormats:
 D$ GPRFormats
 D$ FPUFormats
 D$ MMXFormats
 D$ SSEFormats
 D$ SegFormats
 D$ DbgFormats]

[TabID: D$ ?]

Proc DebugDialog_OnChangeRegisterTab:
    Arguments @hwnd

    Call 'USER32.GetDlgItem' D@hwnd, DEBUGDLG_REGISTER_TAB | Mov ebx eax
    SendMessage ebx, &TCM_GETCURSEL, 0, 0
    SendMessage ebx, &TCM_GETITEM, eax, TabItem
    Move D$TabID D$TabItem@lParam

    Call DebugDialog_UpdateRegisterButtons D@hwnd

    ; Refill format/representation combo
    Mov ebx D$H.DebugFormatCombo
    SendMessage ebx, &CB_RESETCONTENT, 0, 0
    Mov ecx D$TabID, esi D$RegFormats+ecx*4
    lodsd | Mov ecx eax
D0:     Push ecx
            lodsd
            If D$UnicodeStrings = 0
                SendMessage ebx, &CB_ADDSTRING, 0, D$eax
            Else
                Call 'USER32.SendMessageW' ebx, &CB_ADDSTRING, 0, D$eax
            End_If
        Pop ecx
    loop D0<

    Mov ecx D$TabID
    SendMessage ebx, &CB_SETCURSEL, D$TabFormats+ecx*4, 0
    SendMessage D@hwnd, &WM_COMMAND, (&CBN_SELCHANGE shl 16 or DEBUGDLG_FORMAT_COMBO), ebx
EndP
____________________________________________________________________________________________

[H.DataView: D$ ?
 H.MemoryInspector: D$ ?
 H.CurrentDataPage: D$ ?]

Proc DebugDialog_CreateDataTab:
    Arguments @hwnd

      ; Create tab control
        movzx ecx W$DebugDialog.Width
        movzx edx W$DebugDialog.Height | sub edx 195

        Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                      {B$ "SysTabControl32" EOS},
                                      {B$ "DataTab" EOS},
                                      &WS_CHILD+&WS_CLIPSIBLINGS+&WS_VISIBLE+&TCS_FLATBUTTONS, ;+&TCS_FLATBUTTONS+&TCS_HOTTRACK+&TCS_BUTTONS,
                                      0,
                                      195,
                                      ecx,
                                      edx,
                                      D$H.DebugDialog,
                                      DEBUGDLG_DATA_TAB,
                                      D$H.Instance,
                                      0

        Mov ebx eax

        SendMessage eax &WM_SETFONT, D$H.DialogFont, &TRUE

      ; Add tabs
        Mov D$TabItem@imask &TCIF_TEXT
        Mov D$TabItem@pszText DataView
        SendMessage ebx, &TCM_INSERTITEM, 0, TabItem
        Mov D$TabItem@pszText MemoryInspector
        SendMessage ebx, &TCM_INSERTITEM, 1, TabItem
        Mov D$TabItem@pszText CallStack
        SendMessage ebx, &TCM_INSERTITEM, 2, TabItem
        Mov D$TabItem@pszText Log
        SendMessage ebx, &TCM_INSERTITEM, 3, TabItem
        Mov D$TabItem@pszText AddressSpace
        SendMessage ebx, &TCM_INSERTITEM, 4, TabItem

      ; Create sub windows
        Call 'USER32.CreateDialogParamA' D$H.Instance, 1011, ebx, DataViewProc, 0
        Mov D$H.DataView eax
        Mov D$H.CurrentDataPage eax
        Call 'USER32.CreateDialogParamA' D$H.Instance, 1012, ebx, MemoryInspectorProc, 0
        Mov D$H.MemoryInspector eax
        Call 'USER32.ShowWindow' eax, &SW_HIDE

        ;Call 'USER32.CreateDialogParamA' D$H.Instance, 1015, ebx, CallStackProc, 0
        Call CreateNewForm_CallStackForm ebx
        Call 'USER32.ShowWindow' D$H.CallStackForm, &SW_HIDE

        Call CreateNewForm_LogForm ebx
        Call 'USER32.ShowWindow' D$H.LogForm, &SW_HIDE

        Call CreateNewForm_AddressSpaceForm ebx
        Call 'USER32.ShowWindow' D$H.ASForm, &SW_HIDE

        Call DebugDialog_AdjustDataTabSize D@hwnd
EndP
____________________________________________________________________________________________

[FPURndModes: FPURndNearest FPURndDown FPURndUp FPURndTrunc]

[FPUPrec24: B$ '24 bits (single)' EOS]
[FPUPrec53: B$ '53 bits (double)' EOS]
[FPUPrec64: B$ '64 bits (extended)' EOS]

[FPUPrecModes: FPUPrec24 0 FPUPrec53 FPUPrec64]

[NoException: B$ 'No Exception' EOS]

DebugDialog_GetFPUStatus:

    ; Output tag word
    CopyString FPUTagWord
    Push edi
        Mov esi CONTEXT@FloatSave.TagWord, ecx 2 | Call toBinary
        Mov ecx StringBufTail | sub ecx edi
        Mov esi edi
    Pop edi
    rep movsb

    Mov W$edi 0A0D | add edi 2

    ; Output control word
    CopyString FPUControlWord
    Push edi
        Mov esi CONTEXT@FloatSave.ControlWord, ecx 2 | Call toBinary
        Mov ecx StringBufTail | sub ecx edi
        Mov esi edi
    Pop edi
    rep movsb

    Mov W$edi 0A0D | add edi 2

    ; Rounding mode
    CopyString FPURoundingMode
    movzx eax W$CONTEXT@FloatSave.ControlWord
    shr eax 10 | and eax 3
    CopyString D$FPURndModes+eax*4

    Mov W$edi 0A0D | add edi 2

    ; Precision
    CopyString FPUPrecision
    movzx eax W$CONTEXT@FloatSave.ControlWord
    shr eax 8 | and eax 3
    CopyString D$FPUPrecModes+eax*4
    Mov W$edi 0A0D | add edi 2

    ; Output statusword
    CopyString FPUStatusWord
    Push edi
        Mov esi CONTEXT@FloatSave.Statusword, ecx 2 | Call toBinary
        Mov ecx StringBufTail | sub ecx edi
        Mov esi edi
    Pop edi
    rep movsb

    Mov W$edi 0A0D | add edi 2

    movzx eax W$CONTEXT@FloatSave.StatusWord
    Mov esi NoException
    test al 01 ZERO L0>
    Mov esi FLT_INVALID_OPERATION
L0: test al 02 ZERO L0>
    Mov esi FLT_DENORMAL_OPERAND
L0: test al 04 ZERO L0>
    Mov esi FLT_DIVIDE_BY_ZERO
L0: test al 08 ZERO L0>
    Mov esi FLT_OVERFLOW
L0: test al 010 ZERO L0>
    Mov esi FLT_UNDERFLOW
L0: test al 020 ZERO L0>
    Mov esi FLT_INEXACT_RESULT
L0: test al 040 ZERO L0>
    Mov esi FLT_STACK_CHECK
L0: While B$esi <> 0
        movsb
    End_While
    Mov B$edi 0

ret

____________________________________________________________________________________________

[CPUFeatures: B$ 'CPU Features:' EOS]
[ConditionMove: B$ 'Conditional Move Instructions (CMOV / FCMOV / FCOMI)' EOS]

DebugDialog_GetCPUInfo:

    CopyString CPUVendor
    Mov W$edi 0A0D | add edi 2

    Mov esi CPUName
    While B$esi = SPC
        inc esi
    EndWhile
    While B$esi <> 0
        movsb
    EndWhile
    Mov D$edi 0A0D0A0D | add edi 4

    CopyString CPUFeatures
    Mov W$edi 0A0D | add edi 2

  ; Scan the general flags
    Mov edx D$CPUFlags

    test edx FLAG_MMX ZERO L0>
    Mov D$edi 'MMX,', B$edi+4 SPC
    add edi 5

L0: test edx FLAG_SSE ZERO L0>
    Mov D$edi 'SSE,', B$edi+4 SPC
    add edi 5

L0: test edx FLAG_SSE2 ZERO L0>
    Mov D$edi 'SSE2', W$edi+4 ', '
    add edi 6
L0: sub edi 2
    Mov W$edi 0A0D | add edi 2

    test edx FLAG_CMOV ZERO L0>
    CopyString ConditionMove
L0: Mov W$edi 0A0D | add edi 2

  ; Scan extended flags
    Mov edx D$CPUFlagsEx

    test edx FLAG_EX_MMX ZERO L0>
    Mov D$edi 'AMD ', D$edi+4 'MMX ', D$edi+8 'Exte', D$edi+12 'nsio', D$edi+16 'ns, '
    add edi 20
L0: test edx FLAG_EX_3DNOW ZERO L0>
    Mov D$edi '3dno', D$edi+4 'w,  '
    add edi 7
L0: test edx FLAG_EX_3DNOWEX ZERO L0>
    Mov D$edi '3dno', D$edi+4 'w Ex', D$edi+8 'tens', D$edi+12 'ions', W$edi+16 ', '
    add edi 18
L0: sub edi 2
    Mov W$edi 0A0D | add edi 2

    Mov B$edi 0
ret
____________________________________________________________________________________________

; Set the flag checkboxes (button-style) according to the flag register

[FlagMasks: 0800 080 040 01 04 0400 0200 0100 010]
[FPUFlagMasks: 04000 0400 0200 0100]

Proc DebugDialog_UpdateFlags:
    Arguments @hwnd

        ; update the eflags
        Mov ebx D$CONTEXT@regFlag, edi 90, esi FlagMasks
        Do
            Mov edx &FALSE
            lodsd
            test ebx eax ZERO L0>
            inc edx
L0:         SendMessage D$H.DebugFlagBar, &TB_CHECKBUTTON, edi, edx
            ;Call 'USER32.SendDlgItemMessageA' D@hwnd, edi, &BM_SETCHECK, edx, 0
            inc edi
        Loop_Until edi > 98

        ; update FPU flags
        Mov ebx D$CONTEXT@FloatSave.StatusWord, edi 101, esi FPUFlagMasks
        Do
            Mov edx &FALSE
            lodsd
            test ebx eax ZERO L0>
            inc edx
L0:         SendMessage D$H.DebugFPUbar, &TB_CHECKBUTTON, edi, edx
            ;Call 'USER32.SendDlgItemMessageA' D@hwnd, edi, &BM_SETCHECK, edx, 0
            inc edi
        Loop_Until edi > 104
EndP
____________________________________________________________________________________________

Proc DebugDialog_UpdateRegisterButtons:
    Arguments @hwnd

        On B$DebuggerReady = &FALSE, ExitP

        .If D$TabID = 0
            Mov ebx 0
            While ebx < 8
                Mov eax D$GPRRegMap+ebx*4
                Call IsProcessMemory D$eax
                Mov edi eax

                Mov eax ebx
                add eax DEBUGDLG_FIRSTREG_BUTTON
                Call 'USER32.GetDlgItem' D@hwnd, eax
                Mov esi eax
                Call 'USER32.ShowWindow' esi, &SW_SHOW
                Call 'USER32.EnableWindow' esi, edi
                inc ebx
            EndWhile
        .Else
            Mov ebx DEBUGDLG_FIRSTREG_BUTTON
            While ebx <= DEBUGDLG_LASTREG_BUTTON
                Call 'USER32.GetDlgItem' D@hwnd, ebx
                Call 'USER32.ShowWindow' eax, &SW_HIDE
                inc ebx
            EndWhile
        .End_If
EndP

Proc DebugDialog_RedrawRegisterButtons:
    Arguments @hwnd

        Mov ebx DEBUGDLG_FIRSTREG_BUTTON
        While ebx <= DEBUGDLG_LASTREG_BUTTON
            Call 'USER32.GetDlgItem' D@hwnd, ebx
            Call 'USER32.InvalidateRect' eax, &NULL, &TRUE
            inc ebx
        EndWhile
EndP
____________________________________________________________________________________________

Proc DebugDialog_AdjustDataTabSize:
    Arguments @hwnd
    Local @H.Tab
    Uses ebx

        Call 'USER32.GetDlgItem' D@hwnd, DEBUGDLG_DATA_TAB
        Mov D@H.Tab eax

        Call 'USER32.GetClientRect' D@H.Tab, DebugRect
        SendMessage D@H.Tab, &TCM_ADJUSTRECT, &FALSE, DebugRect
        Mov eax D$DebugRect@left
        Mov ebx D$DebugRect@top
        Mov ecx D$DebugRect@right
        Mov edx D$DebugRect@bottom
        sub ecx eax
        sub edx ebx
        Call 'USER32.SetWindowPos' D$H.CurrentDataPage, 0, eax, ebx, ecx, edx, &SWP_NOZORDER
EndP
____________________________________________________________________________________________

[CONTINUE_RUN 0 CONTINUE_STEP 1 CONTINUE_STEPOVER 2 CONTINUE_RETURNTOCALLER 3]

[ContinueMode: D$ ?] ; is used by debug thread

Proc DebugDialog_ContinueDebuggee:
    On B$IsDebugEvent = &FALSE, ExitP

    Call DebugDialog_EnableContinueMenu &FALSE

    Move D$ContinueMode D$UserWants

    If B$ContinueMode = CONTINUE_STEPOVER
        Call NextInstructionDecode ; decode again - might be overwritten by callstackscanner
        Call IsMultiStepInstruction
        On eax = &FALSE, Mov B$ContinueMode CONTINUE_STEP
    Else_If B$ContinueMode = CONTINUE_RUN
        Mov D$LastSourcePos 0
    End_If

    Call 'USER32.SetWindowTextA' D$H.DebugDialog, {B$ 'Running ...' EOS}

    Call 'KERNEL32.SetEvent' D$UserInputEvent
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; Debug dialog image list initialisation & finalization.

[DebugDialog_ImageList: D$ ?]

Proc DebugDialog_CreateImageList:
    Local @Image, @Mask

  ; Create the images
    Call 'USER32.LoadImageA' D$H.Instance, 10, &IMAGE_BITMAP, 0, 0, 0
    If eax = 0
        Call ReportWinError {B$ 'DebugDialog_CreateImageList: LoadImage (1)' EOS}
    End_If
    Mov D@Image eax

    Call 'USER32.LoadImageA' D$H.Instance, 11, &IMAGE_BITMAP, 0, 0, 0
    If eax = 0
        Call ReportWinError {B$ 'DebugDialog_CreateImageList: LoadImage (2)' EOS}
    End_If
    Mov D@Mask eax

    Call 'ComCtl32.ImageList_Create' 16, 16, &ILC_COLOR8+&ILC_MASK, 8, 8
    Mov D$DebugDialog_ImageList eax

    Call 'ComCtl32.ImageList_Add' D$DebugDialog_ImageList, D@Image, D@Mask
    If eax = 0-1
        Call ReportWinError {B$ 'Debug TB: ImageList_Add' EOS}
    End_If

    Call 'GDI32.DeleteObject' D@Image
    Call 'GDI32.DeleteObject' D@Mask
EndP
____________________________________________________________________________________________

DebugDialog_DestroyImageList:
    Call 'COMCTL32.ImageList_Destroy' D$DebugDialog_ImageList
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[DebugMenuTable:
 D$ 29
 ;  ID                 | String             | Shortcut      | Imageindex
 D$ M02_Run            StrRunPtr            StrF6           0
 D$ M02_Step_into      StrStepIntoPtr       StrF7           3
 D$ M02_Step_Over      StrStepOverPtr       StrF8           4
 D$ M02_ReturnToCaller StrReturnPtr         StrCtrlF7       5
 D$ M02_Terminate      StrTerminatePtr      StrCtrlF6       1
 D$ M02_Pause          StrPausePtr          StrCtrlF12      2
 D$ M02_HoldOnBP       StrHoldOnBPPtr       0               7
 D$ M02_Inst_Level     StrInstStepPtr       0               7
 D$ M02_Source_Level   StrSrcStepPtr        0               7
 D$ M02_ShowAll        StrShowAllPtr        0               7
 D$ M02_Font           StrFontPtr           0               0-1
 D$ M02_CPU_Info       StrCPUInfoPtr        0               0-1
 D$ M02_FPU_Status     StrFPUStatusPtr      0               0-1
 D$ M02_ShowCodeAt     StrShowCodeAtPtr     0               0-1
 D$ M02_About          StrAboutPtr          0               0-1
 D$ M02_Help           StrDbgHelpPtr        StrF1           0-1

 D$ M03_SHOW_MEM       StrShowInMemInspPtr  0               0-1
 D$ M03_SHOW_PMEM      StrShowPInMemInspPtr 0               0-1
 D$ M03_SHOW_DECL      StrShowDeclPtr       0               0-1
 D$ M03_WATCH_W        StrBreakOnWPtr       0               7
 D$ M03_WATCH_RW       StrBreakOnRWPtr      0               7
 D$ M03_SORTBYNAME     StrSortByNamePtr     0               7
 D$ M03_SORTBYADDRESS  StrSortByAddrPtr     0               7

 D$ MCS_SHOW_INVOKE    StrShowInvokePtr     0               0-1
 D$ MCS_SHOW_DECL      StrShowDeclPtr       0               0-1
 D$ MCS_SHOW_ALL       StrShowAllCallsPtr   0               7
 D$ MCS_HIDE_EXTERNAL  StrHideModCallsPtr   0               7
 D$ MCS_HIDE_INTRA     StrHideIMCallsPtr    0               7
 D$ MCS_SHOWLOCALS     StrShowLocalsPtr     0               7]
____________________________________________________________________________________________

[M02_Menu  3000                  M02_Run  3001                   M02_Step_Into  3002
 M02_Step_Over  3003             M02_Return_to_Caller  3004      M02_Pause  3005
 M02_Terminate  3006             M02_Hold_on_BP  3007            M02_Inst_Level 3008
 M02_Source_Level 3009           M02_Show_All 3010
 M02_Font  3011                  M02_CPU_Info  3012              M02_FPU_Status  3013
 M02_Show_code_at  3014          M02_About  3015                 M02_Help  3016]
____________________________________________________________________________________________

[DebugMenubarButtons:
 ; iBitmap D, idCommand D, fsState B, fsStyle B, wPad1 W, Data D, iString D
 D$ 0-2 0              B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE+&BTNS_DROPDOWN W$ 0 D$ 0 0
 D$ 0-2 1              B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE+&BTNS_DROPDOWN W$ 0 D$ 0 0
 D$ 0-2 2              B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE+&BTNS_DROPDOWN W$ 0 D$ 0 0
 D$ 0-2 3              B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE+&BTNS_DROPDOWN W$ 0 D$ 0 0
 D$ 0-2 4              B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE+&BTNS_DROPDOWN W$ 0 D$ 0 0]

[ContinueMenu: D$ ?
 BreakMenu: D$ ?
 SettingsMenu: D$ ?
 ExtrasMenu: D$ ?
 HelpMenu: D$ ?]

[NUM_MENUBAR_ENTRIES 5]

Proc DebugWindow_CreateMenu:
    Structure @Item 44,
        @Size 0,  @Mask 4,  @Type 8,  @State 12,  @ID 16,  @SubMenu 20,
        @bmpChecked 24,  @bmpUnchecked 28,  @ItemData 32,  @Data 36,  @cch 40

  ; Store menu handle in ebx
;    Call 'USER32.CreateMenu' | Mov ebx eax

  ; Create menu-bar (toolbar)
    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  {B$ 'ToolbarWindow32' EOS},
                                  &NULL,
                                  DEBUG_TOOLBAR_STYLE,
                                  0,
                                  0,
                                  200,
                                  0,
                                  D$H.DebugDialog,
                                  DEBUGDLG_MENUBAR,
                                  D$H.Instance,
                                  0

    Mov ebx eax

    SendMessage ebx, &WM_SETFONT, D$H.DialogFont, 0

    SendMessage ebx, &TB_BUTTONSTRUCTSIZE, 20, 0

    Move D$DebugMenubarButtons+16   D$StrContinuePtr
    Move D$DebugMenubarButtons+36   D$StrBreakPtr
    Move D$DebugMenubarButtons+56   D$StrSettingsPtr
    Move D$DebugMenubarButtons+76   D$StrInformationPtr
    Move D$DebugMenubarButtons+96   D$StrHelpPtr

    If D$UnicodeStrings = 0
        SendMessage ebx, &TB_ADDBUTTONSA, 5, DebugMenubarButtons
    Else
        SendMessage ebx, &TB_ADDBUTTONSW, 5, DebugMenubarButtons
    End_If

  ; Add the bands
    Mov D$DebugRebarBand@hwndChild ebx
    ;or D$DebugRebarBand@fStyle &RBBS_BREAK
    SendMessage ebx, &TB_GETMAXSIZE, 0, STRUC.POINT
    ;Call 'USER32.GetClientRect'  D$Debug_ToolbarHandle, DebugRect
    ;Mov eax D$DebugRect@right | sub eax D$DebugRect@left
    Mov eax D$STRUC.POINT+POINTX | add eax 10
    Mov D$DebugRebarBand@cx eax
    SendMessage D$H.DebugRebar, &RB_INSERTBAND, BAND_MENUBAR, DebugRebarBand
    SendMessage D$H.DebugRebar, &RB_SHOWBAND, BAND_MENUBAR, 1
    ;and D$DebugRebarBand@fStyle (not &RBBS_BREAK)
    ________________________________________________________________________________________

    Mov D@Size 44
    Mov D@Mask &MIIM_ID+&MIIM_TYPE
    Mov D@Type &MFT_OWNERDRAW

  ; Continue menu
    Call 'USER32.CreatePopupMenu' | Mov edi eax | Mov D$ContinueMenu eax
    ;Call AppendMenu ebx, &MF_STRING+&MF_POPUP, edi, D$StrContinuePtr

    Mov D@ID M02_Run
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item

    Mov D@ID M02_Step_Into
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item

    Mov D@ID M02_Step_Over
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item

    Mov D@Mask &MIIM_TYPE
    Mov D@Type &MFT_SEPARATOR
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item

    Mov D@Mask &MIIM_ID+&MIIM_TYPE
    Mov D@Type &MFT_OWNERDRAW
    Mov D@ID M02_Return_To_Caller
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item

  ; Break menu
    Call 'USER32.CreatePopupMenu' | Mov edi eax, D$BreakMenu eax
    ;Call AppendMenu ebx, &MF_STRING+&MF_POPUP, edi, D$StrBreakPtr

    Mov D@ID M02_Pause
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item

    Mov D@ID M02_Terminate
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item

  ; Settings menu
    Call 'USER32.CreatePopupMenu' | Mov edi eax, D$SettingsMenu eax
    ;Call AppendMenu ebx, &MF_STRING+&MF_POPUP, edi, D$StrSettingsPtr

    Mov D@ID M02_Hold_on_BP
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item
    Mov D@ID M02_Inst_Level
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item
    Mov D@ID M02_Source_Level
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item
    Mov D@ID M02_Show_All
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item
    Mov D@ID M02_Font
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item

    Mov D@Mask &MIIM_TYPE
    Mov D@Type &MFT_SEPARATOR
    Call 'USER32.InsertMenuItemA' edi, 4, 1, D@Item
    Call 'USER32.InsertMenuItemA' edi, 3, 1, D@Item
    Call 'USER32.InsertMenuItemA' edi, 1, 1, D@Item
;;
  ; Toolbar sub menu
    Call 'USER32.CreatePopupMenu' | Mov esi eax, D$Debug_ToolbarMenu eax
    Call 'USER32.AppendMenuA' edi, &MF_STRING+&MF_POPUP, esi, {B$ 'Toolbar' EOS}
    ;Call 'USER32.AppendMenuA' ebx, &MF_STRING, DEBUGDLG_TB_CONFIGURE, {B$ 'Configure ...' EOS}
    Call 'USER32.AppendMenuA' esi, &MF_STRING, DEBUGDLG_TB_SHOW_TEXT, {B$ 'Show text' EOS}
    Call 'USER32.AppendMenuA' esi, &MF_SEPARATOR, 0, 0
    Call 'USER32.AppendMenuA' esi, &MF_STRING+&MF_CHECKED, DEBUGDLG_TB_SHOW_CMDS, {B$ 'Show commands' EOS}
    Call 'USER32.AppendMenuA' esi, &MF_STRING+&MF_CHECKED, DEBUGDLG_TB_SHOW_FLAGS, {B$ 'Show flags' EOS}
    Call 'USER32.AppendMenuA' esi, &MF_STRING, DEBUGDLG_TB_SHOW_FPU, {B$ 'Show FPU flags' EOS}
;;
  ; Information menu
    Call 'USER32.CreatePopupMenu' | Mov edi eax, D$ExtrasMenu eax
    ;Call AppendMenu ebx, &MF_STRING+&MF_POPUP, edi, D$StrInformationPtr

    Mov D@Mask &MIIM_ID+&MIIM_TYPE
    Mov D@Type &MFT_OWNERDRAW

    Mov D@ID M02_CPU_Info
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item
    Mov D@ID M02_FPU_Status
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item
    Mov D@ID M02_Show_code_at
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item

    Mov D@Mask &MIIM_TYPE
    Mov D@Type &MFT_SEPARATOR
    Call 'USER32.InsertMenuItemA' edi, 2, 1, D@Item

  ; Help menu
    Call 'USER32.CreatePopupMenu' | Mov edi eax, D$HelpMenu eax
    ;Call AppendMenu ebx, &MF_STRING+&MF_POPUP, edi, D$StrHelpPtr

    Mov D@Mask &MIIM_ID+&MIIM_TYPE
    Mov D@Type &MFT_OWNERDRAW

    Mov D@ID M02_About
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item
    Mov D@ID M02_Help
    Call 'USER32.InsertMenuItemA' edi, -1, 1, D@Item

  ; Return menu handle
    Mov D$H.MenuBar ebx
    Mov eax ebx
EndP
____________________________________________________________________________________________

[MenubarHook: D$ ?
 CurrentMenubarIndex: D$ ?]

; Observe mouse messages to close the popup menu when the user clicks outside the menu area
; and to switch to other submenus when the mouse hovers above another menubar item.

Proc MenubarHookProc:
    Arguments @Code, @wParam, @Msg
    Uses ebx, edi

    Call 'USER32.CallNextHookEx' D$MenubarHook, D@Code, D@wParam, D@Msg
    Push eax

        Mov ebx D@Msg
        Mov eax D$ebx+4

        .If eax = &WM_LBUTTONDOWN
          ; Collapse menu if clicked outside menu area.
            If D@Code <> &MSGF_MENU
                Call 'USER32.PostMessageA' D$H.DebugDialog, WM_COLLAPSEMENU, 0, 0
            End_If

        .Else_If eax = &WM_RBUTTONDOWN
          ; Collapse menu if clicked outside menu area.
            If D@Code <> &MSGF_MENU
                Call 'USER32.PostMessageA' D$H.DebugDialog, WM_COLLAPSEMENU, 0, 0
            End_If

        .Else_If eax = &WM_MOUSEMOVE
          ; Check if mouse hovered above different menubar item. Perform hittest to
          ; identify which item is selected and if selection has changed collapse the
          ; old menu and track the new menu.
            movzx eax W$ebx+12
            movzx edx W$ebx+14
            Mov D$STRUC.POINT+POINTX eax
            Mov D$STRUC.POINT+POINTY edx
            Call 'USER32.ScreenToClient' D$H.MenuBar, STRUC.POINT
            Call 'USER32.SendMessageA' D$H.MenuBar, &TB_HITTEST, 0, STRUC.POINT
            test eax eax NEGATIVE L0>
            cmp eax NUM_MENUBAR_ENTRIES | jae L0>
            Mov edi eax
            If D$CurrentMenubarIndex <> eax
                Call 'USER32.PostMessageA' D$H.DebugDialog, WM_COLLAPSEMENU, 0, 0
                Call 'USER32.PostMessageA' D$H.DebugDialog, WM_POPUPMENU, edi, 0
            End_If
L0:
        .Else_If eax = &WM_KEYDOWN
          ; Select the next submenu when user presses left/right.
          ; Note: This does *not* work when the mouse is over the menubar as
          ; it continously receives WM_MOUSEMOVE messages (why?) which makes it
          ; switch back to the former menu immediately.
            If D$ebx+8 = &VK_LEFT
                Call 'USER32.PostMessageA' D$H.DebugDialog, WM_COLLAPSEMENU, 0, 0
                Mov eax D$CurrentMenubarIndex
                dec eax | jns L1>
                Mov eax (NUM_MENUBAR_ENTRIES-1)
L1:             Call 'USER32.PostMessageA' D$H.DebugDialog, WM_POPUPMENU, eax, 0
            Else_If D$ebx+8 = &VK_RIGHT
                Call 'USER32.PostMessageA' D$H.DebugDialog, WM_COLLAPSEMENU, 0, 0
                Mov eax D$CurrentMenubarIndex
                inc eax | cmp eax NUM_MENUBAR_ENTRIES | jb L1>
                Mov eax 0
L1:             Call 'USER32.PostMessageA' D$H.DebugDialog, WM_POPUPMENU, eax, 0
            End_If

        .End_If

    Pop eax
EndP
____________________________________________________________________________________________

[HotTracking: D$ ?
 HotTrackMenu: D$ ?]

; Track popup menu and prepare the GUI for menu navigation (install hook).
; TODO: Fix alignment of the rightmost popup menus.

Proc DebugDialog_OnPopupMenu:
    Arguments @Item
    Structure @Rect 16, @left 0,  @top 4,  @right 8,  @bottom 12

    SendMessage D$H.MenuBar, &TB_GETRECT, D@Item, D@Rect
    Move D$STRUC.POINT+POINTX D@left
    Move D$STRUC.POINT+POINTY D@bottom
    Call 'USER32.ClientToScreen' D$H.MenuBar, STRUC.POINT

    Mov edx D@Item
    If edx = 0
        Mov eax D$ContinueMenu
    Else_If edx = 1
        Mov eax D$BreakMenu
    Else_If edx = 2
        Mov eax D$SettingsMenu
    Else_If edx = 3
        Mov eax D$ExtrasMenu
    Else_If edx = 4
        Mov eax D$HelpMenu
    End_If
    Mov D$HottrackMenu eax, D$CurrentMenuBarIndex edx

  ; How can I measure the width of a popup menu before it is tracked?
    Call 'USER32.GetWindowRect' D$HotTrackMenu, D@Rect
    Call 'USER32.GetSystemMetrics' &SM_CXSCREEN
    Mov ecx D@right | sub ecx D@left
    Mov edx D$STRUC.POINT+POINTX
    add edx ecx
    If edx > eax
        sub eax ecx
        Mov D$STRUC.POINT+POINTX eax
    End_If

    SendMessage D$H.MenuBar, &TB_PRESSBUTTON, D@Item, 1

    Mov D$HotTracking 1

  ; Install mouse hook
    If D$MenubarHook <> 0
        Call 'OutputDebugStringA' {B$ 'Unhook (!)' EOS}
        Call 'USER32.UnhookWindowsHookEx' D$MenubarHook
        Mov D$MenubarHook 0
    End_If

    Call 'KERNEL32.GetCurrentThreadId'
    Call 'USER32.SetWindowsHookExA' &WH_MSGFILTER, MenubarHookProc, D$H.Instance, eax
    Mov D$MenubarHook eax

    PRINTLN 'SetHook'

  ; Open the menu. Note: The Call doesn't return until the menu is closed!
    Call 'USER32.TrackPopupMenu' D$HotTrackMenu, &TPM_LEFTBUTTON, D$STRUC.POINT+POINTX, D$STRUC.POINT+POINTY, 0, D$H.DebugDialog, 0

    SendMessage D$H.MenuBar, &TB_PRESSBUTTON, D@Item, 0

    If D$MenuBarHook <> 0
        PRINTLN 'Unhook'
        Call 'USER32.UnhookWindowsHookEx' D$MenubarHook
        Mov D$MenubarHook 0
    End_If

    Mov D$HotTracking 0
EndP
____________________________________________________________________________________________
[PRINTLN | Call 'OutputDebugStringA' {#1 0}]

; Collapse menu.
; TODO: Check if WM_CANCELMODE works under Windows NT.

DebugDialog_OnCollapseMenu:
    SendMessage D$H.DebugDialog, &WM_CANCELMODE, 0, 0
    Mov D$HotTracking 0
    If D$MenubarHook <> 0
        PRINTLN 'Unhook (C)'
        Call 'USER32.UnhookWindowsHookEx' D$MenubarHook
        Mov D$MenubarHook 0
    End_If
ret
____________________________________________________________________________________________

; Show menu when user clicks on menubar item.

Proc DebugDialog_MenubarNotify:
    Arguments @NotifyMsg, @Code, @Item

    Mov eax 0

    If D@Code = &TBN_DROPDOWN
        Call 'USER32.PostMessageA' D$H.DebugDialog, WM_POPUPMENU, D@Item, 0
        Mov eax &TBDDRET_DEFAULT
    End_If
EndP
____________________________________________________________________________________________

; Handle key commands [F10, ALT+x]

Proc DebugDialog_OnSysCommand:
    Arguments @hwnd, @Type, @lParam

    ..If D@Type = &SC_KEYMENU

        .If D$HotTracking = 0

            Mov eax D@lParam
            If eax = 0 ; F10
                ;SendMessage D$H.MenuBar, &TB_PRESSBUTTON, 0, 0
                SendMessage D$H.MenuBar, &TB_SETHOTITEM, 0, 0
                Call 'USER32.SetFocus' D$H.MenuBar
                ;Mov D$PrevFocusWindow eax
            End_If

        .End_If

        Mov eax 0

    ..Else
        Call 'USER32.DefWindowProcA' D@hwnd, &WM_SYSCOMMAND, D@Type, D@lParam
    ..End_If
EndP
____________________________________________________________________________________________

; Handle keyboard menu navigation [Arrow keys, ESC]

Proc DebugDialog_OnKeyDown:
    Arguments @hwnd, @Key, @lParam

    SendMessage D$H.MenuBar, &TB_GETHOTITEM, 0, 0

    .If eax <> 0-1
        If D@Key = &VK_RIGHT
            inc eax
            On eax = NUM_MENUBAR_ENTRIES,
                Mov eax 0

        Else_If D@Key = &VK_LEFT
            dec eax
            On eax = 0-1
                Mov eax NUM_MENUBAR_ENTRIES-1

        Else_If D@Key = &VK_ESCAPE
            ;Call 'USER32.SetFocus' D$PrevFocusWindow
            Mov eax 0-1
        End_If

        SendMessage D$H.MenuBar, &TB_SETHOTITEM, eax, 0
    .End_If

    Mov eax 0
EndP
____________________________________________________________________________________________
; Call (indeed jump to) either to the ansi or unicode taste of API functions.

AppendMenu:
    cmp B$UnicodeStrings 1 | je L0>
    jmp 'USER32.AppendMenuA'
L0: jmp 'USER32.AppendMenuW'

DrawText:
    cmp B$UnicodeStrings 1 | je L0>
    jmp 'USER32.DrawTextA'
L0: jmp 'USER32.DrawTextW'
____________________________________________________________________________________________

____________________________________________________________________________________________

; Enable / Gray-out execution control commands.

Proc DebugDialog_EnableContinueMenu:
    Arguments @Enable

    If D@Enable = 1
        Mov ebx &MF_ENABLED
    Else
        Mov ebx &MF_GRAYED
    End_If

    Call 'USER32.EnableMenuItem' D$ContinueMenu, M02_Run, ebx
    Call 'USER32.EnableMenuItem' D$ContinueMenu, M02_Step_Into, ebx
    Call 'USER32.EnableMenuItem' D$ContinueMenu, M02_Step_Over, ebx
    Call 'USER32.EnableMenuItem' D$ContinueMenu, M02_Return_to_Caller, ebx

    SendMessage D$H.DebugToolbar, &TB_ENABLEBUTTON, M02_Run, D@Enable
    SendMessage D$H.DebugToolbar, &TB_ENABLEBUTTON, M02_Step_Into, D@Enable
    SendMessage D$H.DebugToolbar, &TB_ENABLEBUTTON, M02_Step_over, D@Enable
    SendMessage D$H.DebugToolbar, &TB_ENABLEBUTTON, M02_Return_to_Caller, D@Enable

  ; Invert
    If D@Enable = 1
        Mov ebx &MF_GRAYED
        Mov D@Enable 0
    Else
        Mov ebx &MF_ENABLED
        Mov D@Enable 1
    End_If
    Call 'USER32.EnableMenuItem' D$BreakMenu, M02_Pause, ebx
    SendMessage D$H.DebugToolbar, &TB_ENABLEBUTTON, M02_Pause, D@Enable

    Call 'USER32.DrawMenuBar' D$H.DebugDialog
EndP
____________________________________________________________________________________________

DebugDialog_InitDbgMenu:
    Call 'USER32.CheckMenuItem' D$SettingsMenu, M02_Hold_on_BP, &MF_CHECKED
    Call 'USER32.CheckMenuRadioItem' D$SettingsMenu,
        M02_Inst_Level, M02_Source_Level, M02_Inst_Level, &MF_BYCOMMAND

    Call DebugDialog_EnableContinueMenu 0
ret
____________________________________________________________________________________________

; Process WM_DRAWITEM message for owner-drawn menu items.

Proc DebugDialog_OnDrawMenuItem:
    Arguments @DrawItemStruc
    Local @Brush

    Mov ebx D@DrawItemStruc

    Mov esi DebugMenuTable
    lodsd | Mov ecx eax ; number of entries
    Mov eax D$ebx+DRAWITEM_ITEMID
    While D$esi <> eax
        add esi 16
        dec ecx | jz L9>>
    EndWhile

    Call 'GDI32.SelectObject' D$ebx+DRAWITEM_HDC, D$H.DialogFont
    Push eax

    Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_GRAYED
        Call 'USER32.GetSysColor' &COLOR_GRAYTEXT
        Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax
        jmp L1>
    Test_Else_If D$ebx+DRAWITEM_ITEMSTATE &ODS_SELECTED
        Call 'USER32.GetSysColor' &COLOR_HIGHLIGHTTEXT
        Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax

        Call 'USER32.GetSysColor' &COLOR_HIGHLIGHT
        Call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, eax

        Call 'USER32.GetSysColorBrush' &COLOR_HIGHLIGHT
    Test_Else
        Call 'USER32.GetSysColor' &COLOR_MENUTEXT
        Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax

L1:     Call 'USER32.GetSysColor' &COLOR_MENU
        Call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, eax

        Call 'USER32.GetSysColorBrush' &COLOR_MENU
    Test_End

    lea edx D$ebx+DRAWITEM_RCITEM_LEFT
    Call 'USER32.FillRect' D$ebx+DRAWITEM_HDC, edx, eax

    Mov eax D$esi+12 ; image index
    If eax <> 0-1
        Mov ecx D$ebx+DRAWITEM_RCITEM_LEFT | add ecx 2
        Mov edx D$ebx+DRAWITEM_RCITEM_TOP  | add edx 2
        Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_GRAYED
            Mov edi &ILD_MASK
        Test_Else_If D$ebx+DRAWITEM_ITEMSTATE &ODS_SELECTED
            Mov edi &ILD_NORMAL
        Test_Else
            Mov edi &ILD_TRANSPARENT
        Test_End

        Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_CHECKED
            Mov eax 6
        Test_End

L0:     Call 'COMCTL32.ImageList_Draw' D$DebugDialog_ImageList, eax, D$ebx+DRAWITEM_HDC, ecx, edx, edi
    End_If

    add D$ebx+DRAWITEM_RCITEM_LEFT 22

    Mov eax D$esi+4
    Call DrawMenuItemText D$eax, &DT_LEFT

    Mov eax D$esi+8
    If eax <> 0
      ; Draw shortcut rightaligned
        dec D$ebx+DRAWITEM_RCITEM_RIGHT
        Call DrawMenuItemTextA eax, &DT_RIGHT
    End_If

    Pop eax
    Call 'GDI32.SelectObject' D$ebx+DRAWITEM_HDC, eax

L9: Mov eax 1
EndP
____________________________________________________________________________________________

; ebx > DRAWITEMSTRUCT

Proc DrawMenuItemText: ; Localized (ANSI or Unicode)
    Arguments @Text, @Align

  ; Grayed text is drawn white overlayed by gray (shifted 1 pixel in both directions)
    Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_GRAYED

        inc D$ebx+DRAWITEM_RCITEM_TOP
        inc D$ebx+DRAWITEM_RCITEM_BOTTOM
        inc D$ebx+DRAWITEM_RCITEM_LEFT
        inc D$ebx+DRAWITEM_RCITEM_RIGHT

        Call 'USER32.GetSysColor' &COLOR_3DHIGHLIGHT
        Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax
        lea edx D$ebx+DRAWITEM_RCITEM_LEFT
        Mov eax &DT_SINGLELINE+&DT_VCENTER | or eax D@Align
        Call DrawText D$ebx+DRAWITEM_HDC, D@Text, 0-1, edx, eax

        dec D$ebx+DRAWITEM_RCITEM_TOP
        dec D$ebx+DRAWITEM_RCITEM_BOTTOM
        dec D$ebx+DRAWITEM_RCITEM_LEFT
        dec D$ebx+DRAWITEM_RCITEM_RIGHT

        Call 'USER32.GetSysColor' &COLOR_GRAYTEXT
        Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax
        Call 'GDI32.SetBkMode' D$ebx+DRAWITEM_HDC, &TRANSPARENT

    Test_End

    lea edx D$ebx+DRAWITEM_RCITEM_LEFT
    Mov eax &DT_SINGLELINE+&DT_VCENTER | or eax D@Align
    Call DrawText D$ebx+DRAWITEM_HDC, D@Text, 0-1, edx, eax

EndP
____________________________________________________________________________________________

; ebx > DRAWITEMSTRUCT

Proc DrawMenuItemTextA: ; ANSI only
    Arguments @Text, @Align

  ; Grayed text is drawn white overlayed by gray (shifted 1 pixel in both directions)
    Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_GRAYED

        inc D$ebx+DRAWITEM_RCITEM_TOP
        inc D$ebx+DRAWITEM_RCITEM_BOTTOM
        inc D$ebx+DRAWITEM_RCITEM_LEFT
        inc D$ebx+DRAWITEM_RCITEM_RIGHT

        Call 'USER32.GetSysColor' &COLOR_3DHIGHLIGHT
        Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax
        lea edx D$ebx+DRAWITEM_RCITEM_LEFT
        Mov eax &DT_SINGLELINE+&DT_VCENTER | or eax D@Align
        Call 'USER32.DrawTextA' D$ebx+DRAWITEM_HDC, D@Text, 0-1, edx, eax

        dec D$ebx+DRAWITEM_RCITEM_TOP
        dec D$ebx+DRAWITEM_RCITEM_BOTTOM
        dec D$ebx+DRAWITEM_RCITEM_LEFT
        dec D$ebx+DRAWITEM_RCITEM_RIGHT

        Call 'USER32.GetSysColor' &COLOR_GRAYTEXT
        Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax
        Call 'GDI32.SetBkMode' D$ebx+DRAWITEM_HDC, &TRANSPARENT

    Test_End

    lea edx D$ebx+DRAWITEM_RCITEM_LEFT
    Mov eax &DT_SINGLELINE+&DT_VCENTER | or eax D@Align
    Call 'USER32.DrawTextA' D$ebx+DRAWITEM_HDC, D@Text, 0-1, edx, eax

EndP
____________________________________________________________________________________________

Proc DebugDialog_OnMeasureMenuItem:
    Arguments @MeasureItem

    Mov ebx D@MeasureItem
    Mov edx D$ebx+8 ; item id
    Mov esi DebugMenuTable
    lodsd ; eax = num entries
    While D$esi <> edx
        add esi 16
        dec eax | jz L9>
    EndWhile

    Mov eax D$esi+4
    Call MeasureStringWidth D$eax, D$H.DialogFont

    On D$esi+8 <> 0,
        add eax 50 ; shortcut

    add eax 22 ; icon+padding

    Mov D$ebx+12 eax ; width
    Mov D$ebx+16 20 ; height
L9:
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; TOOLBAR and coolbar (REBAR) of debugger main window.
____________________________________________________________________________________________
____________________________________________________________________________________________

[DEBUGDLG_REBAR 331 DEBUGDLG_TOOLBAR 332 DEBUGDLG_MENUBAR 333
 DEBUGDLG_FLAGS 334 DEBUGDLG_FPUFLAGS 335]

; Flow control buttons
[DebugToolbarButtons:
 ; iBitmap D, idCommand D, fsState B, fsStyle B, wPad1 W, Data D, iString D
 D$ 0 M02_Run              B$ 0                &BTNS_AUTOSIZE W$ 0 D$ 0 0
 D$ 1 M02_Terminate        B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE W$ 0 D$ 0 0
 D$ 2 M02_Pause            B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE W$ 0 D$ 0 0
 D$ 3 M02_Step_Into        B$ 0                &BTNS_AUTOSIZE W$ 0 D$ 0 0
 D$ 4 M02_Step_Over        B$ 0                &BTNS_AUTOSIZE W$ 0 D$ 0 0
 D$ 5 M02_Return_to_Caller B$ 0                &BTNS_AUTOSIZE W$ 0 D$ 0 0]
 ; Strings

[FlagStr.O: B$ 'O' EOS
 FlagStr.S: B$ 'S' EOS
 FlagStr.Z: B$ 'Z' EOS
 FlagStr.C: B$ 'C' EOS
 FlagStr.P: B$ 'P' EOS
 FlagStr.D: B$ 'Dir' EOS
 FlagStr.I: B$ 'Int' EOS
 FlagStr.T: B$ 'Trap' EOS
 FlagStr.A: B$ 'Aux' EOS
 FlagStr.C3: B$ 'C3' EOS
 FlagStr.C2: B$ 'C2' EOS
 FlagStr.C1: B$ 'C1' EOS
 FlagStr.C0: B$ 'C0' EOS]

; Standard flag buttons
[DebugFlagButtons:
 D$ 0-2 90 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr.O
 D$ 0-2 91 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr.S
 D$ 0-2 92 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr.Z
 D$ 0-2 93 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr.C
 D$ 0-2 94 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr.P
 D$ 0-2 95 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr.D
 D$ 0-2 96 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr.I
 D$ 0-2 97 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr.T
 D$ 0-2 98 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr.A]

; FPU flag buttons
[DebugFPUButtons:
 D$ 0-2 101 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr.C3
 D$ 0-2 102 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr.C2
 D$ 0-2 103 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr.C1
 D$ 0-2 104 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr.C0]

[H.DebugToolbar: D$ ?
 H.DebugFlagBar: D$ ?
 H.DebugFPUbar: D$ ?
 H.DebugRebar: D$ ?
 Debug_ToolbarMenu: D$ ?]

[DebugRebarBand:
 @cbSize:     D$ len
 @fMask:      D$ &RBBIM_CHILD+&RBBIM_STYLE+&RBBIM_CHILDSIZE+&RBBIM_SIZE+&RBBIM_IDEALSIZE+&RBBIM_HEADERSIZE
 @fStyle:     D$ &RBBS_CHILDEDGE+&RBBS_GRIPPERALWAYS ;+&RBBS_BREAK
 D$ 0 0 0 0 0
 @hwndChild:  D$ 0
 @cxMinChild: D$ 10
 @cyMinChild: D$ 22
 @cx:         D$ 0 0
 @wID:        D$ 0
 @cyChild:    D$ 0
 @cyMaxChild: D$ 0
 @cyIntegral: D$ 0
 @cxIdeal:    D$ 0 0
 @cxHeader:   D$ 6 ]

[Init_Common_Controls:
 @dwSize: D$ len
 @dwICC:  D$ &ICC_COOL_CLASSES+&ICC_BAR_CLASSES]
____________________________________________________________________________________________

[DEBUG_TOOLBAR_STYLE &WS_CHILD+&CCS_ADJUSTABLE+&TBSTYLE_FLAT+&TBSTYLE_LIST+&TBSTYLE_AUTOSIZE+&TBSTYLE_TRANSPARENT+&CCS_NOPARENTALIGN+&CCS_NODIVIDER+&CCS_NORESIZE]

[DebugShowTBText: D$ ?]

Proc DebugDialog_CreateCommandTB:
  ; Save states & clear if toolbar is REcreated
    .If D$H.DebugToolbar <> 0
        SendMessage D$H.DebugToolbar, &TB_GETSTATE, M02_Run, 0
        Mov B$DebugToolbarButtons+8 al
        SendMessage D$H.DebugToolbar, &TB_GETSTATE, M02_Terminate, 0
        Mov B$DebugToolbarButtons+28 al
        SendMessage D$H.DebugToolbar, &TB_GETSTATE, M02_Pause, 0
        Mov B$DebugToolbarButtons+48 al
        SendMessage D$H.DebugToolbar, &TB_GETSTATE, M02_Step_Into, 0
        Mov B$DebugToolbarButtons+68 al
        SendMessage D$H.DebugToolbar, &TB_GETSTATE, M02_Step_Over, 0
        Mov B$DebugToolbarButtons+88 al
        SendMessage D$H.DebugToolbar, &TB_GETSTATE, M02_Return_to_Caller, 0
        Mov B$DebugToolbarButtons+108 al
        SendMessage D$H.DebugRebar, &RB_DELETEBAND, 1, 0
        Call 'USER32.DestroyWindow' D$H.DebugToolbar
    .End_If

  ; Create toolbar
    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  {B$ 'ToolbarWindow32' EOS},
                                  &NULL,
                                  DEBUG_TOOLBAR_STYLE,
                                  0,
                                  0,
                                  120,
                                  0,
                                  D$H.DebugDialog,
                                  DEBUGDLG_TOOLBAR,
                                  D$H.Instance,
                                  0

    Mov D$H.DebugToolbar eax

    SendMessage eax, &WM_SETFONT, D$H.DialogFont, 0

    SendMessage D$H.DebugToolbar, &TB_BUTTONSTRUCTSIZE, 20, 0
    SendMessage D$H.DebugToolbar, &TB_SETIMAGELIST, 0, D$DebugDialog_ImageList

  ; Activate / Deactivate Text
    If D$DebugShowTBText = 1
        Move D$DebugToolbarButtons+16   D$StrRunPtr
        Move D$DebugToolbarButtons+36   D$StrTerminatePtr
        Move D$DebugToolbarButtons+56   D$StrPausePtr
        Move D$DebugToolbarButtons+76   D$StrStepPtr
        Move D$DebugToolbarButtons+96   D$StrStepOverPtr
        Move D$DebugToolbarButtons+116  D$StrRetPtr
    Else
        Mov D$DebugToolbarButtons+16   0
        Mov D$DebugToolbarButtons+36   0
        Mov D$DebugToolbarButtons+56   0
        Mov D$DebugToolbarButtons+76   0
        Mov D$DebugToolbarButtons+96   0
        Mov D$DebugToolbarButtons+116  0
    End_If

    If D$UnicodeStrings = 0
        SendMessage D$H.DebugToolbar, &TB_ADDBUTTONSA, 6, DebugToolbarButtons
    Else
        SendMessage D$H.DebugToolbar, &TB_ADDBUTTONSW, 6, DebugToolbarButtons
    End_If

  ; Add band
    Move D$DebugRebarBand@hwndChild D$H.DebugToolbar
    SendMessage D$H.DebugToolbar, &TB_GETMAXSIZE, 0, STRUC.POINT
    ;Call 'USER32.GetClientRect'  D$H.DebugToolbar, DebugRect
    ;Mov eax D$DebugRect@right | sub eax D$DebugRect@left
    Mov eax D$STRUC.POINT+POINTX | add eax 10
    Mov D$DebugRebarBand@cx eax
    ;Mov D$DebugRebarBand@cxIdeal eax
    ;Mov D$DebugRebarBand@cxMinChild eax

    SendMessage D$H.DebugRebar, &RB_INSERTBAND, BAND_COMMANDBAR, DebugRebarBand
    SendMessage D$H.DebugRebar, &RB_SHOWBAND, BAND_COMMANDBAR, 1
EndP
____________________________________________________________________________________________

[BAND_MENUBAR 0 BAND_COMMANDBAR 1 BAND_FLAGS 2 BAND_FPUFLAGS 3]

Proc DebugDialog_CreateToolbar:

    Call 'ComCtl32.InitCommonControlsEx' Init_Common_Controls

  ; Create rebar
    Call 'USER32.CreateWindowExA' &WS_EX_LEFT+&WS_EX_TOOLWINDOW,
                                  {B$ 'ReBarWindow32' EOS},
                                  &NULL,
                                  &WS_VISIBLE+&WS_CHILD+&RBS_VARHEIGHT+&RBS_FIXEDORDER+&RBS_BANDBORDERS+&WS_BORDER+&RBS_VERTICALGRIPPER, ;+&CCS_NODIVIDER,
                                  0,
                                  0,
                                  0,
                                  0,
                                  D$H.DebugDialog,
                                  DEBUGDLG_REBAR,
                                  D$H.Instance,
                                  0

    Mov D$H.DebugRebar eax

  ; Create menubar
    Call DebugWindow_CreateMenu

  ; Create flag toolbar
    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  {B$ 'ToolbarWindow32' EOS},
                                  &NULL,
                                  DEBUG_TOOLBAR_STYLE,
                                  0,
                                  0,
                                  80,
                                  0,
                                  D$H.DebugDialog,
                                  DEBUGDLG_FLAGS,
                                  D$H.Instance,
                                  0

    Mov D$H.DebugFlagBar eax

    SendMessage eax, &WM_SETFONT, D$H.DialogFont, 0

  ; Create FPU flag toolbar
    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  {B$ 'ToolbarWindow32' EOS},
                                  &NULL,
                                  DEBUG_TOOLBAR_STYLE,
                                  0,
                                  0,
                                  80,
                                  0,
                                  D$H.DebugDialog,
                                  DEBUGDLG_FPUFLAGS,
                                  D$H.Instance,
                                  0

    Mov D$H.DebugFPUbar eax

    SendMessage eax, &WM_SETFONT, D$H.DialogFont, 0

  ; Send the TB_BUTTONSTRUCTSIZE message, which is required for
  ; backward compatibility.
    SendMessage D$H.DebugFlagBar, &TB_BUTTONSTRUCTSIZE, 20, 0
    SendMessage D$H.DebugFPUbar, &TB_BUTTONSTRUCTSIZE, 20, 0

    Call DebugDialog_CreateCommandTB

  ; Add buttons
    SendMessage D$H.DebugFlagBar, &TB_ADDBUTTONS, 9, DebugFlagButtons
    SendMessage D$H.DebugFPUbar, &TB_ADDBUTTONS, 4, DebugFPUButtons

  ; Add the bands
    Move D$DebugRebarBand@hwndChild D$H.DebugFlagBar
    SendMessage D$H.DebugFlagBar, &TB_GETMAXSIZE, 0, STRUC.POINT
    Mov eax D$STRUC.POINT+POINTX ;| add eax 8
    ;Call 'USER32.GetClientRect'  D$Debug_FlagbarHandle, DebugRect
    ;Mov eax D$DebugRect@right | sub eax D$DebugRect@left

    ;Mov  D$DebugRebarBand@cxIdeal eax
    Mov  D$DebugRebarBand@cx eax
    ;Mov  D$DebugRebarBand@cxMinChild eax
    SendMessage D$H.DebugRebar, &RB_INSERTBAND, BAND_FLAGS, DebugRebarBand
    SendMessage D$H.DebugRebar, &RB_SHOWBAND, BAND_FLAGS, 1

    Move D$DebugRebarBand@hwndChild D$H.DebugFPUbar
    SendMessage D$H.DebugFPUbar, &TB_GETMAXSIZE, 0, STRUC.POINT
    Mov eax D$STRUC.POINT+POINTX ;| add eax 8
    ;Call 'USER32.GetClientRect'  D$Debug_FPUbarHandle, DebugRect
    ;Mov eax D$DebugRect@right | sub eax D$DebugRect@left

    ;Mov  D$DebugRebarBand@cxIdeal eax
    Mov  D$DebugRebarBand@cx eax
    ;Mov  D$DebugRebarBand@cxMinChild eax
    or   D$DebugRebarBand@fStyle &RBBS_HIDDEN
    SendMessage D$H.DebugRebar, &RB_INSERTBAND, 0-1, DebugRebarBand

  ; Create the context menu
    Call 'USER32.CreatePopupMenu' | Mov ebx eax, D$Debug_ToolbarMenu eax
    ;Call 'USER32.AppendMenuA' ebx, &MF_STRING, DEBUGDLG_TB_CONFIGURE, {B$ 'Configure ...' EOS}
    Call 'USER32.AppendMenuA' ebx, &MF_STRING, DEBUGDLG_TB_SHOW_TEXT, {B$ 'Show text' EOS}
    Call 'USER32.AppendMenuA' ebx, &MF_SEPARATOR, 0, 0
    Call 'USER32.AppendMenuA' ebx, &MF_STRING+&MF_CHECKED, DEBUGDLG_TB_SHOW_CMDS, {B$ 'Show commands' EOS}
    Call 'USER32.AppendMenuA' ebx, &MF_STRING+&MF_CHECKED, DEBUGDLG_TB_SHOW_FLAGS, {B$ 'Show flags' EOS}
    Call 'USER32.AppendMenuA' ebx, &MF_STRING, DEBUGDLG_TB_SHOW_FPU, {B$ 'Show FPU flags' EOS}

;;
    SendMessage D@TbHandle, &TB_GETITEMRECT, 0, DebugRect    
    Mov eax D$DebugRect@width | shl eax 16
    SendMessage D@TbHandle, &TB_SETBUTTONWIDTH, 0, eax
;;
;;
    SendMessage D$H.DebugToolbar, &TB_AUTOSIZE, 0, 0 
    SendMessage D$Debug_FlagbarHandle, &TB_AUTOSIZE, 0, 0 
    SendMessage D$Debug_FPUbarHandle,  &TB_AUTOSIZE, 0, 0 
;;
    ;Call 'USER32.ShowWindow' D@TbHandle, &SW_SHOW
EndP
____________________________________________________________________________________________

DebugDialog_DestroyToolbar:
    Call 'USER32.DestroyWindow' D$H.DebugToolbar
    Mov D$H.DebugToolbar 0
    Call 'USER32.DestroyWindow' D$H.DebugRebar
    Mov D$H.DebugRebar 0
    Call 'USER32.DestroyMenu' D$Debug_ToolbarMenu
    Mov D$Debug_ToolbarMenu 0
    Mov D$DebugDialog.RebarHeight 0
ret
____________________________________________________________________________________________

; User rightclicked on the dialog. Test if it is in the rebar and show context menu.
; Position is given in screen coordinates.

Proc DebugDialog_RebarHitTest:
    Arguments @X @Y
    Structure @RBHitTest 16, @pt.x 0,  @pt.y 4,  @flags 8,  @iBand 12

  ; Hittest expects client coordinates
    Move D@pt.x D@X, D@pt.y D@Y
    Call 'USER32.ScreenToClient' D$H.DebugRebar, D@RBHitTest
    SendMessage D$H.DebugRebar, &RB_HITTEST, 0, D@RBHitTest

  ; Show context menu
    If D@iBand <> 0-1
        Call 'USER32.TrackPopupMenu' D$Debug_ToolbarMenu, 0, D@X, D@Y, 0, D$H.DebugDialog, 0
    End_If
EndP
____________________________________________________________________________________________

; Show / Hide rebar-band containing a toolbar.
; Command references the menu item clicked.

Proc DebugDialog_ToggleToolbar:
    Arguments @Command

  ; store band index in ebx
    If D@Command = DEBUGDLG_TB_SHOW_CMDS
        Mov ebx 1
    Else_If D@Command = DEBUGDLG_TB_SHOW_FLAGS
        Mov ebx 2
    Else_If D@Command = DEBUGDLG_TB_SHOW_FPU
        Mov ebx 3
    End_If

  ; get check state of menu item, invert, toggle band and set inverted check state
    Call 'USER32.GetMenuState' D$Debug_ToolbarMenu, D@Command, &MF_BYCOMMAND
    Push eax

        xor edx edx | test eax &MF_CHECKED NOT_ZERO S1>

            xor edx 1

        S1: SendMessage D$H.DebugRebar, &RB_SHOWBAND, ebx, edx

    Pop eax
    xor eax &MF_CHECKED | and eax &MF_CHECKED
    Call 'USER32.CheckMenuItem' D$Debug_ToolbarMenu, D@Command, eax
EndP
____________________________________________________________________________________________

Proc DebugDialog_ToggleToolbarText:
    Structure @TBButtonInfo 32, @Size 0, @Mask 4, @Text 24

    Mov D@Size 32, D@Mask &TBIF_TEXT

  ; get check state of menu item, invert, toggle band and set inverted check state
    Call 'USER32.GetMenuState' D$Debug_ToolbarMenu, DEBUGDLG_TB_SHOWTEXT, &MF_BYCOMMAND
    Push eax
        xor edx edx | test eax &MF_CHECKED NOT_ZERO S1>

            xor edx 1

        S1: Mov B$DebugShowTBText dl

        Call DebugDialog_CreateCommandTB
;;
      ; TODO show text
        Mov ebx 0
        While ebx < 6
            Mov D@Text 0
            SendMessage D$H.DebugToolbar, &TB_SETBUTTONINFOA, ebx, D@TBButtonInfo
            If eax = 0
                Call ReportWinError {B$ 'SetButtonInfo' EOS}
            End_If
            inc ebx
        EndWhile
;;
    Pop eax
    xor eax &MF_CHECKED | and eax &MF_CHECKED
    Call 'USER32.CheckMenuItem' D$Debug_ToolbarMenu, DEBUGDLG_TB_SHOWTEXT, eax
    SendMessage D$H.DebugToolbar, &TB_AUTOSIZE, 0, 0

EndP
____________________________________________________________________________________________

[DebugDialog.RebarHeight: D$ ?]

Proc DebugDialog_RebarNotify:
    Arguments @msg

  ; Reposition all other child windows
    .If D@msg = &RBN_HEIGHTCHANGE
        SendMessage D$H.DebugRebar, &RB_GETBARHEIGHT, 0, 0
        Mov edx D$DebugDialog.RebarHeight
        Mov D$DebugDialog.RebarHeight eax
        sub eax edx | Mov ebx eax

        Call AdjustControlPos D$H.DebugDialog, DEBUGDLG_REGISTER_TAB, 0, ebx
        Call AdjustControlPos D$H.DebugDialog, DEBUGDLG_FORMAT_COMBO, 0, ebx
        Call AdjustControlPos D$H.DebugDialog, DEBUGDLG_REG_LIST, 0, ebx
        Call AdjustControlPos D$H.DebugDialog, DEBUGDLG_DATA_TAB, 0, ebx
        Call AdjustControlPos D$H.DebugDialog, 3, 0, ebx
        Mov esi 71
        While esi < 79
            Call AdjustControlPos D$H.DebugDialog, esi, 0, ebx
            inc esi
        EndWhile
        neg ebx
        Call AdjustControlSize D$H.DebugDialog, DEBUGDLG_DATA_TAB, 0, ebx
        Call DebugDialog_AdjustDataTabSize D$H.DebugDialog

        Call 'USER32.InvalidateRect' D$H.DebugDialog, &NULL, &TRUE
    .End_If
EndP
____________________________________________________________________________________________

Proc DebugDialog_SaveToolbarSettings:
    Arguments @H.File
    Structure @Tbar 36, @Id 0, @Size 4, @Flags 8, @X1 12, @X2 16, @X3 20, @Style1 24, @Style2 28, @Style3 32

    Mov D@Id 'TBar', D@Size 28

    Mov al B$DebugShowTBText | Mov B@Flags al

    SendMessage D$H.DebugRebar, &RB_GETBANDINFO, 1, DebugRebarBand
    Move D@Style1 D$DebugRebarBand@fStyle
    Move D@X1 D$DebugRebarBand@cx

    SendMessage D$H.DebugRebar, &RB_GETBANDINFO, 2, DebugRebarBand
    Move D@Style2 D$DebugRebarBand@fStyle
    Move D@X2 D$DebugRebarBand@cx

    SendMessage D$H.DebugRebar, &RB_GETBANDINFO, 3, DebugRebarBand
    Move D@Style3 D$DebugRebarBand@fStyle
    Move D@X3 D$DebugRebarBand@cx

    Call 'KERNEL32.WriteFile' D@H.File, D@Tbar, 36, BytesTransfered, 0

EndP
____________________________________________________________________________________________

Proc DebugDialog_LoadToolbarSettings:

    Arguments @H.File @Size

    Structure @Tbar 28, @Flags 0, @X1 4, @X2 8, @X3 12, @Style1 16, @Style2 20, @Style3 24

    Mov eax 0
    On D@Size <> 28 EndP

    Call 'KERNEL32.ReadFile' D@H.File, D@Tbar, D@Size, BytesTransfered, 0

    On B@Flags <> 0,
        Call DebugDialog_ToggleToolbarText

    Mov ebx D$DebugRebarBand@fMask
    Mov D$DebugRebarBand@fMask &RBBIM_STYLE+&RBBIM_SIZE

    Move D$DebugRebarBand@fStyle D@Style1
    Move D$DebugRebarBand@cx D@X1
    SendMessage D$H.DebugRebar, &RB_SETBANDINFO, 1, DebugRebarBand

    Move D$DebugRebarBand@fStyle D@Style2
    Move D$DebugRebarBand@cx D@X2
    SendMessage D$H.DebugRebar, &RB_SETBANDINFO, 2, DebugRebarBand

    Move D$DebugRebarBand@fStyle D@Style3
    Move D$DebugRebarBand@cx D@X3
    SendMessage D$H.DebugRebar, &RB_SETBANDINFO, 3, DebugRebarBand

    xor eax eax | test D@Style1 &RBBS_HIDDEN ZERO S1>

        xor eax 00_1000

S1: Call 'USER32.CheckMenuItem' D$Debug_ToolbarMenu, DEBUGDLG_TB_SHOW_CMDS, eax

    xor eax eax | test D@Style2 &RBBS_HIDDEN ZERO S1>

        xor eax 00_1000

S1: Call 'USER32.CheckMenuItem' D$Debug_ToolbarMenu, DEBUGDLG_TB_SHOW_FLAGS, eax

    xor eax eax | test D@Style3 &RBBS_HIDDEN ZERO S1>

        xor eax 00_1000

S1: Call 'USER32.CheckMenuItem' D$Debug_ToolbarMenu, DEBUGDLG_TB_SHOW_FPU, eax

    Mov D$DebugRebarBand@fMask ebx

    Mov eax 1
EndP
____________________________________________________________________________________________

____________________________________________________________________________________________
____________________________________________________________________________________________

[DEBUGLOGFONT:
 @lfHeight: D$ 0_FFFF_FFF5
 @lfWidth: D$ 0
 @lfEscapement: D$ 0
 @lfOrientation: D$ 0
 @lfWeight: D$ 0190
 @lfItalic: B$ 0
 @lfUnderline: B$ 0
 @lfStrikeOut: B$ 0
 @lfCharSet: B$ 0
 @lfOutPrecision: B$ 03
 @lfClipPrecision: B$ 02
 @lfQuality: B$ 01
 @lfPitchAndFamily: B$ 031
 @lfFaceName: B$ 'Courier New' EOS 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]

[DEBUGCHOOSEFONT:
 @lStructSize: D$ len
 @hwndOwner: D$ 0
 @hDC: D$ 0
 @lpLogFont: D$ DEBUGLOGFONT
 @iPointSize: D$ 0
 @Flags: D$ &CF_SCREENFONTS__&CF_FIXEDPITCHONLY
 @rgbColors: D$ 0
 @lCustData: D$ 0
 @lpfnHook: D$ 0
 @lpTemplateName: D$ 0
 @hInstance: D$ 0
 @lpszStyle: D$ 0
 @nFontType: W$ 0
 @Alignment: W$ 0
 @nSizeMin: D$ 0
 @nSizeMax: D$ 0]

[H.DebugFont: D$ ?]

Proc DebugDialog_SetFont:
    Arguments @hwnd

        On D$H.DebugFont <> 0,
            Call 'GDI32.DeleteObject' D$H.DebugFont
        Call 'GDI32.CreateFontIndirectA' DEBUGLOGFONT
        Mov D$H.DebugFont eax
        Call MeasureFont
        SendMessage D@hwnd, &WM_SETFONT, D$H.DebugFont, &TRUE
EndP
____________________________________________________________________________________________

; Get character extents for the owner-drawn lists.
; Create a temporary device context, set the font & measure string sizes.
; (only deals with fixed sized fonts)

[DebugFontCharWidth: D$ ?]

Proc MeasureFont:
    Local @DC

    Call 'GDI32.CreateDCA' {B$ 'DISPLAY' EOS}, 0, 0, 0
    Mov D@DC eax

    Call 'GDI32.SelectObject' D@DC, D$H.DebugFont
    Call 'GDI32.GetTextExtentPoint32A' D@DC, {B$ 'M' EOS}, 1, STRUC.POINT

    Move D$DebugFontCharWidth D$STRUC.POINT+POINTX

    Call 'GDI32.DeleteDC' D@DC
EndP
____________________________________________________________________________________________

MeasureStringWidth:
    cmp B$UnicodeStrings 1 | je L0>
    jmp MeasureStringWidthA
L0: jmp MeasureStringWidthW

; General purpose string measurement for owner-drawn controls

Proc MeasureStringWidthA:
    Arguments @String, @Font
    Local @DC
    Uses edi

    Call 'GDI32.CreateDCA' {B$ 'DISPLAY' EOS}, 0, 0, 0
    Mov D@DC eax

    Call 'GDI32.SelectObject' D@DC, D@Font

    Mov edi D@String, ecx 0-1, al 0
    repne scasb
    Mov eax 0-2 | sub eax ecx

    Call 'GDI32.GetTextExtentPoint32A' D@DC, D@String, eax, STRUC.POINT
    Call 'GDI32.DeleteDC' D@DC

    Mov eax D$STRUC.POINT+POINTX
EndP
____________________________________________________________________________________________

Proc MeasureStringWidthW:
    Arguments @String, @Font
    Local @DC
    Uses edi

    Call 'GDI32.CreateDCA' {B$ 'DISPLAY' EOS}, 0, 0, 0
    Mov D@DC eax

    Call 'GDI32.SelectObject' D@DC, D@Font

    Mov edi D@String, ecx 0-1, ax 0
    repne scasw
    Mov eax 0-2 | sub eax ecx

    Call 'GDI32.GetTextExtentPoint32W' D@DC, D@String, eax, STRUC.POINT
    Call 'GDI32.DeleteDC' D@DC

    Mov eax D$STRUC.POINT+POINTX
EndP
____________________________________________________________________________________________

; Present font dialog

Proc DebugDialog_ChangeFont:
    Arguments @hwnd

        Move D$DEBUGCHOOSEFONT@hwndOwner D@hwnd
        Call 'COMDLG32.ChooseFontA' DEBUGCHOOSEFONT    ; user sets the font:
        If eax > 0
            Call DebugDialog_SetFont D@hwnd
        End_If
EndP
____________________________________________________________________________________________

; Compare the register contents (general purpose) for changed values since last tag.
; Mark changed registers in the bit mask (e.g. bit0=1 means: EAX has changed)

[OldGPR_Values: D$ ? # 8
 GPR_Modified_Mask: D$ ?
 GPR_FirstTime: D$ ?]

Proc TagGPRModified:
    Uses esi edi

    Mov ecx 0, edx 0
    Mov esi GPRRegMap, edi OldGPR_Values
    Do
        lodsd | Mov eax D$eax
        cmp eax D$edi | je L0>
            bts edx ecx ; tag as changed
L0:     stosd
        inc ecx
    Loop_Until ecx = 8

    If D$GPR_FirstTime = 1
        Mov edx 0
        Mov D$GPR_FirstTime 0
    End_If

    Mov D$GPR_Modified_Mask edx
EndP
____________________________________________________________________________________________

[DebugConfig: B$ 'debug.cfg' EOS]

; Load debugger configuration from file (in RosAsmFiles folder) if available

Proc LoadDebugConfig:
    Local @File, @Value, @Size, @Id
    Uses edi, esi

    Call GetBUAsmFilesPath

    Mov edi BUAsmFilesPath, eax 0, ecx 0-1
    repne scasb | dec edi
    Mov esi DebugConfig, ecx 13
    rep movsb

    Call 'KERNEL32.CreateFileA' BUAsmFilesPath, &GENERIC_READ, &FILE_SHARE_READ, 0,
        &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0

    Mov B$edi 0

    On eax = &INVALID_HANDLE_VALUE EndP

    Mov D@File eax

L0: lea eax D@Id
    Call 'KERNEL32.ReadFile' D@File, eax, 8, BytesTransfered, 0
    ..If D$BytesTransfered = 8
        .If D@Id = 'RegX'
          ; Show seg&debug regs (0=No [default]; 1=Show)
            lea eax D@Value
            Call 'KERNEL32.ReadFile' D@File, eax, 4, BytesTransfered, 0
            On D@Value = 1,
                SendMessage D$H.DebugDialog, &WM_COMMAND, M02_Show_All, 0
        .Else_If D@Id = 'Step'
          ; Stepping mode (0=instruction level [default]; 1=source level)
            lea eax D@Value
            Call 'KERNEL32.ReadFile' D@File, eax, 4, BytesTransfered, 0
            On D@Value = 1,
                SendMessage D$H.DebugDialog, &WM_COMMAND, M02_Source_Level, 0
        .Else_If D@Id = 'Font'
            Call 'KERNEL32.ReadFile' D@File, DebugLogFont, D@Size, BytesTransfered, 0
            Call DebugDialog_SetFont D$H.DebugDialog
        .Else_If D@Id = 'Rect'
            Call 'KERNEL32.ReadFile' D@File, DebugRect, D@Size, BytesTransfered, 0
            Mov eax D$DebugRect@right | sub eax D$DebugRect@left
            Mov edx D$DebugRect@bottom | sub edx D$DebugRect@top
            Call 'USER32.MoveWindow' D$H.DebugDialog, D$DebugRect@left, D$DebugRect@top, eax, edx, &FALSE
        .Else_If D@Id = 'TBar'
            Call DebugDialog_LoadToolbarSettings D@File, D@Size
            cmp eax 0 | je L9>
        .Else_If D@Id = 'LaLa'
            Call DataView_LoadSettings D@File, D@Size
        .Else
          ; Unknown chunk, skip it
L9:         Call 'KERNEL32.SetFilePointer' D@File, D@Size, 0, &FILE_CURRENT
        .End_If
        jmp L0<<
    ..End_If

    Call 'KERNEL32.CloseHandle' D@File
EndP
____________________________________________________________________________________________

; Write debugger configuration to a file

Proc SaveDebugConfig:
    Local @File, @Value, @Size, @Id
    Uses edi, esi

    Call GetBUAsmFilesPath

    Mov edi BUAsmFilesPath, eax 0, ecx 0-1
    repne scasb | dec edi
    Mov esi DebugConfig, ecx 13
    rep movsb

    Call 'KERNEL32.CreateFileA' BUAsmFilesPath, &GENERIC_WRITE, &FILE_SHARE_READ, 0,
        &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0

    Mov B$edi 0

    On eax = &INVALID_HANDLE_VALUE EndP

    Mov D@File eax

  ; Show segment & debug regs
    Call 'USER32.GetMenuState' D$SettingsMenu, M02_Show_All, &MF_BYCOMMAND
    and eax &MF_CHECKED
    If eax <> 0
        Mov D@Value 1
    Else
        Mov D@Value 0
    End_If
    Mov D@Id 'RegX'
    Mov D@Size 4
    lea eax D@Id
    Call 'KERNEL32.WriteFile' D@File, eax, 12, BytesTransfered, 0

  ; Stepping Mode
    Mov D@Id 'Step'
    Move D@Value D$Stepping
    lea eax D@Id
    Call 'KERNEL32.WriteFile' D@File, eax, 12, BytesTransfered, 0

  ; Font
    Mov D@Id 'Font'
    Mov D@Size 60
    lea eax D@Id
    Call 'KERNEL32.WriteFile' D@File, eax, 8, BytesTransfered, 0
    Call 'KERNEL32.WriteFile' D@File, DebugLogFont, D@Size, BytesTransfered, 0

  ; Position
    Mov D@Id 'Rect'
    Mov D@Size 16
    Call 'USER32.GetWindowRect' D$H.DebugDialog, DebugRect
    lea eax D@Id
    Call 'KERNEL32.WriteFile' D@File, eax, 8, BytesTransfered, 0
    Call 'KERNEL32.WriteFile' D@File, DebugRect, D@Size, BytesTransfered, 0

    Call DebugDialog_SaveToolbarSettings D@File
    Call DataView_SaveSettings D@File

    Call 'KERNEL32.CloseHandle' D@File
EndP
____________________________________________________________________________________________

[CurrentStackPointer: D$ ?]

; Process WM_DEBUGEVENT message.

Proc DebugDialog_OnDebugEvent:
    Arguments @hwnd
    Local @Inside

      ; Find changed registers
        Call TagGPRModified

      ; Find position in source
        Call SourceDebugPos D$SourcePosCodeAddress
        Call IsProcessCode D$CONTEXT@regEip | Mov D@Inside eax

      ; Copy exception description
        Mov edi DebugCaption
        .If D$DebugEventType = DET_BP
            Mov D$edi 'BP  ' | add edi 3
        .Else_If D$DebugEventType = DET_STEP
            Mov D$edi 'STEP', B$edi+4 SPC | add edi 5
        .Else_If D$DebugEventType = DET_WP
            Mov D$edi 'WP  ' | add edi 3
        .Else_If D$DebugEventType = DET_EXCEPTION
            Mov D$edi 'EXCE', D$edi+4 'PTIO', W$edi+8 'N ' | add edi 10
        .End_If

        ;Mov esi D$BreakTitle, edi DebugCaption
        ;While B$esi <> 0 | movsb | EndWhile

        ; Under 95 we cannot access the process memory after an exception has occurred
        ; Step-Over and InstructionDecode wouldn't work for that reason. (really?)
        ...If D$ExceptionFlags = 0
            Call NextInstructionDecode
            ; For source level stepping, compare the last source pos with the current
            ; if it hasn't changed, continue to step into/over.
            ; UPDATE: Only when stepping inside the process code
            Mov eax D$SourcePos
            ..If eax = D$LastSourcePos
                .If D@Inside = &TRUE
                    If B$Stepping = 1
                        Call DebugDialog_ContinueDebuggee

EndP

                    End_If
                .End_If
            ..Else
                Mov D$LastSourcePos eax
            ..End_If
            ; Show next instruction in caption, e.g. "BREAKPOINT - [Push eax]"
            ;Mov eax ' - [' | stosd
            Mov al '[' | stosb
            Mov esi D$NextInstructionPtr
            While B$esi <> 0 | movsb | EndWhile
            Mov al ']' | stosb
        ...End_If

        On D$ExceptionFlags = 0,
            Call DebugDialog_EnableContinueMenu &TRUE
;;
        test D$ExceptionFlags E_MUSTEXIT | jnz L0>
            Call DebugDialog_EnableContinueMenu &TRUE
L0:
        test D$ExceptionFlags E_OUTSIDE | jnz L0>
L0:     
;;

      ; Show current module name
        If D$CurrentModule <> 0
            Push esi
                Mov esi D$CurrentModule
                Mov B$edi SPC | inc edi
                While B$esi <> 0 | movsb | EndWhile
            Pop esi
        End_If

      ; Show caption
        Mov B$edi 0
        SendMessage D@hwnd, &WM_SETTEXT, 0, DebugCaption

        ; Refresh register content output & flags
        Call DebugDialog_OnChangeRegisterTab D@hwnd
        Call DebugDialog_UpdateFlags D@hwnd
        Call DebugDialog_UpdateRegisterButtons D@hwnd
        Call 'USER32.IsIconic' D$H.MainWindow
        If eax = &TRUE
            Call 'USER32.ShowWindow' D$H.MainWindow, &SW_RESTORE
        End_If
        Call 'USER32.ShowWindow' D@hwnd, &SW_RESTORE
        Call 'USER32.SetForegroundWindow' D$H.MainWindow
        Call 'USER32.SetForegroundWindow' D@hwnd

      ; Refresh the data dialogs - they shall reload the displayed data from the debuggee
        SendMessage D$H.CurrentDataPage, WM_REFRESH_CONTENT, 0, 0

        On D$DebugEventType = DET_WP,
            SendMessage D$H.DataView, WM_SELECT_SYMBOL, D$WatchedAddress, 0

        On D$ExceptionFlags <> 0,
            Call ShowExceptionInfo

        Mov D$CurrentStackPointer 0

        ;test D$ExceptionFlags E_OUTSIDE | jz L0>
        ;    Call 'USER32.MessageBoxA' D$H.MainWindow, ErrorOutside, ErrorOutsideTitle, &MB_ICONEXCLAMATION
L0:     Mov eax 0
EndP
____________________________________________________________________________________________

; Kill Debugger

Proc DebugDialog_KillDebugger:
  ; Tried to kill debug-dialog while debugger is still running
    Mov D$TerminateDebuggee &TRUE, D$DialogKillsDebugger &TRUE

    .If D$IsDebugEvent = 1
      ; If the debug-thread waits for an user input event, simulate that the user pressed
      ; "Terminate Debuggee". If we don't do that, the debugger will wait forever--
        Call DebugDialog_ContinueDebuggee
    .Else
      ; Wait for the debug-thread to terminate. After a few seconds the debuggee and the
      ; debugger thread is terminated if the debugger thread does not exit voluntarily.
        Call 'KERNEL32.WaitForSingleObject' D$H.DebugThread, 5000
        If eax = &WAIT_TIMEOUT
            Call 'USER32.MessageBoxA' D$H.MainWindow, DebugThreadHangs, CriticalError, &MB_ICONEXCLAMATION
            Call CloseProcess
            Call 'KERNEL32.TerminateThread' D$H.DebugThread, 0
        End_If
        Mov D$H.DebugThread &NULL
    .End_If
EndP
____________________________________________________________________________________________

; Process WM_CREATE message. Create child windows and load configuration.

Proc DebugDialog_OnCreate:
    Arguments @hwnd

        Move D$H.DebugDialog D@hwnd
        ;Call 'USER32.GetMenu' D@hwnd | Mov D$DebugMenuHandle eax

      ; Hide tree
        On D$H.ShowTree <> 0, Call 'USER32.ShowWindow' D$H.ShowTree &SW_HIDE

      ; Init the flags
        Mov D$GPR_FirstTime 1, D$GPR_Modified_Mask 0
        Mov D$TerminateDebuggee &FALSE, D$DialogKillsDebugger &FALSE
        Mov D$HoldOnBreakpoints &TRUE, D$PauseThreads &FALSE

        Call 'USER32.GetClientRect' D@hwnd, DebugRect
        Move W$DebugDialog.Width W$DebugRect@width
        Move W$DebugDialog.Height W$DebugRect@height

      ; Place dialog in upper right corner of the source editor.
      ; The position is overwritten when the configuration file is loaded so it
      ; only has any effect when no config file is available.
        Call 'USER32.GetClientRect' D$H.MainWindow, DebugRect
        Mov esi D$DebugRect@width
        Mov edi D$DebugRect@height
        Call 'USER32.GetWindowRect' D@hwnd, DebugRect
        Mov eax D$DebugRect@left
        sub D$DebugRect@right eax ; width
        sub esi D$DebugRect@width
        Mov D$DebugRect@left esi ; xpos
        Mov eax D$DebugRect@top
        sub D$DebugRect@bottom eax ; height
        If edi > D$DebugRect@bottom
            Mov D$DebugRect@bottom edi
        End_If
        Mov D$DebugRect@top 0
        Call 'USER32.ClientToScreen' D$H.MainWindow, DebugRect
        Call 'USER32.MoveWindow' D@hwnd, D$DebugRect@left, D$DebugRect@top,
                                 D$DebugRect@right, D$DebugRect@bottom, &FALSE

      ; Key mapping
        Call 'USER32.CreateAcceleratorTableA' DbgAccels, DbgAccelsNum
        Mov D$H.DbgAccel eax

      ; Create default font
        Mov eax D$H.NationalFont
        If eax <> 0
            Mov D$H.DialogFont eax
        Else
            Call 'GDI32.CreateFontA' 8 4 0 0 400 0 0 0 1,   ;  DEFAULT_CHARSET 1  OEM_CHARSET 255
                                     0 0 0 0 Helv
            Mov D$H.DialogFont eax
        End_If

        ;SendMessage eax, &WM_SETFONT, D$DialogFont_handle, 1
        ;SendMessage eax, &WM_SETFONT, D@hwnd, 1

      ; Create the image list
        Call DebugDialog_CreateImageList

      ; Create the child windows / menu, toolbar, tabs
        Call DebugDialog_CreateRegisterTabs D@hwnd
        Call DebugDialog_CreateDataTab D@hwnd
        Call DebugDialog_CreateToolbar
        Call DebugDialog_InitDbgMenu

      ; Create the monospace font
        Call DebugDialog_SetFont D@hwnd

        Call 'USER32.SetWindowTextA' D@hwnd, {B$ 'Running ...' EOS}

      ; Create the mouse hint form and timer
        Call InitMouseOverDataHints

      ; Finally load configuration from file if available. All windows must be created
      ; at this point.
        Call LoadDebugConfig

        Mov eax 0 ;&TRUE
EndP
____________________________________________________________________________________________

; Process WM_CLOSE message. Save configuration & send destroy message.

Proc DebugDialog_OnClose:
    Arguments @hwnd

      ; Save configuration
        Call SaveDebugConfig

      ; Terminate debugger if it is still running.
        Mov D$DebuggerReady &FALSE
        If D$FL.IsDebugging = &TRUE
            Call DebugDialog_KillDebugger
        End_If

      ; Kill timer and destroy mouse hint window
        Call DeleteMouseOverDataHints

      ; Destroy dialog
        Call 'USER32.DestroyWindow' D@hwnd
        Mov D$H.DebugDialog 0

      ; Restore RosAsm windows
        On D$H.ShowTree <> 0, Call 'USER32.ShowWindow' D$H.ShowTree, &SW_SHOW
        Call 'USER32.IsIconic' D$H.MainWindow
        If eax = &TRUE
            Call 'USER32.ShowWindow' D$H.MainWindow, &SW_RESTORE
        End_If
        Call 'USER32.SetForegroundWindow' D$H.MainWindow
        Mov eax 0
EndP
____________________________________________________________________________________________

; Process WM_DESTROY message. Free resources, destroy child windows.

Proc DebugDialog_OnDestroy:
    Arguments @hwnd

      ; Destroy child windows
        Call 'USER32.DestroyWindow' D$H.DataView
        Call 'USER32.DestroyWindow' D$H.MemoryInspector
        Call 'USER32.DestroyWindow' D$H.CallStackForm
        Call 'USER32.DestroyWindow' D$H.LogForm
        Call 'USER32.DestroyWindow' D$H.ASForm
        Mov D$H.CurrentDataPage 0

        Call DebugDialog_DestroyToolbar

      ; Free images
        Call DebugDialog_DestroyImageList

      ; Destroy key map
        Call 'USER32.DestroyAcceleratorTable' D$H.DbgAccel
        Mov D$H.DbgAccel 0

      ; Delete fonts
        If D$H.DebugFont <> 0
            Call 'GDI32.DeleteObject' D$H.DebugFont
            Mov D$H.DebugFont 0
        End_If
        If D$H.DialogFont <> 0
            On D$H.NationalFont = 0,
                Call 'GDI32.DeleteObject' D$H.DialogFont
            Mov D$H.DialogFont 0
        End_If

        Mov eax 0
EndP
____________________________________________________________________________________________

; Process WM_COMMAND message. Menu, accelerator (key-press) and button notifications.

Proc DebugDialog_OnCommand:
    Arguments @hwnd, @wParam, @lParam

        movzx eax W@wParam
        movzx edx W@wParam+2

        .If eax = M02_Hold_on_BP
            Call 'USER32.GetMenuState' D$SettingsMenu, M02_Hold_on_BP, &MF_BYCOMMAND
            xor B$HoldOnBreakpoints 1 ; bool toggle
            xor eax &MF_CHECKED | and eax &MF_CHECKED
            Call 'USER32.CheckMenuItem' D$SettingsMenu, M02_Hold_on_BP, eax

        .Else_if eax = M02_Show_All
            Call 'USER32.GetMenuState' D$SettingsMenu, M02_Show_All, &MF_BYCOMMAND
            Push eax
                xor edx edx | test eax &MF_CHECKED ZERO S1>

                xor edx 1

           S1: Call DebugDialog_ShowAdvancedTabs D@hwnd edx

            Pop eax
            xor eax &MF_CHECKED | and eax &MF_CHECKED
            Call 'USER32.CheckMenuItem' D$SettingsMenu, M02_Show_All, eax

        .Else_if eax = M02_Run
            Mov B$UserWants CONTINUE_RUN
            Call DebugDialog_ContinueDebuggee

        .Else_if eax = M02_Step_Over
            Mov B$UserWants CONTINUE_STEPOVER
            Call DebugDialog_ContinueDebuggee

        .Else_if eax = M02_Step_Into
            Mov B$UserWants CONTINUE_STEP
            Call DebugDialog_ContinueDebuggee

        .Else_if eax = M02_Return_to_Caller
            Mov B$UserWants CONTINUE_RETURNTOCALLER
            Call DebugDialog_ContinueDebuggee

        .Else_if eax = M02_Terminate
            Mov B$TerminateDebuggee &TRUE
            Call DebugDialog_ContinueDebuggee

        .Else_if eax = M02_Pause
            Mov B$PauseThreads &TRUE

        .Else_If eax = M02_Show_code_at
            Call CreateNewForm_CodeAddressForm

        .Else_if eax = M02_Inst_Level
            Call 'USER32.CheckMenuRadioItem' D$SettingsMenu, M02_Inst_Level, M02_Source_Level,
                                             M02_Inst_Level, &MF_BYCOMMAND
            Mov B$Stepping 0

        .Else_if eax = M02_Source_Level
            Call 'USER32.CheckMenuRadioItem' D$SettingsMenu, M02_Inst_Level, M02_Source_Level,
                                             M02_Source_Level, &MF_BYCOMMAND
            Mov B$Stepping 1

        .Else_if eax = M02_Font
            Call DebugDialog_ChangeFont D@hwnd

        .Else_if eax = M02_CPU_Info

            Call VirtualAlloc DebugTextBuffer,
                              01000

            Mov edi D$DebugTextBuffer
            Call DebugDialog_GetCPUInfo
            Call 'USER32.MessageBoxA' D$H.MainWindow, D$DebugTextBuffer, {B$ 'CPU Information' EOS}, &MB_OK__&MB_ICONINFORMATION

            Call VirtualFree DebugTextBuffer

        .Else_if eax = M02_FPU_Status

            Call VirtualAlloc DebugTextBuffer,
                              01000

            Mov edi D$DebugTextBuffer
            Call DebugDialog_GetFPUStatus
            Call 'USER32.MessageBoxA' D$H.MainWindow, D$DebugTextBuffer, {B$ 'FPU Status' EOS}, &MB_OK__&MB_ICONINFORMATION

            Call VirtualFree DebugTextBuffer

        .Else_if eax = M02_Help
            Call Help, B_U_AsmName, {B$ 'Debugger' EOS}, ContextHlpMessage

        .Else_if eax = M02_About
            Call 'USER32.MessageBoxA' D$H.MainWindow, AboutDebugger, DebuggerVersion, &MB_OK__&MB_ICONINFORMATION

        .Else_If eax = DEBUGDLG_FORMAT_COMBO ; Representation Combo
            If edx = &CBN_SELCHANGE
                SendMessage D@lParam, &CB_GETCURSEL, 0, 0
                On eax <> &CB_ERR, Call DebugDialog_OnFormatChange D@hwnd eax
            End_If

        .Else_if eax = DEBUGDLG_TB_CONFIGURE
            ; TODO
        .Else_If eax = DEBUGDLG_TB_SHOW_CMDS
            Call DebugDialog_ToggleToolbar eax
        .Else_If eax = DEBUGDLG_TB_SHOW_FLAGS
            Call DebugDialog_ToggleToolbar eax
        .Else_If eax = DEBUGDLG_TB_SHOW_FPU
            Call DebugDialog_ToggleToolbar eax
        .Else_If eax = DEBUGDLG_TB_SHOW_TEXT
            Call DebugDialog_ToggleToolbarText

        .Else_if eax >= DEBUGDLG_FIRSTREG_BUTTON
            If eax <= DEBUGDLG_LASTREG_BUTTON
                sub eax DEBUGDLG_FIRSTREG_BUTTON
                Mov eax D$GPRRegMap+eax*4
                Mov ecx D$eax
                and ecx 0_FFFF_F000
                SendMessage D$H.MemoryInspector, WM_SET_PAGE, ecx, D$eax
            End_If
        .End_If
        Mov eax 0
EndP
____________________________________________________________________________________________

; Process WM_NOTIFY message. Handles tab selection changes and rebar height change.

Proc DebugDialog_OnNotify:
    Arguments @hwnd, @Notification

        Mov ebx D@Notification
        Mov edx D$ebx+4
        Mov eax D$ebx+8
        ..If edx = DEBUGDLG_REGISTER_TAB
            If eax = &TCN_SELCHANGE
                SendMessage D$ebx, &TCM_GETCURSEL, 0, 0
                Mov D$TabItem@imask &TCIF_PARAM
                SendMessage D$ebx, &TCM_GETITEM, eax, TabItem
                Call DebugDialog_OnChangeRegisterTab D@hwnd
            End_If
            Mov eax 0
        ..Else_If edx = DEBUGDLG_DATA_TAB
            .If eax = &TCN_SELCHANGE
                SendMessage D$ebx, &TCM_GETCURSEL, 0, 0
                If eax = 0
                    Mov edi D$H.DataView
                Else_If eax = 1
                    Mov edi D$H.MemoryInspector
                Else_If eax = 2
                    Mov edi D$H.CallStackForm
                Else_If eax = 3
                    Mov edi D$H.LogForm
                Else_If eax = 4
                    Mov edi D$H.ASForm
                End_If
                Call 'USER32.ShowWindow' D$H.CurrentDataPage, &SW_HIDE
                Call 'USER32.ShowWindow' edi, &SW_SHOW
                Mov D$H.CurrentDataPage edi
                Call DebugDialog_AdjustDataTabSize D@hwnd
            .End_If
            Mov eax 0 ; mandatory for TCN_SELCHANGING !!!
        ..Else_If edx = DEBUGDLG_REBAR
            Call DebugDialog_RebarNotify eax
            Mov eax 0
        ..Else_If edx = DEBUGDLG_MENUBAR
            Call DebugDialog_MenubarNotify ebx eax D$ebx+12
        ..Else
            Mov eax 0
        ..End_If

EndP
____________________________________________________________________________________________

; Process WM_SETFONT message. Propagate message to affected child windows.

Proc DebugDialog_OnSetFont:
    Arguments @hwnd @hFont, @Redraw

        SendMessage D$H.RegList, &WM_SETFONT, D@hFont, D@Redraw
        SendMessage D$H.DataView, &WM_SETFONT, D@hFont, D@Redraw
        SendMessage D$H.MemoryInspector, &WM_SETFONT, D@hFont, D@Redraw
        SendMessage D$H.CallStackForm, &WM_SETFONT, D@hFont, D@Redraw
        SendMessage D$H.LogForm, &WM_SETFONT, D@hFont, D@Redraw
        SendMessage D$H.MouseHintForm, &WM_SETFONT, D@hFont, D@Redraw
        SendMessage D$H.ASFormTree, &WM_SETFONT, D@hFont, D@Redraw
        Mov ebx DEBUGDLG_FIRSTREG_BUTTON
        While ebx <= DEBUGDLG_LASTREG_BUTTON
            Call 'USER32.GetDlgItem' D@hwnd, ebx
            SendMessage eax, &WM_SETFONT, D@hFont, D@Redraw
            inc ebx
        EndWhile
EndP
____________________________________________________________________________________________


____________________________________________________________________________________________

; Create the main debugger window.

CreateDebugWindow:

    Move D$DebugWindowClass@hInstance D$H.Instance
    Move D$DebugWindowClass@hIcon D$STRUC.WINDOWCLASS@hIcon
    Move D$DebugWindowClass@hIconSm D$STRUC.WINDOWCLASS@hIcon
    Move D$DebugWindowClass@hCursor D$STRUC.WINDOWCLASS@hCursor

    Call 'USER32.RegisterClassExA' DebugWindowClass

    ;Call 'USER32.LoadMenuA' D$H.Instance, M02_MENU
    ;Call DebugWindow_CreateMenu

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  DebugWindowClassName,
                                  &NULL,
                                  &WS_OVERLAPPEDWINDOW+&WS_VISIBLE+&WS_POPUP,
                                  0,
                                  0,
                                  160,
                                  240,
                                  D$H.MainWindow,
                                  0,
                                  D$H.Instance,
                                  0

    If eax = 0

        Call ReportWinError {B$ 'Debugger: CreateWindowEx' EOS}

        Mov eax 0 | ret

    End_If

    Mov D$H.DebugDialog eax

    Mov eax 1

ret
____________________________________________________________________________________________
[DebugWindowClass:
 @cbSize:        D$ len
 @style:         D$ 11
 @lpfnWndProc:   D$ DebugDlgProc
 @cbClsExtra:    D$ 0
 @cbWndExtra:    D$ 0
 @hInstance:     D$ 0
 @hIcon:         D$ 0
 @hCursor:       D$ 0
 @hbrBackground: D$ 1
 @lpszMenuName:  D$ 0
 @lpszClassName: D$ DebugWindowClassName
 @hIconSm:       D$ 0]
[DebugWindowClassName: B$ "BUA DebugWindow" EOS]
____________________________________________________________________________________________
; Custom events used to interchange informations between the debugger thread and the various
; windows/subwindows.

[WM_DEBUGEVENT      &WM_USER+1  ; debugger thread -> main debug dlg : when debug event occurs
 WM_BEGIN_DEBUG     &WM_USER+2  ; debugger thread -> main debug dlg : debuggee is set up
 WM_SET_PAGE        &WM_USER+3  ; various dlgs -> mem inspector : select virtual page
 WM_REFRESH_CONTENT &WM_USER+4  ; main debug dlg -> data dlgs : refresh data from debuggee
 WM_SELECT_SYMBOL   &WM_USER+5  ; main debug dlg -> data viewer : select symbol by address
 WM_LOG             &WM_USER+6  ; debugger thread -> main debug dlg : to log debug strings
 WM_POPUPMENU       &WM_USER+7  ; hook proc -> main debug dlg : popup menubar sub-menu
 WM_COLLAPSEMENU    &WM_USER+8] ; hook proc -> main debug dlg : collapse menubar sub-menu

; Accelerator table - assign key-combos to menu items

[DbgAccels:
 U$ &FVIRTKEY                   &VK_F6      M02_Run
    &FVIRTKEY                   &VK_F7      M02_Step_Into
    &FVIRTKEY                   &VK_F8      M02_Step_Over
    &FVIRTKEY+&FCONTROL         &VK_F7      M02_Return_to_Caller
    &FVIRTKEY+&FCONTROL         &VK_F12     M02_Pause
    &FVIRTKEY+&FCONTROL         &VK_F6      M02_Terminate]
    ;&FVIRTKEY+&FCONTROL         "F"         M02_FPU_Status


[DbgAccelsNum 6]
[H.DbgAccel: D$ ?]

;[BreakTitle: ?]
[DebugCaption: B$ ? # 64]

; Debuggee is started.
[DebuggerReady: D$ ?]

[TabItem:
 @imask: D$ ? # 3
 @pszText: D$ ?
 @cchTextMax: D$ ?
 @iImage: D$ ?
 @lParam: D$ ?]

[DebugRect:
 @left: D$ ?
 @top: D$ ?
 @right: @width: D$ ?
 @bottom: @height: D$ ?]

[UserWants: D$ ?] ; Execution control after debug event (step, run, ...)
[Stepping: D$ ?
 LastSourcePos: D$ ?]

[DbgLineHeight: D$ 16]

[H.DebugDialog: D$ ?
 H.RegList: D$ ?]; DebugMenuHandle: D$ ?]
[H.MenuBar: D$ ?]
[HoldOnBreakpoints: D$ ?
 TerminateDebuggee: D$ ?
 PauseThreads: D$ ?
 DialogKillsDebugger: D$ ?]

[DebugTextBuffer: D$ ?]

[DebugDialogSize:
 DebugDialog.Width: W$ ?
 DebugDialog.Height: W$ ?]

[DEBUGDLG_REGISTER_TAB 40
 DEBUGDLG_DATA_TAB 200
 DEBUGDLG_FORMAT_COMBO 60
 DEBUGDLG_REG_LIST 70
 DEBUGDLG_FIRSTREG_BUTTON 71
 DEBUGDLG_LASTREG_BUTTON 78
 DEBUGDLG_TB_CONFIGURE 300
 DEBUGDLG_TB_SHOW_CMDS 301
 DEBUGDLG_TB_SHOW_FLAGS 302
 DEBUGDLG_TB_SHOW_FPU 303
 DEBUGDLG_TB_SHOW_TEXT 304]

[H.DialogFont: D$ ?]


;;
    The main debugger window - related functions (right-click)
    
    'DebugDialog_InitDbgMenu', 'DebugDialog_CreateRegisterTabs', 'DebugDialog_CreateDataTab',
    'DebugDialog_InitRegisterListBox', 'DebugDialog_CreateRegisterButtons',
    'DebugDialog_SetFont', 'DebugDialog_ChangeFont', 'DebugDialog_ContinueDebuggee',
    'DebugDialog_OnChangeRegisterTab', 'DebugDialog_OnDrawRegisterItem', 'DebugDialog_OnFormatChange',
    'DebugDialog_UpdateFlags', 'DebugDialog_UpdateRegisterButtons', 
    'DebugDialog_ShowAdvancedTabs', 'DebugDialog_GetCPUInfo', 'DebugDialog_GetFPUStatus',
    'DebugDialog_AdjustDataTabSize', 'DebugDialog_ShowCaller'
;;

Proc DebugDlgProc:
    Arguments @hwnd @msg @wParam @lParam
    Uses ebx, esi, edi

    .If D@msg = &WM_CREATE
        Call DebugDialog_OnCreate D@hwnd

    .Else_If D@msg = &WM_CONTEXTMENU
        movzx eax W@lParam
        movzx ecx W@lParam+2
        Call DebugDialog_RebarHitTest eax ecx

    .Else_if D@msg = WM_BEGIN_DEBUG
        Mov D$DebuggerReady &TRUE
        Mov eax 0

    .Else_If D@msg = WM_LOG
        SendMessage D$H.LogForm, D@msg, D@wParam, D@lParam

    .Else_If D@msg = WM_DEBUGEVENT
        Call DebugDialog_OnDebugEvent D@hwnd

    .Else_If D@msg = WM_POPUPMENU
        Call DebugDialog_OnPopupMenu D@wParam

    .Else_If D@msg = WM_COLLAPSEMENU
        Call DebugDialog_OnCollapseMenu

    .Else_If D@msg = &WM_CLOSE
        Call DebugDialog_OnClose D@hwnd

    .Else_If D@msg = &WM_DESTROY
        Call DebugDialog_OnDestroy D@hwnd

    .Else_If D@msg = &WM_COMMAND
        Call DebugDialog_OnCommand D@hwnd, D@wParam, D@lParam

    .Else_If D@msg = &WM_SYSCOMMAND
        Call DebugDialog_OnSysCommand D@hwnd, D@wParam, D@lParam

    .Else_if D@msg = &WM_KEYDOWN
        Call DebugDialog_OnKeyDown D@hwnd, D@wParam, D@lParam

    .Else_If D@msg = &WM_NOTIFY
        Call DebugDialog_OnNotify D@hwnd, D@lParam

    .Else_if D@msg = &WM_GETMINMAXINFO
        Mov eax D@lParam
        Mov D$eax+24 200
        Mov D$eax+28 480
        Mov eax 0

    .Else_if D@msg = &WM_SIZE
        If D@wParam <> &SIZE_MINIMIZED
            Call DebugDialog_OnSize D@hwnd, D@lParam
        End_If

    .Else_if D@msg = &WM_ACTIVATEAPP
        Mov eax 0

    .Else_if D@msg = &WM_SETFONT
        Call DebugDialog_OnSetFont D@hwnd, D@wParam, D@lParam

    .Else_if D@msg = &WM_DRAWITEM
        If D@wParam = 0
            Call DebugDialog_OnDrawMenuItem D@lParam
        Else
            Call DebugDialog_OnDrawRegisterItem D@lParam
        End_If
        Mov eax &TRUE

    .Else_if D@msg = &WM_MEASUREITEM
        Mov eax D@lParam
        If D@wParam = 0
          ; menu
            Call DebugDialog_OnMeasureMenuItem D@lParam
        Else
          ; listbox
            Move D$eax+16 D$DbgLineHeight
        End_If
        Mov eax &TRUE

    .Else
        Call 'USER32.DefWindowProcA' D@hwnd, D@msg, D@wParam, D@lParam
    .End_If

EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; MEMORY INSPECTOR
____________________________________________________________________________________________
____________________________________________________________________________________________

[MemInspectorSize:
 MemInspector.Width: W$ ?
 MemInspector.Height: W$ ?]

[MEMINSPECTOR_DATA_LIST 150
 MEMINSPECTOR_PAGE_EDIT 160
 MEMINSPECTOR_PREV_BUTTON 151
 MEMINSPECTOR_NEXT_BUTTON 152
 MEMINSPECTOR_TABLE_BUTTON 153
 MEMINSPECTOR_FORMAT_COMBO 170]

[MemFormatConversionProc: D$ ?]

[CurrentPageAddress: D$ ?
 CurrentPage: D$ ?]

Proc MemoryInspector_OnDrawItem:
    Arguments @DrawItemStruc
    Local @Brush @Offset @Selected

    Mov ebx D@DrawItemStruc
    Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0

    Mov D@Selected 0

    xor eax eax | test D$ebx+DRAWITEM_ITEMSTATE &ODS_SELECTED NOT_ZERO S1>

        xor al 1

S1: Mov B@Selected al

    ; Print Offset
    Mov edx D$DebugFontCharWidth | shl edx 2 | add edx PADDING ; 4 chars
    Mov eax D$ebx+DRAWITEM_RCITEM_LEFT | Mov D$ItemRect@x1 eax
    add eax edx | Mov D$ItemRect@x2 eax
    Move D$ItemRect@y1 D$ebx+DRAWITEM_RCITEM_TOP
    Move D$ItemRect@y2 D$ebx+DRAWITEM_RCITEM_BOTTOM

    Mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    On B@Selected = 1, Mov edi 2
    Call 'GDI32.CreateSolidBrush' D$ARVB.Background.Name+edi*4 | Mov D@Brush eax
    Call 'USER32.FillRect' D$ebx+DRAWITEM_HDC ItemRect D@Brush
    Call 'GDI32.DeleteObject' D@Brush
    Call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC D$ARVB.Background.Name+edi*4

    Mov ecx D$ebx+DRAWITEM_ITEMDATA ; offset into page
    lea edi D@Offset
    Mov B$edi '+'
    Mov al ch | and al 0F
    add al '0'
    On al > '9', add al 7
    Mov B$edi+1 al
    Mov al cl | shr al 4
    add al '0'
    On al > '9', add al 7
    Mov B$edi+2 al
    Mov al cl | and al 0F
    add al '0'
    On al > '9', add al 7
    Mov B$edi+3 al

    Call 'USER32.DrawTextA' D$ebx+DRAWITEM_HDC, edi, 4, ItemRect,
         (&DT_SINGLELINE+&DT_LEFT+&DT_VCENTER)
        ; (&DT_SINGLELINE+&DT_CENTER+&DT_VCENTER)
;;
  Modification proposed by AKar, because the &CENTER+&DT is causing some miss-alignments,
  in the Memory-View, when showing chinese Unicode.
;;

    ; Print value
    Move D$ItemRect@x1 D$ItemRect@x2
    Move D$ItemRect@x2 D$ebx+DRAWITEM_RCITEM_RIGHT

    Mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    On B@Selected = 1, Mov edi 2
    Call 'GDI32.CreateSolidBrush' D$ARVB.Background.Value+edi*4 | Mov D@Brush eax
    Call 'USER32.FillRect' D$ebx+DRAWITEM_HDC, ItemRect, D@Brush
    Call 'GDI32.DeleteObject' D@Brush
    Call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, D$ARVB.Background.Value+edi*4

    If B@Selected = 1
        Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0FF_FFFF
    End_If

    Mov esi D$CurrentPage
    add esi D$ebx+DRAWITEM_ITEMDATA
    Mov edi ItemString
    Mov ecx 8
    Call D$MemFormatConversionProc

    Call 'USER32.DrawTextA' D$ebx+DRAWITEM_HDC, ItemString, 0-1, ItemRect,
         (&DT_SINGLELINE+&DT_CENTER+&DT_VCENTER)

    ; Draw focus rect if selected
    If B@Selected = 1
        lea eax D$ebx+DRAWITEM_RCITEM_LEFT
        Call 'USER32.DrawFocusRect' D$ebx+DRAWITEM_HDC, eax
    End_If
EndP

____________________________________________________________________________________________

; Converts string in Hexadecimal (uppercase) notation to a 32 bit integer. (no leading zeros)
;   esi : String
; Output
;   eax : Integer

HexStringToInt:
    Mov edx 0
    While B$esi <> 0

        lodsb

        ; Sort out invalid chars
        sub al '0' | js L6>  ; FAIL:    [esi] < '0'
        cmp al 9   | jle L0> ; SUCCESS: [esi] = '0'..'9'
        cmp al 17  | jl L6>  ; FAIL:    [esi] < 'A'
        sub al 7
        cmp al 16  | jae L6> ; FAIL:    [esi] > 'F'

L0:     shl edx 4
        or dl al

    EndWhile
    Mov eax edx
ret
; Invalid character error
L6: Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'Hexadecimal notation: Only 0-9 and A-F allowed!' EOS},
        {B$ 'Invalid character' EOS}, &MB_ICONWARNING
    Mov eax 0-1
ret
____________________________________________________________________________________________

; Converts 32 bit integer to string in hexadecimal notation. (no leading zeros)
;   eax : Integer
; Output is stored in 'HexString'.

[HexString: B$ ? # 10]

IntToHexString:
    Push edi
        Mov ecx 8, edx eax, edi HexString

L0:     Mov eax 0
        shld eax edx 4
        shl edx 4

        add al '0'
        On al > '9', add al 7
        stosb
        loop L0<

        Mov B$edi 0
    Pop edi
ret
____________________________________________________________________________________________

; When the user enters an address by hand and presses enter or the 'go' button, this
; proc is called. The string is converted to an integer. Then it is verified if it is
; a valid address. If the address is valid WM_SET_PAGE is sent to the dialog.
; Otherwise the old value is restored.

Proc MemInspector_OnGoToAddress:
    Arguments @hwnd
    Local @Address, @SegBase, @SegLimit
    Uses esi, edi

        Call 'USER32.GetDlgItemTextA' D@hwnd, MEMINSPECTOR_PAGEEDIT, HexString, 10
        Mov esi HexString
      ; Segment override?
        If W$esi = 'FS'
            Move D@SegBase D$FS.Linear
            Move D@SegLimit D$FS.Limit
            add esi 3
        Else
            Mov D@SegBase 0
            Mov D@SegLimit 0_FFFF_FFFF
        End_If
        Call HexStringToInt
        If eax > D@SegLimit
            Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'The offset is beyond the segment limit!' EOS},
                {B$ 'Invalid address' EOS}, &MB_ICONWARNING
            jmp L0>
        End_If

        add eax D@SegBase
        Mov D@Address eax

        Call IsProcessMemory D@Address
        If eax > 0
            Mov eax D@Address
            and eax PageBaseMask
            SendMessage D@hwnd, WM_SET_PAGE, eax, D@Address
        Else
            Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'This is not a valid address!' EOS},
                {B$ 'Invalid address' EOS}, &MB_ICONWARNING
L0:         Mov eax D$CurrentPageAddress
            Call IntToHexString
            Call 'USER32.SetDlgItemTextA' D@hwnd, MEMINSPECTOR_PAGEEDIT, HexString
        End_If
EndP
____________________________________________________________________________________________

; Tag Dialog 1012

Proc MemoryInspectorProc:
    Arguments @hwnd @msg @wParam @lParam
    Uses ebx, esi, edi

    ...If D@msg = &WM_INITDIALOG

        Call VirtualAlloc CurrentPage,
                          01000

        Mov D$CurrentPageAddress 0

        Call 'USER32.GetClientRect' D@hwnd, DebugRect
        Move W$MemInspector.Width W$DebugRect@width
        Move W$MemInspector.Height W$DebugRect@height

        Call 'USER32.GetDlgItem' D@hwnd, MEMINSPECTOR_DATA_LIST | Mov ebx eax
        Mov esi 0
        While esi < 4096
            SendMessage ebx, &LB_ADDSTRING, 0, esi
            add esi 8
        EndWhile

        Call 'USER32.GetDlgItem' D@hwnd, MEMINSPECTOR_FORMAT_COMBO | Mov ebx eax
        SendMessage ebx, &CB_RESETCONTENT, 0, 0
        Mov esi MemFormats
        lodsd
        Mov edi eax
        While edi > 0
            lodsd
            If D$UnicodeStrings = 0
                SendMessage ebx, &CB_ADDSTRING, 0, D$eax
            Else
                Call 'USER32.SendMessageW' ebx, &CB_ADDSTRING, 0, D$eax
            End_If
            dec edi
        EndWhile
        SendMessage ebx, &CB_SETCURSEL, 0, 0
        Move D$MemFormatConversionProc D$MemConvert

        Call 'USER32.GetDlgItem' D@hwnd, MEMINSPECTOR_PREV_BUTTON
        Call 'USER32.EnableWindow' eax, &FALSE
        Call 'USER32.GetDlgItem' D@hwnd, MEMINSPECTOR_NEXT_BUTTON
        Call 'USER32.EnableWindow' eax, &FALSE

        Call 'USER32.GetDlgItem' D@hwnd, MEMINSPECTOR_PAGE_EDIT
        SendMessage eax, &EM_SETLIMITTEXT, 8, 0

        Mov eax &TRUE

    ...Else_If D@msg = WM_REFRESH_CONTENT
        If D$CurrentPageAddress <> 0
            Call 'KERNEL32.ReadProcessMemory' D$PROCESS_INFORMATION@hProcess,
                D$CurrentPageAddress, D$CurrentPage, PAGE_SIZE, &NULL
            Call 'USER32.GetDlgItem' D@hwnd, MEMINSPECTOR_DATA_LIST
            Call 'USER32.InvalidateRect' eax, &NULL, &TRUE
        End_If

        Mov eax 0

    ...Else_If D@msg = WM_SET_PAGE
        Mov eax D@wParam
        If eax <> D$CurrentPageAddress
            Mov D$CurrentPageAddress eax
            Call 'KERNEL32.ReadProcessMemory' D$PROCESS_INFORMATION@hProcess, D@wParam, D$CurrentPage, 01000, &NULL
        End_If
      ; Write Base address of page into an edit
        Mov eax D@wParam
        Call IntToHexString
        Call 'USER32.SetDlgItemTextA' D@hwnd, MEMINSPECTOR_PAGE_EDIT, HexString
      ; Switch to memory inspector tab
        Call SelectTab D$H.DebugDialog, DEBUGDLG_DATA_TAB, 1
      ; Scroll list to address (lParam) and redraw list entries
        Call 'USER32.GetDlgItem' D@hwnd, MEMINSPECTOR_DATA_LIST
        Mov ebx eax
        Mov edi D@lParam
        and edi 0FFF
        shr edi 3
        SendMessage ebx, &LB_SETTOPINDEX, edi, 0
        SendMessage ebx, &LB_SETCURSEL, edi, 0
        Call 'USER32.SetFocus' ebx
      ; Activate / Deactivate Prev & Next Buttons
        Call 'USER32.GetDlgItem' D@hwnd, MEMINSPECTOR_PREV_BUTTON
        Mov ebx eax
        Call FindPrevPage D$CurrentPageAddress
        On eax > 0, Mov eax &TRUE
        Call 'USER32.EnableWindow' ebx, eax
        Call 'USER32.GetDlgItem' D@hwnd, MEMINSPECTOR_NEXT_BUTTON
        Mov ebx eax
        Call FindNextPage D$CurrentPageAddress
        On eax > 0, Mov eax &TRUE
        Call 'USER32.EnableWindow' ebx, eax

        Mov eax 0

    ...Else_If D@msg = &WM_DESTROY

        Call VirtualFree CurrentPage

        Mov eax 0
;;
    ...Else_if D@msg = &WM_KEYDOWN
        Call 'USER32.GetFocus'
        Call 'USER32.GetDlgCtrlID' eax
        ;.If eax = MEMINSPECTOR_PAGE_EDIT
            If W@wParam = &VK_RETURN
                nop
            End_If
        ;.End_If
;;
    ...Else_if D@msg = &WM_COMMAND
        ..If W@wParam = MEMINSPECTOR_FORMAT_COMBO
            .If W@wParam+2 = &CBN_SELCHANGE
                SendMessage D@lParam, &CB_GETCURSEL, 0, 0
                If eax <> &CB_ERR
                    Move D$MemFormatConversionProc D$MemConvert+eax*4
                    Call 'USER32.GetDlgItem' D@hwnd, MEMINSPECTOR_DATA_LIST
                    Call 'USER32.InvalidateRect' eax, &NULL, &TRUE
                End_If
            .End_If
        ..Else_if W@wParam = MEMINSPECTOR_PREV_BUTTON
            Call FindPrevPage D$CurrentPageAddress
            If eax > 0
                SendMessage D@hwnd, WM_SET_PAGE, eax, eax
            End_If
        ..Else_if W@wParam = MEMINSPECTOR_NEXT_BUTTON
            Call FindNextPage D$CurrentPageAddress
            If eax > 0
                SendMessage D@hwnd, WM_SET_PAGE, eax, eax
            End_If
        ..Else_if W@wParam = MEMINSPECTOR_TABLE_BUTTON
            Call 'USER32.DialogBoxParamA' D$H.Instance, 1013, D$H.DebugDialog,
                                          PageTableProc, D$CurrentPageAddress
            If eax >= 01000
                SendMessage D@hwnd, WM_SET_PAGE, eax, eax
            End_If
        ..Else_if W@wParam = MEMINSPECTOR_PAGE_EDIT
            movzx eax W@wParam+2
        ..Else_if W@wParam = &IDOK
            Call MemInspector_OnGoToAddress D@hwnd
        ..End_If
        Mov eax 0

    ...Else_If D@msg = &WM_SIZE
        movzx eax W$MemInspector.Width
        movzx esi W@lParam
        sub esi eax
        movzx eax W$MemInspector.Height
        movzx edi W@lParam+2
        sub edi eax
        Call AdjustControlSize D@hwnd, MEMINSPECTOR_DATA_LIST, esi, edi
        Call AdjustControlSize D@hwnd, MEMINSPECTOR_FORMAT_COMBO, esi, 0
        Call AdjustControlPos D@hwnd, MEMINSPECTOR_PREV_BUTTON, 0, edi
        Call AdjustControlPos D@hwnd, MEMINSPECTOR_NEXT_BUTTON, esi, edi
        Call AdjustControlPos D@hwnd, MEMINSPECTOR_TABLE_BUTTON, 0, edi
        Call AdjustControlSize D@hwnd, MEMINSPECTOR_TABLE_BUTTON, esi, 0
        Call 'USER32.InvalidateRect' D@hwnd, &NULL, &TRUE
        Move D$MemInspectorSize D@lParam
        Mov eax 0

    ...Else_if D@msg = &WM_SETFONT
        Call 'USER32.GetDlgItem' D@hwnd, MEMINSPECTOR_DATA_LIST
        SendMessage eax, &WM_SETFONT, D@wParam, D@lParam
        Call 'USER32.GetDlgItem' D@hwnd, MEMINSPECTOR_PAGE_EDIT
        SendMessage eax, &WM_SETFONT, D@wParam, D@lParam

    ...Else_if D@msg = &WM_DRAWITEM
        Call MemoryInspector_OnDrawItem D@lParam
        Mov eax &TRUE

    ...Else_if D@msg = &WM_MEASUREITEM
        Mov eax D@lParam
        Mov D$eax+16 15
        Mov eax &TRUE

    ...Else
        Mov eax &FALSE
    ...End_If

EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; PAGE TABLE
____________________________________________________________________________________________
____________________________________________________________________________________________

Proc PageTable_WritePageDescription:
    Arguments @Address, @Protect
    Uses esi, edi

        ; Write address
        Mov eax D@Address
        Mov edi PageDesc, ecx 4, edx eax
        test eax 0FFFF ZERO L0>
        Mov D$edi ' >> '
        add edi 4
L0:     add edi 8

L0:     Mov al dl
        Mov ah al | and ah 0F | shr al 4

        add ah '0'
        On ah > '9', add ah 7
        dec edi | Mov B$edi ah
        add al '0'
        On al > '9', add al 7
        dec edi | Mov B$edi al

        shr edx 8
        loop L0<

        ; Write protection "XRWC GN"
        Mov edi Pagedesc+9, ecx D@Protect
        On B$Pagedesc = SPC, add edi 4
        Mov B$edi-1 9
        Mov D$edi '----', D$edi+4 ' -- '
        If ecx = &PAGE_READONLY
            Mov B$edi+1 'R'
        Else_if ecx = &PAGE_READWRITE
            Mov W$edi+1 'RW'
        Else_if ecx = &PAGE_EXECUTE
            Mov B$edi 'X'
        Else_if ecx = &PAGE_EXECUTE_READ
            Mov W$edi 'XR'
        Else_if ecx = &PAGE_EXECUTE_READWRITE
            Mov D$edi 'XRW-'
        Else_if ecx = &PAGE_EXECUTE_WRITECOPY
            Mov D$edi 'XRWC'
        Else_if ecx = &PAGE_WRITECOPY
            Mov D$edi '-RWC'
        End_If
        test ecx &PAGE_GUARD ZERO L0>
        Mov B$edi+5 'G'
L0:     test ecx &PAGE_NOCACHE ZERO L0>
        Mov B$edi+6 'N'
L0:
        ; Write module filename (dll/exe), if available
        Mov edi Pagedesc+17
        On B$Pagedesc = SPC, add edi 4
        Mov eax 0
        Call GetModuleName D@Address
        If eax <> 0
            Mov esi eax
L0:         movsb | cmp B$esi 0 | jne L0<
        End_If
        Mov D$edi 0
EndP

Proc PageTable_AddItem:
    Arguments @Base, @Size, @Protect, @Type
    Uses esi, edi

        Mov esi D@Base, edi esi
        add edi D@Size

        While esi < edi
            Call PageTable_WritePageDescription esi, D@Protect
            SendMessage ebx, &LB_ADDSTRING, 0, PageDesc
            SendMessage ebx, &LB_SETITEMDATA, eax, esi
            add esi 01000
        EndWhile
EndP
____________________________________________________________________________________________

Proc PageTable_Build:
    Uses esi

        Mov esi D$AddressLowerBound
        While esi < D$AddressUpperBound
            Call VirtualQuery esi
            If eax = 1
                Call PageTable_AddItem esi, ecx,
                    D$MemoryInformation@Protect, D$MemoryInformation@Type
            Else_If eax = 0-1
                ExitP
            End_If
            add esi D$MemoryInformation@RegionSize
        EndWhile
EndP
____________________________________________________________________________________________

; Tag Dialog 1013

Proc PageTableProc:
    Arguments @hwnd, @msg, @wParam, @lParam
    Uses ebx, esi, edi

    ..If D@msg = &WM_INITDIALOG
        Call 'USER32.GetDlgItem' D@hwnd, 10
        Mov ebx eax
        SendMessage ebx, &LB_RESETCONTENT, 0, 0
        SendMessage ebx, &WM_SETFONT, D$H.DebugFont, &TRUE
        Call PageTable_Build
        Mov eax &TRUE

    ..Else_if D@msg = &WM_COMMAND
        .If D@wParam = 1
            Call 'USER32.GetDlgItem' D@hwnd, 10
            Mov ebx eax
            SendMessage ebx, &LB_GETCURSEL, 0, 0
            SendMessage ebx, &LB_GETITEMDATA, eax, 0
            Call 'USER32.EndDialog' D@hwnd, eax
        .Else_if W@wParam = 10
            If W@wParam+2 = &LBN_DBLCLK
                SendMessage D@lParam, &LB_GETCURSEL, 0, 0
                SendMessage D@lParam, &LB_GETITEMDATA, eax, 0
                Call 'USER32.EndDialog' D@hwnd, eax
            End_If
        .End_If
        Mov eax 0

    ..Else_if D@msg = &WM_CLOSE
        Call 'USER32.EndDialog' D@hwnd, 0
        Mov eax 0
    ..Else
        Mov eax &FALSE
    ..End_If
EndP
____________________________________________________________________________________________

; Tag Dialog 1014

ShowExceptionInfo:
    Call 'USER32.CreateDialogParamA' D$H.Instance, 1014, D$H.MainWindow, ExceptionInfoProc, D$E.ExceptionCode
ret

[EXCEPTINFO_DESC 10 EXCEPTINFO_ADDRESS 15 EXCEPTINFO_INSTRUCTION 20 EXCEPTINFO_INFO 25]

[ExceptionMap:
 &EXCEPTION_ACCESS_VIOLATION ACCESS_VIOLATION
 &EXCEPTION_ARRAY_BOUNDS_EXCEEDED ARRAY_BOUNDS_EXCEEDED
 &EXCEPTION_DATATYPE_MISALIGNMENT DATATYPE_MISALIGNMENT
 &EXCEPTION_FLT_DENORMAL_OPERAND FLT_DENORMAL_OPERAND
 &EXCEPTION_FLT_DIVIDE_BY_ZERO FLT_DIVIDE_BY_ZERO
 &EXCEPTION_FLT_INEXACT_RESULT FLT_INEXACT_RESULT
 &EXCEPTION_FLT_INVALID_OPERATION FLT_INVALID_OPERATION
 &EXCEPTION_FLT_OVERFLOW FLT_OVERFLOW
 &EXCEPTION_FLT_STACK_CHECK FLT_STACK_CHECK
 &EXCEPTION_FLT_UNDERFLOW FLT_UNDERFLOW
 &EXCEPTION_ILLEGAL_INSTRUCTION ILLEGAL_INSTRUCTION
 &EXCEPTION_IN_PAGE_ERROR IN_PAGE_ERROR
 &EXCEPTION_INT_DIVIDE_BY_ZERO INT_DIVIDE_BY_ZERO
 &EXCEPTION_INT_OVERFLOW INT_OVERFLOW
 &EXCEPTION_PRIV_INSTRUCTION PRIV_INSTRUCTION
 &EXCEPTION_STACK_OVERFLOW STACK_OVERFLOW
 &EXCEPTION_INVALID_DISPOSITION INVALID_DISPOSITION
 &EXCEPTION_NONCONTINUABLE_EXCEPTION NONCONTINUABLE_EXCEPTION
 0 UNKNOWN_EXCEPTION]

Proc ExceptionInfoProc:
    Arguments @hwnd, @msg, @wParam, @lParam
    Uses ebx, esi, edi

    ..If D@msg = &WM_INITDIALOG

      ; Output module in caption
        If D$CurrentModule <> 0
            Mov eax D$CurrentModule
        Else
            Mov eax {B$ 'Exception in Non-Code Section' EOS}
        End_If
        Call 'USER32.SetWindowTextA' D@hwnd, eax

      ; Output exception description
        Mov eax D$E.ExceptionCode
        Mov esi ExceptionMap
        While D$esi <> 0
            cmp eax D$esi | je L0>
            add esi 8
        EndWhile
        Mov edx eax, ecx 4, edi D$esi+4
        Call IntToHex
L0:     Call 'USER32.GetDlgItem' D@hwnd, EXCEPTINFO_DESC | Mov ebx eax
        SendMessage ebx, &WM_SETFONT, D$H.DebugFont, &TRUE
        Call 'USER32.SetWindowTextA' ebx, D$esi+4

      ; Output troubling instruction and its address
        Mov eax D$E.ExceptionAddress
        Call IntToHexString
        Call 'USER32.GetDlgItem' D@hwnd, EXCEPTINFO_ADDRESS | Mov ebx eax
        SendMessage ebx, &WM_SETFONT, D$H.Font1, &TRUE
        Call 'USER32.SetWindowTextA' ebx, HexString

        Call NextInstructionDecode
        Call 'USER32.GetDlgItem' D@hwnd, EXCEPTINFO_INSTRUCTION | Mov ebx eax
        SendMessage ebx, &WM_SETFONT, D$H.Font1, &TRUE
        Call 'USER32.SetWindowTextA' ebx, D$NextInstructionPtr

      ; Output further information for protection faults
        .If D$E.ExceptionCode = &EXCEPTION_ACCESS_VIOLATION
            Mov eax D$E.ExceptionInfo ; read/write
            If eax = 0
                Mov D$AV_ReadWrite 'read', D$AV_ReadWrite+4 ' fro', B$AV_ReadWrite+8 'm'
            Else
                Mov D$AV_ReadWrite 'writ', D$AV_ReadWrite+4 'e at', B$AV_ReadWrite+8 SPC
            End_If
            Mov edx D$E.ExceptionInfo+4 ; inaccessible address
            Mov ecx 4, edi AV_Address
            Call IntToHex
            Call 'USER32.SetDlgItemTextA' D@hwnd, EXCEPTINFO_INFO, Exception_AV
        .End_If

      ; If the exception can be continued hand to the SEH
        Call 'USER32.GetDlgItem' D@hwnd, 2
        Mov edx D$ExceptionFlags | and edx E_MUSTEXIT
        If edx <> 0
            Mov edx 0
        Else
            Mov edx 1
        End_If
        Call 'USER32.EnableWindow' eax, edx

        Call 'USER32.GetDlgItem' D@hwnd, 1
        Call 'USER32.SetFocus' eax
        Mov eax 0

    ..Else_if D@msg = &WM_CTLCOLORSTATIC
        Call 'USER32.GetDlgItem' D@hwnd, EXCEPTINFO_DESC
        If eax = D@lParam
            Call 'GDI32.SetBkColor' D@wParam, D$ARVB.DialogsBackColor
            Mov eax D$H.DialogsBackGroundBrush

EndP

        End_If
        Call 'USER32.GetDlgItem' D@hwnd, EXCEPTINFO_INSTRUCTION
        If eax = D@lParam
            Call 'GDI32.SetTextColor' D@wParam, 099
            Call 'GDI32.SetBkColor' D@wParam, D$ARVB.DialogsBackColor
            Mov eax D$H.DialogsBackGroundBrush

EndP

        End_If
        Call 'USER32.GetDlgItem' D@hwnd, EXCEPTINFO_ADDRESS
        If eax = D@lParam
            Call 'GDI32.SetBkColor' D@wParam, D$ARVB.DialogsBackColor
            Mov eax D$H.DialogsBackGroundBrush

EndP

        End_If
        Mov eax 0

    ..Else_if D@msg = &WM_COMMAND
        .If D@wParam = 1
            Call 'USER32.EndDialog' D@hwnd, 0
            Mov B$TerminateDebuggee &TRUE
            Call DebugDialog_ContinueDebuggee
            ;SendMessage D$H.DebugDialog, &WM_CLOSE, 0, 0
        .Else_If D@wParam = 2
            Call 'USER32.EndDialog' D@hwnd, 0
            Call DebugDialog_ContinueDebuggee
        .End_If
        Mov eax 0

    ..Else_if D@msg = &WM_CLOSE
        Call 'USER32.EndDialog' D@hwnd, 0
        Mov eax 0
    ..Else
        Mov eax &FALSE
    ..End_If
EndP


____________________________________________________________________________________________
____________________________________________________________________________________________

; DATA LABEL VIEWER
____________________________________________________________________________________________
____________________________________________________________________________________________

[PADDING 4]

Proc DataView_OnDrawItem:
    Arguments @DrawItemStruc
    Local @Brush @Address @Selected

    Mov ebx D@DrawItemStruc
    Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0

    Mov D@Selected 0
    xor eax eax | test D$ebx+DRAWITEM_ITEMSTATE &ODS_SELECTED NOT_ZERO S1>

        xor al 1

S1: Mov B@Selected al

  ; Print Offset
    Mov edx D$DebugFontCharWidth | shl edx 3 | add edx PADDING ; 8 chars
    Mov eax D$ebx+DRAWITEM_RCITEM_LEFT | Mov D$ItemRect@x1 eax
    add eax edx | Mov D$ItemRect@x2 eax
    Move D$ItemRect@y1 D$ebx+DRAWITEM_RCITEM_TOP
    Move D$ItemRect@y2 D$ebx+DRAWITEM_RCITEM_BOTTOM

    Mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    On B@Selected = 1, Mov edi 2
    Call 'GDI32.CreateSolidBrush' D$ARVB.Background.Name+edi*4 | Mov D@Brush eax
    Call 'USER32.FillRect' D$ebx+DRAWITEM_HDC ItemRect D@Brush
    Call 'GDI32.DeleteObject' D@Brush
    Call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC D$ARVB.Background.Name+edi*4

    Call IsWatchPoint D$ebx+DRAWITEM_ITEMDATA
    If eax = 1
        Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0CC
    Else_If eax = 3
        Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 066CC
    End_If

    Mov eax D$ebx+DRAWITEM_ITEMDATA
    Call IntToHexString
    Call 'USER32.DrawTextA' D$ebx+DRAWITEM_HDC, HexString, 8, ItemRect,
         (&DT_SINGLELINE+&DT_CENTER+&DT_VCENTER)

  ; Print value
    Move D$ItemRect@x1 D$ItemRect@x2
    Move D$ItemRect@x2 D$ebx+DRAWITEM_RCITEM_RIGHT

    Mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    On B@Selected = 1, Mov edi 2
    Call 'GDI32.CreateSolidBrush' D$ARVB.Background.Value+edi*4 | Mov D@Brush eax
    Call 'USER32.FillRect' D$ebx+DRAWITEM_HDC ItemRect D@Brush
    Call 'GDI32.DeleteObject' D@Brush
    Call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, D$ARVB.Background.Value+edi*4

    If B@Selected = 1
        Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0FF_FFFF
    End_If

    SendMessage D$ebx+DRAWITEM_HWNDITEM, &CB_GETLBTEXT, D$ebx+DRAWITEM_ITEMID, ItemString

    add D$ItemRect@x1 5
    Call 'USER32.DrawTextA' D$ebx+DRAWITEM_HDC, ItemString, 0-1, ItemRect,
         (&DT_SINGLELINE+&DT_LEFT+&DT_VCENTER)

    ; Draw focus rect if selected
    If B@Selected = 1
        lea eax D$ebx+DRAWITEM_RCITEM_LEFT
        Call 'USER32.DrawFocusRect' D$ebx+DRAWITEM_HDC, eax
    End_If
EndP
____________________________________________________________________________________________

Proc DataView_OnDrawValueItem:
    Arguments @DrawItemStruc
    Local @Brush @Address @Selected

    Mov ebx D@DrawItemStruc
    On D$ebx+DRAWITEM_ITEMID = 0-1 EndP

    Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0

    Mov D@Selected 0

    test D$ebx+DRAWITEM_ITEMSTATE &ODS_SELECTED NOT_ZERO S1>

        Mov D@Selected 1

  ; Print size
S1: Mov edx D$DebugFontCharWidth | shl edx 3 | add edx PADDING ; 8 chars
    Mov eax D$ebx+DRAWITEM_RCITEM_LEFT | Mov D$ItemRect@x1 eax
    add eax edx | Mov D$ItemRect@x2 eax
    Move D$ItemRect@y1 D$ebx+DRAWITEM_RCITEM_TOP
    Move D$ItemRect@y2 D$ebx+DRAWITEM_RCITEM_BOTTOM

    Mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    ;On B@Selected = 1, Mov edi 2
    Call 'GDI32.CreateSolidBrush' D$ARVB.Background.Name+edi*4 | Mov D@Brush eax
    Call 'USER32.FillRect' D$ebx+DRAWITEM_HDC ItemRect D@Brush
    Call 'GDI32.DeleteObject' D@Brush
    Call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC D$ARVB.Background.Name+edi*4

    Mov eax D$ebx+DRAWITEM_ITEMDATA
    If al = 'D'
        Mov eax {B$ '32bit' EOS}
    Else_If al = 'W'
        Mov eax {B$ '16bit' EOS}
    Else_If al = 'B'
        Mov eax {B$ '8bit' EOS}
    Else_If al = 'S'
        Mov eax {B$ 'ASCII' EOS}
    Else_If al = 'F'
        Mov eax {B$ '32bit FP' EOS}
    Else_If al = 'R'
        Mov eax {B$ '64bit FP' EOS}
    Else_If al = 'T'
        Mov eax {B$ '80bit FP' EOS}
    End_If
    Call 'USER32.DrawTextA' D$ebx+DRAWITEM_HDC, eax, -1, ItemRect, (&DT_SINGLELINE+&DT_CENTER+&DT_VCENTER)

  ; Print value
    Move D$ItemRect@x1 D$ItemRect@x2
    Move D$ItemRect@x2 D$ebx+DRAWITEM_RCITEM_RIGHT

    Mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    ;On B@Selected = 1, Mov edi 2
    Call 'GDI32.CreateSolidBrush' D$ARVB.Background.Value+edi*4 | Mov D@Brush eax
    Call 'USER32.FillRect' D$ebx+DRAWITEM_HDC ItemRect D@Brush
    Call 'GDI32.DeleteObject' D@Brush
    Call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC D$ARVB.Background.Value+edi*4

    Mov B$HexSeparator 3

    Mov eax D$ebx+DRAWITEM_ITEMDATA, esi DataBuffer
    If al = 'D'
        Mov ecx 4 | Call toHex
        sub edi 2 | Mov W$edi '0x'
    Else_If al = 'W'
        Mov ecx 2 | Call toHex
        sub edi 2 | Mov W$edi '0x'
    Else_If al = 'B'
        Mov ecx 1 | Call toHex
        sub edi 2 | Mov W$edi '0x'
    Else_If al = 'S'
        Mov edi DataBuffer
    Else_If al = 'F'
        Mov ecx 4 | Call toFloat
    Else_If al = 'R'
        Mov ecx 8 | Call toDouble
    Else_If al = 'T'
        Mov ecx 10 | Call toExtended
    End_If

    add D$ItemRect@x1 5
    Call 'USER32.DrawTextA' D$ebx+DRAWITEM_HDC, edi, 0-1, ItemRect,
         (&DT_SINGLELINE+&DT_LEFT+&DT_VCENTER)

    Mov eax D$ItemRect@x2 | sub eax D$ItemRect@x1
    Mov edx 0, ecx 3 | div ecx
    Push eax
        add D$ItemRect@x1 eax

        Mov eax D$ebx+DRAWITEM_ITEMDATA, esi DataBuffer
        If al = 'D'
            Mov ecx 4 | Call toUDWord
        Else_If al = 'W'
            Mov ecx 2 | Call toUWord
        Else_If al = 'B'
            Mov ecx 1 | Call toUByte
        Else
            Pop eax | jmp L0>
        End_If
        Call 'USER32.DrawTextA' D$ebx+DRAWITEM_HDC, edi, 0-1, ItemRect, (&DT_SINGLELINE+&DT_LEFT+&DT_VCENTER)
    Pop eax
    add D$ItemRect@x1 eax

    Mov eax D$ebx+DRAWITEM_ITEMDATA, esi DataBuffer
    If al = 'D'
        Mov ecx 4 | Call toSDWord
    Else_If al = 'W'
        Mov ecx 2 | Call toSWord
    Else_If al = 'B'
        Mov ecx 1 | Call toSByte
    Else
        Pop eax | jmp L0>
    End_If
    Call 'USER32.DrawTextA' D$ebx+DRAWITEM_HDC, edi, 0-1, ItemRect, (&DT_SINGLELINE+&DT_LEFT+&DT_VCENTER)

    ; Draw focus rect if selected
L0: If B@Selected = 1
        lea eax D$ebx+DRAWITEM_RCITEM_LEFT
        Call 'USER32.DrawFocusRect' D$ebx+DRAWITEM_HDC, eax
    End_If
EndP
____________________________________________________________________________________________

; Insert data label sorted by address. Brute force search.

Proc DataView_InsertDataLabel:
    Arguments @H.Combo, @Name, @Address
    Uses ebx

    Mov ebx 0

L0: SendMessage D@H.Combo, &CB_GETITEMDATA, ebx, 0
    cmp eax &CB_ERR | je L1> ; EOL or highest address > append

    If eax > D@Address
L1:     SendMessage D@H.Combo, &CB_INSERTSTRING, ebx, D@Name
        ExitP
    End_If

    inc ebx | jmp L0<
EndP
____________________________________________________________________________________________

; Filling the ComboBox with the Data Label Names (as string) / Addresses (as data)

[H.DataLabelCombo: D$ ?]

Proc DataView_FillDataLabelCombo:
    Arguments @H.Combo @SortByName

    SendMessage D@H.Combo, &CB_RESETCONTENT, 0, 0
    Move D$H.DataLabelCombo D@H.Combo

    Mov esi D$PlainLabelList
    lodsd | Mov edx D$PlainLabelList | add edx eax

L0: inc esi ; '|'

L0: Mov ebx esi
    While B$esi <> 2
        inc esi
    End_While
    test B$esi+5 FLAG_DATA_LABEL ZERO L2>

        Mov edi ItemString, esi ebx
        While B$esi <> 2
            movsb
        End_While
        Mov B$edi 0
        Push edx
            Mov ebx D$esi+1 | add ebx D$DataAjust
            If D@SortByName = 1
                SendMessage D@H.Combo, &CB_ADDSTRING, 0, ItemString
            Else
                Call DataView_InsertDataLabel D@H.Combo, ItemString, ebx
            End_If
            SendMessage D@H.Combo, &CB_SETITEMDATA, eax, ebx
        Pop edx
        add esi 7
        cmp esi edx | jb L0<
    ExitP

L2: add esi 7 | cmp esi edx | jb L0<
EndP
____________________________________________________________________________________________

Proc DataView_LoadSettings:
    Arguments @H.File @Size

  ; Copy label to stack
    Mov eax D@Size | add eax 4 | and eax 0_FFFF_FFFC ; reserve for \0 and dw-align stack
    sub esp eax | Mov edi esp
    Call 'KERNEL32.ReadFile' D@H.File, edi, D@Size, BytesTransfered, 0
    Mov ecx D@Size | Mov B$edi+ecx 0 ; terminate string

  ; Search and select
    SendMessage D$H.DataLabelCombo, &CB_FINDSTRING, 0-1, edi
    SendMessage D$H.DataLabelCombo, &CB_SETCURSEL, eax, 0

    Mov eax 1
EndP
____________________________________________________________________________________________

Proc DataView_SaveSettings:
    Arguments @H.File
    Structure @Settings 8, @Id 0, @Size 4

    Mov D@Id 'LaLa' ; LAst LAbel

  ; Get currently selected label
    SendMessage D$H.DataLabelCombo, &CB_GETCURSEL, 0, 0
    On eax = 0-1, ExitP
    Mov ebx eax
    SendMessage D$H.DataLabelCombo, &CB_GETLBTEXTLEN, ebx, 0
    Mov D@Size eax

  ; Copy label to stack
    add eax 4 | and eax 0_FFFF_FFFC ; reserve for \0 and dw-align stack
    sub esp eax | Mov edi esp
    SendMessage D$H.DataLabelCombo, &CB_GETLBTEXT, ebx, edi

    Call 'KERNEL32.WriteFile' D@H.File, D@Settings, 8, BytesTransfered, 0
    Call 'KERNEL32.WriteFile' D@H.File, edi, D@Size, BytesTransfered, 0
EndP
____________________________________________________________________________________________

[DataBuffer: B$ ? # 64]
[DataPointer: D$ ?]

Proc DataView_OnSelectDataLabel:

    Arguments @H.Dlg,
              @H.Combo

    Local @LabelLen,
          @H.List

        SendMessage D@H.Combo, &CB_GETCURSEL, 0, 0
        On eax = &CB_ERR EndP

        SendMessage D@H.Combo, &CB_GETITEMDATA, eax, 0
        Mov D$DataPointer eax

        Call 'USER32.GetDlgItem' D@H.Dlg, DATAVIEW_VALUE_LIST
        Mov D@H.List eax

        SendMessage D@H.List, &LB_RESETCONTENT, 0, 0

        ; Read a block of memory with a max size of 64 byte
        Call IsProcessMemory D$DataPointer
        On eax = 0 EndP

        Mov ebx 64
        If eax < ebx
            Mov ebx eax
        End_If
        Call 'KERNEL32.ReadProcessMemory' D$PROCESS_INFORMATION@hProcess, D$DataPointer, DataBuffer, ebx, &NULL

        ; DWord Size
        On ebx >= 4, SendMessage D@H.List, &LB_ADDSTRING, 0, 'D'
        ; Word Size
        On ebx >= 2, SendMessage D@H.List, &LB_ADDSTRING, 0, 'W'
        ; Byte size
        SendMessage D@H.List, &LB_ADDSTRING, 0, 'B'
        ; String
        Call IsString DataBuffer 64
        If ah = 1
            Mov B$DataBuffer+63 0
            SendMessage D@H.List, &LB_ADDSTRING, 0, 'S'
        End_If
        ; Float
        On ebx >= 4, SendMessage D@H.List, &LB_ADDSTRING, 0, 'F'
        ; Double
        On ebx >= 8, SendMessage D@H.List, &LB_ADDSTRING, 0, 'R'
        ; Extended
        On ebx >= 10, SendMessage D@H.List, &LB_ADDSTRING, 0, 'T'

        ; Activate 'More' button
        Call 'USER32.GetDlgItem' D@H.Dlg, M03_SHOW_MEM
        Call 'USER32.EnableWindow' eax, &TRUE
        ; Activate/Deactivate 'More From Pointer' button
        .If ebx >= 4
            Call IsProcessMemory D$DataBuffer
            If eax > 0
                Mov ebx &TRUE
            Else
                Mov ebx &FALSE
            End_If
            Call 'USER32.GetDlgItem' D@H.Dlg, M03_SHOW_PMEM
            Call 'USER32.EnableWindow' eax, ebx
            If ebx = &TRUE
                Mov eax &MF_ENABLED
            Else
                Mov eax &MF_GRAYED
            End_If
            Call 'USER32.EnableMenuItem' D$DataView.PopupMenu, M03_SHOW_PMEM, eax
        .End_If
EndP
____________________________________________________________________________________________

Proc DataView_SelectSymbol:
    Arguments @H.Dlg, @Address
    Local @H.Combo

        Call SelectTab D$H.DebugDialog, DEBUGDLG_DATA_TAB, 0
        Call 'USER32.GetDlgItem' D@H.Dlg, DATAVIEW_LABEL_COMBO
        Mov D@H.Combo eax
        SendMessage D@H.Combo, &CB_GETCOUNT, 0, 0
        Mov edi eax, esi 0, ebx D@Address
        While esi < edi
            SendMessage D@H.Combo, &CB_GETITEMDATA, esi, 0
            If eax = ebx
                SendMessage D@H.Combo, &CB_SETCURSEL, esi, 0
                ExitP
            End_If
            inc esi
        EndWhile
EndP

____________________________________________________________________________________________

Proc DataView_ShowDeclaration:
    Arguments @H.Dlg
    Local @H.Combo, @LabelLen

        Call 'USER32.GetDlgItem' D@H.Dlg, DATAVIEW_LABEL_COMBO
        Mov D@H.Combo eax

        SendMessage D@H.Combo, &CB_GETCURSEL, 0, 0
        On eax = &CB_ERR, ExitP
        SendMessage D@H.Combo, &CB_GETLBTEXT, eax, ItemString
        Mov D@LabelLen eax

        Call RestoreRealSource

        Mov edx ItemString, ebx D@LabelLen
        Call InternSearch
        If D$FL.BlockInside = &TRUE
            Mov D$FL.BlockInside &FALSE
            Mov esi D$STRUCT.EditData@CurrentWritingPos | dec esi | Call InternalRightClick
        End_If

        Call SetPartialEditionFromPos
EndP
____________________________________________________________________________________________

[DataView.PopupMenu: D$ ?]

[M03_SHOW_MEM       3100
 M03_SHOW_PMEM      3101
 M03_SHOW_DECL      3102
 M03_WATCH_W        3103
 M03_WATCH_RW       3104
 M03_SORTBYNAME     3105
 M03_SORTBYADDRESS  3106]

DataView_CreatePopupMenu:

    Call 'USER32.CreatePopupMenu'

    Mov ebx eax, D$DataView.PopupMenu eax

    Call AppendMenu ebx, &MF_OWNERDRAW, M03_SHOW_MEM, 0

    Call AppendMenu ebx, &MF_OWNERDRAW, M03_SHOW_PMEM, 0

    Call AppendMenu ebx, &MF_OWNERDRAW, M03_SHOW_DECL, 0

    Call AppendMenu ebx, &MF_SEPARATOR, 0, 0

    Call AppendMenu ebx, &MF_OWNERDRAW, M03_WATCH_W, 0

    Call AppendMenu ebx, &MF_OWNERDRAW, M03_WATCH_RW, 0

    Call AppendMenu ebx, &MF_SEPARATOR, 0, 0

    Call AppendMenu ebx, &MF_OWNERDRAW, M03_SORTBYNAME, 0

    Call AppendMenu ebx, &MF_OWNERDRAW, M03_SORTBYADDRESS, 0

    Call 'USER32.CheckMenuRadioItem' D$DataView.PopupMenu,
                                     M03_SORTBYNAME,
                                     M03_SORTBYADDRESS,
                                     M03_SORTBYNAME,
                                     &MF_BYCOMMAND

ret
____________________________________________________________________________________________

DataView_UpdatePopupMenu:

    Call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_RW, &MF_UNCHECKED
    Call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_W, &MF_UNCHECKED
    Call IsWatchPoint D$DataPointer
    If eax = 0011
        Call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_RW, &MF_CHECKED
    Else_If eax = 1
        Call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_W, &MF_CHECKED
    End_If

ret
____________________________________________________________________________________________

; Process WM_DRAWITEM message for owner-drawn menu items.
;;
Proc DebugDialog_OnDrawMenuItem:
    Arguments @DrawItemStruc
    Local @Brush

    Mov ebx D@DrawItemStruc

    Mov esi DebugMenuTable
    lodsd | Mov ecx eax ; number of entries
    Mov eax D$ebx+DRAWITEM_ITEMID
    While D$esi <> eax
        add esi 16
        dec ecx | jz L9>>
    EndWhile

    Call 'GDI32.SelectObject' D$ebx+DRAWITEM_HDC, D$DialogFont_handle
    Push eax

    Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_GRAYED
        Call 'USER32.GetSysColor' &COLOR_GRAYTEXT
        Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax
        jmp L1>
    Test_Else_If D$ebx+DRAWITEM_ITEMSTATE &ODS_SELECTED
        Call 'USER32.GetSysColor' &COLOR_MENUTEXT
        Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax

        Call 'USER32.GetSysColor' &COLOR_HIGHLIGHTTEXT
        Call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, eax

        Call 'USER32.GetSysColorBrush' &COLOR_HIGHLIGHTTEXT
    Test_Else
        Call 'USER32.GetSysColor' &COLOR_MENUTEXT
        Call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax

L1:     Call 'USER32.GetSysColor' &COLOR_MENU
        Call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, eax

        Call 'USER32.GetSysColorBrush' &COLOR_MENU
    Test_End

    lea edx D$ebx+DRAWITEM_RCITEM_LEFT
    Call 'USER32.FillRect' D$ebx+DRAWITEM_HDC, edx, eax

    Mov eax D$esi+12 ; image index
    If eax <> 0-1
        Mov ecx D$ebx+DRAWITEM_RCITEM_LEFT | add ecx 2
        Mov edx D$ebx+DRAWITEM_RCITEM_TOP  | add edx 2
        Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_GRAYED
            Mov edi &ILD_MASK
        Test_Else_If D$ebx+DRAWITEM_ITEMSTATE &ODS_SELECTED
            Mov edi &ILD_NORMAL
        Test_Else
            Mov edi &ILD_TRANSPARENT
        Test_End

        Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_CHECKED
            Mov eax 6
        Test_End

L0:     Call 'COMCTL32.ImageList_Draw' D$DebugDialog_ImageList, eax, D$ebx+DRAWITEM_HDC, ecx, edx, edi
    End_If

    add D$ebx+DRAWITEM_RCITEM_LEFT 22

    Mov eax D$esi+4
    Call DrawMenuItemText D$eax, &DT_LEFT

    Mov eax D$esi+8
    If eax <> 0
      ; Draw shortcut rightaligned
        dec D$ebx+DRAWITEM_RCITEM_RIGHT
        Call DrawMenuItemTextA eax, &DT_RIGHT
    End_If

    Pop eax
    Call 'GDI32.SelectObject' D$ebx+DRAWITEM_HDC, eax

L9: Mov eax 1
EndP
;;
____________________________________________________________________________________________

; To allow rightclick inside the list of a combobox we override the window proc of the list.
; The listbox is a child window of the combobox from which the handle is retrieved through
; enumerating.

[ComboListClass: B$ 'ComboLBox' EOS] ; consistent among all win OS's ?
[ComboChildClass: B$ ? # 32]

Proc EnumComboChilds:
    Arguments @hwnd, @Param
    Uses esi, edi

    Call 'USER32.GetClassNameA' D@hwnd, ComboChildClass, 32
    Mov edi ComboListClass, esi ComboChildClass, ecx eax
    repe cmpsb | je L1>
    Mov eax 1 | ExitP ; continue search

  ; Listbox of the combo
L1: Call 'USER32.SetWindowLongA' D@hwnd, &GWL_WNDPROC, DataView_InterceptRightClick
    Mov D$DataView.LBProc eax
    Mov eax 0 ; finish search
EndP
____________________________________________________________________________________________

Proc DataView_OverrideComboProc:
    Arguments @H.Dlg

    Mov D$DataView.LBProc 0
    Call 'USER32.GetDlgItem' D@H.Dlg, DATAVIEW_LABEL_COMBO | Mov ebx eax
    Call 'USER32.EnumChildWindows' ebx, EnumComboChilds, 0
    If D$DataView.LBProc = 0
        Call 'USER32.MessageBoxA' D$H.MainWindow,
            {B$ 'Listbox not found in combo! Please report this problem and your OS version on the board.' EOS},
            {B$ 'EnumChildWindows' EOS}, &MB_OK+&MB_ICONWARNING
    End_If
EndP

[DataView.LBProc: D$ ?]

Proc DataView_InterceptRightClick:
    Arguments @hwnd, @msg, @wParam, @lParam
    Uses ebx esi edi

    If D@msg = &WM_RBUTTONDOWN
      ; Simulate left click (select item) before showing the popup menu
        SendMessage D@hwnd, &WM_LBUTTONDOWN, D@wParam, D@lParam
        SendMessage D@hwnd, &WM_LBUTTONUP, D@wParam, D@lParam
      ; Show the popup menu at the position of the mouse-click
        movzx eax W@lParam
        movzx ecx W@lParam+2
        Mov D$STRUC.POINT+POINTX eax, D$STRUC.POINT+POINTY ecx
        Call 'USER32.ClientToScreen' D@hwnd, STRUC.POINT
        Call 'USER32.TrackPopupMenu' D$DataView.PopupMenu, &TPM_LEFTALIGN, D$STRUC.POINT+POINTX, D$STRUC.POINT+POINTY, 0, D$H.DataView, 0
    Else_If D@msg = &WM_LBUTTONDBLCLK
      ; Show more
        Mov eax D$DataPointer | and eax 0_FFFF_F000
        SendMessage D$H.MemoryInspector, WM_SET_PAGE, eax, D$DataPointer
    End_If
    Call 'USER32.CallWindowProcA' D$DataView.LBProc, D@hwnd, D@msg, D@wParam, D@lParam
EndP
____________________________________________________________________________________________

; Process WM_INITDIALOG message.

Proc DataViewDialog_OnCreate:
    Arguments @hwnd

        Call 'USER32.GetClientRect' D@hwnd, DebugRect
        Move W$DataView.Width W$DebugRect@width
        Move W$DataView.Height W$DebugRect@height

        Call 'USER32.GetDlgItem' D@hwnd, DATAVIEW_LABEL_COMBO
        Call DataView_FillDataLabelCombo eax 1

        Call DataView_CreatePopupMenu
        Call DataView_OverrideComboProc D@hwnd

        Mov eax &TRUE
EndP
____________________________________________________________________________________________

; Process WM_SIZE message.

Proc DataViewDialog_OnSize:
    Arguments @hwnd, @WidthHeight

        movzx eax W$DataView.Width
        movzx esi W@WidthHeight
        sub esi eax
        movzx eax W$DataView.Height
        movzx edi W@WidthHeight+2
        sub edi eax
        Call AdjustControlSize D@hwnd, DATAVIEW_LABEL_COMBO, esi, edi
        Call AdjustControlSize D@hwnd, DATAVIEW_VALUE_LIST, esi, 0
        Call AdjustControlPos D@hwnd, DATAVIEW_VALUE_LIST, 0, edi
        Call 'USER32.InvalidateRect' D@hwnd, &NULL, &TRUE

        Move D$DataViewSize D@WidthHeight
        Mov eax 0
EndP
____________________________________________________________________________________________

; Process WM_COMMAND message.

Proc DataViewDialog_OnCommand:
    Arguments @hwnd, @wParam, @lParam

        movzx ecx W@wParam
        movzx eax W@wParam+2
        .If ecx = DATAVIEW_LABEL_COMBO
            If eax = &CBN_SELCHANGE
                Call DataView_OnSelectDataLabel D@hwnd, D@lParam
                Call DataView_UpdatePopupMenu
            End_If
        .Else_If ecx = M03_SHOW_MEM
            Mov eax D$DataPointer
            and eax 0_FFFF_F000
            SendMessage D$H.MemoryInspector, WM_SET_PAGE, eax, D$DataPointer
        .Else_If ecx = M03_SHOW_PMEM
            Mov eax D$DataBuffer
            and eax 0_FFFF_F000
            SendMessage D$H.MemoryInspector, WM_SET_PAGE, eax, D$DataBuffer
        .Else_If ecx = M03_SHOW_DECL
            Call DataView_ShowDeclaration D@hwnd
        .Else_If ecx = M03_WATCH_W
            Call 'USER32.GetMenuState' D$DataView.PopupMenu, M03_WATCH_W, 0
            and eax &MF_CHECKED
            If eax = 0
                Call SetWatchPoint D$DataPointer, 4, 1
                Call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_W, &MF_CHECKED
            Else
                Call DeleteWatchPoint
                Call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_W, &MF_CHECKED
            End_If
            Call 'USER32.GetDlgItem' D@hwnd, DATAVIEW_LABEL_COMBO
            Call 'USER32.InvalidateRect' eax, 0, &FALSE
        .Else_If ecx = M03_WATCH_RW
            Call 'USER32.GetMenuState' D$DataView.PopupMenu, M03_WATCH_RW, 0
            and eax &MF_CHECKED
            If eax = 0
                Call SetWatchPoint D$DataPointer, 4, 3
                Call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_RW, &MF_CHECKED
            Else
                Call DeleteWatchPoint
                Call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_RW, &MF_CHECKED
            End_If
            Call 'USER32.GetDlgItem' D@hwnd, DATAVIEW_LABEL_COMBO
            Call 'USER32.InvalidateRect' eax, 0, &FALSE
        .Else_If ecx = M03_SORTBYNAME
            Call 'USER32.CheckMenuRadioItem' D$DataView.PopupMenu, M03_SORTBYNAME, M03_SORTBYADDRESS,
                                             M03_SORTBYNAME, &MF_BYCOMMAND
            Call DataView_FillDataLabelCombo D$H.DataLabelCombo 1

        .Else_If ecx = M03_SORTBYADDRESS
            Call 'USER32.CheckMenuRadioItem' D$DataView.PopupMenu, M03_SORTBYNAME, M03_SORTBYADDRESS,
                                             M03_SORTBYADDRESS, &MF_BYCOMMAND
            Call DataView_FillDataLabelCombo D$H.DataLabelCombo 0
        .End_If

        Mov eax 0
EndP
____________________________________________________________________________________________

[DataViewSize:
 DataView.Width: W$ ?
 DataView.Height: W$ ?]

[DATAVIEW_LABEL_COMBO 50
 DATAVIEW_VALUE_LIST 120]

; Tag Dialog 1011

Proc DataViewProc:
    Arguments @hwnd, @msg, @wParam, @lParam
    Uses ebx, esi, edi

    .If D@msg = &WM_INITDIALOG
        Call DataViewDialog_OnCreate D@hwnd

    .Else_If D@msg = &WM_SIZE
        Call DataViewDialog_OnSize D@hwnd, D@lParam

    .Else_If D@msg = &WM_COMMAND
        Call DataViewDialog_OnCommand D@hwnd, D@wParam, D@lParam

    .Else_if D@msg = WM_REFRESH_CONTENT
        Call 'USER32.GetDlgItem' D@hwnd, DATAVIEW_LABEL_COMBO
        Call DataView_OnSelectDataLabel D@hwnd, eax

    .Else_if D@msg = WM_SELECT_SYMBOL
        Call DataView_SelectSymbol D@hwnd, D@wParam

    .Else_if D@msg = &WM_SETFONT
        Call 'USER32.GetDlgItem' D@hwnd, DATAVIEW_LABEL_COMBO
        SendMessage eax, &WM_SETFONT, D@wParam, D@lParam
        Call 'USER32.GetDlgItem' D@hwnd, DATAVIEW_VALUE_LIST
        SendMessage eax, &WM_SETFONT, D@wParam, D@lParam

    .Else_if D@msg = &WM_DRAWITEM
        If D@wParam = 0
            Call DebugDialog_OnDrawMenuItem D@lParam
        Else_If D@wParam = DATAVIEW_LABEL_COMBO
            Call DataView_OnDrawItem D@lParam
        Else
            Call DataView_OnDrawValueItem D@lParam
        End_If
        Mov eax &TRUE

    .Else_if D@msg = &WM_MEASUREITEM
        Mov eax D@lParam
        If D@wParam = 0
          ; menu
            Call DebugDialog_OnMeasureMenuItem D@lParam
        Else
          ; listbox
            Mov D$eax+16 15
        End_If
        Mov eax &TRUE

    .Else
        Mov eax &FALSE
    .End_If
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; Conversion Routines
;   esi : Address of Register (in Context)
;   ecx : Size in Bytes
; Output
;   edi : Address of Ascii String

[HexSeparator: D$ ?]

toHex:
    Mov edi StringBufTail
    Mov eax 0, B$edi 0

L0: lodsb
    Mov ah al | and ah 0F | shr al 4

    add ah '0'
    On ah > '9', add ah 7
    dec edi | Mov B$edi ah

    add al '0'
    On al > '9', add al 7
    dec edi | Mov B$edi al

    dec ecx
    jecxz L1>

    test B$HexSeparator cl NOT_ZERO L0<

    dec edi | Mov B$edi SPC

    jmp L0<

L1: ret

toAscii:
    Mov edi StringBuf
    rep movsb
    Mov B$edi 0
    Mov edi StringBuf
ret
____________________________________________________________________________________________

; Convert dword value to hex-string onto specified buffer
;   ecx : size of value (1 | 2 | 4)
;   edx : source value (dl | dx | edx)
;   edi : address of destination
; Output
;   edi : address behind hex-string
; Uses
;   eax, edx

[DwordToHex | Mov ecx 4 | Mov edx #1 | Call IntToHex]
[WordToHex  | Mov ecx 2 | Mov  dx #1 | Call IntToHex]
[ByteToHex  | Mov ecx 1 | Mov  dl #1 | Call IntToHex]

IntToHex:
    Mov eax ecx | add eax eax
    add edi eax
    Mov eax 0 ;, B$edi 0

    Push edi

L0:     Mov al dl | shr edx 8
        Mov ah al | and ah 0F | shr al 4

        add ah '0'
        On ah > '9', add ah 7
        dec edi | Mov B$edi ah

        add al '0'
        On al > '9', add al 7
        dec edi | Mov B$edi al

        dec ecx | jnz L0<

    Pop edi
ret
____________________________________________________________________________________________

; Special routine to output meaningful information for segment regs.
; The format is "ssss Base: bbbbbbbb Limit: llllllll"
;   esi: Address of Register
;   edi: Address of Base+Limit
; Output
;   edi: Ascii String

[SegInfo: B$ 'xxxx Base: B$ '
 SegInfo.Base: B$ 'xxxxxxxx Limit: '
  SegInfo.Limit: B$ 'xxxxxxxx' EOS]

toSegHex:
    Push edx
        Mov ecx 2, dx W$esi
        Mov esi edi
        Mov edi SegInfo
        Call IntToHex

        Mov ecx 4, edx D$esi
        Mov edi SegInfo.Base
        Call IntToHex

        Mov ecx 4, edx D$esi+4
        Mov edi SegInfo.Limit
        Call IntToHex
    Pop edx
    Mov edi SegInfo
ret
____________________________________________________________________________________________

Proc toBinary:
    Uses edx

        Mov edi StringBufTail, B$edi 0

L0:     Mov dl 1
        lodsb

L1:     Mov ah '0'
        test al dl ZERO L2>
        inc ah
L2:     dec edi | Mov B$edi ah
        shl dl 1
        jnc L1<

        dec edi | Mov B$edi SPC
        loop L0<
        inc edi
EndP
____________________________________________________________________________________________

Proc toSByte:
    Uses ebx, edx

        Mov edi StringBufTail, B$edi 0, ebx 10

L0:     lodsb
        Mov dl al
        test dl 0_80 ZERO L1>
        neg al

L1:     Mov ah 0
        div bl
        add ah '0'
        dec edi | Mov B$edi ah
        cmp al 0 | jnz L1<

        test dl 0_80 ZERO L2>
        dec edi | Mov B$edi '-'

L2:     dec edi | Mov B$edi SPC
        loop L0<

        inc edi
EndP

Proc toUByte:
    Uses ebx

        Mov edi StringBufTail, B$edi 0, ebx 10

L0:     lodsb

L1:     Mov ah 0
        div bl
        add ah '0'
        dec edi | Mov B$edi ah
        cmp al 0 | jnz L1<

        dec edi | Mov B$edi SPC
        loop L0<

        inc edi
EndP
____________________________________________________________________________________________

Proc toSWord:
    Uses ebx, edx

        Mov edi StringBufTail, B$edi 0, ebx 10
        shr ecx 1

L0:     lodsw

        test B$esi-1 0_80 ZERO L4>
        neg ax

L4:     movzx eax ax
L1:     Mov edx 0
        div ebx
        add dl '0'
        dec edi | Mov B$edi dl
        cmp eax 0 | jnz L1<

        test B$esi-1 0_80 ZERO L2>
        dec edi | Mov B$edi '-'

L2:     dec edi | Mov B$edi SPC
        loop L0<

        inc edi
EndP

Proc toUWord:
    Uses ebx, edx

        Mov edi StringBufTail, B$edi 0, ebx 10
        shr ecx 1

L0:     lodsw
        movzx eax ax

L1:     Mov edx 0
        div ebx
        add dl '0'
        dec edi | Mov B$edi dl
        cmp eax 0 | jnz L1<

        dec edi | Mov B$edi SPC
        loop L0<

        inc edi
EndP
____________________________________________________________________________________________

Proc toSDword:
    Uses ebx, edx

        Mov edi StringBufTail, B$edi 0, ebx 10
        shr ecx 2

L0:     lodsd

        test B$esi-1 0_80 ZERO L1>
        neg eax

L1:     Mov edx 0
        div ebx
        add dl '0'
        dec edi | Mov B$edi dl
        cmp eax 0 | jnz L1<

        test B$esi-1 0_80 ZERO L2>
        dec edi | Mov B$edi '-'

L2:     dec edi | Mov B$edi SPC
        loop L0<

        inc edi
EndP

Proc toUDword:
    Uses ebx, edx

        Mov edi StringBufTail, B$edi 0, ebx 10
        shr ecx 2

L0:     lodsd

L1:     Mov edx 0
        div ebx
        add dl '0'
        dec edi | Mov B$edi dl
        cmp eax 0 | jnz L1<

        dec edi | Mov B$edi SPC
        loop L0<

        inc edi
EndP
____________________________________________________________________________________________

Proc toFloat:
    Uses edx

        shr ecx 2 | dec ecx
        Mov B$StringBuf 0, edx ecx

L0:     fld D$esi+edx*4 | fstp T$FloatBuf
        Mov edi StringBuf, al 0, ecx 255
        repne scasb
        Mov B$edi-1 SPC
        Call FloatToUString FloatBuf edi

        dec edx | jns L0<

        Mov edi StringBuf | inc edi
EndP

Proc toDouble:
    Uses edx

        shr ecx 3 | dec ecx
        Mov B$StringBuf 0, edx ecx

L0:     fld Q$esi+edx*8 | fstp T$FloatBuf
        Mov edi StringBuf, al 0, ecx 255
        repne scasb
        Mov B$edi-1 SPC
        Call FloatToUString FloatBuf edi

        dec edx | jns L0<

        Mov edi StringBuf | inc edi
EndP

toExtended:
    Mov edi StringBuf
    Call FloatToUString esi edi
ret

[StringBuf: B$ ? # 255
 StringBufTail: B$ ?]
[FloatBuf: T$ ?]
____________________________________________________________________________________________

toHexWithAnsi:
    Push esi, ecx
L0:     lodsb
        Mov ah al | and ah 0F | shr al 4
        add al '0'
        On al > '9', add al 7
        Mov B$edi al | inc edi
        add ah '0'
        On ah > '9', add ah 7
        Mov B$edi ah | inc edi
        Mov B$edi SPC | inc edi
        loop L0<
        Mov al '"' | stosb
    Pop ecx, esi
L0: lodsb
    If al < SPC
        Mov al '.'
    Else_If al = '&'
        stosb
    End_If
    stosb
    loop L0<
    Mov al '"' | stosb
    Mov B$edi 0
ret
____________________________________________________________________________________________

[InversedLowSigns: B$ '.|| ..^/*-+.)(:$.][][,}.{##."...']

toHexWithCookedAnsi:
    Push esi, ecx
L0:     lodsb
        Mov ah al | and ah 0F | shr al 4
        add al '0'
        On al > '9', add al 7
        Mov B$edi al | inc edi
        add ah '0'
        On ah > '9', add ah 7
        Mov B$edi ah | inc edi
        Mov B$edi SPC | inc edi
        loop L0<
        Mov al '"' | stosb
    Pop ecx, esi

    xor eax eax

L0: lodsb
    On al < SPC, Mov al B$InversedLowSigns+eax
    and al 07F
    stosb
    On al = '&', stosb
    loop L0<

    Mov al '"' | stosb
    Mov B$edi 0
ret

____________________________________________________________________________________________

toHexDwords:
    Mov edx ecx
L1:     Mov ecx 4
L0:         lodsb
            Mov ah al | and ah 0F | shr al 4
            add ah '0'
            On ah > '9', add ah 7
            Mov B$edi+ecx*2-1 ah
            add al '0'
            On al > '9', add al 7
            Mov B$edi+ecx*2-2 al
        loop L0<
        Mov B$edi+8 SPC
        add edi 9
        sub edx 4
    jnz L1<
    Mov B$edi-1 0
ret
____________________________________________________________________________________________

toHexWords:
    Mov edx ecx
L1:     Mov ecx 2
L0:         lodsb
            Mov ah al | and ah 0F | shr al 4
            add ah '0'
            On ah > '9', add ah 7
            Mov B$edi+ecx*2-1 ah
            add al '0'
            On al > '9', add al 7
            Mov B$edi+ecx*2-2 al
        loop L0<
        Mov B$edi+4 SPC
        add edi 5
        sub edx 2
    jnz L1<
    Mov B$edi-1 0
ret
____________________________________________________________________________________________

Proc toFloats:
    Uses edx

        shr ecx 2
        Mov edx ecx
        Mov ecx 0-1

        While edx > 0
            fld D$esi | fstp T$FloatBuf
            Call FloatToUString FloatBuf edi
            add esi 4
            Mov al 0, ecx 255
            repne scasb
            Mov B$edi-1 SPC
            dec edx
        EndWhile
        Mov B$edi-1 0
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; Show a tooltip(-like) window.
____________________________________________________________________________________________
____________________________________________________________________________________________

; Show a hint when the user holds the mouse over a datalabel in the source-editor

;[DataHintWinHandle: D$ ? DataHintVisible: D$ ? DataHintTimer: D$ ?]

[MouseHintTimer:    D$ ?
 MouseHintVisible:  D$ ?]

InitMouseOverDataHints:
;;
    Call 'USER32.CreateWindowExA' 0, StaticClassName, 0, &WS_POPUP+&SS_LEFT,
        &CW_USEDEFAULT, &CW_USEDEFAULT, 250, D$FontHeight,
        D$H.MainWindow, 0, D$H.Instance, 0

    Mov D$DataHintWinHandle eax, D$DataHintVisible 0
    
    SendMessage D$DataHintWinHandle, &WM_SETFONT, D$H.DebugFont, &TRUE
;;
    Call CreateNewForm_MouseHint
    Call 'USER32.SetTimer' 0, 2, 1000, MouseOverDataHint
    Mov D$MouseHintTimer eax
ret

DeleteMouseOverDataHints:
    Call 'USER32.KillTimer' 0, D$MouseHintTimer
    Mov D$MouseHintTimer 0
    Call 'USER32.DestroyWindow' D$H.MouseHintForm
    Mov D$H.MouseHintForm 0
ret

Proc MouseOverDataHint:
    Arguments @hwnd, @Msg, @id, @Time
    Local @Column, @Row, @Size, @Address
    Uses ebx, esi, edi

    On D$FL.IsDebugging = 0, jmp @Invalid

  ; Check if mouse is inside client space
    Call 'USER32.GetCursorPos' STRUC.POINT
    Call 'USER32.ScreenToClient' D$H.MainWindow, STRUC.POINT
    Mov eax D$STRUC.POINT+POINTX
    cmp eax D$RECTleft  | jl @Invalid
    cmp eax D$RECTright | jg @Invalid
    Mov edx D$STRUC.POINT+POINTY
    cmp edx D$RECTtop    | jl @Invalid
    cmp edx D$RECTbottom | jg @Invalid

    On D$FL.ToolbarWanted = 1 sub edx D$ToolBarPixelsHight

    Move W$MousePosX ax, W$MousePosY dx

    Call SimpleMouseTextPos

    Mov D@Column eax, D@Row ebx
    Push D$STRUCT.EditData@CaretRow
        Call SearchTxtPtr
    Pop D$STRUCT.EditData@CaretRow
    Mov esi eax, ecx 0-1

    Call MouseHint@ScanForSeparator
    On eax = 0-1, jmp @Invalid
    Do
        Call MouseHint@LookupEquates
    Loop_Until ebx = 0
    Call MouseHint@Evaluate
    On eax = 0, jmp @Invalid

    Call RowToX D@Column | Mov D$STRUC.POINT+POINTX eax
    Call LineToY D@Row   | add eax D$FontHeight
    On D$FL.ToolbarWanted = 1, add eax D$ToolBarPixelsHight
    Mov D$STRUC.POINT+POINTY eax
    Call 'USER32.ClientToScreen' D$H.MainWindow, STRUC.POINT

    Call 'USER32.InvalidateRect' D$H.MouseHintForm, 0, 1
    Call 'USER32.SetWindowPos' D$H.MouseHintForm, 0, D$STRUC.POINT+POINTX, D$STRUC.POINT+POINTY, 0, 0, &SWP_NOSIZE+&SWP_SHOWWINDOW+&SWP_NOACTIVATE+&SWP_NOZORDER

    Mov D$MouseHintVisible 1
    ExitP

@Invalid:
    If D$MouseHintVisible = 1
        Call 'USER32.SetWindowPos' D$H.MouseHintForm, 0, 0, 0, 0, 0, &SWP_HIDEWINDOW+&SWP_NOMOVE+&SWP_NOSIZE+&SWP_NOACTIVATE+&SWP_NOZORDER
        Mov D$MouseHintVisible 0
    End_If
EndP

____________________________________________________________________________________________

[H.MouseHintForm: D$ ?]

; Tag Wizard Form "C:\projekte\RosAsm\Work\WizardFiles\WZRDForm0001.wwf"
CreateNewForm_MouseHint:

    Call 'USER32.RegisterClassExA' MouseHintFormClass

    imul eax D$FontHeight 4

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
                                  MouseHintFormClassName,
                                  &NULL,
                                  &WS_BORDER+&WS_OVERLAPPED+&WS_POPUP,
                                  0,
                                  0,
                                  160,
                                  eax,
                                  D$H.MainWindow,
                                  0,
                                  D$H.Instance,
                                  0

    Mov D$H.MouseHintForm eax

    Call 'USER32.SendMessageA' D$H.MouseHintForm,
                               &WM_SETFONT,
                               D$H.DebugFont,
                               &TRUE

ret
____________________________________________________________________________________________
[MouseHintFormClass:
 @cbSize:        D$ len
 @style:         D$ 0
 @lpfnWndProc:   D$ MouseHintFormProc
 @cbClsExtra:    D$ 0
 @cbWndExtra:    D$ 0
 @hInstance:     D$ 0
 @hIcon:         D$ 0
 @hCursor:       D$ 0
 @hbrBackground: D$ 1
 @lpszMenuName:  D$ 0
 @lpszClassName: D$ MouseHintFormClassName
 @hIconSm:       D$ 0]
[MouseHintFormClassName: B$ "MouseHintForm" EOS]
____________________________________________________________________________________________

Proc MouseHintFormProc:
    Arguments @hwnd @msg @wParam @lParam
    Local @Brush
    Structure @PaintStruct 64 @hdc 0
    Uses esi, edi, ebx

    .If D@msg = &WM_CREATE
        Mov eax 0

    .Else_If D@msg = &WM_CLOSE
        Call 'USER32.DestroyWindow' D@hwnd

    .Else_If D@msg = &WM_DESTROY
        Mov eax 0

    .Else_If D@msg = &WM_PAINT
        If D$FL.IsDebugging = &TRUE
            Call 'USER32.BeginPaint' D@hwnd, D@PaintStruct
            Call 'GDI32.SelectObject' D@hdc, D$H.DebugFont
            Call MouseHintDrawWindow D@hwnd, D@hdc
            Call 'USER32.EndPaint' D@hwnd D@PaintStruct
        End_If
        Mov eax 0

    .Else
        Call 'USER32.DefWindowProcA' D@hwnd D@msg D@wParam D@lParam
    .End_If

EndP
; Tag End
____________________________________________________________________________________________


Proc MouseHintDrawWindow:

    Arguments @hwnd @hdc

    Local @Brush

    Structure @Rect 16 @left 0 @top 4 @right 8 @bottom 12

    [@Line1: B$ ? # 16
     @Line2: B$ ? # 16
     @Line3: B$ ? # 16]

    Call 'USER32.GetClientRect' D@hwnd, D@Rect
    Move D@bottom D$FontHeight

    Call 'GDI32.CreateSolidBrush' 0_FF_FF_FF | Mov D@Brush eax
    Call 'USER32.FillRect' D@hdc, D@Rect, D@Brush
    Call 'GDI32.DeleteObject' D@Brush

    Call 'GDI32.SetBkColor' D@hdc, 0_FF_FF_FF

    Call 'GDI32.SetTextColor' D@hdc, 0_33_33_33

  ; Output size
    Mov edi ItemString
    Mov al SPC | stosb
    Mov al B$MouseHint@SizeMarker
    If al = 'D'
        stosb | Mov eax 'WORD' | stosd
    Else_If al = 'W'
        Mov eax 'WORD' | stosd
    Else_If al = 'B'
        Mov eax 'BYTE' | stosd
    Else_If al = 'F'
        stosb | Mov eax 'LOAT' | stosd
    Else_If al = 'R'
        Mov eax 'REAL' | stosd
    Else_If al = 'T'
        Mov eax 'EXTE' | stosd
        Mov eax 'NDED' | stosd
    End_If
    Mov B$edi 0

    Call 'USER32.DrawTextA' D@hdc, ItemString, 0-1, D@Rect,
                            &DT_SINGLELINE+&DT_LEFT+&DT_VCENTER

  ; Output address
    Mov edi ItemString
    DwordToHex D$MouseHint@Address
    Mov al SPC | stosb
    Mov B$edi 0

    Call 'USER32.DrawTextA' D@hdc, ItemString, 0-1, D@Rect,
                            &DT_SINGLELINE+&DT_RIGHT+&DT_VCENTER

  ; Draw background for values
    Mov eax D$FontHeight
    lea edx D$eax*4
    Move D@Top eax, D@Bottom edx

    Call 'GDI32.CreateSolidBrush' 0_DD_EE_EE | Mov D@Brush eax
    Call 'USER32.FillRect' D@hdc, D@Rect, D@Brush
    Call 'GDI32.DeleteObject' D@Brush
    Call 'GDI32.SetBkColor' D@hdc, 0_DD_EE_EE

  ; Read a block of memory with a max size of 64 byte
    Call IsProcessMemory D$MouseHint@Address
    On eax = 0, jmp @Invalid
    Mov ebx 64
    On eax < ebx, Mov ebx eax
    Call ReadProcessMem D$MouseHint@Address, DataBuffer, ebx

  ; Output value based on size selector (D$ / W$ / ...)
    Mov al B$MouseHint@SizeMarker
    Mov B@Line1 0, B@Line2 0, B@Line3 0
    .If al = 'D'
L0:     On ebx < 4, jmp @Invalid
        Mov edi @Line1
        DwordToHex D$DataBuffer
        Mov B$edi 0

        Mov esi DataBuffer, ecx 4
        Call toUDword
        Mov esi edi, edi @Line2
        Do | movsb | LoopUntil B$esi-1 = 0

        Mov esi DataBuffer, ecx 4
        Call toSDword
        Mov esi edi, edi @Line3
        Do | movsb | LoopUntil B$esi-1 = 0
    .Else_If al = 'W'
        ; Word Size
        On ebx < 2, jmp @Invalid
        Mov edi @Line1
        WordToHex W$DataBuffer
        Mov B$edi 0

        Mov esi DataBuffer, ecx 2
        Call toUword
        Mov esi edi, edi @Line2
        Do | movsb | LoopUntil B$esi-1 = 0

        Mov esi DataBuffer, ecx 2
        Call toSword
        Mov esi edi, edi @Line3
        Do | movsb | LoopUntil B$esi-1 = 0

    .Else_If al = 'B'
        ; Byte size
        Mov edi @Line1
        ByteToHex B$DataBuffer
        Mov B$edi 0

        Mov esi DataBuffer, ecx 1
        Call toUByte
        Mov esi edi, edi @Line2
        Do | movsb | LoopUntil B$esi-1 = 0

        Mov esi DataBuffer, ecx 1
        Call toSByte
        Mov esi edi, edi @Line3
        Do | movsb | LoopUntil B$esi-1 = 0

    .Else_If al = 'F'
        On ebx < 4, jmp @Invalid
        Mov edi @Line2
        fld F$DataBuffer | fstp T$FloatBuf
        Call FloatToUString FloatBuf edi
        Mov al 0, ecx 0-1 | repne scasb
    .Else_If al = 'R'
        On ebx < 8, jmp @Invalid
        Mov edi @Line2
        fld R$DataBuffer | fstp T$FloatBuf
        Call FloatToUString FloatBuf edi
        Mov al 0, ecx 0-1 | repne scasb
    .Else_If al = 'T'
        On ebx < 10, jmp @Invalid
        Mov edi @Line2
        Call FloatToUString DataBuffer edi
        Mov al 0, ecx 0-1 | repne scasb
    .End_If

    Mov eax D$FontHeight
    lea eax D$eax*2
    Mov D@bottom eax
    Call 'USER32.DrawTextA' D@hdc, @Line1, 0-1, D@Rect,
                            &DT_SINGLELINE+&DT_CENTER+&DT_VCENTER

    Mov eax D$FontHeight
    add D@top eax
    add D@bottom eax
    Call 'USER32.DrawTextA' D@hdc, @Line2, 0-1, D@Rect,
                            &DT_SINGLELINE+&DT_CENTER+&DT_VCENTER

    Mov eax D$FontHeight
    add D@top eax
    add D@bottom eax
    Call 'USER32.DrawTextA' D@hdc, @Line3, 0-1, D@Rect,
                            &DT_SINGLELINE+&DT_CENTER+&DT_VCENTER
    ExitP

@Invalid:
    Mov eax D$FontHeight
    lea edx D$eax*4
    Move D@Top eax, D@Bottom edx
    Mov eax {B$ 'Invalid address' EOS}

    Call 'USER32.DrawTextA' D@hdc, eax, 0-1, D@Rect,
                            &DT_SINGLELINE+&DT_CENTER+&DT_VCENTER
EndP
____________________________________________________________________________________________

MouseHint: ; !!! Label Plain et @Labels locaux

[@VOID: MouseHint]
____________________________________________________________________________________________

; Get address of data symbol
; Input  :  esi -> name, ecx = len
; Output :  eax = value, edx = valid(1) invalid(0)

@EvaluateDataSymbol:

  ; Search address of data label (reuse information already stored in the label combo)
    Mov edx 0
    On D$H.DataLabelCombo = 0, ret
    Mov bl B$esi+ecx, B$esi+ecx 0 ; find routine requires zero terminated string!
    Push ecx
        SendMessage D$H.DataLabelCombo, &CB_FINDSTRINGEXACT, ecx, esi
    Pop ecx
    Mov B$esi+ecx bl
    Mov edx 0
    On eax = &CB_ERR, ret
    SendMessage D$H.DataLabelCombo, &CB_GETITEMDATA, eax, 0
    Mov edx 1
ret
____________________________________________________________________________________________

; Translate number representations
; Input  :  esi -> name, ecx = len
; Output :  eax = value, edx = valid(1) invalid(0)

@EvaluateNumber:
    Mov edx 0
    On B$esi < '0', ret
    On B$esi > '9', ret

    Push esi ecx
        If W$esi = '00'
            Call TranslateBinary
        Else_If B$esi = '0'
            Call TranslateHexa
        Else
            Call TranslateDecimal
        End_If
    Pop ecx esi

    Mov edx 1
ret
____________________________________________________________________________________________

; Get value of register
; Input  :  esi -> name, ecx = len
; Output :  eax = value, edx = valid(1) invalid(0)

@EvaluateRegister:
    Mov edx 0
    On B$esi <> 'E', ret
    On ecx <> 3, ret

    Mov eax D$esi
    and eax 0FF_FFFF
    Mov edi GPRegs
    Mov ecx 0

    While ecx < 8
        If D$GPRegs+ecx*4 = eax
            Mov eax D$GPRRegMap+ecx*4
            Mov eax D$eax
            Mov edx 1
            ret
        End_If
        inc ecx
    EndWhile

    Mov edx 0
ret

@EvaluateSegmentSelector:
    Mov edx 0
    On ecx <> 2, ret
    On B$esi+1 <> 'S', ret

    Mov edx 1
    Mov al B$esi
    cmp al 'F' | jne L0>
        Mov eax D$FS.Linear | ret
L0: cmp al 'D' | jne L0>
        Mov eax D$DS.Linear | ret
L0: cmp al 'C' | jne L0>
        Mov eax D$CS.Linear | ret
L0: cmp al 'E' | jne L0>
        Mov eax D$ES.Linear | ret
L0: cmp al 'G' | jne L0>
        Mov eax D$GS.Linear | ret
L0: cmp al 'S' | jne L0>
        Mov eax D$SS.Linear | ret

L0: Mov edx 0 ; invalid seg reg
ret
____________________________________________________________________________________________

; Get value of string token
; Input  :  esi -> name, ecx = len
; Output :  eax = value, edx = success (1) failed (0)

Proc @EvaluateToken:
    Uses esi, edi, ebx, ecx

    Call @EvaluateRegister
    On edx = 1, ExitP
    Call @EvaluateNumber
    On edx = 1, ExitP
    Call @EvaluateDataSymbol
    On edx = 1, ExitP
EndP
____________________________________________________________________________________________

; Output :  eax = address

[@Address: D$ ?]

Proc @Evaluate:

    Mov esi @Buffer
    Mov D@Address 0
    Mov ebx 0
    Mov dl addSign ; last operator
    Mov ecx 0-1

    .Do
        inc ecx
        .If B$esi+ecx < SPC
          ; operator precedence of '*' e.g. D$eax+ecx*4 -> @Address=eax, ebx=ecx
            If B$esi+ecx = mulSign
                add D@Address ebx
                Mov ebx 0
            End_If

          ; get value of token -> eax. Break up if the token is unknown (e.g. local symbols)
            Push edx
                Call @EvaluateToken
                If edx = 0
                    Mov eax 0
                    ExitP
                End_If
            Pop edx

          ; address arithmetic
            If dl = addSign
                add ebx eax
            Else_If dl = subSign
                sub ebx eax
            Else_If dl = mulSign
                imul ebx eax
            End_If

          ; save operator
            Mov dl B$esi+ecx
            add esi ecx
            inc esi
            Mov ecx 0-1
        .Else_If B$esi+ecx = ':'
          ; colon only after segment selector
            Call @EvaluateSegmentSelector
            If edx = 0
                Mov eax 0
                ExitP
            End_If
            add ebx eax
            Mov dl addSign ; segment base implies addition of the offset
            add esi ecx
            inc esi
            Mov ecx 0-1
        .End_If
    .Loop_Until B$esi+ecx = 0

    add D@Address ebx
    Mov eax 1
EndP
____________________________________________________________________________________________

; Get value of equate
; Input  :  esi -> name, ecx = namelen, edx = size of destination buffer
; Output :  eax = valid(1) invalid(0)

Proc @ReplaceEquate:
    Uses esi, ecx

  ; If naked local symbol, check if this belongs to the scope of the current code label.
    If B$esi = '@'
        Push edi ecx
            Mov edi LabelName
            Push ecx
                Mov ecx 0-1, al 0
                repne scasb
            Pop ecx
            dec edi
            rep movsb
            Mov B$edi 0
        Pop ecx edi
        Mov esi LabelName
    End_If

    Call GetFromQwordCheckSum esi, D$EquateList, D$EquateListLimit

    If eax <> 0
      ; Already copied name (len=ecx) is wiped off the buffer
        add edx ecx

      ; Skip equate name
        While B$eax > LowSigns
            inc eax
        End_While
        inc eax

      ; Store equate contents. First check if there's sufficient room to store it.
        Mov esi D$eax, ecx D$eax+4
        sub edx ecx | js L8>
        rep movsb

        Mov eax 1
    Else
L8:     Mov eax 0
    End_If
EndP
____________________________________________________________________________________________

; Copy the cooked buffer and replace equates by its values. This must be done until no more
; equates are found in the expression (in case of nested equates).

Proc @LookupEquates:

  ; HACK - get current label into labelname
    Call IsProcessCode D$CONTEXT@regEIP
    If eax = 1
        Call ScanLabelListForCodeLabel D$CONTEXT@regEIP, 0
    Else
        Mov B$LabelName 0
    End_If

  ; output buffer on stack
    sub esp 256
    Mov edi esp
    Mov edx 255

    Mov ebx 0
    Mov esi @Buffer
    Mov ecx 0-1

    Do
        inc ecx
        dec edx | js L8>

        Mov al B$esi+ecx
        Mov B$edi+ecx al

        .If al < SPC
          ; substitute equate with value
            Call @ReplaceEquate
            If eax = 1
                inc ebx
            Else
                add edi ecx
            End_If

          ; restore operator (might have been overwritten, different len equate<->value)
            add esi ecx
            Mov al B$esi | inc esi
            Mov B$edi al | inc edi

            Mov ecx 0-1
        .End_If
    Loop_Until B$esi+ecx = 0

L8: Mov ecx edi
    sub ecx esp

    Mov esi esp
    Mov edi @Buffer

    rep movsb

    Mov B$@Buffer+255 0

    Mov eax ebx ; number of replacements
EndP
____________________________________________________________________________________________

[@Buffer: B$ ? # 256]

; Input
;   esi -> $ in expression
; Output
;   @Buffer contains cooked (uppercase with spaces stripped) expression

Proc @CopyAndCook:

  ; scan forward & copy
    Mov edi @Buffer, edx 0

L3:   ; next char
        inc esi
        Mov al B$esi
        On al = 167, Mov al 36

L0:     cmp dl 1 | je L0>

      ; step over legal symbol chars: A..Z a..z 0..9 _ & : @
        cmp al '&' | je L4>
        cmp al '.' | je L4>
        cmp al '0' | jb L0>
        cmp al ':' | jbe L4> ; '0'..'9', ':'
        cmp al '@' | jb L0>
        cmp al 'Z' | jbe L4> ; '@', 'A'..'Z'
        cmp al '_' | je L3<
        cmp al 'a' | jb L0>
        cmp al 'z' | jbe L2> ; 'a' .. 'z'

L0:   ; not a symbol char, check for 'connecting' chars SPC, '+', '-', '*'
        If al = '+'
            Mov dl 0-1
            Mov al addSign
            jmp L1>
        Else_If al = '-'
            Mov dl 0-1
            Mov al subSign
            jmp L1>
        Else_If al = '*'
            Mov dl 0-1
            Mov al mulSign
            jmp L1>
        Else_If al = SPC
            On dl = 0, Mov dl 1
            jmp L3<
        End_If

      ; over
        jmp L9>

L2:   ; a..z -> A..Z
        sub al SPC

L4:     Mov dl 0

L1:   ; copy
        stosb

        cmp edi @Buffer+255 | je L9>

    jmp L3<


L9: Mov B$edi 0
EndP
____________________________________________________________________________________________

; Input
;   esi -> Text Ptr
; Output
;   edi -> Start of string
;   ecx = Size of string
;   eax = Expression (1) | Data declaration (0) | Invalid (-1)

[@SizeMarker: B$ ?]

Proc @ScanForSeparator:

    Mov al B$esi
    Mov dl 0 ; expect separator=1 symbol=-1

  ; scan backward
    While al <> 36 ;B$ParagraphChar ; '$' ; Dollar
        On al = 167, jmp L7>>

        cmp dl 1 | je L0>

      ; step over legal symbol chars: A..Z a..z 0..9 _ & : @ .
        cmp al '&' | je L3>
        cmp al '.' | je L3>
        cmp al '0' | jb L0>
        cmp al ':' | jbe L3> ; '0'..'9', ':'
        cmp al '@' | jb L0>
        cmp al 'Z' | jbe L3> ; '@', 'A'..'Z'
        cmp al '_' | je L1>
        cmp al 'a' | jb L0>
        cmp al 'z' | jbe L3> ; 'a' .. 'z'

L0:   ; not a symbol char, check for 'connecting' chars SPC, '+', '-', '*'
        If al = '+'
            Mov dl 0-1
            jmp L1>
        Else_If al = '-'
            Mov dl 0-1
            jmp L1>
        Else_If al = '*'
            Mov dl 0-1
            jmp L1>
        Else_If al = SPC
            On dl = 0, Mov dl 1
            jmp L1>
        End_If

      ; not preceded by '$', check for naked local "D@Local"
L5:     inc esi
        cmp B$esi SPC | je L5<

        cmp B$esi+1 '@' | jne L2>
        Mov al B$esi
        Mov B@SizeMarker al

        jmp L4>

L3:   ; symbol
        Mov dl 0

L1:     dec esi
        Mov al B$esi
    EndWhile

L7: Mov al B$esi-1
    Mov B@SizeMarker al

L4: Call @CopyAndCook
    Mov eax 1
    ExitP

L2: ; not preceded by '$', check for data declaration
    Mov eax 0-1
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; Check if the specified buffer might be a string. It is rejected if it contains
; non-printable chars or is empty (starts with zero).
; Output in AH! [1 (yes) | 0 (no)]

Proc IsString:
    Arguments @Buffer, @Size
    Uses esi

    Mov ah 0, esi D@Buffer, ecx D@Size
L0: While B$esi <> 0
        lodsb
        Mov ah 1
        dec ecx | jz P9>
        cmp al SPC | jb L9>
        cmp al 07F | jb L0<
        cmp al 080 | je L0<
        cmp al 091 | je L0<
        cmp al 092 | je L0<
        cmp al 0A0 | jb L9>
    EndWhile
    ExitP

L9: Mov ah 0
EndP

____________________________________________________________________________________________

; This is a printf clone for internal use in RosAsm.

[FormatString | &9=0 | C_Call FormatStr #L>1]
[C_Call | &9=&9+4 | Push #2 | #+1 | Call #F | add esp &9]

; Formats a string
; The stack must be cleared by the caller - use FormatString macro!
; Invokation: Call FormatStr PatternString OutputString [Linked parameters in order of occurence]
;
; Link  | Converted to            | Expected parameter
; ______|_________________________|____________________
; %s    | string                  | address of string
; %d    | decimal                 | dword immediate
; %x    | hex with leading 0's    | dword immediate

FormatStr:
    Push ebp
    Mov ebp esp

    Push esi edi ebx edx ; rescue regs

    Mov esi D$ebp+12 ; pattern string >> esi
    Mov edi D$ebp+8 ; output buffer >> edi
    Mov ebx 2 ; paramter count >> ebx

L0: lodsb
    .If al = '%'
        lodsb
        If al = 's'
            ; Copy string to buffer
            Push esi
                Mov esi D$ebp+8+ebx*4 | inc ebx
                cmp esi 0 | je L3>
                While B$esi <> 0 | movsb | EndWhile
        L3: Pop esi
        Else_If al = 'x'
            ; Convert to hex
            Mov eax D$ebp+8+ebx*4 | inc ebx
            Mov edx eax | add edi 7
            std
            Mov ecx 8
L1:         Mov al dl | and al 0F | cmp al 0A | jb L2>
            add al 7
L2:         add al '0' | stosb | shr edx 4 | loop L1<
            cld
            add edi 9
        Else_If al = 'd'
            ; Convert integer to decimal representation
            Mov eax D$ebp+8+ebx*4 | inc ebx
            Call IntToStr
        Else
            stosb
        End_If
    .Else
        stosb
    .End_If
    cmp al 0 | jne L0<

    ; Return stringlength in ecx
    Mov ecx edi
    sub ecx D$ebp+8
    dec ecx

    Pop edx ebx edi esi ; restore regs

    Pop ebp
ret
____________________________________________________________________________________________

; Outputs the time in format hh:mm:ss
;   parameter : edi -> string (8 chars must fit in)
;   returns   : edi -> string (terminating null-char)
;   uses      : eax, ecx, edx

TimeToStr:
    sub esp 16

        Call 'KERNEL32.GetLocalTime' esp
        movzx eax W$esp+8
        Mov edx 0, ecx 10 | div ecx
        add al '0'
        stosb
        add dl '0' | Mov al dl
        stosb

        Mov al ':' | stosb

        movzx eax W$esp+10
        Mov edx 0, ecx 10 | div ecx
        add al '0'
        stosb
        add dl '0' | Mov al dl
        stosb

        Mov al ':' | stosb

        movzx eax W$esp+12
        Mov edx 0, ecx 10 | div ecx
        add al '0'
        stosb
        add dl '0' | Mov al dl
        stosb

        Mov B$edi 0

    add esp 16
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; Text visible to the user is collected here.
____________________________________________________________________________________________
____________________________________________________________________________________________

[StrRun: B$ 'Run' EOS]
[StrStepInto: B$ 'Step Into' EOS]
[StrStepOver: B$ 'Step Over' EOS]
[StrStep: B$ 'Step' EOS]
[StrReturn: B$ 'Return to Caller' EOS]
[StrRet: B$ 'Return' EOS]
[StrTerminate: B$ 'Terminate' EOS]
[StrPause: B$ 'Pause' EOS]
[StrHoldOnBp: B$ 'Hold on breakpoints' EOS]
[StrInstStep: B$ 'Instruction level stepping' EOS]
[StrSrcStep: B$ 'Source level stepping' EOS]
[StrShowAll: B$ 'Show segment/debug registers' EOS]
[StrFont: B$ 'Choose font ...' EOS]
[StrCPUInfo: B$ 'CPU info' EOS]
[StrFPUStatus: B$ 'FPU status' EOS]
[StrShowCodeAt: B$ 'Show code at address ...' EOS]
[StrAbout: B$ 'About Debugger' EOS]
[StrDbgHelp: B$ 'Debugger Help' EOS]
[StrContinue: B$ 'Continue' EOS]
[StrBreak: B$ 'Break' EOS]
[StrSettings: B$ 'Settings' EOS]
[StrInformation: B$ 'Information' EOS]
[StrHelp: B$ 'Help' EOS]

[StrDataFmt: B$ 'Data Representation:' EOS]

[StrF1: B$ 'F1' EOS]
[StrF6: B$ 'F6' EOS]
[StrF7: B$ 'F7' EOS]
[StrF8: B$ 'F8' EOS]
[StrCtrlF7: B$ 'Ctrl+F7' EOS]
[StrCtrlF6: B$ 'Ctrl+F6' EOS]
[StrCtrlF12: B$ 'Ctrl+F12' EOS]

[FPUControlWord: B$ 'Control Word: ' EOS]
[FPUTagWord: B$ 'Tag Word: ' EOS]
[FPURoundingMode: B$ 'Rounding Mode: ' EOS]
[FPUPrecision: B$ 'Precision: ' EOS]
[FPUStatusWord: B$ 'Status Word: ' EOS]
[FPURndNearest: B$ 'Nearest or even' EOS]
[FPURndDown: B$ 'Round down' EOS]
[FPURndUp: B$ 'Round up' EOS]
[FPURndTrunc: B$ 'Truncate' EOS]

[DataView: B$ 'Data' EOS]
[MemoryInspector: B$ 'Memory' EOS]
[CallStack: B$ 'Call Stack' EOS]
[Log: B$ 'Log' EOS]
[AddressSpace: B$ 'Address Space' EOS]

[FmtHex: B$ 'Hexadecimal' EOS]
[FmtUDec: B$ 'Unsigned Decimal' EOS]
[FmtSDec: B$ 'Signed Decimal' EOS]
[FmtBinary: B$ 'Binary' EOS]
[FmtFloat: B$ 'Floating Point' EOS]
[FmtPUB: B$ 'Packed Unsigned Byte' EOS]
[FmtPSB: B$ 'Packed Signed Byte' EOS]
[FmtPUW: B$ 'Packed Unsigned Word' EOS]
[FmtPSW: B$ 'Packed Signed Word' EOS]
[FmtPUD: B$ 'Packed Unsigned Dword' EOS]
[FmtPSD: B$ 'Packed Signed Dword' EOS]
[FmtPUQ: B$ 'Packed Unsigned Qword' EOS]
[FmtPSQ: B$ 'Packed Signed Qword' EOS]
[FmtPF: B$ 'Packed Single Precision Float' EOS]
[FmtPD: B$ 'Packed Double Precision Float' EOS]
[FmtHexAnsi: B$ 'Hexadecimal / ANSI' EOS]
[FmtHexDW: B$ 'Hexadecimal Dwords' EOS]
[FmtHexW: B$ 'Hexadecimal Words' EOS]
[FmtFloats: B$ 'Single Precision Floats' EOS]
[FmtDoubles: B$ 'Double Precision Floats' EOS]
[FmtAscii: B$ 'Ascii Characters' EOS]
[FmtHexCooked: B$ 'Hexadecimal / Cooked Ascii (RosAsm Development)' EOS]

[StrShowInMemInsp: B$ 'Show in memory inspector' EOS]
[StrShowPInMemInsp: B$ 'Show memory pointed at' EOS]
[StrShowDecl: B$ 'Show declaration' EOS]
[StrBreakOnW: B$ 'Break on write access' EOS]
[StrBreakOnRW: B$ 'Break on read/write access' EOS]
[StrSortByName: B$ 'Sort by name' EOS]
[StrSortByAddr: B$ 'Sort by address' EOS]

[StrShowInvoke: B$ 'Show invocation' EOS]
[StrShowAllCalls: B$ 'Show all calls' EOS]
[StrHideModCalls: B$ 'Hide module calls' EOS]
[StrHideIMCalls: B$ 'Hide intra-module calls' EOS]
[StrShowLocals: B$ 'Show Local data' EOS]

[ACCESS_VIOLATION: B$ "ACCESS VIOLATION [C0000005]
The thread tried to read from or write to a virtual address for which it does not have the appropriate access." EOS]
[ARRAY_BOUNDS_EXCEEDED: B$ "ARRAY BOUNDS EXCEEDED [C000008C]
The thread tried to access an array element that is out of bounds and the underlying hardware supports bounds checking." EOS]
[DATATYPE_MISALIGNMENT: B$ "DATATYPE_MISALIGNMENT [80000002]
The thread tried to read or write data that is misaligned on hardware that does not provide alignment. 
For example, 16-bit values must be aligned on 2-byte boundaries; 32-bit values on 4-byte boundaries, and so on." EOS]
[FLT_DENORMAL_OPERAND: B$ "FLT DENORMAL OPERAND [C000008D]
One of the operands in a floating-point operation is denormal. 
A denormal value is one that is too small to represent as a standard floating-point value." EOS]
[FLT_DIVIDE_BY_ZERO: B$ "FLT DIVIDE BY ZERO [C000008E]
The thread tried to divide a floating-point value by a floating-point divisor of zero." EOS]
[FLT_INEXACT_RESULT: B$ "FLT INEXACT RESULT [C000008F]
The result of a floating-point operation cannot be represented exactly as a decimal fraction." EOS]
[FLT_INVALID_OPERATION: B$ "FLT INVALID OPERATION [C0000090]" EOS]
[FLT_OVERFLOW: B$ "FLT OVERFLOW [C0000091]
The exponent of a floating-point operation is greater than the magnitude allowed by the corresponding type." EOS]
[FLT_STACK_CHECK: B$ "FLT STACK CHECK [C0000092]
The stack overflowed or underflowed as the result of a floating-point operation." EOS]
[FLT_UNDERFLOW: B$ "FLT UNDERFLOW [C0000093]
The exponent of a floating-point operation is less than the magnitude allowed by the corresponding type." EOS]
[ILLEGAL_INSTRUCTION: B$ "ILLEGAL INSTRUCTION [C000001D] 
The thread tried to execute an invalid instruction." EOS]
[IN_PAGE_ERROR: B$ "IN PAGE ERROR [C0000006]
The thread tried to access a page that was not present, and the system was unable to load the page.
For example, this exception might occur if a network connection is lost while running a program over the network." EOS]
[INT_DIVIDE_BY_ZERO: B$ "INT DIVIDE BY ZERO [C0000094]
The thread tried to divide an integer value by an integer divisor of zero." EOS]
[INT_OVERFLOW: B$ "INT OVERFLOW [C0000095]
The result of an integer operation caused a carry out of the most significant bit of the result." EOS]
[PRIV_INSTRUCTION: B$ "PRIVILIGED INSTRUCTION [C0000096]
The thread tried to execute an instruction whose operation is not allowed in the current machine mode." EOS]
[STACK_OVERFLOW: B$ "STACK OVERFLOW [C00000FD]
The thread used up its stack." EOS]
[INVALID_DISPOSITION: B$ "INVALID DISPOSITION [C0000026]
An exception handler returned an invalid disposition to the exception dispatcher." EOS]
[NONCONTINUABLE_EXCEPTION: B$ "NONCONTINUABLE EXCEPTION [C0000025]
The thread tried to continue execution after a noncontinuable exception occurred." EOS]
[UNKNOWN_EXCEPTION: B$ "xxxxxxxx 
Unknown exception." EOS]
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Debug           ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

[DebuggerVersion: B$ 'BUA Debugger V2.2b' EOS]

;;
_____________________________________________________________________________________________

                             Debugger [Version 2.2b] - Ludwig Haehne
     
    * [Bugfix] Added security for degenerated Call stack cases
    
  RosAsm 2.033b [Debugger V2.2a]
  
    * [Bugfix] FPU flags toolbar was not effective
  
  RosAsm 2.031a [Debugger V2.2]
                 
    * [Feature] Localized user interface
    * [Feature] Recognize stack-frames in Call stack set up by ENTER intruction
    * [Change] Ctrl+F shortcut for FPU info removed (conflict with search feature)
    * [Change] Terminate debuggee immediately when debugger window is closed
    * [Change] Do not inherit startup information to debuggee
    * [Bugfix] Preserve z-order and focus of debuggee's windows across debug events
    * [Bugfix] Minimize/Restore dialog messed up child-window sizes    
    * [Bugfix] Sourceposition was wrong when a breakpoint was set on a single-byte instruction
    * [Bugfix] Error checking for VirtualQuery

  RosAsm 2.027a [Debugger V2.1b]

    * [Bugfix] Menu did not work on Win95
    * [Bugfix] MMX register contents did not show properly on Win9x
    * [Bugfix] Occasional crash when mouse hints showed up behind other windows on Win98

  RosAsm 2.025e [Debugger V2.1a]
  
    * [Bugfix] Thread synch problems fixed when running multiple debugger instances
    * [Bugfix] Logfiles now have application specific names
                             
  RosAsm 2.025a [Debugger V2.1]
  
    * [Feature] Local symbol support for mouse hints and Call stack
    * [Feature] New filter capabilities in Call stack (context menu)
    * [Feature] Sort data labels by Address or Name (select in context menu)
    * [Feature] Toolbar
    * [Change] Flags moved into toolbar (can be hidden)
    * [Change] General code cleanup
    * [Bugfix] Rare "Invalid path" problem fixed
____________________________________________________________________________________________
          
 Known bugs:
 
    * Check for Invalid parameter counts in callstack computation (MyPNN)
 
    * Two byte breakpoints make the debuggee crash when HoldOnBreakPoints = 0
    * Terminate leaves process and thread handle open    
    * Stepping into int 02e seeds a 'breakpoint' at the return address (TrackPopupMenu)
    * Int 3 in Hook procedures (mouse hooks) hangs the Windows GUI
   
    *   "There is an issue about focus at debug time. "Sometimes" the debuger  set  the 
        focus to main debugee window.
        when the focus was at a second overlaped window (not the main nor a  sysmodal) i want 
        the focus to go back where it was, not to the owner  window. I have a rare efect 
        even without BPs at debug time" (from Marcelo)
        
        >> Find a way to not touch the z-order of the debuggee windows after run/step-over.
        
    * Close debug window when debuggee has message box open  (except.exe)
        -> wait -> "Debug thread does not respond" -> [Ok] 
        -> Unknown exception (C0000008) in CloseHandle called by DebugRsrcManager
        (exception does NOT crash RosAsm also it does not seem to have a SEH attached !?)

 Future ;)
 
    * Window message logger
    * Structured data memory inspector
    * Conditional breakpoints
    * Editable contents (register, memory)
    * Symbolic Profiler
____________________________________________________________________________________________
                          
 Maintainer since November 2003: Ludwig Haehne, wkx@gmx.li
 
 I have almost completely rewritten the existing debugger to introduce new features and 
 have a better UI.
 
 The debugger is now roughly divided into the following sections:
 
 Main Debug Routines
 
  * 'Debugger' is called when you click on [Run] and creates the 'DebugRsrcManagerThread'
  * 'KillDebugger' is called whenever you try to modify your sources
  
 Debugger polling Thread (handles debug events)
 
  * 'DebugThread', 'ShowProcessWindows', 'ScanStackForCodePointer', 'CloseProcess',
    'ReadProcessMem', 'WriteProcessMem', 'SignalDebugEvent', 'EncounterException'
  
 Breakpoint management
 
  * 'CreateBPTable', 'DestroyBPTable', 'AddProcessBreakpoint', 'DeleteProcessBreakpoint', 
    'DisableProcessBreakpoints', 'EnableProcessBreakpoints', 'EncounterBreakpoint', 
    'KillBreakpointGroup'
    
 Breakpoint synchronization with Source editor
  
  * 'CreateBPAnteroom', 'DestroyBPAnteroom', 'InitialFillBPAnteroom', 'AddBPToAnteroom',
    'ClearBPAnteroom'

 Address Space Routines
 
  * 'VirtualQuery', 'IsProcessMemory', 'IsProcessCode', 'FindNextPage', 'FindPrevPage'
  
 Call stack routines
  
  * 'GenerateCallStack', 'DestroyCallStack', 'ReadApplicationStack', 'IsReturnAddress',
    'IsReturnAddressInSource', 'GetCodeLabelFromAddress', 'GetNearestProc', 'CountParametersAndScanStackFrame'
    
 Module management
 
  * 'IsModuleCode'
_____________________________________________________________________________________________

;;

[DEBUG_EVENT:
 DE.dwDebugEventCode: D$ ?
 DE.dwProcessId: D$ ?
 DE.dwThreadId: D$ ?
 @DE.u:
    CPDI.hFile:         CTDI.hThread:           E.ExceptionCode:    ODS.DebugString:  LOADDLL.hFile:    UNLOADDLL.Base: D$ ?
    @CPDI.hProcess:      @CTDI.lpThreadLocalBase: @E.ExceptionFlags:   @ODS.Unicode:      LOADDLL.Base:     W$ ?
                                                                    ODS.StringLen:    W$ ?
    CPDI.hThread:       @CTDI.lpStartAddress:    @E.ExceptionRecord:                    @LOADDLL.DIOffset: D$ ?
    CPDI.lpBaseOfImage:                         E.ExceptionAddress:                   @LOADDLL.DISize:   D$ ?
                                                @E.NumParams:                          @LOADDLL.Name:     D$ ?
                                                E.ExceptionInfo:                      @LOADDLL.Unicode:  D$ ?
                                                                                      D$ ?
    @CPDI.lpStartAddress:                                                              D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                E.FirstChance:                        D$ ?]

____________________________________________________________________________________________

[CONTEXT:
 @ContextFlags: D$ ?
 @iDr0: D$ ?
 @iDr1: D$ ?
 @iDr2: D$ ?
 @iDr3: D$ ?
 @iDr6: D$ ?
 @iDr7: D$ ?
 @FloatSave.ControlWord: D$ ?
 @FloatSave.StatusWord: D$ ?
 @FloatSave.TagWord: D$ ?
 @FloatSave.ErrorOffset: D$ ?
 @FloatSave.ErrorSelector: D$ ?
 @FloatSave.DataOffset: D$ ?
 @FloatSave.DataSelector: D$ ?
 @FloatSave.RegisterArea: B$ ? # &SIZE_OF_80387_REGISTERS
 @FloatSave.Cr0NpxState: D$ ?
 @regGs: D$ ?
 @regFs: D$ ?
 @regEs: D$ ?
 @regDs: D$ ?
 @regEdi: D$ ?
 @regEsi: D$ ?
 @regEbx: D$ ?
 @regEdx: D$ ?
 @regEcx: D$ ?
 @regEax: D$ ?
 @regEbp: D$ ?
 @regEip: D$ ?
 @regCs: D$ ?
 @regFlag: D$ ?
 @regEsp: D$ ?
 @regSs: D$ ?
 @ExtendedRegisters: B$ ? # 32
 @regMM: B$ ? # 128
 @regXMM: B$ ? # 128
 @UnknownExtendedRegs: B$ ? # 224
 EndOfContext: B$ ?]

[ContextSize (EndOfContext-Context)]
____________________________________________________________________________________________

; All user-visible messages are stored here for easier proof-reading / localization.

[AboutDebugger:
B$ "BUAsm's debugger V 01.00.001a" EOS]

[DebugThreadHangs:
B$ "The debugger thread does not respond. 
This should not happen! The thread is now terminated!" EOS]

[CriticalError: B$ "Critical error" EOS]

[MessageKillDebugger:
B$ "You cannot modify the Source in a Debug Session    
    
                     Close the Debugger?" EOS]

[DebuggerRunning: B$ "Debugger running ..." EOS]
____________________________________________________________________________________________

________________________________________________________________________________________

[MY_CONTEXT_FULL &CONTEXT_FULL__&CONTEXT_FLOATING_POINT__&CONTEXT_DEBUG_REGISTERS__&CONTEXT_EXTENDED_REGISTERS]

; Main Routine of the Debugger.

[FL.IsDebugging: D$ ?
 FL.Compiling: D$ ?]


[DebugRsrcManagerThreadId: D$ ?]

Proc Debugger:
    On D$FL.IsDebugging = &TRUE, ExitP

    Call TestCPUFeatures

    ; Get OS version information - The main difference between Win9x / WinNT
    ; concerning the debugger is the address space layout.
    Mov D$OSVersionInfo@Size OSVI_SIZE
    Call 'KERNEL32.GetVersionExA' OsVersionInfo
    If D$OsVersionInfo@PlatformId = &VER_PLATFORM_WIN32_WINDOWS
        Mov D$AddressLowerBound 0
        Mov D$AddressUpperBound 0_BFFF_FFFF
    End_If

    ; Create the debug dialog that displays registers, labels and memory.
    Call CreateDebugWindow

    Call 'KERNEL32.CreateThread' &NULL, 0, DebugRsrcManagerThread, 0,
                                 &THREAD_PRIORITY_NORMAL, DebugRsrcManagerThreadId
    If eax = &NULL
        Call ReportWinError {B$ 'Debugger: CreateThread (Resource Manager)' EOS}
    Else
        ; we don't need the thread handle
        Call 'KERNEL32.CloseHandle' eax
    End_If
EndP
____________________________________________________________________________________________

;;
  User attempts to modify the Source in a Debug Session. 
  Impossible > offer him to either close the Debug Session or to abort the Source Edition
;;

CloseDebuggerOrIgnore:

    test D$H.DebugDialog NA NOT_ZERO S1>

    Mov eax &IDNO

ret

S1: Call 'USER32.MessageBoxA' D$H.MainWindow,
                              MessageKillDebugger,
                              DebuggerRunning,
                              &MB_SYSTEMMODAL+&MB_YESNO


    Comp eax &IDYES = S1>

ret

S1: Call 'USER32.SendMessageA' D$H.DebugDialog,
                               &WM_CLOSE,
                               &NULL,
                               &NULL

    Mov eax &IDYES

ret
____________________________________________________________________________________________

; Debugger resource manager thread. This thread takes care of initializing and freeing
; all resources (objects, files, memory). It is separated from the polling
; thread to cleanup properly even if the thread hangs (for whatever reason) and must be
; terminated; which (very rarely) caused deadlocks with the past solution.

[H.DebugThread: D$ ?
 DebugThreadId: D$ ?] ; the polling thread
[UserInputEvent: D$ ?] ; synch dialog with polling thread
[TABLE.H.ThreadID: D$ ?
 NumThreads: D$ ?] ; maps thread id's to handles

[PROCESS_INFORMATION: ; the debuggee's process and (main) thread handle & id
 @hProcess: D$ ?
 @hThread: D$ ?
 @dwProcessId: D$ ?
 @dwThreadId: D$ ?]

[STARTUPINFO:
 @cb: D$ ?
 @lpReserved: D$ ?
 @lpDesktop: D$ ?
 @lpTitle: D$ ?
 @dwX: D$ ?
 @dwY: D$ ?
 @dwXSize: D$ ?
 @dwYSize: D$ ?
 @dwXCountChars: D$ ?
 @dwYCountChars: D$ ?
 @dwFillAttribute: D$ ?
 @dwFlags: D$ ?
 @wShowWindow: W$ ?
 @cbReserved2: W$ ?
 @lpReserved2: D$ ?
 @hStdInput: D$ ?
 @hStdOutput: D$ ?
 @hStdError: D$ ?]

DebugRsrcManagerThread:

  ; Create an autoreset event to synchronize the debug dialog with the debugthread.
    Call 'KERNEL32.CreateEventA' 0, 0, 0, 0
    If eax = &NULL
        Call ReportWinError {B$ 'Debugger: CreateEvent' EOS}
        jmp @Exit
    End_If
    Mov D$UserInputEvent eax

    Call CreateBPTable

  ; Create a lookup table to retrieve thread handles. The reason we need this is that
  ; we get a thread handle only with the Create-Thread-Debug-Event. For exception handling
  ; only the thread ID is provided, so the handle and the corresponding ID must be saved.

    Call VirtualAlloc TABLE.H.ThreadID,
                      01000

    Mov D$NumThreads 0


    Call 'KERNEL32.HeapCreate' 0, 01000, 0 ; Create a growable heap.
    Mov D$ModuleNameHeap eax

    Call VirtualAlloc ModuleList,
                      01000

    Mov D$NumModules 0

  ; Create the thread that creates and observes the debuggee.
    Call 'KERNEL32.CreateThread' &NULL, 0, DebugThread, 0,
                                &THREAD_PRIORITY_NORMAL+&CREATE_SUSPENDED, DebugThreadId
    If eax = &NULL
        Call ReportWinError {B$ 'Debugger: CreateThread' EOS}

EndP

    End_If
    Mov D$H.DebugThread eax

  ; Create synchronization table (like a printer-spool) for dynamic breakpoints.
    Call CreateBPAnteroom
    Call InitialFillBPAnteroom

    Call InitWatchpointResources

  ; Resume (start) the thread. The thread is created suspended to be sure that the
  ; handle is set correctly.
    Call 'KERNEL32.ResumeThread' D$H.DebugThread

  ; Enter debug event polling
    Call 'KERNEL32.WaitForSingleObject' D$H.DebugThread, &INFINITE

  ; Now the polling thread is dead- either the debuggee has terminated or the thread
  ; was killed. Clean up.

    Call FreeWatchpointResources

    Call DestroyBPAnteroom

    Call 'KERNEL32.CloseHandle' D$H.DebugThread
    Mov D$H.DebugThread 0

  ; Cleanup
    Call VirtualFree ModuleList

    Call 'KERNEL32.HeapDestroy' D$ModuleNameHeap
    Call VirtualFree TABLE.H.ThreadID

    Call 'KERNEL32.CloseHandle' D$PROCESS_INFORMATION@hThread
    Call 'KERNEL32.CloseHandle' D$PROCESS_INFORMATION@hProcess

    Call DestroyBPTable

  ; we post a close signal no matter if the dialog still exists or not
    Call 'USER32.PostMessageA' D$H.DebugDialog, &WM_CLOSE, &NULL, &NULL

    Call 'KERNEL32.CloseHandle' D$UserInputEvent
    Mov D$UserInputEvent 0

  ; If the debuggee has called 'KERNEL32.OutputDebugString' there is a file in which the
  ; output has been logged. Close the file now.
    If D$DebugLogFile <> 0
        Call 'KERNEL32.CloseHandle' D$DebugLogFile
        Mov D$DebugLogFile 0
    End_If

  ; Clear data structures (safety)
    Mov ecx EndOfContext | sub ecx Context | shr ecx 2
    Mov edi Context, eax 0
    rep stosd

@Exit:
    Call 'KERNEL32.ExitThread' 0
ret
____________________________________________________________________________________________

[FilterEXE: B$ 'Executables (*.exe)' EOS '*.exe' EOS 0]
[HostAppTitle: B$ 'Host application ...' EOS]

[SelectHostAppDialog:
 @lStructSize: D$ len
 @hwndOwner: D$ 0
 @hInstance: D$ 0
 @lpstrFilter: D$ FilterEXE
 @lpstrCustomFilter: D$ 0
 @nMaxCustFilter: D$ 0
 @nFilterIndex: D$ 0
 @lpstrFile: D$ DebuggeeExe
 @nMaxFile: D$ &MAX_PATH
 @lpstrFileTitle: D$ 0
 @nMaxFileTitle: D$ 0
 @lpstrInitialDir: D$ 0
 @lpstrTitle: D$ HostAppTitle
 @Flags: D$ &OFN_FILEMUSTEXIST+&OFN_EXPLORER+&OFN_NOCHANGEDIR
 @nFileOffset: W$ 0
 @nFileExtension: W$ 0
 @lpstrDefExt: D$ 0
 @lCustData: D$ 0
 @lpfnHook: D$ 0
 @lpTemplateName: D$ 0]

[DebuggeePath: B$ ? # &MAX_PATH]
[DebuggeeExe: B$ ? # &MAX_PATH]
[DebuggeeExeTitle: D$ ?]
[DebuggeeParams: D$ ?]
[CommandLineString: B$ ? # &MAX_PATH]

Proc CreateDebuggeeProcess:
    Local @Success

    Mov D@Success &FALSE

    ; Allocate buffer for the command line, check if a command line file is provided and
    ; create the debuggee with debug rights for RosAsm.

    Call 'KERNEL32.GetStartupInfoA' STARTUPINFO
    Mov D$STARTUPINFO@dwFlags 0

    ; Setup Path, Executable, Parameters

    Mov esi MainName, edi DebuggeePath
    While B$esi <> 0
        movsb
    EndWhile

    On B$edi <> '\', dec edi ; !!!

    While B$edi <> '\'
        Mov B$edi 0
        dec edi
    EndWhile

    inc edi
    sub edi DebuggeePath
    Mov D$DebuggeeExeTitle edi

    Call SetDirectory DebuggeePath

    If D$SavingExtension = '.DLL'
        Call 'Comdlg32.GetOpenFileNameA' SelectHostAppDialog
        On eax = &FALSE EndP

        movzx eax W$SelectHostAppDialog@nFileOffset
        Mov D$DebuggeeExeTitle eax
    Else
        Mov edi DebuggeeExe, esi MainName
        While B$esi <> 0
            movsb
        EndWhile
        Move D$edi D$SavingExtension
        Mov B$edi+4 0
    End_If

    add D$DebuggeeExeTitle DebuggeeExe

    Call SetupCommandLine
    Mov D$DebuggeeParams eax

    ; Assemble the commandline
    Mov edi CommandLineString, ecx &MAX_PATH
    Mov al '"' | stosb | dec ecx
    Mov esi DebuggeeExe
    While B$esi <> 0
        movsb | dec ecx
    EndWhile
    Mov ax '" ' | stosw | sub ecx 2
    Mov esi D$DebuggeeParams
    cmp esi 0 | je L0>
    While B$esi <> 0
        On ecx = 1, jmp L0>
        movsb | dec ecx
    EndWhile
L0: Mov B$edi 0

    ; Create the process with debug rights
    Call 'KERNEL32.CreateProcessA' 0, CommandLineString, &NULL, &NULL, &FALSE,
                        &DEBUG_PROCESS+&DEBUG_ONLY_THIS_PROCESS+&PROCESS_TERMINATE,
                        &NULL, DebuggeePath, STARTUPINFO, PROCESS_INFORMATION
    Mov D@Success eax
    If eax = &FALSE
        Call ReportWinError {B$ 'Debugger: CreateProcess' EOS}
        On eax = &ERROR_DIRECTORY,
            Call 'USER32.MessageBoxA' D$H.MainWindow, DebuggeePath, {B$ 'Directory is:' EOS}, &MB_OK
    End_If

    ; Allocated by SetupCommandLine (dirty, but necessary if param-string is static [/S])

    Call VirtualFree CommandLinePtr

    Mov eax D@Success
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; Debug (polling) Thread
____________________________________________________________________________________________
____________________________________________________________________________________________

; The actual debug work is done by this thread, it creates the debuggee and waits
; for debug-events. If these occur it transfers control to the user who can decide how to
; proceed.

[IsDebugEvent: D$ ?
 DebugStart: D$ ?]
[BreakpointsEnabled: D$ ?]
[BreakpointOp: B$ 0CC]
[ByteBuf: B$ ?]
[ContinueStatus: D$ ?]

Proc DebugThread:
    Local @Exit, @CloseSent

    Call CreateDebuggeeProcess
    If eax = &FALSE
        jmp L9>>
    End_If

    Mov D$BreakpointsEnabled &TRUE
    Mov D$FL.IsDebugging &TRUE
    Mov D$IsDebugEvent &FALSE
    Mov B$DebugStart &FALSE
    Mov B$ExceptionFlags 0

    ; Main loop, as long as we don't want to quit, wait for debug events and process them.
    Mov D@Exit &FALSE, B$DebugStart &FALSE, D@CloseSent 0

    .While D@Exit = &FALSE

L0:     Call 'KERNEL32.WaitForDebugEvent' DEBUG_EVENT, 100

      ; If we receive false, the timeout occurred. Process any user input that makes sense
      ; while the debuggee is running (e.g. killing it or generating breakpoints)
        ..If eax = &FALSE

          ; The user requested the termination of the debuggee while it was running. Send
          ; WM_CLOSE messages to the main windows and then wait a second. Be sure to process
          ; debug messages (do *not* Call WaitForSingleObject) inbetween. If the process is
          ; still alive after a second it is terminated.
            .If D$TerminateDebuggee = &TRUE
;;
                Mov D$HoldOnBreakpoints 0
                If D@CloseSent = 0
                    Call CloseMainWindows
                    Mov D@CloseSent 1
                    jmp L0<
                Else
                    inc D@CloseSent
                    On D@CloseSent < 10, jmp L0<
;;
                    Call 'KERNEL32.TerminateProcess' D$PROCESS_INFORMATION@hProcess, 0
                    jmp L9>>
                ;End_If
            .End_If

          ; Check if we either need to enable or disable the breakpoints. (HoldOnBreakpoint
          ; has changed).
            Mov eax D$HoldOnBreakpoints
            .If eax <> D$BreakpointsEnabled
                If B$HoldOnBreakpoints = &TRUE
                    Call EnableProcessBreakpoints
                Else
                    Call DisableProcessBreakpoints
                End_If
            .End_If

          ; User requested Pause: Generate breakpoint to halt all threads
            If D$PauseThreads = &TRUE
                Mov ebx 0, esi D$TABLE.H.ThreadID
                While ebx < D$NumThreads
                    Call HaltThread D$esi+ebx*8+4
                    inc ebx
                EndWhile
                Mov D$PauseThreads &FALSE
            End_If

          ; Look for BP changes in the source editor
            Call ClearBPAnteroom
            jmp L0<<

        ..End_If

        Mov eax D$DE.dwProcessId
        If eax <> D$PROCESS_INFORMATION@dwProcessId
          ; If this debug event belongs to an other (child) process, continue execution
            Call 'KERNEL32.ContinueDebugEvent' D$DE.dwProcessId, D$DE.dwThreadId, &DBG_CONTINUE
            jmp L0<<
        End_If

        Mov D$ContinueStatus &DBG_CONTINUE

        .If D$DE.dwDebugEventCode = &EXIT_PROCESS_DEBUG_EVENT
            Mov D@Exit &TRUE
        .Else_If D$DE.dwDebugEventCode = &CREATE_THREAD_DEBUG_EVENT
            Call Debugger_OnCreateThread
        .Else_If D$DE.dwDebugEventCode = &EXIT_THREAD_DEBUG_EVENT
            Call Debugger_OnExitThread
        .Else_If D$DE.dwDebugEventCode = &LOAD_DLL_DEBUG_EVENT
            Call Debugger_OnLoadDll D$LOADDLL.Base
        .Else_If D$DE.dwDebugEventCode = &UNLOAD_DLL_DEBUG_EVENT
            Call Debugger_OnUnloadDll D$UNLOADDLL.Base
        .Else_If D$DE.dwDebugEventCode = &EXCEPTION_DEBUG_EVENT
            Call Debugger_OnException
            Mov D@Exit eax
        .Else_If D$DE.dwDebugEventCode = &CREATE_PROCESS_DEBUG_EVENT
            Call Debugger_OnCreateProcess
        .Else_If D$DE.dwDebugEventCode = &OUTPUT_DEBUG_STRING_EVENT
            Call HandleDebugString
        .Else
            Mov D$ContinueStatus &DBG_EXCEPTION_NOT_HANDLED
        .End_If

        Call 'KERNEL32.ContinueDebugEvent' D$DE.dwProcessId, D$DE.dwThreadId, D$ContinueStatus

    .End_While

L9: Mov D$FL.IsDebugging &FALSE
    Call 'KERNEL32.ExitThread' 0
EndP
____________________________________________________________________________________________

; When a thread is created in the debuggee. Add Thread ID/Handle pair to table.

Debugger_OnCreateThread:
    Mov esi D$TABLE.H.ThreadID, ecx D$NumThreads
    Move D$esi+ecx*8 D$DE.dwThreadID
    Move D$esi+ecx*8+4 D$CTDI.hThread
    inc D$NumThreads

    FormatString DebugLogString, {B$ 'Thread ID=%d created' EOS}, D$DE.dwThreadId
    Call 'USER32.PostMessageA' D$H.DebugDialog, WM_LOG, DebugLogString, ecx
ret
____________________________________________________________________________________________

; Overwrite Thread ID/Handle pair in table with last entry.

Debugger_OnExitThread:
    dec D$NumThreads
    Mov ecx D$NumThreads, edx 0
    Mov esi D$TABLE.H.ThreadID, eax D$DE.dwThreadID
    While D$esi+edx*8 <> eax
        inc edx
    End_While
    Move D$esi+edx*8 D$esi+ecx*8
    Move D$esi+edx*8+4 D$esi+ecx*8+4

    FormatString DebugLogString, {B$ 'Thread ID=%d terminated' EOS}, D$DE.dwThreadId
    Call 'USER32.PostMessageA' D$H.DebugDialog, WM_LOG, DebugLogString, ecx
ret
____________________________________________________________________________________________

; When process is created. Add main thread ID/handle to table.

[DebugBaseOfCode: D$ ?
 DebugCodeSize: D$ ?]

Debugger_OnCreateProcess:
    Call 'KERNEL32.CloseHandle' D$CPDI.hFile

    Mov D$DebugBaseOfCode 0, D$DebugCodeSize 0

    Mov esi D$TABLE.H.ThreadID
    Move D$esi D$DE.dwThreadID, D$esi+4 D$CPDI.hThread
    inc D$NumThreads

    Call ScanPEHeader D$CPDI.lpBaseOfImage

    Call GetModuleName D$CPDI.lpBaseOfImage
    FormatString DebugLogString, {B$ '%s ID=%d mapped at 0x%x' EOS}, eax, D$DE.dwProcessId, D$CPDI.lpBaseOfImage
    Call 'USER32.PostMessageA' D$H.DebugDialog, WM_LOG, DebugLogString, ecx
ret
____________________________________________________________________________________________

; When exception/breakpoint is encountered.

[DebugEventType: D$ ?
 WatchedAddress: D$ ?]
[DET_BP 1 DET_STEP 2 DET_WP 3 DET_EXCEPTION 4]

; Exception flags
[ExceptionFlags: D$ ?]
[E_HAPPENED 1     E_OUTSIDE 2     E_MUSTEXIT 4]

[CurrentModule: D$ ?]

Proc Debugger_OnException:
    Local @hThread, @Exit

    Mov D@Exit &FALSE

    ;Mov edi ExceptionTypes, eax D$E.ExceptionCode, ecx 18
    ;repne scasd | jne P9>>
    ;Mov eax ExceptionStrings | Mov ebx 17 | sub ebx ecx | shl ebx 2 | add eax ebx
    ;Mov eax D$eax, D$BreakTitle eax

    ; Retrieve handle of the thread that has thrown the exception
    Mov esi D$TABLE.H.ThreadID, eax D$DE.dwThreadID
    While D$esi <> eax
        add esi 8
    End_While
    Move D@hThread D$esi+4

    ;Mov D$C.ContextFlags MY_CONTEXT_FULL
    ;Call 'KERNEL32.GetThreadContext' D@hThread, CONTEXT

    ..If B$DebugStart = &TRUE

      ; Take note which window currently has the focus
        Call 'USER32.GetForegroundWindow' | Mov D$ActiveWindow eax

        Mov D$CONTEXT@ContextFlags MY_CONTEXT_FULL
        Call 'KERNEL32.GetThreadContext' D@hThread, CONTEXT

        Call IsModuleCode D$CONTEXT@regEip
        If eax <> 0
            Move D$CurrentModule D$eax+ME_Name
        Else
            Mov D$CurrentModule 0
        End_If

        Call IsProcessCode D$CONTEXT@regEip
        If eax = 1
            Move D$SourcePosCodeAddress D$CONTEXT@regEip
        Else
            Call ScanStackForCodePointer D$CONTEXT@REG_ESP
            dec eax
            Mov D$SourcePosCodeAddress eax
        End_If

        Call ResolveSegmentAddresses D@hThread

        ; Write-back dynamic breakpoints. BPPending points at an entry in the
        ; breakpoint table-
        Mov ebx D$BPPending
        If ebx <> 0
            Call WriteProcessMem D$ebx, BreakpointOp, 1
            Mov B$ebx+5 BP_ENABLED
            Mov D$BPPending 0
        End_If

        Mov D$ContinueMode CONTINUE_RUN ; default

        .If D$E.ExceptionCode = &EXCEPTION_SINGLE_STEP
            Mov D$DebugEventType DET_STEP

            Call EncounterWatchPoint

            If D$RunAfterWriteBack = &FALSE
                On D$HoldOnBreakpoints = &TRUE,
                    Call SignalDebugEvent        ; <<<<<<<<<<<<<<<<<<<<<<<<<<
            Else
                Mov D$ContinueMode CONTINUE_RUN
                Mov D$RunAfterWriteBack &FALSE
            End_If

        .Else_If D$E.ExceptionCode = &EXCEPTION_BREAKPOINT
            Mov D$DebugEventType DET_BP

            Call EncounterBreakpoint
            On D$HoldOnBreakpoints = &TRUE,
                Call SignalDebugEvent        ; <<<<<<<<<<<<<<<<<<<<<<<<<<

        .Else
            Mov D$DebugEventType DET_EXCEPTION

            Call EncounterException
            Mov D@Exit eax

            ;On D$ContinueStatus <> &DBG_EXCEPTION_NOT_HANDLED,
            ;    Call SignalDebugEvent        ; <<<<<<<<<<<<<<<<<<<<<<<<<<

            ;If D$E.ExceptionFlags = 0
            ;    Call NextInstructionDecode
            ;    Mov eax D$InstructionLength
            ;    add D$C.regEip eax ; TODO this is a dirty hack and no real solution!!
            ;    Mov D@Exit 0
            ;End_If
        .End_If

        .If D@Exit = &FALSE
            ; For step over instructions, we overwrite the process memory after
            ; the next instruction with a breakpoint. The overwritten byte is
            ; preserved with the code address in the breakpoint table.
            If D$ContinueMode = CONTINUE_STEPOVER
                Mov ebx D$CONTEXT@regEip | add ebx D$InstructionLength
                Call AddProcessBreakpoint ebx, BP_ONESHOT, BP_ENABLED, 0
            Else_If D$ContinueMode = CONTINUE_RETURNTOCALLER
                Call ScanStackForCodePointer D$CONTEXT@REG_ESP
                On eax <> 0,
                    Call AddProcessBreakpoint eax, BP_ONESHOT, BP_ENABLED, 0
            End_If

            If D$BPPending <> 0
                On D$ContinueMode <> CONTINUE_STEP,
                    Mov D$RunAfterWriteBack &TRUE
                Mov D$ContinueMode CONTINUE_STEP
            End_If

            If D$ContinueMode = CONTINUE_STEP
                or D$CONTEXT@regFlag 0100 ; set trap flag
            Else
                and D$CONTEXT@regFlag 0_FFFF_FEFF ; in case of Exceptions it's not auto-cleared
            End_If

            On D$ContinueMode = CONTINUE_RUN,
                Call ShowProcessWindows

            On D$TerminateDebuggee = &TRUE,
                Mov D@Exit &TRUE

            ; Take care of user-activated/deactivated dynamic breakpoints.
            Call ClearBPAnteroom

            Call TransferWatchpoints

            Mov D$CONTEXT@ContextFlags MY_CONTEXT_FULL
            Call 'KERNEL32.SetThreadContext' D@hThread, CONTEXT

        .End_If

    ..Else

        If D$E.ExceptionCode = &EXCEPTION_BREAKPOINT
            Mov B$DebugStart &TRUE
            Call ClearBPAnteroom
            Call 'USER32.PostMessageA' D$H.DebugDialog, WM_BEGIN_DEBUG, 0, 0
        End_If

    ..End_If
    Mov eax D@Exit

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[LDT_ENTRY: B$ ? # 8]

[LinearSegmentAddresses:
 CS.Linear: D$ ?
 @CS.Limit: D$ ?
 DS.Linear: D$ ?
 @DS.Limit: D$ ?
 ES.Linear: D$ ?
 @ES.Limit: D$ ?
 FS.Linear: D$ ?
 FS.Limit: D$ ?
 GS.Linear: D$ ?
 @GS.Limit: D$ ?
 SS.Linear: D$ ?
 @SS.Limit: D$ ?]

Proc ResolveSegmentAddresses:
    Arguments @hThread

    Mov esi SegRegMap, edi LinearSegmentAddresses, ebx 6

    While ebx > 0
        lodsd
        Call 'KERNEL32.GetThreadSelectorEntry' D@hThread, D$eax, LDT_Entry
        If eax = &TRUE
            Mov al B$LDT_ENTRY+4, ah B$LDT_ENTRY+7
            shl eax 16
            Mov ax W$LDT_ENTRY+2
            stosd
            movzx eax W$LDT_ENTRY
            stosd
        End_If
        dec ebx
    EndWhile
EndP
____________________________________________________________________________________________

; The 'ModuleList' points at a list of module information entries that are currently
; loaded and mapped into the address space of the debuggee.

; Entry in module list
[ME_Base 0          ; The base VA of the mapped module
 ME_Size 4          ; size in bytes
 ME_Name 8          ; pointer to filename
 ME_CodeBase 12     ; base VA of code section
 ME_CodeSize 16     ; size in bytes of code section
 ME_ExportBase 20   ; base RVA of export section
 ME_ExportSize 24]  ; size in bytes of export section
[SizeOf_ModuleEntry 32]

[ModuleList: D$ ?
 NumModules: D$ ?
 ModuleNameHeap: D$ ?]

[new | imul eax D$Num#1s SizeOf_#1Entry | add eax D$#1List | inc D$NumModules | Mov #2 eax]
[delete | Push esi edi ecx | dec D$Num#1s |
    Mov ecx SizeOf_#1Entry | imul esi D$Num#1s SizeOf_#1Entry | add esi D$#1List |
    Mov edi #2 | rep movsb |
    Pop ecx edi esi]
____________________________________________________________________________________________

; After messing with the toolhelp and psapi and having endless problems enumerating and
; getting module info I finally decided to use none of these evil APIs and read information
; needed directly from the PE image in the debuggee as soon as it is loaded. Most of the
; addresses are stored in the header. Only the module name must be read out of the export
; section or, in case of executables, from the commandline.

Proc ScanPEHeader:
    Arguments @BaseAddress
    Local @Size, @CodeBase, @CodeSize, @ExportBaseRVA, @ExportSize, @Name, @IsExe
    Uses esi, edi, ebx

        ; Read size of image, base-address and size of the code section & export table
        ; from PE image header.
        Call VirtualAlloc PEBuffer,
                          0400

            Call ReadProcessMem D@BaseAddress, D$PEBuffer, 0400

            Call 'KERNEL32.HeapAlloc' D$ModuleNameHeap, 0, 040
            Mov D@Name eax

            Mov esi D$PEBuffer
            add esi D$esi+03C ; skip DOS header
            test W$esi+016 &IMAGE_FILE_DLL NOT_ZERO S1>; characteristics (dll/exe)

                or B@IsExe 1

S1:         add esi 018 ; skip file header

            On W$esi <> 010B, jmp @Error ; check optional header ID

            Move D@Size D$esi+038

            Mov eax D$esi+014 | add eax D@BaseAddress
            Mov D@CodeBase eax
            Move D@CodeSize D$esi+04
            Move D@ExportBaseRVA D$esi+060
            Move D@ExportSize D$esi+064

        Call VirtualFree PEBuffer

        ; A PE can be a DLL or an EXE (and some other formats that RosAsm does not deal with yet).
        ; If it is an executable its name is extracted from the commandline. Otherwise (DLL) the
        ; name is expected in the export table.
        .If B@IsExe = &FALSE
            ; A dll without an export table??
            On D@ExportBaseRVA = 0, jmp @Error
            On D@ExportSize = 0, jmp @Error

            ; Load the export table.
            Call VirtualAlloc PEBuffer,
                              D@ExportSize

                Mov eax D@ExportBaseRVA | add eax D@BaseAddress
                Call ReadProcessMem eax, D$PEBuffer, D@ExportSize

                Mov esi D$PEBuffer, edi D@Name
                ; copy module name
                Mov edx D$esi+0C
                sub edx D@ExportBaseRVA
                add edx esi
                Do
                    Mov al B$edx
                    stosb
                    inc edx
                Loop_Until al = 0
                Mov B$edi 0

            Call VirtualFree PEBuffer

        ; TODO is it possible that exe files are used as library from the actual application exe?
        ; If really possible this branch would be wrong. (ntoskrnl.exe !)
        .Else
            Move D@Name D$DebuggeeExeTitle
        .End_If

        new Module edi

        Move D$edi+ME_Base D@BaseAddress
        Move D$edi+ME_Size D@Size
        Move D$edi+ME_Name D@Name
        Move D$edi+ME_CodeBase D@CodeBase
        Move D$edi+ME_CodeSize D@CodeSize
        Move D$edi+ME_ExportBase D@ExportBaseRVA
        Move D$edi+ME_ExportSize D@ExportSize

        Mov eax D@BaseAddress, ecx D@CodeSize, edx D@CodeBase
        .If D$SavingExtension = '.DLL'
            If eax = D$LinkerDllDefault
                Mov D$DebugBaseOfCode edx
                Mov D$DebugCodeSize ecx
            End_If
        .Else
            If eax = LINKERDEFAULT
                Mov D$DebugBaseOfCode edx
                Mov D$DebugCodeSize ecx
            End_If
        .End_If

        Mov eax 1
        ExitP

@Error:
        Call VirtualFree PEBuffer

        Mov eax 0

EndP
____________________________________________________________________________________________

Proc Debugger_OnLoadDll:
    Arguments @BaseAddress

        Call 'KERNEL32.CloseHandle' D$LoadDll.hFile

        Call ScanPEHeader D@BaseAddress

        Call GetModuleName D@BaseAddress
        FormatString DebugLogString, {B$ '%s mapped at 0x%x' EOS}, eax, D@BaseAddress
        Call 'USER32.PostMessageA' D$H.DebugDialog, WM_LOG, DebugLogString, ecx

EndP
____________________________________________________________________________________________

Proc Debugger_OnUnloadDll:
    Arguments @BaseAddress
    Uses esi, edi

        Call GetModuleName D@BaseAddress
        FormatString DebugLogString, {B$ '%s unmapped' EOS}, eax
        Call 'USER32.PostMessageA' D$H.DebugDialog, WM_LOG, DebugLogString, ecx

        ; Search module in table
        Mov edi D$ModuleList, ecx 0, eax D@BaseAddress
        While ecx < D$NumModules
            On D$edi = eax, jmp L0>
            add edi SizeOf_ModuleEntry
            inc ecx
        EndWhile
        ExitP

L0:
        ; Do cleanup work. Free the memory for the module name.
        Call 'KERNEL32.HeapFree' D$ModuleNameHeap, 0, D$edi+ME_Name

        ; Overwrite the entry to delete with last entry in table.
        delete Module edi

EndP
____________________________________________________________________________________________

; Search in the modulelist for the name of the module starting at the base address passed.

GetModuleName:
    Mov eax D$esp+4
    Mov edx D$ModuleList, ecx D$NumModules
    While ecx > 0 ; bugfix V2.0b
        cmp eax D$edx+ME_Base | je L1>
        add edx SizeOf_ModuleEntry
        dec ecx
    EndWhile
    Mov eax 0
ret 4
L1: Mov eax D$edx+ME_Name
ret 4
____________________________________________________________________________________________

; Find the module from an address. Return the address of the module entry or NULL if no
; module with such a code address could be found.

Proc IsModuleCode:
    Arguments @CodeAddress
    Uses esi

        Mov ecx 0, esi D$ModuleList
        While ecx < D$NumModules
            Mov eax D$esi+ME_CodeBase, edx D$esi+ME_CodeSize
            .If D@CodeAddress >= eax
                add edx eax
                If D@CodeAddress < edx
                    Mov eax esi
                    ExitP
                End_If
            .End_If
            add esi SizeOf_ModuleEntry | inc ecx
        EndWhile
        Mov eax 0
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[DebugLogString: B$ ? # 256]

; Log debug output to a file. First read debug string from process memory of the debuggee
; to a local buffer (the stack).

[DebugStringBuffer: D$ ?
 DebugLogFile: D$ ?]

[DebugLogFileName: B$ ? # &MAX_PATH]

[DebugLogName: B$ '_dbg.log' EOS]

Proc HandleDebugString:
    Local @Size

  ; Get mem on the stack for the debug string
    movzx eax W$ODS.StringLen
    AlignOn 4 eax
    Mov D@Size eax
    sub esp D@Size
    Mov D$DebugStringBuffer esp

  ; Read the debug string
    Call ReadProcessMem D$ODS.DebugString, D$DebugStringBuffer, D@Size

    Call 'USER32.SendMessageA' D$H.DebugDialog, WM_LOG, D$DebugStringBuffer, D@Size

    .If D$DebugLogFile = 0

      ; Build logfile-name of the form "[Path]\[AppName]_dbg.log"
        Mov esi DebuggeeExe, edi DebugLogFileName, ecx 256

      ; Copy full path+filename+extension
L0:     cmp B$esi 0 | je L1>
        movsb
        loop L0<

L1:     neg ecx | add ecx 256
        Mov B$edi 0

      ; Strip extension
L0:     cmp B$edi '.' | je L1>
        dec edi
        loop L0<

L1:     neg ecx | add ecx 256
        Mov esi DebugLogName

      ; append "_dbg.log"
L0:     cmp B$esi 0 | je L1>
        movsb
        loop L0<

L1:     Mov B$edi 0

        Call 'KERNEL32.CreateFileA' DebugLogFileName, &GENERIC_WRITE, &FILE_SHARE_READ, 0,
            &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0

        If eax = &INVALID_HANDLE_VALUE
            Call ReportWinError {B$ 'HandleDebugString: CreateFile' EOS}
            jmp L9>
        Else
            Mov D$DebugLogFile eax
        End_If

    .End_If

    movzx eax W$ODS.StringLen | dec eax
    Call 'KERNEL32.WriteFile' D$DebugLogFile, D$DebugStringBuffer, eax, BytesTransfered, 0

    Mov W$esp 0A0D
    Call 'KERNEL32.WriteFile' D$DebugLogFile, D$DebugStringBuffer, 2, BytesTransfered, 0

  ; Free mem from the stack
L9: add esp D@Size
EndP
____________________________________________________________________________________________

; Called when an exception in the debuggee occurs. Check if the exception is continueable.
; Returns 1 if the debuggee must be terminated, otherwise 0.

Proc EncounterException:
    Local @Exit, @Dummy

    Mov D$ExceptionFlags E_HAPPENED

    Call IsProcessCode D$CONTEXT@regEip
    If eax = 0
        Call ScanStackForCodePointer D$CONTEXT@REG_ESP
        dec eax
        Mov D$SourcePosCodeAddress eax
    End_If

    ..If D$E.FirstChance <> 0
      ; check if exception handler is inside debuggee code
        lea eax D@Dummy | Call ReadProcessMem D$FS.Linear, eax, 4
        Mov ecx D@Dummy | add ecx 4 ; get handler address
        lea eax D@Dummy | Call ReadProcessMem ecx, eax, 4
        Call IsProcessCode D@Dummy ; handler address
        .If eax = 1
            Call IsProcessCode D$CONTEXT@regEip
            On eax = 0, or D$ExceptionFlags E_OUTSIDE

            Call SignalDebugEvent
            If D$TerminateDebuggee = &TRUE
                Mov eax 1
            Else
                Mov D$ContinueStatus &DBG_EXCEPTION_NOT_HANDLED
                Mov D$ContinueMode CONTINUE_RUN
                Mov eax 0
            End_If
        .Else
            Mov D$ContinueStatus &DBG_EXCEPTION_NOT_HANDLED
            Mov D$ContinueMode CONTINUE_RUN
            Mov eax 0
        .End_If
    ..Else
        or D$ExceptionFlags E_MUSTEXIT

        Call SignalDebugEvent
        Mov eax 1
    ..End_If

    Mov D$ExceptionFlags 0 ; was only needed for UI, clear it so we could proceed (SEH)

;;
  ; Check if Exception happened outside of application code. 
    Call IsProcessCode D$C.regEip
    .If eax = 1
        
        On D$E.FirstChance = 0, 
            or D$ExceptionFlags E_MUSTEXIT
            
        Call SignalDebugEvent
        
        If D$TerminateDebuggee = &TRUE
            Mov eax 1
        Else
            Mov D$ContinueStatus &DBG_EXCEPTION_NOT_HANDLED
            Mov D$ContinueMode CONTINUE_RUN
            Mov eax 0
        End_If
        
    .Else
    
        or D$ExceptionFlags E_OUTSIDE
      
      ; Give the module the possibility to handle the exception by its per-thread
      ; exception handler. If it does not catch the exception, show the exception
      ; dialog.
      
        If D$E.FirstChance = 0
            or D$ExceptionFlags E_MUSTEXIT            
            
            Call ScanStackForCodePointer D$C.REG_ESP
            dec eax
            Mov D$SourcePosCodeAddress eax
            
            Call SignalDebugEvent
          
            Mov eax 1
        Else
            Mov D$ContinueStatus &DBG_EXCEPTION_NOT_HANDLED
            Mov D$ContinueMode CONTINUE_RUN
            Mov eax 0
        End_If
    
    .End_If    
    
    Mov D$ExceptionFlags 0 ; was only needed for UI, clear it so we could proceed (SEH)
                
    .If D$E.FirstChance = 0
        Mov D$ExceptionFlags E_HAPPENED

        Call IsProcessCode D$C.regEIP
        If eax = &FALSE
            
        End_If

        ; Exception is continueable?
        If D$E.ExceptionFlags <> 0
            or D$ExceptionFlags E_MUSTEXIT
            Mov D@Exit 1
        End_If

        ;Call SignalDebugEvent

        Mov eax D@Exit
        On D$TerminateDebuggee = &TRUE, Mov eax 1
    .Else
    
      ; try to pass to apps exception handler
        Mov D$ContinueStatus &DBG_EXCEPTION_NOT_HANDLED
        Mov eax 0
        
    .End_If
;;
EndP
____________________________________________________________________________________________

; Bring all visible windows of the debuggee to front.

[ActiveWindow: D$ ?]

Proc EnumThreadWindowProc:
    Arguments @hwnd, @Param

    Call 'USER32.SetWindowPos' D$H.MainWindow, D@hwnd, 0, 0, 0, 0, &SWP_NOMOVE+&SWP_NOSIZE

    Mov eax D@hwnd
    If eax = D$ActiveWindow
        Call 'USER32.SetForegroundWindow' D$ActiveWindow
    End_If

    Mov eax 1
EndP

ShowProcessWindows:
    Mov ebx 0, esi D$TABLE.H.ThreadID
    While ebx < D$NumThreads
        Call 'USER32.EnumThreadWindows' D$esi+ebx*8, EnumThreadWindowProc, 0
        inc ebx
    EndWhile
ret
____________________________________________________________________________________________

; STACK SCANNER
____________________________________________________________________________________________

;;
    The stack has the following structure (for each stackframe)
    
        Parameter n
        [...]
        Parameter 2
    ___ Parameter 1
        Return Address
        Saved EBP (if proc has stackframe)
        Local data
    
  * To differ between procedures we first have to find the return addresses. Then the number
    of parameters must be estimated. Given that information a complete Call-stack can
    be generated.
    
  * First, all return addresses on the stack are collected bottom-up. The proc is tried to
    be identified. 
    
  * Note that life would be much easier if every proc was guaranteed to have a stack frame.
    We could just take the saved ebp as a pointer to the callers stack frame. However,
    in Assembly you are free to use ebp for whatever you like, and creating a stack frame is
    optional. Therefore the return addresses are used to identify called procedures.
    
  * Misinterpretation problems arise from "stack pollution", that is procs reserving space on 
    the stack without freeing it (e.g. sub esp 0100). Return addresses from former execution
    pollute the stack in this region. This has been partially solved by validating the stack 
    frames top-down in the third pass (ignore the locals region). The remaining problems
    are due to dynamic stack allocation (e.g. sub esp ecx). 
;;

[BufferOverrun:
B$ "Detected buffer-overrun. 
Contact RosAsm dev team if this happens regularly." EOS]

[CallStackDesc: D$ ?
 CallStackEntries: D$ ?
 FirstCallStackEntry: D$ ?]

[MAX_CALLSTACK_ENTRIES 512]

[CSE_Address 0      ; points at the ret-address+4 in the LOCAL stack copy
 CSE_ProcAddress 4  ; (estimated) address of the called function
 CSE_ProcName 8     ; points at the name (+estimation info) of the funtion
 CSE_NumParams 12   ; number of paramters (after ret-address)
 CSE_NumLocals 16   ; number of locals (before ret-address)
 CSE_Rating 20      ; probability of correctness
 CSE_Flags 21       ; flags
 CSE_Next 24        ; address of next Call-stack entry
 SizeOf_CSE 32]     ; align on cache line

[CSEF_HAS_STACKFRAME 01  ; CSE has a stackframe (Push ebp | ...)
 CSEF_FUZZY_ADDRESS  02  ; address of proc is not exact
 CSEF_EXTERNAL       04] ; proc is outside debugged module


[ProcNameHeap: D$ ?]

Proc GenerateCallStack:
    Local @Pointer, @CurrentSize, @ProcAddr, @LastCodeAddr, @Exact, @NumLocals

    Call DestroyCallStack

    On D$ProcNameHeap = 0, Call 'KERNEL32.HeapCreate' 0, 01000, 0
    Mov D$ProcNameHeap eax

    Call ReadApplicationStack D$CONTEXT@REG_ESP
    On eax = &FALSE, ExitP
    On D$CallStackDesc = 0 Call VirtualAlloc CallStackDesc,
                                             04000

    Call CallStack.Pass1
    If D$CallStackEntries = 0
        Mov eax 0
        ExitP
    End_If
    Call CallStack.Pass2
    Call CallStack.Pass3
;;
    Mov esi D$StackBuffer, edi D$CallStackDesc, D$CallStackEntries 0
    Mov D$NextStackFrame 0, D@NumLocals 0
    Move D@CurrentSize D$StackSize
    Move D@LastCodeAddr D$C.regEip
    .While D@CurrentSize > 0
        lodsd | Mov D@Pointer eax

        Call IsReturnAddress eax, edi
        .If eax = &TRUE

            Mov D$edi+CSE_Address esi

            Call 'KERNEL32.HeapAlloc' D$ProcNameHeap, 0, 040
            Mov D$edi+CSE_ProcName eax

            ; Check if the exact address of the procedure called could be estimated.
            ; If not (Call reg / Call mem / ...) use the code address which is
            ; somewhere in the proc to find the procedure address and label.
            Mov eax D$edi+CSE_ProcAddress
            If eax <> 0
                Mov D@ProcAddr eax
                Mov D@Exact &TRUE
            Else
                Move D@ProcAddr D@LastCodeAddr
                Mov D@Exact &FALSE
            End_If
            Call IsProcessCode D@ProcAddr
            If eax = &TRUE
                Call ScanLabelListForCodeLabel D@ProcAddr, D@Exact
            Else
                Call ScanExportTableForCodeLabel D@ProcAddr, D@Exact
            End_If

            Mov D$edi+CSE_ProcAddress eax

            Push esi edi
                Mov esi LabelName, edi D$edi+CSE_ProcName
                Do | movsb | Loop_Until B$esi-1 = 0
            Pop edi esi

            Call CountParametersAndScanStackFrame edi

            ; Local data - Begin to count local data from the last return address.
            ; Therefore NumLocals start with a negative number if parameters were
            ; passed to the last function.
            Mov eax D@NumLocals
            On eax l 0, Mov eax 0
            Mov D$edi+CSE_NumLocals eax

            Mov eax D$edi+CSE_NumParams | neg eax
            Mov D@NumLocals eax

            Move D@LastCodeAddr D@Pointer
            add edi SizeOf_CSE
            inc D$CallStackEntries
        .Else
            inc D@NumLocals
        .End_If
        sub D@CurrentSize 4
    .EndWhile
;;
    Mov eax &TRUE
EndP

____________________________________________________________________________________________

; First pass - search all possible return addresses

Proc Callstack.Pass1:
    Local @CurrentSize, @LastCodeAddr, @Pointer, @ProcAddr, @Exact
    Uses esi, edi

    Mov esi D$StackBuffer, edi D$CallStackDesc, D$CallStackEntries 0
    Move D@CurrentSize D$StackSize
    Move D@LastCodeAddr D$CONTEXT@regEip
    .While D@CurrentSize > 0
        lodsd | Mov D@Pointer eax

        Call IsReturnAddress eax, edi
        .If eax = &TRUE
            Mov D$edi+CSE_Address esi

            Call 'KERNEL32.HeapAlloc' D$ProcNameHeap, 0, 040
            Mov D$edi+CSE_ProcName eax

          ; Check if the exact address of the procedure called could be estimated.
          ; If not (Call reg / ...) use the code address which is
          ; somewhere in the proc to find the procedure address and label.
            Mov B$edi+CSE_Flags 0
            Mov eax D$edi+CSE_ProcAddress
            If eax <> 0
                Mov D@ProcAddr eax
                Mov D@Exact &TRUE
            Else
                Move D@ProcAddr D@LastCodeAddr
                or B$edi+CSE_Flags CSEF_FUZZY_ADDRESS
                Mov D@Exact &FALSE
            End_If
            Call IsProcessCode D@ProcAddr
            If eax = &TRUE
                Call ScanLabelListForCodeLabel D@ProcAddr, D@Exact
            Else
                Call ScanExportTableForCodeLabel D@ProcAddr, D@Exact
                or B$edi+CSE_Flags CSEF_EXTERNAL
            End_If

            Mov D$edi+CSE_ProcAddress eax

            Push esi edi
                Mov esi LabelName, edi D$edi+CSE_ProcName
                Do | movsb | Loop_Until B$esi-1 = 0
            Pop edi esi

            Move D@LastCodeAddr D@Pointer
            add edi SizeOf_CSE
            inc D$CallStackEntries

          ; Prevent buffer overrun
            If D$CallStackEntries >= MAX_CALLSTACK_ENTRIES
                Call 'USER32.MessageBoxA' D$H.MainWindow, BufferOverrun, {B$ 'Callstack generation' EOS}, &MB_OK+&MB_ICONEXCLAMATION
                Mov eax &FALSE
                ExitP
            End_If
        .End_If
        sub D@CurrentSize 4
    .EndWhile
    Mov eax &TRUE
EndP
____________________________________________________________________________________________

; Second pass - scan stack frames and rate procs

[CSRatingFailed: D$ ?] ; indicate that rating wasn't successful -> don't rely on the ratings

Proc CallStack.Pass2:
    Uses esi, edi, ebx

    Mov esi D$StackBuffer, edi D$CallStackDesc, ecx D$CallStackEntries
    Mov edx esi | sub edx D$CONTEXT@REG_ESP

    Mov ebx D$CONTEXT@regEbp | add ebx edx

L0:     lea eax D$ebx+8
        While eax <> D$edi
            add edi SizeOf_CSE
            dec ecx | jz L9>
        EndWhile
        inc B$edi+CSE_Rating

      ; Check for invalid stackframe ptrs - a stackframe ptr is invalid if it points
      ; to somewhere outside the used stack.
        If ebx < esi
            Mov D$CSRatingFailed 1
            ExitP
        End_If
        Mov eax esi | add eax D$StackSize
        If ebx >= eax
            Mov D$CSRatingFailed 1
            ExitP
        End_If

        Mov ebx D$ebx | add ebx edx ; next stackframe ptr
    jmp L0<

L9: Mov D$CSRatingFailed 0
EndP
____________________________________________________________________________________________

; Third pass - validate, count params, locals, ...

Proc CallStack.Pass3:
    Local @LowerBound, @UpperBound, @LastCSE
    Uses esi, edi, ebx

  ; Traverse the callstack top-down, begin with the last entry
    Mov ebx D$CallStackEntries | dec ebx
    imul edi ebx SizeOf_CSE | add edi D$CallStackDesc
    Mov esi D$edi+CSE_address ; esi -> params of the root function

    Mov eax D$StackBuffer | Mov D@LowerBound eax
    add eax D$StackSize   | Mov D@UpperBound eax

    Mov D@LastCSE 0

    .While ebx ge 0

      ; UpperBound - address of last CSE
      ; LowerBound - limit given through esp

      ; The bounds are stored to detect collisions of CSEs. Collision (or overlaps)
      ; occur if some interpretation mechanism has failed (locals, params) or if the
      ; whole CSE is a ghost entry (old ret addresses in non-overwritten locals)

        Mov eax D$edi+CSE_Address
        .If D@UpperBound < eax
            Mov edx D@LastCSE | Mov al B$edx+CSE_Rating
            If al g B$edi+CSE_Rating
              ; overlapped by local data of a higher rated proc, considered
              ; as stack pollution -> throw away
                jmp L8>
            Else_If al = B$edi+CSE_Rating
              ; overlapped by local data of equally rated proc, the assumption
              ; about the size of local data of the last CSE might be wrong, correct it (set to zero)
                Mov D$edx+CSE_NumLocals 0
                ;Mov eax D$edi+CSE_Address | sub eax D@Upperbound | shr eax 2
                ;sub D$edx+CSE_NumLocals eax
                Move D@UpperBound D$edi+CSE_Address
            Else
              ; overlapped by local data of lower rated proc (the interpretation failed)
              ; throw away the last(!) CSE
                Mov eax D$edx+CSE_Next | Mov D@LastCSE eax
            End_If
        .End_If

        Call CountParametersAndScanStackFrame edi

      ; Check parameters size - the parameter sizes should be ok in most cases.
      ; however, if some ill "ret 086D" statement is somewhere in the source (e.g. MyPNN)
      ; the boundaries are exceeded easily. If this occurs in other apps too, better merge
      ; the validation of param and local sizes and do something more intelligent ...
        Mov eax D$edi+CSE_NumParams | shl eax 2
        add eax D$edi+CSE_Address
        If D@UpperBound < eax
          ; MyPNN phenomenon, consider cleaner way to deal with this issue
            Mov D$edi+CSE_NumParams 0
        End_If


        If D$CSRatingFailed = 0
          ; proc with stackframes should be rated if rating was successful
            test B$edi+CSE_Flags CSEF_HAS_STACKFRAME ZERO L0>
                cmp B$edi+CSE_Rating 1 | jl L8>
L0:     End_If

      ; recompute upper bound
        Mov eax D$edi+CSE_NumLocals | inc eax | shl eax 2 ; SizeOf(Locals+RetAddress)
        Mov edx D$edi+CSE_Address | sub edx eax
        Mov D@UpperBound edx

      ; if we just entered the proc the stack might not be fully filled - either we
      ; must handle it or the one who displays it. Otherwise we'd read below the stackptr.
        If edx < D@LowerBound
            sub edx D@Lowerbound ; edx is negative!
            neg edx | shr edx 2
            sub D$edi+CSE_NumLocals edx ; subtract from localnumber
        End_If

        Move D$edi+CSE_Next D@LastCSE
        Mov D@LastCSE edi

L8:     sub edi SizeOf_CSE
        dec ebx | js L9>
    .EndWhile

L9: Move D$FirstCallStackEntry D@LastCSE

EndP
____________________________________________________________________________________________


____________________________________________________________________________________________

Proc DestroyCallStack:
    Mov D$StackSize 0

    Call VirtualFree StackBuffer

    Mov D$CallStackEntries 0, D$FirstCallStackEntry 0

    Call VirtualFree CallStackDesc

    If D$ProcNameHeap <> 0

        Call 'KERNEL32.HeapDestroy' D$ProcNameHeap

        Mov D$ProcNameHeap 0

    End_If

EndP
____________________________________________________________________________________________

; Copy the complete stack from the address space of the debuggee into our address space.

[StackBuffer: D$ ?
 StackSize: D$ ?]

Proc ReadApplicationStack:
    Arguments @StackPointer

        ; Get size of current stack
        Mov eax D@StackPointer
        On eax = 0, ExitP
        and eax 0_FFFF_FFFC ; dword align
        Mov D@StackPointer eax
        Call IsProcessMemory D@StackPointer
        On eax = 0, ExitP
        Mov D$StackSize eax

        ; Copy stack, starting at the stackpointer
        Call VirtualAlloc StackBuffer,
                          eax

        Call ReadProcessMem D@StackPointer, D$StackBuffer, D$StackSize
EndP
____________________________________________________________________________________________

; Check if the given value is an return address.
; Returns:
;   eax - TRUE / FALSE

; NextStackFrame is the so called ghost-return-address prevention. In external modules
; all procs are assumed to have a stackframe (which is not true). If those procs use the
; stack for local data (sub esp imm) but do not clear/use it, old return addresses might
; still be there (this happens _very_ often).
[NextStackFrame: D$ ?]

Proc IsReturnAddress:
    Arguments @Address, @CSE

    Mov eax D@CSE
    Mov D$eax+CSE_ProcAddress 0

    Call IsProcessCode D@Address
    ..If eax = 1
        Call IsReturnAddressInSource D@Address, D@CSE
    ..Else
        Mov eax 0
        Call IsModuleCode D@Address
        .If eax <> 0
            If edi > D$NextStackFrame
                Call IsReturnAddressInModule D@Address, D@CSE, eax
            Else
                Mov eax 0
            End_If
        .End_If
    ..End_If
EndP
____________________________________________________________________________________________

; Determine if the given address is a return address which was pushed on the stack by a
; call. We look into process memory if the instruction preceding the address is call.
; There are some different encodings of calls:
;   Call Label      >> E8 ## ## ## ##
;   Call D$Label    >> FF 15 ## ## ## ##
;   Call reg32      >> FF D#
;   Call D$reg32    >> FF 1# (eax/ecx/edx/ebx/edi/esi)
;   Call D$esp      >> FF 14 24
;   Call D$ebp      >> FF 55 00
; And with address arithmetic there are more variants. So we first check for the standard
; Call opcode E8. If it is different we scan backward for the opcode FF and try a decode.
; If the decoded instruction is a Call and equals the number of bytes searched back
; IsReturnAddress returns 1 otherwise 0 (in eax).

[PrecedingCode: B$ ? # 96]

[PrecedingCodeSize: D$ ?]

Proc IsReturnAddressInModule:
    Arguments @Address, @CSE, @ModuleBase
    Uses ebx, edi

        Mov eax D@ModuleBase, ebx D@Address, ecx ebx
        sub ecx D$eax+ME_CodeBase
        If ecx > 8
            Mov ecx 8
        Else_If ecx < 2
            ; the minimum length of a Call is two bytes (FF ##)
            jmp L9>>
        Else
            Mov D$PrecedingCode 0, D$PrecedingCode+4 0
        End_If
        Mov D$PrecedingCodeSize ecx | sub ebx ecx
        Call ReadProcessMem ebx, PrecedingCode, ecx

        Mov edi PrecedingCode, ecx D$PrecedingCodeSize
        If B$edi+ecx-5 = 0E8 ; Call imm
            Mov eax &TRUE
            ; convert the immediate to a virtual address
            Mov edx D$edi+ecx-4
            add edx D@Address
            Mov ecx D@CSE
            Mov D$ecx+CSE_ProcAddress edx
            ExitP
        Else_If W$edi+ecx-6 = 015FF ; Call D$Label
            Mov eax D$edi+ecx-4
            Call ReadProcessMem eax, PrecedingCode, 4
            Mov edx D$PrecedingCode
            Mov ecx D@CSE
            Mov D$ecx+CSE_ProcAddress edx
            Mov eax &TRUE
            ExitP
        End_If
L1:     Mov al 0FF
            repne scasb | jne L9>
            dec edi

            Call InstructionDecode edi
            Mov eax D$NextInstructionPtr
            .If D$eax = 'Call'
                inc ecx
                If ecx = D$InstructionLength
                    Mov eax &TRUE
                    ExitP
                End_If
                dec ecx
            .End_If
            inc edi
        jmp L1<

L9:     Mov eax &FALSE
EndP
____________________________________________________________________________________________

; Simplified version of IsReturnAddress. Here we use the IpTable to find the preceding
; instruction. This is much safer as no data can be mistaken as an opcode.

Proc IsReturnAddressInSource:
    Arguments @Address, @CSE
    Uses ebx, edi, esi

        ; >>> TODO
        ; Most mistaken return addresses are indeed function addresses which are pushed
        ; on the stack (callback functions, window procs). We should take care of the
        ; following case:
        ; Main:
        ; [...]
        ; Call 'KERNEL32.ExitProcess'
        ; Proc MainWindowProc:
        ; [...]
        ; EndP
        ; The address of the window proc is saved on the stack multiple times, therefore
        ; messing up the callstack because it is preceded by Call and mistaken as a return
        ; address.
        ; <<< TODO

        Mov eax D@Address

      ; Search for return address in the instruction table.
        sub eax D$DebugBaseOfCode
        Mov edi D$IpTable, ecx D$IpTablePtr
        sub ecx edi
        shr ecx 2
            jz L9>> ; if IpTable is empty/freed (which should never happen)
        While eax >= D$edi
            dec ecx | jz L9>>
            add edi 4
        EndWhile

      ; Search back for the preceding instruction. We can't just use [edi-8] because
      ; also Labels are recorded in the IpTable.
        sub edi 4
        Do
            On edi < D$IpTable, jmp L9>>
            Mov edx D$edi
            sub edi 4
        Loop_Until edx <> eax
        Mov ebx eax | sub ebx edx ; statements length
        add edx D$DebugBaseOfCode
        Call ReadProcessMem edx, PrecedingCode, ebx

      ; The statement might contain several instruction (Call-macro!), so decode
      ; every instruction until we find the last one of that statement.
        Mov esi PrecedingCode
        Do
            Call InstructionDecode esi
            Mov eax D$InstructionLength
            add esi eax
            sub ebx eax
                js L9> ; how is this possible ? it happens... [Bugfix V2.0]
        Loop_Until ebx = 0

        Mov eax D$NextInstructionPtr
        .If D$eax = 'Call'
            Mov eax 1, edx 0
            sub esi D$InstructionLength
            If B$esi = 0E8
                Mov edx D$esi+1
                add edx D@Address
                Mov ecx D@CSE
                Mov D$ecx+CSE_ProcAddress edx
            Else_If W$esi = 015FF
                Mov edx D$esi+2
                Call ReadProcessMem edx, PrecedingCode, 4
                Mov eax D$PrecedingCode
                Mov ecx D@CSE
                Mov D$ecx+CSE_ProcAddress eax
                Mov eax 1
            End_If
            ExitP
        .End_If

L9:     Mov eax 0
EndP
____________________________________________________________________________________________

[LabelName: B$ ? # 128]

CopyStringFromLabelList:
    Push esi, edi

        Mov edi LabelName
        While B$esi <> EOI
            movsb
        EndWhile
        Mov B$edi 0

    Pop edi, esi
ret
____________________________________________________________________________________________

; Lookup the label of the procedure starting at the given address.

Proc ScanLabelListForCodeLabel:
    Arguments @Address, @Exact
    Local @NearestProc @NearestProcName
    Uses esi, edi, ebx

    Mov edi D$PlainLabelList, ebx D$EndOfPlainLabelList, edx D@Address
    Mov ecx D$edi
    add edi 5 | sub ecx 5

    .If D@Exact = &TRUE

        While edi < ebx

            ; address of string
            Mov esi edi
            Mov al EOI
            repne scasb | jne L9>>
            test B$edi+4 FLAG_DATA_LABEL NOT_ZERO L0>
            Mov eax D$edi | add eax D$CodeAjust
            If eax = edx
                Call CopyStringFromLabelList

EndP

            End_If
L0:         add edi 6 | sub ecx 6

        EndWhile

    .Else

        Mov D@NearestProc 0, D@NearestProcName 0
        While edi < ebx

            ; address of string
            Mov esi edi
            Mov al EOI
            repne scasb | jne L9>
            Mov cl B$edi+4
            test cl FLAG_DATA_LABEL NOT_ZERO L0>
            Mov eax D$edi | add eax D$CodeAjust
            If eax <= edx
                On eax > D@NearestProc, Mov D@NearestProc eax, D@NearestProcName esi
            End_If
L0:         add edi 6 | sub ecx 6

        EndWhile

        Mov esi D@NearestProcName
        On esi <> 0, Call CopyStringFromLabelList
        Mov eax D@NearestProc
        On eax <> 0, ExitP

    .End_If

L9: Mov eax D@Address
    Call IntToHexString
    Move D$LabelName D$HexString, D$LabelName+4, D$HexString+4
    Mov B$LabelName+8 0
    Mov eax D@Address
EndP
____________________________________________________________________________________________

; Lookup the label of the procedure starting at the given address. The export table of
; the module which is referenced by the code address is scanned.

[PEBuffer: D$ ?]

Proc ScanExportTableForCodeLabel:
    Arguments @CodeAddress, @Exact
    Local @BaseAddress, @ExportBaseRVA, @ExportSize, @NumNames, @ProcAddressRVA, @AddressTableEntry
    Uses ebx, esi, edi

    Call IsModuleCode D@CodeAddress
    If eax = 0

EndP

    End_If
    Move D@BaseAddress D$eax+ME_Base
    Move D@ExportBaseRVA D$eax+ME_ExportBase
    Move D@ExportSize D$eax+ME_ExportSize

    On D@ExportBaseRVA = 0 EndP

    On D@ExportSize = 0 EndP

    ; Load the export table.
    Call VirtualAlloc PEBuffer,
                      D@ExportSize

        Mov eax D@ExportBaseRVA | add eax D@BaseAddress
        Call ReadProcessMem eax, D$PEBuffer, D@ExportSize

        Mov esi D$PEBuffer, edi LabelName
        ; address conversion: RVA -> Linear address in copied export-table
        Mov eax esi
        sub eax D@ExportBaseRVA
        Mov D$ExportTableAdjust eax
        ; copy module name
        Mov edx D$esi+0C
        add edx D$ExportTableAdjust
        Do
            Mov al B$edx
            If al = 0 ; no library name?
                Mov eax '???.'
                stosd
                jmp L0>
            End_If
            stosb
            inc edx
        Loop_Until al = '.'
        ; number of exported functions
L0:     Mov ecx D$esi+014
        Move D@NumNames D$esi+018
        ; Convert address table RVA to pointer in local buffer
        Mov eax D$esi+01C
        add eax D$ExportTableAdjust
        ; Convert code address to RVA
        Mov ebx D@CodeAddress
        sub ebx D@BaseAddress

        ; ebx = Code RVA
        ; eax -> Address table (list of function RVA's)
        ; ecx = Number of functions

        Mov D@ProcAddressRVA 0
        .If D@Exact = &TRUE

            Mov D@ProcAddressRVA ebx
            While ecx > 0
                If D$eax = ebx
                    Call SearchNameInExportTable
                    cmp edx 0 | je L8> ; function has no name (comctl32.dll !)
                    sub edx D@ExportBaseRVA
                    cmp edx D@ExportSize | ja L8> ; ignore invalid function name pointers (does happen!)
                    Do
                        Mov al B$esi+edx
                        stosb
                        inc edx
                    Loop_until al = 0
                    jmp L9>>
                End_If
                add eax 4
                dec ecx
            EndWhile
L8:         DwordToHex D@CodeAddress
            Mov B$edi 0

        .Else

            While ecx > 0
                If D$eax <= ebx
                    Mov edx D$eax
                    On edx > D@ProcAddressRVA,
                        Mov D@ProcAddressRVA edx, D@AddressTableEntry eax
                End_If
                add eax 4
                dec ecx
            EndWhile
            Mov eax D@AddressTableEntry
            Call SearchNameInExportTable
            If edx <> 0
                sub edx D@ExportBaseRVA
                cmp edx D@ExportSize | ja L8> ; ignore invalid function name pointers (does happen!)
                Do
                    Mov al B$esi+edx
                    stosb
                    inc edx
                Loop_until al = 0
                dec edi
                Mov D$edi ' (< ' | add edi 3
                Mov edx ebx | sub edx D@ProcAddressRVA
                cmp edx 0_FFFF | ja L8> ; function bigger as 64k ??
                Mov ecx 2 | Call IntToHex
                Mov W$edi ')'
            Else
L8:             Mov D@ProcAddressRVA ebx
                Mov al '<' | stosb
                DwordToHex D@CodeAddress
                Mov B$edi 0
            End_If
        .End_If

L9: Call VirtualFree PEBuffer

    Mov eax D@ProcAddressRVA
    add eax D@BaseAddress
EndP

[ExportTableAdjust: D$ ?]

; Input
;   esi -> copied Export section
;   eax -> Address table entry
;   ecx = Number of functions
; Output
;   edx = Name RVA  /  zero (no name in export table -ordinal only-)

SearchNameInExportTable:
    Mov edx 0
    Push eax ecx edi
        sub eax D$ExportTableAdjust ; convert back to RVA
        sub eax D$esi+01C | shr eax 2 ; eax = index of current function
        Mov ecx D$esi+018 ; ecx = number of names
        Mov edi D$esi+024 | add edi D$ExportTableAdjust ; ordinal table
        repne scasw ; search the ordinal table
            jne L9>
        sub edi D$ExportTableAdjust
        sub edi D$esi+024 | shl edi 1
        add edi D$esi+020
        add edi D$ExportTableAdjust
        Mov edx D$edi-4
L9: Pop edi ecx eax
ret
____________________________________________________________________________________________

; Try to find out how many parameters are passed to the procedure. If a stackframe is
; found (entry sequence 55 8B EC), the code is scanned for the exit sequence [8B E5]5D | C9.
;
; After that the ret instruction tells how many bytes are removed from the stack, which
; is the number of params multiplied by 4:
;   ret       >> C3 (no params)
;   ret ####  >> C2 ## ##
; If there is a naked ret (C3) then either there are no parameters, or the params get
; removed by the caller (C_Call). Check the code at the return address for:
;   add esp imm >> 83 C4 ##
;
; If no stackframe is found, the assumption is made that no parameters were passed
; on the stack (which may not be true for some asm hardcore code-styles).

[ProcBuffer: D$ ?]

[GUARD_BYTES 4] ; protect from dissassembler reading data below the ip ('op00')

Proc CountParametersAndScanStackFrame:
    Arguments @CSE
    Local @Procedure, @RetAddress, @Result, @Size, @NumLocals
    Uses edi, esi, ebx

    Call VirtualAlloc ProcBuffer,
                      01000

        Mov D@Result 0

        Mov eax D@CSE
        Mov D$eax+CSE_NumParams 0
        Move D@Procedure D$eax+CSE_ProcAddress
        Mov eax D$eax+CSE_Address
        Move D@RetAddress D$eax-4

        Call IsProcessMemory D@Procedure
        On eax > 01000-GUARD_BYTES, Mov eax 01000-GUARD_BYTES
        Mov D@Size eax

        Mov esi D$ProcBuffer | add esi GUARD_BYTES
        Call ReadProcessMem D@Procedure, esi, D@Size
        On eax = &FALSE, jmp @Exit

        Mov ecx D@Size
        sub ecx 16 ; guard bytes to prevent from disassembly overflow

      ; Stack frame?
        cmp B$esi 0C8   | je @WithStackFrame ; enter x x
        cmp W$esi 08B55 | jne @WithOutStackFrame
        cmp B$esi+2 0EC | jne @WithOutStackFrame
;;
    the proc-entry has the following structure:
    [in most API calls local and seh section exchanged]
    
    stackframe      Push ebp        55
                    Mov ebp esp     8B EC
                    
    locals          sub esp imm8/32 83/81 EC im
    
    SEH            (Push imm32)     68 imm32 / 6A imm8
                   (Push imm32)
                    Push imm32
                    Mov eax D$fs:0  64 A1 00 00 00 00
                    Push eax        50
                    Mov D$fs:0 esp  64 89 25 00 00 00 00                 
                   (Push ecx)
                   (Push ecx)
                   
    save regs       Push ebx
                    ...
    
;;

@WithStackFrame:
        Mov eax D@CSE | or B$eax+CSE_Flags CSEF_HAS_STACKFRAME

      ; Scan proc entry - size of local data in EBX. Local data is
      ; reserved with "sub esp xx" but also everything that is pushed
      ; _before_ the sub is considered as local data (SEH in Win32 code).

        Mov ebx 4, edx 0 ; ebx = sizeof locals, edx = sizeof pushed data
        If B$esi = 0C8 ; enter x x
            add bx W$esi+1
        End_If

        add esi 3 | sub ecx 3

L0:     Call InstructionDecode esi
            If D$eax = 'Push'
                add edx 4
            Else_If D$eax = 'Mov '
                ;nop
            Else_If W$esi = 0EC83 ; sub esp b
                movzx eax B$esi+2
                add ebx eax
                add ebx edx
            Else_If W$esi = 0EC81 ; sub esp dw
                Mov eax D$esi+2
                add ebx eax
                add ebx edx
            Else
                jmp L1>
            End_If
            Mov eax D$InstructionLength
            sub ecx eax | js @Exit
            add esi eax
        jmp L0<

      ; Search exit sequence - might be 'Pop ebp' / 'leave'
L1:     dec ecx | jz @Exit ; we need at min 2 bytes left (leave + ret)
            lodsb
            cmp al 05D | je L2> ; Pop ebp
            cmp al 0C9 | je L2> ; leave
        jmp L1<

        ; Mov esp ebp is not really necessary...
        ;cmp W$esi-3 0E58B | jne L1<

L2:     If B$esi = 0C3 ; ret
            ; C_Call ?
            Call ReadProcessMem D@RetAddress, D$ProcBuffer, 4
            Mov esi D$ProcBuffer
            cmp W$esi 0C483 | jne @Exit
            movzx eax B$esi+2
            shr eax 2
            Mov D@Result eax
            jmp @Exit
        Else_If B$esi = 0C2 ; ret imm
            movzx eax W$esi+1
            shr eax 2
            Mov D@Result eax
            jmp @Exit
        Else ; no ret, maybe data mistaken as exit sequence?
            Mov edx 0DEADC0DE ; debug (I-was-here) marker
            jmp L1<
        End_If
        jmp @Exit

@WithOutStackFrame:
        ; No stack-frame, decode every instruction to find the ret.

L1:     ; Do not scan behind the end of code, may happen if there is a function
        ; without ret (e.g. Main: [...] Call 'KERNEL32.ExitProcess')

        Mov ebx 0
        On D$esi = 0, jmp @Exit
        Call InstructionDecode esi
        .If W$eax = 're' ; must be re(t)
            If B$esi = 0C3 ; ret
                ; C_Call ?
                Call ReadProcessMem D@RetAddress, D$ProcBuffer, 4
                Mov esi D$ProcBuffer
                cmp W$esi 0C483 | jne @Exit
                movzx eax B$esi+2
                shr eax 2
                Mov D@Result eax
                jmp @Exit
            Else_If B$esi = 0C2 ; ret imm
                movzx eax W$esi+1
                shr eax 2
                Mov D@Result eax
                jmp @Exit
            Else ; ???
                jmp @Exit
            End_If
        .End_If
        add esi D$InstructionLength
        sub ecx D$InstructionLength | jns @WithOutStackFrame
        jmp @Exit

@Exit:

    Call VirtualFree ProcBuffer

    Mov eax D@CSE
    Move D$eax+CSE_NumParams D@Result
    shr ebx 2
    Move D$eax+CSE_NumLocals ebx
EndP
____________________________________________________________________________________________

[StackFragment: B$ ? # 32]

Proc ScanStackForCodePointer:
    Arguments @StackPointer
    Local @StackSize, @Pointer, @Offset
    Uses ebx esi edi

        ; Get size of current stack
        Mov edi D@StackPointer
        Call IsProcessMemory edi
        Mov D@StackSize eax
        Mov ebx 32
        Mov D@Offset 0

        ; Read stack in 32byte fragments
        While D@StackSize >s 0
            On D@StackSize < ebx,
                Mov ebx D@StackSize
            Call 'KERNEL32.ReadProcessMemory' D$PROCESS_INFORMATION@hProcess, edi, StackFragment, ebx, &NULL
            sub D@StackSize ebx
            add edi ebx
            Mov ecx ebx
            shr ecx 2 | jecxz L2> ; Bug fix Betov.
            Mov esi StackFragment
L1:         lodsd
                Mov D@Pointer eax
                ;Call IsProcessCode eax
                Push ecx ; bugfix V2.0b
                    Call CheckReturnAddress eax
                Pop ecx
                cmp eax &TRUE | je L2>
                add D@Offset 4
            loop L1<
        End_While
        Mov D@Pointer 0

L2:     Mov eax D@Pointer
        Mov edx D@Offset
EndP

Proc CheckReturnAddress:
    Arguments @Address
    Local @Result
    Structure @Dummy SizeOf_CSE

    Call IsProcessCode D@Address
    If eax = 1
        pushad
            Call IsReturnAddressInSource D@Address, D@Dummy
            Mov D@Result eax
        popad
        Mov eax D@Result
    End_If
EndP
____________________________________________________________________________________________

; Nothing works for fully close the Debuggee. Something remain attached:

CloseProcess:
    Call 'KERNEL32.GetExitCodeProcess' D$PROCESS_INFORMATION@hProcess, ExitCode
    Call 'KERNEL32.TerminateProcess'  D$PROCESS_INFORMATION@hProcess, D$ExitCode

    Call 'KERNEL32.CloseHandle' D$PROCESS_INFORMATION@hThread       ; should be of
    Call 'KERNEL32.CloseHandle' D$PROCESS_INFORMATION@hProcess      ; no use.
ret
____________________________________________________________________________________________

; TODO
;  * write back real opcodes (into copy!) when reading code sections with dynamic breakpoints inside
;  * reading beyond 2GB in Win9x ? if yes, just return ptr as this section is global

Proc ReadProcessMem:
    Arguments @Source, @Dest, @Size
    Uses ebx esi

    Call 'KERNEL32.ReadProcessMemory' D$PROCESS_INFORMATION@hProcess, D@Source, D@Dest, D@Size, &NULL
    On eax = 0, ExitP

    ; Iterate through breakpoint-table, write back real opcodes
    Mov esi D$BPTable, ecx D$NumBreakpoints
L0: While ecx > 0
        Mov eax D$esi
        .If eax >= D@Source
            sub eax D@Source ; eax = offset into buffer
            If eax < D@Size
                Mov edx D@Dest
                Mov bl B$esi+7
                Mov B$edx+eax bl ; restore original byte
            End_If
        .End_If
        add esi 8
        dec ecx
    EndWhile

    Mov eax 1
EndP
____________________________________________________________________________________________

Proc WriteProcessMem:
    Arguments @Dest @Source @Size

    Call 'KERNEL32.WriteProcessMemory' D$PROCESS_INFORMATION@hProcess, D@Dest, D@Source, D@Size, &NULL
    If eax = &TRUE
      ; should not be needed on x86
        Call 'KERNEL32.FlushInstructionCache' D$PROCESS_INFORMATION@hProcess, D@Dest, D@Size
    End_If
EndP
____________________________________________________________________________________________

[ExitCode: D$ ?]

[NumberOfBytesRead: D$ ?]


;;
SetCodeRVA:
    Move D$DebugBaseOfCode D$CPDI.lpBaseOfImage

    VirtualAlloc DebugHeaderImage 0400 | Mov D$NumberOfBytesRead 0

    Call 'KERNEL32.ReadProcessMemory' D$CPDI.hProcess, D$DebugBaseOfCode,
                                     D$DebugHeaderImage, 0400,  NumberOfBytesRead
    Mov edi D$DebugHeaderImage, al '.', ecx 0400
L0: repne scasb | jne L9>
       cmp D$edi 'text' | jne L0<
           dec edi
           Mov eax D$edi+0C
           add D$DebugBaseOfCode eax
           Move D$DebugCodeSize D$edi+8

L9: VirtualFree D$DebugHeaderImage
ret
;;
____________________________________________________________________________________________

SignalDebugEvent:
    Mov B$IsDebugEvent &TRUE
    Call 'USER32.PostMessageA' D$H.DebugDialog, WM_DEBUGEVENT, 0, 0
    Call 'KERNEL32.WaitForSingleObject' D$UserInputEvent, &INFINITE
    Mov B$IsDebugEvent &FALSE
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

@WATCHPOINTS:

; Watchpoints mean everything in RosAsm that uses the debug registers (DR0-DR7).
____________________________________________________________________________________________

; Mutex to control access to shared WP data structures of debug thread and UI thread.
; To prevent deadlocks, do not make API calls while holding the mutex.

[WPSynchMutex: D$ ?]

; Maps to the debug registers DR0, DR1, DR2, DR3, DR7. All r/w access must be protected
; by WPSynchMutex. These values are written by the UI thread and read by the debug thread.
; Exception is WPChanged which is set to 1 by UI and zeroed by the debugger.

[WPSlot0: D$ ?     ; DR0
 WPSlot1: D$ ?     ; DR1
 WPSlot2: D$ ?     ; DR2
 WPSlot3: D$ ?     ; DR3
 WPControl: D$ ?   ; DR7
 WPChanged: D$ ?]  ; Signal changed data
____________________________________________________________________________________________

; Init data and mutex - called by resource manager thread.

InitWatchpointResources:
    Mov eax 0
    Mov D$WPSlot0 eax
    Mov D$WPSlot1 eax
    Mov D$WPSlot2 eax
    Mov D$WPSlot3 eax
    Mov D$WPControl eax
    Mov D$WPChanged eax
    Call 'KERNEL32.CreateMutexA' 0, 0, 0
    Mov D$WPSynchMutex eax
    If eax = 0
        Call ReportWinError {B$ 'CreateWPMutex' EOS}
        Mov eax 0
    End_If
ret
____________________________________________________________________________________________

; Destroy mutex and clear data fields - called by resource manager thread.

FreeWatchpointResources:
    Call 'KERNEL32.CloseHandle' D$WPSynchMutex
    Mov eax 0
    Mov D$WPSlot0 eax
    Mov D$WPSlot1 eax
    Mov D$WPSlot2 eax
    Mov D$WPSlot3 eax
    Mov D$WPControl eax
    Mov D$WPChanged eax
ret
____________________________________________________________________________________________

; Add watchpoint - called by UI.

Proc SetWatchPoint:
    Arguments @Address, @Size, @ReadWrite

    Call 'KERNEL32.WaitForSingleObject' D$WPSynchMutex, &INFINITE

        Mov eax D@Address
        Mov D$WPSlot0 eax
        and D$WPControl 0_FFF0_FFFF
        or  D$WPControl 1 ; activate DR0
        Mov eax D@ReadWrite
        and eax 0011
        shl eax 16
        or  D$WPControl eax
        If eax <> 0
            ; 00 1-byte length
            ; 01 2-byte length
            ; 10 Undefined
            ; 11 4-byte length
            Mov eax D@Size | dec eax
            shl eax 18
            or  D$WPControl eax
        End_If

        Mov D$WPChanged 1

    Call 'KERNEL32.ReleaseMutex' D$WPSynchMutex
EndP
____________________________________________________________________________________________

; Delete watchpoint - called by UI.

Proc DeleteWatchPoint:
    Call 'KERNEL32.WaitForSingleObject' D$WPSynchMutex, &INFINITE

        and D$WPControl 0_FFF0_FFFE
        Mov D$WPSlot0 0

        Mov D$WPChanged 1

    Call 'KERNEL32.ReleaseMutex' D$WPSynchMutex
EndP
____________________________________________________________________________________________

; Take over any changed values into thread context structure - called by debugger.

Proc TransferWatchpoints:
    Call 'KERNEL32.WaitForSingleObject' D$WPSynchMutex, &INFINITE

        Move D$CONTEXT@iDr0 D$WPSlot0
        Move D$CONTEXT@iDr1 D$WPSlot1
        Move D$CONTEXT@iDr2 D$WPSlot2
        Move D$CONTEXT@iDr3 D$WPSlot3
        Move D$CONTEXT@iDr7 D$WPControl

        Mov D$WPChanged 0

    Call 'KERNEL32.ReleaseMutex' D$WPSynchMutex
EndP
____________________________________________________________________________________________

; Test if address is watched - called by UI.
; No need to use the mutual exclusion here as the debug thread doesn't write to the fields.

Proc IsWatchPoint:
    Arguments @Address

    Mov eax D@Address
    If eax = D$WPSlot0
        Mov eax D$WPControl
        shr eax 16
        and eax 0011
    Else
        Mov eax 0
    End_If
EndP
____________________________________________________________________________________________

; Test if a watched data access has taken place - called by debugger.

Proc EncounterWatchPoint:

    test D$CONTEXT@iDr6 01 ZERO L9>

    Mov D$DebugEventType DET_WP
    Move D$WatchedAddress D$CONTEXT@iDr0
    dec D$SourcePosCodeAddress

  ; clear status
    Mov D$CONTEXT@iDr6 0
L9:
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; BREAKPOINTS

; Every breakpoint is saved in the breakpoint table. An entry has the following structure:
; DWORD Address
; BYTE  Type (see type flags)
; BYTE  State (see state flags)
; BYTE  Reserved (can be used for bp-group ids)
; BYTE  Overwritten byte

[BPTable: D$ ?
 NumBreakpoints: D$ ?]

; Type flags
[BP_STATIC 0 BP_STATIC2BYTE 01 BP_DYNAMIC 02 BP_ONESHOT 04]
; State flags
[BP_ENABLED 1 BP_DISABLED 0 BP_ISPENDING 2]

; BPPending has the address of a dynamic breakpoint that is currently deactivated to
; execute the real code that was overwritten by the bp-op.
; Otherwise it is zero- indicating that no BP must be written back to process mem ATM.
[BPPending: D$ ?]

CreateBPTable:

    Call VirtualFree BPTable

    Call VirtualAlloc BPTable,
                      01_0000 ; 64k table

    Mov D$NumBreakpoints 0

    Mov D$BPPending 0

ret

DestroyBPTable:

    Mov D$BPPending 0

    Mov D$NumBreakpoints 0

    Call VirtualFree BPTable

ret

[RunAfterWriteBack: D$ ?]
____________________________________________________________________________________________

; Add breakpoint to table and, if enabled, to process memory.

Proc AddProcessBreakpoint:
    Arguments @Address, @Type, @State, @GroupID
    Uses edi

        Mov edi D$BPTable, ecx D$NumBreakpoints
        lea edi D$edi+ecx*8

        Mov eax D@Address   | stosd
        Mov al B@Type       | stosb
        Mov al B@State      | stosb
        Mov al B@GroupID    | stosb

        .If B@Type <> BP_STATIC
            Call ReadProcessMem D@Address, edi, 1
            If B@State = BP_ENABLED
                Call WriteProcessMem D@Address, BreakpointOp, 1
            End_If
        .Else
            If B@State = BP_DISABLED
                Mov B$ByteBuf 090
                Call WriteProcessMem D@Address, ByteBuf, 1
            End_If
        .End_If
        inc D$NumBreakpoints

        ;Call 'KERNEL32.OutputDebugStringA' {B$ 'BP manager: BP added' EOS}
EndP
____________________________________________________________________________________________

; Delete breakpoint from table and from process memory.

Proc DeleteProcessBreakpoint:
    Arguments @Address
    Uses esi

        On D$NumBreakpoints = 0, jmp L9>>

        ; save last entry on stack, search for breakpoint in table, do the cleanup
        ; work (write back process memory), and overwrite entry with last one from stack
        Mov esi D$BPTable, ecx D$NumBreakpoints, eax D@Address
        dec ecx
        Push D$esi+ecx*8, D$esi+ecx*8+4
            While D$esi <> eax
                add esi 8
                dec ecx | js L9>
            EndWhile

            .If B$esi+5 = BP_ENABLED
                If B$esi+4 <> BP_STATIC
                    Mov al B$esi+7
                Else
                    Mov al 090
                End_If
                Mov B$ByteBuf al
                Call WriteProcessMem D@Address, ByteBuf, 1

            .Else_If B$esi+5 = BP_ISPENDING
                ; fix: if breakpoint is currently deactivated and waits for write-back
                ; the write-back command must be killed with the breakpoint
                Mov D$BPPending 0
            .End_If

        Pop D$esi+4, D$esi
        dec D$NumBreakpoints
        ;Call 'KERNEL32.OutputDebugStringA' {B$ 'BP manager: BP deleted' EOS}
        ExitP

L9:     Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'Tried to delete non-existing breakpoint!' EOS},
                                  {B$ 'Debugger error' EOS}, &MB_ICONERROR
EndP
____________________________________________________________________________________________

; When [Hold On Breakpoint] is deactivated we disable all known breakpoints and delete
; all oneshot breakpoints.

Proc DisableProcessBreakpoints:
    Uses esi, edi

        ; Iterate through breakpoint-table, delete oneshot and disable all other bp's.
        Mov esi D$BPTable, edi D$NumBreakpoints
L0:     While edi > 0
            If B$esi+4 = BP_ONESHOT
                Call DeleteProcessBreakpoint D$esi
                dec edi
                jmp L0<
            Else_If B$esi+4 = BP_DYNAMIC
                Mov B$esi+5 BP_DISABLED
                lea eax D$esi+7
                Call WriteProcessMem D$esi, eax, 1
            Else_If B$esi+4 = BP_STATIC
                Mov B$esi+5 BP_DISABLED
                Mov B$ByteBuf 090
                Call WriteProcessMem D$esi, ByteBuf, 1
            End_If
            add esi 8
            dec edi
        EndWhile
        Mov B$BreakpointsEnabled &FALSE
EndP
____________________________________________________________________________________________

; When [Hold On Breakpoint] is reactivated we enable all known breakpoints

Proc EnableProcessBreakpoints:
    Uses esi, ebx

        ; Iterate through breakpoint-table, write breakpoint ops to process memory.
        Mov esi D$BPTable, ebx D$NumBreakpoints ; bugfix V2.0b
L0:     While ebx > 0
            Call WriteProcessMem D$esi, BreakpointOp, 1
            Mov B$esi+5 BP_ENABLED
            add esi 8
            dec ebx
        EndWhile
        Mov B$BreakpointsEnabled &TRUE
EndP
____________________________________________________________________________________________

; Deal with encountered breakpoints. Adjusts EIP according to breakpoint type.

Proc EncounterBreakpoint:
    Uses esi, ebx

        ; Search breakpoint in table
        Mov esi D$BPTable, ecx D$NumBreakpoints
        Mov ebx D$CONTEXT@regEip | dec ebx
        On ecx = 0, jmp L1>>
        While D$esi <> ebx
            add esi 8
            dec ecx | jz L1>>
        EndWhile

        ; One shot breakpoints are set by step-over, step-out and pause. The user will
        ; receive them as normal stepping (well...), so they are deleted as soon as they are hit.
        ; They can be grouped (for pause), so that if one is hit all others in the group
        ; are deleted with it.
        .If B$esi+4 = BP_ONESHOT
            lea eax D$esi+7
            Call WriteProcessMem ebx, eax, 1
            If B$esi+6 <> 0
                movzx eax B$esi+6
                Call KillBreakpointGroup eax
            Else
                Call DeleteProcessBreakpoint ebx
            End_If
            dec D$CONTEXT@regEIP, D$SourcePosCodeAddress

        ; Dynamic breakpoints are user-defined which appear as bp-marks in the source
        ; editor. When encountered the original operation must be restored, executed
        ; (single-stepped), and written back when the next SINGLE_STEP Debug event occurs.
        .Else_If B$esi+4 = BP_DYNAMIC
            lea eax D$esi+7
            Call WriteProcessMem ebx, eax, 1
            Mov B$esi+5 BP_ISPENDING
            If B$HoldOnBreakpoints = &TRUE
                Mov D$BPPending esi
            End_If
            ; Weird case when a 'int 3' is marked with a breakpoint. It would loop into infinity
            ; so we just skip over it.
            On B$esi+7 <> 0CC,
                dec D$CONTEXT@regEIP, D$SourcePosCodeAddress

        ; Static breakpoints need not to be dealt with. Execution can continue
        .End_If

        ExitP

L1:     ; New static breakpoint encountered.
        Call AddProcessBreakpoint ebx, BP_STATIC, D$HoldOnBreakpoints, 0
EndP
____________________________________________________________________________________________

Proc KillBreakpointGroup:
    Arguments @GroupID
    Uses esi, edi, ebx

        ; Search breakpoint with given group-id in table. If one is found, delete it.
        Mov esi D$BPTable, edi D$NumBreakpoints, ebx D@GroupID
L0:     While edi > 0
            If B$esi+6 = bl
                Call DeleteProcessBreakpoint D$esi
                dec edi
                jmp L0<
            End_If
            add esi 8
            dec edi
        EndWhile
EndP
____________________________________________________________________________________________

; Interrupts the execution of a thread by setting a breakpoint at the location pointed at by
; the instruction pointer. If it is outside of process code, the stack is scanned for a
; valid code pointer.

Proc HaltThread:

    Arguments @H.Thread

        Call 'KERNEL32.SuspendThread' D@H.Thread
        Mov D$CONTEXT@ContextFlags MY_CONTEXT_FULL
        Call 'KERNEL32.GetThreadContext' D@H.Thread, Context
        Call IsProcessCode D$CONTEXT@regEip
        .If eax = &TRUE
            Call AddProcessBreakpoint D$CONTEXT@regEip, BP_ONESHOT, BP_ENABLED, 0
        .Else
            Call ScanStackForCodePointer D$CONTEXT@REG_ESP
            If eax <> 0
                Call AddProcessBreakpoint eax, BP_ONESHOT, BP_ENABLED, 0
            End_If
        .End_If

        Call 'KERNEL32.ResumeThread' D@H.Thread

EndP
____________________________________________________________________________________________

; SYNCHRONIZE BREAKPOINTS WITH SOURCE EDITOR

[BPAnteroom: D$ ?
 BPSyncMutex: D$ ?]

CreateBPAnteroom:
    Call 'KERNEL32.CreateMutexA' 0, 0, 0
    Mov D$BPSyncMutex eax

    Call VirtualAlloc BPAnteroom,
                      01000

    ;Call 'KERNEL32.OutputDebugStringA' {B$ 'BP synch: Created BP synch objects' EOS}
ret

DestroyBPAnteroom:

    Call VirtualFree BPAnteroom

    Call 'KERNEL32.CloseHandle' D$BPSyncMutex

    ;Call 'KERNEL32.OutputDebugStringA' {B$ 'BP synch: Destroyed BP synch objects' EOS}
ret

; Copy initial set of breakpoints from the "OnTable" to the Anteroom. This proc is
; called before the debugger thread starts so we don't need to sync with the mutex.

InitialFillBPAnteroom:
    On D$TABLE.BreakPointsOn = &NULL ret
    ;Call 'KERNEL32.WaitForSingleObject' D$BPSyncMutex, &INFINITE
    Mov esi D$TABLE.BreakPointsOn
    Mov edi D$BPAnteroom
    While D$esi <> 0
        movsd
        Mov eax &TRUE
        stosd
        Call 'KERNEL32.OutputDebugStringA' {B$ 'BP synch: BP set' EOS}
    EndWhile
    ;Call 'KERNEL32.ReleaseMutex' D$BPSyncMutex
    ;Call 'KERNEL32.OutputDebugStringA' {B$ 'BP synch: Initial fill complete' EOS}
ret

; FILL Anteroom: This proc is called by the UI thread (RosAsm's mainthread)

Proc AddBPToAnteroom:
    Arguments @Address @Set

        On edi = 0, ExitP

        Call 'KERNEL32.WaitForSingleObject' D$BPSyncMutex, &INFINITE
        Mov edi D$BPAnteroom
        While D$edi <> 0
            add edi 8
        EndWhile
        Move D$edi D@Address
        Move D$edi+4 D@Set
        Call 'KERNEL32.ReleaseMutex' D$BPSyncMutex

        ;Call 'KERNEL32.OutputDebugStringA' {B$ 'BP synch: BP set' EOS}
EndP

; CLEAR Anteroom: This proc is called by the debugger thread

Proc ClearBPAnteroom:
    Call 'KERNEL32.WaitForSingleObject' D$BPSyncMutex, &INFINITE
    Mov edi D$BPAnteroom
    While D$edi <> 0
        Call GetcodeBreakPointPosFromSourcePointer D$edi
        If D$edi+4 = &TRUE ; add breakpoint
            Call AddProcessBreakpoint eax, BP_DYNAMIC, D$HoldOnBreakpoints, 0
        Else
            Call DeleteProcessBreakpoint eax
        End_If
        Mov D$edi 0, D$edi+4 0
        add edi 8
    EndWhile
    Call 'KERNEL32.ReleaseMutex' D$BPSyncMutex

    ;Call 'KERNEL32.OutputDebugStringA' {B$ 'BP synch: Anteroom cleared' EOS}
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; ADDRESS SPACE ROUTINES
____________________________________________________________________________________________
____________________________________________________________________________________________

[PageOffsetMask     PAGE_SIZE-1]
[PageBaseMask       0_FFFF_F000]

[AddressLowerBound:  0_1000]
[AddressUpperBound:  0_7FFF_0000]

[MemoryInformation:
 @BaseAddress: D$ ?
 @AllocationBase: D$ ?
 @AllocationProtect: D$ ?
 @RegionSize: D$ ?
 @State: D$ ?
 @Protect: D$ ?
 @Type: D$ ?]

; Wrap routine for VirtualQueryEx
;   Parameter
;       Virtual Address
;   Output
;       EAX : 1=commited 0=free -1=error
;       ECX : region size

Proc VirtualQuery:
    Arguments @Address

        Mov eax D@Address
        If eax >= D$AddressUpperBound
            Mov eax &FALSE

EndP

        End_If

        Call 'KERNEL32.VirtualQueryEx' D$PROCESS_INFORMATION@hProcess, D@Address, MemoryInformation, 28
        If eax <> 28
            Mov eax 0-1
            ;Call ReportWinError {B$ 'VirtualQueryEx reported error:' EOS}
            ExitP
        End_If

        ; There is a bug in the implementation of VirtualQuery under WinNT.
        ; Jeffrey Richter has written a workaround (see VMMap in his book) which I
        ; implemented here.
        test D$MemoryInformation@AllocationBase 0FFF ZERO L0>
        inc D$MemoryInformation@AllocationBase

L0:     test D$MemoryInformation@RegionSize 0FFF ZERO L0>
        inc D$MemoryInformation@RegionSize

L0:     .If D$MemoryInformation@State <> &MEM_FREE
            If D$MemoryInformation@AllocationProtect = 0
                Mov D$MemoryInformation@AllocationProtect &PAGE_READONLY
            End_If
        .End_If

        Mov ecx D$MemoryInformation@RegionSize

        If D$MemoryInformation@State = &MEM_COMMIT
            Mov eax &TRUE
        Else
            Mov eax &FALSE
        End_If
EndP
____________________________________________________________________________________________

; Determines if the address points to a commited page in the debuggees address space.
; Returns the size of the block starting at the given address in eax.

Proc IsProcessMemory:
    Arguments @Address
    Local @Offset

        ; Offset from start of Page
        Mov eax D@Address
        and eax PageOffsetMask
        Mov D@Offset eax
        ; Page address
        Mov edx D@Address
        sub edx eax
        ; Query information for corresponding page:
        ;  * if eax is 1 the page was commited
        ;  * ecx contains the number of commited bytes from the page address
        Call VirtualQuery edx
        If eax = 1
            Mov eax ecx
            sub eax D@Offset
        Else
            Mov eax 0
        End_If
EndP
____________________________________________________________________________________________

Proc FindNextPage:
    Arguments @Address
    Uses ebx

        ; align address on page boundary
        Mov ebx D@Address
        and ebx PageBaseMask
        add ebx PAGE_SIZE
        If ebx >= D$AddressUpperBound
            Mov eax 0
            ExitP
        End_If
        ; advance the regions until a commited page is found or the upper bound is met
        Call VirtualQuery ebx
        While eax = 0
            add ebx ecx
            If ebx >= D$AddressUpperBound
                Mov eax 0
                ExitP
            End_If
            Call VirtualQuery ebx
            If eax = 0-1
                xor eax eax
                ExitP
            End_If
        EndWhile
        If eax = 0-1
            xor eax eax
        Else
            Mov eax ebx
        End_If
EndP
____________________________________________________________________________________________

Proc FindPrevPage:
    Arguments @Address
    Uses ebx

        ; align address on page boundary
        Mov ebx D@Address
        and ebx PageBaseMask
        sub ebx PAGE_SIZE
        If ebx < D$AddressLowerBound
            Mov eax 0
            ExitP
        End_If
        ; advance the regions until a commited page is found or the upper bound is met
        Call VirtualQuery ebx
        While eax = 0
            sub ebx PAGE_SIZE
            If ebx < D$AddressLowerBound
                Mov eax 0
                ExitP
            End_If
            Call VirtualQuery ebx
        EndWhile
        If eax = 0-1
            xor eax eax
        Else
            Mov eax ebx
        End_If
EndP
____________________________________________________________________________________________

Proc IsProcessCode:
    Arguments @Address

        Mov eax &FALSE
        Mov edx D$DebugBaseOfCode
        If D@Address >= edx
            add edx D$DebugCodeSize
            On D@Address < edx, Mov eax &TRUE
        End_If
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; Source Editor integration
____________________________________________________________________________________________
____________________________________________________________________________________________

;[ApiWarningDone: D$ ?]

[SourcePos: D$ ?]

;;
  Two parallel Tables:
  
* 'IpTable': Each Record is the Displacement for the Origin of Code (for each encoded
  Instruction. In case of Labels (That _are_ parsed by the Encoder, the Label and the
  relative Instruction are both recorded, with the same Displacement).
  
* 'StatementsTable': Each Record is a Pointer to Source Statement. For example, in cases
  of
  
  > Mov eax 1, ebx 2, ecx 3
  
  there will be only one Pointer, in 'StatementsTable', that is a Pointer to this 'm'
  Char inside the user Source.
;;

[SourcePosCodeAddress: D$ ?]

Proc SourceDebugPos:
    Arguments @CodeAddress

    Call RestoreRealSource

    Mov ebx D@CodeAddress | sub ebx D$DebugBaseOfCode

    Mov esi D$IpTable, ecx D$IpTablePtr | sub ecx esi | shr ecx 2

    Move D$StatementsPtr D$StatementsTable
;;
  Cases of critical error: C_regEip is not update (eip yet pointing to the faultive
  instruction).
  
  Cases of Int 3 and Stepping: The instruction is executed and C_regEip is updated
  (pointing to the next Instruction).
;;
    Call ActualDebugPos

  ; eax = 'StatementsPtr' >>> Pointing to a Source Pos Record in 'StatementsTable'.
    Mov eax D$eax

    Mov D$SourcePos eax ; <<< for stepping

    .If eax <> 0
        ;Mov B$ApiWarningDone &FALSE
L5:     Call SetEndOfErrorText | Call SetDebuggeeText | Call AskForRedraw

    .Else_If D$E.ExceptionCode <> &EXCEPTION_SINGLE_STEP
      ; Error outside > Point to end of Source:
        sub D$StatementsPtr 4 | jmp L5<

    .End_If

    Call SetPartialEditionFromPos
EndP


ActualDebugPos:
L0: lodsd

    .If eax = ebx
      ; Cases of Labels in the 'IpTable':
L1:     While D$esi = eax | add esi 4 | add D$StatementsPtr 4 | End_While
        jmp L2>

    .Else_If eax > ebx
        sub D$StatementsPtr 4 | jmp L2>

    .End_If

    add D$StatementsPtr 4 | loop L0<

L2: Mov eax D$StatementsPtr
    If eax < D$StatementsTable
        Mov eax D$StatementsTable | add D$StatementsPtr 4
    End_If
ret
____________________________________________________________________________________________

[CodeBuf: B$ ? # 32]

NextInstructionDecode:
    Call 'KERNEL32.ReadProcessMemory' D$PROCESS_INFORMATION@hProcess, D$CONTEXT@regEip, CodeBuf,
                                      32, NumberOfBytesRead
    Call InstructionDecode CodeBuf
ret
____________________________________________________________________________________________

[InstructionLength: D$ ?]
[DecodedInstruction: B$ ? # 50]
[NextInstructionPtr: D$ ?]

Proc InstructionDecode:
    Arguments @CodeBuffer

    pushad

    ; Clear buffer, set disassembler flags for simple decode and feed the disassembler
    ; with the code in the codebuffer.

    Mov edi DecodedInstruction, ecx 50, eax 0
    rep stosb

    Mov B$SimpleScan &TRUE, D$LastCodeRef 0
    Mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
    Mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
    Mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE
    Mov B$WithCommentedHexa &FALSE

    Mov esi D@CodeBuffer, edi DecodedInstruction
    add edi 10 ; disassembler sometimes writes in front of edi, reserve 10 guard bytes
L0: movzx eax B$esi | inc esi | Call D$DisOp1+eax*4
    On B$DisFlag = DISDONE, jmp L0<
    Mov D$edi 0
    sub esi D@CodeBuffer | Mov D$InstructionLength esi
    Mov B$SimpleScan &FALSE

  ; Dirty method to find the real beginning of the instruction string:
    .If D$LastCodeRef <> 0
        If B$edi-1 = '$'
            Mov eax D$LastCodeRef | Call WriteEax
        End_If
    .End_If

    Mov edi DecodedInstruction, ecx 50, eax 0
    repe scasb | dec edi
L1: If B$edi = SPC
        inc edi | jmp L1<
    Else_If B$edi = '|'
        inc edi | jmp L1<
    End_If
    Mov D$NextInstructionPtr edi

    popad

    Mov eax D$NextInstructionPtr
EndP
____________________________________________________________________________________________

IsMultiStepInstruction:
    Mov esi D$NextInstructionPtr
    lodsd
    If eax = 'Call'
        Mov eax 1 | ret
    End_If
    and eax 0FF_FFFF
    If eax = 'rep'
        Mov eax 1 | ret
    End_If
    Mov eax 0
ret
____________________________________________________________________________________________

[CPUName: B$ ? # 48]
[CPUVendor: B$ ? # 16]
[CPUFlags: D$ ?
 CPUFlagsEx: D$ ?]

[FLAG_FPU 1 FLAG_CMOV 0_8000 FLAG_MMX 080_0000 FLAG_SSE 0200_0000 FLAG_SSE2 0400_0000]
[FLAG_EX_MMX 040_0000 FLAG_EX_3DNOW 0_4000_0000 FLAG_EX_3DNOWEX 0_8000_0000]

Proc TestCpuFeatures:
    Local @MaxFunc @MaxExFunc

    Mov D$CPUFlags 0, D$CPUFlagsEx 0, B$CPUName 0

    ; Check if CPUID instruction is available
    pushfd | Pop eax
    Mov ebx eax
    xor eax 0200000
    Push eax | popfd
    pushfd | Pop eax

    .If eax <> ebx
        Mov eax 0
        cpuid
        Mov D@MaxFunc eax
        Mov D$CPUVendor ebx, D$CPUVendor+4 edx, D$CPUVendor+8 ecx, D$CPUVendor+12 0
        ; Get general flags
        If D@MaxFunc >= 1
            Mov eax 1
            cpuid
            Mov D$CPUFlags edx
        End_If

        Mov eax 0_8000_0000
        cpuid
        Mov D@MaxExFunc eax
        ; Extended flags
        If D@MaxExFunc >= 0_8000_0001
            Mov eax 0_8000_0001
            cpuid
            Mov D$CPUFlagsEx edx
        End_If
        ; CPU name
        If D@MaxExFunc >= 0_8000_0004
            Mov eax 0_8000_0002
            cpuid
            Mov D$CPUName eax, D$CPUName+4 ebx, D$CPUName+8 ecx, D$CPUName+12 edx
            Mov eax 0_8000_0003
            cpuid
            Mov D$CPUName+16 eax, D$CPUName+20 ebx, D$CPUName+24 ecx, D$CPUName+28 edx
            Mov eax 0_8000_0004
            cpuid
            Mov D$CPUName+32 eax, D$CPUName+36 ebx, D$CPUName+40 ecx, D$CPUName+44 edx
        End_If
    .End_If
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Exception       ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
    General exception handler.
    
    October 2004 - Ludwig Haehne - wkx@gmx.li
    
    Reports a description of the exception that occurred, writes a crash.log file
    and tries to save the source before RosAsm is terminated by the system. 
    
    TODO Create a crash dump (data, stack, context) that can be loaded on a different 
    machine to find the problem.
;;
____________________________________________________________________________________________

Proc FinalExceptionHandler:
    Arguments @ExceptionInfo
    Uses ebx esi edi

  ; Save whole source
    On D$FL.RealSourceRestored = &FALSE Call RestoreRealSource
    Mov B$WeAreSavingPart &FALSE | Call SaveSource

    Mov eax D@ExceptionInfo | Call GetExceptionInfo D$eax
    Mov eax D@ExceptionInfo | Call WriteCrashLog D$eax D$eax+4

    Call 'USER32.MessageBoxA' D$H.MainWindow, ExceptionMessage,
        {B$ 'RosAsm crashed' EOS}, &MB_OK+&MB_ICONEXCLAMATION

    Call 'KERNEL32.SetErrorMode' &SEM_NOGPFAULTERRORBOX

    Mov eax &EXCEPTION_CONTINUE_SEARCH
EndP
____________________________________________________________________________________________


[ExceptionMessage:
"An exception occurred inside RosAsm. It must terminate now.

                    YOUR WORK IS NOT LOST!
                
Your source has been saved at the path of your application.
To continue working restart RosAsm, open your application
and replace the source.

Please post a bug report describing how to reproduce this
problem along with the crash.log (in the applications folder)
at RosAsm board.

Thank you and sorry for the inconvenience.

" ExceptionInfo: B$ "Exception occurred at address " ExceptionAddress: B$ "########.
" ExceptionDesc: B$ 0 # &MAX_PATH]

[Exception_AV: B$ 'Access Violation! Attempt to ' AV_ReadWrite: B$ '######### address ' AV_Address: B$ '########.' EOS]
[Exception_other: B$ 'Unknown exception. Code ' Exception_Code: B$ '########' EOS]

Proc GetExceptionInfo:
    Arguments @ExceptionRecord

    Mov ebx D@ExceptionRecord

    Mov edi ExceptionAddress
    DwordToHex D$ebx+12 ; Address

    Mov eax D$ebx ; ExceptionCode

    .If eax = &EXCEPTION_ACCESS_VIOLATION
        Mov eax D$ebx+20 ; read/write
        If eax = 0
            Mov D$AV_ReadWrite 'read', D$AV_ReadWrite+4 ' fro', B$AV_ReadWrite+8 'm'
        Else
            Mov D$AV_ReadWrite 'writ', D$AV_ReadWrite+4 'e at', B$AV_ReadWrite+8 SPC
        End_If
        Mov edi AV_Address
        DwordToHex D$ebx+24 ; inaccessible address
        Mov esi Exception_AV
    .Else
        Mov edi ExceptionCode
        DwordToHex D$ebx ; exc. code
        Mov esi Exception_other
    .End_If

    Mov edi ExceptionDesc
    Do
        movsb
    Loop_until B$esi-1 = 0
EndP
____________________________________________________________________________________________

; Write a log-file which is really helpful.
;   * dump exception information (exc code, inaccessible address, access type)
;   * rosasm version
;   * OS information (NT/9x)
;   * register contents

[NewLineSeq: W$ 0A0D]

Proc EmitNewLine:
    Arguments @File

    Call 'KERNEL32.WriteFile' D@File, NewLineSeq, 2, BytesTransfered, 0
EndP

[RegContent: B$ 'Exx=12345678' 0D 0A] ; EOS

Proc WriteCrashLog:

    Arguments @ExceptionRecord @Context

    Local @H.File

    Call 'KERNEL32.CreateFileA' {B$ 'crash.log' EOS}, &GENERIC_WRITE, &FILE_SHARE_READ, 0,
        &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0
    Mov D@H.File eax

    .If D@H.File <> &INVALID_HANDLE_VALUE

      ; Output RosAsm version
        Mov edi STR.A.ApplicationName | Call StrLen
        Mov edx STR.A.ApplicationName | add edx 2 | sub eax 2
        Call 'KERNEL32.WriteFile' D@H.File, edx, eax, BytesTransfered, 0
        Call EmitNewLine D@H.File

      ; Output Windows version
        Call GetWindowsVersionString
        Mov edi WindowsVersion | Call StrLen
        Call 'KERNEL32.WriteFile' D@H.File, WindowsVersion, eax, BytesTransfered, 0
        Call EmitNewLine D@H.File
        Call EmitNewLine D@H.File

      ; Output exception info
        Mov edi ExceptionInfo | Call StrLen
        Call 'KERNEL32.WriteFile' D@H.File, ExceptionInfo, eax, BytesTransfered, 0
        Call EmitNewLine D@H.File
        Call EmitNewLine D@H.File

      ; Output reg contents
        Mov ebx D@Context

        Mov edi RegContent | Mov W$edi+1 'AX' | add edi 4
        DwordToHex D$ebx+0B0
        Call 'KERNEL32.WriteFile' D@H.File, RegContent, 14, BytesTransfered, 0

        Mov edi RegContent | Mov W$edi+1 'BX' | add edi 4
        DwordToHex D$ebx+0A4
        Call 'KERNEL32.WriteFile' D@H.File, RegContent, 14, BytesTransfered, 0

        Mov edi RegContent | Mov W$edi+1 'CX' | add edi 4
        DwordToHex D$ebx+0AC
        Call 'KERNEL32.WriteFile' D@H.File, RegContent, 14, BytesTransfered, 0

        Mov edi RegContent | Mov W$edi+1 'DX' | add edi 4
        DwordToHex D$ebx+0A8
        Call 'KERNEL32.WriteFile' D@H.File, RegContent, 14, BytesTransfered, 0

        Mov edi RegContent | Mov W$edi+1 'SI' | add edi 4
        DwordToHex D$ebx+0A0
        Call 'KERNEL32.WriteFile' D@H.File, RegContent, 14, BytesTransfered, 0

        Mov edi RegContent | Mov W$edi+1 'DI' | add edi 4
        DwordToHex D$ebx+09C
        Call 'KERNEL32.WriteFile' D@H.File, RegContent, 14, BytesTransfered, 0

        Mov edi RegContent | Mov W$edi+1 'BP' | add edi 4
        DwordToHex D$ebx+0B4
        Call 'KERNEL32.WriteFile' D@H.File, RegContent, 14, BytesTransfered, 0

        Mov edi RegContent | Mov W$edi+1 'SP' | add edi 4
        DwordToHex D$ebx+0C4
        Call 'KERNEL32.WriteFile' D@H.File, RegContent, 14, BytesTransfered, 0

        Call 'KERNEL32.CloseHandle' D@H.File
    .End_If

EndP
____________________________________________________________________________________________

; Get windows version information. Original C code from MSDN converted to RosAsm.

[WindowsVersion: B$ ? # 256]

[OSVersionInfo:
 @Size: D$ ?
 @MajorVersion: D$ ?
 @MinorVersion: D$ ?
 @BuildNumber: D$ ?
 @PlatformId: D$ ?
 @CSDVersion: B$ ? # 128
 @ServicePackMajor: W$ ?
 @ServicePackMinor: W$ ?
 @SuiteMask: W$ ?
 @ProductType: B$ ?
 @Reserved: B$ ?]

[OSVI_SIZE 148 OSVI_EX_SIZE 156]

Win2003ServerProductType:
    Mov ax W$OSVersionInfo@SuiteMask
    test ax &VER_SUITE_DATACENTER ZERO L0>
        Mov esi {B$ 'Datacenter Edition' EOS} | ret
L0: test ax &VER_SUITE_ENTERPRISE ZERO L0>
        Mov esi {B$ 'Enterprise Edition' EOS} | ret
L0: test ax 0400 ZERO L0> ;&VER_SUITE_BLADE | jz L0>
        Mov esi {B$ 'Web Edition' EOS} | ret
L0: Mov esi {B$ 'Standard Edition' EOS}
ret

Win2000ServerProductType:
    test ax &VER_SUITE_DATACENTER ZERO L0>
        Mov esi {B$ 'Datacenter Server' EOS} | ret
L0: test ax &VER_SUITE_ENTERPRISE ZERO L0>
        Mov esi {B$ 'Advanced Server' EOS} | ret
L0: Mov esi {B$ 'Server' EOS}
ret

Proc TestWinNTSP6a:
    Local @Key

    .If D$OSVersionInfo@MajorVersion = 4
        lea eax D@Key
        Call 'ADVAPI32.RegOpenKeyExA' &HKEY_LOCAL_MACHINE,
            {B$ 'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Hotfix\Q246009' EOS},
            0, &KEY_QUERY_VALUE, eax

        If eax = &ERROR_SUCCESS
            Mov al 'a' | stosb
        End_If

        Call 'ADVAPI32.RegCloseKey' D@Key
    .End_If
EndP

[WinNTProductType: B$ ? # 80]
[WinNTPTLen: D$ ?]

Proc GetWindowsProductInfo:
    Local @Key

    Mov esi 0

    Mov D$OSVersionInfo@Size OSVI_EX_SIZE
    Call 'KERNEL32.GetVersionExA' OSVersionInfo
    ...If eax = 1

      ; workstation
        ..If W$OsVersionInfo@ProductType = &VER_NT_WORKSTATION
            .If D$OSVersionInfo@MajorVersion = 4
                Mov esi {B$ 'Workstation 4.0' EOS}
            .Else
                Mov ax W$OSVersionInfo@SuiteMask
                and ax 0200 ;&VER_SUITE_PERSONAL
                If ax <> 0
                    Mov esi {B$ 'Home Edition' EOS}
                Else
                    Mov esi {B$ 'Professional' EOS}
                End_If
            .End_If

       ; server
         ..Else
            .If D$OSVersionInfo@MajorVersion = 5
                If D$OSVersionInfo@MinorVersion = 2
                    Call Win2003ServerProductType
                Else_If D$OSVersionInfo@MinorVersion = 0
                    Call Win2000ServerProductType
                End_If
            .Else
                Mov ax W$OSVersionInfo@SuiteMask
                and ax &VER_SUITE_ENTERPRISE
                If ax <> 0
                    Mov esi {B$ 'Server 4.0 Enterprise' EOS}
                Else
                    Mov esi {B$ 'Server 4.0' EOS}
                End_If
            .End_If
         ..End_If

    ...Else

        lea eax D@Key
        Call 'ADVAPI32.RegOpenKeyExA' &HKEY_LOCAL_MACHINE,
            {B$ 'SYSTEM\CurrentControlSet\Control\ProductOptions' EOS},
            0, &KEY_QUERY_VALUE, eax

        On eax <> &ERROR_SUCCESS, ExitP

        Mov D$WinNTPTLen 80
        Call 'ADVAPI32.RegQueryValueExA' D@Key, {B$ 'ProductType' EOS},
            0, 0, WinNTProductType, WinNTPTLen

        On eax <> &ERROR_SUCCESS, ExitP
        On D$WinNTPTLen > 80, ExitP

        Call 'ADVAPI32.RegCloseKey' D@Key

        If D$WinNTProductType = 'WINN'
            Mov esi {B$ 'Workstation' EOS}
        Else_If D$WinNTProductType = 'LANM'
            Mov esi {B$ 'Server' EOS}
        Else_If D$WinNTProductType = 'SERV'
            Mov esi {B$ 'Advanced Server' EOS}
        End_If

    ...End_If
EndP

IntToStr:
    Mov dl 0FF | Push edx                       ; Push stack end mark
    Mov ecx 10
L0: Mov edx 0
    div ecx | Push edx | cmp eax 0 | ja L0<     ; Push remainders
L2: Pop eax                                     ; Retrieve Backward
    cmp al 0FF | je L9>                         ; Over?
    add al '0' | stosb | jmp L2<             ; Write
L9: ret

Proc GetWindowsVersionString:

    Mov D$OSVersionInfo@Size OSVI_SIZE
    Call 'KERNEL32.GetVersionExA' OSVersionInfo

    Mov edi WindowsVersion

    ..If D$OSVersionInfo@PlatformId = &VER_PLATFORM_WIN32_NT

      ; Major versions
        .If D$OSVersionInfo@MajorVersion = 5
            If D$OSVersionInfo@MinorVersion = 2
                Mov esi {B$ 'MS Windows Server 2003' EOS}
            Else_If D$OSVersionInfo@MinorVersion = 1
                Mov esi {B$ 'MS Windows XP' EOS}
            Else_If D$OSVersionInfo@MinorVersion = 0
                Mov esi {B$ 'MS Windows 2000' EOS}
            End_If
        .Else_If D$OSVersionInfo@MajorVersion <= 4
            Mov esi {B$ 'MS Windows NT' EOS}
        .End_If

        While B$esi <> 0 | movsb | EndWhile
        Mov al SPC | stosb

      ; Service pack number
        Mov esi OSVersionInfo@CSDVersion
        While B$esi <> 0 | movsb | EndWhile
        Call TestWinNTSP6a

      ; Build number
        Mov esi {B$ ' Build ' EOS}
        While B$esi <> 0 | movsb | EndWhile
        movzx eax W$OSVersionInfo@BuildNumber
        Call IntToStr
        Mov al SPC | stosb

      ; Home / Professional / ...
        Call GetWindowsProductInfo
        If esi <> 0
            While B$esi <> 0 | movsb | EndWhile
            Mov al SPC | stosb
        End_If

    ..Else_If D$OSVersionInfo@PlatformId = &VER_PLATFORM_WIN32_WINDOWS

      ; Major versions
        .If D$OSVersionInfo@MajorVersion = 4
            Mov eax 0
            If D$OSVersionInfo@MinorVersion = 90
                Mov esi {B$ 'MS Windows ME' EOS}
            Else_If D$OSVersionInfo@MinorVersion = 10
                Mov esi {B$ 'MS Windows 98' EOS}
                On B$OSVersionInfo@CSDVersion+1 = 'A', Mov eax ' SE'
            Else_If D$OSVersionInfo@MinorVersion = 0
                Mov esi {B$ 'MS Windows 95 ' EOS}
                On B$OSVersionInfo@CSDVersion+1 = 'B', Mov eax 'OSR2'
                On B$OSVersionInfo@CSDVersion+1 = 'C', Mov eax 'OSR2'
            End_If
            While B$esi <> 0 | movsb | EndWhile
            stosd
        .End_If

    ..Else_If D$OSVersionInfo@PlatformId = &VER_PLATFORM_WIN32S

        Mov esi {B$ 'MS Win32s' EOS}
        While B$esi <> 0 | movsb | EndWhile

    ..End_If

    Mov B$edi 0
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE ShowInfos       ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

; Win32 Data Types significations (This is the [Win32 Data Types] from [Help] Menu
; -ShowTypesInfo- and the Right-Click upon Mnemonic feature -ShowMnemonicInfo-):

[TypesTitle: B$ 'Win32 Data Types' EOS]

; Tag Dialog 1000

ShowTypes:
    If D$ShowTypesDialogHandle = 0
        Call 'USER32.DialogBoxParamA' D$H.Instance, 1000, &NULL, ShowTypesInfo, &NULL
    Else
        Call Beep
    End_If
ret


ShowEquates:
    Call SetEquatesEquFileName

    Call 'SHELL32.ShellExecuteA' D$H.MainWindow, Open, {B$ 'WordPad' EOS},
                                 IncludeFileName, &NULL, &SW_SHOWNORMAL
ret


[ShowTypesDialogHandle: D$ ?
 FirstCTLCOLOREDIT: D$ ?]

Proc ShowTypesInfo:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    .If D@msg = &WM_COMMAND
         If D@wParam = &IDCANCEL
            Mov D$ShowTypesDialogHandle 0
            Call 'USER32.EndDialog' D@hwnd 0
         End_If

    .Else_If D@msg = &WM_INITDIALOG
        Move D$ShowTypesDialogHandle D@hwnd
        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        Call 'USER32.SetDlgItemTextA' D@hwnd 100 Win32Types
        Call 'USER32.SendMessageA' D@hwnd &WM_SETTEXT &NULL TypesTitle
        Mov B$FirstCTLCOLOREDIT &TRUE

    .Else_If D@msg = &WM_CTLCOLOREDIT
        If B$FirstCTLCOLOREDIT = &TRUE
            Call 'USER32.SendMessageA' D@lParam &EM_SETSEL 0 0
            Mov B$FirstCTLCOLOREDIT &FALSE
        End_If
        Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>

    .Else
        popad | Mov eax &FALSE | jmp L9>

    .End_If

    popad | Mov eax &TRUE

L9: EndP


[Win32Types:
 B$ " ACHAR         B$ ; ansi character
 ATOM          D$ ; string atom
 BOOL          D$ ; boolean variable
 COLORREF      D$ ; rgb color
 DWORDLONG     Q$ ; 8 bytes
 GLOBALHANDLE  D$ ; global handle
 HACCEL        D$ ; accelerator handle
 HANDLE        D$ ; unspecified handle
 HBITMAP       D$ ; bitmap handle
 HBRUSH        D$ ; brush handle
 HCOLORSPACE   D$ ; color space handle
 HCURSOR       D$ ; cursor handle
 HDC           D$ ; device context handle
 HDWP          D$ ; defer win pos handle
 HENHMETAFILE  D$ ; enh. metafile handle
 HFILE         D$ ; file handle
 HFONT         D$ ; font handle
 HGLOBAL       D$ ; global handle
 HHOOK         D$ ; hook handle
 HICON         D$ ; icon handle
 HINSTANCE     D$ ; instance handle
 HINTERNET     D$ ; internet handle
 HLOCAL        D$ ; local handle
 HMENU         D$ ; menu handle
 HMETAFILE     D$ ; metafile handle
 HPALETTE      D$ ; palette handle
 HPEN          D$ ; pen handle
 HRGN          D$ ; region handle
 HRSRC         D$ ; resource handle
 HSTR          D$ ; string handle
 HTASK         D$ ; task handle
 HTREEITEM     D$ ; tree view item handle
 HWND          D$ ; window handle
 INTEGER       D$ ; standard integer
 LOCALHANDLE   D$ ; local handle
 LONG          D$ ; long integer
 LONGINT       D$ ; long integer
 LPARAM        D$ ; long parameter
 LPBOOL        D$ ; long ptr to boolean
 LPBYTE        D$ ; long ptr to byte
 LPCSTR        D$ ; long ptr to string
 LPCTSTR       D$ ; long ptr to string
 LPCVOID       D$ ; long ptr to buffer
 LPDWORD       D$ ; long ptr to dword
 LPFN          D$ ; long ptr to function
 LPINT         D$ ; long ptr to integer
 LPLONG        D$ ; long ptr to long int
 LPMSG         D$ ; long pointer to message
 LPPAINTSTRUCT D$ ; long ptr to paint struc
 LPRECT        D$ ; long pointer to rectangle
 LPSTR         D$ ; long ptr to string
 LPTSTR        D$ ; long ptr to string
 LPVOID        D$ ; long ptr to buffer
 LPWORD        D$ ; long ptr to word
 LRESULT       D$ ; long result
 POINTER       D$ ; pointer to anything
 PVOID         D$ ; pointer to buffer
 SHORTINT      W$ ; short integer
 UINT          D$ ; unsigned integer
 WCHAR         W$ ; unicode character
 WNDPROC       D$ ; window procedure
 WPARAM        D$ ; word parameter" EOS]
____________________________________________________________________________________________
____________________________________________________________________________________________


; > in from Caller (RightClick) ah = first ORed 32 char // edx > second char // ebx = lenght

[MnemonicIndex: D$ ?]

OldSearchMneMonic:
    pushad
        Mov D$MnemonicIndex 7
        or ah 32 | xor ah 32         ;  > upper case (all Upper case in the list
        Mov esi OpcodesList
        .While B$esi > 0
            lodsb
            .If al = ah
                pushad | Mov ecx ebx, edi edx
L0:             lodsb | Mov ah B$edi | inc edi | or ah SPC | xor ah SPC ; Source upper case.
                cmp ah al | jne L1>
                loop L0<
L1:             popad | jne L3>
                If B$esi+ebx = SPC
                    On D$H.ShowMnemonic > 0, Call 'USER32.EndDialog' D$H.ShowMnemonic 0
                    Call 'USER32.DialogBoxParamA' D$H.Instance 1000  &NULL ShowMnemonicInfo  &NULL
                    Mov B$MnemonicHelpFound &TRUE | jmp L9>
                End_If
L3:
            .End_If
            While B$esi-1 > LF
                inc esi
            End_While
            inc D$MnemonicIndex
        .End_While
L9:  popad
ret


[MnemonicCopy: D$ ? # 4]

; > in from Caller (RightClick):
; ah = first ORed 32 char // edx > second char // ebx = lenght

[MnemonicHelpFound: D$ ?]

SearchMneMonic: On ebx > 14, ret
    pushad
        Mov D$MnemonicCopy '    ', D$MnemonicCopy+4 '    ',
            D$MnemonicCopy+8 '    ', D$MnemonicCopy+12 '    '

      ; 1) Make an upper Case copy of the possible Mnemonic (spaces ended):
        dec edx | Mov esi edx, edi MnemonicCopy, ecx ebx | inc ecx
L0:     lodsb | On al > 'Z', and eax (not SPC) | stosb | loop L0<

      ; Search identical record in 'OpCodeList':
        Mov edi MnemonicCopy, esi OpCodeList, ebx D$edi
L0:     lodsd | cmp eax 0 | je L9>>
                cmp eax ebx | je L5>

L4:                 AlignOn 16 esi | jmp L0<

L5:                     Mov edx edi | add edx 4
                        While B$edx <> SPC
                            lodsd | cmp eax D$edx | jne L4<
L6:                         add edx 4
                        End_While
                        On B$esi <> SPC, jmp L4<

                      ; Step back to Main Mnemonic if '<' encounted:
                        AlignOn 16 esi | sub esi 16
                        If B$esi-1 = '<'
                            While B$esi-1 = '<'
                                sub esi 16
                            End_While
                        End_If

                      ; Zero end Case sensitive recopy of the MnemonicCopy for ShellExecute:
                        Mov edi MnemonicCopy
                        While B$esi <> SPC
                            movsb
                        End_While
                        Mov B$edi 0
                        Call Help B_U_AsmName, MnemonicCopy, FileNotFound
                        If eax <= 32
                            jmp L9>
                        Else
                            Mov B$MnemonicHelpFound &TRUE
                        End_If
    popad
ret

L9: popad
jmp OldSearchMneMonic


[H.ShowMnemonic: D$ ?]
[MnemonicsTitle: B$ 'Mnemonics list (More Infos with OpHelp.exe...)' EOS]

Proc ShowMnemonicInfo:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    .If D@msg = &WM_COMMAND
         If D@wParam = &IDCANCEL
            Call 'USER32.EndDialog' D@hwnd 0
         End_If

    .Else_If D@msg = &WM_INITDIALOG
        Move D$H.ShowMnemonic D@hwnd
        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        Call 'USER32.SetDlgItemTextA' D@hwnd 100 OpcodesListTitle
        Call 'USER32.GetDlgItem' D@hwnd 100
        Call 'USER32.SendMessageA' eax &EM_LINESCROLL 0  D$MnemonicIndex
        Call 'USER32.SendMessageA' D@hwnd &WM_SETTEXT 0 MnemonicsTitle
        Mov B$FirstCTLCOLOREDIT &TRUE

    .Else_If D@msg = &WM_CTLCOLOREDIT
        If B$FirstCTLCOLOREDIT = &TRUE
            Call 'USER32.SendMessageA' D@lParam &EM_SETSEL 0 0
            Mov B$FirstCTLCOLOREDIT &FALSE
        End_If
        Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>

    .Else
        popad | Mov eax &FALSE | jmp L9>

    .End_If

    popad | Mov eax &TRUE

L9: EndP

____________________________________________________________________________________________
____________________________________________________________________________________________


[ApiTitle: B$ 'Api Call infos' EOS]

; Tag Dialog 1000

Proc ShowApiInfo:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    .If D@msg = &WM_COMMAND
         If D@wParam = &IDCANCEL
            Call 'USER32.EndDialog' D@hwnd 0
         End_If

    .Else_If D@msg = &WM_INITDIALOG
        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        Call 'USER32.SetDlgItemTextA' D@hwnd 100  OneApiInfo
        Call 'USER32.SendMessageA' D@hwnd &WM_SETTEXT 0 ApiTitle
        Mov B$FirstCTLCOLOREDIT &TRUE

    .Else_If D@msg = &WM_CTLCOLOREDIT
        If B$FirstCTLCOLOREDIT = &TRUE
            Call 'USER32.SendMessageA' D@lParam &EM_SETSEL 0 0
            Mov B$FirstCTLCOLOREDIT &FALSE
        End_If
        Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>

    .Else
        popad | Mov eax &FALSE | jmp L9>

    .End_If

    popad | Mov eax &TRUE

L9: EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[OpcodesListTitle: B$
"            ************************************************
            *  The Complete Pentium Instruction Set Table  *
            *      - Thanks to Sang Cho (SV 1999) -        *
            *==============================================*
            *    Ripped from exe and converted into this   *
            *         text format by Test Department       *
            ************************************************
"


OpcodesList: B$ "
AAA                  37           ASCII adjust AL after addition       
    > Mov al 09, bl 02 | add al bl | AAA ; ax = BCD(0101)

AAD                  D5 0A        ASCII adjust AX before division      
    > Mov ax 0102 | AAD ; ax = 12

AAM                  D4 0A        ASCII adjust AX after multiplication 
    > Mov al 7 | Mov cx 8 | mul cx | aam ; ax = 0506

AAS                  3F           ASCII adjust AL after subtraction    
    > sub al bl | aas | jc CarryFlagSet

ADC AL,imm8          14       ib  Add with carry
    > ... To be continued by who wants to...

ADC EAX,imm32        15       id  Add with carry
    > ... Search for 'OpcodesList' Label in RosAsm Source.

ADC r/m8,imm8        80    /2 ib  Add with carry
    > ...

ADC r/m32,imm32      81    /2 id  Add with carry
    > ...

ADC r/m32,imm8       83    /2 ib  Add with carry
    > ...

ADC r/m8,r8          10    /r     Add with carry
    > ...

ADC r/m32,r32        11    /r     Add with carry
ADC r8,r/m8          12    /r     Add with carry 
ADC r32,r/m32        13    /r     Add with carry
ADD AL,imm8          04       ib  Add 
ADD EAX,imm32        05       id  Add 
ADD r/m8,imm8        80    /0 ib  Add 
ADD r/m32,imm32      81    /0 id  Add 
ADD r/m32,imm8       83    /0 ib  Add 
ADD r/m8,r8          00    /r     ADD 
ADD r/m32,r32        01    /r     ADD 
ADD r8,r/m8          02    /r     ADD 
ADD r32,r/m32        03    /r     ADD 
AND AL,imm8          24       ib  AND 
AND EAX,imm32        25       id  AND
AND r/m8,imm8        80    /4 ib  AND
AND r/m32,imm32      81    /4 id  AND
AND r/m32,imm8       83    /4 ib  AND
AND r/m8,r8          20    /r     AND
AND r/m32,r32        21    /r     AND
AND r8,r/m8          22    /r     AND
AND r32,r/m32        23    /r     AND
ARPL r/m16,r16       63    /r     Adjust Request Privilege Level of Sel.
BOUND r32,m32&32     62    /r     Check Array Index Against Bounds
BSF r32,r/m32        0F BC /r     Bit scan forward on r/m32
BSR r32,r/m32        0F BD /r     Bit scan reverse on r/m32
BSWAP r32            0F C8+rd     Reverses the byte order of a r32
BT r/m32,r32         0F A3 /r     Bit Test
BT r/m32,imm8        0F BA /4 ib  Bit Test
BTC r/m32,r32        0F BB /r     Bit Test and Complement
BTC r/m32,imm8       0F BA /7 ib  Bit Test and Complement
BTR r/m32,r32        0F B3 /r     Bit Test and Clear
BTR r/m32,imm8       0F BA /6 ib  Bit Test and Clear
BTS r/m32,r32        0F AB /r     Bit Test and Set
BTS r/m32,imm8       0F BA /5 ib  Bit Test and Set
Call rel32           E8       cd  Call near, rel to n.inst
Call r/m32           FF    /2     Call near, abs.ind.add. given in r/m32
Call ptr16:32        9A       cp  Call far, abs.add. given in operand
Call m16:32          FF    /3     Call far, abs.ind.add. given in m16:32
CBW                  98           Convert Byte to Word
CWD                  99           Convert Word to Doubleword
CDQ                  99           Convert Doubleword to Quadword 
CLC                  F8           Clear CF flag
CLD                  FC           Clear DF flag
CLI                  FA           Clear interrupt flag
CLTS                 0F 06        Clear Task-Switched Flag in Control Reg. Zero
CMC                  F5           Complement CF flag
CMOVA r32,r/m32      0F 47 /r     Move if above 
CMOVAE r32,r/m32     0F 43 /r     Move if above or equal 
CMOVB r32,r/m32      0F 42 /r     Move if below 
CMOVBE r32,r/m32     0F 46 /r     Move if below or equal 
CMOVC r32,r/m32      0F 42 /r     Move if carry 
CMOVE r32,r/m32      0F 44 /r     Move if equal 
CMOVG r32,r/m32      0F 4F /r     Move if greater 
CMOVGE r32,r/m32     0F 4D /r     Move if greater or equal 
CMOVL r32,r/m32      0F 4C /r     Move if less 
CMOVLE r32,r/m32     0F 4E /r     Move if less or equal 
CMOVNA r32,r/m32     0F 46 /r     Move if not above 
CMOVNAE r32,r/m32    0F 42 /r     Move if not above or equal 
CMOVNB r32,r/m32     0F 43 /r     Move if not below 
CMOVNBE r32,r/m32    0F 47 /r     Move if not below or equal 
CMOVNC r32,r/m32     0F 43 /r     Move if not carry 
CMOVNE r32,r/m32     0F 45 /r     Move if not equal 
CMOVNG r32,r/m32     0F 4E /r     Move if not greater 
CMOVNGE r32,r/m32    0F 4C /r     Move if not greater or equal 
CMOVNL r32,r/m32     0F 4D /r     Move if not less 
CMOVNLE r32,r/m32    0F 4F /r     Move if not less or equal 
CMOVNO r32,r/m32     0F 41 /r     Move if not overflow 
CMOVNP r32,r/m32     0F 4B /r     Move if not parity 
CMOVNS r32,r/m32     0F 49 /r     Move if not sign 
CMOVNZ r32,r/m32     0F 45 /r     Move if not zero 
CMOVO r32,r/m32      0F 40 /r     Move if overflow 
CMOVP r32,r/m32      0F 4A /r     Move if parity 
CMOVPE r32,r/m32     0F 4A /r     Move if parity even 
CMOVPO r32,r/m32     0F 4B /r     Move if parity odd 
CMOVS r32,r/m32      0F 48 /r     Move if sign 
CMOVZ r32,r/m32      0F 44 /r     Move if zero 
CMP AL,imm8          3C       ib  Compare 
CMP EAX,imm32        3D       id  Compare 
CMP r/m8,imm8        80    /7 ib  Compare 
CMP r/m32,imm32      81    /7 id  Compare 
CMP r/m32,imm8       83    /7 ib  Compare 
CMP r/m8,r8          38    /r     Compare 
CMP r/m32,r32        39    /r     Compare 
CMP r8,r/m8          3A    /r     Compare 
CMP r32,r/m32        3B    /r     Compare 
CMPSB                A6           Compare byte at ESI byte at with EDI 
CMPSD                A7           Compare dword  at ESI byte at with EDI
CMPXCHG r/m8,r8      0F B0 /r     Compare and Exchange
CMPXCHG r/m32,r32    0F B1 /r     Compare and Exchange
CMPXCHG8B m64        0F C7 /1 m64 Compare and Exchange
CPUID                0F A2        EAX := Processor id.info.
DAA                  27           Decimal adjust AL after addition
DAS                  2F           Decimal adjust AL after subtraction
DEC r/m8             FE    /1     Decrement r/m8 by 1
DEC r/m32            FF    /1     Decrement r/m32 by 1
DEC r32              48+rd        Decrement r32 by 1
DIV r/m8             F6    /6     Unsigned divide AX by r/m8
DIV r/m16            F7    /6     Unsigned divide DX:AX by r/m16
DIV r/m32            F7    /6     Unsigned divide EDX:EAX by r/m32 
EMMS                 0F 77        Set the FP tag word to empty
ENTER imm16,0        C8     iw 00 Create a stack frame for a procedure
ENTER imm16,1        C8     iw 01 Create a nested stack frame for a proc.
ENTER imm16,imm8     C8     iw ib Create a nested stack frame for a proc.
F2XM1                D9 F0        Replace ST0 with 2**ST0 - 1
FABS                 D9 E1        Replace ST0 with its absolute value
FADD m32real         D8    /0     Add m32real to ST0 and s.r. in ST0
FADD m64real         DC    /0     Add m64real to ST0 and s.r.in ST0
FADD ST(0),ST(i)     D8 C0+i      Add ST0 to STi and s.r.in ST0
FADD ST(i),ST(0)     DC C0+i      Add STi to ST0 and s.r. in STi
FADDP ST(i),ST(0)    DE C0+i      Add ST0 to STi, s.r.in STi,Pop r.stack
FADDP                DE C1        Add ST0 to ST1, s.r.in ST1,Pop r.stack
FIADD m32int         DA    /0     Add m32int to ST0 and s.r.in ST0
FIADD m16int         DE    /0     Add m16int to ST0 and s.r.in ST0
FBLD m80bcd          DF    /4     Convert m80BCD to real and Push 
FBSTP m80bcd         DF    /6     Store ST0 in m80bcd and Pop ST0
FCHS                 D9 E0        Complements sign of ST0
FCLEX                9B DB E2     Clear f.e.f. after checking for ..
FNCLEX               DB E2        Clear f.e.f. without checking for ..
FCMOVB ST(0),ST(i)   DA C0+i      Move if below 
FCMOVE ST(0),ST(i)   DA C8+i      Move if equal 
FCMOVBE ST(0),ST(i)  DA D0+i      Move if below or equal 
FCMOVU ST(0),ST(i)   DA D8+i      Move if unordered 
FCMOVNB ST(0),ST(i)  DB C0+i      Move if not below 
FCMOVNE ST(0),ST(i)  DB C8+i      Move if not equal 
FCMOVNBE ST(0),ST(i) DB D0+i      Move if not below or equal 
FCMOVNU ST(0),ST(i)  DB D8+i      Move if not unordered 
FCOM m32real         D8    /2     Compare ST0 with m32real.
FCOM m64real         DC    /2     Compare ST0 with m64real.
FCOM ST(i)           D8 D0+i      Compare ST0 with STi.
FCOM                 D8 D1        Compare ST0 with ST1.
FCOMP m32real        D8    /3     Compare ST0 with m32real,Pop r.stack.
FCOMP m64real        DC    /3     Compare ST0 with m64real,Pop r.stack.
FCOMP ST(i)          D8 D8+i      Compare ST0 with STi, Pop 
FCOMP                D8 D9        Compare ST0 with ST1, Pop 
FCOMPP               DE D9        Compare ST0 with ST1, Pop Pop
FCOMI ST,ST(i)       DB F0+i      Compare ST0 with STi, set status flags
FCOMIP ST,ST(i)      DF F0+i      Compare ST0 with STi, set s.f. ,Pop 
FUCOMI ST,ST(i)      DB E8+i      Compare ST0 with STi, check o.v.set s.f.
FUCOMIP ST,ST(i)     DF E8+i      Compare ST0 with STi, check ovssf Pop 
FCOS                 D9 FF        Replace ST0 with its cosine
FDECSTP              D9 F6        Decrement TOP field in FPU status word.
FDIV m32real         D8    /6     Divide ST0 by m32real and s.r.in ST0
FDIV m64real         DC    /6     Divide ST0 by m64real and s.r.in ST0
FDIV ST(0),ST(i)     D8 F0+i      Divide ST0 by STi and s.r.in ST0
FDIV ST(i),ST(0)     DC F8+i      Divide STi by ST0 and s.r.in STi
FDIVP ST(i),ST(0)    DE F8+i      Divide STi by ST0, s.r.in STi Pop 
FDIVP                DE F9        Divide ST1 by ST0, s.r.in ST1 Pop 
FIDIV m32int         DA    /6     Divide ST0 by m32int and s.r.in ST0
FIDIV m16int         DE    /6     Divide ST0 by m64int and s.r.in ST0
FDIVR m32real        D8    /7     Divide m32real by ST0 and s.r.in ST0
FDIVR m64real        DC    /7     Divide m64real by ST0 and s.r.in ST0
FDIVR ST(0),ST(i)    D8 F8+i      Divide STi by ST0 and s.r.in ST0
FDIVR ST(i),ST(0)    DC F0+i      Divide ST0 by STi and s.r.in STi
FDIVRP ST(i),ST(0)   DE F0+i      Divide ST0 by STi, s.r.in STi Pop 
FDIVRP               DE F1        Divide ST0 by ST1, s.r.in ST1 Pop 
FIDIVR m32int        DA    /7     Divide m32int by ST0 and s.r.in ST0
FIDIVR m16int        DE    /7     Divide m64int by ST0 and s.r.in ST0
FFREE ST(i)          DD C0+i      Sets tag for STi to empty
FICOM m16int         DE    /2     Compare ST0 with m16int
FICOM m32int         DA    /2     Compare ST0 with m32int
FICOMP m16int        DE    /3     Compare ST0 with m16int and Pop 
FICOMP m32int        DA    /3     Compare ST0 with m32int and Pop 
FILD m16int          DF    /0     Push m16int 
FILD m32int          DB    /0     Push m32int 
FILD m64int          DF    /5     Push m64int 
FINCSTP              D9 F7        Increment the TOP field FPU status r.
FINIT                9B DB E3     Initialize FPU after ...
FNINIT               DB E3        Initialize FPU without ...
FIST m16int          DF    /2     Store ST0 in m16int
FIST m32int          DB    /2     Store ST0 in m32int
FISTP m16int         DF    /3     Store ST0 in m16int and Pop 
FISTP m32int         DB    /3     Store ST0 in m32int and Pop 
FISTP m64int         DF    /7     Store ST0 in m64int and Pop 
FLD m32real          D9    /0     Push m32real 
FLD m64real          DD    /0     Push m64real 
FLD m80real          DB    /5     Push m80real 
FLD ST(i)            D9 C0+i      Push STi 
FLD1                 D9 E8        Push +1.0 
FLDL2T               D9 E9        Push log2 10 
FLDL2E               D9 EA        Push log2 = 
FLDPI                D9 EB        Push pi 
FLDLG2               D9 EC        Push log10 2 
FLDLN2               D9 ED        Push loge 2 
FLDZ                 D9 EE        Push +0.0 
FLDCW m2byte         D9    /5     Load FPU control word from m2byte
FLDENV m14/28byte    D9    /4     Load FPU environment from m14/m28
FMUL m32real         D8    /1     Multiply ST0 by m32real and s.r.in ST0
FMUL m64real         DC    /1     Multiply ST0 by m64real and s.r.in ST0
FMUL ST(0),ST(i)     D8 C8+i      Multiply ST0 by STi and s.r.in ST0
FMUL ST(i),ST(0)     DC C8+i      Multiply STi by ST0 and s.r.in STi
FMULP ST(i),ST(0)    DE C8+i      Multiply STi by ST0, s.r.in STi Pop 
FMULP                DE C9        Multiply ST1 by ST0, s.r.in ST1 Pop 
FIMUL m32int         DA    /1     Multiply ST0 by m32int and s.r.in ST0
FIMUL m16int         DE    /1     Multiply ST0 by m16int and s.r.in ST0
FNOP                 D9 D0        No operation is performed
FPATAN               D9 F3        Repalces ST1 with arctan(ST1/ST0) Pop 
FPREM                D9 F8        Replaces ST0 with rem (ST0/ST1)
FPREM1               D9 F5        Replaces ST0 with IEEE rem(ST0/ST1)
FPTAN                D9 F2        Replaces ST0 with its tangent Push 1.0
FRNDINT              D9 FC        Round ST0 to an integer
FRSTOR m94/108byte   DD    /4     Load FPU status from m94 or m108 byte
FSAVE m94/108byte    9B DD /6     Store FPU status to m94 or m108
FNSAVE m94/108byte   DD    /6     Store FPU environment to m94 or m108
FSCALE               D9 FD        Scale ST0 by ST1
FSIN                 D9 FE        Replace ST0 with its sine
FSINCOS              D9 FB        Compute sine and consine of ST0 s Push c
FSQRT                D9 FA        square root of ST0
FST m32real          D9    /2     Copy ST0 to m32real
FST m64real          DD    /2     Copy ST0 to m64real
FST ST(i)            DD D0+i      Copy ST0 to STi
FSTP m32real         D9    /3     Copy ST0 to m32real and Pop 
FSTP m64real         DD    /3     Copy ST0 to m64real and Pop 
FSTP m80real         DB    /7     Copy ST0 to m80real and Pop 
FSTP ST(i)           DD D8+i      Copy ST0 to STi and Pop 
FSTCW m2byte         9B D9 /7     Store FPU control word
FNSTCW m2byte        D9    /7     Store FPU control word without
FSTENV m14/28byte    9B D9 /6     Store FPU environment
FNSTENV m14/28byte   D9    /6     Store FPU env without
FSTSW m2byte         9B DD /7     Store FPU status word at m2byte after 
FSTSW AX             9B DF E0     Store FPU status word in AX  after 
FNSTSW m2byte        DD    /7     Store FPU status word at m2byte without 
FNSTSW AX            DF E0        Store FPU status word in AX without 
FSUB m32real         D8    /4     Sub m32real from ST0 and s.r.in ST0
FSUB m64real         DC    /4     Sub m64real from ST0 and s.r.in ST0
FSUB ST(0),ST(i)     D8 E0+i      Sub STi from ST0 and s.r.in ST0
FSUB ST(i),ST(0)     DC E8+i      Sub ST0 from STi and s.r.in STi
FSUBP ST(i),ST(0)    DE E8+i      Sub ST0 from STi, s.r.in STi Pop
FSUBP                DE E9        Sub ST0 from ST1, s.r.in ST1 Pop 
FISUB m32int         DA    /4     Sub m32int from ST0 and s.r.in ST0
FISUB m16int         DE    /4     Sub m16int from ST0 and s.r.in ST0
FSUBR m32real        D8    /5     Sub ST0 from m32real and s.r.in ST0
FSUBR m64real        DC    /5     Sub ST0 from m64real and s.r.in ST0
FSUBR ST(0),ST(i)    D8 E8+i      Sub ST0 from STi and s.r.in ST0
FSUBR ST(i),ST(0)    DC E0+i      Sub STi from ST0 and s.r.in STi
FSUBRP ST(i),ST(0)   DE E0+i      Sub STi from ST0, s.r. in STi) Pop 
FSUBRP               DE E1        Sub ST1 from ST0, s.r.in ST1 Pop 
FISUBR m32int        DA    /5     Sub ST0 from m32int and s.r.in ST0
FISUBR m16int        DE    /5     Sub ST0 from m16int and s.r.in ST0
FTST                 D9 E4        Compare ST0 with 0.0
FUCOM ST(i)          DD E0+i      Compare ST0 with STi
FUCOM                DD E1        Compare ST0 with ST1
FUCOMP ST(i)         DD E8+i      Compare ST0 with STi and Pop 
FUCOMP               DD E9        Compare ST0 with ST1 and Pop 
FUCOMPP              DA E9        Compare ST0 with ST1 and Pop Pop
FXAM                 D9 E5        Classify value or number in ST0
FXCH ST(i)           D9 C8+i      Exchange ST0 and STi
FXCH                 D9 C9        Exchange ST0 and ST1
FXTRACT              D9 F4        Seperate value in ST(0) exp. and sig.
FYL2X                D9 F1        Replace ST1 with ST1*log2(ST0) and Pop
FYL2XP1              D9 F9        Replace ST1 with ST1*log2(ST0+1) Pop
HLT                  F4           Halt
IDIV r/m8            F6    /7     Divide   
IDIV r/m32           F7    /7     Divide  
IMUL r/m8            F6    /5     Multiply
IMUL r/m32           F7    /5     Multiply
IMUL r32,r/m32       0F AF /r     Multiply
IMUL r32,r/m32,imm8  6B    /r ib  Multiply
IMUL r32,imm8        6B    /r ib  Multiply
IMUL r32,r/m32,imm32 69    /r id  Multiply
IMUL r32,imm32       69    /r id  Multiply
IN AL,imm8           E4       ib  Input byte from imm8 I/O port address into AL
IN EAX,imm8          E5       ib  Input byte from imm8 I/O port address into EAX
IN AL,DX             EC           Input byte from I/O port in DX into AL
IN EAX,DX            ED           Input doubleword from I/O port in DX into EAX
INC r/m8             FE    /0     Increment 1
INC r/m32            FF    /0     Increment 1
INC r32              40+rd        Increment register by 1
INS m8               6C           Input byte from I/O(DX) into  (E)DI
INS m32              6D           Input dw from I/O(DX) into (E)DI
INT 3                CC           Interrupt 3--trap to debugger
INT imm8             CD       ib  Interrupt vector number (imm8)
INTO                 CE           Interrupt 4--if overflow flag is 1
INVD                 0F 08        Flush internal caches
INVLPG m             0F 01 /7     Invalidate TLB Entry for page (m)
IRETD                CF           Interrupt return(32)
JA rel8              77       cb  Jump short if above 
JAE rel8             73       cb  Jump short if above or equal 
JBE rel8             76       cb  Jump short if below or equal 
JC rel8              72       cb  Jump short if carry 
JECXZ rel8           E3       cb  Jump short if ECX register is 0
JE rel8              74       cb  Jump short if equal 
JG rel8              7F       cb  Jump short if greater 
JGE rel8             7D       cb  Jump short if greater or equal 
JL rel8              7C       cb  Jump short if less 
JLE rel8             7E       cb  Jump short if less or equal 
JNE rel8             75       cb  Jump short if not equal 
JNO rel8             71       cb  Jump short if not overflow 
JNS rel8             79       cb  Jump short if not sign 
JO rel8              70       cb  Jump short if overflow 
JPE rel8             7A       cb  Jump short if parity even 
JPO rel8             7B       cb  Jump short if parity odd 
JS rel8              78       cb  Jump short if sign 
JA rel32             0F 87    cd  Jump near if above 
JAE rel32            0F 83    cd  Jump near if above or equal 
JB rel32             0F 82    cd  Jump near if below 
JBE rel32            0F 86    cd  Jump near if below or equal 
JE rel32             0F 84    cd  Jump near if equal 
JG rel32             0F 8F    cd  Jump near if greater 
JGE rel32            0F 8D    cd  Jump near if greater or equal 
JL rel32             0F 8C    cd  Jump near if less 
JLE rel32            0F 8E    cd  Jump near if less or equal 
JNE rel32            0F 85    cd  Jump near if not equal 
JNO rel32            0F 81    cd  Jump near if not overflow 
JNS rel32            0F 89    cd  Jump near if not sign 
JO rel32             0F 80    cd  Jump near if overflow 
JPE rel32            0F 8A    cd  Jump near if parity even 
JPO rel32            0F 8B    cd  Jump near if parity odd 
JS rel32             0F 88    cd  Jump near if sign 
JMP rel8             EB       cb  Jump short, relative, 
JMP rel32            E9       cd  Jump near, relative, 
JMP r/m32            FF    /4     Jump near, abs.ind.in r/m32
JMP ptr16:32         EA       cp  Jump far, abs.add given in operand
JMP m16:32           FF    /r     Jump far, abs.ind.in m16:32
LAHF                 9F           Load Status Flags into AH 
LAR r32,r/m32        0F 02 /r     Load Access Rights Byte     
LDS r32,m16:32       C5    /r     Load DS:r32 with far ptr
LEA r32,m            8D    /r     Load effective address  
LEAVE                C9           Set ESP to EBP, then Pop EBP
LES r32,m16:32       C4    /r     Load ES:r32 with far ptr 
LFS r32,m16:32       0F B4 /r     Load FS:r32 with far ptr
LGS r32,m16:32       0F B5 /r     Load GS:r32 with far ptr
LGDT m16&32          0F 01 /2     Load m into GDTR
LIDT m16&32          0F 01 /3     Load m into IDTR
LLDT r/m16           0F 00 /2     Load segment selector r/m16 into LDTR
LMSW r/m16           0F 01 /6     Load r/m16 in machine status word of CR0
LOCK                 F0           Asserts LOCK signal for duration ..
LODSB                AC           Load byte at address ESI into AL
LODSD                AD           Load dword at address ESI into EAX
LODSW                AD           Load word at address ESI into AX
LOOP rel8            E2       cb  Dec count;jump if count # 0
LOOPE rel8           E1       cb  Dec count;jump if count # 0 and ZF=1
LOOPZ rel8           E1       cb  Dec count;jump if count # 0 and ZF=1
LOOPNE rel8          E0       cb  Dec count;jump if count # 0 and ZF=0
LOOPNZ rel8          E0       cb  Dec count;jump if count # 0 and ZF=0
LSL r16,r/m16        0F 03 /r     Load Segment Limit
LSL r32,r/m32        0F 03 /r     Load Segment Limit
LSS r32,m16:32       0F B2 /r     Load SS:r32 with far ptr
LTR r/m16            0F 00 /3     Load Task Register
Mov r/m8,r8          88    /r     Move 
Mov r/m32,r32        89    /r     Move 
Mov r8,r/m8          8A    /r     Move 
Mov r32,r/m32        8B    /r     Move 
Mov r/m16,Sreg**     8C    /r     Move segment register to r/m16
Mov Sreg,r/m16**     8E    /r     Move r/m16 to segment register
Mov AL, moffs8*      A0           Move byte at ( seg:offset) to AL
Mov AX, moffs16*     A1           Move word at ( seg:offset) to AX
Mov EAX, moffs32*    A1           Move dword at ( seg:offset) to EAX
Mov moffs8*,AL       A2           Move AL to ( seg:offset)
Mov moffs16*,AX      A3           Move AX to ( seg:offset)
Mov moffs32*,EAX     A3           Move EAX to ( seg:offset)
Mov r8,imm8          B0+rb        Move imm8 to r8
Mov r32,imm32        B8+rd        Move imm32 to r32
Mov r/m8,imm8        C6    /0 ib  Move imm8 to r/m8
Mov r/m32,imm32      C7    /0 id  Move imm32 to r/m32
Mov CR0, r32         0F 22 /r     Move r32 to CR0
Mov CR2, r32         0F 22 /r     Move r32 to CR2
Mov CR3, r32         0F 22 /r     Move r32 to CR3
Mov CR4, r32         0F 22 /r     Move r32 to CR4
Mov r32,CR0          0F 20 /r     Move CR0 to r32
Mov r32,CR2          0F 20 /r     Move CR2 to r32
Mov r32,CR3          0F 20 /r     Move CR3 to r32
Mov r32,CR4          0F 20 /r     Move CR4 to r32
Mov r32,DR0-DR7      0F 21 /r     Move debug register to r32
Mov DR0-DR7,r32      0F 23 /r     Move r32 to debug register
MOVD mm,r/m32        0F 6E /r     Move doubleword from r/m32 to mm
MOVD r/m32,mm        0F 7E /r     Move doubleword from mm to r/m32
MOVQ mm,mm/m64       0F 6F /r     Move quadword from mm/m64 to mm
MOVQ mm/m64,mm       0F 7F /r     Move quadword from mm to mm/m64
MOVSB                A4           Move byte at ESI to  EDI
MOVSD                A5           Move dword at ESI to  EDI
MOVSW                A5           Move word at ESI to  EDI
MOVSX r32,r/m8       0F BE /r     Move byte to doubleword, sign-extension
MOVSX r32,r/m16      0F BF /r     Move word to doubleword, sign-extension
MOVZX r32,r/m8       0F B6 /r     Move byte to doubleword, zero-extension
MOVZX r32,r/m16      0F B7 /r     Move word to doubleword, zero-extension
MUL r/m8             F6    /4     Unsigned multiply 
MUL r/m32            F7    /4     Unsigned multiply 
NEG r/m8             F6    /3     Two's complement negate r/m8
NEG r/m32            F7    /3     Two's complement negate r/m32
NOP                  90           No operation
NOT r/m8             F6    /2     Reverse each bit of r/m8
NOT r/m32            F7    /2     Reverse each bit of r/m32
OR AL,imm8           0C       ib  OR
OR EAX,imm32         0D       id  OR 
OR r/m8,imm8         80    /1 ib  OR 
OR r/m32,imm32       81    /1 id  OR 
OR r/m32,imm8        83    /1 ib  OR 
OR r/m8,r8           08    /r     OR 
OR r/m32,r32         09    /r     OR 
OR r8,r/m8           0A    /r     OR 
OR r32,r/m32         0B    /r     OR 
OUT imm8,AL          E6       ib  Output byte in AL to I/O(imm8)
OUT imm8,EAX         E7       ib  Output dword in EAX to I/O(imm8)
OUT DX,AL            EE           Output byte in AL to I/O(DX)
OUT DX,EAX           EF           Output dword in EAX to I/O(DX)
OUTS DX,m8           6E           Output byte from (E)SI to I/O(DX)
OUTS DX,m32          6F           Output dword from (E)SI to I/O (DX)
PACKSSWB mm,mm/m64   0F 63 /r     Pack with Signed Saturation
PACKSSDW mm,mm/m64   0F 6B /r     Pack with Signed Saturation
PACKUSWB mm,mm/m64   0F 67 /r     Pack with Unsigned Saturation
PADDB mm,mm/m64      0F FC /r     Add packed bytes 
PADDW mm,mm/m64      0F FD /r     Add packed words 
PADDD mm,mm/m64      0F FE /r     Add packed dwords 
PADDSB mm,mm/m64     0F EC /r     Add signed packed bytes 
PADDSW mm,mm/m64     0F ED /r     Add signed packed words 
PADDUSB mm,mm/m64    0F DC /r     Add unsigned pkd bytes 
PADDUSW mm,mm/m64    0F DD /r     Add unsigned pkd words 
PAND mm,mm/m64       0F DB /r     AND quadword from .. to ..
PANDN mm,mm/m64      0F DF /r     And qword from .. to NOT qw in mm
PCMPEQB mm,mm/m64    0F 74 /r     Packed Compare for Equal
PCMPEQW mm,mm/m64    0F 75 /r     Packed Compare for Equal
PCMPEQD mm,mm/m64    0F 76 /r     Packed Compare for Equal
PCMPGTB mm,mm/m64    0F 64 /r     Packed Compare for GT
PCMPGTW mm,mm/m64    0F 65 /r     Packed Compare for GT
PCMPGTD mm,mm/m64    0F 66 /r     Packed Compare for GT
PMADDWD mm,mm/m64    0F F5 /r     Packed Multiply and Add
PMULHW mm,mm/m64     0F E5 /r     Packed Multiply High
PMULLW mm,mm/m64     0F D5 /r     Packed Multiply Low
Pop m32              8F    /0     Pop m32
Pop r32              58+rd        Pop r32
Pop DS               1F           Pop DS
Pop ES               07           Pop ES
Pop SS               17           Pop SS
Pop FS               0F A1        Pop FS
Pop GS               0F A9        Pop GS
POPAD                61           Pop EDI,... and EAX
POPFD                9D           Pop Stack into EFLAGS Register
POR mm,mm/m64        0F EB /r     OR qword from .. to mm
PSLLW mm,mm/m64      0F F1 /r     Packed Shift Left Logical
PSLLW mm,imm8        0F 71 /6 ib  Packed Shift Left Logical
PSLLD mm,mm/m64      0F F2 /r     Packed Shift Left Logical
PSLLD mm,imm8        0F 72 /6 ib  Packed Shift Left Logical
PSLLQ mm,mm/m64      0F F3 /r     Packed Shift Left Logical
PSLLQ mm,imm8        0F 73 /6 ib  Packed Shift Left Logical
PSRAW mm,mm/m64      0F E1 /r     Packed Shift Right Arithmetic
PSRAW mm,imm8        0F 71 /4 ib  Packed Shift Right Arithmetic
PSRAD mm,mm/m64      0F E2 /r     Packed Shift Right Arithmetic
PSRAD mm,imm8        0F 72 /4 ib  Packed Shift Right Arithmetic
PSRLW mm,mm/m64      0F D1 /r     Packed Shift Right Logical 
PSRLW mm,imm8        0F 71 /2 ib  Packed Shift Right Logical 
PSRLD mm,mm/m64      0F D2 /r     Packed Shift Right Logical 
PSRLD mm,imm8        0F 72 /2 ib  Packed Shift Right Logical 
PSRLQ mm,mm/m64      0F D3 /r     Packed Shift Right Logical 
PSRLQ mm,imm8        0F 73 /2 ib  Packed Shift Right Logical 
PSUBB mm,mm/m64      0F F8 /r     Packed Subtract
PSUBW mm,mm/m64      0F F9 /r     Packed Subtract
PSUBD mm,mm/m64      0F FA /r     Packed Subtract
PSUBSB mm,mm/m64     0F E8 /r     Packed Subtract with Saturation
PSUBSW mm,mm/m64     0F E9 /r     Packed Subtract with Saturation
PSUBUSB mm,mm/m64    0F D8 /r     Packed Subtract Unsigned with S.
PSUBUSW mm,mm/m64    0F D9 /r     Packed Subtract Unsigned with S.
PUNPCKHBW mm,mm/m64  0F 68 /r     Unpack High Packed Data
PUNPCKHWD mm,mm/m64  0F 69 /r     Unpack High Packed Data
PUNPCKHDQ mm,mm/m64  0F 6A /r     Unpack High Packed Data
PUNPCKLBW mm,mm/m32  0F 60 /r     Unpack Low Packed Data
PUNPCKLWD mm,mm/m32  0F 61 /r     Unpack Low Packed Data
PUNPCKLDQ mm,mm/m32  0F 62 /r     Unpack Low Packed Data
Push r/m32           FF    /6     Push r/m32
Push r32             50+rd        Push r32
Push imm8            6A       ib  Push imm8
Push imm32           68       id  Push imm32
Push CS              0E           Push CS
Push SS              16           Push SS
Push DS              1E           Push DS
Push ES              06           Push ES
Push FS              0F A0        Push FS
Push GS              0F A8        Push GS
PUSHAD               60           Push All g-regs
PUSHFD               9C           Push EFLAGS
PXOR mm,mm/m64       0F EF /r     XOR qword
RCL r/m8,1           D0    /2     Rotate 9 bits left once
RCL r/m8,CL          D2    /2     Rotate 9 bits left CL times
RCL r/m8,imm8        C0    /2 ib  Rotate 9 bits left imm8 times
RCL r/m32,1          D1    /2     Rotate 33 bits left once
RCL r/m32,CL         D3    /2     Rotate 33 bits left CL times
RCL r/m32,imm8       C1    /2 ib  Rotate 33 bits left imm8 times
RCR r/m8,1           D0    /3     Rotate 9 bits right once
RCR r/m8,CL          D2    /3     Rotate 9 bits right CL times
RCR r/m8,imm8        C0    /3 ib  Rotate 9 bits right imm8 times
RCR r/m32,1          D1    /3     Rotate 33 bits right once
RCR r/m32,CL         D3    /3     Rotate 33 bits right CL times
RCR r/m32,imm8       C1    /3 ib  Rotate 33 bits right imm8 times
ROL r/m8,1           D0    /0     Rotate 8 bits r/m8 left once
ROL r/m8,CL          D2    /0     Rotate 8 bits r/m8 left CL times
ROL r/m8,imm8        C0    /0 ib  Rotate 8 bits r/m8 left imm8 times
ROL r/m32,1          D1    /0     Rotate 32 bits r/m32 left once
ROL r/m32,CL         D3    /0     Rotate 32 bits r/m32 left CL times
ROL r/m32,imm8       C1    /0 ib  Rotate 32 bits r/m32 left imm8 times
ROR r/m8,1           D0    /1     Rotate 8 bits r/m8 right once
ROR r/m8,CL          D2    /1     Rotate 8 bits r/m8 right CL times
ROR r/m8,imm8        C0    /1 ib  Rotate 8 bits r/m16 right imm8 times
ROR r/m32,1          D1    /1     Rotate 32 bits r/m32 right once
ROR r/m32,CL         D3    /1     Rotate 32 bits r/m32 right CL times
ROR r/m32,imm8       C1    /1 ib  Rotate 32 bits r/m32 right imm8 times
RDMSR                0F 32        Read from Model Specific Register
RDPMC                0F 33        Read Performance-Monitoring counters
RDTSC                0F 31        Read Time-Stamp Counter
REP INS m8,DX        F3 6C        Input ECX bytes from port DX into [(E)DI]
REP INS m32,DX       F3 6D        Input ECX dwords from port DX into [(E)DI]
REP MOVSB            F3 A4        Move ECX bytes from ESI to EDI
REP MOVSD            F3 A5        Move ECX dwords from ESI to EDI
REP MOVSW            F3 A5        Move ECX words from ESI to EDI
REP OUTS DX,m8       F3 6E        Output ECX bytes from ESI to port DX
REP OUTS DX,m32      F3 6F        Output ECX dwords from ESI to port DX
REP LODSB            F3 AC        Load ECX bytes from ESI to AL
REP LODSD            F3 AD        Load ECX dwords from ESI to EAX
REP LODSW            F3 AD        Load ECX words from ESI to AX
REP STOSB            F3 AA        Fill ECX bytes at EDI with AL
REP STOSD            F3 AB        Fill ECX dwords at EDI with EAX
REP STOSD            F3 AB        Fill ECX words at EDI with AX
REPE CMPSB           F3 A6        Find nonmatching bytes in m and m
REPE CMPSD           F3 A7        Find nonmatching dwords in m and m
REPE CMPSW           F3 A7        Find nonmatching words in m and m
REPE SCASB           F3 AE        Find non-AL byte starting at 
REPE SCASD           F3 AF        Find non-EAX dword starting at
REPE SCASW           F3 AF        Find non-AX dword starting at  
REPNE CMPSB          F2 A6        Find matching bytes in m and m
REPNE CMPSD          F2 A7        Find matching dwords in m and m
REPNE CMPSW          F2 A7        Find matching words in m and m
REPNE SCASB          F2 AE        Find AL, starting at EDI
REPNE SCASD          F2 AF        Find EAX, starting at EDI
REPNE SCASW          F2 AF        Find AX, starting at EDI
RET                  C3           Near return 
RET                  CB           Far return 
RET imm16            C2       iw  Near return, Pop imm16 bytes from stack
RET imm16            CA       iw  Far return, Pop imm16 bytes from stack
RSM                  0F AA        Resume from System Management
SAHF                 9E           Store AH into Flags
SAL r/m8,1           D0    /4     Shift Arithmetic Left
SAL r/m8,CL          D2    /4     Shift Arithmetic Left
SAL r/m8,imm8        C0    /4 ib  Shift Arithmetic Left
SAL r/m32,1          D1    /4     Shift Arithmetic Left
SAL r/m32,CL         D3    /4     Shift Arithmetic Left
SAL r/m32,imm8       C1    /4 ib  Shift Arithmetic Left
SAR r/m8,1           D0    /7     Shift Arithmetic Right
SAR r/m8,CL          D2    /7     Shift Arithmetic Right
SAR r/m8,imm8        C0    /7 ib  Shift Arithmetic Right
SAR r/m32,1          D1    /7     Shift Arithmetic Right
SAR r/m32,CL         D3    /7     Shift Arithmetic Right
SAR r/m32,imm8       C1    /7 ib  Shift Arithmetic Right
SHL r/m8,1           D0    /4     Shift Logical Left
SHL r/m8,CL          D2    /4     Shift Logical Left
SHL r/m8,imm8        C0    /4 ib  Shift Logical Left
SHL r/m32,1          D1    /4     Shift Logical Left
SHL r/m32,CL         D3    /4     Shift Logical Left
SHL r/m32,imm8       C1    /4 ib  Shift Logical Left
SHR r/m8,1           D0    /5     Shift Logical Right
SHR r/m8,CL          D2    /5     Shift Logical Right
SHR r/m8,imm8        C0    /5 ib  Shift Logical Right
SHR r/m32,1          D1    /5     Shift Logical Right
SHR r/m32,CL         D3    /5     Shift Logical Right
SHR r/m32,imm8       C1    /5 ib  Shift Logical Right
SBB AL,imm8          1C       ib  Subtract with borrow 
SBB EAX,imm32        1D       id  Subtract with borrow 
SBB r/m8,imm8        80    /3 ib  Subtract with borrow 
SBB r/m32,imm32      81    /3 id  Subtract with borrow 
SBB r/m32,imm8       83    /3 ib  Subtract with borrow 
SBB r/m8,r8          18    /r     Subtract with borrow 
SBB r/m32,r32        19    /r     Subtract with borrow 
SBB r8,r/m8          1A    /r     Subtract with borrow 
SBB r32,r/m32        1B    /r     Subtract with borrow 
SCASB                AE           Scan String 
SCASD                AF           Scan String
SCASD                AF           Scan String
SETA r/m8            0F 97 /r     Set byte if above 
SETAE r/m8           0F 93 /r     Set byte if above or equal
SETB r/m8            0F 92 /r     Set byte if below 
SETBE r/m8           0F 96 /r     Set byte if below or equal 
SETE r/m8            0F 94 /r     Set byte if equal 
SETG r/m8            0F 9F /r     Set byte if greater 
SETGE r/m8           0F 9D /r     Set byte if greater or equal
SETL r/m8            0F 9C /r     Set byte if less 
SETLE r/m8           0F 9E /r     Set byte if less or equal 
SETNE r/m8           0F 95 /r     Set byte if not equal 
SETNO r/m8           0F 91 /r     Set byte if not overflow 
SETNS r/m8           0F 99 /r     Set byte if not sign 
SETO r/m8            0F 90 /r     Set byte if overflow 
SETPE r/m8           0F 9A /r     Set byte if parity even 
SETPO r/m8           0F 9B /r     Set byte if parity odd 
SETS r/m8            0F 98 /r     Set byte if sign 
SGDT m               0F 01 /0     Store GDTR to m
SIDT m               0F 01 /1     Store IDTR to m
SHLD r/m32,r32,imm8  0F A4 /r ib  Double Precision Shift Left
SHLD r/m32,r32,CL    0F A5 /r     Double Precision Shift Left
SHRD r/m32,r32,imm8  0F AC /r ib  Double Precision Shift Right
SHRD r/m32,r32,CL    0F AD /r     Double Precision Shift Right
SLDT r/m32           0F 00 /0     Store Local Descriptor Table Register
SMSW r/m32           0F 01 /4     Store Machine Status Word
STC                  F9           Set Carry Flag
STD                  FD           Set Direction Flag
STI                  FB           Set Interrup Flag
STOSB                AA           Store String (byte)
STOSD                AB           Store String (dWord)
STOSW                AB           Store String (word)
STR r/m16            0F 00 /1     Store Task Register
SUB AL,imm8          2C       ib  Subtract 
SUB EAX,imm32        2D       id  Subtract 
SUB r/m8,imm8        80    /5 ib  Subtract 
SUB r/m32,imm32      81    /5 id  Subtract 
SUB r/m32,imm8       83    /5 ib  Subtract 
SUB r/m8,r8          28    /r     Subtract 
SUB r/m32,r32        29    /r     Subtract 
SUB r8,r/m8          2A    /r     Subtract 
SUB r32,r/m32        2B    /r     Subtract 
TEST AL,imm8         A8       ib  Logical Compare
TEST EAX,imm32       A9       id  Logical Compare
TEST r/m8,imm8       F6    /0 ib  Logical Compare
TEST r/m32,imm32     F7    /0 id  Logical Compare
TEST r/m8,r8         84    /r     Logical Compare
TEST r/m16,r16       85    /r     Logical Compare
TEST r/m32,r32       85    /r     Logical Compare
UD2                  0F 0B        Undifined Instruction
VERR r/m16           0F 00 /4     Verify a Segment for Reading
VERW r/m16           0F 00 /5     Verify a Segment for Writing
WAIT                 9B           Wait
FWAIT                9B           Wait
WBINVD               0F 09        Write Back and Invalidate Cache
WRMSR                0F 30        Write to Model Specific Register
XADD r/m8,r8         0F C0 /r     Exchange and Add
XADD r/m16,r16       0F C1 /r     Exchange and Add
XADD r/m32,r32       0F C1 /r     Exchange and Add
XCHG EAX,r32         90+rd        Exchange r32 with EAX
XCHG r32,EAX         90+rd        Exchange EAX with r32
XCHG r/m8,r8         86    /r     Exchange byte 
XCHG r8,r/m8         86    /r     Exchange byte 
XCHG r/m32,r32       87    /r     Exchange doubleword 
XCHG r32,r/m32       87    /r     Exchange doubleword 
XLAT m8              D7           Table Look-up Translation
XOR AL,imm8          34       ib  Logical Exclusive OR
XOR EAX,imm32        35       id  Logical Exclusive OR
XOR r/m8,imm8        80    /6 ib  Logical Exclusive OR
XOR r/m32,imm32      81    /6 id  Logical Exclusive OR
XOR r/m32,imm8       83    /6 ib  Logical Exclusive OR
XOR r/m8,r8          30    /r     Logical Exclusive OR
XOR r/m32,r32        31    /r     Logical Exclusive OR
XOR r8,r/m8          32    /r     Logical Exclusive OR
XOR r32,r/m32        33    /r     Logical Exclusive OR" EOS]

;;
  Each Name must be 16 Bytes aligned for the search. Any error breaks all of the
  downward searches down.
  
  A '<' before the Name indicates a substitution. Example, 'AAD' is in the same
  B_U_Asm Description as 'AAA'.
;;

[<16 OpCodeList: B$

'AAA             AAS             AAM             AAD             ADC             '
'ADD             ADDPD           ADDPS           ADDSD           ADDSS           '
'ADDSUBPD        ADDSUBPS        AND             ANDNPD          ANDNPS          '
'ANDPD           ANDPS           ARPL            '

'BOUND           BSF             BSR             BSWAP           BT              '
'BTC             BTR             BTS             '

'Call            CBW             CWD             CWDE            CDQ             '
'CLC             CLD             CLI             CLTS            CLFLUSH         '
'CMC             CMP             '
'CMPccPD        <CMPEQPD        <CMPLEPD        <CMPLTPD        <CMPNEQPD       <'
'CMPNLEPD       <CMPNLTPD       <CMPORDPD       <CMPPD          <CMPUNORDPD      '
'CMPccPS        <CMPEQPS        <CMPLEPS        <CMPLTPS        <CMPNEQPS       <'
'CMPNLEPS       <CMPNLTPS       <CMPORDPS       <CMPPS          <CMPUNORDPS      '
'CMPccSD        <CMPEQSD        <CMPLESD        <CMPLTSD        <CMPNEQSD       <'
'CMPNLESD       <CMPNLTSD       <CMPORDSD       <CMPUNORDSD      '
'CMPccSS        <CMPEQSS        <CMPLESS        <CMPLTSS        <CMPNEQSS       <'
'CMPNLESS       <CMPNLTSS       <CMPORDSS       <CMPSS          <CMPUNORDSS      '
'CMPSB           CMPSW           CMPSD           CMPXCHG         CMPXCHG8B       '
'CMOVcc         <FCMOVB         <FCMOVBE        <'
'FCMOVE         <FCMOVNB        <FCMOVNBE       <FCMOVNE        <FCMOVNU        <'
'FCMOVU          '
'COMISD          COMISS          CPUID           '

'CVTDQ2PD        CVTDQ2PS        CVTPD2DQ        CVTPD2PI        CVTPD2PS        '
'CVTPI2PD        CVTPI2PS        CVTPS2DQ        CVTPS2PD        CVTPS2PI        '
'CVTSD2SI        CVTSD2SS        CVTSI2SD        CVTSI2SS        CVTSS2SD        '
'CVTSS2SI        CVTTPD2DQ       CVTTPD2PI       CVTTPS2DQ       CVTTPS2PI       '
'CVTTSD2SI       CVTTSS2SI       '

'DAA             DAS             DEC             DIV             DIVPD           '
'DIVPS           DIVSD           DIVSS           '

'EMMS            ENTER           '

'F2XM1           FABS            FADD            FADDP           FBLD            '
'FBSTP           FCHS            FCLEX           '
'FCMOVcc        <FCMOVB         <FCMOVBE        <'
'FCMOVE         <FCMOVNB        <FCMOVNBE       <FCMOVNE        <FCMOVNU        <'
'FCMOVU          '
'FCOM            FCOMP           FCOMPP          FCOMI           FCOMIP          '
'FCOS            FDECSTP         FDIV            FDIVP           FDIVR           '
'FDIVRP          FEMMS           FFREE           FIADD           FICOM           '
'FICOMP          FIDIV           FIDIVR          FILD            FIST            '
'FISTP           FISTTP          FIMUL           FINCSTP         FINIT           '
'FNINIT          FISUB           FISUBR          FLD             '
'FLDxx          <FLD1           <FLDL2E         <FLDL2T         <FLDLG2         <'
'FLDLN2         <FLDZ           <FLDPI           '
'FLDCW           FLDENV          FMUL            FMULP           FNOP            '
'FNSAVE          FNSTCW          FNSTENV         FPATAN          FPTAN           '
'FNSTSW          '
'FPREM           FPREM1          FRNDINT         FRSTOR          FSAVE           '
'FSCALE          FSETPM          FSIN            FSINCOS         FSQRT           '
'FST             FSTP            FSTCW           FSTENV          FSTSW           '
'FSUB            FSUBP           FSUBR           FSUBRP          FTST            '
'FUCOMxx        <FUCOMP         <FUCOMPP        <FUCOMI         <FUCOMIP         '
'FWAIT           FXAM            FXCH            FXRSTOR         FXSAVE          '
'FXTRACT         FYL2X           FYL2XP1         '

'HADDPD          HADDPS          HSUBPD          HSUBPS          HLT             '

'IDIV            IMUL            INC             IN              INSB            '
'INSD            INSW            INT             INT01           INT1            '
'INT3            ICEBP           INTO            INVD            INVLPG          '
'IRET            IRETW           IRETD           '

'Jcc            <JA             <JAE            <JB             <JBE            <'
'JC             <JE             <JG             <JGE            <JL             <'
'JLE            <JNA            <JNAE           <JNB            <JNBE           <'
'JNC            <JNE            <JNG            <JNGE           <JNL            <'
'JNLE           <JNO            <JNP            <JNS            <JNZ            <'
'JO             <JP             <JPE            <JPO            <JS             <'
'JZ              '
'JCXZ            JECXZ           JMP             '

'LAHF            LAR             LDDQU           LDMXCSR         LDS             '
'LES             LFS             LGS             LSS             LEA             '
'LEAVE           LFENCE          LGDT            LIDT            LLDT            '
'LMSW            LODSB           LODSW           LODSD           LOCK            '
'LOOP            LOOPE           LOOPZ           LOOPNE          LOOPNZ          '
'LSL             LTR             '

'MASKMOVDQU      MASKMOVQ        MAXPD           MAXPS           MAXSD           '
'MAXSS           MFENCE          MINPD           MINPS           MINSD           '
'MINSS           MONITOR         Mov             MOVAPD          MOVAPS          '
'MOVD            MOVDDUP         MOVDQ2Q         MOVDQA          MOVDQU          '
'MOVHLPS         MOVHPD          MOVHPS          MOVLHPS         MOVLPD          '
'MOVLPS          MOVMSKPD        MOVMSKPS        MOVNTDQ         MOVNTI          '
'MOVNTPD         MOVNTPS         MOVNTQ          MOVQ            MOVQ2DQ         '
'MOVSB           MOVSD           MOVSHDUP        MOVSLDUP        MOVSW           '
'MOVSS           MOVSX           MOVUPD          MOVUPS          MOVZX           '
'MUL             MULPD           MULPS           MULSD           MULSS           '
'MWAIT           '

'NEG             NOT             NOP             NOPE            '

'OR              ORPD            ORPS            OUT             OUTSB           '
'OUTSW           OUTSD           '

'PACKSSDW        PACKSSWB        PACKUSWB        PADDB           PADDW           '
'PADDD           PADDQ           PADDSB          PADDSW          PADDUSB         '
'PADDUSW         PAND            PANDN           PAUSE           PAVGB           '
'PAVGW           PAVGUSB         '
'PCMPxxx        <PCMPEQB        <PCMPEQD        <PCMPEQW        <'
'PCMPGTB        <PCMPGTD        <PCMPGTW         '
'PEXTRW          PF2ID           PF2IW           PFACC           PFADD           '
'PFCMPxx        <PFCMPEQ        <PFCMPGE        <PFCMPGT         '
'PFMAX           PFMIN           PFMUL           PFNACC          PFPNACC         '
'PFRCP           PFRCPIT1        PFRCPIT2        PFRSQIT1        PFRSQRT         '
'PFSUB           PFSUBR          PI2FD           PI2FW           PINSRW          '
'PMADDWD         PMAXSW          PMAXUB          PMINSW          PMINUB          '
'PMOVMSKB        PMULHRWA        PMULHUW         PMULHW          PMULLW          '
'PMULUDQ         Pop             POPA            POPAD           POPF            '
'POR             PREFETCH        '
'PREFETCHh      <PREFETCHNTA    <PREFETCHT0     <PREFETCHT1     <PREFETCHT2      '
'PSADBW          PSHUFD          PSHUFHW         PSHUFLW         PSHUFW          '
'PSLLDQ          '
'PSLLx          <PSLLW          <PSLLD          <PSLLQ           '
'PSRAx          <PSRAW          <PSRAD          <PSRAQ           '
'PSRLDQ          '
'PSRLx          <PSRLW          <PSRLD          <PSRLQ           '
'PSUBx          <PSUBB          <PSUBW          <PSUBD          <PSUBQ           '
'PSUBxx         <PSUBSB         <PSUBSW         <PSUBUSB        <PSUBUSW         '
'PSWAPD          '
'PUNPCKhxx      <PUNPCKHBW      <PUNPCKHWD      <PUNPCKHDQ      <PUNPCKHQDQ     <'
'PUNPCKLBW      <PUNPCKLWD      <PUNPCKLDQ      <PUNPCKLQDQ      '
'Push            PUSHA           PUSHAD          PUSHF           PXOR            '

'RCL             RCR             RCPPS           RCPSS           RDMSR           '
'RDPMC           RDTSC           REP             RET             RETF            '
'RETN            ROL             ROR             '
'RSDC            RSLDT           RSM             RSQRTPS         RSQRTSS         '
'RSTS            '

'SAHF            SAL             SAR             SBB             SCASB           '
'SCASW           SCASD           '
'SETcc           '
'SFENCE          SGDT            SIDT            SLDT            SHL             '
'SHR             SHLD            SHRD            SHUFPD          SHUFPS          '
'SMSW            SQRTPD          SQRTPS          SQRTSD          SQRTSS          '
'STC             STD             STI             STMXCSR         STOSB           '
'STOSW           STOSD           STR             SUB             SUBPD           '
'SUBPS           SUBSD           SUBSS           SYSCALL         SYSENTER        '
'SYSEXIT         SYSRET          '

'TEST            '

'UCOMISD         UCOMISS         UD0             UD1             UD2             '
'UNPCKHPD        UNPCKHPS        UNPCKLPD        UNPCKLPS        '

'VERR            VERW            '

'WAIT            WBINVD          WRMSR           '

'XADD            XCHG            XLATB           XOR             XORPD           '
'XORPS           '

0 0 0 0  0 0 0 0  0 0 0 0  0 0 0 0]


____________________________________________________________________________________________
____________________________________________________________________________________________

DataToStructure:

    Call 'USER32.DialogBoxParamA' D$H.Instance,
                                  32500,
                                  &NULL,
                                  DataToStructureProc,
                                  &NULL

ret
____________________________________________________________________________________________


[DataTextTable: D$ ?
 StructureTextTable: D$ ?
 H.DataToStructureDialog: D$ ?]

Proc DataToStructureProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_COMMAND
        Mov eax D@wParam | and eax 0FFFF
        If eax = &IDCANCEL

L5:         Call VirtualFree DataTextTable

            Call VirtualFree StructureTextTable

            Call 'USER32.EndDialog' D@hwnd 0
        Else_If eax = &IDOK
            Call SaveStructureToClipBoard | jmp L5<
        Else_If eax = &IDHELP
            Call Help, B_U_AsmName, StructuresHelp, ContextHlpMessage
        Else_If eax = 5     ; [ >>>>>>>> ]
            Call FromDataToStructure
      ;  Else_If eax = 6     ; [ <<<<<<<< ]
      ;      Call FromStructureToData
        End_If

    ...Else_If D@msg e &WM_INITDIALOG

        Call VirtualAlloc DataTextTable,
                          01000

        Call VirtualAlloc StructureTextTable,
                          01000

        Move D$H.DataToStructureDialog D@hwnd

    ...Else_If D@msg e &WM_CTLCOLOREDIT
        ; Control of output

    ...Else
        popad | Mov eax &FALSE | ExitP

    ...End_If

    popad | Mov eax &TRUE
EndP


[DisScale: D$ ?
 EquateValue: D$ ?
 FirstDataLabel: D$ ?]

;;
[DataTest:
 Val1: 0
 Val2: 0
 Val3: 0]

[DataXTest: D$ ? # 8]

[Data2Test:
 Val21: B$ 0
 Val22: 0
 Val23: 0]
;;

SaveStructureToClipBoard:
    Mov eax D$StructureTextTable
    While B$eax > 0 | inc eax | end_While
    sub eax D$StructureTextTable | On eax = 0, ret
    Mov D$TheClipLenght eax

    Call 'USER32.OpenClipboard' D$H.MainWindow | cmp eax 0 | je L9>>
    Call 'USER32.EmptyClipboard' | cmp eax 0 | je L8>>

    Mov ecx D$TheClipLenght | shl ecx 2               ; *4 > room for Generic Names
    Push ecx
        Call 'KERNEL32.GlobalAlloc' &GMEM_DDESHARE ecx | cmp eax 0 | jne L1>  ; > eax = handle
        Pop eax | jmp L8>>
L1:     Mov D$hBlock eax
        Call 'KERNEL32.GlobalLock' eax                                       ; > eax = adress
    Pop ecx
    shr ecx 2                                                   ; restore true data size
    Mov edi eax, esi D$StructureTextTable

    While B$esi > 0 | movsb | End_While | Mov eax 0 | stosd

    Call 'KERNEL32.GlobalUnlock' D$hBlock
    Call 'USER32.SetClipboardData' &CF_TEXT  D$hBlock
L8: Call 'USER32.CloseClipboard'
L9: ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Loaders         ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
________________________________________________________________________________________
________________________________________________________________________________________

                         ; Loaders for non-edited Resources
________________________________________________________________________________________
________________________________________________________________________________________

; read new open PE Resources:

[ResourcePointersSecurity: D$ ? # 10]

; Each Record of these Lists is: ID / Ptr / Size.

[CursorList: D$ ? # MAXCURSOR]
[CursorListPtr: D$ CursorList]
[GroupCursorList: D$ ? # MAXCURSOR]
[GroupCursorListPtr: D$ GroupCursorList]
[IconList: D$ ? # MAXICON]
[IconListPtr: D$ IconList]
[MenuList: D$ ? # MAXMENU]
[MenuListPtr: D$ MenuList]
[DialogList: D$ ? # MAXDIALOG]
[DialogListPtr: D$ DialogList]
[StringsList: D$ ? # MAXSTRINGS]
[StringsListPtr: D$ StringsList]
[GroupIconList: D$ ? # MAXICON]
[GroupIconListPtr: D$ GroupIconList]
[WaveList: D$ ? # MAXWAVE]
[WaveListPtr: D$ WaveList]
[AviList: D$ ? # MAXAVI]
[AviListPtr: D$ AviList]
[RCdataList: D$ ? # MAXRCDATA]
[RCdataListPtr: D$ RCdataList]
[BitMapList: D$ ? # MAXBITMAP]
[BitMapListPtr: D$ BitMapList]

[OtherList: D$ ?
 OtherListPtr: D$ ?]

[WaveFilesFilters: B$ 'Wave Files' EOS '*.wav' EOS 0
 WaveFilesTitle: B$ 'Chose a Wave File' EOS
 AviFilesFilters: B$ 'Avi Files' EOS   '*.avi' EOS 0
 AviFilesTitle: B$ 'Choose an Avi File' EOS
 RCDataFilesFilters: B$ 'AnyThing' EOS  '*.*' EOS 0
 RCDataFilesTitle: B$ 'Choose a File' EOS
 CursorFilesFilters: B$ 'Cursor Files' EOS   '*.cur' EOS 0
 CursorFilesTitle: B$ 'Choose a Cursor File' EOS
 IconFilesFilters: B$ 'Icon Files' EOS   '*.Ico' EOS 0
 IconFilesTitle: B$ 'Choose an Icon File' EOS
 DialogFilesFilters: B$ 'Dlg Files' EOS, '*.dlg' EOS, 0
 BinDialogFilesFilters: B$ 'bdf Files' EOS, '*.bdf' EOS, 0
 BinMenuFilesFilters: B$ 'bmf Files' EOS, '*.bmf' EOS, 0
 DialogFilesTitle: B$ 'Choose a Dialog Template File' EOS]

[OtherChoosenFile: B$ ? # &MAX_PATH]
[OtherFileFilter: B$ ? # &MAX_PATH]
[OtherSourceFilterPtr: B$ ? # &MAX_PATH]
[OtherSaveFilter: B$ ? # &MAX_PATH]

[OtherOpenStruc: len
 OtherhwndFileOwner: D$ 0
 OtherhInstance: D$ 0
 OtherFilesFilters: D$ 0
 D$ OtherFileFilter
 D$ &MAX_PATH
 D$ OtherSourceFilterPtr
 D$ OtherSaveFilter
 D$ &MAX_PATH
 D$ OtherChoosenFile
 D$ &MAX_PATH
 D$ 0
 OpenOtherFileTitle: D$ 0
 @OtherFlags: D$  0281804 ; for read 0280006 : for write !!! WinEquates !!!
 D$ 0  0  0  0  0]

[H.OtherSource: D$ ?
 OtherFileLen: D$ ?
 OtherFilePtr: D$ ?]

ReadRCData:
    Mov D$OtherFilesFilters RCDataFilesFilters
    Mov D$OpenOtherFileTitle RCDataFilesTitle
    Mov D$OtherList RcDataList | Move D$OtherListPtr D$RCDataListPtr
    Call ReadOtherFile
        If D$OtherSaveFilter = 0
            Mov D$OtherList 0,  D$OtherListPtr 0 | ret
        End_If
        Call AskForResID | add D$RCDataListPtr 12
    Call CloseOtherFilesRead
ret


SaveRcData:
    If D$RCDataList = 0
        Call 'USER32.MessageBoxA' D$H.MainWindow, NoRcData, Argh, &MB_OK+&MB_SYSTEMMODAL | ret
    End_If

    Mov D$WhatDialogListPtr RcDataList,  D$OkDialogFlag &FALSE
    add D$WhatDialogListPtr 4

    Call 'USER32.CreateDialogParamA' D$H.Instance, 1000, &NULL, EmptyProc, &NULL
    Mov D$H.EmptyDialog eax


    .While B$OkDialogFlag = &FALSE
        Call SetRcDataTitle | Call ShowHexa
        Call SetNextChoiceID
        Call 'USER32.DialogBoxIndirectParamA' D$H.Instance, ChoiceBar, D$H.MainWindow,
                                              ChoiceDialogBoxProc, RcDataList
        .If D$OkDialogFlag = &VK_ESCAPE
            jmp L9>>
        .Else_If D$WhatDialogListPtr < RCDataList
            add D$WhatDialogListPtr 12
            Call SetNextChoiceID
        .Else
            Mov esi D$WhatDialogListPtr
            If D$esi = 0
                sub D$WhatDialogListPtr 12
                Call SetNextChoiceID
            End_If
        .End_If
   .End_While

    Call 'USER32.MessageBoxA' D$H.MainWindow, SaveRc, Sure, &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL

    Push eax
        Call 'USER32.EndDialog' D$H.EmptyDialog &NULL
    Pop eax

   .If eax = &IDYES
        Mov D$OpenDlg@lpstrFilter RcFilesFilters
        Call 'Comdlg32.GetSaveFileNameA' OpenDlg
        Mov D$OpenDlg@lpstrFilter DlgFilesFilters
        On eax = &FALSE, ret

        Call 'KERNEL32.CreateFileA' SaveDlgFilter &GENERIC_WRITE,
                                &FILE_SHARE_READ__&FILE_SHARE_WRITE, 0,
                                &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0

        If eax = &INVALID_HANDLE_VALUE

            Call MessageBox D$BusyFilePtr

ret

        End_If

        Mov D$H.Destination eax, D$NumberOfReadBytes 0
        Mov esi D$WhatDialogListPtr, ecx D$esi+4, esi D$esi

        Call 'KERNEL32.WriteFile' D$H.Destination, esi, ecx, NumberOfReadBytes  0

        Call 'KERNEL32.CloseHandle' D$H.Destination | Mov D$H.Destination 0
   .End_If

L9: ret


[NoRcData: B$ 'No RC Data Resources in this PE' EOS]
[KillRc: B$ 'Delete this Rc Data Resource?' EOS]
[SaveRc: B$ 'Save this RC Resource to Disk?' EOS]
[IdTitle: B$ 'RC Data ID: ' IdTitleID: B$ '       ' EOS]

SetRcDataTitle:
    Mov eax D$WhatDialogListPtr, eax D$eax-4, edi IdTitleID
    Call TransDwordToAsciiDecimal
    Call 'USER32.SendMessageA' D$H.EmptyDialog &WM_SETTEXT 0 IdTitle
ret


ShowHexa:
    Mov eax D$WhatDialogListPtr, esi D$eax, ecx D$eax+4
    shl ecx 3 | On ecx > 0FF00, Mov ecx 0FF00

    Call VirtualAlloc TempoMemPointer,
                      ecx

    Mov edi D$TempoMemPointer

    shr ecx 3 | sub ecx 001111 | or ecx 001111
    Push edi
L0:     lodsb | shr al 4 | add al '0' | On al > '9', add al 7 | stosb
        dec esi | lodsb | and al 0F | add al '0' | On al > '9', add al 7 | stosb
        Mov al SPC | stosb
        test ecx 00111 NOT_ZERO L1>
            Mov al SPC | stosb
        test ecx 001111 NOT_ZERO L1>
           sub esi 16
           Push ecx
               Mov ecx 16
T0:            lodsb | On al < SPC, Mov al '.' | stosb | loop T0<
           Pop ecx
           Mov ax 0A0D | stosw
L1:     loop L0<
    Pop edi

    Call 'USER32.SetDlgItemTextA' D$H.EmptyDialog, 100, edi
ret


DeleteRcData:
    If D$RCDataList = 0
        Call 'USER32.MessageBoxA' D$H.MainWindow, NoRcData, Argh, &MB_OK+&MB_SYSTEMMODAL | ret
    End_If

    Mov D$WhatDialogListPtr RcDataList,  D$OkDialogFlag &FALSE
    add D$WhatDialogListPtr 4
; Tag Dialog 1000
    Call 'USER32.CreateDialogParamA' D$H.Instance, 1000, &NULL, EmptyProc, &NULL
    Mov D$H.EmptyDialog eax

    .While B$OkDialogFlag = &FALSE
        Call SetRcDataTitle | Call ShowHexa
        Call SetNextChoiceID
        Call 'USER32.DialogBoxIndirectParamA' D$H.Instance, ChoiceBar, D$H.MainWindow, ChoiceDialogBoxProc, RcDataList

        .If D$OkDialogFlag = &VK_ESCAPE
            jmp L9>>
        .Else_If D$WhatDialogListPtr < RCDataList
            add D$WhatDialogListPtr 12
            Call SetNextChoiceID
        .Else
            Mov esi D$WhatDialogListPtr
            If D$esi = 0
                sub D$WhatDialogListPtr 12 ;| Mov esi D$WhatDialogListPtr
                Call SetNextChoiceID
            End_If
        .End_If
   .End_While

   Call 'USER32.MessageBoxA' D$H.MainWindow, KillRc, Sure, &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL
   If eax = &IDYES
        sub D$WhatDialogListPtr 4
        Mov esi D$WhatDialogListPtr, edi esi | add esi 12
        Mov eax D$WhatDialogListPtr | sub eax RCDataList | shr eax 2 | Mov ecx 300 | sub ecx eax
        rep movsd
        sub D$RCDataListPtr 12
   End_If

L9: Call 'USER32.EndDialog' D$H.EmptyDialog &NULL
ret


ReadWaveFile:
    Mov D$OtherFilesFilters WaveFilesFilters
    Mov D$OpenOtherFileTitle WaveFilesTitle
    Mov D$OtherList WaveList | Move D$OtherListPtr D$WaveListPtr
    Call ReadOtherFile
        If D$OtherSaveFilter = 0
            Mov D$OtherList 0,  D$OtherListPtr 0 | ret
        End_If
        Call AskForResID | add D$WaveListPtr 12
    Call CloseOtherFilesRead
ret


[KillWave: B$ 'Delete this Wave Resource?' EOS]
[NoWave: B$ 'No Wave Resources in this PE' EOS]
[H.TempoWaveFile: D$ ?]
[TempoWaveFile: B$ 'Wave$$$.Wav' EOS]

DeleteWave:
    If D$WaveList = 0
        Call 'USER32.MessageBoxA' D$H.MainWindow, NoWave, Argh, &MB_OK+&MB_SYSTEMMODAL | ret
    End_If

    Mov D$WhatDialogListPtr WaveList,  D$OkDialogFlag &FALSE
    add D$WhatDialogListPtr 4

    .While B$OkDialogFlag = &FALSE
        Call 'KERNEL32.CreateFileA' TempoWaveFile &GENERIC_WRITE, 0, 0,
                                    &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0
        Mov D$H.TempoWaveFile eax
        Mov esi D$WhatDialogListPtr
        Call 'KERNEL32.WriteFile' D$H.TempoWaveFile D$esi D$esi+4 NumberOfReadBytes &NULL
        Call 'KERNEL32.CloseHandle' D$H.TempoWaveFile
        Call 'WINMM.PlaySound' TempoWaveFile &NULL  &SND_ASYNC__&SND_FILENAME
        Call SetNextChoiceID
        Call 'USER32.DialogBoxIndirectParamA' D$H.Instance, ChoiceBar, D$H.MainWindow, ChoiceDialogBoxProc, WaveList
        Call 'WINMM.PlaySound' &NULL &NULL &NULL
        .If D$OkDialogFlag = &VK_ESCAPE
            jmp L9>>
        .Else_If D$WhatDialogListPtr < WaveList
            add D$WhatDialogListPtr 12
            Call SetNextChoiceID
        .Else
            Mov esi D$WhatDialogListPtr
            If D$esi = 0
              sub D$WhatDialogListPtr 12 | Mov esi D$WhatDialogListPtr
              Call SetNextChoiceID
            End_If
        .End_If
   .End_While

    Call 'USER32.MessageBoxA' D$H.MainWindow, KillWave, Sure, &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL
    If eax = &IDYES
        sub D$WhatDialogListPtr 4
        Mov esi D$WhatDialogListPtr, edi esi | add esi 12
        Mov eax D$WhatDialogListPtr | sub eax WaveList | shr eax 2 | Mov ecx 300 | sub ecx eax
        rep movsd
        sub D$WaveListPtr 12
    End_If

L9: Call 'KERNEL32.DeleteFileA' TempoWaveFile
ret


ReadAviFile:
    Mov D$OtherFilesFilters AviFilesFilters
    Mov D$OpenOtherFileTitle AviFilesTitle
    Mov D$OtherList AviList | Move D$OtherListPtr D$AviListPtr
    Call ReadOtherFile
        If D$OtherSaveFilter = 0
            Mov D$OtherList 0,  D$OtherListPtr 0 | ret
        End_If

        Call AskForResID | add D$AviListPtr 12
    Call CloseOtherFilesRead
ret


[TempoCursorMem: D$ ?
 CursorHotSpot: D$ ?]
[BadCurFile: B$ 'Bad or multiple Cursor(s) file' EOS]
[BadIcoFile: B$ 'Bad or multiple Icon(s) file' EOS]

ReadCursor:
    Mov D$OtherFilesFilters CursorFilesFilters
    Mov D$OpenOtherFileTitle CursorFilesTitle
    Mov D$OtherList CursorList | Move D$OtherListPtr D$CursorListPtr

    Move D$OtherhwndFileOwner D$H.MainWindow, D$OtherhInstance D$H.Instance

    Mov edi OtherSaveFilter, ecx 260, eax 0 | rep stosd
    Call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc
        If D$OtherSaveFilter = 0
            Mov D$OtherList 0,  D$OtherListPtr 0 | ret
        End_If

    Call 'KERNEL32.CreateFileA' OtherSaveFilter &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE

      Call MessageBox D$BusyFilePtr

ret  ; return to caller of caller

    Else
      Mov D$H.OtherSource eax
    End_If

    Call 'KERNEL32.GetFileSize'  eax 0
    Mov D$OtherFileLen eax

    Call VirtualAlloc OtherFilePtr,
                      eax

    Call 'KERNEL32.ReadFile' D$H.OtherSource D$OtherFilePtr,
                            eax NumberOfReadBytes 0

    Mov eax D$OtherFilePtr
    If D$eax+2 <> 010002
        Call 'USER32.MessageBoxA' D$H.MainWindow, BadCurFile, Argh, &MB_OK+&MB_SYSTEMMODAL

        Call VirtualFree OtherFilePtr

ret

    End_If

  ; We write both the RT_CURSOR and the RT_GROUP_CURSOR:
    Call VirtualAlloc TempoCursorMem,
                      D$OtherFileLen

    Call VirtualAlloc TempoMemPointer,
                      20

    Mov edi D$GroupCursorListPtr, eax D$TempoMemPointer, D$edi+4 eax, D$edi+8 20

    Mov edi eax                                       ; edi > RT_GROUP_CURSOR mem

    Mov esi D$OtherFilePtr

    Mov ecx 20 | rep movsb
    Move D$CursorHotSpot D$edi-10                     ; x/y hot spot
    Push edi

    Mov esi D$OtherFilePtr | add esi 016
    sub D$OtherFileLen 012 | Mov ecx D$OtherFileLen
    Mov eax D$CursorHotSpot                           ; PE cursors need the hot spot in data:
    Mov edi D$TempoCursorMem | stosd | rep movsb

    Call VirtualFree OtherFilePtr

    Move D$OtherFilePtr D$TempoCursorMem

    Call AskForResID | Call CloseOtherFilesRead

    Mov esi D$OtherListPtr | lodsd                    ; rewrite ID to GroupCursor:
    Mov edi D$GroupCursorListPtr | stosd
    Pop edi
    Mov W$edi-2 ax                           ; write the ID in RT_GROUP_CURSOR records
    add D$edi-6 4                            ; +4 size because upper added hot Spot in data

    add D$CursorListPtr 12 | add D$GroupCursorListPtr 12
ret


[TempoIconMem: D$ ?]

ReadIcon:
    Mov D$OtherFilesFilters IconFilesFilters
    Mov D$OpenOtherFileTitle IconFilesTitle
    Mov D$OtherList IconList | Move D$OtherListPtr D$IconListPtr

    Move D$OtherhwndFileOwner D$H.MainWindow, D$OtherhInstance D$H.Instance

    Mov edi OtherSaveFilter, ecx 260, eax 0 | rep stosd
    Call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc
        If D$OtherSaveFilter = 0
            Mov D$OtherList 0,  D$OtherListPtr 0 | ret
        End_If

    Call 'KERNEL32.CreateFileA' OtherSaveFilter &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE

      Call MessageBox D$BusyFilePtr

ret  ; return to caller of caller

    Else
      Mov D$H.OtherSource eax
    End_If

    Call 'KERNEL32.GetFileSize'  eax 0
    Mov D$OtherFileLen eax

    Call VirtualAlloc OtherFilePtr,
                      eax


    Call 'KERNEL32.ReadFile' D$H.OtherSource D$OtherFilePtr,
                            eax NumberOfReadBytes 0

    Mov eax D$OtherFilePtr
    If D$eax+2 <> 010001
        Call 'USER32.MessageBoxA' D$H.MainWindow, BadIcoFile, Argh, &MB_OK+&MB_SYSTEMMODAL

        Call VirtualFree OtherFilePtr

ret

    End_If

  ; We write both the RT_ICON and the RT_GROUP_ICON:
    Call VirtualAlloc TempoIconMem,
                      D$OtherFileLen

    Call VirtualAlloc TempoMemPointer,
                      20

    Mov edi D$GroupIconListPtr, eax D$TempoMemPointer, D$edi+4 eax, D$edi+8 20

    Mov edi eax                                       ; edi > RT_GROUP_ICON mem

    Mov esi D$OtherFilePtr

    Mov ecx 20 | rep movsb
    Push edi

    Mov esi D$OtherFilePtr | add esi 016
    sub D$OtherFileLen 012 | Mov ecx D$OtherFileLen
    Mov edi D$TempoIconMem | rep movsb

    Call VirtualFree OtherFilePtr

    Move D$OtherFilePtr D$TempoIconMem

    Mov B$OnIconLoad &TRUE
        Call AskForResID | Call CloseOtherFilesRead
    Mov B$OnIconLoad &FALSE

    Mov esi D$OtherListPtr | lodsd                    ; rewrite ID to GroupCursor:
    Mov edi D$GroupIconListPtr | stosd
    Pop edi
    Mov W$edi-2 ax                           ; write the ID in RT_GROUP_CURSOR records
    add D$edi-6 4                            ; +4 size because upper added hot Spot in data

    add D$IconListPtr 12 | add D$GroupIconListPtr 12
ret


[H.Animate: D$ ?
 H.TempoAviFile: D$ ?]
[AnimateClass: B$ 'SysAnimate32' EOS]
[TempoAviFile: B$ 'Avi$$$.avi' EOS]
[KillAvi: B$ 'Delete this Avi Resource?' EOS]
[NoAvi: B$ 'No Avi Resources in this PE' EOS]

[EmptyDialog: D$ 0900408C2 0    ; Style
 U$ 0 0 0 0DC 0C8              ; Dim
 0                             ;      no Menu
 '' 0                          ; Class
 '' 0                          ; Title
 08 'Helv' 0]                  ; Font

[H.EmptyDialog: D$ ?]

Proc EmptyProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    If D@msg = &WM_INITDIALOG
        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        Mov eax &TRUE

    Else_If D@msg = &WM_CLOSE
        Mov B$OkDialogFlag &TRUE
       ; Call 'USER32.EndDialog' D$H.ChoiceDialogBox 0
        Call 'USER32.DestroyWindow' D@hwnd

    Else
        popad | Mov eax &FALSE | jmp L9>

    End_If

    popad | Mov eax &TRUE

L9: EndP


DeleteAviFile:
    If D$AviList = 0
        Call 'USER32.MessageBoxA' D$H.MainWindow, NoAvi, Argh, &MB_OK+&MB_SYSTEMMODAL | ret
    End_If

    Call 'USER32.CreateDialogIndirectParamA' D$H.Instance EmptyDialog &NULL Emptyproc 0
    Mov D$H.EmptyDialog eax

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT+&WS_SIZEBOX+&WS_DLGFRAME,
                                  AnimateClass,
                                  &NULL,  ; &WS_Border  &WS_BORDER
                                  &ACS_AUTOPLAY+&WS_VISIBLE+&WS_CHILD+&ACS_CENTER,
                                  4,
                                  4,
                                  200,
                                  100,
                                  D$H.EmptyDialog,
                                  &NULL,
                                  D$H.Instance,
                                  0

    Mov D$H.Animate eax

    Mov D$WhatDialogListPtr AviList,  D$OkDialogFlag &FALSE
    add D$WhatDialogListPtr 4

    .While B$OkDialogFlag = &FALSE
        Call 'KERNEL32.CreateFileA' TempoAviFile &GENERIC_WRITE, 0, 0,
                                    &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0

        Mov D$H.TempoAviFile eax
        Mov esi D$WhatDialogListPtr | Mov ecx D$esi+4
        Call 'KERNEL32.WriteFile' D$H.TempoAviFile D$esi ecx NumberOfReadBytes &NULL
        Call 'KERNEL32.CloseHandle' D$H.TempoAviFile
        Call 'USER32.SendMessageA' D$H.Animate &ACM_OPEN  &NULL TempoAviFile
        Call SetNextChoiceID
        Call 'USER32.DialogBoxIndirectParamA' D$H.Instance, ChoiceBar, D$H.MainWindow, ChoiceDialogBoxProc, AviList
        Call 'USER32.SendMessageA' D$H.Animate &ACM_STOP  &NULL &NULL
        .If D$OkDialogFlag = &VK_ESCAPE
            jmp L9>>
        .Else_If D$WhatDialogListPtr < AviList
            add D$WhatDialogListPtr 12
            Call SetNextChoiceID
        .Else
            Mov esi D$WhatDialogListPtr
            If D$esi = 0
              sub D$WhatDialogListPtr 12 | Mov esi D$WhatDialogListPtr
              Call SetNextChoiceID
            End_If
        .End_If
    .End_While

    Call 'USER32.MessageBoxA' D$H.MainWindow, KillAvi, Sure, &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL
    If eax = &IDYES
        sub D$WhatDialogListPtr 4
        Mov esi D$WhatDialogListPtr, edi esi | add esi 12
        Mov eax D$WhatDialogListPtr | sub eax AviList | shr eax 2 | Mov ecx 300 | sub ecx eax
        rep movsd
        sub D$AviListPtr 12
    End_If

L9: Call 'USER32.DestroyWindow' D$H.Animate
    Call 'USER32.EndDialog' D$H.EmptyDialog &NULL
    Call 'KERNEL32.DeleteFileA' TempoAviFile
ret


[NoCursor: B$ 'No Cursor Resources in this PE' EOS]
[KillCursor: B$ 'Delete this Cursor?' EOS]
[KillIcon: B$ 'Delete this Icon?' EOS]
[TempoCursorFile: B$ 'Cursor.$$$' EOS]
[CurDataPtr: W$ 0  D$ 22]

[H.UserCursor: D$ ?
 H.TempoCursorFile: D$ ?]

DeleteCursor:
    If D$CursorList = 0
        Call 'USER32.MessageBoxA' D$H.MainWindow, NoCursor, Argh, &MB_OK+&MB_SYSTEMMODAL | ret
    End_If

    Mov D$WhatDialogListPtr CursorList,  D$OkDialogFlag &FALSE, D$H.EmptyDialog 0
    add D$WhatDialogListPtr 4

    .While B$OkDialogFlag = &FALSE
        On D$H.EmptyDialog <> 0, Call 'USER32.EndDialog' D$H.EmptyDialog &NULL
        Call 'USER32.CreateDialogIndirectParamA' D$H.Instance EmptyDialog &NULL Emptyproc 0
            Mov D$H.EmptyDialog eax
        Call 'KERNEL32.CreateFileA' TempoCursorFile &GENERIC_WRITE, 0, 0,
                                    &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0
        Mov D$H.TempoCursorFile eax
        Mov eax D$WhatDialogListPtr | sub eax CursorList | add eax GroupCursorList
        Mov ecx D$eax | sub D$ecx+14 4 | Mov ecx D$ecx+14  ; how much -4 for added Hot Spot
        Push eax, ecx
            Call 'KERNEL32.WriteFile' D$H.TempoCursorFile D$eax 010 NumberOfReadBytes &NULL
            Call 'KERNEL32.WriteFile' D$H.TempoCursorFile CurDataPtr 6 NumberOfReadBytes &NULL
            Mov esi D$WhatDialogListPtr, esi D$esi | add esi 4
        Pop ecx, eax
        Mov eax D$eax | add D$eax+14 4                     ; restore our 'how much'
        Call 'KERNEL32.WriteFile' D$H.TempoCursorFile esi ecx NumberOfReadBytes &NULL
        Call 'KERNEL32.CloseHandle' D$H.TempoCursorFile
        Call 'USER32.LoadCursorFromFileA' TempoCursorFile
        If D$H.UserCursor > 0
            pushad
               Call 'USER32.DestroyCursor' D$H.UserCursor
            popad
        End_If
        Mov D$H.UserCursor eax
            Call 'USER32.GetDC' D$H.EmptyDialog
            Push eax
                Call 'USER32.DrawIcon' eax 10 10 D$H.UserCursor
            Pop eax
            Call 'USER32.ReleaseDC' D$H.EmptyDialog eax
            Call SetNextChoiceID
        Call 'USER32.DialogBoxIndirectParamA' D$H.Instance, ChoiceBar,
                                             D$H.MainWindow, ChoiceDialogBoxProc, CursorList

        .If D$OkDialogFlag = &VK_ESCAPE
            jmp L9>>
        .Else_If D$WhatDialogListPtr < CursorList
            add D$WhatDialogListPtr 12
            Call SetNextChoiceID
        .Else
            Mov esi D$WhatDialogListPtr
            If D$esi = 0
              sub D$WhatDialogListPtr 12
              Call SetNextChoiceID
            End_If
        .End_If
   .End_While

   Call 'USER32.MessageBoxA' D$H.MainWindow, KillCursor, Sure, &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL
   If eax = &IDYES
       sub D$WhatDialogListPtr 4
       Mov esi D$WhatDialogListPtr, edi esi | add esi 12
       Mov ebx D$edi                                                ; ebx = ID
       Mov eax D$WhatDialogListPtr | sub eax CursorList | shr eax 2
       Mov ecx MAXCURSOR | sub ecx eax | rep movsd
       sub D$CursorListPtr 12

       Mov esi GroupCursorList, ecx MAXCURSOR
       While D$esi <> ebx
           add esi 12 | sub ecx 3
       End_While
       Mov edi esi | add esi 12  | rep movsd
       sub D$GroupCursorListPtr 12
   End_If

L9: Call 'USER32.EndDialog' D$H.EmptyDialog &NULL
    Call 'KERNEL32.DeleteFileA' TempoCursorFile
ret

DeleteIcon:
    If D$IconList = 0
        Call 'USER32.MessageBoxA' D$H.MainWindow, NoIcon, Argh, &MB_OK+&MB_SYSTEMMODAL | ret
    End_If

    Mov D$WhatDialogListPtr IconList,  D$OkDialogFlag &FALSE, D$H.EmptyDialog 0
    add D$WhatDialogListPtr 4

   ; ID / Pointer / Size.

    .While B$OkDialogFlag = &FALSE
        On D$H.EmptyDialog <> 0, Call 'USER32.EndDialog' D$H.EmptyDialog &NULL
        Call 'USER32.CreateDialogIndirectParamA' D$H.Instance EmptyDialog &NULL Emptyproc 0
            Mov D$H.EmptyDialog eax
        Call 'KERNEL32.CreateFileA' TempoCursorFile &GENERIC_WRITE, 0, 0,
                                    &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0
        Mov D$H.TempoCursorFile eax
        Mov eax D$WhatDialogListPtr | sub eax IconList | add eax GroupIconList

      ; May hang down there here with an ecx = 0. So, temporary:
        On D$eax = 0, jmp L9>>

        Mov ecx D$eax | Mov ecx D$ecx+14
        Push ecx
            Call 'KERNEL32.WriteFile' D$H.TempoCursorFile D$eax 010 NumberOfReadBytes &NULL
            Call 'KERNEL32.WriteFile' D$H.TempoCursorFile CurDataPtr 6 NumberOfReadBytes &NULL
            Mov esi D$WhatDialogListPtr
        Pop ecx
        Call 'KERNEL32.WriteFile' D$H.TempoCursorFile D$esi D$esi+4 NumberOfReadBytes &NULL
        Call 'KERNEL32.CloseHandle' D$H.TempoCursorFile
        Call 'USER32.LoadCursorFromFileA' TempoCursorFile
        If D$H.UserCursor > 0
            pushad
               Call 'USER32.DestroyCursor' D$H.UserCursor
            popad
        End_If
        Mov D$H.UserCursor eax
            Call 'USER32.GetDC' D$H.EmptyDialog
            Push eax
                Call 'USER32.DrawIcon' eax 10 10 D$H.UserCursor
            Pop eax
            Call 'USER32.ReleaseDC' D$H.EmptyDialog eax
            Call SetNextChoiceID

        Call 'USER32.DialogBoxIndirectParamA' D$H.Instance, ChoiceBar,
                                             D$H.MainWindow, ChoiceDialogBoxProc, IconList

        .If D$OkDialogFlag = &VK_ESCAPE
            jmp L9>>
        .Else_If D$WhatDialogListPtr < IconList
            add D$WhatDialogListPtr 12
            Call SetNextChoiceID
        .Else
            Mov esi D$WhatDialogListPtr
            If D$esi = 0
              sub D$WhatDialogListPtr 12
              Call SetNextChoiceID
            End_If
        .End_If
   .End_While

    Call 'USER32.MessageBoxA' D$H.MainWindow, KillIcon, Sure, &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL
    If eax = &IDYES
        sub D$WhatDialogListPtr 4
        Mov esi D$WhatDialogListPtr, edi esi | add esi 12
        Mov ebx D$edi                                                ; ebx = ID
        Mov eax D$WhatDialogListPtr | sub eax IconList | shr eax 2
        Mov ecx MAXICON | sub ecx eax | rep movsd
        sub D$IconListPtr 12

        Mov esi GroupIconList, ecx MAXICON
        While D$esi <> ebx
            add esi 12 | sub ecx 3
        End_While
        Mov edi esi | add esi 12  | rep movsd
        sub D$GroupIconListPtr 12
    End_If

L9: Call 'USER32.EndDialog' D$H.EmptyDialog &NULL
    Call 'KERNEL32.DeleteFileA' TempoCursorFile
ret


ReadOtherFile:
    Move D$OtherhwndFileOwner D$H.MainWindow, D$OtherhInstance D$H.Instance

    Mov edi OtherSaveFilter, ecx 260, eax 0 | rep stosd
    Call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc
      On D$OtherSaveFilter = 0,  ret

  ; Loading the entire file in memory:
    On D$H.OtherSource > 0, Call 'KERNEL32.CloseHandle' D$H.OtherSource
    Mov D$H.OtherSource 0

    Call 'KERNEL32.CreateFileA' OtherSaveFilter, &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE

      Call MessageBox D$BusyFilePtr

ret  ; return to caller of caller

    Else
        Mov D$H.OtherSource eax
    End_If

    Call 'KERNEL32.GetFileSize'  eax 0 | Mov D$OtherFileLen eax

    Call VirtualAlloc OtherFilePtr,
                      eax


    Call 'KERNEL32.ReadFile' D$H.OtherSource, D$OtherFilePtr,
                            eax, NumberOfReadBytes 0
ret


CloseOtherFilesRead:
    On D$H.OtherSource > 0, Call 'KERNEL32.CloseHandle' D$H.OtherSource
    Mov D$H.OtherSource 0
ret



AskForResID:
    Call 'USER32.DialogBoxIndirectParamA' D$H.Instance, OtherIdTemplate, 0, OtherIDProc, 0
ret


[H.OtherEdit: D$ ?]
[OtherID: B$ '                   ' EOS]

[OnIconLoad: D$ ?]

Proc OtherIDProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    .If D@msg = &WM_COMMAND
       ..If D@wParam = &IDCANCEL
            Call 'USER32.EndDialog' D@hwnd 0
       ..Else_If D@wParam = &IDOK
           Call 'USER32.GetDlgItem' D@hwnd 3 | Mov D$H.OtherEdit eax
           Call 'USER32.SendMessageA' D$H.OtherEdit &WM_GETTEXTLENGTH 0 0 | inc eax
           Call 'USER32.SendMessageA' D$H.OtherEdit &WM_GETTEXT eax OtherID
           TranslateAsciiToDword OtherID
           If eax > 0FFFF

             Call MessageBox D$IdTooBigPtr

           Else_If eax < 1

             Call MessageBox D$IdTooSmallPtr

           Else
             Mov edi D$OtherListPtr | stosd
             Mov eax D$OtherFilePtr | stosd
             Mov eax D$OtherFileLen | stosd
             Call 'USER32.EndDialog' D@hwnd 0
           End_If
       ..End_If

    .Else_If D@msg = &WM_INITDIALOG
        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        Call 'USER32.GetDlgItem' D@hwnd 3
        Call 'USER32.SendMessageA' eax &EM_SETLIMITTEXT 5  0
           Mov esi D$OtherListPtr | On esi > D$OtherList, sub esi 12
           If D$esi = 0
             Mov eax 1
             On B$OnIconLoad = &TRUE, inc eax
           Else
             lodsd | inc eax
           End_If
           Call 'USER32.SetDlgItemInt' D@hwnd 3 eax 0
    .Else
       popad | Mov eax &FALSE | jmp L9>

    .End_If

    popad | Mov eax &TRUE

L9: EndP


[OtherIdTemplate: D$ 090C408C2 0    ; Style
 U$ 03 0 0 0B9 018             ; Dim
 0                             ; no Menu
 '' 0                          ; Class
 'What ID number for new Resource?' 0 ; Title
 08 'Helv' 0]                  ; Font

[@OID0: D$ 050000000 0         ; Style
 U$ 07E 03 038 013             ; Dim
 01                            ; ID
 0FFFF 080                     ; Class
 'OK' 0                        ; Title
 0]                            ; No creation data

[@OID1: D$ 050000000 0         ; Style
 U$ 03 03 038 013              ; Dim
 02                            ; ID
 0FFFF 080                     ; Class
 'Abort' 0                     ; Title
 0]                            ; No creation data

[@OID2: D$ 050802000 0         ; Style
 U$ 040 05 038 0F              ; Dim
 03                            ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data

____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Clip            ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;                                     Templates.
;
; A simple bank of Templates to be copied inside the user ClipBoard trough a friendly
; Dialog interface ([Clip] Menu Option).

[GenericName: D$ ? # 10]     ; 40 bytes for a name to add to symbols.

; 'TemplateChoice' 'AddGroup' 'DeleteGroup' 'AddTemplate' 'DeleteTemplate'
;
;
; Proc modified is: 'ShowClip'
; Additional procs added are: 'Clip_Disable_Customization_Controls' and
; 'Clip_Enable_Customization_Controls'
____________________________________________________________________________________________
____________________________________________________________________________________________

[ClipMessage: B$ " Copy 'Clip.txt' in this directory
or run [Config] menu option" EOS]

Templates:
    If D$H.Clipper > 0
        Call Beep | ret
    End_If

    On eax = M00_Clip_File, jmp L1>

    If D$NumberOfClipFiles > 1
        Call LoadSelectedClipFile
    Else
L1:     Call LoadClipFile
    End_If

    If B$ClipFileReady = &TRUE
      ; Tag Dialog 2000
        Call 'USER32.DialogBoxParamA' D$H.Instance, 2000, &NULL, TemplateChoice, &NULL
        Call ReleaseClipFile
    Else_If B$ClipFileReady = &FALSE
        Call 'USER32.MessageBoxA' D$H.MainWindow, ClipMessage, FileNotFound, &MB_ICONINFORMATION+&MB_SYSTEMMODAL
    Else_If B$ClipFileReady = 0-1
        Call 'USER32.MessageBoxA' D$H.MainWindow, ClipTitleWanted, UnvalidClipTitle, &MB_SYSTEMMODAL
        Call ReleaseClipFile
    End_If
ret


[H.ClipFile: D$ ?
 ClipFileSize: D$ ?
 ClipFileMemoryPointer: D$ ?
 ClipMemoryEnd: D$ ?
 ClipFileReady: D$ ?]

[CLIPRESERVATION 010000]

LoadClipFile:
    Call 'KERNEL32.CreateFileA' ClipName, &GENERIC_READ, 0, 0, &OPEN_EXISTING,
                                &FILE_ATTRIBUTE_NORMAL, &NULL
    If eax = &INVALID_HANDLE_VALUE
        Mov B$ClipFileReady &FALSE | ret
    Else
        Mov B$ClipFileReady &TRUE, D$H.ClipFile eax
    End_If

    Call 'KERNEL32.GetFileSize' D$H.ClipFile, &NULL | Mov D$ClipFileSize eax

    add eax CLIPRESERVATION

    Call VirtualAlloc ClipFileMemoryPointer,
                      eax

    mov eax D$ClipFileMemoryPointer | add eax D$ClipFileSize | add eax CLIPRESERVATION | Mov D$ClipMemoryEnd eax

    Call 'KERNEL32.ReadFile' D$H.ClipFile, D$ClipFileMemoryPointer, D$ClipFileSize,
                            NumberOfReadBytes, &NULL
    Call ClipCRLFs
ret


LoadSelectedClipFile:
  ; eax stil hold the ID: 7000, 7001, ...
    sub eax 7000

    Mov esi ClipMenuStrings
    .While eax > 0
        While B$esi <> 0 | inc esi | End_While | inc esi
        dec eax
    .End_While

    Mov edi ClipName
    While B$edi <> 0 | inc edi | End_While
    While B$edi <> '\' | dec edi | End_While | inc edi
    While B$esi <> 0 | movsb | End_While | movsb

    Call LoadClipFile
ret


WriteClipFile:
    Call 'KERNEL32.CloseHandle' D$H.ClipFile

    Call 'KERNEL32.CreateFileA' ClipName, &GENERIC_READ__&GENERIC_WRITE, 0, 0,
                                &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, &NULL
    Mov D$H.ClipFile eax, D$NumberOfReadBytes 0

    Call 'KERNEL32.WriteFile' D$H.ClipFile, D$ClipFileMemoryPointer, D$ClipFileSize,
                              NumberOfReadBytes, 0
ret


ReleaseClipFile:

    Call VirtualFree ClipFileMemoryPointer

    Call 'KERNEL32.CloseHandle' D$H.ClipFile

ret


[OneClipName: D$ ? # 40]

ReadClipsections:
    Call 'USER32.SendMessageA' D$TemplateList1, &LB_RESETCONTENT, 0, 0

    Mov esi D$ClipFileMemoryPointer

    .While esi < D$ClipMemoryEnd
        lodsb
        If al = '/'
            .If B$esi = '/'
                ..If B$esi-2 < SPC
                    inc esi | Mov edi OneClipName
                    While B$esi >= SPC
                        movsb
                    End_While
                    Mov al 0 | stosb

                    Call 'USER32.SendMessageA' D$TemplateList1, &LB_ADDSTRING,
                                               0, OneClipName
                ..End_If
            .End_If
        End_If
    .End_While
ret


; in eax: 0 based index of the first ListBox (Sections)

[SectionPointer: D$ ?]

SearchSection:
    inc eax | Mov ebx eax
    Mov esi D$ClipFileMemoryPointer

    .While esi < D$ClipMemoryEnd
        lodsb
        If al = '/'
            .If B$esi = '/'
                ..If B$esi-2 < SPC
                    dec ebx | jnz L1>
                        While B$esi <> LF
                            inc esi
                        End_While
                        inc esi | Mov D$SectionPointer esi | ret
L1:             ..End_If
            .End_If
        End_If
    .End_While

    Mov D$SectionPointer 0
ret


ReadClipTitles:
    Mov esi D$SectionPointer
    Mov edx D$ClipFileMemoryPointer | add edx D$ClipFileSize

    .While esi < edx ;D$ClipMemoryEnd
        lodsb
        If al = '/'
            .If B$esi-2 < SPC
                ..If B$esi = '/'
                    ret
                ..Else
                    Mov edi OneClipName
                    While B$esi >= SPC
                        movsb
                    End_While
                    Mov al 0 | stosb
                    Push edx
                        Call 'USER32.SendMessageA' D$TemplateList2  &LB_ADDSTRING,
                                                   0 OneClipName
                    Pop edx
                ..End_If
            .End_If
        End_If
    .End_While
ret


; in eax: 0 based index of the second ListBox (Titles)

[ClipPointer: D$ ?
 ClipGroupIndex: D$ ?
 ClipIndex: D$ ?]

SearchTheClip:
    Mov D$TheClipLenght 0, D$ClipPointer 0
    Call 'USER32.SendMessageA' D$TemplateList2, &LB_GETCURSEL, 0, 0 | cmp eax &LB_ERR | je L9>>
    Mov D$ClipIndex eax
    Mov esi D$SectionPointer | inc eax | Mov ebx eax

    .While esi < D$ClipMemoryEnd
        lodsb
        If al = '/'
            .If B$esi-2 < SPC
                dec ebx | jnz L1>
                    While B$esi <> LF
                            inc esi
                    End_While

                    inc esi | Mov D$ClipPointer esi | Call SearchTheClipLenght | jmp L9>
L1:         .End_If
        End_If
    .End_While
L9: ret


[TheClipLenght: D$ ?]

SearchTheClipLenght:
    .While esi < D$ClipMemoryEnd
        lodsb | inc D$TheClipLenght
        .If al = '/'
            If B$esi-2 < SPC
                dec D$TheClipLenght | ret
            End_If
        .Else_If al = 0
            dec D$TheClipLenght | ret
        .End_If
    .End_While
ret
____________________________________________________________________________________________


[TempoClipmemoryPtr: D$ ?]
[H.ControlID108: D$ ?] ; Handle to Generic Name textbox
[H.ControlID104: D$ ?] ; These are the 4 handles to the radio buttons.
[H.ControlID105: D$ ?]
[H.ControlID106: D$ ?]
[H.ControlID107: D$ ?]


ShowClip:
    Call RetrieveGenericName
    Call SearchTheClip | On D$TheClipLenght = 0, ret

    Mov ecx D$TheClipLenght | shl ecx 2               ; *4 > room for Generic Names

    Call VirtualAlloc TempoClipmemoryPtr,
                      ecx

    Mov edi D$TempoClipmemoryPtr, esi D$ClipPointer

    shr ecx 2                                                   ; restore true data size

  ; If the very first Char after the first CR/LF is '@', we load the Clip 'As is':
    Mov ebx esi | add ebx 2
    While B$ebx <= SPC | inc ebx | End_While

    .If B$ebx = '@'
        Call Clip_Disable_Customization_Controls
        Call SearchTheClip | On D$TheClipLenght = 0, ret
        Mov esi D$ClipPointer, ecx D$TheClipLenght
        While B$esi <> '@'
            inc esi | dec ecx | jz L8>
        End_While | inc esi | dec ecx | jz L8>
        rep movsb

    .Else_If B$WithData = &TRUE
        If B$GlobalScope = &TRUE
            Call WithDataGlobalScope
        Else
            Call WithDataLocalScope
        End_If
        Call Clip_Enable_Customization_Controls
    .Else
        If B$GlobalScope = &TRUE
            Call WithoutDataGlobalScope
        Else
            Call WithoutDataLocalScope
        End_If
        Call Clip_Enable_Customization_Controls
    .End_If

    Mov eax 0 | stosd

    Call 'USER32.SendMessageA' D$TemplateList3  &WM_SETTEXT 0 D$TempoClipmemoryPtr
L8:
ret


Clip_Disable_Customization_Controls:
   Call 'USER32.EnableWindow' D$H.ControlID108 &FALSE
   Call 'USER32.EnableWindow' D$H.ControlID104 &FALSE
   Call 'USER32.EnableWindow' D$H.ControlID105 &FALSE
   Call 'USER32.EnableWindow' D$H.ControlID106 &FALSE
   Call 'USER32.EnableWindow' D$H.ControlID107 &FALSE
ret

Clip_Enable_Customization_Controls:
   Call 'USER32.EnableWindow' D$H.ControlID108 &TRUE
   Call 'USER32.EnableWindow' D$H.ControlID104 &TRUE
   Call 'USER32.EnableWindow' D$H.ControlID105 &TRUE
   Call 'USER32.EnableWindow' D$H.ControlID106 &TRUE
   Call 'USER32.EnableWindow' D$H.ControlID107 &TRUE
ret

____________________________________________________________________________________________


[TemplateList1: D$ ?
 TemplateList2: D$ ?
 TemplateList3: D$ ?]

[RadioButtonID: D$ ?
 H.Clipper: D$ ?]

[DEL_TEMPLATE 5    AD_TEMPLATE 6    DEL_GROUP 7   AD_GROUP 8   DEL_GROUP_TEMPLATES 4
 CLIP_MANAGER 25]

[ClipDialogIsExtended: D$ ?]

ExtendClipDialog:
    Call 'USER32.GetWindowPlacement' D$H.Clipper Control

    If B$ClipDialogIsExtended = &FALSE
        add D$Control@rcNormalPosition.bottom 52
    Else
        sub D$Control@rcNormalPosition.bottom 52
    End_If

    Call 'USER32.SetWindowPlacement' D$H.Clipper Control

    xor B$ClipDialogIsExtended &TRUE
ret


Proc TemplateChoice:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_COMMAND
         ..If D@wParam = &IDCANCEL
            Mov D$H.Clipper 0
            Call 'USER32.EndDialog' D@hwnd 0

         ..Else_If D@wParam = &IDOK
             Call RetrieveGenericName
             Call SearchTheClip
             Call TemplateToClipBoard
             Mov D$H.Clipper 0
             Call 'USER32.EndDialog' D@hwnd 0

         ..Else_If D@wParam = &IDHELP
             Call Help, B_U_AsmName TempateHelp, ContextHlpMessage

         ..Else_If D@wParam = CLIP_MANAGER
            Call ExtendClipDialog

         ..Else_If D@wParam = AD_GROUP
            Call AddGroup

         ..Else_If D@wParam = DEL_GROUP
            Call DeleteGroup

         ..Else_If D@wParam = DEL_GROUP_TEMPLATES
            Call DeleteGroupAndTemplates

         ..Else_If D@wParam = AD_TEMPLATE
            Call AddTemplate

         ..Else_If D@wParam = DEL_TEMPLATE
            Call DeleteTemplate

         ..Else_If W@wParam = 101                     ; 101 > First ListBox
             shr D@wParam 16
             .If D@wParam = &LBN_SELCHANGE
                Call ViewTemplatesItems
             .End_If

         ..Else_If W@wParam = 102                     ; 102 > Second ListBox
             shr D@wParam 16
             .If D@wParam = &LBN_SELCHANGE
                 Call ShowClip
             .End_If

         ..Else_If W@wParam = 108                   ; Generic Name Edit Control
            Call ShowClip
         ..Else_If W@wParam >= 104                   ; 104/105/106/107 > Radio Buttons
             Move D$RadioButtonID D@wParam
             and D$RadioButtonID 0FFFF
             .If W@wParam <= 107
                 shr D@wParam 16
                 If D@wParam = &BN_CLICKED
                     Call CheckTemplateRadioButtons
                     Call ShowClip
                 End_If
             .End_If
         ..End_If

    ...Else_If D@msg = &WM_INITDIALOG
        Move D$H.Clipper D@hwnd
        Mov B$ClipDialogIsExtended &FALSE
        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        Call 'USER32.GetDlgItem' D@hwnd 101 | Mov D$TemplateList1 eax
        Call 'USER32.GetDlgItem' D@hwnd 102 | Mov D$TemplateList2 eax
        Call 'USER32.GetDlgItem' D@hwnd 110 | Mov D$TemplateList3 eax
        Call 'USER32.GetDlgItem' D@hwnd 108 | Mov D$H.ControlID108 eax
        Call 'USER32.GetDlgItem' D@hwnd 104 | Mov D$H.ControlID104 eax
        Call 'USER32.GetDlgItem' D@hwnd 105 | Mov D$H.ControlID105 eax
        Call 'USER32.GetDlgItem' D@hwnd 106 | Mov D$H.ControlID106 eax
        Call 'USER32.GetDlgItem' D@hwnd 107 | Mov D$H.ControlID107 eax
        Call ReadClipsections
        Call InitTemplateRadioButtons D@hwnd
        Call 'USER32.SendMessageA' D$TemplateList1  &LB_SETCURSEL 0 0
        Call ViewTemplatesItems
       ; Call 'USER32.SendDlgItemMessageA' D@hwnd, 110, &WM_SETFONT, D$H.Font1, &FALSE

    ...Else_If D@msg = &WM_CTLCOLOREDIT
        jmp L1>

   ; ...Else_If D@msg = &WM_CTLCOLORBTN ; Never received for Radio/Check Buttons !!!???
   ;     jmp L1>

    ...Else_If D@msg = &WM_CTLCOLORLISTBOX
L1:     Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>>

    ...Else
       ; Mov eax D$BlockEndTextPtr | sub eax D$BlockStartTextPtr
       ; Mov ebx D$ClipMemoryEnd | sub ebx D$ClipFileMemoryPointer
       ; Mov ecx D$FL.BlockInside | On eax >= ebx, Mov ecx &FALSE
       ; EnableControl D@hwnd, AD_TEMPLATE, ecx

        popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE

L9: Endp


ViewTemplatesItems:
    Call 'USER32.SendMessageA' D$TemplateList2, &LB_RESETCONTENT, 0, 0
    Call 'USER32.SendMessageA' D$TemplateList3, &WM_SETTEXT, 0, 0

    Call 'USER32.SendMessageA' D$TemplateList1  &LB_GETCURSEL 0 0
    Call SearchSection | On D$SectionPointer <> 0, Call ReadClipTitles
ret

____________________________________________________________________________________________

[H.GetNewGroupName: D$ ?]

AddGroup: ; 'LoadClipFile'
    Call SaveClipSelections

    On D$H.GetNewGroupName <> 0,
        Call 'USER32.EndDialog' D$H.GetNewGroupName, 0
    Call 'USER32.DialogBoxParamA' D$H.Instance 20001, &NULL, GetNewGroupName, &NULL
    On D$NewGroupName = 0, ret

    ...If B$GroupInsert = &TRUE
      ; Go to the selected Group:
        Mov esi D$ClipFileMemoryPointer, edx D$ClipGroupIndex | inc edx

        While esi < D$ClipMemoryEnd
            lodsb
            ..If al = '/'
                .If B$esi = '/'
                    If B$esi-2 < SPC
                        dec edx | jz L1>
                    End_If
                .End_If
            ..End_If
        End_While

L1:     dec esi

        Push esi
          ; Make room: ('D$NewGroupNameLen'+6) Bytes:
            Mov ecx D$ClipFileMemoryPointer | add ecx D$ClipFileSize
            Mov edi ecx     ; edi > End.
            sub ecx esi     ; ecx = How many Bytes to be moved downward.
            Mov esi edi | add edi D$NewGroupNameLen | add edi 8 ; 6 = 3 CRLF + '//'
          ; esi > End // edi > (End+room). Copy BackWard:
            inc ecx | std | rep movsb | cld
        Pop edi

        add edi 2 ; (old '//' yet there).
        Mov esi NewGroupName, ecx D$NewGroupNameLen | rep movsb
        Mov D$edi CRLF2, W$edi+4 CRLF

        Mov eax D$NewGroupNameLen | add eax 8 | add D$ClipFileSize eax

    ...Else ; B$GroupInsert = &FALSE >>> Append:
        Mov edi D$ClipFileMemoryPointer | add edi D$ClipFileSize
        While B$edi < SPC | dec edi | dec D$ClipFileSize | End_While
        inc edi | inc D$ClipFileSize
        Mov D$edi CRLF2, W$edi+4 CRLF, W$edi+6 '//' | add edi 8
        Mov esi NewGroupName
        While B$esi <> 0 | movsb | inc D$ClipFileSize | End_While
        Mov D$edi CRLF2 | add edi 4
        add D$ClipFileSize 12 ; (5 CRLF + '//')

    ...End_If

    Call ClipUpdate
ret


[GroupInsert: D$ ?]

Proc GetNewGroupName:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

        .If D@msg = &WM_COMMAND
            If D@wParam = &IDOK         ; [Append]
                Mov D$GroupInsert &FALSE
L1:             Call 'USER32.SendDlgItemMessageA' D@hwnd, 10, &WM_GETTEXTLENGTH, 0, 0
                Mov D$NewGroupNameLen eax
                Call 'USER32.SendDlgItemMessageA' D@hwnd, 10, &WM_GETTEXT, 38,
                                                  NewGroupName
                Call 'USER32.EndDialog' D@hwnd, 0 | popad | Mov eax &TRUE

EndP

            Else_If D@wParam = 20       ; [Insert]
                Mov D$GroupInsert &TRUE | jmp L1<

            Else_If D@wParam = &IDCANCEL
                Mov D$H.GetNewGroupName 0
                Call 'USER32.EndDialog' D@hwnd, 0 | popad | Mov eax &TRUE | ExitP

            End_If

        .Else_If D@msg = &WM_INITDIALOG
            Mov B$WithCustomisation &FALSE
            Move D$H.GetNewGroupName D@hwnd
            Mov edi NewGroupName, eax 0, ecx 10 | rep stosd

            Call 'USER32.SendDlgItemMessageA' D@hwnd, 21,  &BM_SETCHECK, &TRUE, 0
            Call 'USER32.GetDlgItem', D@hwnd, 10
            Call 'USER32.SetFocus' eax

        .End_If

    popad | Mov eax &FALSE
EndP


; Deleting a Group name only.

[SureDelGroupName: B$ 'Delete "                                ' EOS]

DeleteGroup:
    Call SaveClipSelections

    Mov esi D$ClipFileMemoryPointer, ecx D$ClipGroupIndex | inc ecx

L0: inc esi | cmp D$esi 02F2F0A0D | jne L0<     ; "CR LF //" = 02F2F0A0D
    dec ecx | jnz L0<

    Push esi
        add esi 4 | lea edi D$SureDelGroupName+8
        While B$esi > CR | movsb | End_While
        Mov D$edi '" ? ', B$edi+3 0
        Call 'USER32.MessageBoxA' D$H.MainWindow, SureDelGroupName, SureDelTemplateTitle,
                                  &MB_SYSTEMMODAL__&MB_YESNO__&MB_ICONEXCLAMATION
    Pop esi

    .If eax = &IDYES
        Mov edx D$ClipFileMemoryPointer | add edx D$ClipFileSize
        add esi 2 | Mov edi esi | add esi 2 | sub D$ClipFileSize 2
      ; edi > '//'. esi > Name. Skip over Line:
        While B$esi > CR | inc esi | dec D$ClipFileSize | End_While
      ; Skip over coming CRLF:
        While W$esi = CRLF | add esi 2 | sub D$ClipFileSize 2 | End_While
        While esi < edx | movsb | End_While

        Call ClipUpdate
    .End_If
ret


DeleteGroupAndTemplates:
    Call SaveClipSelections

    Mov esi D$ClipFileMemoryPointer, ecx D$ClipGroupIndex | inc ecx

L0: inc esi | cmp D$esi 02F2F0A0D | jne L0<     ; "CR LF //" = 02F2F0A0D
    dec ecx | jnz L0<

    Push esi
        add esi 4 | lea edi D$SureDelGroupName+8
        While B$esi > CR | movsb | End_While
        Mov D$edi '" ? ', B$edi+3 0
        Call 'USER32.MessageBoxA' D$H.MainWindow, SureDelGroupName, SureDelTemplateTitle,
                                  &MB_SYSTEMMODAL__&MB_YESNO__&MB_ICONHAND
    Pop esi

    .If eax = &IDYES
        Mov edx D$ClipFileMemoryPointer | add edx D$ClipFileSize
        Mov edi esi | add esi 4 | sub D$ClipFileSize 4
        While D$esi <> 02F2F0A0D
            inc esi | dec D$ClipFileSize
            On esi >= edx, jmp L2>
        End_While

        While esi < edx | movsb | End_While

L2:     Call ClipUpdate
    .End_If
ret


[H.GetNewTemplateName: D$ ?]

[NoClipSelection: B$ 'No selection found in the Source Editor  ' EOS
 SelectionTooBig: B$ 'The Selection is too big  ' EOS]

AddTemplate: ; 'LoadClipFile'

    Mov eax D$LP.BlockEndText | sub eax D$LP.BlockStartText

    Mov ebx D$ClipMemoryEnd | sub ebx D$ClipFileMemoryPointer

    If D$FL.BlockInside = &FALSE

        Call 'USER32.MessageBoxA' D$H.MainWindow,
                                  NoClipSelection,
                                  Argh,
                                  &MB_SYSTEMMODAL

ret

    Else_If eax >= ebx

        Call 'USER32.MessageBoxA' D$H.MainWindow,
                                  SelectionTooBig,
                                  Argh,
                                  &MB_SYSTEMMODAL

ret

    End_If

    Call SaveClipSelections

    On D$H.GetNewTemplateName <> 0,
        Call 'USER32.EndDialog' D$H.GetNewTemplateName, 0
    Call 'USER32.DialogBoxParamA' D$H.Instance 20000, &NULL, GetNewTemplateName, &NULL

    On D$NewTemplateName = 0, ret

    Call SearchTheClip

    Mov eax D$ClipFileSize | add eax CLIPRESERVATION

    Call VirtualAlloc TempoClipFileMemoryPointer,
                      eax

    If D$TheClipLenght = 0

      ; No Item yet, or no Item selected >>> paste at end:
        Mov ebx D$SectionPointer, edx D$ClipFileMemoryPointer | add edx D$ClipFileSize
L0:     inc ebx | cmp ebx edx | jae L1>
        cmp W$ebx '//' | jne L0<
L1:         Mov D$ClipPointer ebx

        Mov esi D$ClipFileMemoryPointer, edi D$TempoClipFileMemoryPointer
        While esi < D$ClipPointer | movsb | End_While

    Else
      ; Item selected >>> Insert:
        Mov esi D$ClipFileMemoryPointer, edi D$TempoClipFileMemoryPointer
        While esi < D$ClipPointer | movsb | End_While

L0:     dec esi | dec edi | cmp B$esi '/' | jne L0<
        If B$esi-1 = '/'
            dec esi | dec edi
        End_If
        cmp W$esi-2 CRLF | jne L0<

    End_If

    Mov B$edi '/' | inc edi | inc D$ClipFileSize
    Push esi
        Mov esi NewTemplateName
        While B$esi <> 0 | movsb | inc D$ClipFileSize | End_While
    Pop esi
    Mov D$edi CRLF2 | add edi 4 | add D$ClipFileSize 4

    If B$WithCustomisation = &FALSE
        Mov B$edi '@', W$edi+1 CRLF | add edi 3 | add D$ClipFileSize 3
    End_If

    Mov W$edi CRLF | add edi 2 | add D$ClipFileSize 2

    Push esi

        Mov esi D$LP.BlockStartText

        While esi < D$LP.BlockEndText

            movsb | add D$ClipFileSize (1*ASCII)

        End_While

        movsb | add D$ClipFileSize (1*ASCII)

        Mov D$edi CRLF2,
            W$edi+4 CRLF

        add edi (6*ASCII) | add D$ClipFileSize (6*ASCII)

    Pop esi

    Mov edx D$ClipFileMemoryPointer | add edx D$ClipFileSize

    While esi < edx | movsb | End_While

    Exchange D$ClipFileMemoryPointer D$TempoClipFileMemoryPointer

    Call VirtualFree TempoClipFileMemoryPointer

    Call ClipUpdate

ret


SaveClipSelections:
    Call 'USER32.SendMessageA' D$TemplateList1  &LB_GETCURSEL 0 0 | Mov D$ClipGroupIndex eax
    Call 'USER32.SendMessageA' D$TemplateList2  &LB_GETCURSEL 0 0 | Mov D$ClipIndex eax
ret

ClipUpdate:
    Call ClipCRLFs | Call WriteClipFile | Call ReleaseClipFile
    Call LoadClipFile | Call ReadClipsections



    Call 'USER32.SendMessageA' D$TemplateList2, &LB_SETCURSEL, D$ClipIndex, 0
    If eax = &LB_ERR
        Call 'USER32.SendMessageA' D$TemplateList2, &LB_SETCURSEL, 0-1, 0
    End_If

    Call 'USER32.SendMessageA' D$TemplateList1, &LB_SETCURSEL, D$ClipGroupIndex, 0
    If eax = &LB_ERR
        Call 'USER32.SendMessageA' D$TemplateList1, &LB_SETCURSEL, 0, 0
    End_If

    Call ViewTemplatesItems
ret
____________________________________________________________________________________________

[UnvalidClipTitle: B$ 'Unvalid Clip File' EOS]
[ClipTitleWanted: B$ "A Clip File must contain some text before the first //Group" EOS]

;;
  Ensure that all '/Name', '//Name' are preceeded and ended by 3 CRLF and than the
  whole thing is ended by 2 CRLF.
;;

ClipCRLFs:
    Mov esi D$ClipFileMemoryPointer
    While W$esi = CRLF | add esi 2 | End_While
    If B$esi = '/'
        Mov B$ClipFileReady 0-1 | ret
    End_If

    Mov eax D$ClipFileSize | add eax CLIPRESERVATION

    Call VirtualAlloc TempoClipFileMemoryPointer,
                      eax

    Mov eax D$TempoClipFileMemoryPointer | add eax D$ClipFileSize | add eax CLIPRESERVATION | Mov D$ClipMemoryEnd eax

    Mov esi D$ClipFileMemoryPointer, edi D$TempoClipFileMemoryPointer
    Mov edx esi | add edx D$ClipFileSize

L0: .While esi < edx
        lodsb

        .If al = '/'
            If W$esi-3 = CRLF
              ; Skip the CRLF Back:
                While W$edi-2 = CRLF | sub edi 2 | End_While
              ; Re-Write the wanted 3 CRLFs:
                Mov D$edi CRLF2, W$edi+4 CRLF | add edi 6
              ; Write the '/Name', '//Name':
                dec esi | While B$esi <> CR | movsb | End_While
              ; Write the wanted 3 CRLFs:
                Mov D$edi CRLF2, W$edi+4 CRLF | add edi 6
              ; Arase the existing source CRLF:
                While W$esi = CRLF | add esi 2 | End_While | jmp L0<
            End_If
        .End_If

        stosb
    .End_While

  ; Arase existing CRLF at End:
    While W$edi-2 = CRLF | sub edi 2 | End_While
  ; And rewrite the 2 wanted ones:
    Mov D$edi CRLF2 | add edi 4

    sub edi D$TempoClipFileMemoryPointer | Mov D$ClipFileSize edi
    Exchange D$ClipFileMemoryPointer D$TempoClipFileMemoryPointer

    Mov eax D$ClipMemoryEnd | sub eax D$ClipFileMemoryPointer

    Call VirtualFree TempoClipFileMemoryPointer

ret


[NewTemplateName: NewGroupName: D$ ? # 10]
[WithCustomisation: D$ ?
 NewGroupNameLen: D$ ?]

Proc GetNewTemplateName:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

        .If D@msg = &WM_COMMAND
            If D@wParam = &IDOK
                Call 'USER32.SendDlgItemMessageA' D@hwnd, 10, &WM_GETTEXTLENGTH, 0, 0
                inc eax | On eax > 38, Mov eax 38
                Call 'USER32.SendDlgItemMessageA' D@hwnd, 10, &WM_GETTEXT, eax,
                                                   NewTemplateName

                Call 'USER32.EndDialog' D@hwnd 0 | popad | Mov eax &TRUE | ExitP

            Else_If D@wParam = &IDCANCEL
                Mov D$H.GetNewTemplateName 0
                Call 'USER32.EndDialog' D@hwnd 0 | popad | Mov eax &TRUE | ExitP

            Else_If D@wParam = 20
                xor B$WithCustomisation &TRUE

            End_If

        .Else_If D@msg = &WM_INITDIALOG
            Mov B$WithCustomisation &FALSE
            Move D$H.GetNewTemplateName D@hwnd
            Mov edi NewTemplateName, eax 0, ecx 10 | rep stosd

        .End_If

    popad | Mov eax &FALSE
EndP


[NoClipSelected: B$ 'Select a Template in the second List Box, if you want to delete it' EOS]
[SureDelTemplateTitle: B$ 'Sure?' EOS]
[SureDelTemplate: B$ 'Delete "                                ']

DeleteTemplate:
    Call SaveClipSelections

    Call SearchTheClip

    .If D$TheClipLenght = 0
      ; No Item yet, or no Item selected:
        Call 'USER32.MessageBoxA' D$H.MainWindow, NoClipSelected, Argh, &MB_SYSTEMMODAL

    .Else
      ; Item selected >>> Delete:
        Mov esi D$ClipPointer, edi esi

      ; Go to start of Template to be deleted:
        While B$edi <> '/' | dec edi | End_While | Mov D$ClipPointer edi

        Push esi, edi
            lea edi D$SureDelTemplate+8 | Mov esi D$ClipPointer | inc esi
            While B$esi <> CR | movsb | End_While | Mov D$edi '"  ?', B$edi+4 0

            Call 'USER32.MessageBoxA' D$H.MainWindow, SureDelTemplate, SureDelTemplateTitle,
                                      &MB_SYSTEMMODAL__&MB_YESNO__&MB_ICONEXCLAMATION
        Pop edi, esi

        .If eax = &IDYES
            Mov edx D$ClipFileMemoryPointer | add edx D$ClipFileSize
            Mov esi D$ClipPointer | inc esi | dec D$ClipFileSize
            While B$esi <> '/'
L0:             inc esi | dec D$ClipFileSize | On esi >= edx, jmp L1>
            End_While
            cmp B$esi-1 LF | jne L0<
            Mov ecx D$ClipMemoryEnd | sub ecx esi | rep movsb

L1:         Call ClipUpdate
        .End_If

    .End_If
ret

[TempoClipFileMemoryPointer: D$ ?]

____________________________________________________________________________________________

Proc InitTemplateRadioButtons:
    Argument @hwnd

    Mov eax 105 | xor al B$WithData
    Call 'USER32.GetDlgItem' D@hwnd eax
    Call 'USER32.SendMessageA' eax &BM_SETCHECK eax &TRUE
    Mov eax 107 | xor al B$GlobalScope
    Call 'USER32.GetDlgItem' D@hwnd eax
    Call 'USER32.SendMessageA' eax &BM_SETCHECK eax &TRUE
EndP


[WithData: B$ &TRUE    GlobalScope: &TRUE]

CheckTemplateRadioButtons:
    Call 'USER32.GetDlgItem' D$H.Clipper D$RadioButtonID
    Push eax
        Call 'USER32.SendMessageA' eax &BM_GETCHECK 0 0 | xor eax &TRUE
    Pop ebx
    Call 'USER32.SendMessageA' ebx &BM_SETCHECK eax 0
    xor D$RadioButtonID 1                                    ; 104 <> 105 // 106 <> 107
    Call 'USER32.GetDlgItem' D$H.Clipper D$RadioButtonID
    Push eax
        Call 'USER32.SendMessageA' eax &BM_GETCHECK 0 0 | xor eax &TRUE
    Pop ebx
    Call 'USER32.SendMessageA' ebx &BM_SETCHECK eax 0
    If D$RadioButtonID < 106
        xor B$WithData &TRUE
    Else
        xor B$GlobalScope &TRUE
    End_If
ret


TemplateToClipBoard:
    On D$TheClipLenght = 0, ret
    Call 'USER32.OpenClipboard' D$H.MainWindow | cmp eax 0 | je L9>>
    Call 'USER32.EmptyClipboard' | cmp eax 0 | je L8>>

    Mov ecx D$TheClipLenght | shl ecx 2               ; *4 > room for Generic Names
    Push ecx
        Call 'KERNEL32.GlobalAlloc' &GMEM_DDESHARE ecx | cmp eax 0 | jne L1>  ; > eax = handle
        Pop eax | jmp L8>>
L1:     Mov D$hBlock eax
        Call 'KERNEL32.GlobalLock' eax                                       ; > eax = adress
    Pop ecx
    shr ecx 2                                                   ; restore true data size
    Mov edi eax, esi D$ClipPointer

  ; If the very first Char after the first CR/LF is '@', we load the Clip 'As is':
    Mov ebx esi | add ebx 2
    While B$ebx <= SPC | inc ebx | End_While

    .If B$ebx = '@'
        Call SearchTheClip | On D$TheClipLenght = 0, ret
        Mov esi D$ClipPointer, ecx D$TheClipLenght
        While B$esi <> '@'
            inc esi | dec ecx | jz L8>
        End_While | inc esi | dec ecx | jz L8>
        rep movsb

    .Else_If B$WithData = &TRUE
        If B$GlobalScope = &TRUE
            Call WithDataGlobalScope
        Else
            Call WithDataLocalScope
        End_If
    .Else
        If B$GlobalScope = &TRUE
            Call WithoutDataGlobalScope
        Else
            Call WithoutDataLocalScope
        End_If
    .End_If

    Mov eax 0 | stosd

    Call 'KERNEL32.GlobalUnlock' D$hBlock
    Call 'USER32.SetClipboardData' &CF_TEXT  D$hBlock
    Call 'USER32.SendMessageA' D$TemplateList3  &WM_SETTEXT 0 D$hBlock
L8: Call 'USER32.CloseClipboard'
L9: ret


[H.GenericName: D$ ?]

RetrieveGenericName:
    Mov edi GenericName, ecx 10, eax 0 | rep stosd
    Call 'USER32.GetDlgItem' D$H.Clipper 108  ; 108 = ID of Generic Name Edit Control.
    Mov D$H.GenericName eax
    Call 'USER32.SendMessageA' D$H.GenericName &EM_LINELENGTH 0 0
    If eax > 0
        Mov W$GenericName ax
        Call 'USER32.SendMessageA' D$H.GenericName, &EM_GETLINE, 0, GenericName
        Mov B$GenericName+eax 0  ; >>> 'EM_GETLINE_Comment'
    End_If
ret


WithDataGlobalScope:
L0: lodsb
    .If al = '@'
        If B$GenericName > 0
            Push esi
                Mov esi GenericName | lodsb
L1:             stosb | lodsb | cmp al 0 | ja L1<
            Pop esi
        End_If
    .Else
        stosb
    .End_If
    loop L0<
ret


WithDataLocalScope:
L0: lodsb
    .If al = '@'
        stosb
        If B$GenericName > 0
            Push esi
                Mov esi GenericName | lodsb
L1:             stosb | lodsb | cmp al 0 | ja L1<
            Pop esi
        End_If
    .Else_If al = '['
        If B$esi = '@'
            Mov eax 'Loca' | stosd | Mov ax 'l ' | stosw
            Call CopyTemplateLabelsOnly
        Else
            stosb
        End_If
    .Else_If al = '$'
      ; Strip '$' in 'D$@Value', but not in D$Value.
        On B$esi <> '@', stosb
    .Else_If al = '$'
      ; Strip '$' in 'D$@'Value', but not in D$Value.
        On B$esi <> '@', stosb
    .Else
        stosb
    .End_If
    loop L0<
ret


CopyTemplateLabelsOnly:
L0:
    lodsb
        .If al = '@'
            stosb
            If B$GenericName > 0
                Push esi
                    Mov esi GenericName | lodsb
L1:                 stosb | lodsb | cmp al 0 | ja L1<
                Pop esi
            End_If
L1:         lodsb | dec ecx | stosb
            If B$esi = SPC
                dec ecx | jmp L2>
            Else_If B$esi <> ':'
                jmp L1<
            End_If

L2:         Mov ax ', ' | stosw
        .Else_If al = ']'
            sub edi 2 | Mov D$edi 0 | ret       ; strip ending ' ,'
        .End_If
    Loop L0<


WithoutDataGlobalScope:
L0: lodsb
    .If al = '['
        On B$esi <> '@', jmp L2>
        While al <> ']'
            lodsb | dec ecx         ; Strip Data if unwished
        End_While
    .Else_If al = '@'
        If B$GenericName > 0
            Push esi
                Mov esi GenericName | lodsb
L1:             stosb | lodsb | cmp al 0 | ja L1<
            Pop esi
        End_If
    .Else
L2:     stosb
    .End_If
    loop L0<
ret


WithoutDataLocalScope:
L0: lodsb
    .If al = '['
        On B$esi <> '@', jmp L2>
        While al <> ']'
            lodsb | dec ecx         ; Strip Data if unwished
        End_While
    .Else_If al = '@'
        stosb
        If B$GenericName > 0
            Push esi
                Mov esi GenericName | lodsb
L1:             stosb | lodsb | cmp al 0 | ja L1<
            Pop esi
        End_If
    .Else_If al = '$'
      ; Strip '$' in 'D$@'
        On B$esi <> '@', stosb
    .Else_If al = '$'
      ; Strip '$' in 'D$@'
        On B$esi <> '@', stosb
    .Else
L2:     stosb
    .End_If
    loop L0<
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Struct          ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

; The Structures DialogBox ([Struct] Menu option):

[WinStructures: D$ ?]
____________________________________________________________________________________________
____________________________________________________________________________________________
;;
 Data in the .str Files are like this:

     [POINT:|x D|y D
     [POINTS:|x W|y W
     [RECT:|left D|top D|right D|bottom D

 For multi-units records:

     [FONTSIGNATURE:|fsUsb4 D 4|fsCsb2 D 2
                              ^          ^
 Nested Structures are expanded:

     [RBHITTESTINFO:|pt.x D|pt.y D|flags D|iBand D
                     ^^^^^^^^^^^^^
 Equates Values are given as this:

     [MIXERCONTROLDETAILS_LISTTEXTA:|dwParam1 D|dwParam2 D|szName < MIXER_LONG_NAME_CHARS
                                                                    ^^^^^^^^^^^^^^^^^^^^^
 (Without the '&').
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

[StructHelp: B$ 'Structures' EOS]

StructDialog:

    .If B$StructuresFileOK = &TRUE
        If D$H.Struct = 0
            Call 'USER32.DialogBoxParamA' D$H.Instance, 18000, &NULL, StrucProc, &NULL
        Else
            Call Beep
        End_If

    .Else
        Call Help B_U_AsmName, IncludeFilesHelp, BUAsmHlpMessage

    .End_If
ret


[H.Struct: D$ ?
 H.StructCombo: D$ ?
 H.StructEdit: D$ ?
 H.StructTitleEdit: D$ ?]

; Tag Dialog 18000

Proc StrucProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_INITDIALOG
        Move D$H.Struct D@hwnd

        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon

       ; Call 'USER32.SetWindowLongA' D@hwnd &GWL_EXSTYLE &WS_EX_TOOLWINDOW

        Call 'USER32.GetDlgItem' D@hwnd 10 | Mov D$H.StructCombo eax
        Call 'USER32.GetDlgItem' D@hwnd 11 | Mov D$H.StructEdit eax
        Call 'USER32.GetDlgItem' D@hwnd 30 | Mov D$H.StructTitleEdit eax
        Call InitStructListBox
        Call InitSerFormFlag
        Call 'USER32.GetDlgItem' D@hwnd 10
        Call 'USER32.SetFocus' eax
        jmp L8>>

    ...Else_If D@msg = &WM_COMMAND
        .If W@wParam = 21
            Mov D$StructHeadFlag NACKEDSTRUCT | Call ReBuildStructForm
        .Else_If W@wParam = 22
            Mov D$StructHeadFlag LOCALSTRUCT | Call ReBuildStructForm
        .Else_If W@wParam = 23
            Mov D$StructHeadFlag SEMISTRUCT | Call ReBuildStructForm
        .Else_If W@wParam = 24
            Mov D$StructHeadFlag DASHSTRUCT | Call ReBuildStructForm
        .Else_If W@wParam = 40
            movzx eax W@wParam | Call SetFormFlags | Call ReBuildStructForm
        .Else_If W@wParam = 41
            movzx eax W@wParam | Call SetFormFlags | Call ReBuildStructForm
        .Else_If W@wParam = 42
            movzx eax W@wParam | Call SetFormFlags | Call ReBuildStructForm
        .Else_If W@wParam = 50
            If B$ZeroOrQuestionMark = '?'
                Mov B$ZeroOrQuestionMark '0'
            Else
                Mov B$ZeroOrQuestionMark '?'
            End_If
           Call ReBuildStructForm
        .End_If

        Mov eax D@wParam | and D@wParam 0FFFF | shr eax 16
        .If eax = &CBN_SELCHANGE
            Call InitStructureName | Call BuildStructForm

        .Else_If eax = &EN_CHANGE
            If W@wParam = 30
                Call GetStructureUserName | Call ReBuildStructForm
            End_If

        .Else_If D@wParam = &IDCANCEL
            jmp L1>

        .Else_If D@wParam = &IDOK
            Call ClipStructure
L1:         Mov D$H.Struct 0

            Call VirtualFree WinStructures

            Call 'USER32.EndDialog' D@hwnd 0

        .Else_If D@wParam = &IDHELP
            Call Help, B_U_AsmName, StructHelp, ContextHlpMessage

        .Else_If eax = &BN_CLICKED
            Mov eax D@wParam

       .End_If

    ...Else_If D@msg = &WM_CTLCOLOREDIT
        jmp L1>

    ...Else_If D@msg = &WM_CTLCOLORLISTBOX
L1:     Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>

    ...Else
L8:     popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE

L9: EndP

____________________________________________________________________________________________

[StructTitle: D$ ? # 50]
[StructTitleLen: D$ ?]
[UserStructTitle: D$ ? # 50]
[StructEditText: D$ ? # 1000]

; Fill the ComboBox with all 'WinStructures' Data:

InitStructListBox:
    Call OpenStructureFile

    Mov esi D$WinStructures
    While B$esi <> 0
        lodsb
        If al = '['
            Mov edi StructTitle
L1:             lodsb | cmp al ':' | je L2>
                stosb | jmp L1<
L2:         Mov B$edi 0
            Call 'USER32.SendMessageA' D$H.StructCombo &CB_ADDSTRING 0 StructTitle
        End_If
    End_While
    Mov D$StructTitle 0
ret


[MenuID: D$ ?
 SeveralStructuresFiles: D$ ?
 H.StructuresFile: D$ ?
 StructuresFileSize: D$ ?]

[MenuItemString: B$ ? # &MAX_PATH]

OpenStructureFile:
    .If B$StructuresFileOK = &FALSE
        Call Help, B_U_AsmName, IncludeFilesHelp, ContextHlpMessage | ret

    .Else_If B$SeveralStructuresFiles = &TRUE
        Mov esi EquatesName, edi MenuItemString
        While B$esi <> 0 | movsb | End_While
        dec edi
        While B$edi <> '.' | dec edi | End_While

L0:     dec edi | cmp B$edi '\' | je L1>
                  cmp B$edi ':' | je L1>
                  cmp edi MenuItemString | ja L0<
                    jmp L2>
L1:     inc edi
L2:     Mov ecx &MAX_PATH | add ecx MenuItemString | sub ecx edi
      ; Case when Call from the ToolBar
        On D$MenuID = 0, Mov D$MenuID 4001
        Call 'USER32.GetMenuStringA' D$H.MenuMain, D$MenuID, edi, ecx, &MF_BYCOMMAND

        Mov esi MenuItemString
        While B$esi <> 0 | inc esi | End_While | Mov D$esi '.str', B$esi+4 0

    .End_If

    Call 'KERNEL32.CreateFileA' MenuItemString &GENERIC_READ,
                                &FILE_SHARE_READ, 0, &OPEN_EXISTING,
                                &FILE_ATTRIBUTE_NORMAL, 0
    Mov D$H.StructuresFile eax

    Call 'KERNEL32.GetFileSize' eax 0 | Mov D$StructuresFileSize eax

    Call VirtualAlloc WinStructures,
                      eax


    Call 'KERNEL32.ReadFile' D$H.StructuresFile, D$WinStructures,
                             eax, NumberOfReadBytes, 0

    Call 'KERNEL32.CloseHandle' D$H.StructuresFile
ret

____________________________________________________________________________________________

InitStructureName:
    Call 'USER32.SendMessageA' D$H.StructCombo &CB_GETCURSEL 0 0
    Push eax
        Call 'USER32.SendMessageA' D$H.StructCombo &CB_GETLBTEXT eax StructTitle
        Mov D$StructTitleLen eax
    Pop eax
    Call 'USER32.SendMessageA' D$H.StructCombo &CB_GETLBTEXT eax UserStructTitle
    Call 'USER32.SendMessageA' D$H.StructTitleEdit &WM_SETTEXT 0 UserStructTitle
ret

____________________________________________________________________________________________

; strucMode: 0 > Data    1 > Equates    2 > Stack Macro
[H.OnMode: D$ ?
 StructMode: D$ ?]


InitSerFormFlag:
    Mov eax D$StructHeadFlag | add eax 21
    Call 'USER32.SendDlgItemMessageA' D$H.Struct eax &BM_SETCHECK 1 0

    Mov eax D$StructMode | add eax 40
    Call 'USER32.SendDlgItemMessageA' D$H.Struct eax &BM_SETCHECK 1 0
ret



SetFormFlags:
    Mov D$StructMode eax | sub D$StructMode 40

    Call 'USER32.GetDlgItem' D$H.Struct eax | Mov D$H.OnMode eax

    Call 'USER32.GetDlgItem' D$H.Struct 40
    Call 'USER32.SendMessageA' eax &BM_SETCHECK 0 0
    Call 'USER32.GetDlgItem' D$H.Struct 41
    Call 'USER32.SendMessageA' eax &BM_SETCHECK 0 0
    Call 'USER32.GetDlgItem' D$H.Struct 42
    Call 'USER32.SendMessageA' eax &BM_SETCHECK 0 0

    Call 'USER32.SendMessageA' D$H.OnMode &BM_SETCHECK 1 0
ret

____________________________________________________________________________________________


ReBuildStructForm:
    cmp B$StructTitle 0 | je L9>
        Call SetStructHeadText | Call BuildStructForm
L9: ret


BuildStructForm:
    Mov edi StructEditText, eax 0, ecx 1000 | rep stosd

  ; First, search the structure inside 'WinStructures' list same for all forms):
    Mov esi D$WinStructures, bl B$StructTitle, eax D$StructTitleLen

L1: inc esi
    While B$esi <> bl
        inc esi
    End_While
    cmp B$esi-1 '[' | jne L1<
    Push esi
        Mov ecx eax
        Mov edi StructTitle | repe cmpsb
        Mov dl B$esi
    Pop esi | jne L1<
    cmp dl ':' | jne L1<
    add esi eax | inc esi

    If D$StructMode = 0
        Call BuildStructDataForm
        sub edi 3 | Mov al ']' | stosb |  Mov B$edi 0
    Else_If D$StructMode = 1
       Call BuildStructEquForm
       sub edi 3 | Mov al ']' | stosb |  Mov B$edi 0
    Else_If D$StructMode = 2
       Call BuildStructStackForm
       sub edi 3 |  Mov B$edi 0
    End_If

    Call StripDoubleColon

    Call 'USER32.SendMessageA' D$H.StructEdit &WM_SETTEXT 0 StructEditText
ret


StripDoubleColon:
    Mov esi StructEditText
    While B$esi > 0
        lodsb
        If al = ':'
            On B$esi = ':', Mov B$esi SPC
        End_If
    End_While
ret

[ZeroOrQuestionMark: B$ '?'] ; !!! 1*ASCII

BuildStructDataForm:
  ; Write the Structure main name in the EditBox:
    Mov edi StructEditText

    Push esi
        Mov esi UserStructTitle
        Mov al '[' | stosb
        While B$esi <> 0
            movsb
        End_While
        Mov al ':' | stosb
    Pop esi
    Mov al 13 | stosb | Mov al 10 | stosb | Mov al SPC | stosb

; Write the items:
;
; [REBARBANDINFO:|cbSize D|fMask D|fStyle D|clrFore D|cl...
;                ^
    Call SetStructHeadText

L0: Call WriteStructHead
    inc esi                                           ; jmp over first '|'
    If B$esi+1 = '|'
        ; case of missing names: "[DDEUP:|D|D'
    Else_If B$esi+1 < SPC
        ; ... Same for: "[DDELN:|D"
    Else
        While B$esi <> SPC
        movsb
        End_While
        Mov al ':' | stosb
        inc esi
    End_If

; [REBARBANDINFO:|cbSize D|fMa...
;                        ^
    ..If B$esi+1 = '|'
L3:     If B$esi = 'B'
            Mov eax ' B$ '
        Else_If B$esi = 'W'
            Mov eax ' W$ '
        Else_If B$esi = 'D'
            Mov eax ' D$ '
        Else_If B$esi = 'Q'
            Mov eax ' Q$ '
        Else_If B$esi = 'F'
            Mov eax ' F$ '
        Else_If B$esi = 'U'
            Mov eax ' U$ '
        Else_If B$esi = 'T'
            Mov eax ' T$ '
        End_If
        stosd | Mov eax 0200A0D30 | Mov al B$ZeroOrQuestionMark | stosd
      ; 0200A0D30 =  '0' 13 10 SPC
        inc esi

    ..Else_If B$esi+1 = 13
        jmp L3<

    ..Else_If B$esi+1 = SPC
        add edi 2

L4:         dec edi | cmp B$edi 13 | jne L4<
L4:         dec esi | cmp B$esi-1 '|' | jne L4<
            On B$edi-1 = ']', dec edi
          ; No more need of Square Brackets for Multiple Data:
           ; Mov eax 05B0A0D5D | stosd              ;  05B0A0D5D = ']' 13 10 '['
           Mov W$edi CRLF, B$edi+2 SPC | add edi 3
                Call WriteStructHead
                While B$esi <> SPC
                    movsb
                End_While
            Mov al ':' | stosb | inc esi

        If B$esi = 'B'
            Mov eax ' B$ '
        Else_If B$esi = 'W'
            Mov eax ' W$ '
        Else_If B$esi = 'D'
            Mov eax ' D$ '
        Else_If B$esi = 'U'
            Mov eax ' U$ '
        Else_If B$esi = 'Q'
            Mov eax ' Q$ '
        Else_If B$esi = 'F'
            Mov eax ' F$ '
        Else_If B$esi = 'T'
            Mov eax ' T$ '
        End_If

        stosd | dec edi | Mov eax ' 0 #' | stosd | Mov al B$ZeroOrQuestionMark, B$edi-3 al
        add esi 2
        If B$esi >= 'A'
            Mov al '&' | stosb  ; If it is a Win Equate instead of a value.
        End_If
        While B$esi <> '|'
            On B$esi = 13, jmp L5>
            movsb
        End_While
     ; No more need of Square Brackets for Multiple Data:
L5:   ;  Mov eax 05B0A0D5D | stosd   ; 05B0A0D5D =  ']' 13 10 '['
      Mov W$edi CRLF, B$edi+2 SPC | add edi 3
        If B$esi <> '|'
          ; dec edi
        End_If
    ..Else
L6:     movsb | cmp B$esi '|' | je L7>
                cmp B$esi 13 | jne L6<
L7:     Mov al 13 | stosb | Mov al 10 | stosb | Mov al SPC | stosb
    ..End_If

L9: cmp B$esi '|' | je L0<<
ret


[StructDisplacement: D$ ?]

BuildStructEquForm:
  ; Write the Structure main name in the EditBox:
  ; esi is on 'WinStructures'
    Mov edi StructEditText, D$StructDisplacement 0

        Mov al '[' | stosb

BuildFromEquRoutine:           ; reused (called by 'BuildStructStackForm')

; Write the items:
;
; [REBARBANDINFO:|cbSize D|fMask D|fStyle D|clrFore D|cl...
;                ^
    Call SetStructHeadText

L0: Call WriteStructHead

    inc esi                                           ; jmp over first '|'

    .If B$esi+1 = '|'
        ; case of missing names: "[DDEUP:|D|D'
    .Else_If B$esi+1 < SPC
        ; ... Same for: "[DDELN:|D"
    .Else
        While B$esi <> SPC
            movsb
            If W$esi = '::'
                inc esi | jmp L1>
            End_If
        End_While
L1:     Mov eax 'Dis ' | stosd
    .End_If

    Mov eax D$StructDisplacement
  ; Destination String pointed by edi. eax holds the value to translate in Ascii Decimal.
    Mov dl 0FF | Push edx                       ; Push stack end mark
    Mov ecx 10
L1: Mov edx 0
    div ecx | Push edx | cmp eax 0 | ja L1<     ; Push remainders
L2: Pop eax                                     ; Retrieve Backward
    cmp al 0FF | je L3>                         ; Over?
       add al '0' | stosb | jmp L2<             ; Write
L3: Mov al 13 | stosb | Mov al 10 | stosb | Mov al SPC | stosb

  ; Cases of '::', as found above:
    If B$esi = ':'
        jmp L0<
    End_If

    inc esi

; [REBARBANDINFO:|cbSize D|fMa|cl... |bReserved < 2|dwDa...|rcChild RECT<>|rcBand RECT<>...
;                        ^
    ..If B$esi+1 = '|'
        If B$esi = 'B'
            add D$StructDisplacement 1
        Else_If B$esi = 'W'
            add D$StructDisplacement 2
        Else_If B$esi = 'D'
            add D$StructDisplacement 4                                   ; WinStructures
        Else_If B$esi = 'Q'
            add D$StructDisplacement 8
        Else_If B$esi = 'F'
            add D$StructDisplacement 4
        End_If
        inc esi

    ..Else_If B$esi+1 = SPC
      ; Cases of multiple Values (#n)
        Mov bl B$esi | add esi 2 | Mov ecx 0, eax 0
L4:     lodsb
        cmp al '|' | je L6>>
        cmp al '9' | ja L4>
        cmp al '0' | jb L5>>

                sub al '0'                  ; convert Decimal to binary:
                lea ecx D$ecx+ecx*4         ;     ecx = ecx * 5
                lea ecx D$eax+ecx*2         ;     ecx = eax + old ecx * 10
        jmp L4<
L4:
            Mov D$imm32 0
            pushad
                Mov edi DataLoopWinEquate
                ;Mov al '&' | stosb |
                dec esi
                While B$esi > SPC
                    movsb | On B$esi = '|', jmp L4>
                End_While
L4:             Mov al 0 | stosb
                Mov esi DataLoopWinEquate
                Mov B$ShowWinEquateError &FALSE

                Call ReadWin32Equate | on B$EquateFound = &TRUE, Mov D$imm32 eax
            popad

            If B$EquateFound = &TRUE
                Mov ecx D$imm32
            Else
                Mov ecx 1
            End_If

            Mov B$ShowWinEquateError &TRUE, D$imm32 0
            While B$esi >= 'A'
                inc esi | On B$esi = '|', jmp L5>
            End_While
            If D$esi = ' + 1'
                inc ecx | add esi 4
            End_If

L5:   ; Error case

L6:     If bl = 'B'
            Mov eax 1
        Else_If bl = 'W'
            Mov eax 2
        Else
            Mov eax 4
        End_If
        mul ecx | add D$StructDisplacement eax | dec esi

    ..End_If

        While B$esi <> '|'
            On B$esi = 13, jmp L9>
            inc esi
        End_While

L9: cmp B$esi '|' | je L0<<
ret


BuildStructStackForm:

    Mov edi StructEditText | add edi 100 | Mov D$StructDisplacement 0

    Call BuildFromEquRoutine

    While B$esi <> '|'        ; Back one item to count the last one size
        dec esi
    End_While

    While B$esi <> SPC
        inc esi
    End_While
    inc esi

    .If B$esi+1 <= CR
        If B$esi = 'B'
            add D$StructDisplacement 1
        Else_If B$esi = 'W'
            add D$StructDisplacement 2
        Else_If B$esi = 'D'
            add D$StructDisplacement 4
        Else_If B$esi = 'Q'
            add D$StructDisplacement 8
        Else_If B$esi = 'F'
            add D$StructDisplacement 4
        End_If
        inc esi
;;
    .Else    ;_If B$esi+1 = SPC
  ; In fact(, it apears that, when the Structure is ended by a Table, this Table Length
  ; is already counted inside the D$StructDisplacement provided by 'BuildFromEquRoutine'.
        Mov bl B$esi | add esi 2 | Mov ecx 0
L4:     lodsb
        cmp al '9' | ja L5>
        cmp al '0' | jb L5>
        cmp al '|' | je L6>
                sub al '0'                  ; convert Decimal to binary:
                lea ecx D$ecx+ecx*4         ;     ecx = ecx * 5
                lea ecx D$eax+ecx*2         ;     ecx = eax + old ecx * 10
        jmp L4<
L5:     ; Error case
L6:     If bl = 'B'
            Mov eax 1
        Else_If bl = 'W'
            Mov eax 2
        Else
            Mov eax 4
        End_If
        mul ecx | add D$StructDisplacement eax | dec esi
;;

    .End_If

    Mov edi StructEditText, esi UserStructTitle  ; Write "Structure @NAME"
    Mov eax 'Stru' | stosd | Mov eax 'ctur' | stosd | Mov ax 'e ' | stosw | Mov al '@' | stosb
        While B$esi <> 0
            movsb
        End_While
        Mov al SPC | stosb

    Mov eax D$StructDisplacement
    AlignOn 4 eax                              ; Stack must remain aligned, whatever.

  ; Destination String pointed by edi. eax holds the value to translate in Ascii Decimal.
    Mov dl 0FF | Push edx                       ; Push stack end mark
    Mov ecx 10
L0: Mov edx 0
    div ecx | Push edx | cmp eax 0 | ja L0<     ; Push remainders
L2: Pop eax                                     ; Retrieve Backward
    cmp al 0FF | je L9>                         ; Over?
       add al '0' | stosb | jmp L2<             ; Write
L9:
    Mov ax ', ' | stosw

    Mov esi StructEditText | add esi 100

    While B$esi <> 0
        lodsb
        If al = 13
            Mov al ','
        Else_If al = 10
            Mov al SPC
        End_If
        stosb
    End_While
ret

____________________________________________________________________________________________


[StructHeadText: D$ ? # 50]

WriteStructHead:
    Push esi
        Mov esi StructHeadText
        While B$esi > 0
            movsb
        End_While
    Pop esi
ret

[NACKEDSTRUCT 0    LOCALSTRUCT 1    SEMISTRUCT 2    DASHSTRUCT 3]

[StructHeadFlag: D$ ?]

; Defining What text will (or none) be added at the begining of each symbol:

SetStructHeadText:
    pushad
        Mov edi StructHeadText

        If B$StructMode = 2
            Mov al '@' | stosb | jmp L1>
        End_If

        .If D$StructHeadFlag = NACKEDSTRUCT
            ; 0

        .Else_If D$StructHeadFlag = LOCALSTRUCT
            Mov al '@' | stosb

        .Else
L1:         Call GetStructureUserName
            Mov esi UserStructTitle
            While B$esi <> 0
                movsb
            End_While
            If D$StructHeadFlag = SEMISTRUCT
                Mov al '.' | stosb
            Else
                Mov al '_' | stosb
            End_If

        .End_If

        Mov al 0 | stosb
    popad
ret
____________________________________________________________________________________________

GetStructureUserName:
    Call 'USER32.SendMessageA' D$H.StructTitleEdit &WM_GETTEXT 150 UserStructTitle
ret

____________________________________________________________________________________________

[ClipStructureMemory: D$ ?]

ClipStructure:

    Push D$LP.BlockStartText,
         D$LP.BlockEndText,
         D$FL.BlockInside

        Call VirtualAlloc ClipStructureMemory,
                          4000

        Move D$LP.BlockStartText D$ClipStructureMemory

        Call 'USER32.SendMessageA' D$H.StructEdit,
                                   &WM_GETTEXT,
                                   4000,
                                   D$ClipStructureMemory

        If eax > 0

            add eax D$LP.BlockStartText

            Mov D$FL.BlockInside &TRUE,
                D$LP.BlockEndText eax

            Call ControlC

            Call VirtualFree ClipStructureMemory

        End_If

L9: Pop D$FL.BlockInside,
        D$LP.BlockEndText,
        D$LP.BlockStartText

ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Format          ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;;
 >>> 'PeHeader' <<<
 SubSystem: W$ 2 > GUI // 3 > CON

 CodeCharacteristics:
 D$   0_60000020                ; readable, runable, code
      0_40000040                ; readable
      0_C0000040                ; readable, writable, initialised data
      0_C0000000                ; Not readable initialised data; don't keep; don't cache
      0_6000840                 ; Not readable initialised data; don't keep; don't cache
0x00000020 code. Usually set in conjunction with the executable flag (0x80000000
0x00000040 initialized data. Almost all sections except executable and the .bss section have this flag set.
0x00000080 uninitialized data (for example, the .bss section).
0x00000200 comments or some other type of information. A typical use of this section is the .drectve section emitted by the compiler, which contains commands for the linker.
0x00000800 shouldn't be put in the final EXE file. These sections are used by the compiler/assembler to pass information to the linker.
0x02000000 can be discarded, since it's not needed by the process once it's been loaded. The most common discardable section is the base relocations (.reloc).
0x10000000 shareable. When used with a DLL, the data in this section will be shared among all processes using the DLL. The default is for data sections to be nonshared, meaning that each process using a DLL gets its own copy of this section's data. In more technical terms, a shared section tells the memory manager to set the page mappings for this section such that all processes using the DLL refer to the same physical page in memory. To make a section shareable, use the SHARED attribute at link time. For example
LINK /SECTION:MYDATA,RWS ...
tells the linker that the section called MYDATA should be readable, writeable, and shared.
0x20000000 executable. This flag is usually set whenever the "contains code" flag (0x00000020) is set.
0x40000000 readable. This flag is almost always set for sections in EXE files.
0x80000000 writeable. loader should mark the memory mapped pages as read-only or execute-only. Typical sections with this attribute are .data and .bss. Interestingly, the .idata section also has this attribute set.

 >>> code = 0_60000020 (unwriteable) // 0_A0000020 (Writeable)
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

OutputFormat:
    If D$H.Output = 0
        Call 'USER32.DialogBoxParamA' D$H.Instance, 19000,  D$H.MainWindow, OutputFormatProc, 0
    Else
        Call Beep | ret
    End_If

    .If D$TempoSavingExtension  = '.DLL'
        If D$H.Output = 0
            Call 'USER32.DialogBoxParamA' D$H.Instance, 21000,  D$H.MainWindow, DLLFormatProc, 0
        Else
            Call Beep | ret
        End_If
    .End_If
;;
    .If D$TempoSavingExtension  = '.SYS'
        If D$H.Output = 0
            Call 'USER32.DialogBoxParamA' D$H.Instance, 21001,  D$H.MainWindow, SYSFormatProc, 0
        Else
            Beep | ret
        End_If
    .End_If
;;
ret


[TempoSubSystem: D$ ?
 TempoSavingExtension: D$ ?
 TempoCodeCharacteristics: D$ ?
 TempoDataCharacteristics: D$ ?
 TempoLinkerDllDefault: D$ ?
 H.Output: D$ ?]

; Tag Dialog 19000

Proc OutputFormatProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_COMMAND
        .If D@wParam = &IDCANCEL
            jmp L1>

        .Else_If D@wParam = &IDOK
            Call SaveOutputFormat
L1:         Mov D$H.Output 0 | Call 'USER32.EndDialog' D@hwnd 0

        .Else_If D@wParam = 10
          ; GUI:
            Mov D$TempoSubSystem &IMAGE_SUBSYSTEM_WINDOWS_GUI,
                D$TempoSavingExtension '.EXE'
        .Else_If D@wParam = 11
          ; CON:
            Mov D$TempoSubSystem &IMAGE_SUBSYSTEM_WINDOWS_CUI,
                D$TempoSavingExtension '.EXE'
        .Else_If D@wParam = 12
          ; ScreenSaver:
            Mov D$TempoSubSystem &IMAGE_SUBSYSTEM_WINDOWS_GUI,
                D$TempoSavingExtension '.SCR'
        .Else_If D@wParam = 13
          ; DLL:
            Mov D$TempoSubSystem &IMAGE_SUBSYSTEM_WINDOWS_GUI,
                D$TempoSavingExtension '.DLL' | Call DlgSetRelocs; jE!
        .Else_If D@wParam = 14
          ; SYS:
            Mov D$TempoSubSystem &IMAGE_SUBSYSTEM_NATIVE,
                D$TempoSavingExtension '.SYS' | Call DlgSetRelocs; jE!
; 'SubSystem'
        .Else_If D@wParam = 210

    ;  ..Else_If D$wParam = 211                                    ; Num EditControls, no use.
    ;  ..Else_If D$wParam = 212
    ;  ..Else_If D$wParam = 213

        .Else_If D@wParam = 300                                     ; Writeable Code
            xor D$TempoCodeCharacteristics 0_8000_0000

        .Else_If D@wParam = 301
            xor D$TempoDataCharacteristics &IMAGE_SCN_MEM_SHARED

        .Else_If D@wParam = 302 ; jE! Relocs
            xor D$FL.RelocsWanted &TRUE

        .Else
            jmp L8>>

        .End_If

    ...Else_If D@msg = &WM_INITDIALOG
        Move D$H.Output D@hwnd
        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon

        Call InitOutputDialog

    ...Else
L8:     popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE

L9: EndP

DlgSetRelocs: Mov D$FL.RelocsWanted &TRUE | Call 'USER32.CheckDlgButton' D$H.Output, 302, &TRUE | ret; jE!

[LinkerDllDefaultString: B$ '           ' EOS] [DllAttachDetach: D$ ?]

; Tag Dialog 21000

Proc DLLFormatProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_COMMAND
        ..If D@wParam = &IDCANCEL
L1:         Mov D$H.Output 0
            Call 'USER32.EndDialog' D@hwnd 0

        ..Else_If D@wParam = &IDOK
            Mov ax W$DllAttachDetach, W$DllCharacteristics ax
            Call SaveDLLLinkerDefault | cmp eax 0 | jne L1<

 ; DllCharacteristics:     ; 0001h - Per-Process Library Initialization
 ;                         ; 0002h - Per-Process Library Termination
 ;                         ; 0004h - Per-Thread Library Initialization
 ;                         ; 0008h - Per-Thread Library Termination

        ..Else_If D@wParam = 200             ; &DLL_PROCESS_ATTACH = 1
            or D$DllAttachDetach 4 | xor D$DllAttachDetach 4
            or D$DllAttachDetach 1
            Call CheckDLLFlags
        ..Else_If D@wParam = 201             ; &DLL_PROCESS_DETACH = 0
            or D$DllAttachDetach 8 | xor D$DllAttachDetach 8
            or D$DllAttachDetach 2
            Call CheckDLLFlags
        ..Else_If D@wParam = 202             ; &DLL_THREAD_ATTACH = 2
            or D$DllAttachDetach 1 | xor D$DllAttachDetach 1
            or D$DllAttachDetach 4
            Call CheckDLLFlags
        ..Else_If D@wParam = 203             ; &DLL_THREAD_DETACH = 3
            or D$DllAttachDetach 2 | xor D$DllAttachDetach 2
            or D$DllAttachDetach 8
            Call CheckDLLFlags

        ..Else_If D@wParam = 100                                     ; LinkerDllDefault

        ..Else
            jmp L8>>

        ..End_If

    ...Else_If D@msg = &WM_INITDIALOG
        Move D$H.Output D@hwnd
        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        Mov edi LinkerDllDefaultString, ecx 10 al SPC | rep stosb
        Mov eax D$LinkerDllDefault, ebx eax | Mov edi LinkerDllDefaultString | add edi 10
        std
            Mov ecx, 8
L1:         Mov al bl | and al 0F | On al >= 0A, add al 7
            add al, '0' | stosb | shr ebx, 4 | loop L1<
        cld
        inc edi
        Push edi
            Call 'USER32.GetDlgItem' D@hwnd 100
        Pop edi
        Call 'USER32.SendMessageA' eax &WM_SETTEXT 0 edi

        Mov ax W$DllCharacteristics, W$DllAttachDetach ax
        Call CheckDLLFlags

    ...Else
L8:     popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE

L9: EndP

____________________________________________________________________________________________

[DllAdressRange: B$ "
 Smaller than: 0_8000_0000
 Bigger  than:    040_0000     " EOS]
[DllAdressRangeTitle: B$ 'Dll Load Adress range is:' EOS]

SaveDLLLinkerDefault:
    Call 'USER32.GetDlgItem' D$H.Output 100
    Call 'USER32.SendMessageA' eax &WM_GETTEXT 11 LinkerDllDefaultString

    Mov esi LinkerDllDefaultString, ebx 0, eax 0
L0: lodsb | cmp al SPC | je L0<
            cmp al '_' | je L0<
            cmp al 0   | je L8>
    sub al '0' | On al > 9, sub al 7
    If al > 0F
        Mov eax 0 | jmp L9>
    End_If
    shl ebx 4 | add ebx eax | jmp L0<

L8: Mov eax ebx | AlignOn 01000 eax
    If eax < 0_40_0000
        jmp L2>
    Else_If eax >= 0_8000_0000
L2:     Call 'USER32.MessageBoxA' D$H.MainWindow, DllAdressRange, DllAdressRangeTitle, &MB_SYSTEMMODAL
        Mov eax 0
    Else
        Mov D$LinkerDllDefault eax
    End_If

L9: ret


 ; DllCharacteristics:     ; 0001h - Per-Process Library Initialization
 ;                         ; 0002h - Per-Process Library Termination
 ;                         ; 0004h - Per-Thread Library Initialization
 ;                         ; 0008h - Per-Thread Library Termination

CheckDLLFlags:

    On D$DllAttachDetach = 0, Mov D$DllAttachDetach 3    ; Default on first run

    Test D$DllAttachDetach 1 NOT_ZERO L1>
        or D$DllAttachDetach 4 | jmp L2>    ; If not 1 > 4
L1: and D$DllAttachDetach 0_FFFF_FFFB       ; If 1 > not 4

L2: Test D$DllAttachDetach 2 NOT_ZERO L1>
        or D$DllAttachDetach 8 | jmp L2>    ; If not 2 > 8
L1: and D$DllAttachDetach 0_FFFF_FFF7       ; If 2 > not 8

L2: Call 'USER32.CheckDlgButton' D$H.Output 200 &FALSE
    Call 'USER32.CheckDlgButton' D$H.Output 201 &FALSE
    Call 'USER32.CheckDlgButton' D$H.Output 202 &FALSE
    Call 'USER32.CheckDlgButton' D$H.Output 203 &FALSE

    Test D$DllAttachDetach 1 ZERO L1>
        Call 'USER32.CheckDlgButton' D$H.Output 200 &TRUE
L1: Test D$DllAttachDetach 2 ZERO L1>
        Call 'USER32.CheckDlgButton' D$H.Output 201 &TRUE
L1: Test D$DllAttachDetach 4 ZERO L1>
        Call 'USER32.CheckDlgButton' D$H.Output 202 &TRUE
L1: Test D$DllAttachDetach 8 ZERO L1>
        Call 'USER32.CheckDlgButton' D$H.Output 203 &TRUE
L1: ret

____________________________________________________________________________________________

InitOutputDialog:
    Move D$TempoCodeCharacteristics D$CodeCharacteristics
    Move D$TempoDataCharacteristics D$DataCharacteristics
    Move D$TempoSavingExtension D$SavingExtension
    Move D$TempoSubSystem D$SubSystem
    Move D$TempoLinkerDllDefault, D$LinkerDllDefault

    Call 'USER32.SetDlgItemInt' D$H.Output, 210, D$AppStackMin, 0
    Call 'USER32.SetDlgItemInt' D$H.Output, 211, D$AppStackMax, 0
    Call 'USER32.SetDlgItemInt' D$H.Output, 212, D$AppHeapMin, 0
    Call 'USER32.SetDlgItemInt' D$H.Output, 213, D$AppHeapMax, 0

    test D$CodeCharacteristics 0_8000_0000 ZERO L2>
        Call 'USER32.CheckDlgButton' D$H.Output, 300, &TRUE

L2: test D$DataCharacteristics &IMAGE_SCN_MEM_SHARED ZERO L2>
        Call 'USER32.CheckDlgButton' D$H.Output, 301, &TRUE

L2: If D$SavingExtension = '.SCR'
        Call 'USER32.CheckDlgButton' D$H.Output, 12, &TRUE
    Else_If D$SavingExtension = '.DLL'
        Call 'USER32.CheckDlgButton' D$H.Output, 13, &TRUE
    Else_If D$SavingExtension = '.SYS'
        Call 'USER32.CheckDlgButton' D$H.Output, 14, &TRUE
    Else_If D$SubSystem = 2
        Call 'USER32.CheckDlgButton' D$H.Output, 10, &TRUE
    Else_If D$SubSystem = 3
        Call 'USER32.CheckDlgButton' D$H.Output, 11, &TRUE
    End_If

    Call 'USER32.CheckDlgButton' D$H.Output,
                                 302,
                                 D$FL.RelocsWanted ; jE!

   Call LoadCommandLine

ret


SaveOutputFormat:
    Call 'USER32.GetDlgItemInt' D$H.Output, 210, &NULL, &FALSE | AlignOn 01000 eax
        Mov D$AppStackMin eax
    Call 'USER32.GetDlgItemInt' D$H.Output, 211, &NULL, &FALSE | AlignOn 01000 eax
        On eax < D$AppStackMin, Mov eax D$AppStackMin
        Mov D$AppStackMax eax
    Call 'USER32.GetDlgItemInt' D$H.Output, 212, &NULL, &FALSE
        On eax > 0,  AlignOn 01000 eax
        Mov D$AppHeapMin eax
    Call 'USER32.GetDlgItemInt' D$H.Output, 213, &NULL, &FALSE | AlignOn 01000 eax
        On eax < D$AppHeapMin, Mov eax D$AppHeapMin
        Mov D$AppHeapMax eax

    Move D$CodeCharacteristics D$TempoCodeCharacteristics
    Move D$DataCharacteristics D$TempoDataCharacteristics
    Move D$SavingExtension D$TempoSavingExtension
    Move D$SubSystem D$TempoSubSystem

    On D$TempoSavingExtension = '.SYS',
       Mov W$DllCharacteristics &IMAGE_DLLCHARACTERISTICS_WDM_DRIVER

    Call SaveCommandLine
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE Disassembler    ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
  'StripSectionsZeroEnd', 'FlagApiProcedures'
  
  'DisDataTypeRouter', 'MarkSSEdata'
 
 'HLL_Strings_Table_notes'
 'FlagApiProcedures', 'SetApiProcedure', 'WriteDisCodeLabel', 
 'WriteOneDataLabel', 'WriteDisPointers'

 'SelectMainWindowProc'
 
 'ForcedFlagsProc' 'DisassembleProc' 'WriteForcedMapFiles'
 
 'ConditionalJumpsAnalyzes' 'IsConditionalShortJump' 'IsLoop'
 
 'DisImageBase' 'UnlikelyOut'
 
 'WriteOneDataChunk' >>> 'DisDataTypeRouter' 'FlagPointerToPointer'
  
 'Map'
 
 'DisMain' 'ForceMenusExType' 'WriteDisRelative' 'EndWithDisByteRelative'
 'WritedWordPointers'
 'DisFail'
 'MarkEvocated' 'StoreDisSize' <<< for Size Markers
 'IsItCode' 'CheckAsciiData'
 'DisassembleForCodeRouting' 'TryToDisassembleEvocated' 'DisassembleAndWrite'
 'WriteDBandData' 'AlignRecognition' 'WriteOneDataChunk' >>> 'DisDataTypeRouter'
 'SearchMainWindowProc'
 'WriteDisRelative', 'FlagApiProcedures', 'StoreDisSize'
 'IsItCode'
 
  For Menus: EnableMenuItem
  
 'NamedIdSubstitution'  'WriteDisMenuIDs'
 
 'ST0ToAscii'
 
 'DisOp1'
____________________________________________________________________________________________
 
 For volunteers: 'OpenDev' / 'HLLAnalyzes' / ...

 Strategy:
 
   Once loaded, the target PE is re-mapped from File Alignement (usually 0200) to Memory
   alignement (usually 01000). The Name of this Target Table is yet 'UserPeStart'

   Then Tables are created, with the same length as the mapped PE. They are 'Flag Images'
   of the Target:
   
 * The 'SectionsMap' Table is for storing Sections Flags.
 * The 'RoutingMap' Table is for storing the routing Flags.
 * The 'SizesMap' Table is for the Sizes of evocated Data.
 
   These Table are duplicated , for the Negative Strategy, in 'InitDisTablesCopies'
   and friends.
 
 ________________ Positive Strategy ____________________
 (This is to say, searching, first, for all very highly probable Code and Data).
  
 * Mark 'Main'.
 
 * Search the EVOCATED Procedure (PUSH_EBP)
 
 * 'DisassembleForCodeRouting' for main and identified procedures
 
 * Search for Data Strings, Unicode Strings, PointersFlows, ...
 
 * (Sure Code marked CODEFLAG // Data Strings, Pointers and Sizes Marked >>> DATAFLAG)
 
 
 ________________ Negative Strategy ____________________
 (This is to say, everything left unflaged, that could be considerd Code will
 much likely kill something already identified valid, either as Code or as Data
 if it would not be interpreted as Data).

 * 'TryToDisassembleEvocated' >>> ItsItCode >>> Yes (it looks like valid Codes
   >>>> 'DisassemblingAttempt' >>> No Code broken // No Data in Disassembly 
   >>> Valid Code >>> Run 'DisassembleForCodeRouting' on all Evocated Location
   not yet Flaged as a Section.
 
 * All remaining zeroed Sections Flags to Data.
____________________________________________________________________________________________
____________________________________________________________________________________________
;;

[FirstDisVirtualData: D$ ?]

; re-mapped target File:

;;
  All of these Tables are the same size as the PE to be disassembled.
  
  'SectionsMap' is simply for flaging the various sections. The Flags are the
  ones found at 'CODEFLAG'
  
  'RoutingMap' is mainly for flaging the Code Flow, as found by r=the Recognitions
  and by the various Disassembling passes. The Flags are the ones found at 'INSTRUCTION'.
  In this List of Equates, 'EVOCATED' is not only for Code, but is used as well for
  Data.
  
  'SizesMap' is for flaging the Memory accesses. The purpose is for pointing Data
  out. The Flags are the one at 'BYTE'
  
  'StringsMap' is a Table of dWords, where each dWord is a mirror of a Byte, in
  the PE, and where each dWord may be a Pointer to a Symbol String, located
  anywhere Else.
  
  A Macro 'ToStringsMapFrom' is provided to help switching from any other Map, to
  the Strings Table. This Macro is used each time a Label is being written, so
  that the Symbolic Name could be given, in the outputed Source, with the usual
  synthetic Label.
;;

[SectionsMap: D$ ?
 EndOfSectionsMap: D$ ?]

[RoutingMap: D$ ?
 EndOfRoutingMap: D$ ?]

[SizesMap: D$ ?
 EndOfSizesMap: D$ ?]

[StringsMap: D$ ?
 EndOfStringsMap: D$ ?]

;;
  Macro for switching from any Map to StringsMap:
  
  ToStringsMapFrom Map reg ; example:
  
  ToStringsMapFrom SectionsMap, ebx
;;

[ToStringsMapFrom | sub #2 D$#1 | shl #2 2 | add #2 D$StringsMap]

;;
  ToStringsMapFrom is evocated from: 'MarkEntryPoint', 'WriteOneDataLabel',
  'WriteDisPointers', 'SetWINDCLASSData', 'SetWINDCLASSEXData', 'SetApiProcedure',
  'WriteDisCodeLabel', 'SetProcStrings'
;;

; ('EndOf...' points the Byte *after* // All the Length are 'D$UserPeLen')

; Sections Flags:
[CODEFLAG 1, DATAFLAG 2, VIRTUALFLAG 4, IMPORTFLAG 8, RESOURCESFLAG 010
 EXPORTFLAG 040,  KILLFLAG 080, TEMPOFLAG 0FF]

[TWOTEMPOFLAGS 0FFFF TWODATAFLAGS 0202
 FOURCODEFLAGS 01010101    FOURDATAFLAGS 02020202    FOURTEMPOFLAGS 0FFFF_FFFF
 FOUR_RESOURCESFLAG 010101010]
; 02 0A 01
; Routing Flags:  ; 01A (0A=EVOCATED+LABEL) 012 01F 010 09F 04A
[INSTRUCTION         1  ; > Start of an Instruction.
 EVOCATED        00_10  ; > little weight marker for any supposed evocation.
 NODE           00_100  ; > Directely CALLed or JMPed Location (+INSTRUCTION+LABEL)
 LABEL         00_1000  ; > Labelled Data Location.
 CHUNKEND      00_1000  ; > Location after a RET or a JMP (should be LABEL+NODE)
 ACCESSED    00_1_0000  ; > Marks a chunk of Instructions by direct Call or jump.
 EXPORTNODE 00_10_0000  ; > Used for direct write of Exported Function Labels Names.
 INDIRECT  00_100_0000  ; > Data Reference to Code. No effect if not Instruction aligned.
 PUSH_EBP 00_1000_0000] ; > Futur NODE (typical CallBack entry-Point).

; 04A >  00_100_1010 EVOCATED LABEL INDIRECT
; 01F
; 016 >>> 10110
; 17    >>>   001_0001  ; Instruction / Accessed  //  0A EVOCATED+LABEL 012

; Sizes Flags: ; 014 045
;[BYTE 1, WORD 00_10, DWORD  00_100
[FP4 00_1000, FP8 00_1_0000, FP10 00_10_0000
 POINTER 00_100_0000, STRINGS 00_1000_0000]

[LeaInstruction: &FALSE]

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
 Initialisation of the Disassembly:
 
 We clear all of the Disassembler internal data, from 'FirstDisVirtualData'
 to 'LastDisVirtualData', and free all of the Data that could have been for
 a previously loaded PE.
 
 We intialize The Truth Ascii Table, for Ascii and Unicode Recognitions, and
 initialize the ProgreesBar, for the Disassembly time.
;;

DisInitialise:
  ; Clear all Disassembler job Virtual Data:
    Mov edi FirstDisVirtualData, eax 0

    While edi < LastDisVirtualData | stosd | End_While

    AlignOn 4 D$UserPeLen

    Mov B$Disassembling &TRUE

    Call CloseTree | Call ReInitUndo | Call ReInitHeaderFormat

    Call VirtualFree BookMarks | Call ClearBackTable | Call ReleaseResourceMemory

    Call BuildTruthAsciiTable

    Call InitDisProgressBar
;;
  The steping of the Progress Bar is just a simple evaluation. The Range is set
  (in 'InitDisProgressBar') at 0 to 128. So that we have to shr 7 for having the
  step size. But, as the Disassembler is run at least 4 times (2 or more for Pass1 /
  1 for Pass2 / 1 for Pass3), we estimate the number of Passes at 8 (> shl 3).
  So 7-3 > 4.
;;
    Mov eax D$UserPeLen | shr eax 4 | or eax 1
    Mov D$DisBarStep eax | Move D$NextDisBarPos D$UserPeStart

    Mov eax D$UserPeStart
    If D$eax+059 = 'spit'
        On D$eax+069 = ' wiz', Mov D$CompiledBy 'ROSA'
    End_If

    Mov D$DisMainWindowProc 0
ret
____________________________________________________________________________________________

; 'DisMain' is called by 'OpenRosAsmPe' if no Source found inside and if the
; user wants it.

[DisWarningMessage: B$ ' ... with Un-modified File Name.           ' EOS]
[DisWarningTitle: B$ 'Take care!!!...' EOS]

[WritingData: B$ 'Writing Data...' EOS]
[DisPasses: B$ 'Analyze of the Code flow...' EOS]
[PointersAnalyzes: B$ 'Analyzes of pointers to Code. Wait...' EOS]
[NegativeAnalyze: B$ 'Negative Analysis of Code. May be slow...' EOS]

[EndOfDisData: D$ ?]
____________________________________________________________________________________________

MarkRosAsmPeSections:
    GetPeHeader SectionsHeaders | Mov esi eax

    Mov ecx D$DisNumberOfSections

L0: Push ecx
        Mov edi D$esi+SECTION_RVA | add edi D$SectionsMap
        Mov ecx D$esi+SECTION_RVASIZE | AlignOn 01000 ecx

        Mov eax D$esi

        .If eax = '.ida'
            Mov al IMPORTFLAG
        .Else_If eax = '.rsr'
            Mov al RESOURCESFLAG
        .Else_If eax = '.dat'
            Mov al DATAFLAG, ecx D$esi+SECTION_RVASIZE, edx D$esi+SECTION_FILESIZE
            On edx < ecx, xchg ecx edx
            AlignOn 32 ecx
            Push ecx
                rep stosb
            Pop eax
            Mov ecx D$esi+SECTION_RVASIZE, edx D$esi+SECTION_FILESIZE
            On edx > ecx, xchg ecx edx
            AlignOn 01000 ecx | sub ecx eax
            Mov al VIRTUALFLAG
        .Else_If eax = '.tex'
          ; Not CODEFLAG. It would kill the 'TryToDisassembleEvocated' job:
            Mov al 0, ecx D$esi+SECTION_RVASIZE, edx D$esi+SECTION_FILESIZE
            On edx < ecx, xchg ecx edx
            add ecx 7
            Push ecx
                rep stosb
            Pop eax
            Mov ecx D$esi+SECTION_RVASIZE, edx D$esi+SECTION_FILESIZE
            On edx > ecx, xchg ecx edx
            AlignOn 01000 ecx | sub ecx eax
            Mov al KILLFLAG
        .Else_If eax = '.eda'
            Mov al EXPORTFLAG
        .Else
            Mov al KILLFLAG
        .End_If

        rep stosb
    Pop ecx

    add esi SECTIONHEADERSIZE | dec ecx | jnz L0<<
ret

____________________________________________________________________________________________

[OriginalDisPe: B$ ? # &MAX_PATH]
[UserDisPeName: B$ ? # &MAX_PATH]

Proc SaveDisPeName:

    Argument @STR.A.Destination

    Uses esi,
         edi

    Mov esi MainName,
        edi D@STR.A.Destination

    While B$esi <> EOS | movsb | End_While

    Mov eax D$SavingExtension | stosd | Mov B$edi EOS

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[CompiledBy: D$ ?
 LastDisassemblyRoutingPass: D$ ?]

DisMain: ; 'MSVBVM' 'OpenRosAsmPe', 'DisassembleProc'
    Mov B$LastDisassemblyRoutingPass &FALSE

    Call SaveDisPeName OriginalDisPe
    ___________________________
  ; Initialise the Disassembly:
;;
  When loading a PE without Source, the 'OpenRosAsmPE' Routine jumps here.
  'UserPeStart' point to the Start of the PE load into Memory, and 'UserPeLen'
  holds the length of the PE. All of this is the PE as found on Disk.
;;
  ; For 'DisFail' short exit:
    Mov eax esp, D$OldStackPointer eax, D$CompiledBy 0

    Call DisInitialise | Call FixMzParagraphsNumber

  ; 'ReadResourcesRecord' seems to fail at pointing out GoAsm Resources.
  ; Not sure: To be verified.

    Call LoadDisResources

    Call StartNewDisFile | Call ReAlignPE | Call AllocateDisTables

; 'OutputFormat'
; Hexprint D$SavingExtension | jmp DisFail
    ____________________________________________________________
;;
  The PE in Memory is now ready for analyzes.
;;
  ; We don't need .reloc and .debug:
    Call KillPeHeader | Call KillSection RelocSectionTable | Call KillSection DebugDir
;map
  ; Check the secure Sections:
    Call CheckImport | Call CheckExport
;map
    Call CheckResources
;map
    Call CheckVirtualData | Call CheckExtendedVirtual

    Call SmallBlanksToSameFlag
;map
    Call KillSectionsExtensions
;map
    _____________________________________________________________

  ; If called from 'TryDisassembly' or from 'ReRunDisassembler':
    If B$WithForcedMapFile = &TRUE
        Call ReadForcedRecordsFile
        On D$ForcedRecordsTable <> 0, Call ForceRecordsToMaps
    Else

        Call DeleteForcedFile

        Call VirtualFree ForcedRecordsTable

    End_If

  ; Sniff Recognition should come here...
    If D$CompiledBy = 'ROSA'
        Call MarkRosAsmPeSections
;map
    Else_If D$CompiledBy = 'MSVB'
        Call MarkVbPe
    Else
      ; ...
    End_If
;map
    ;
    ____________________________________________________________
;;
    Guga D.I.S. Identification Plan:
  
    Call GetDisPath | Call LoadOneDisFile {B$ 'Pe' EOS}, '.dis'
    
    ; LoadPeDisFile
    
    .If B$DisFileOk = &TRUE
        VirtualAlloc PeDisMatches 01000 | Move D$PeDisMatchesPointer D$PeDisMatches
  
        Call ParsePeDis
        Call GetBiggerPeDisID
        
        VirtualFree PeDisMatches
        jmp DisFail
    .End_If
;;
    ____________________________________________________________
  ; Here we go for Code vs Data Recognitions:
    ______________________________________
  ; Positive Recognition for Data and Code:

  ; 'MarkEvocated' _MUST_ be kept _first_ Recognition.
    Call MarkEvocated | Call ConditionalJumpsAnalyzes
;map
    Call MarkEntryPoint
    Call MarkProcedures | Call MarkJumpsTables
;map
    Call MarkPointersFlows | Call MarkAlternatedPointersFlows
;map
    Call DisassembleForCodeRouting
;map
    Call MarkVeryRepetitiveDataBytes ; (12 identical Bytes >>> Data)
;Map
    Call MarkEvocatedSizes
;map
    Call MarkRepetitiveDataBytes ; (8 identical Bytes >>> Data)
;;;map
; Probably obsolete. Anyway, should not be at thins place:
    ;Call ExtendStrings | Call FillStringsSizes
;Map
    Call UnEvocatedProcedures

    Call DisassembleForCodeRouting

    Mov B$Forced &TRUE
    Call AsciiRecognition 25 | Call UnicodeRecognition 25
    Mov B$Forced &FALSE
;Map
    Call SmallBlanksToSameFlag
;Map
    Mov B$LastDisassemblyRoutingPass &TRUE
    Call DisassembleForCodeRouting
    Mov B$LastDisassemblyRoutingPass &FALSE

    Call FlagTrueDataSection
;map
    Call MarkIsolatedPointers
;map
    Call SmallBlanksToSameFlag
;map
    Call FlagsCleaner
;map
    ;Call FlagTrueDataSection ; Better 4 lines above.
;map

    _________________________________________________________________
  ; Try&See recognitions of left Code // Negative Recognition of Data:
    Call 'USER32.SendMessageA' D$H.ForBar, &WM_SETTEXT, 0, PointersAnalyzes
;
    Call CodeFromPointers

    If B$AttemptSuccess = &TRUE
        Call DisassembleForCodeRouting
        Call SmallBlanksToSameFlag
    End_If

    Call 'USER32.SendMessageA' D$H.ForBar, &WM_SETTEXT, 0, NegativeAnalyze

    Call GetBiggerSectionsBlank | Mov ecx D$BiggerZeroedSectionsChunk
;map

    .Do
L0:     Push ecx
            Call TryToDisassembleEvocated ecx

            If B$AttemptSuccess = &TRUE
                Call DisassembleForCodeRouting
                Call SmallBlanksToSameFlag
;;
  This inner loop is Bound to "jmp L9>", in 'TryToDisassembleEvocated'. When these
  are uncommented, the results tend to be a little bit better. The problem is that
  it all becomes way too slow:
;;
                ;Pop ecx | jmp L0<
;;
  Therefore, we can expect that a more sophisticated way for choosing the biggest
  Chunks could perhaps be implemented.
;;
            End_If
        Pop ecx
;;
  To be watched: The tuning of these Strings jobs have impact on 3DFUN.EXE. Example,
  reducing the last (smaller) length, breaks the rebuilt. Remark: There is no need of
  scaning smaller Chunks here, as they should be assumed later, by 'DisDataTypeRouter'.
;;
        Push ecx
            .If ecx < 100
                If ecx > 50
                    Call AsciiRecognition 20 | Call UnicodeRecognition 20 | jmp L9>
                End_If
            .End_If

            .If ecx <= 50
                If ecx > 25
                    Call AsciiRecognition 15 | Call UnicodeRecognition 15 | jmp L9>
                End_If
            .End_If

            .If ecx <= 25
                If ecx > 13
                    Call AsciiRecognition 12 | Call UnicodeRecognition 12 | jmp L9>
                End_If
            .End_If
L9:     Pop ecx

        shr ecx 1 | Mov eax ecx | shr eax 1 | add ecx eax
  ; Let the ecx = 0. This is to say down to one _Instruction_:
    .Loop_Until ecx = 0
;map
    Call FlagsCleaner

    Call DisassembleForCodeRouting

    Call SmallBlanksToSameFlag
;Map
    Call DisAlign
;Map
    ;Call RemoveNonAccessedEvocatedData
;Map
  ; All Code pointed out >>> Not flaged Chunks to Data:
    Call FillDataSection | Call StripSectionsZeroEnd

    Call MarkIsolatedPointers ; Second Call really helpfull?
;map
    Mov B$LastDisassemblyRoutingPass &TRUE

    Call DisassembleForCodeRouting
;Map
    Call CheckPointersInData

    Call SplitBigData
;map
    Call FlagsCoherency

    Call FlagsCleaner
;map

    _________________________________
    _________________________________

  ; Recognitions over: The real Disassembly output begins here.
    ________________________________________________________
  ; Now we write the Source. We need the original File Name. Save it first:

    Mov edi D$CodeSource | Call WriteOriginalFileNameInSource

  ; then, Default Macros, and Data:

    Mov D$NextDisTITLE edi | add D$NextDisTITLE (TITLE_MAX/2) | Mov W$DisTitle+12 '01'

    Call 'USER32.SendMessageA' D$H.ForBar, &WM_SETTEXT, 0, WritingData
;Map
    If B$WithMacros = &TRUE
        On D$SavingExtension <> '.SYS', Call WriteMacros
    End_If

    Mov D$EndOfDisData edi

  ; ... and then Code:
;Map
    Mov D$NextDisBarPos 0 | Call DisassembleAndWrite  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;Call TestStringsTable
    pushad
        Call WriteMapFiles ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        Call WriteForcedRecordsFileBase
    popad

    ________________________________
  ; Preparing for the Source Editor:
    Call SetDisSourceVariables

  ; Searching for 'MainWindowProc' Location:
   ;On D$SavingExtension <> '.DLL', Call SearchMainWindowProc

    If B$MenuInside = &TRUE
         ; called from 'MenuIdsSubstitutions', 'PrepareDisMenuIDs' Builds the
           ; Table of Menu Ids Declarations
            Call MenuIdsSubstitutions
            On B$WM_COMMAND_Found = &TRUE, Call ResetMenusIDs
        End_If
    End_If

    Call NamedIdSubstitution

    Call VirtualFree TruthAsciiTable

    Call VirtualFree ApiBuffer

    Call VirtualFree UserPeStart | Move D$UserPeStart D$CodeSource

    Call VirtualFree SectionsMap

    Call VirtualFree RoutingMap

    Call VirtualFree SizesMap

    Call VirtualFree StringsMap

;;
  Because the 'normal' way to load a PE, in RosAsm, implements the 'CodeSource'
  pointer into the 'UserPeStart' Mem Chunk. Here, we do not define the Mem size
  depending on the File Source size, but we evaluate the size from the Code
  length after analyze of the PE.

  + If Resources saved by Name: Set ID Numbers ?????
;;

    Call SetBUAWindowText

    Mov D$DestinationFile 0

    Mov D$STRUC.OPENFILENAME@lpstrTitle ChangeNameTitle
    Mov esi SaveFilter
    While B$esi <> 0 | inc esi | End_While
    dec esi | lea edi D$esi+2
    std
        Do
            movsb | On B$esi = '\', jmp L1>
        Loop_Until esi < SaveFilter
L1:     inc esi | Mov W$esi 'My'
    cld

    .If D$WithForcedMapFile = &FALSE
        Call ChangeName ;| Mov D$STRUC.OPENFILENAME@lpstrTitle OpenPEFileTitle

        If eax = &FALSE
            Call 'USER32.MessageBoxA' D$H.MainWindow, DisWarningMessage, DisWarningTitle,
                                    &MB_SYSTEMMODAL__&MB_ICONSTOP
        End_If

        Call SaveDisPeName UserDisPeName

    .Else
        Call SaveNewFileName ;| Mov D$STRUC.OPENFILENAME@lpstrTitle OpenPEFileTitle
        Call SaveDisPeName UserDisPeName

        Call SetBUAWindowText

    .End_If

    Call StartEdition | Move D$UserPeStart D$CodeSource

    Mov B$Disassembling &FALSE, D$FL.SourceReady &TRUE

    Call DestroyDisProgressBar

    Mov B$ThisSourceIsDisassembled &TRUE
ret


DestroyDisProgressBar:
    On D$ProgressInst <> 0, Call 'USER32.DestroyWindow' D$ProgressInst
    On D$H.ForBar <> 0, Call 'USER32.DestroyWindow' D$H.ForBar
    Mov D$ProgressInst 0, D$H.ForBar 0
ret
____________________________________________________________________________________________

[MenuInside: D$ ?]

LoadDisResources:
    __________________________________________________________________________
  ; Next Lines are the same as the ones in 'OpenRosAsmPE' after having read the
  ; included Source:

    Mov B$MenuInside &FALSE

    Call SearchDisPEstartOfResource | On B$NoResourcesPE = &TRUE, jmp L9>>

  ; Here, 'UserPEStartOfResources' is the IMAGE_OPTIONAL_HEADER Sections aligned Pointer
  ; to Header.
    Mov eax D$UserPEStartOfResources, ebx 0 | On eax = 0, jmp L9>>

L0: shl ebx 1 | or ebx 1 | test eax ebx ZERO L0<
    shr ebx 1 | and eax ebx

    Push eax
        Call SearchPEstartOfResource
      ; Here 'UserPEStartOfResources' is the Sections Header File Aligned Section Pointer.
      ; We need this one but with the eventual Dis to Header (header not necessary at
      ; first Section Byte.
    Pop eax

    .If D$UserPEStartOfResources <> 0
        or D$UserPEStartOfResources eax

        Move D$iExePtr D$UserPeStart

        Mov eax D$UserPEStartOfResources, D$iStartOfResources eax
        Call DisReadMainIcon

        If B$PeIconFound = &TRUE
            Mov esi eax | Mov edi iIcon | rep movsb ; Copying to icon editor buffer
            Call StoreIcon                          ; and copy it to 'compilable' image
        End_If

        Call ReadRosAsmResources

        If D$MenuList+4 <> 0
            Call ForceMenusExType | Mov B$MenuInside &TRUE
        End_If
    .End_If
L9: ret


SearchDisPEstartOfResource:
    Mov B$NoResourcesPE &TRUE, D$UserPEStartOfResources 0
    Mov esi D$DisPeTagPointer | On esi = 0, ret

  ; RVA of resources from "Image Data Dir...":
    add esi 136 | lodsd
    If eax <> 0
        add eax D$UserPeStart | Mov D$UserPEStartOfResources eax
        Move D$ResourcesSize D$esi
        Mov B$NoResourcesPE &FALSE
    End_If
ret
____________________________________________________________________________________________

; There are 2 types of Win Menus: Menu and MenuEx. RosAsm work only with MenuEx Type.
; In case an old type is encounted we need a translation:

ForceMenusExType:  ; ExistingMenu
    Mov ebx MenuList                                ; (ID / Ptr / Size)
    While D$ebx+4 <> 0
        Mov esi D$ebx+4
        If W$esi = 0

            Call TurnThisMenuToExType     ; First Header Word is 0 (old) / 1 (EX)

        End_If

        add ebx 12
    End_While
ret


[DisExMenuMemoryPointer: D$ ?]

TurnThisMenuToExType:
    Mov D$PopUpNumber 1

    Mov ecx D$ebx+8 | Mov edx ecx | shl edx 3
  ; esi > Menu Template // ecx Length of Menu Template (*8 estimation > edx).

    Call VirtualAlloc DisExMenuMemoryPointer,
                      edx

  ; Menu Header:
    Mov edi D$DisExMenuMemoryPointer
    Mov W$edi 1 | add edi 2     ; Type.
    Mov W$edi 4 | add edi 2     ; Displacement to next Item.
    Mov D$edi 0 | add edi 4     ; Help ID.
    movzx eax W$esi+2 | add eax 4 | add esi eax

  ; Items:
  ; Split MF_Flags into MFT_Flags / MFS_Flags / MFR_Flags.
L0:
  ; Security in case of perverted Menu: Old Menus begin by W$ Flags W$ ID. So the first
  ; dWord can't be zeroed, even in case of PopUp -with no ID-:
  ;;;  On D$esi = 0, jmp L9>>
  ;;; Commented out because it troncates the Menus after the first separator...
    movzx eax W$esi
    and eax &MFT_BITMAP__&MFT_MENUBARBREAK__&MFT_MENUBREAK__&MFT_RIGHTJUSTIFY__&MFT_SEPARATOR
    stosd
    Mov ax W$esi
    and eax &MFS_CHECKED__&MFS_DEFAULT__&MFS_GRAYED__&MFS_HILITE
    stosd
    Mov ax W$esi
    and eax &MF_END__&MF_POPUP
    add esi 2

    Mov D$edi 0
    Test eax &MF_POPUP ZERO L1>
        and eax (not &MF_POPUP) | or eax 1      ; 1 = My MF_POPUP substitution.
        inc D$PopUpNumber
      ; No ID in old Menu for POPUP item:
        add edi 4 | jmp L2>

L1: movsw | add edi 2      ; ID

L2: stosw       ; My MF_END / &MF_POPUP >>> ax yet holds the MF_Flags.
    Test eax &MF_END ZERO L1>
        dec D$PopUpNumber
L1:
;;
  ; Menu: Items                  //     MenuEx Items
    W$     ; Menu Item Flags            D$      ; Type >>> 0
    W$     ; ID (none for PopUp)        D$      ; State >>> 0
    US     ; 'String' EOS               W$      ; ID
                                        B$      ; END / POPUP / 0
                                        B$ 0    ; Align
                                        US      ; 'String' EOS
                                        Align 4
                                      ; If PopUp:
                                        D$      ; HelpID
;;
    While W$esi <> 0 | movsw | End_While | movsw | AlignOn 4, edi

L1: Test eax 1 ZERO L1>             ; 1 = My MF_POPUP substitution.
        Mov D$edi 0 | add edi 4

L1: cmp D$PopUpNumber 0 | ja L0<<

L9: Mov eax edi | sub eax D$DisExMenuMemoryPointer | Mov D$ebx+8 eax

    lea eax D$ebx+4 | Call VirtualFree eax

    Move D$ebx+4 D$DisExMenuMemoryPointer
    Mov ecx edi | sub ecx D$DisExMenuMemoryPointer
ret


[BasemenuId: D$ ?]

ResetMenusIDs:
    Mov ebx MenuList                                ; (ID / Ptr / Size)
    While D$ebx+4 > 0
        Move D$BasemenuId D$ebx
        Push ebx
            Call ResetThisMenuIDs
        Pop ebx
        add ebx 12
    End_While
ret


ResetThisMenuIDs:
    Mov esi D$ebx+4, edx D$ebx+8 | add edx esi

;[MENUEX_TEMPLATE_HEADER:
; wVersion: W$ 0
; wOffset: W$ 0
; dwHelpId: D$ 0]

    add esi 8

;[MENUEX_TEMPLATE_ITEM:
; dwType: D$ 0
; dwState: D$ 0
; uId: D$ 0
; bResInfo: W$ 0
; szText:U1
; dwHelpId: D$ 0]

L0: add esi 8 | movzx eax W$esi+4     ; Save Pos of possible POPUP Flag
    and eax (not &MF_END)
    .If eax = 0    ; &MF_END  080 // &MF_POPUP 010   ; Menu
        If W$esi+6 <> 0     ; 0 > Separator
            inc D$BasemenuId | Move D$esi D$BasemenuId
        End_If
    .End_If

L2: add esi 6
  ; Name (including 2 zeros if Separators):
    While W$esi <> 0 | add esi 2 | End_While | add esi 2 | AlignOn 4, esi

    If eax <> 0
      ; Help ID:
        add esi 4
    End_If

L2: cmp esi edx | jb L0<
ret
____________________________________________________________________________________________

SetDisSourceVariables:
    Mov D$STRUCT.EditData@SourceEnd edi
    Mov D$SourceLen edi, eax D$CodeSource | sub D$SourceLen eax
    Mov eax 0A0D0A0D, ecx 100 | rep stosd                            ; end security tail

    Mov eax D$CodeSource
    Mov D$STRUCT.EditData@CurrentWritingPos eax, D$STRUCT.EditData@CaretLine 0, D$STRUCT.EditData@CaretRow 1

    Move D$STRUCT.EditData@UpperLine D$CodeSource
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  We read all through the PE and search for Pointers to PE Locations.
  3 Processes are done:
  * Simple Evocations >>> EVOCATED
  * Pointers to Code saying 'Push ebp | Mov ebp esp' / 'Enter' >>> PUSH_EBP+EVOCATED
  * Pointer Lists >>> EVOCATED+NODE+ACCESSED
;;

[EntryPointName: B$ "
Main:" EOS]

MarkEntryPoint:
    Mov eax D$DisEntryPoint | sub eax D$DisImageBase | add eax D$RoutingMap
    or B$eax NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
    sub eax D$RoutingMap | add eax D$SectionsMap | Mov B$eax CODEFLAG

    ToStringsMapFrom SectionsMap, eax | Mov D$eax EntryPointName
ret
____________________________________________________________________________________________

MarkEvocated:
; We are going to analyze the PE up to the last dWord (Mov eax D$esi >>> error!!!). So:
    sub D$UserPeEnd 4
;;
 EVOCATED is a 'little weight' Flag, just saying that some reference has been found
 to this Location. Nothing more. It may come from hazard. NODE / LABEL are stronger
 meaning (considered definitive significant Locations).
 
 Search for any reference (evocation) to a Code, Data or Virtual Data Location all 
 along the File being disassembled. When found, we mark the Routing Map Byte pointed
 by the evocation with EVOCATED:
;;

    Mov esi D$UserPeStart | add esi D$FirstSection
  ; Relative:
    .While esi < D$UserPeEnd
        Mov eax esi | add eax 4 | add eax D$esi
;Push eax
;    Mov eax esi | sub eax D$UserPeStart | add eax D$DisImageBase
;    On eax = 0440899, int3
;Pop eax
        ;sub eax D$DisImageBase | add eax D$UserPeStart

        ...If eax > D$UserPeStart
            ..If eax < D$UserPeEnd
                sub eax D$UserPeStart | add eax D$SectionsMap
                Mov bl B$eax | and bl IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG
                .If bl = 0
                    sub eax D$SectionsMap | add eax D$RoutingMap
                  ; eax >>> "Pointed to" Location
                    If B$esi-1 = 0E8
                        test B$eax EVOCATED ZERO L1>
                      ; 1 chance on 400,000 * (2 or more) for both case:

                      ; 2 or more Call Instructions to the same location:
                        or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                        Mov ebx eax | sub ebx D$RoutingMap | add ebx D$SectionsMap
                        Mov B$ebx CODEFLAG

                    Else_If B$esi-1 = 0E9
                        test B$eax EVOCATED ZERO L1>
                      ; 2 or more JMP Instructions to the same location:
                        or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                        Mov ebx eax | sub ebx D$RoutingMap | add ebx D$SectionsMap
                        Mov B$ebx CODEFLAG

L1:                     or B$eax EVOCATED

                    End_If

                .End_If
            ..End_If
        ...End_If

L5:     inc esi
    .End_While

    Mov esi D$UserPeStart | add esi D$FirstSection
  ; Absolute:
    While esi < D$UserPeEnd
        Mov eax D$esi | sub eax D$DisImageBase | add eax D$UserPeStart
        ..If eax > D$UserPeStart
            .If eax < D$UserPeEnd
                sub eax D$UserPeStart | add eax D$SectionsMap
                Mov bl B$eax | and bl IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG
                If bl = 0
                    sub eax D$SectionsMap | add eax D$RoutingMap
                    or B$eax EVOCATED
                End_If
            .End_If
        ..End_If

L5:     inc esi
    End_While

    add D$UserPeEnd 4
ret

____________________________________________________________________________________________

MarkProcedures:
;;
 'Enter' and 'Push ebp | Mov ebp esp', Locations in Code, are Flaged PUSH_EBP, in
 the 'RoutingMap' Table. But, if they also are found as EVOCATED, we consider them
 valid and accessed Code Nodes:
;;
    sub D$UserPeEnd 4

    Mov esi D$UserPeStart | add esi D$FirstSection

    .While esi < D$UserPeEnd
        Mov eax esi | sub eax D$UserPeStart | add eax D$RoutingMap
        Test B$eax EVOCATED ZERO L5>>

        Mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
        Test B$eax VIRTUALFLAG+IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+DATAFLAG NOT_ZERO L5>>

      ; 1 miss-interpretation chance on 0FFFFFF (16,777,215)
      ; * by number of "Push ebp | Mov ebp esp":
        ...If B$esi = 055               ; OpCode for "Push ebp"  Op55
            ..If B$esi-1 <> 0F          ; No Escape Prefix wanted.
                .If W$esi+1 = 0EC8B      ; 08B 0EC >  "Mov ebp esp"
L1:                 sub eax D$SectionsMap | add eax D$SectionsMap
                    If B$eax = 0
                        Mov B$eax CODEFLAG
                        sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                    Else
L2:                     sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax EVOCATED+LABEL
                    End_If

                .Else_If W$esi+1 = 0E589 ; Alternate for "Mov ebp esp" op89 / op8B
                    jmp L1<
                .End_If
            ..End_If
      ; 1 miss-interpretation chance on 0FF*(0FF-32) [* (256/8) for IsItPush case]
      ; 0FF-32 = 0CD // 0CD*FF = 0CC33 // (256/8) = 020 // 0CC33*020 = 1 on 1,672,800
      ; * by number of "Enter":
        ...Else_If B$esi = 0C8          ; OpCode for 'enter'  OpC8 Op0F
            ..If B$esi-1 <> 0F          ; No Escape Prefix wanted.
                If B$esi+3 < 32         ; Nested Levels Byte is from 0 to 31.
                    sub eax D$SectionsMap | add eax D$RoutingMap
                    lea ebx D$eax+4 | Call IsItPush ebx | cmp eax &FALSE | je L5>>
                        Mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
                        On B$eax <> 0, jmp L2>
                            Mov B$eax CODEFLAG
                            sub eax D$SectionsMap | add eax D$RoutingMap
                            or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL | jmp L5>>

L2:                     sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax EVOCATED+LABEL
                End_If
            ..End_If

       ; 1 miss-interpretation chance on 0FF * (0FF/2) * (0FF/7) = 1 on 1,165,860
         ...Else_If B$esi = 0EC
             .If B$esi-1 = 083         ; 083 0EC: OPcode for sub esp imm8
                sub eax D$SectionsMap | add eax D$RoutingMap
                lea ebx D$eax+2 | Call IsItPushRegister ebx | cmp eax &FALSE | je L5>>
                    Mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
                    If B$eax = 0
                        Mov B$eax CODEFLAG
                        sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                    Else
L2:                     sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax EVOCATED+LABEL
                    End_If

             .Else_If B$esi-1 = 081    ; 081 EC: OPcode for sub esp imm32
                sub eax D$SectionsMap | add eax D$RoutingMap
                lea ebx D$eax+5 | Call IsItPushRegister ebx | cmp eax &FALSE | je L5>
                    Mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
                    If B$eax = 0
                        Mov B$eax CODEFLAG
                        sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                    Else
L2:                     sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax EVOCATED+LABEL
                    End_If
             .End_If

        ...End_If

L5:     inc esi
    .End_While

    add D$UserPeEnd 4
ret
____________________________________________________________________________________________

UnEvocatedProcedures:
;;
 'Enter' and 'Push ebp | Mov ebp esp', Locations in Code, are Flaged PUSH_EBP, in
 the 'RoutingMap' Table. But, if they also are found as EVOCATED, we consider them
 valid and accessed Code Nodes:
;;
    sub D$UserPeEnd 4

    Mov esi D$UserPeStart | add esi D$FirstSection

    .While esi < D$UserPeEnd
        Mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
        Test B$eax VIRTUALFLAG+IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG, ;+DATAFLAG |
        NOT_ZERO L5>>

      ; 1 miss-interpretation chance on 0FFFFFF (16,777,215)
      ; * by number of "Push ebp | Mov ebp esp":
        ...If B$esi = 055               ; OpCode for "Push ebp"  Op55
            ..If B$esi-1 <> 0F          ; No Escape Prefix wanted.
                .If W$esi+1 = 0EC8B      ; 08B 0EC >  "Mov ebp esp"
L1:                 Push esi
                        Mov eax esi | add eax 50
                        Call IsItCode esi, eax, 8 ;20
                    Pop esi

                    cmp eax &FALSE | je L5>

                    Mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
                    If B$eax = 0
                        sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                        sub eax D$RoutingMap | add eax D$SectionsMap | Mov B$eax CODEFLAG
                    Else_If B$eax = CODEFLAG
                        sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                    Else
                      ; Case of Map File reuse with Flag forced to Data (to follow up):
                        sub eax D$SectionsMap | add eax D$RoutingMap
                        Mov B$eax EVOCATED+LABEL
                    End_If

                .Else_If W$esi+1 = 0E589 ; Alternate for "Mov ebp esp" op89 / op8B
                    jmp L1<

                .End_If
            ..End_If

        ...End_If

L5:     inc esi
    .End_While

    add D$UserPeEnd 4
ret


____________________________________________________________________________________________

; There is such a JMPs Table at Data043E188, in Teste.exe.

MarkJumpsTables:
    Mov esi D$UserPeStart | add esi D$FirstSection
    Mov edx D$UserPeEnd | sub edx 4
    Mov ecx 0

    .While esi < edx
       ; OpFF, 'Dis_rm32_rm16', 'WriteEffectiveAddressFromModRm'
        ...If B$esi = 0FF  ; 1 on 256
            Mov bl B$esi+1 | DigitMask bl to al
          ; 0FF /2 >>> Call r/m32 // 0FF /4 >>> JMP r/m32
            ..If al = 2    ; 2 on 8
                jmp L1>
            ..Else_If al = 4
              ; Dis32 inside ? With SIB ?
              ; For JMP or Call "D$Table+eax*4" and friends, the ModRm Byte must be:
              ; mod = 0 and r/m = 4 (SIB + dis32)
L1:             ModMask bl To al
                .If al = 0 ; 1 on 4
                    RmMask bl To al
                    If al = 4 ; 1 on 4
                        Call CheckPointersTable
                        On eax = &TRUE, add esi 7
                    End_If
                .End_If
            ..End_If
        ...End_If

        inc esi

    .End_While
ret

;;
  A flow of Bytes that could be, for example, for 'Call D$Table+eax*4' has been found.
  Is this 'Table' really a flow of Pointers. If true, the Instruction is valid Code,
  the target is valid Data, the data contents are valid Pointers to Code and the Code
  pointed by these Pointers are valid entry-points.
;;
CheckPointersTable:
    Push esi, edx

    sub D$UserPeEnd 4 | Mov eax D$esi+3
    sub eax D$DisImageBase | add eax D$UserPeStart

    ..If eax > D$UserPeStart
        .If eax < D$UserPeEnd
            Mov ebx eax
            sub eax D$UserPeStart | add eax D$SectionsMap
            test B$eax IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG NOT_ZERO L5>>
          ; OK: 'Label' is a valid Pointer to a supposed Jumps Table.
          ; Now, are the two first dWords valid Pointers ?
            Mov eax ebx, ebx D$eax | sub ebx D$DisImageBase | add ebx D$UserPeStart
            cmp ebx D$UserPeStart | jb L5>>
            cmp ebx D$UserPeEnd | ja L5>>

            Mov ebx D$eax+4 | sub ebx D$DisImageBase | add ebx D$UserPeStart
            cmp ebx D$UserPeStart | jb L5>>
            cmp ebx D$UserPeEnd | ja L5>>

              ; OK, this is a Table of Code Pointers. Flag everything:
L0:             Mov ebx D$eax | sub ebx D$DisImageBase | add ebx D$UserPeStart
                cmp ebx D$UserPeStart | jb L2>
                cmp ebx D$UserPeEnd | ja L2>
                    Mov edx eax | sub edx D$UserPeStart | add edx D$SizesMap
                    or B$edx POINTER
                    sub edx D$SizesMap | add edx D$SectionsMap
                    Mov D$edx FOURDATAFLAGS

                    sub ebx D$UserPeStart | add ebx D$SectionsMap
                    Mov B$ebx CODEFLAG
                    sub ebx D$SectionsMap | add ebx D$RoutingMap
                    Mov B$ebx PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL

                add eax 4 | jmp L0<
        .End_If
    ..End_If

L2: Pop edx, esi | add D$UserPeEnd 4 | Mov eax &TRUE | ret

L5: Pop edx, esi | add D$UserPeEnd 4 | Mov eax &FALSE | ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
  Analyzes of the Code Conditional Jumps
;;

[JumpsMap: D$ ?
 EndOfJumpsMap: D$ ?]

ConditionalJumpsAnalyzes:
  ; Create a Table, where to flag the possible Addresses pointed to, by Conditional Jumps:
    Mov eax D$EndOfSectionsMap | sub eax D$SectionsMap
    Mov D$EndOfJumpsMap eax

    Call VirtualAlloc JumpsMap,
                      eax

    mov eax D$JumpsMap | add D$EndOfJumpsMap eax

    Mov esi D$UserPeStart | add esi D$FirstSection
    Mov ebx D$SectionsMap | add ebx D$FirstSection
    Mov edx D$JumpsMap | add edx D$FirstSection
    Mov eax 0

    .While esi < D$UserPeEnd
        ...If B$ebx = 0
            ..If B$esi <> 0
                Call IsConditionalShortJump esi

                .If eax = &TRUE
L1:                 inc esi, ebx, edx | movsx eax B$esi | inc esi, ebx, edx
                    add eax edx
                    Push esi, eax, ebx, edx
                        sub eax D$JumpsMap | add eax D$UserPeStart
                        Mov ebx eax | add ebx 50
                        Call IsItCode eax, ebx, 0
                        If eax = &TRUE
                            Pop edx, ebx, eax, esi
                            inc B$eax
                        Else
                            Pop edx, ebx, eax, esi
                        End_If
                .Else
                     Call IsLoop esi
                     On eax = &TRUE, jmp L1<
                .End_If
            ..End_If
        ...End_If

        inc esi, ebx, edx
    .End_While
;;
  16 Chance on 256 (1 on 16) for a given Byte to be a Jcc.
  
  This is to say, that in a Flow of Random Bytes, one given Byte has 1 chance on
  16 to be the target of a possible Jcc. [In fact, less than that, because the
  cases of "070", ... , "07F", are way less frequent than, say "0", in a real PE]
  
  So, randomaly, there would 1 chance on 256, for a given Byte, for being the target
  of 2 JCCs, if these Jcc would not be limited to a 256 Bytes scope.
  
  Plus 3 chances on 256*2 to be a loop.
  
  Then, with the IsItCode Identification, this is considered reliable.
  
  We now cross all of this with the previously done analyzes of 'MarkEvocated',
  that flaged any Absolute or Relative Evocation of a Location.
;;
    Mov esi D$RoutingMap, edi D$JumpsMap, edx D$EndOfRoutingMap

    While esi < edx
        Test B$esi EVOCATED ZERO L2>
            On B$edi <> 0, inc B$edi
L2:     inc esi, edi
    End_While


    Mov esi D$JumpsMap | add esi D$FirstSection
    Mov edi D$SectionsMap | add edi D$FirstSection
    Mov ebx D$RoutingMap | add ebx D$FirstSection
    Mov edx D$EndOfSectionsMap

    While edi < edx
        If B$esi > 3
            On B$edi = 0, Mov B$edi CODEFLAG
            On B$edi = CODEFLAG, Mov B$ebx INSTRUCTION+EVOCATED+LABEL+ACCESSED+PUSH_EBP
            inc ecx
        End_If
        inc esi, edi, ebx
    End_While
;map

    Call VirtualFree JumpsMap

ret


;[LongJmpsOp: 0E8    ; Long Call 'OpE8'
;             0E9]   ; Long jmp    'OpE9'
;           ; 0EB    ; jmp short 'OpEB'
;;'loop' ; E0, E1, E2     OpE3 >>> jecxz
;[ShortJccOp:
;    070, 071, 072, 073, 074, 075, 076, 077, 078, 079, 07A, 07B, 07C, 07D, 07E, 07F, 0E3]
;; 0F Prefix >>> Long
;[LongJccOp:
;    080 > 08F    Op80 Op8F

;[DisCodePointer: D$ ?]

Proc IsConditionalShortJump:    ; 21 random chances on 256
    Argument @Pointer
    Uses esi, edi, ebx

        Mov esi D@Pointer, al B$esi, ebx &FALSE
;;
  Op78, Op79, Op7A, Op7B, Op7C, Op7D
  
  If these next ones have a 0F Escape Prefix, they are other Mnemonics:
  
  Op70, Op71, Op72, Op73, Op74, Op75, Op76, Op77, (....above.....)  Op7E, Op7F
  
  OpE3 is JECXZ
;;
        ...If al >= 070
            ..If al <= 07D
              ; This is can be a Conditional Short Jump
                Mov ebx &TRUE
              ; No Escape Prefix for some:
                If al <= 077
                    On B$esi-1 = 0F, Mov ebx &FALSE
                Else_If al >= 07E
                    On B$esi-1 = 0F, Mov ebx &FALSE
                End_If

              ; A bit less than 16 chances on 256, randomaly.

            ..Else_If al = 0E3
              ; OpE3 is JECXZ // DEC ecx: 049 // sub ecx 5: 083 0E9 05
                If B$esi-1 = 049
                    Mov ebx &TRUE
                Else_If W$esi-3 = 0E983
                    Mov ebx &TRUE
                Else
                    Mov ebx &FALSE
                End_If

              ; Max: (1 chance on 256) * (1 chance on 256) = 1 on 65,536
            ..End_If
        ...End_If

        If ebx = &TRUE
          ; It cannot be a jump to 0, -1, -2, -3, -4
            Mov al B$esi+1 | neg al
            On al < 5, Mov ebx &FALSE
        End_If

        Mov eax ebx
EndP


Proc IsLoop:     ; 18 random chances on 256 / by the 1 on 256 of the 0F Jcc prefix.
    Argument @Pointer
    Uses esi

        Mov esi D@Pointer, eax D$UserPeEnd | dec eax | On esi <= eax, jmp L2>

        Mov al B$esi

      ; Must be negative:
        Test B$esi+1 080 ZERO L2>

        .If al = 0E0
            Mov eax &TRUE
        .Else_If al = 0E1
            Mov eax &TRUE
        .Else_If al = 0E2
            Mov eax &TRUE
        .Else
L2:         Mov eax &FALSE
        .End_If

  ; 3 chances on 256*2 to be a loop
EndP
____________________________________________________________________________________________

Proc IsItPush:
    Argument @Location
    uses esi
      ; 8 chances on 256
        Mov esi D@Location
        sub esi D$RoutingMap | add esi D$UserPeStart | Mov al B$esi

        If al = 060
            Mov eax &TRUE       ; pushad
        Else_If al < 050
            Mov eax &FALSE
        Else_If al < 058
            Mov eax &TRUE       ; Push reg (050 to 057)
        Else
            Mov eax &FALSE
        End_If
EndP

Proc IsItPushRegister:
    Argument @Location
    uses esi
      ; 7 chances on 256
        Mov esi D@Location
        sub esi D$RoutingMap | add esi D$UserPeStart | Mov al B$esi

        If al < 050
            Mov eax &FALSE
        Else_If al < 058
            Mov eax &TRUE       ; Push reg (050 to 057)
        Else
            Mov eax &FALSE
        End_If
EndP
____________________________________________________________________________________________

; Force the small (smaller than 4) zeroed Bytes inside a Code/Data Section (SectionsMap)
; to CODEFLAG/DATAFLAAG:

SmallBlanksToSameFlag:
    Mov esi D$SectionsMap | add esi D$FirstSection
    Mov edx D$EndOfSectionsMap | sub edx 4

    While esi < edx
        .If B$esi = 0
            Mov edi esi, bl B$esi-1, ecx 0
            lodsb
            lodsb | inc ecx | cmp al bl | je L1>
                              cmp al 0 | ja L1>
            lodsb | inc ecx | cmp al bl | je L1>
                              cmp al 0 | ja L1>
            lodsb | inc ecx | cmp al bl | jne L2>
L1:         If al = bl
                rep stosb | dec esi
            End_If
        .End_If

L2:     inc esi
    End_While
ret
____________________________________________________________________________________________

[DisPeTagPointer: D$ ?]

FixMzParagraphsNumber:
    Mov D$DisPeTagPointer 0

  ; Standard manner: parag. size of dos header end > PE header address:
    Mov esi D$UserPeStart | movzx eax W$esi+8 | shl eax 4 | sub eax 4
    If eax < D$UserPeLen
        add esi D$esi+eax
    Else
        Mov eax 0
    End_If

    ..If eax <> 0
        Mov edx D$UserPeStart | add edx D$UserPeLen | sub edx 4
        .If esi < edx
            If D$esi = 'PE'
                Mov D$DisPeTagPointer esi | ret ; (No fix needed, in that case)
            End_If
        .End_If
    ..End_If

  ; Fix needed for these two other methods:
    Call GetPeTagMethod2
    If esi < edx
        On D$esi = 'PE', jmp L1>
    End_If

    Call GetPeTagMethod3 | On D$esi <> 'PE', jmp DisFail

L1: Mov D$DisPeTagPointer esi

  ; Now, esi point to the PE Tag. Fix the MZ Paragraph Number for 'SearchPEstartOfResource':
    Mov ecx esi | sub ecx D$UserPeStart

  ; Overwrite the Dos header according Displacement ('2' is for a minimum Dos Header):
    Mov edi D$UserPeStart | Mov W$edi+8 2, D$edi+(16+12) ecx

;  ; Test: Make sure it is now good for the default internal method:
;    Mov esi D$UserPeStart | movzx eax W$esi+8 | shl eax 4 | sub eax 4 | add esi D$esi+eax
;    On D$esi <> 'PE', jmp DisFail

; With such an error, the Debugger fails, when compiling RosAsm with RosAsm...
; Mov esi 0 | On D$esi <> 'PE', jmp DisFail
ret


GetPeTagMethod2:
  ; Method 2 for searching the PE Tag:
  ; If Origin >= 040 > PE header adress at 03C
    Mov eax D$UserPeStart | add eax 018
    If W$eax >= 040
        sub eax 018 | add eax 03C | movzx esi W$eax | add esi D$UserPeStart
    End_If
ret

GetPeTagMethod3:
  ; Method 3. Stupid desesparated search:
    Mov esi D$UserPeStart, ecx 0200
L0: inc esi | On D$esi <> 'PE', loop L0<
ret
____________________________________________________________________________________________

[DisNumberOfSections: D$ ?
 @DisDataMin: D$ ?
 @DisDataMax: D$ ?
 @DisVirtualMin: D$ ?
 @DisVirtualMax: D$ ?
 @DisCodeMin: D$ ?
 @DisCodeMax: D$ ?
 @DisApiMin: D$ ?
 @DisApiMax: D$ ?
 LastCodeRef: D$ ?
 DisImageBase: D$ ?
 DisEntryPoint: D$ ?
 DisPeOrigine: D$ ?
 DisRvaSectionAlignment: D$ ?
 DisFileSectionAlignment: D$ ?
 @DisBaseOfRsrc: D$ ?]

[Disassembling: D$ ?
 ThisSourceIsDisassembled: D$ ?]

; Used to switch from a RosAsm Data Label (for example, 'AppBaseOfCode') to the target
; File corresponding location:

[GetPeHeader | Mov eax #1 | sub eax DosHeader | add eax D$DisPeOrigine
 add eax D$UserPeStart]

;;
  Here, we store several Data we need along Disassembling:
  The equivalents, in the UserPE of the Displacements found in our internal Stub;
  'PeHeader', 'SubSystem', 'NumberOfSections', 'ImageBase', Sections Alignment,
  EntryPoint ('AppRVAentryPoint').
;;

StartNewDisFile:
    Mov D$DisPeOrigine 0 | GetPeHeader PeHeaderPointer

    Mov eax D$eax | sub eax 080 | Mov D$DisPeOrigine eax
  ; (080 is the RosAsm Data 'PeHeaderPointer')

    GetPeHeader PeHeader | Mov eax D$eax | On eax <> D$PeHeader, jmp DisFail
  ; Pe Header found.

  ; Like in 'ReadHeaderFormat'.
  ; Copy / SubSystem / DllCharacteristics / AppStackMax / .... :
    GetPeHeader SubSystem | Mov esi eax, edi SubSystem, ecx 5 | rep movsd

    GetPeHeader NumberOfSections | movzx eax W$eax | On eax = 0, jmp DisFail
    Mov D$DisNumberOfSections eax

    GetPeHeader ImageBase | Mov ebx D$eax, D$DisImageBase ebx, D$LinkerDllDefault ebx

    Move D$DisRvaSectionAlignment D$eax+4, D$DisFileSectionAlignment D$eax+8

    GetPeHeader AppRVAentryPoint | Mov eax D$eax | add eax D$DisImageBase
    Mov D$DisEntryPoint eax
ret

____________________________________________________________________________________________

[TempoUserPeStart: D$ ?
 DisRelocPointer: D$ ?]

[FirstSection: D$ ?
 EndOfLastSection: D$ ?]

;;
  Targetted File Mapping. Usually:

  The PE File alignment is on 0200 Bytes / Memory Image alignement is on 01000.
  In other words: On disk the Section are aligned on 0200h Boundaries // In
  Memory, the runing PE Sections are aligned on 01000h Boudaries, by the OS
  Launcher.
  
  The analyzes are made a bit easier by realigning the Sections the same way
  they are when runing in Memory.
;;

ReAlignPE:
    Mov eax D$UserPeStart | sub D$UserPEStartOfResources eax ; Gona switch...

    Mov ecx D$DisNumberOfSections, D$FirstSection 0-1, D$EndOfLastSection 0
    GetPeHeader SectionsHeaders

  ; Search for the First Section RVA:
L0: Mov ebx D$eax+SECTION_RVA
    On ebx < D$FirstSection, Mov D$FirstSection ebx
  ; Search for the last Section RVA and adds its RVA Size:
    Push ecx
        Mov ecx D$eax+SECTION_RVASIZE
      ; Some compiler (Watcom-C) may set the RVA to zero. So... :
        If ecx < D$eax+SECTION_FILESIZE
            Mov ecx D$eax+SECTION_FILESIZE
            Align_On_Variable D$DisRvaSectionAlignment ecx
          ; Fix it (just in case this would be needed later...):
            Mov D$eax+SECTION_RVASIZE ecx
        End_If

        On ebx > D$EndOfLastSection, Mov D$EndOfLastSection ebx, edx ecx
    Pop ecx
    add eax SECTIONHEADERSIZE | loop L0<

    add edx ebx | Align_On_Variable D$DisRvaSectionAlignment edx | Mov D$UserPeLen edx

    Call VirtualAlloc TempoUserPeStart,
                      edx ;D$UserPeLen

    Mov esi D$UserPeStart, edi D$TempoUserPeStart

  ; Copy the PE headers down to (including) 'SectionsHeaders':
    GetPeHeader SectionsHeaders
    Mov ecx eax | sub ecx D$UserPeStart | rep movsb

    Mov ecx D$DisNumberOfSections

L0: Push ecx
        Mov ecx SECTIONHEADERSIZE | rep movsb
    Pop ecx
    loop L0<

  ; Want to skip 'RelocSectionTable', if any:
    GetPeHeader RelocSectionTable | Move D$DisRelocPointer D$eax
  ; Copy all Sections with Memory alignment:
    GetPeHeader SectionsHeaders | Mov edx D$DisNumberOfSections

    While D$eax+SECTION_RVA <> 0
        Mov esi D$eax+SECTION_FILEPOINTER | add esi D$UserPeStart
        Mov edi D$eax+SECTION_RVA | On edi = D$DisRelocPointer, jmp L1>
        add edi D$TempoUserPeStart
        Mov ecx D$eax+SECTION_FILESIZE | AlignOn 4 ecx | shr ecx 2 | rep movsd
L1:     add eax SECTIONHEADERSIZE | dec edx | jz L2>
    End_While

L2: Exchange D$UserPeStart D$TempoUserPeStart
    Mov eax D$UserPeStart | add eax D$UserPeLen | Mov D$UserPeEnd eax

    Call VirtualFree TempoUserPeStart

ret

____________________________________________________________________________________________
;;
  Allocations of 'SectionsMap', 'RoutingMap', 'SizesMap' (more comments ther) Tables
  (All same length as the mapped File):
;;

AllocateDisTables:

    Call VirtualAlloc SectionsMap,
                      D$UserPeLen

    Call VirtualAlloc RoutingMap,
                      D$UserPeLen

    Call VirtualAlloc SizesMap,
                      D$UserPeLen

    Mov eax D$SectionsMap | add eax D$UserPeLen | Mov D$EndOfSectionsMap eax
    Mov eax D$RoutingMap | add eax D$UserPeLen | Mov D$EndOfRoutingMap eax
    Mov eax D$SizesMap | add eax D$UserPeLen | Mov D$EndOfSizesMap eax

    If D$StringsMap = 0

        Mov eax D$UserPeLen | shl eax 2

        Call VirtualAlloc StringsMap,
                          eax

        add eax D$StringsMap | mov D$EndOfStringsMap eax

    End_If

  ; And widely evaluated disassembly Source:
    Mov ecx D$UserPeLen | shl ecx 4 | add ecx 10_000_000

    Call VirtualAlloc CodeSource,
                      ecx

    Mov eax D$CodeSource,
        D$eax+(0*ASCII) CRLF2,
        D$eax+(4*ASCII) CRLF2

    add D$CodeSource 8

    add ecx D$CodeSource | Mov D$EndOfSourceMemory ecx

  ; restore the true length (without the security tail):
    sub D$UserPeLen 01000

    Mov edi D$CodeSource, eax CRLF2, ecx 100 | rep stosd

    Mov eax D$UserPeStart | add D$UserPEStartOfResources eax  ; Switch done...
ret

@HLL_Strings_Table_notes:

;;
  * Create one another paralel Table: 'SymbolsMap'
  
  * Symbol wanted at 'SomeRoom': Set the 'STRINGS' Flag.
  
  * Store the String, zero-ended, in a StringsTable.
  
  * Store the Pointer to the zero-ended String in a 'StringsPointersTable':
    Record: [... / SomeRoom, StringPointer / ...]
  
  'STRINGS' Flag encouted in 'SymbolsMap'
  >>> Search for the 'SomeRoom' Displacement, in the 'StringsPointersTable'
  >>> take the 'StringPointer'.
  
  Length? Why not using directly the String origine? Example the "Functions.api"
  File. Just a Pointer to the Name (>= SPC ending).
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
 Import Section looks like this:

[DirectoryTable:
 LookUpRVA: D$ 03050 TimeDate: 0 ForwarderChain: 0 NameRVA: 03136 AdressRVA: 030A8
 LookUpRVA: D$ 03060 TimeDate: 0 ForwarderChain: 0 NameRVA: 03164 AdressRVA: 030B8
 ...
 LookUp1: (03050:)
;;

[DisNumberOfFunctions: D$ ?
 ApiBuffer: D$ ?
 EndOfApiBuffer: D$ ?]

CheckImport:
    GetPeHeader AppImportSize | Mov eax D$eax | On eax = 0, ret ;jmp DisFail

  ; !!! 'AppImportSize' is _NOT_ the size of Import, but the one of the Import
  ; Header only !!! We can't use it for defining the 'ApiBuffer' size !!!
  ; Done at the end, based on the number of found Functions.

    GetPeHeader AppBaseOfImport | Mov edx D$eax | On edx = 0, jmp DisFail

    add edx D$UserPeStart
;;
  The Import Directory is a flow of blocks of 5 dWords (+ zero ended with 5 dWords):
  
  Import LookUp Table RVA
  Time and Date Stamp
  Forwarder Chain
  Name RVA                    ; <<<<<  MODULE.dll
  Import Addresses Table RVA  ; <<<<<  Function
  
  Import Addresses Table RVA is flow of dWords Pointer to Functions Names for each DLL.
  (Zero ending dWord).
  
  We first fill all the SectionsMap part of this Tree-like Structure with IMPORTFLAG:

  If either 'Import LookUp Table RVA' or 'Import Addresses Table RVA' are zeroed,
  we fill the one by the other, in order to save from no end Checking:
;;
    Mov eax edx

    While D$eax+(4*3) <> 0          ; At least 'Name RVA' should be there ;)
        If D$eax = 0
            Move D$eax D$eax+(4*4)
        Else_If D$eax+(4*4) = 0
            Move D$eax+(4*4) D$eax
        End_If
        add eax (5*4)
    End_While

    Push edx
        Mov eax IMPORTFLAG+(IMPORTFLAG shl 8)+(IMPORTFLAG shl 16)+(IMPORTFLAG shl 24)

        Mov edi edx | sub edi D$UserPeStart | add edi D$SectionsMap

        ..While D$edx <> 0
          ; Flag the Directory (dWords):
            Mov edi edx, ecx 5
            sub edi D$UserPeStart | add edi D$SectionsMap | rep stosd
          ; Flag the LookUp Table (dWords):
            Mov edi D$edx, ebx edi | add edi D$SectionsMap | add ebx D$UserPeStart
            While D$ebx <> 0
                ;Call FlagImportCalls ebx
                stosd | add ebx 4
            End_While | stosd
          ; Flag the DLL Name (Bytes):
            Mov edi D$edx+(3*4), ebx edi | add edi D$SectionsMap | add ebx D$UserPeStart
            While B$ebx <> 0 | stosb | inc ebx | End_While | stosb
          ; Flag the Address Table (dWords):
            Mov edi D$edx+(4*4), ebx edi | add edi D$SectionsMap | add ebx D$UserPeStart
            While D$ebx <> 0
               ; Call FlagImportCalls ebx
                stosd | add ebx 4
            End_While | stosd
          ; The Import Address Table may be either empty or filled up with any value.
          ; we first recopy the LoockUp Table upon it:
            Push esi, edi
                Mov esi D$edx, edi D$edx+(4*4)
                add esi D$UserPeStart | add edi D$UserPeStart
                While D$esi <> 0 | movsd | End_While
            Pop edi, esi
          ; Flag the Functions String (Bytes, pointed by LookUp // Address Tables):
            Mov ebx D$edx | add ebx D$UserPeStart
            .While D$ebx <> 0
                Push ebx
                    Mov ebx D$ebx, edi ebx, ecx ebx | and ecx 0_8000_0000
                    If ecx = 0_8000_0000 ; By Number

                    Else                 ; By Name
                        add ebx D$UserPeStart | add edi D$SectionsMap
                        stosw | add ebx 2
                        While B$ebx <> 0 | stosb | inc ebx | End_While | stosb
                    End_If
                Pop ebx
                add ebx 4
            .End_While

            add edx (5*4)
        ..End_While
      ; Flag the Directory zero ending (5 dWords, too):
        Mov edi edx, ecx 5
        sub edi D$UserPeStart | add edi D$SectionsMap | rep stosd
    Pop edx
;;
  We fill the relative Flags image with the Pointers to DLL Names (instead of a Flag),
  at each Function Name Address, so that, when the Flag Image will hold a Pointer,
  instead of a Flag, this will be the Pointer to the DLL Name, and the Pointer to the
  Function Name will appear in the relative Pos in UserPeStart:
;;
    Push edx
      ; (edx keeps track of the .import Base)
        .While D$edx <> 0
            Mov eax D$edx+12 | add eax D$UserPeStart    ; Pointer to DLL Name
            On D$eax = 'MSVB', Mov D$CompiledBy 'MSVB'
            Mov ebx D$edx+16 | add ebx D$UserPeStart    ; Pointer to Functions Names List.
            Mov edi D$RoutingMap | add edi D$edx+16
        ; Write the Pointer to DLL Name upon all 'RoutingMap' Pointers to Functions Names:
            While D$ebx <> 0
                stosd | add ebx 4
            End_While

            Mov ebx D$edx+16 | add ebx D$UserPeStart
            Mov edi D$SectionsMap | add edi D$edx+16
            Mov eax IMPORTFLAG
        ; Write again IMPORTFLAG upon all 'SectionsMap' Pointers to Functions Names:
            While D$ebx <> 0
                stosb | inc ebx
            End_While

            add edx 20
        .End_While

    Pop edx
;;
  Once done, when we encount a Pointer, and see 'IMPORTFLAG' in the relative 'SectionsMap'
  dWord / >>> We have the DLL Name Pointer in the relative 'RoutingMap' dWord and the
  the Pointer to the Function Name in the relative 'UserPeStart' dWord.
  
  Now, we make a Copy of 'DllName.FunctionName' into 'ApiBuffer', and replace all
  Address Table and LookUp Table dWords by Pointers to these new Strings:
  
  Search the Number of Functions, first, in order to guess what size for 'ApiBuffer'.
;;
    Push esi, edx

        Mov D$DisNumberOfFunctions 0

      ; Pointer to Functions Names Address Table in edx:
L0:     Mov esi D$edx+(4*4) | add esi D$UserPeStart
        While D$esi <> 0
            add esi 4 | inc D$DisNumberOfFunctions
        End_While

        add edx 20 | cmp D$edx 0 | jne L0<<

    Pop edx, esi

  ; Large estimation: 128 Chars per Function:
    Mov eax D$DisNumberOfFunctions | shl eax 7

    Call VirtualAlloc ApiBuffer,
                      eax

    add eax D$ApiBuffer | Mov D$EndOfApiBuffer eax

  ; Now, fill the ApiBuffer:
    Mov edi D$ApiBuffer

L0: Mov ebx D$edx+(3*4) | add ebx D$UserPeStart    ; Pointer to DLL Name.
    Mov esi D$edx+(4*4) | add esi D$UserPeStart    ; Pointer to Functions Names Address Table.

    While D$esi <> 0
        Mov ecx edi

        Mov B$edi "'" | inc edi
        Push ebx
L1:         Mov al B$ebx | stosb | inc ebx | cmp al 0 | jne L1<   ; 'DllName.
        Pop ebx
        Mov eax D$edi-5 | or eax 020202020
        If eax = '.dll'
            sub edi 4
        Else
            Mov B$edi-1 "."
        End_If

        lodsd | test eax 08000_0000 ZERO L1>
            xor eax 08000_0000 | Push ebx | Call WriteEax | Pop ebx | jmp L2>

L1:     Push ebx
            Mov ebx eax | add ebx D$UserPeStart | add ebx 2
L1:         Mov al B$ebx | stosb | inc ebx | cmp al 0 | jne L1<   ; ....FunctionName'
            dec edi
        Pop ebx

L2:     Mov B$edi "'" | inc edi | Mov B$edi 0 | inc edi

      ; Overwrite Address Table and LookUp Table dWords by Pointers to 'ApiBuffer':
        Mov D$esi-4 ecx
        Mov eax esi | sub eax D$edx+(4*4) | add eax D$edx | Mov D$eax-4 ecx
    End_While

    add edx 20 | cmp D$edx 0 | jne L0<<

  ; ... and clear the temporary used 'RoutingMap'
    Mov edi D$RoutingMap, ecx D$EndOfRoutingMap, eax 0
    sub ecx edi | shr ecx 2 | rep stosd

    Call KillBlankBytes AppImportSize, IMPORTFLAG
ret

____________________________________________________________________________________________

[DisResourcesOrigine: D$ ?]

; Resources have be loaded by LoadDisResources. We now simply Flag the Resources Section.
; (Only the real Resources -not the whole Section that main contain anything Else-).

CheckResources:
    GetPeHeader AppBaseOfRsrc | On D$eax = 0, ret

    Mov eax D$eax | add eax D$UserPeStart | Mov D$DisResourcesOrigine eax

    Call FlagResourceTree eax

    Call KillBlankBytes AppBaseOfRsrc, RESOURCESFLAG
ret

;;
  'FlagResourceTree' is a good example of Procedure calling itself, for moving along
  all branches of a tree.
;;


____________________________________________________________________________________________
____________________________________________________________________________________________

; Guga proposition:

;;

Resource structures

[IMAGE_RESOURCE_DIRECTORY:
 Characteristics: D$ 0
 TimeDateStamp: D$ 0
 MajorVersion: W$ 0
 MinorVersion: W$ 0
 NumberOfNamedEntries: W$ 0
 NumberOfIdEntries: W$ 0]

[ImgResDir.CharacteristicsDis 0
 ImgResDir.TimeDateStampDis 4
 ImgResDir.MajorVersionDis 8
 ImgResDir.MinorVersionDis 10
 ImgResDir.NumberOfNamedEntriesDis 12
 ImgResDir.NumberOfIdEntriesDis 14]

[Size_Of_IMAGE_RESOURCE_DIRECTORY 16]

; followed by an array of XX IMAGE_RESOURCE_DIRECTORY_ENTRY. The total amount of elements
 on theg array are the sum of NumberOfNamedEntries + NumberOfIdEntries.

[IMAGE_RESOURCE_DIRECTORY_ENTRY:
 Name1: Id: D$ 0
 OffsetToData: D$ 0]
 
 Name1 = This field contains either an integer ID or a pointer to a structure that contains a string name.
         If the high bit (0x80000000) is zero, this field is interpreted as an integer ID.
         Th ID is the type of the resource, such as a dialog, an icon, an bitmap image etc. It can be one of the
         following equates (This member does not allow combination of the equates):
         &RT_CURSOR, &RT_BITMAP, &RT_ICON, &RT_MENU, &RT_DIALOG, &RT_STRING, &RT_FONTDIR, &RT_FONT, &RT_ACCELERATOR,
         &RT_RCDATA, &RT_GROUP_CURSOR, &RT_GROUP_ICON, &RT_MESSAGETABLE, &RT_VERSION, &RT_DLGINCLUDE, &RT_PLUGPLAY,
         &RT_VXD, &RT_ANICURSOR

            Ex.: 05 = the ID of the data resource. It is a dialog (&RT_DIALOG)
 
         If the high bit is nonzero, the lower 31 bits are an offset (relative to the start of the resources)
            to an IMAGE_RESOURCE_DIR_STRING_U structure.
            Ex.: 080000688 = 080000000+DataOffset-IMAGE_RESOURCE_DIRECTORY_ENTRY (The main one, that is the 1st found in the section)
                So, on the example we are at byte 0688 from the start of the resources section.
                At byte 0688 we will have a IMAGE_RESOURCE_DIR_STRING_U structure
            This structure contains a WORD character count, followed by a UNICODE string with the resource name.
            Yes, even PE files intended for non-UNICODE Win32 implementations use UNICODE here.
            To convert the UNICODE string to an ANSI string, use the WideCharToMultiByte function.
                [IMAGE_RESOURCE_DIR_STRING_U:
                    Length1: W$ 0   The length of the string
                    NameString: W$ 0] The unicode string. This string is non null terminated, but an additional word
                                      may be inserted after the string to make next field start on a dword boundary.

OffsetToData = This field is either an offset to another resource directory or a pointer to information about
               a specific resource instance.
               
               If the high bit (0x80000000) is set, this directory entry refers to a subdirectory.
                The lower 31 bits are an offset (relative to the start of the resources) to another IMAGE_RESOURCE_DIRECTORY.
                Ex.: 080000468 = 080000000+DataOffset-IMAGE_RESOURCE_DIRECTORY_ENTRY (The main one, that is the 1st found in the section)
                So, on the example we are at byte 0468 from the start of the resources section.
                At byte 0468 we will have another IMAGE_RESOURCE_DIRECTORY structure
               
               If the high bit isn't set, the lower 31 bits point to an IMAGE_RESOURCE_DATA_ENTRY structure.
               This is called as "leaf node".
                Ex.: 0EA0 = DataOffset-IMAGE_RESOURCE_DIRECTORY_ENTRY (The main one, that is the 1st found in the section)
                     At byte 0EA0 we will have an IMAGE_RESOURCE_DATA_ENTRY structure
                The IMAGE_RESOURCE_DATA_ENTRY structure contains the location of the resource's raw data, its size, and its code page.
                    [IMAGE_RESOURCE_DATA_ENTRY:
                        OffsetToData: D$ 0
                        Size1: D$ 0
                        CodePage: D$ 0
                        Reserved: D$ 0]

                OffsetToData = location of the actual resource data. Since this information is used primarily
                               by functions once the application has been loaded,
                               it makes more sense to make the OffsetToData field a relative virtual address.

                                This is precisely the case.
               
                                Interestingly enough, all other offsets, such as pointers from directory entries
                                to other directories, are offsets relative to the location of the root node.
                                Ex.: 0E1608 = DataOffset-ImageBase (The start of thge PE file)
               
                Size1 = size of the actual resource data.
               
                CodePage = Code page is the traditional IBM term used for a specific character encoding table:
                           a mapping in which a sequence of bits, usually a single octet representing integer values
                           0 through 255, is associated with a specific character. IBM and Microsoft often allocate a
                           code page number to a character set even if that charset is better known by another name.

                           Whilst the term code page originated from IBM's EBCDIC-based mainframe systems, the term is
                           most commonly associated with the IBM PC code pages. Microsoft, a maker of PC operating systems,
                           refers to these code pages as OEM code pages, and supplements them with its own "ANSI" code pages.

                           Most well-known code pages, excluding those for the CJK languages and Vietnamese, represent character
                           sets that fit in 8 bits and don't involve anything that can't be represented by mapping each code to a
                           simple bitmap, such as combining characters, complex scripts, etc.

                           The text mode of standard (VGA compatible) PC graphics hardware is built around using an 8 bit
                           code page, though it is possible to use two at once with some color depth sacrifice, and up to
                           8 may be stored in the display adaptor for easy switching).
                           
                           There were a selection of code pages that could be loaded into such hardware.
                           
                           However, it is now commonplace for operating system vendors to provide their own character encoding
                           and rendering systems that run in a graphics mode and bypass this system entirely.
                           
                           The character encodings used by these graphical systems (particularly Windows) are sometimes
                           called code pages as well.
                           
                            - Relationship to ASCII. -
                           The basis of the IBM PC code pages is ASCII, a 7-bit code representing 128 characters and control
                           codes. In the past, 8-bit extensions to the ASCII code often either set the top bit to zero,
                           or used it as a parity bit in network data transmissions.
                           When this bit was instead made available for representing character data, another 128 characters
                           and control codes could be represented. IBM used this extended range to encode characters used
                           by various languages.
                           No formal standard existed for these 'extended character sets'; IBM merely referred to the variants
                           as code pages, as it had always done for variants of EBCDIC encodings.
               
                            - IBM PC (OEM) code pages -

                            These code pages are most often used under MS-DOS-like operating systems;
                            they include a lot of box drawing characters. Since the original IBM PC code page (number 437)
                            was not really designed for international use, several incompatible variants emerged.
                            Microsoft refers to these as the OEM code pages. Examples include:

                                * 437  The original IBM PC code page
                                * 737  Greek
                                * 850  "Multilingual (Latin-1)" (Western European languages)
                                * 852  "Slavic (Latin-2)" (Eastern European languages)
                                * 855  Cyrillic
                                * 857  Turkish
                                * 858  "Multilingual" with euro symbol
                                * 860  Portuguese
                                * 861  Icelandic
                                * 863  French Canadian
                                * 865  Nordic
                                * 866  Cyrillic
                                * 869  Greek

                            - Other code pages of note -

                                * 10000  Macintosh Roman encoding (followed by several other Mac character sets)
                                * 10007  Macintosh Cyrillic encoding
                                * 10029  Macintosh Central European encoding
                                * 932  Supports Japanese
                                * 936  GBK Supports Simplified Chinese
                                * 949  Supports Korean
                                * 950  Supports Traditional Chinese
                                * 1200  UCS-2LE Unicode little-endian
                                * 1201  UCS-2BE Unicode big-endian
                                * 65001  UTF-8 Unicode
                                * ASMO449+  Supports Arabic

                            In modern applications, operating systems and programming languages, the IBM code pages
                            have been rendered obsolete by newer & better international standards, such as ISO 8859-1
                            and Unicode.

                            - Windows (ANSI) code pages -

                            Microsoft defined a number of code pages known as the ANSI code pages (as the first one, 1252
                            was based on an ansi draft of what became ISO 8859-1). Code page 1252 is built on ISO 8859-1
                            but uses the range 0x80-0x9F for extra printable characters rather than the C1 control codes
                            used in ISO-8859-1.
                            Some of the others are based in part on other parts of ISO 8859 but often rearranged to make
                            them closer to 1252.

                                * 1250  East European Latin
                                * 1251  Cyrillic
                                * 1252  West European Latin
                                * 1253  Greek
                                * 1254  Turkish
                                * 1255  Hebrew
                                * 1256  Arabic
                                * 1257  Baltic
                                * 1258  Vietnamese

                Reserved = Reserved data. Do not use.
;;

;;
  'FlagResourceTree' is a good example of Procedure calling itself, for moving along
  all branches of a tree.
;;

; IMAGE_RESOURCE_DIRECTORY structure

[ImgResDir.CharacteristicsDis 0
 ImgResDir.TimeDateStampDis 4
 ImgResDir.MajorVersionDis 8
 ImgResDir.MinorVersionDis 10
 ImgResDir.NumberOfNamedEntriesDis 12
 ImgResDir.NumberOfIdEntriesDis 14]

[Size_Of_IMAGE_RESOURCE_DIRECTORY 16]

; IMAGE_RESOURCE_DIRECTORY_ENTRY structure

[ImgResDirEntry.Name1Dis 0
 ImgResDirEntry.OffsetToDataDis 4]

[Size_Of_IMAGE_RESOURCE_DIRECTORY_ENTRY 8]

; IMAGE_RESOURCE_DIR_STRING_U structure

[ImgResDirStringU.Length1Dis 0]
; ImgResDirStringU.NameString the size of the unicode string depends of the value of Length1

; IMAGE_RESOURCE_DATA_ENTRY structure

[ImgResDataEntry.OffsetToDataDis 0
 ImgResDataEntry.Size1Dis 4
 ImgResDataEntry.CodePageDis 8
 ImgResDataEntry.ReservedDis 12]

[Size_Of_IMAGE_RESOURCE_DATA_ENTRY 16]

Proc FlagResourceTree: ; 'ResourcesStub' For infos.
    Argument @Pointer
    Local @Array
    Uses esi, ebx, eax

    Mov esi D@Pointer, eax 0

    Push esi
      ; add ImgResDir.NumberOfNamedEntries to ImgResDir.NumberOfIdEntries
      ; and copy the result to N:
        add esi ImgResDir.NumberOfNamedEntriesDis
        lodsw | Mov D@Array eax
        lodsw | add D@Array eax
    Pop esi

    ; now we flag all IMAGE_RESOURCE_DIRECTORY
    Mov ebx esi | sub ebx D$UserPeStart | add ebx D$SectionsMap
    Mov eax RESOURCESFLAG+(RESOURCESFLAG shl 8)+(RESOURCESFLAG shl 16)+(RESOURCESFLAG shl 24)
    Mov D$ebx+ImgResDir.CharacteristicsDis eax, D$ebx+ImgResDir.TimeDateStampDis eax,
    W$ebx+ImgResDir.MajorVersionDis ax, W$ebx+ImgResDir.MinorVersionDis ax,
    W$ebx+ImgResDir.NumberOfNamedEntriesDis ax, W$ebx+ImgResDir.NumberOfIdEntriesDis ax

    ; esi and ebx now points to the IMAGE_RESOURCE_DIRECTORY_ENTRY.
    add esi Size_Of_IMAGE_RESOURCE_DIRECTORY
    add ebx Size_Of_IMAGE_RESOURCE_DIRECTORY

          ; We need to see if we have a Unicode String Name or a ID
L0:         lodsd ; load the name ID to eax
            ; flag the Name1Dis member
            Mov D$ebx+ImgResDirEntry.Name1Dis RESOURCESFLAG+(RESOURCESFLAG shl 8)+(RESOURCESFLAG shl 16)+(RESOURCESFLAG shl 24)
            ;add ebx ImgResDirEntry.OffsetToDataDis ; update ebx to it points to the offsettodata in the sectionmap

            Test_If eax 08000_0000 ; If it is a named ID, flag all the IMAGE_RESOURCE_DIR_STRING_U structure
                xor eax 08000_0000
                add eax D$DisResourcesOrigine ; eax is now at IMAGE_RESOURCE_DIR_STRING_U
                movzx ecx W$eax ; ecx now contains the lenght of our unicode string
                sub eax D$userpestart ; let´s point it to the proper location
                add eax D$SectionsMap ; in the section map
                ; flag the lenght member
                Mov W$eax+ImgResDirStringU.Length1Dis RESOURCESFLAG+(RESOURCESFLAG shl 8)
                add eax 2 ; points to the begginning of the unicode string
                ; flag the unicode string
                Mov edi eax
                Mov ax RESOURCESFLAG+(RESOURCESFLAG shl 8) | rep stosw
            Test_End

            ; Now, load the OffsetToData and save it´s value at eax
            lodsd
            ; flag the OffsetToDataDis member
            Mov D$ebx+ImgResDirEntry.OffsetToDataDis RESOURCESFLAG+(RESOURCESFLAG shl 8)+(RESOURCESFLAG shl 16)+(RESOURCESFLAG shl 24)
            add ebx Size_Of_IMAGE_RESOURCE_DIRECTORY_ENTRY ; update ebx

            .Test_If eax 08000_0000 ; If the high bit (0x80000000) is set this is a node
                xor eax 08000_0000 | add eax D$DisResourcesOrigine
                Call FlagResourceTree eax

                If D@Array > 1
                  ; let´s flag the rest of the array IMAGE_RESOURCE_DIRECTORY_ENTRY.
                    dec D@Array | jmp L0<<
                End_If

            .Test_Else ; If the high bit (0x80000000) is not set this is a leaf
                ; Flag all the IMAGE_RESOURCE_DATA_ENTRY and their internal pointers
                add eax D$DisResourcesOrigine
                Mov ebx eax
                sub ebx D$UserPeStart
                add ebx D$SectionsMap

                Mov D$ebx+ImgResDataEntry.OffsetToDataDis RESOURCESFLAG+(RESOURCESFLAG shl 8)+(RESOURCESFLAG shl 16)+(RESOURCESFLAG shl 24)
                Mov D$ebx+ImgResDataEntry.Size1Dis RESOURCESFLAG+(RESOURCESFLAG shl 8)+(RESOURCESFLAG shl 16)+(RESOURCESFLAG shl 24)
                Mov D$ebx+ImgResDataEntry.CodePageDis RESOURCESFLAG+(RESOURCESFLAG shl 8)+(RESOURCESFLAG shl 16)+(RESOURCESFLAG shl 24)
                Mov D$ebx+ImgResDataEntry.ReservedDis RESOURCESFLAG+(RESOURCESFLAG shl 8)+(RESOURCESFLAG shl 16)+(RESOURCESFLAG shl 24)

                ; flag the data contents
                Mov edi D$eax+ImgResDataEntry.OffsetToDataDis
                Mov ecx D$eax+ImgResDataEntry.Size1Dis
                add edi D$SectionsMap; edi points to the offset of the data in the sectinosmap
                Mov al RESOURCESFLAG | rep stosb

            .Test_End
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
 If no Virtual Data Section is found, the Application is allowed (RosAsm works like
 this, and many other Compilers), to consider as Virtual (uninitialized) Data the
 room left between the End of Data and the Virtual End of .Data section. In
 'SectionsHeaders', this is the difference between the first dWord (after the name)
 and the third dWord.

 Here, if we find no Virtual Data Section, we simply exit and let in the Values
 defined in upper 'ReadDataSection'.
;;

[VirtualIsRunable: D$ ?]

CheckVirtualData:
    GetPeHeader SectionsHeaders | Mov ecx D$DisNumberOfSections

L0: test D$eax+SECTION_FLAG &IMAGE_SCN_CNT_UNINITIALIZED_DATA ZERO L3>
        test D$eax+SECTION_FLAG &IMAGE_SCN_MEM_READ ZERO L3>
            test D$eax+SECTION_FLAG &IMAGE_SCN_MEM_WRITE ZERO L3>

                test D$eax &IMAGE_SCN_MEM_EXECUTE ZERO L2>
                    Mov B$VirtualIsRunable &TRUE            ; See this pb later.

  ; Regular Virtual Data Section found. Check the Bytes in 'SectionMap':
L2: Mov ebx D$eax+SECTION_RVA | add ebx D$SectionsMap
    Mov edi D$SectionsMap | add edi D$eax+SECTION_RVA
    Mov edx edi | add edx D$eax+SECTION_FILESIZE
    Push edi
        While edi < edx | Mov B$edi VIRTUALFLAG | inc edi | End_While
    Pop edi
  ; Force the First Virtual Byte EVOCATED:
    sub edi D$SectionsMap | add edi D$RoutingMap | Mov B$edi EVOCATED

L3: add eax SECTIONHEADERSIZE | loop L0<
ret


CheckExtendedVirtual:
    GetPeHeader SectionsHeaders | Mov ecx D$DisNumberOfSections
    Push ecx ;jE! fixing incorrect loop; bcoz if header is dirty, then will bad..
L0: Mov ecx D$eax+SECTION_RVASIZE, ebx D$eax+SECTION_FILESIZE
    Align_On_Variable D$DisRvaSectionAlignment ecx
    Align_On_Variable D$DisFileSectionAlignment ebx
    .If ecx > ebx
        test D$eax+SECTION_FLAG &IMAGE_SCN_MEM_EXECUTE ZERO L2>
            Mov B$VirtualIsRunable &TRUE            ; See this pb later.

L2:     Mov edi D$SectionsMap | add edi D$eax+SECTION_RVA | add edi D$eax+SECTION_FILESIZE
      ; Don't touch Reloc and DebugInfo:
        If B$edi <> KILLFLAG
          ; Force the First Virtual Byte EVOCATED:
            Mov edx edi | sub edx D$SectionsMap | add edx D$RoutingMap | Mov B$edx EVOCATED

            Push eax
                Mov ecx D$eax+SECTION_RVASIZE
                Align_On_Variable D$DisRvaSectionAlignment ecx
                sub ecx ebx | Mov al VIRTUALFLAG | rep stosb
            Pop eax
        End_If
    .End_If

L3: dec D$esp | jle L4> ;jE!
    add eax SECTIONHEADERSIZE | cmp D$eax+SECTION_RVA 0 | ja L0<<
    jmp L3< ;jE! VirtualSize can be 0!
L4: add esp 4 ;jE!
ret
____________________________________________________________________________________________

[NumberOfDisExportedFunctions: D$ ?
 DisExportFunctionsPointers: D$ ?
 DisExportNamesPointers: D$ ?
 DisExportInside: D$ ?
 DisExportOrdinal: D$ ?]

; 'ExportSectionComments'.

[NumberOfForwardedExport: D$ ?]

[ForwardedMessage: B$ '     '
 Forwarded: B$ "Forwarded Exports found in this Module. 
   
 RosAsm Assembler does not assume this method.    
 The rebuilt Module will therefore not work
 like the original (missing Functions)." EOS]

CheckExport:
    GetPeHeader SectionTable | On D$eax = 0, ret

    Mov D$NumberOfForwardedExport 0

    Push eax
        Mov edi D$eax, ecx D$eax+4, al EXPORTFLAG
        add edi D$SectionsMap | rep stosb
    Pop eax

    Mov edx D$eax | add edx D$UserPeStart
    Mov eax D$edx+(5*4), ebx D$edx+(6*4)
    On ebx > eax, Mov eax ebx
    add edx (6*4)
    Mov D$NumberOfDisExportedFunctions eax
; 0476 = 1142 in wsock32.dll !!!   04B  Forwarded Functions (forwarded to other DLLs) !!!
    On D$NumberOfDisExportedFunctions = 0, jmp L9>>
  ; 'ExportSectionComments'
    add edx 4 | Mov eax D$edx | add eax D$UserPeStart
    Mov D$DisExportFunctionsPointers eax

    add edx 4 | Mov eax D$edx | add eax D$UserPeStart
    Mov D$DisExportNamesPointers eax

    add edx 4 | Mov eax D$edx | add eax D$UserPeStart
    Mov D$DisExportOrdinal eax

  ; Mark the Exported Functions as Nodes in the Code Routing Table:
    Mov esi D$DisExportFunctionsPointers, ecx D$NumberOfDisExportedFunctions

L0: lodsd
    .If eax = 0
        loop L0<
    .Else
        add eax D$SectionsMap
        If B$eax = EXPORTFLAG
            inc D$NumberOfForwardedExport | loop L0<
        Else
            sub  eax D$SectionsMap | add eax D$RoutingMap
            or B$eax NODE+INSTRUCTION+EXPORTNODE+ACCESSED+EVOCATED+PUSH_EBP+LABEL
            sub eax D$RoutingMap | add eax D$SectionsMap | Mov B$eax CODEFLAG | loop L0<
        End_If
    .End_If

    If D$NumberOfForwardedExport <> 0
        Mov eax D$NumberOfForwardedExport, edi ForwardedMessage
        Call WriteEaxDecimal
        While edi < Forwarded | Mov B$edi SPC | inc edi | End_While
        Call 'USER32.MessageBoxA' D$H.MainWindow, ForwardedMessage,
                                  {B$ ' Warning' EOS}, 0
    End_If
ret

; Old flaging method:

  ; Flag the SectionsMap with EXPORTFLAG (only the real Export Table. Not
  ; the whole Section, that may contain anything Else -Import / Data /...-):
L1: GetPeHeader SectionTable | Mov esi D$eax | add esi D$UserPeStart

    Mov al EXPORTFLAG

  ; First, the Header (10 dWords).
    Mov ecx (10*4)
    Mov edi esi | sub edi D$UserPeStart | add edi D$SectionsMap
    rep stosb

  ; 'ExportSectionComments'.
  ;
  ; DllName:
    Mov edi D$esi+(3*4), ebx edi
    ..If edi <> 0
        add edi D$SectionsMap | add ebx D$UserPeStart
        .If edi > D$SectionsMap
            If edi < D$EndOfSectionsMap
                While B$ebx <> 0 | stosb | inc ebx | End_While | stosb
            End_If
        .End_If
    ..End_If

  ; ExportAdressesTable:
    Mov edi D$esi+(7*4)
    ..If edi <> 0
        add edi D$SectionsMap
        .If edi > D$SectionsMap
            If edi < D$EndOfSectionsMap
                Mov ecx D$NumberOfDisExportedFunctions | shl ecx 2 | rep stosb
            End_If
        .End_If
    ..End_If

  ; ExportNamesTable:
    Mov edi D$esi+(8*4)
    ..If edi <> 0
        add edi D$SectionsMap
        .If edi > D$SectionsMap
            If edi < D$EndOfSectionsMap
                Mov ecx D$NumberOfDisExportedFunctions | shl ecx 2 | rep stosb
            End_If
        .End_If
    ..End_If

  ; ExportOrdinals
    Mov edi D$esi+(9*4)
    ..If edi <> 0
        add edi D$SectionsMap
        .If edi > D$SectionsMap
            If edi < D$EndOfSectionsMap
                Mov ecx D$NumberOfDisExportedFunctions | shl ecx 1 | rep stosb
            End_If
        .End_If
    ..End_If

  ; Function1Name, Function2Name, ...
    Mov esi D$esi+(8*4), ecx D$NumberOfDisExportedFunctions | On esi = 0, jmp L1>
    add esi D$UserPeStart
    ...If esi > D$UserPeStart
        ..If esi < D$UserPeEnd
L0:         Mov edi D$esi, ebx edi
            add edi D$SectionsMap | add ebx D$UserPeStart
            .If edi > D$SectionsMap
                If edi < D$EndOfSectionsMap
                    While B$ebx <> 0 | stosb | inc ebx | End_While | stosb
                    add esi 4 | loop L0<
                End_If
            .End_If
        ..End_If
    ...End_If

L1: Mov B$DisExportInside &TRUE

L9: Call KillBlankBytes SectionTable, EXPORTFLAG
ret
____________________________________________________________________________________________

;;
  The 'KILLFLAG' is simply for _not_ analysing these Sections that are no use for
  the Disassembling Process.
;;

KillPeHeader:
    Mov edi D$SectionsMap, ecx D$FirstSection, al KILLFLAG
    rep stosb
ret


Proc KillSection:
    Argument @OptionalHeaderTable

        GetPeHeader D@OptionalHeaderTable | Mov edi D$eax | On edi = 0, ExitP

    ; Example: Is it a clean .reloc with nothing Else inside?
        test edi 0FFF NOT_ZERO L2>

            Mov esi edi | add esi D$UserPeStart
            Mov ecx D$eax+4 | Align_On_Variable D$DisRvaSectionAlignment ecx
            Mov edx esi | add edx ecx | add esi D$eax+4

            While esi < edx
                On B$esi <> 0, jmp L2>
                inc esi
            End_While

            ; Example: Seems to be a clean .reloc. Fill it all:
                add edi D$SectionsMap | Mov al KILLFLAG | rep stosb | ExitP

L2:     Mov ecx D$eax+4 | add edi D$SectionsMap | Mov al KILLFLAG | rep stosb
EndP


Proc KillBlankBytes:
    Arguments @OptionalHeaderTable, @FLAG

        Mov eax D@OptionalHeaderTable, esi D$eax, ecx D$eax+4
        Align_On_Variable D$DisRvaSectionAlignment ecx

        add esi D$UserPeStart | Mov edx esi | add edx ecx
        Mov ebx esi | sub ebx D$UserPeStart | add ebx D$SectionsMap

        While esi < edx
            On ebx >= D$EndOfSectionsMap, ExitP

            If B$ebx = 0
                On B$esi <> 0, ExitP
            End_If
            inc esi | inc ebx
        End_While

      ; OK. Only blank Bytes found, other than, for example, the normal Export Data:
        Mov eax D@OptionalHeaderTable, esi D$eax, ecx D$eax+4
        Align_On_Variable D$DisRvaSectionAlignment ecx

        add esi D$UserPeStart | Mov edx esi | add edx ecx
        Mov ebx esi | sub ebx D$UserPeStart | add ebx D$SectionsMap

        While esi < edx
            On B$ebx = 0, Mov B$ebx KILLFLAG
            inc esi | inc ebx
        End_While
EndP


KillSectionsExtensions:
    GetPeHeader SectionsHeaders | Mov esi eax

    Mov ecx D$DisNumberOfSections

L0: Push ecx
        Mov edi D$esi+SECTION_RVA | add edi D$SectionsMap
        Mov ecx D$esi+SECTION_RVASIZE
        Mov eax D$esi+SECTION_FILESIZE
        On ecx > eax, Mov eax ecx
        Align_On_Variable D$DisFileSectionAlignment eax
        Mov ecx eax
        Align_On_Variable D$DisRvaSectionAlignment ecx
        sub ecx eax | jz L2>

            add edi eax | Mov al KILLFLAG | rep stosb
L2: Pop ecx

    add esi SECTIONHEADERSIZE | loop L0<
ret
____________________________________________________________________________________________

[DisFailText: B$ 'Failure of Disassembly' EOS]
[SilentMap: D$ ?]

DisFail:

    Call DestroyDisProgressBar

    Call VirtualFree UserPeStart

    Call VirtualFree CodeSource

    Call VirtualFree TruthAsciiTable

    Call VirtualFree RoutingMap

    Call VirtualFree SectionsMap

    Call VirtualFree SizesMap

    Call VirtualFree ApiBuffer

    Mov B$Disassembling &FALSE
    If B$SilentMap = &FALSE

        Call MessageBox DisFailText

    End_If
    Mov B$SilentMap &FALSE

L0: Mov ebx, esp | cmp ebx, D$OldStackPointer | jnb L1>
        Pop ebx | jmp L0<

L1: jmp StartNewFile

____________________________________________________________________________________________
____________________________________________________________________________________________

[ProgressWindowStyle: &WS_EX_LEFT+&WS_EX_TOOLWINDOW+&WS_EX_NOPARENTNOTIFY]

;;
   Attempt to having a ProgressBar that would be possible to close.
   
   Should be the routing center of all of the Assembler or Disassembler stuff.
   
   later...
;;

;InitDisProgressBar:
  ; Tag Dialog 25
    Call 'USER32.DialogBoxParamA' D$H.Instance, 25, &NULL, ProgressProc, &NULL
ret

Proc ProgressProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ..If D@msg = &WM_COMMAND
        If D@wParam = &IDCANCEL
            Call 'USER32.EndDialog' D@hwnd, 0
        End_If

    ..If D@msg = &WM_CLOSE
        Call 'USER32.EndDialog' D@hwnd, 0

    ..Else_If D@msg = &WM_INITDIALOG
        Move D$H.ForBar D@hwnd
        Call 'USER32.GetDlgItem' D@hwnd 5 | Mov D$ProgressInst eax

        Call 'USER32.SetClassLongA' D@hwnd, &GCL_HICON, D$STRUC.WINDOWCLASS@hIcon
      ; Set steping and Title:
        Call 'USER32.SendMessageA' D$ProgressInst, &PBM_SETRANGE, 0, (128 shl 16)
        Call 'USER32.SendMessageA' D$ProgressInst, &PBM_SETSTEP, 1, 0  ; 1/100
        Call 'USER32.SendMessageA' D$H.ForBar, &WM_SETTEXT, 0, DisPasses

    ..Else
        popad | Mov eax &FALSE | ExitP

    ..End_If

    popad | Mov eax &TRUE
EndP
____________________________________________________________________________________________

InitDisProgressBar:
  ; Center the bar:
    Call 'USER32.GetSystemMetrics' &SM_CXSCREEN
      sub eax D$PBarWindowW | shr eax 1 | Mov D$PBarWindowX eax
    Call 'USER32.GetSystemMetrics' &SM_CYSCREEN
      sub eax D$PBarWindowH | shr eax 1 | Mov D$PBarWindowY eax

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT+&WS_EX_NOPARENTNOTIFY+&WS_EX_TOOLWINDOW,
                                  STR.A.BUAWindowClass,
                                  &NULL,
                                  &WS_VISIBLE+&WS_OVERLAPPEDWINDOW,
                                  D$PBarWindowX,
                                  D$PBarWindowY,
                                  D$PBarWindowW,
                                  D$PBarWindowH,
                                  D$H.MainWindow,
                                  &NULL,
                                  D$H.Instance,
                                  0

    Mov D$H.ForBar eax

  ;  Call 'USER32.ShowWindow' D$H.ForBar, &SW_SHOWNORMAL
  ;  Call 'USER32.UpdateWindow' D$H.ForBar
_____________________________

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  ProgressClassName,
                                  &NULL,
                                  &WS_VISIBLE+050000000, ; TODO Equate !
                                  D$PWindowX,
                                  D$PWindowY,
                                  D$PWindowW,
                                  D$PWindowH,
                                  D$H.ForBar,
                                  1,
                                  D$H.Instance,
                                  0
    Mov D$ProgressInst eax

  ; Set steping and Title:
    Call 'USER32.SendMessageA' D$ProgressInst, &PBM_SETRANGE, 0, (128 shl 16)
    Call 'USER32.SendMessageA' D$ProgressInst, &PBM_SETSTEP, 1, 0  ; 1/100
    Call 'USER32.SendMessageA' D$H.ForBar, &WM_SETTEXT, 0, DisPasses
ret

;InitDisProgressBar:
  ; Center the bar:
    Call 'USER32.GetSystemMetrics' &SM_CXSCREEN
      sub eax D$PBarWindowW | shr eax 1 | Mov D$PBarWindowX eax
    Call 'USER32.GetSystemMetrics' &SM_CYSCREEN
      sub eax D$PBarWindowH | shr eax 1 | Mov D$PBarWindowY eax

  ; WindowExStyle > 084:    80 > tool  4 > no parent notify
    Call 'USER32.CreateWindowExA' D$ProgressWindowStyle,
                                  STR.A.BUAWindowClass,
                                  &NULL,
                                  &WS_VISIBLE+&WS_OVERLAPPEDWINDOW,
                                  D$PBarWindowX,
                                  D$PBarWindowY,
                                  D$PBarWindowW,
                                  D$PBarWindowH,
                                  D$H.MainWindow,
                                  &NULL,
                                  D$H.Instance,
                                  0

    Mov D$H.ForBar eax

;    Call 'USER32.ShowWindow' D$H.ForBar, &SW_SHOWNORMAL
;    Call 'USER32.UpdateWindow' D$H.ForBar

    Call 'USER32.SetWindowLongA' D$H.ForBar, &GWL_WNDPROC, ProgressProc
    Mov D$PreviousProgressProc eax
_____________________________

    Call 'USER32.CreateWindowExA' &WS_EX_LEFT,
                                  ProgressClassName,
                                  &NULL,
                                  050000000, ; TODO Equate !
                                  D$PWindowX,
                                  D$PWindowY,
                                  D$PWindowW,
                                  D$PWindowH,
                                  D$H.ForBar,
                                  1,
                                  D$H.Instance,
                                  0

    Mov D$ProgressInst eax

  ; Set steping and Title:
    Call 'USER32.SendMessageA' D$ProgressInst, &PBM_SETRANGE, 0, (128 shl 16)
    Call 'USER32.SendMessageA' D$ProgressInst, &PBM_SETSTEP, 1, 0  ; 1/100
    Call 'USER32.SendMessageA' D$H.ForBar, &WM_SETTEXT, 0, DisPasses
ret


[PreviousProgressProc: D$ ?
 ProgressRet: D$ ?
 ProgressAdressee: D$ ?
 ProgressMessage: D$ ?
 ProgressWparam: D$ ?
 ProgressLparam: D$ ?]

;ProgressProc:
    Pop D$ProgressRet
    Pop D$ProgressAdressee, D$ProgressMessage, D$ProgressWparam, D$ProgressLparam
    Push D$ProgressRet

    .If D$ProgressMessage = &WM_COMMAND
        If D$mEditWparam = &IDCANCEL
           ; Mov eax &FALSE | ret
        End_If
    .End_If

L9: Call 'USER32.CallWindowProcA' D$PreviousProgressProc D$ProgressAdressee,
                                  D$ProgressMessage, D$ProgressWparam, D$ProgressLparam
    ret

____________________________________________________________________________________________
____________________________________________________________________________________________

[SubEdi6 | On B$WithCommentedHexa = &FALSE, Call SubEdi6IfNoComment]

;;
 Try a minimal organisation of Jcc Instructions writing, under the form of:

 > cmp eax 2 | je K2<

 In case "Cmp eax 2" is followed by comments (either "Code0407050" or Commented
 Hexa Code), we abort the attempt:
;;

SubEdi6IfNoComment:
    Push ebx
        Mov ebx edi | sub ebx 7
        While B$ebx >= SPC
            dec ebx | On B$ebx = ';', jmp L9>
        End_While
        sub edi 6
L9: Pop ebx
ret
____________________________________________________________________________________________

; The main Passes Analyzes of Disassembly.
____________________________________________________________________________________________

[DisEndOfChunk: D$ ?]
[DisCodeDisplacement: D$ ?
 DisBarStep: D$ ?
 NextDisBarPos: D$ ?
 NewAccessedLocations: D$ ?]

[TestLastLocation: D$ ?
  TestLastLineLocation: D$ ?]

DisassembleForCodeRouting:
    Mov edi D$CodeSource, esi D$UserPeStart
    add esi D$FirstSection
    Mov D$NewAccessedLocations &FALSE, D$LastCodeRef 0

    NextDisLine

L0: Mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
    Mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
    Mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE
    Mov B$CALLInstruction &FALSE, B$LeaInstruction &FALSE

  ; Parse onlyCODEFLAGed (in SectionsMap) and ACCESSED (in RoutingMap) Locations:
L1: Mov eax esi | sub eax D$UserPestart | add eax D$SectionsMap
    Test B$eax CODEFLAG NOT_ZERO L2>
        inc esi | On esi = D$UserPeEnd, jmp L9>>
            jmp L1<

L2: sub eax D$SectionsMap | add eax D$RoutingMap
    test B$eax ACCESSED NOT_ZERO L3>
        inc esi | On esi = D$UserPeEnd, jmp L9>>
            jmp L1<

      ; Call for the Disassembly Routines:
L3:     or B$eax INSTRUCTION
L3:     movzx eax B$esi

        Mov D$TestLastLineLocation esi, D$TestLastLocation esi

        inc esi | Call D$DisOp1+eax*4

      ; Loop immidiately in case of simple Prefix:
        While B$DisFlag = DISDONE
            Mov D$TestLastLocation esi
            movzx eax B$esi | inc esi | Call D$DisOp1+eax*4
        End_While

        Mov eax D$TestLastLineLocation | sub eax D$UserPeStart | add eax D$DisImageBase

      ; Clear any LABEL from inside the valid parsed Code:
        Mov eax D$TestLastLineLocation, edx esi | inc eax
        sub eax D$UserPeStart | add eax D$RoutingMap
        sub edx D$UserPeStart | add edx D$RoutingMap
L3:     and B$eax (not LABEL)
        On B$LastDisassemblyRoutingPass = &TRUE,
            and B$eax (not LABEL+INSTRUCTION+EVOCATED+NODE)
        inc eax | cmp eax edx | jb L3<

      ; If a Call or a JMP was Disassembed, the decoding Routines return this Flag set on.
      ; We mark the RoutingMap's according Byte as a new Entry Point:
        .If B$CALLInstruction = &TRUE
            Mov B$CALLInstruction &FALSE

            If B$EscapePrefix <> &TRUE
                Mov eax D$TestLastLocation
                On B$eax = 0E8, Call IsItNoReturnCall  ; OpE8
            End_If

            Mov eax D$LastCodeRef
            sub eax D$DisImageBase | add eax D$SectionsMap
            On eax < D$SectionsMap, jmp L4>>
            On eax >= D$EndOfSectionsMap, jmp L4>>
            test B$eax VIRTUALFLAG+IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+DATAFLAG NOT_ZERO L4>>
            ;test B$eax VIRTUALFLAG+IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG | jnz L4>>
                Mov B$eax CODEFLAG
                sub eax D$SectionsMap | add eax D$RoutingMap
                test B$eax ACCESSED NOT_ZERO L3>
                    Mov B$NewAccessedLocations &TRUE
L3:             or B$eax NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
        .End_If

      ; CHUNKEND Flag marks the first Byte *after* a RET or a JMP:
L4:     Mov eax esi | sub eax D$UserPeStart | add eax D$RoutingMap
        If B$DisEndOfChunk = &TRUE
            or B$eax CHUNKEND | dec eax | Mov B$DisEndOfChunk &FALSE
        End_If

      ; Now Flaged *backward* 'ACCESSED' the Bytes of the new disassembled Instruction,
      ; including the very first Byte of the new coming Instruction, if this one is
      ; not a CHUNKEND (we have 'dec eax' up there in such cases):
L4:     test B$eax ACCESSED NOT_ZERO L4>
            Mov D$NewAccessedLocations &TRUE

L4:     Mov ecx D$TestLastLineLocation | sub ecx D$UserPeStart | add ecx D$RoutingMap

L4:     or B$eax ACCESSED
        Mov ebx eax | sub ebx D$RoutingMap | add ebx D$SectionsMap
        test B$ebx VIRTUALFLAG+IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+DATAFLAG NOT_ZERO L5>
       ; test B$eax VIRTUALFLAG+IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG | jnz L5>
        Mov B$ebx CODEFLAG
L5:     dec eax

        On eax >= ecx, jmp L4<

L6:   ; Adjust the ProgressBar is wanted:
        If esi > D$NextDisBarPos
            Mov eax esi | add eax D$DisBarStep | Mov D$NextDisBarPos eax
            Call BarProgress
        End_If

    On esi < D$UserPeEnd, jmp L0<<

  ; Loop it all until no more new accessed Code Chunks are found:
L9: Mov D$NextDisBarPos 0
   ; map
    cmp B$NewAccessedLocations &TRUE | je DisassembleForCodeRouting
L9:ret

____________________________________________________________________________________________

IsItNoReturnCall:
  ; Escape, if the pointed Byte is already flaged valid Code, by some Code Reference:
    Mov eax esi | sub eax D$UserPeStart | add eax D$RoutingMap
    test B$eax LABEL ZERO L1>
        sub eax D$RoutingMap | add eax D$SectionsMap
        On B$eax = CODEFLAG, ret
;sub eax D$SectionsMap | add eax D$DisImageBase | On eax = 040188B, Mov B$TestNow 1
L1: Push esi, edi
        Push D$DisEndOfChunk, D$LastCodeRef
            lea eax D$esi+50
            Mov B$StopAtCall &TRUE
                Call IsItCode esi, eax, 0
            Mov B$StopAtCall &FALSE
        Pop D$LastCodeRef, D$DisEndOfChunk
    Pop edi, esi

;If B$TestNow = 1
;    Mov eax D$LastUnAccessed | sub eax D$UserPeStart | add eax D$DisImageBase
;    hexprint eax
;End_If

    If eax = &FALSE
        Mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap | Mov B$eax DATAFLAG
        sub eax D$SectionsMap | add eax D$RoutingMap | or B$eax EVOCATED
        Mov D$DisEndOfChunk &TRUE | ;Mov B$esi-5 0E9
        Mov eax &FALSE

    Else
        Mov D$DisEndOfChunk &FALSE

    End_If
ret
____________________________________________________________________________________________

[FollowedByCode: D$ ?
 No0CC: D$ ?]

CodeFromPointers:
    Call InitDisTablesCopies

    Mov B$AttemptSuccess &FALSE, B$No0CC &TRUE, B$StopAtEndOfChunk &TRUE

    Mov esi D$SizesMap | add esi D$FirstSection
    sub edx 4

    .While esi < D$EndOfSizesMap
        test B$esi POINTER ZERO L8>>
          ; Get the Pointer:
            Mov ebx esi | sub ebx D$SizesMap | add ebx D$UserPeStart
            Mov eax D$ebx |; On eax = 047E3D4, int3
            sub eax D$DisImageBase | add eax D$UserPeStart

            ...If eax < D$UserPeStart
                xor B$esi POINTER

            ...Else_If eax > D$UserPeEnd
                xor B$esi POINTER

            ...Else
              ; If the Bytes flow begins with zero, this is probably not Code:
                On B$eax = 0, jmp L8>>

              ; Kill POINTERs to the special Sections:
                sub eax D$UserPeStart | add eax D$SectionsMap
                Test_If B$eax IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG
                    xor B$esi POINTER
                    jmp L8>>
                Test_End

              ; The Section must not be flaged, yet:
                ..If B$eax = 0
                  ; Compute the size of the zeored Chunk:
                    Mov ecx 0 | While B$eax+ecx = 0 | inc ecx | End_While
                    If B$eax+ecx = CODEFLAG
                        Mov B$FollowedByCode &TRUE
                    Else
                        Mov B$FollowedByCode &FALSE
                    End_If
                    Push esi, ebx
                        lea ebx D$eax+ecx
                        sub eax D$SectionsMap | add eax D$UserPeStart
                        sub ebx D$SectionsMap | add ebx D$UserPeStart
                        Call IsItCode eax, ebx, 1
                    Pop ebx, esi

                    .If eax = &TRUE
                        If B$FollowedByCode = &FALSE
                            On B$DisEndOfChunkEncounted = &FALSE, jmp L7>>
                        End_If

                      ; Possible Code Candidate found. Give it a try:
L4:                     Push esi, ebx
                            Mov esi D$ebx ;| On eax = 047E3D4, int3
                            sub esi D$DisImageBase | add esi D$SectionsMap
                            If B$esi <> 0
                                Pop edx, ebx, esi | jmp L8>>
                            End_If
                          ; Save copies the Tables states for cases of failure:
                            Call SetDisTablesCopies

                            Mov B$esi CODEFLAG
                            sub esi D$SectionsMap | add esi D$RoutingMap
                            or B$esi NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL

                            sub esi D$RoutingMap | add esi D$SectionsMap
                            Call DisassemblingAttempt
                        Pop ebx, esi

                      ; Restore the previous Tables versions on failure cases:
                        If B$DisFailure = &TRUE
                      ; Arase the effect of the previous 'SetDisTablesCopies':
                            sub esi D$SizesMap | add esi D$RoutingMap
                            Call ExchangeDisTables
                            sub esi D$RoutingMap | add esi D$SizesMap

                            jmp L7>

                        Else
                            Mov B$AttemptSuccess &TRUE

                        End_If

                    .Else
                       ; Kills the rebuilt of 3DFUN.exe:

L7:                    ; Mov eax D$ebx | sub eax D$DisImageBase | add eax D$SectionsMap
                       ; Mov B$eax DATAFLAG

                    .End_If
                ..End_If
            ...End_If
L8:     inc esi
    .End_While

    Call ReleaseDisTablesCopies
    Mov B$No0CC &FALSE, B$StopAtEndOfChunk &FALSE
ret
____________________________________________________________________________________________

[BiggerZeroedSectionsChunk: D$ ?]

GetBiggerSectionsBlank:
    Mov D$BiggerZeroedSectionsChunk 1

    Mov esi D$SectionsMap, edx D$EndOfSectionsMap | add esi D$FirstSection
    Mov ebx esi | sub ebx D$SectionsMap | add ebx D$UserPeStart

    .While esi < edx
        .If B$esi = 0
            Mov ecx 0, eax &FALSE

            While B$esi = 0
                inc esi | inc ecx | On esi >= edx, jmp L2>
                On B$ebx <> 0, Mov eax &TRUE
            End_While

            If eax = &TRUE
              ; (Don't consider zeroed Chunks, in the PE):
                Mov eax &FALSE
L2:             On ecx > D$BiggerZeroedSectionsChunk, Mov D$BiggerZeroedSectionsChunk ecx
            End_If
        .End_If

        inc esi, ebx

    .End_While
ret

____________________________________________________________________________________________
;;
  Everything EVOCATED but not yet Recognized may be either Code or Data.
  
  We first Call for 'IsItCode' that says if, 'physicaly', a Chunk could be Code or not.
  
  If yes, run a Try&See Disassembly ('DisassemblingAttempt') on duplicated Dis Tables.
  
  If this attempt is _not_ valid Code, it will __much__ probably break something in the
  already found out Code and/or Data. Nothing broken >>> Run 'DisassembleForCodeRouting'
  for flaging Code.
;;

[LastIdentifiedCandidate: D$ ?]

[Switch | sub #1 D$#2 | add #1 D$#2]

Proc TryToDisassembleEvocated:
    Argument @Required
  ; This 'Required' is the Number of Instructions. Not the number of Bytes.
        Call InitDisTablesCopies

        Mov B$AttemptSuccess &FALSE

        Mov esi D$RoutingMap | add esi D$FirstSection

L0:     .While esi < D$EndOfRoutingMap
L1:         test B$esi EVOCATED+LABEL ZERO L5>>

            Mov ebx esi | sub ebx D$RoutingMap | add ebx D$SectionsMap
            cmp B$ebx 0 | jne L5>>
            sub ebx D$SectionsMap | add ebx D$SizesMap
            cmp B$ebx 0 | jne L5>>

            Push esi, ebx
                sub ebx D$SizesMap | add ebx D$UserPeStart
                Mov ecx ebx | add ecx 100
                Call IsItCode ebx, D$UserPeEnd, D@Required
            Pop ebx, esi

            Move D$LastIdentifiedCandidate D$LastUnAccessed

            ...If eax = &TRUE
              ; Possible Code Candidate found. Give it a try:
L4:             Push esi
                  ; The copies are for preserving the Tables states in cases of failure:
                    Call SetDisTablesCopies
                    or B$esi NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                    sub esi D$RoutingMap | add esi D$SectionsMap
                    Mov B$esi CODEFLAG

                    Call DisassemblingAttempt
                Pop esi

              ; Restore the previous Tables versions on failure cases:
                .If B$DisFailure = &TRUE
                  ; Arase the effect of the previous 'SetDisTablesCopies':
                    Call ExchangeDisTables

                .Else
                    Mov B$AttemptSuccess &TRUE
                    ;jmp L9> ; (Bound to "Pop ecx | jmp L0<", in the main calling loop)

                .End_If

            ...End_If

L5:     inc esi

    .End_While

L9:  Call ReleaseDisTablesCopies
EndP


[SectionsMapCopy: D$ ?
 RoutingMapCopy: D$ ?
 SizesMapCopy: D$ ?
 EndOfSectionsMapCopy: D$ ?
 EndOfRoutingMapCopy: D$ ?
 EndOfSizesMapCopy: D$ ?]

[DisTableLength: D$ ?]

InitDisTablesCopies:
    Mov eax D$EndOfSectionsMap | sub eax D$SectionsMap
  ; Align_On_Variable D$DisRvaSectionAlignment eax |
    Mov D$DisTableLength eax

    Call VirtualAlloc SectionsMapCopy,
                      D$DisTableLength

    Call VirtualAlloc RoutingMapCopy,
                      D$DisTableLength

    Call VirtualAlloc SizesMapCopy,
                      D$DisTableLength

    Mov ecx D$DisTableLength
    Mov eax D$SectionsMapCopy | add eax ecx | Mov D$EndOfSectionsMapCopy eax
    Mov eax D$RoutingMapCopy | add eax ecx | Mov D$EndOfRoutingMapCopy eax
    Mov eax D$SizesMapCopy | add eax ecx | Mov D$EndOfSizesMapCopy eax
ret


SetDisTablesCopies:
    Push esi, edi, ecx
        Mov esi D$SectionsMap, edi D$SectionsMapCopy, ecx D$DisTableLength
        shr ecx 2 | rep movsd
        Mov esi D$RoutingMap, edi D$RoutingMapCopy, ecx D$DisTableLength
        shr ecx 2 | rep movsd
        Mov esi D$SizesMap, edi D$SizesMapCopy, ecx D$DisTableLength
        shr ecx 2 | rep movsd
    Pop ecx, edi, esi
ret

ExchangeDisTables:
    sub esi D$RoutingMap
    Exchange D$SectionsMap D$SectionsMapCopy
    Exchange D$RoutingMap D$RoutingMapCopy
    Exchange D$SizesMap D$SizesMapCopy
    Exchange D$EndOfSectionsMap D$EndOfSectionsMapCopy
    Exchange D$EndOfRoutingMap D$EndOfRoutingMapCopy
    Exchange D$EndOfSizesMap D$EndOfSizesMapCopy
    add esi D$RoutingMap
ret

ReleaseDisTablesCopies:

    Call VirtualFree SectionsMapCopy

    Call VirtualFree RoutingMapCopy

    Call VirtualFree SizesMapCopy

ret


; Code Recognitions over > Everything not yet Flaged is Data:

FillDataSection:
    Mov esi D$SectionsMap | add esi D$FirstSection
    Mov edx D$EndOfSectionsMap

;Mov eax esi | sub eax D$SectionsMap | add eax D$DisImageBase
;    hexprint eax

    While esi < edx

        ;Mov eax esi | sub eax D$SectionsMap | add eax D$UserPeStart | sub eax D$FirstSection
        ;On eax = 04081E4, hexprint DATAFLAG


        .If B$esi = 0
            Mov B$esi DATAFLAG

          ; Force a dummy EVOCATED, at start of any Data Chunk, for the output:
            If B$esi-1 <> DATAFLAG
                Mov ebx esi | sub ebx D$SectionsMap | add ebx D$RoutingMap
                or B$ebx EVOCATED+LABEL
            End_If

        .End_If

        inc esi

    End_While

   ; Mov eax esi | sub eax D$SectionsMap | add eax D$DisImageBase
   ; hexprint eax
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
    Code Recognition of a [Start --- End] un-accessed Code Chunk. Positive recognition
    occur when:
    
    * begins with a 'PUSH_EBP' Routing Flaged Instruction ('@PUSH_EBP')
    * end with a CHUNKEND ('@CHUNKEND')
    * not produce any 'DB' in Disassembly ('@DB')
    * have a positive Likely/Unlikely Code weight Value ('LikelyCode', 'UnLikelyCode')
    * have less than 20% of zeroed Bytes ('@Zeros')
    * be big enough for any bet ('@Size')
    
    Terrific problem of 'tuning', with all of this. So, the recognition tends to say
    it is really Code when it is very likely Code (better failing at flaging valid
    Code than flaging wrong Code as valid...).
;;

[LikelyCode: D$ ?
 UnLikelyCode: D$ ?
 SimpleScan: D$ ?
 LastUnAccessed: D$ ?
 StopAtCall: D$ ?
 StopAtEndOfChunk: D$ ?
 DisEndOfChunkEncounted: D$ ?
 UnlikelyCodeFoundAt: D$ ?]

Proc IsItCode:
    Arguments @Start, @End, @Required
    Local @OpNumber

    Mov B$SimpleScan &TRUE ; Prevents 'WriteDisRelative' from modifying Routing Flags.
    Mov B$DisEndOfChunkEncounted &FALSE

    Mov D$LikelyCode 0, D$UnLikelyCode 0, B$DisEndOfChunk &FALSE, D@OpNumber 0

    Mov eax D@Start | sub eax D$UserPeStart | add eax D$RoutingMap

    Mov ecx D@End | On ecx > D$UserPeEnd, Move D@End D$UserPeEnd

    Mov esi D@Start, edi D$CodeSource

    .If B$esi = 0
        Mov ecx esi
        add ecx 2
        On ecx >= D$UserPeEnd, jmp L2>
        If W$esi+1 = 0
L2:            Mov eax &FALSE | jmp L9>>
        End_If
    .End_If


    .While esi < D@End
        Mov B$DisFlag 0

        Mov D$SegmentOverride 0, B$AddressSizeOverride 0, B$OperandSizeOverride 0
        Mov W$DisSizeMarker 'D$', B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE
        Mov D$LastCodeRef 0, B$LeaInstruction &FALSE

        Mov D$LastUnAccessed esi
;If B$TestNow = 1
;    Mov eax esi | sub eax D$UserPeStart | add eax D$DisImageBase
;    On eax = 0401899, int3
;End_If

L0:     movzx eax B$esi | inc esi | Call D$DisOp1+eax*4 | inc D@OpNumber

        ;Mov ecx D@Required | On D@OpNumber >= ecx, jmp L2>

        .If B$StopAtCall = &TRUE
            If B$CALLInstruction = &TRUE
                Mov eax D$LastUnAccessed | On B$eax = 0E8, Mov B$DisEndOfChunk &TRUE
            End_If
        .End_If

        If D$UnLikelyCode > 0
L1:         Mov eax D$LastUnAccessed | sub eax D$UserPeStart | add eax D$DisImageBase
            Mov D$UnlikelyCodeFoundAt eax
            Mov eax &FALSE | jmp L9>>
        Else_If B$DisFlag = DISFAILED
            Mov eax &FALSE | jmp L9>
        Else_If B$DisEndOfChunk = &TRUE
            Mov B$DisEndOfChunkEncounted &TRUE
            On B$StopAtEndOfChunk = &TRUE, jmp L2>
            Mov ecx D@Required | On D@OpNumber >= ecx, jmp L2>
        End_If

        If B$DisFlag = DISDONE
            jmp L0<<
        Else_If B$LockPrefix = &TRUE
          ; DISDONE+DISLINEOVER, but LOCK not taken by a valid LOCKable Instruction:
            Mov B$LockPrefix &FALSE | jmp L1<
        End_If

    .End_While

L2: Mov eax &TRUE

L9: Mov B$SimpleScan &FALSE

    On eax = &TRUE, Mov D$LastUnAccessed esi
EndP
____________________________________________________________________________________________

[StartOfDisLine: D$ ?
 AlignedComment: D$ ?
 NonAccessedByteWritten: D$ ?]

[DisFailure: D$ ?
 DisFailureType: D$ ?
 EncountedFlag: D$ ?
 AttemptSuccess: D$ ?]

DisassemblingAttempt:
    Mov B$DisFailure &FALSE, D$DisFailureType 0, B$NewAccessedLocations &FALSE
    Mov B$LockPrefix &FALSE

  ; esi > 'SectionsMap' new CODEFLAG attempt when called. So:
    sub esi D$SectionsMap | add esi D$UserPeStart

L0: Mov edi D$CodeSource, D$LastCodeRef 0
    Mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
    Mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
    Mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE
    Mov B$CALLInstruction &FALSE, B$DisEndOfChunk &FALSE

  ; Parse onlyCODEFLAGed (in SectionsMap) and ACCESSED (in RoutingMap) Locations:
L1: Mov eax esi | sub eax D$UserPestart | add eax D$SectionsMap

    Test B$eax CODEFLAG NOT_ZERO L2>
        If B$eax <> 0
            ;On B$TestNow = 1, hexprint 1
            Mov D$DisFailureType 1
            Mov B$DisFailure &TRUE | ret
        End_If
        inc esi | On esi = D$UserPeEnd, jmp L9>>
            jmp L1<

L2:
  ; Is it still a new Location when comparing to the original Table? Yes > Quit:
    sub eax D$SectionsMap | add eax D$SectionsMapCopy | On B$eax = CODEFLAG, ret

    sub eax D$SectionsMapCopy | add eax D$RoutingMap
    test B$eax ACCESSED NOT_ZERO L3>
        inc esi | On esi = D$UserPeEnd, jmp L9>>
            jmp L1<

      ; Call for the Disassembly Routines:
L3:     or B$eax INSTRUCTION

        movzx eax B$esi | Mov D$TestLastLocation esi | inc esi

        Call D$DisOp1+eax*4

        While B$DisFlag = DISDONE
            movzx eax B$esi | inc esi | Call D$DisOp1+eax*4
        End_While

        If B$LockPrefix = &TRUE
            Mov B$LockPrefix &FALSE | add B$UnlikelyCode 50
        End_If

      ; The instruction must not cover a valid Label:
        Mov eax D$TestLastLocation | inc eax
        Mov ebx eax | sub ebx D$UserPeStart | add ebx D$RoutingMap
        While eax < esi
            test B$ebx INSTRUCTION+NODE+LABEL ZERO L3>
                Mov D$DisFailureType 2 | Mov B$DisFailure &TRUE | ret
L3:         inc eax | inc ebx
        End_While

      ; If a Call or a JMP was Disassembed, the decoding Routines return this Flag set on.
      ; We mark the RoutingMap's according Byte as a new Entry Point:
        ...If B$CALLInstruction = &TRUE
            Mov B$CALLInstruction &FALSE

            If B$EscapePrefix <> &TRUE
                Mov eax D$TestLastLocation
                On B$eax = 0E8, Call IsItNoReturnCall ; OpE8
            End_If

            Mov eax D$LastCodeRef | sub eax D$DisImageBase | add eax D$SectionsMap
            On eax < D$SectionsMap, jmp L4>>
            On eax > D$EndOfSectionsMap, jmp L4>>
            test B$eax VIRTUALFLAG+IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+DATAFLAG NOT_ZERO L4>>
            jmp L5>

L4:         Mov D$DisFailureType 3 | Mov B$DisFailure &TRUE | ret

L5:         If B$eax = CODEFLAG
                sub eax D$SectionsMap | add eax D$RoutingMap
                cmp B$eax 0 | je L5>
                test B$eax INSTRUCTION+CHUNKEND NOT_ZERO L3>>
                    Mov D$DisFailureType 4 | Mov B$DisFailure &TRUE | ret

L5:             sub eax D$RoutingMap | add eax D$SectionsMap
; This is not out of logic to re-scan the Code: We are in Try&See actions.
            End_If

            Push esi, eax
                sub eax D$SectionsMap | add eax D$UserPeStart
                Mov ebx eax | add ebx 100
                Push D$DisEndOfChunk
                    Call IsItCode eax, ebx, 1
                Pop D$DisEndOfChunk
                If eax = &FALSE
                    Pop eax, esi
                    Mov D$DisFailureType 5 | Mov B$DisFailure &TRUE | ret
                End_If
            Pop eax, esi

            Mov B$eax CODEFLAG
            sub eax D$SectionsMap | add eax D$RoutingMap | test B$eax ACCESSED NOT_ZERO L3>
                Mov B$NewAccessedLocations &TRUE
L3:         or B$eax NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
        ...End_If

      ; CHUNKEND Flag marks the first Byte *after* a RET or a JMP:
L4:     Mov eax esi | sub eax D$UserPeStart | add eax D$RoutingMap
        If B$DisEndOfChunk = &TRUE
            or B$eax CHUNKEND | dec eax | Mov B$DisEndOfChunk &FALSE | ret ; <<<< new
        End_If

        Mov ebx eax | sub ebx D$RoutingMap | add ebx D$SectionsMap
        .If B$ebx = 0
            ; OK
        .Else_If B$ebx <> CODEFLAG
            Mov D$DisFailureType 6 | Mov B$DisFailure &TRUE | ret
        .End_If

      ; Now Flaged *backward* 'ACCESSED' the Bytes of the new disassembled Instruction,
      ; including the very first Byte of the new coming Instruction, if this one is
      ; not a CHUNKEND (we have 'dec eax' up there in such cases):
L4:     test B$eax ACCESSED NOT_ZERO L6>>
            Mov ecx D$TestLastLocation | sub ecx D$UserPeStart | add ecx D$RoutingMap

L4:         or B$eax ACCESSED | Mov D$NewAccessedLocations &TRUE
            Mov ebx eax | sub ebx D$RoutingMap | add ebx D$SectionsMap
            .If B$ebx = 0
                Mov B$ebx CODEFLAG
            .Else_If B$ebx <> CODEFLAG
                Mov al B$ebx, B$EncountedFlag al
                Mov D$DisFailureType 7 | Mov B$DisFailure &TRUE | ret
            .End_If
            sub ebx D$SectionsMap | add ebx D$SizesMap
            If B$ebx <> 0
                Mov D$DisFailureType 8 | Mov B$DisFailure &TRUE | ret
            End_If

L5:         dec eax

            If eax >= ecx
                test B$eax ACCESSED ZERO L4<<
            End_If

L6: If B$DisFlag = DISLINEOVER+DISDONE
        On esi < D$UserPeEnd, jmp L0<<
    Else_If B$DisFlag = DISFAILED
        Mov D$DisFailureType 9 | Mov B$DisFailure &TRUE | ret
    End_If

  ; Adjust the ProgressBar is wanted:
    If esi > D$NextDisBarPos
        Mov eax esi | add eax D$DisBarStep | Mov D$NextDisBarPos eax
        Call BarProgress
    End_If

  ; Cases of B$DisFlag = DISDONE only (Prefixes, ...):
    On esi < D$UserPeEnd, jmp L1<<

  ; Loop it all until no more new accessed Code Chunks are found:
L9: Mov D$NextDisBarPos 0
    If B$NewAccessedLocations = &TRUE
        Mov edi D$CodeSource, esi D$UserPeStart
        add esi D$FirstSection
        Mov D$NewAccessedLocations &FALSE, D$LastCodeRef 0 | jmp L0<<
    End_If
ret
____________________________________________________________________________________________

[ZeroedEnd: D$ ?
 NextDisTITLE: D$ ?
 StartOfDataChunks: D$ ?]

DisassembleAndWrite:
    Mov B$NonAccessedByteWritten &FALSE, B$LabelWritten &FALSE, D$ZeroedEnd 0
    Mov esi D$UserPeStart, D$TestLastLineLocation 0

    NextDisLine

L0: Mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
    Mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
    Mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE
    Mov B$CALLInstruction &FALSE, B$LeaInstruction &FALSE, B$LabelWritten &FALSE
    Mov D$LastCodeRef 0

    Mov D$Prefixes 0

    On edi > D$NextDisTITLE, Call WriteDisTITLE

  ; Parse only CODEFLAGed Chunks:
L1: Mov eax esi | sub eax D$UserPestart | add eax D$SectionsMap

    If B$eax = DATAFLAG
        Call WriteOneDataChunksAsFound eax | On esi >= D$UserPeEnd, jmp L9>>
        jmp L1<

    Else_If B$eax = VIRTUALFLAG
        Call WriteOneDataChunksAsFound eax | On esi >= D$UserPeEnd, jmp L9>>
        jmp L1<

    Else
        Mov D$StartOfDataChunks 0

    End_If

    Test B$eax CODEFLAG NOT_ZERO L2>
        inc esi | On esi = D$UserPeEnd, jmp L9>>
            jmp L1<<

L2: Mov ebx esi | sub ebx D$UserPeStart | add ebx D$RoutingMap

    Test B$ebx EVOCATED ZERO L3>
        Push ebx
            Call WriteDisCodeLabel
        Pop ebx
        Mov B$edi CR, B$edi+1 LF, D$edi+2 '    ' | add edi 6

      ; Just to force non ACCESSED DB here:
        Mov B$NonAccessedByteWritten &FALSE, B$LabelWritten &TRUE

L3: test B$ebx ACCESSED NOT_ZERO L3>
        .If B$NonAccessedByteWritten = &FALSE
            If B$LabelWritten = &FALSE
                Push ebx
                    Call WriteDisCodeLabel | NextDisLine
                Pop ebx
            End_If
            Push ebx
                Call WriteDBandData
            Pop ebx
            cmp B$ItWasAlignment &TRUE | je L0<<
            cmp B$NonAccessedByteWritten &FALSE | je L4>
        .End_If
        Mov B$edi-2 ';' | jmp L4>

L3: Mov B$NonAccessedByteWritten &FALSE

L4: Mov D$StartOfDisLine esi, D$AlignedComment edi | add D$AlignedComment 32

    movzx eax B$esi | inc esi
    Push esi
        Call D$DisOp1+eax*4
            While B$DisFlag = DISDONE
                movzx eax B$esi | inc esi | Call D$DisOp1+eax*4
            End_While
        End_If
    Pop ebx

  ; Was a real NODE eaten by the Decoding? If yes, go back and re-parse:
  ; Should be no more used since the implementation of upper 'DisAlignedToData':
    While ebx < esi
        Mov eax ebx | sub eax D$UserPeStart | add eax D$RoutingMap
        Test B$eax NODE ZERO L4>
            Call BadDecode | Mov esi ebx
            Push esi
                Call WriteDisCodeLabel | NextDisLine
            Pop esi
            jmp L0<<
L4:     inc ebx
    End_While

  ; Adjust the ProgressBar is wanted:
    If esi > D$NextDisBarPos
        Mov eax esi | add eax D$DisBarStep | Mov D$NextDisBarPos eax
        Call BarProgress
    End_If

    If B$DisFlag = DISLINEOVER+DISDONE
        On B$WithCommentedHexa = &TRUE, Call CommentHexa
        NextDisLine

    Else_If B$DisFlag = DISDONE
        On esi < D$UserPeEnd, jmp L1<<

    Else_If B$DisFlag = DISFAILED
        Push esi, eax
            Mov esi D$StartOfDisLine
            Call WriteDisCodeLabel
        Pop eax, esi
        Mov D$edi ' DB ' | add edi 4
        Call LoadedOpToHexa | stosw
            NextDisLine
    End_If

    On esi < D$UserPeEnd, jmp L0<<

L9: If D$ZeroedEnd <> 0
        Mov edi D$ZeroedEnd, D$edi 0
    End_If
ret
____________________________________________________________________________________________
;;
  Menus: Usually, 0111 (&WM_COMMAND) in D$ebp+12 // ID in W$ebp+16. Failure Message if not.
;;

[WM_COMMAND_Found: D$ ?]

MenuIdsSubstitutions:
    Mov B$WM_COMMAND_Found &FALSE

    On D$MainWindowProcIsThere = 0, ret

  ; 'PrepareDisMenuIDs' Builds the Table of Menu Ids Declaration ready to insert:
    Call PrepareDisMenuIDs | Call WriteDisMenuIDs

    Mov esi D$MainWindowProcIsThere, edx D$STRUCT.EditData@SourceEnd

    .While esi < edx
          ; Search for a &WM_COMMAND:
;;
; Example:
  Mov eax D$ebp+0C
    cmp eax 01
    
Code040112B: N9: | jne K0>  ; Code04011A4
;;
        ...If D$esi = 'p+0C'

            If D$esi+5 = '0111'
                add esi 5 | jmp L1>
            End_If
L0:         While D$esi <> 'cmp '
                inc esi | On esi >= edx, jmp L9>>
            End_While
            add esi 5
            While B$esi > SPC
                inc esi | On esi >= edx, jmp L9>>
            End_While
            inc esi

            ..If D$esi = '0111'
L1:             .If B$esi-1 <= SPC
                    If B$esi+4 <= SPC
                    ; Example:
                    ; Code0401230: I0:
                    ;     cmp eax 0111 | jne Code04018D1
                        Mov ebx esi | sub ebx 2
                        While B$ebx > SPC | dec ebx | End_While
                        On D$ebx-3 = 'cmp ', jmp L5>>
                    End_If
                .End_If

            ..Else
;;
                  ; Not a '0111' Case >>> Search the 'jne ' >>> Get the next Label:
                    While D$esi <> 'jne '
                        inc esi | On esi >= edx, jmp L9>>
                    End_While
                    While D$esi <> 'Code'
                        inc esi | On esi >= edx, jmp L9>>
                    End_While
                    add esi 7 | lodsd
        
L1:                 While D$esi <> eax
                        inc esi | On esi >= edx, jmp L9>>
                    End_While
                    add esi 4 | On B$esi <> ':', jmp L1<
;;
            ..End_If

            jmp L0<<

       ...End_If

        inc esi
    .End_While

    Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ "WM_COMMAND not found:
  
You cannot edit the Resources Main Menu, if any   " EOS},
                                {B$ 'Menu IDs substitution failure' EOS}, 0
    ret

L5: Push esi
        Call SaveOriginalMenuIDs
    Pop esi

    Call DisReplace esi, 4, {B$ '&WM_COMMAND' EOS}, 11

    Call SubstituteMainMenuIDs

    Mov B$WM_COMMAND_Found &TRUE
L9: ret

;;
  Menu ID Equates in 'DataForClipEquates'
  Original Equates in 'OriginalMenuIDs'
  esi yet pointing '0111' (&WM_COMMAND) in the Source
;;
SubstituteMainMenuIDs:
;;
  esi yet pointing the &WM_COMMAND Location:
  
  cmp eax &WM_COMMAND | jne Code04018D1
      Mov eax D$ebp+010
      cmp ax 0M00_Calculate_
    
Code0401242: J8: | jne Code040142B
;;
    While B$esi <> '|' | inc esi | End_While
    While W$esi <> ' j' | inc esi | End_While | inc esi

    If D$esi <> 'jne '
        Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ 'Unexpected MainWindowProc Main Menu Messages Cases organisation' EOS},
                                {B$ 'Failure of Main Menu IDs substitutions' EOS}, 0
        ret
    End_If

  ; Store the end of the Label Name closing the &WM_COMMAND Case in edx ('Text'):
    add esi 9 | While B$esi > SPC | inc esi | End_While
    Mov edx D$esi-4

L0: ..While D$esi <> edx
        inc esi

        ...If D$esi = '$ebp'
            ..If D$esi+4 = '+010'
                If D$esi-5 = 'cmp '
                    add esi 8 | jmp A5>
                End_If
                add esi 8
L1:             While D$esi <> 'cmp '
                    inc esi | On esi = D$STRUCT.EditData@SourceEnd, jmp L9>>
                End_While

                add esi 5 | On D$esi = '$ebp', jmp L1<

                While B$esi > SPC | inc esi | End_While

A5:             .If W$esi = ' 0'
                    add esi 2 | Mov ebx 0
                    Push esi
L2:                     lodsb | cmp al SPC | jbe L2>
                        sub al '0' | On al > 9, sub al 7
                        shl ebx 4 | or bl al | jmp L2<
L2:                 Pop esi
                    dec esi

                  ; Possible ID in eax. Is it in 'OriginalMenuIDs':
                    If ebx <> 0
                        Mov eax ebx, edi OriginalMenuIDs, ecx 100 | repne scasd
                    Else
                        Mov ecx 0
                    End_If

                    If ecx > 0
                      ; One Based Indice of Menu ID in ecx (1 is M00_Menu):
                        sub ecx 100 | neg ecx
                        Mov edi DataForClipEquates | inc edi

                        While ecx > 0
L3:                         inc edi | cmp B$edi SPC | ja L3<    ; An Equate Name
L3:                         inc edi | cmp B$edi SPC | jna L3<   ; Spaces
L3:                         inc edi | cmp B$edi SPC | ja L3<    ; An Equate Value
L3:                         inc edi | cmp B$edi SPC | jna L3<   ; Spaces
                            dec ecx
                        End_While

                      ; Length of Equate Name in ebx
                        Mov ebx 0
                        While B$edi+ebx > SPC | inc ebx | End_While
                        On B$edi+ebx-1 = ']', dec ebx
                      ; Length of Original Source Equate Value in ecx
                        Mov ecx 0
                        While B$esi+ecx > SPC | inc ecx | End_While

                        Call DisReplace esi, ecx, edi, ebx
                    End_If
                .End_If

                While D$esi <> 'jne '
                    inc esi | On esi = D$STRUCT.EditData@SourceEnd, jmp L9>>
                End_While
                While D$esi <> 'Code'
                    inc esi | On esi = D$STRUCT.EditData@SourceEnd, jmp L9>>
                End_While

                While B$esi > SPC | inc esi | End_While
                Mov eax D$esi-4
L6:             While D$esi <> eax
                    inc esi | On esi = D$STRUCT.EditData@SourceEnd, jmp L9>>
                End_While
                add esi 4 | cmp B$esi ':' | jne L6<

                jmp L1<<
            ..End_If
        ...End_If
    ..End_While

    add esi 4 | cmp B$esi ':' | jne L0<<
L9: ret


; For replacing small words on the fly:

Proc DisReplace:
    Arguments @SourcePos, @DelLength, @Insert, @InsertLength
    Uses esi, edi, ecx

        add D$SourceLen 400 | add D$STRUCT.EditData@SourceEnd 400
        Mov eax D@InsertLength

        .If eax > D@DelLength
            Mov esi D$STRUCT.EditData@SourceEnd, edi esi
            add edi D@InsertLength | sub edi D@DelLength
            Mov ecx esi | sub ecx D@SourcePos | std | rep movsb | cld

            Mov esi D@Insert, edi D@SourcePos, ecx D@InsertLength
            rep movsb

        .Else
            Mov esi D@Insert, edi D@SourcePos, ecx D@InsertLength
            rep movsb

            If eax < D@DelLength
                Mov esi D@SourcePos | add esi D@DelLength
                Mov ecx D$STRUCT.EditData@SourceEnd | sub ecx esi
                rep movsb
            End_If

        .End_If

        Mov eax D@InsertLength | sub eax D@DelLength
        sub D$SourceLen 400 | add D$SourceLen eax
        sub D$STRUCT.EditData@SourceEnd 400 | add D$STRUCT.EditData@SourceEnd eax
EndP


[OriginalMenuIDs: D$ ? # 100]
; 'uMenu' comments
; We read the original Menu Items IDs yet in the new MenuEx Table:

SaveOriginalMenuIDs: ; Original IDs at +8?   'PrepareDisMenuIDs'  'TurnThisMenuToExType'
    Mov D$MenulistPtr MenuList, esi MenuList        ; (ID / Ptr / Size)

    Mov eax D$esi, ecx D$esi+8, esi D$esi+4
    inc eax | Mov D$FirstMenuId eax

    Mov D$EndOfDisMenu esi | add D$EndOfDisMenu ecx

  ; Header:  'uMenu'
    add esi 8

    Mov edi OriginalMenuIDs, eax 0, ecx 100 | rep stosd

    Mov edi OriginalMenuIDs, edx 0, D$SeparatorsNumber 0, D$PopUpNumber 0

L0: movzx eax W$esi+8
    .If eax = 0             ; No ID >>> Separator or PopUp
        If W$esi+12 = 0     ; Separator (8 zeroed Words)
            add esi 16 | On esi < D$EndOfDisMenu, jmp L0<
                jmp L9>
        Else                ; PopUp (+4 is the Added 'HelpID' for Popups Items only)
            add esi 14
            While W$esi <> 0 | add esi 2 | End_While | add esi 2+4
            AlignOn 4, esi
        End_If

    .Else
        stosd
L1:     add esi 14
        If esi < D$EndOfDisMenu
            While W$esi <> 0 | add esi 2 | End_While | add esi 2
            AlignOn 4, esi
        Else
L9:         Mov D$edi 0 | ret
        End_If

    .End_If

    On esi < D$EndOfDisMenu, jmp L0<

____________________________________________________________________________________________

[MenuCharsSet: B$ '&<>=?@0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.' EOS]
[MenuCharsLen: D$ 70]

[MenuChar: D$ ?]

; Is a Char valid for Naming The Menu IDs?:

MenuChars:
        Push ecx, edi
            Mov ecx D$MenuCharsLen, edi MenuCharsSet, B$MenuChar &FALSE
            repne scasb | jnz L9>
                Mov B$MenuChar &TRUE
L9:     Pop edi, ecx
ret
____________________________________________________________________________________________

[MenuReadPointer: D$ ?
 EndOfDisMenu: D$ ?
 DisItemFlag: D$ ?]

PrepareDisMenuIDs:  ; 'ClipEquates', 'ForceMenusExType', 'TurnThisMenuToExType'

    Mov D$MenulistPtr MenuList, esi MenuList        ; (ID / Ptr / Size)

  ; Temporary consider the first Menu, the Main one.
  ; Add Checking for the Main Window Menu later.
    Mov eax D$esi, ecx D$esi+8, esi D$esi+4

  ; Kill the High Bit saying that this is a Pointer to the name of a Named ID, if any:
    and eax 0FFFF

    inc eax | Mov D$FirstMenuId eax

    Mov D$EndOfDisMenu esi | add D$EndOfDisMenu ecx

    Mov D$MenuEquateIndice 'M00_'
    Mov eax D$MenulistPtr | sub eax MenuList
    Mov ebx 12, edx 0 | div ebx                 ; > indice = 0, 1, 2, ...
    Mov ebx 10, edx 0 | div ebx
    add B$MenuEquateIndice+2 dl
    Mov edx 0 | div ebx
    add B$MenuEquateIndice+1 dl

  ; Header:  'uMenu'
    add esi 8 | Mov D$MenuReadPointer esi

    Mov edi DataForClipEquates, edx 0, D$SeparatorsNumber 0, D$PopUpNumber 0
    Mov al '[' | stosb | Mov D$StartOfItemsLine edi

    Mov eax D$MenuEquateIndice | stosd | Mov eax 'Menu' | stosd

    dec D$FirstMenuID | Call WriteClipIDvalue | inc D$FirstMenuID

L0: Push edi
        Mov edi OneItemString, esi D$MenuReadPointer
        add esi 14
        movzx eax W$esi-2 | and eax (not &MF_END) | Mov D$DisItemFlag eax

        .If esi < D$EndOfDisMenu
            While W$esi <> 0
L1:             lodsw
                    Call MenuChars | On B$MenuChar = &FALSE, Mov al '_'
                stosb
            End_While | lodsw | stosb
            On D$DisItemFlag <> 0, add esi 4
            AlignOn 4, esi | Mov D$MenuReadPointer esi
        .Else
            Pop edi
            While B$edi-1 <= SPC | dec edi | End_While
            Mov al ']' | stosb | Mov al 0 | stosb | ret
        .End_If
    Pop edi

    Mov esi OneItemString

    While B$esi = TAB
        inc esi
    End_While
    If B$esi = 0
        inc D$SeparatorsNumber | inc edx | jmp L0<<
    End_If

    If D$DisItemFlag <> 0
        inc D$PopUpNumber | inc edx | jmp L0<<
    End_If

T0: Mov esi OneItemString, eax D$MenuEquateIndice | stosd
    While B$esi <= SPC
        lodsb                                           ; strip leading tabs and spaces
    End_While

L3: lodsb | cmp al 0 | je L4>
        On al = '&', jmp L3<                            ; do not write '&'
        On al = TAB  , jmp L4>                          ; do not write 'hot keys'
        On al < '0', Mov al '_'
        If al = '_'
            On B$edi-1 = '_', jmp L3<                   ; only one '_' at a time
        End_If
        stosb | jmp L3<                                 ; name

L4: Call WriteClipIDvalue | inc edx | jmp L0<<

____________________________________________________________________________________________

[TempoSource: D$ ?]

; Writes the [Menus IDs] into the Source.

WriteDisMenuIDs:
    Mov ecx D$SourceLen | add ecx 1_000_000

    Call VirtualAlloc TempoSource,
                      ecx

  ; Make a temporary Copy:
    Mov esi D$CodeSource, edi D$TempoSource, ecx D$SourceLen

    AlignOn 4 ecx | shr ecx 2 | rep movsd

  ; Now Tempo >>> Original Source (simpler than killing all associated Variables)
  ; (edx = How many added Bytes):

    Mov edi D$MainWindowProcIsThere, esi edi
    sub esi D$CodeSource | add esi D$TempoSource

  ; Start the Insert after a CRLF:
    While W$edi-2 <> CRLF | dec edi | dec esi | End_While

  ; Kep track of the original Source Last Chunk length:
    Mov ebx D$STRUCT.EditData@SourceEnd | sub ebx edi

    Mov al '_'
    Mov ecx DRAWLINELEN | rep stosb | Mov W$edi CRLF | add edi 2
    Mov ecx DRAWLINELEN | rep stosb | Mov D$edi CRLF2 | add edi 4

    Mov edx (DRAWLINELEN+2+DRAWLINELEN+4)

    Push esi
        Mov esi DataForClipEquates

        While B$esi <> 0 | movsb | inc edx | End_While
    Pop esi

    Mov D$edi CRLF2 | add edi 4 | add edx 4

    Mov ecx ebx | add ecx 400       ; Security CRLFs Tail
    rep movsb

    add D$SourceLen edx | add D$STRUCT.EditData@SourceEnd edx

    Call VirtualFree TempoSource

ret

____________________________________________________________________________________________

[MainWindowProcIsThere: D$ ?]
____________________________________________________________________________________________

WriteDisTITLE:  ; 'DisTitle'
    Push esi
        Mov esi DisTitle
        .If B$DisTitle+13 = '9'
            Mov B$DisTitle+13 'A'
        .Else
            inc B$DisTitle+13
            If B$DisTitle+13 = '['
                Mov B$DisTitle+13 '0' | inc B$DisTitle+12
            End_If
        .End_If
        While B$esi <> 0 | movsb | End_While
    Pop esi

    Mov eax edi | add eax (TITLE_MAX/2) | Mov D$NextDisTITLE eax

    Mov D$edi '    ' | add edi 4
ret

____________________________________________________________________________________________
;;
  Problem: When Pointers to either Code or Data are found inside Data, we have to
  choose if they effectively are Pointers or not. It is statistically possible that
  what appears to possiblily be a Pointer, be nothing Else but the result of random
  Needless to say, the bigger size the targetted File is, the more chances we have
  for a wrong interpretation.
  
  In such case, wrongly interpreting a random flow of Bytes as a Pointer is not
  catastrophic. The reverse is... : Say we have a dWord like 040301A that we suspect
  to be a Code Pointer. Now, if we do not validate the 'Code040301A' interpretation,
  the Application will hang after re-compilation, because what was located at 040301A
  in the original file has no chance to be at the same Address after re-compilation
  (because of Code size variations across various Compiler, because of PE Sections
  ordering, and so on...). I other words, once re-compiled, 'Code040301A' Value will
  not be 040301A (unless the targetted File had been builded with RosAsm).
  
  So, the better way is to validate those Pointers each time it is possible, when
  interpreting and writing the Data.
  
  For Data Pointers to Data, there is zero problem. In the worst cases, we may, for
  example, induce a no use Data Label, that will, fore example, cut a String presentation,
  into 2 sub-Strings, but this will not change a thing for the re-Compilation. Only
  the Data content (in place of that Pointer will be wrong, and user can restore it
  from the Label Name, if necesary, by hand).
  
  For Code, the problem is about not cutting into the middle of a valid Instruction.
  This is why, before runing 'CheckPointersInData', we have first run
  'DisassembleForIntructions' one shot (for having all Instructions Flaged INSTRUCTION).
  
  Here, we simply Flag the Data Part of RoutingMap, with INDIRECT, for making the 
  interpretations easier. We verify, also that any Pointer to Code does
  not break an Instruction into two. So, the possibilities for wrongly validating a 
  Pointer to Code is divided by 3 or 4...
;;

CheckPointersInData:
    Mov esi D$SectionsMap, edx D$EndOfSectionsMap | sub edx 4
    add esi D$FirstSection

    .While esi < edx
    Mov eax esi | sub eax D$SectionsMap | add eax D$DisImageBase

        ...If B$esi =  DATAFLAG
          ; We read the dWord Values of each Data in the PE:
L1:         Mov eax esi | sub eax D$SectionsMap | add eax D$UserPeStart
            Mov eax D$eax | sub eax D$DisImageBase | add eax D$UserPeStart
          ; Is it pointing somewhere inside the PE?
            ..If eax > D$UserPeStart
                .If eax < D$UserPeEnd
                    Call IsItTruePointer | cmp eax 0 | je L5>>

                  ; Yes, say it in SizesMap:
                    Mov ebx esi | sub ebx D$SectionsMap | add ebx D$SizesMap
                    or B$ebx POINTER

                  ; Yes > read the Pointer Section Flag:
                    sub eax D$UserPeStart | add eax D$SectionsMap
                    Mov bl B$eax | and bl CODEFLAG+DATAFLAG+VIRTUALFLAG | jz L5>>
                        sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax EVOCATED
                        If bl = CODEFLAG
                            test B$eax INSTRUCTION ZERO L5> ; Do not kill a valid instruction.
                              ; Write the Code Routing Map:
                                or B$eax NODE+ACCESSED+LABEL
                              ; Write the Data Routing Map:
L2:                             Mov eax esi |  sub eax D$SectionsMap | add eax D$RoutingMap
                                or B$eax INDIRECT
                                add esi 3       ; +1 down here > next dWord.
                        Else_If bl = DATAFLAG
                          ; Do not destroy a valid Data Type: ???
                            Mov eax esi |  sub eax D$SectionsMap | add eax D$SizesMap
                          ;  cmp D$eax 0 | jne L5>
                            sub eax D$SizesMap | add eax D$RoutingMap
;;
  Problem: For Erde, it needs 'INDIRECT'. For the big File it needs 'EVOCATED'.
  This should indicate a problem in the Data outputing...
;;
                            or B$eax INDIRECT ;+EVOCATED+LABEL
                            add esi 3
                        End_If
                .End_If
            ..End_If
        ...End_If

L5:     inc esi
    .End_While

  ; Now, force a dummy Label to be outputed at the first and after last INDIRECT
  ; references (first and last of a flow of pointers, in order to ease the Data
  ; interpretations output, and group in one single set, flows of Pointers).
    Mov esi D$SectionsMap | add esi D$FirstSection

    .While esi < edx
        If B$esi = DATAFLAG
            Mov eax esi | sub eax D$SectionsMap | add eax D$RoutingMap

            test B$eax INDIRECT ZERO L5>
                Mov D$eax LABEL+EVOCATED+INDIRECT  ; 04A
L1:             add eax 4 | add esi 4
                test B$eax INDIRECT ZERO L3>
                test B$eax LABEL+EVOCATED NOT_ZERO L3>
                    Mov D$eax 0 | jmp L1<
L2:
L3:             or B$eax LABEL+EVOCATED

        Else
L5:         inc esi
        End_If

    .End_While
ret
____________________________________________________________________________________________

;;
  In RosAsm Assembler, the Table Sizes (usually zeroed Tables), are limited,
  on purpose (they could as well not be limited...), to Push the users to good
  programming practices. So, in the Disassembler we need a Routine for splitting
  these too big Tables, by emitting (forcing) a dummy Label, that has no other
  purpose but forcing the Assembler to eat such demential Tables, and to kill the limitation.
;;

SplitBigData:
    Mov esi D$SectionsMap, edx D$EndOfSectionsMap | add esi D$FirstSection
    Mov ebx esi | sub ebx D$SectionsMap | add ebx D$RoutingMap

    .While esi < edx
        Mov al B$esi

        .If al = DATAFLAG
            Mov ecx 4
            While B$esi = al
                inc esi | inc ecx | inc ebx | On esi >= edx, ret
                test B$ebx EVOCATED+LABEL ZERO L1>
                    Mov ecx 4

L1:             If ecx >= LOOPDATAMAX
                    Mov ebx esi | sub ebx D$SectionsMap | add ebx D$RoutingMap
                    or B$ebx LABEL+EVOCATED
                    ;sub ebx D$RoutingMap | add ebx D$DisImageBase | hexprint ebx
                    Mov ecx 4
                End_If
            End_While

        .Else_If al = VIRTUALFLAG
            Mov ecx 4
            While B$esi = al

                inc esi | inc ecx | inc ebx | On esi >= edx, ret
                test B$ebx LABEL ZERO L1>
                    Mov ecx 4

L1:             If ecx >= LOOPVDATAMAX
                    Mov ebx esi | sub ebx D$SectionsMap | add ebx D$RoutingMap
                    or B$ebx LABEL+EVOCATED
                    ;sub ebx D$RoutingMap | add ebx D$DisImageBase | hexprint ebx
                    Mov ecx 4
                End_If
            End_While

        .End_If

        inc esi | inc ebx

    .End_While
ret
____________________________________________________________________________________________

FlagsCoherency:
    Mov esi D$SizesMap, edx D$EndOfSizesMap | add esi D$FirstSection
    Mov ebx esi | sub ebx D$SizesMap | add ebx D$RoutingMap

    .While esi < edx
        Mov eax ebx | sub eax D$RoutingMap | add eax D$SectionsMap
        On B$eax <> DATAFLAG, jmp L2>>

        test B$esi FP4 ZERO L1>
            ;Call IsLabelInsideFp 4
            and D$ebx 0FF
            Mov D$esi 0, B$esi FP4 | jmp L2>>
            ;Mov B$esi FP4 | jmp L2>>

L1:     test B$esi FP8 ZERO L1>
            ;Call IsLabelInsideFp 8
            and D$ebx 0FF | Mov D$ebx+4 0
            Mov D$esi 0, D$esi+4 0, B$esi FP8 | jmp L2>>

            ;Mov B$esi FP8 | jmp L2>>

L1:     test B$esi FP10 ZERO L1>
            ;Call IsLabelInsideFp 10
            and D$ebx 0FF | Mov D$ebx+4 0, W$ebx+8 0
            Mov D$esi 0, D$esi+4 0, W$esi+8 0, B$esi FP10 | jmp L2>
           ;Mov B$esi FP10 | jmp L2>>

L1:     test B$esi DWORD ZERO L1>
            ;Call IsDwordString | On eax = &TRUE, jmp L2>
            ;and D$ebx 0FF
            Mov B$esi DWORD | jmp L2>

L1:     Test B$esi STRINGS ZERO L1>
            Mov al POINTER+DWORD | not al | and B$esi al

L1:     Test B$esi POINTER ZERO L2>
;;
            Push ebx
                sub ebx D$RoutingMap | add ebx D$UserPeStart | Mov eax D$ebx
                sub eax D$DisImageBase | add eax D$SectionsMap
                On eax < D$SectionsMap, jmp L4>
                On eax > D$EndOfSectionsMap, jmp L4>
                   ; If B$eax = CODEFLAG
                   ;     sub eax D$SectionsMap | add eax D$RoutingMap
                   ;     test B$eax INSTRUCTION | jnz L3>

L4:                         ;Pop ebx | Push ebx
                            ;sub ebx D$RoutingMap | add ebx D$DisImageBase
                            ;hexprint ebx
                            ;Mov D$MapingBase ebx
                            ;map

                            xor B$esi POINTER
                   ; End_If
L3:         Pop ebx
;;
L2:     inc esi | inc ebx
    .End_While
ret


Proc FlagsCleaner:
    pushad
        Mov ecx D$SectionsMap, edx D$EndOfSectionsMap, esi D$RoutingMap, ebx D$SizesMap
        Mov eax (not (INSTRUCTION+NODE+EXPORTNODE+PUSH_EBP))

        .While ecx < edx
          ; Data cannot assume any of these Routing Flags:
            If B$ecx = DATAFLAG
                xor al EXPORTNODE
                and B$esi al
                xor al EXPORTNODE

          ; Same for VirtualData:
            Else_If B$ecx = VIRTUALFLAG
                and B$esi al

          ; Code cannot assume any Size Flag:
            Else_If B$ecx = CODEFLAG
                Mov B$ebx 0

            End_If

            inc ecx, esi, ebx

        .End_While
    popad
EndP
____________________________________________________________________________________________

;;
  eax points to a supposed Pointer in the PE data section.
  Might not be a true Pointer but, as well, a String, unicode String, or anything Else.
;;

IsItTruePointer:
    pushad
      ; esi points to 'SectionsMap'. Read the real PE Value:
        sub esi D$SectionsMap | add esi D$UserPeStart | Mov eax D$esi

      ; Do not break any Label:
        Mov ebx esi | sub ebx D$UserPeStart | add ebx D$RoutingMap
        test D$ebx ((LABEL shl 24)+(LABEL shl 16)+(LABEL shl 8)) ZERO L1>
            and B$ebx (not INDIRECT)
            popad | Mov eax 0 | ret

      ; First, do not break any identifed Data Type:
L1:     Mov ebx esi | sub ebx D$UserPeStart | add ebx D$SizesMap
        If D$ebx <> 0
            popad | Mov eax 0 | ret
        End_If



      ; Do not break an Evocated Ascii String:
        Mov edx D$TruthAsciiTable
        Mov eax 0 | add esi 3 | add ebx 3 | Mov al B$esi

        Push esi, ebx
            While B$edx+eax = GOODASCII
                If B$ebx <> EOS
                    test B$ebx BYTE ZERO L2>
                        or B$ebx STRINGS
                        Pop ebx, esi | popad | Mov eax 0 | ret
                End_If

                dec esi | dec ebx
                Mov al B$esi
            End_While

L2:     Pop ebx, esi

      ; Do not break an Evocated Unicode String:
        Mov al B$esi
        If al = 0
            dec esi | dec ebx
            Mov al B$esi
        End_If

        While B$edx+eax = GOODASCII
            On B$esi+1 <> 0, jmp L2>

            If B$ebx <> 0
                test B$ebx WORD ZERO L2>
                    or B$ebx STRINGS
                    popad | Mov eax 0 | ret
            End_If

            sub esi 2
            dec ebx | cmp B$ebx 0 | jne L2>
            dec ebx

            Mov al B$esi
        End_While

L2:
    popad
ret
____________________________________________________________________________________________

WriteLabelFromEsi:
    On esi = D$LastWrittenLabel, ret
    Mov ebx esi | sub ebx D$UserPeStart | add ebx D$DisImageBase
            Push ebx
            Mov ax 0A0D | stosw
            Mov D$edi 'Code' | add edi 4
            Push 0-1
L0:         Mov eax ebx | shr ebx 4 | and eax 0F
            add eax '0' | On eax > '9', add eax 7
            Push eax
            cmp ebx 0 | ja L0<
            Mov B$edi '0' | inc edi
L0:         Pop eax | cmp eax 0-1 | je L9>
            Mov B$edi al | inc edi | jmp L0<
L9:         Mov W$edi ': ' | add edi 2
        Pop eax
        Call WriteLocalLabelFromEax
ret


[ItWasAlignment: D$ ?]

; In: ebx (> eax) > RoutingMap // esi > CodeTest // edi > CodeSource
WriteDBandData:
    Mov B$ItWasAlignment &FALSE
  ; May be Valid Code, but not ACCESSED:
; (This first part should no more be of any use).
    test B$ebx PUSH_EBP ZERO L1>
        Push ebx
L0:         inc ebx | cmp ebx D$EndOfRoutingMap | je L0>
            test B$ebx ACCESSED NOT_ZERO L0>
                Mov eax ebx | sub eax D$RoutingMap | add eax D$UserPestart
                .If B$eax = 05D                 ; Pop ebp
                    If B$eax+1 = 0C3            ; ret
                        inc ebx
                        Mov ecx ebx | Pop ebx | Call ReFlagNonaccessed ; | jmp L9>>
                        Mov B$NonAccessedByteWritten &FALSE, B$LabelWritten &FALSE | ret
                    Else_If B$eax+1 = 0C2   ; ret n (n dWord aligned)
                        Test B$eax+2 00_11 NOT_ZERO L0>
                            add ebx 3
                            Mov ecx ebx | Pop ebx | Call ReFlagNonaccessed ; | jmp L9>>
                            Mov B$NonAccessedByteWritten &FALSE, B$LabelWritten &FALSE | ret
                    End_If
                .End_If
            jmp L0<
L0:     Pop ebx

  ; May be a 'NOP' or 'Int 3', or... , Alignment:
L1: Call AlignRecognition

    If B$ItWasAlignment = &TRUE
        Mov D$edi 'Alig', W$edi+4 'n ' | add edi 6
        Move D$edi D$Alignement | add edi 4
        Mov D$StartOfDisLine esi | add esi D$Alignementlenght
        On B$WithCommentedHexa = &TRUE, Call CommentHexa
        NextDisLine | jmp L9>>
    End_If

L2: Mov eax ebx
    Push esi
       ; If B$LabelWritten = &FALSE
            Push eax
                Call WriteLabelFromEsi | NextDisLine
            Pop eax
       ; End_If
;;
pushad
Mov eax esi | sub eax D$UserPeStart | add eax D$DisImageBase
On eax = 0401354, int3
popad
;;
        Call WriteDisCodeLabel
      ; Durty: Need a version without the CRLFs:
        While B$edi <> ':' | dec edi | End_While | inc edi
        Mov B$edi SPC | inc edi

        Mov edx eax, ecx 0
        Mov D$edi 'DB  ' | add edi 3

L0:     test B$edx ACCESSED NOT_ZERO L5>  ; 01F
        test B$edx EVOCATED ZERO L3>
            pushad
                Call WriteDisCodeLabel
            popad
           ; Mov B$edi CR, B$edi+1 LF, D$edi+2 '    ' | add edi 6

L3:         movzx eax B$esi | inc esi
            If eax < 010
                Mov D$edi '    ' | inc edi
                On eax = 0, inc edi
            End_If
            Call WriteEax
            Mov B$edi SPC | inc edi | inc ecx
            If ecx = 20
                Mov B$edi-1 ','
                NextDisLine | Mov D$edi '    ' | add edi 3
                Mov ecx 0
            End_If
            inc edx
            If edx < D$EndOfRoutingMap
                test B$edx EVOCATED NOT_ZERO L5>
                jmp L0<
            End_If

L5:     On D$edi-3 = '    ', sub edi 3 ; <--- Probably stupid.
        NextDisLine
        Mov ecx esi
    Pop esi

    sub ecx esi | jecxz L9>
    Mov ebx esi | Call WriteCommentedAsciiData | NextDisLine
    .If B$ItWasReallyAscii = &FALSE
        If ecx > 3
            Call WritedCommentedWordsData | NextDisLine
        End_If
    .End_If

L9: Mov B$NonAccessedByteWritten &TRUE, B$LabelWritten &FALSE
ret

;;
[AlignNop: B$ 090
 AlignInt3: 0CC
 AddB_eaxAl: 0 0
 LeaEspLong: 08D 0A4 024 0 0 0 0    ; lea esp D$esp+00 >>> 8D A4 24 00 00 00 00
 LeaEsiLong: 08D 0B4 026 0 0 0 0    ; lea esi D$esi+00 >>> 8D B4 26 00 00 00 00
 LeaEsp: 08D 064 024 0              ; lea esp D$esp+00 >>> 8D 64 24 00 
 LeaEcx: 08D 049 0                  ; lea ecx D$ecx+00 >>> 8D 49 00 
 LeaEbx: 08D 09B 0 0 0 0            ; lea ebx D$ebx+00 >>> 8D 9B 00 00 00 00
 AddEax0: 05 0 0 0 0                ; add eax 0 >>> 05 00 00 00 00 
 MovEdiEdi: 08B 0FF                 ; Mov edi edi >>> 8B FF 
 MovEsiEsi: 089 0F6                 ; Mov esi esi >>> 89 F6 
 ]

[AlignTable: AlignNop 1, AlignInt3 1, AddB_eaxAl 2, LeaEspLong 7, LeaEsp 4, LeaEcx 3,
             LeaEbx 6, AddEax0 5, MovEdiEdi 2
             0 0]
;;

[Alignement: D$ ?
 Alignementlenght: D$ ?]

AlignRecognition:
    Mov B$ItWasAlignment &FALSE
    pushad
      ; esi > UserPe
      ; ebx > RoutingMap . How many Bytes?
        Mov ecx 0
L0:     test B$ebx ACCESSED NOT_ZERO L1>
            inc ecx | inc ebx | cmp ebx D$EndOfRoutingMap | jb L0<

L1:   ; ecx = How many Bytes unaccessed.
        On ecx = 0, jmp L9>>

        Mov D$Alignementlenght ecx

        .If ecx > 0100
            jmp L9>>
        .Else_If ecx > 080
            test ebx 00_1111_1111 NOT_ZERO L9>>
                Mov D$Alignement '0100'
        .Else_If ecx > 040
            test ebx 00_0111_1111 NOT_ZERO L9>>
                Mov D$Alignement '080 '
        .Else_If ecx > 020
            test ebx 00_0011_1111 NOT_ZERO L9>>
                Mov D$Alignement '040 '
        .Else_If ecx > 010
            test ebx 00_0001_1111 NOT_ZERO L9>
                Mov D$Alignement '020 '
        .Else_If ecx > 08
            test ebx 00_1111 NOT_ZERO L9>
                Mov D$Alignement '010 '
        .Else_If ecx > 04
            test ebx 00_0111 NOT_ZERO L9>
                Mov D$Alignement '08  '
        .Else  ; _If ecx > 0
            test ebx 00_0011 NOT_ZERO L9>
                Mov D$Alignement '04  '
        .End_If

        Mov B$ItWasAlignment &TRUE
L9: popad
ret

;;
  Supposed no more use Instructions checking, because, at that stage, if no pointer
  has been found anywhere in the File to this Location, we can suppose this is neither
  Code nor Data, and that, anyway, even if it was not Alignment, this interpretation
  would not change a thing: The rebuilt would be wron,g in any case. So...
;;
L0:     lodsb

        ..If al = 090                   ; nop
            dec ecx | cmp ecx 0 | ja L0<

        ..Else_If al = 0CC              ; int 3
            dec ecx | cmp ecx 0 | ja L0<

        ..Else_If al = 0
            If B$esi = 0                ; add B$eax al >>> 0 0
                inc esi | sub ecx 2 | jc L9>>
                cmp ecx 0 | ja L0<
            End_If
           ; dec esi
           ; While B$esi = 0
           ;     inc esi | dec ecx | jc L9>>
           ; End_While
           ; cmp ecx 0 | ja L0<

        ..Else_If al = 08D              ; lea esp D$esp+00 >>> 8D A4 24 00 00 00 00
            .If D$esi = 024A4
                If W$esi+4 = 0
                    add esi 6 | sub ecx 7 | jc L9>>
                    cmp ecx 0 | ja L0<
                End_If

            .Else_If D$esi = 0B6       ; lea esi D$esi >>> 8D B6 00 00 00 00
                                       ; LeaEsiLong2 --> Guga
                If B$esi+4 = 0
                    add esi 5 | sub ecx 6 | jc L9>>
                    cmp ecx 0 | ja L0<<
                End_If
            .Else_If D$esi = 026B4      ; lea esi D$esi+00 >>> 8D B4 26 00 00 00 00
                If W$esi+4 = 0
                    add esi 6 | sub ecx 7 | jc L9>>
                    cmp ecx 0 | ja L0<<
                End_If
            .Else_If D$esi-1 = 024648D  ; lea esp D$esp+00 >>> 8D 64 24 00
                add esi 3 | sub ecx 4 | jc L9>>
                cmp ecx 0 | ja L0<<
            .Else_If D$esi = 09B        ; lea ebx D$ebx+00 >>> 8D 9B 00 00 00 00
                If B$esi+4 = 0
                    add esi 5 | sub ecx 6 | jc L9>>
                    cmp ecx 0 | ja L0<<
                End_If
            .Else_If W$esi = 049        ; lea ecx D$ecx+00 >>> 8D 49 00
                add esi 2 | sub ecx 3 | jc L9>>
                cmp ecx 0 | ja L0<<
            .Else_If W$esi = 040        ; lea eax D$eax+00 >>> 8D 40 00
                add esi 2 | sub ecx 3 | jc L9>>
                cmp ecx 0 | ja L0<<
            .End_If

        ..Else_If al = 05               ; add eax 0 >>> 05 00 00 00 00
            If D$esi = 0
                add esi 4 | sub ecx 5 | jc L9>>
                cmp ecx 0 | ja L0<<
            End_If

        ..Else_If al = 089              ; Mov esi esi >>> 89 F6
            If B$esi = 0F6
                inc esi | sub ecx 2 | jc L9>>
                cmp ecx 0 | ja L0<<
            End_If

        ..Else_If al = 08B              ; Mov edi edi >>> 8B FF
            If B$esi = 0FF
                inc esi | sub ecx 2 | jc L9>>
                cmp ecx 0 | ja L0<<
            Else_If B$esi = 0C0         ; Mov eax eax >>> 8B C0
                inc esi | sub ecx 2 | jc L9>>
                cmp ecx 0 | ja L0<<
            End_If
        ..End_If

L5:     On ecx = 0, Mov B$ItWasAlignment &TRUE

L9: popad
ret

____________________________________________________________________________________________

;;
  After having analyzed all possible Code, but, before the Negative Recogition,
  if a complete Section holds nothing but Data, we can bet that it is a true
  Data Section, without any Code inside.
  
  Seems to be of little help.
;;


FlagTrueDataSection:
    Mov ecx D$DisNumberOfSections

    GetPeHeader SectionsHeaders

L0: Mov ebx D$eax+SECTION_FLAG | test ebx &IMAGE_SCN_MEM_EXECUTE NOT_ZERO L8>

    ...If ebx = &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
        Push eax, ecx
            Mov esi D$eax+SECTION_RVA | add esi D$SectionsMap
            Mov edx D$eax+SECTION_RVASIZE
            Mov ebx D$eax+SECTION_FILESIZE
            On edx < ebx, xchg edx ebx
            add edx esi | add ebx esi

            Push esi, ebx, edx
                .While esi < ebx
                    .If B$esi <> 0
                        If B$esi = DATAFLAG
                            ; OK.
                        Else_If B$esi = VIRTUALFLAG
                            ; OK.
                        Else
                            Pop eax, eax, eax, ecx, eax | jmp L8>>
                        End_If
                    .End_If

                    inc esi

                .End_While

L5:         Pop edx, ebx, esi

          ; If here, this Section holds nothing but data. Flag it all:
            While esi < ebx
                Mov B$esi DATAFLAG | inc esi
            End_While
            While esi < edx
                Mov B$esi VIRTUALFLAG | inc esi
            End_While

        Pop ecx, eax

    ...End_If

L8: add eax SECTIONHEADERSIZE | dec ecx | jnz L0<<
ret

____________________________________________________________________________________________

DisAlign:
    Mov esi D$SectionsMap | add esi D$FirstSection

    .While esi < D$EndOfSectionsMap
        ...If B$esi = CODEFLAG
            While B$esi = CODEFLAG
                inc esi | On esi >= D$EndOfSectionsMap, ret
            End_While

            ..If B$esi = 0
                Mov ebx esi | inc esi
                While B$esi = 0
                    Mov eax esi | sub eax D$SectionsMap | add eax D$RoutingMap
                    test B$eax LABEL NOT_ZERO L9>
                    inc esi | On esi >= D$EndOfSectionsMap, ret
                End_While

                .If B$esi = CODEFLAG
                    Mov edx esi, ecx edx | sub ecx ebx

                    Push esi, ebx
                        sub ebx D$SectionsMap | add ebx D$RoutingMap
                        Mov esi ebx | sub esi D$RoutingMap | add esi D$UserPeStart
                        Call AlignRecognition
                    Pop ebx, esi

                    If B$ItWasAlignment = &TRUE
                        Mov edi ebx, al CODEFLAG | rep stosb
                    End_If

                .End_If
            ..End_If
        ...End_If

L9:     inc esi
    .End_While
ret
____________________________________________________________________________________________

[NoDirectString: B$ "; No direct Access found to this valid Code Chunk:
    "
 NoDirectStringLength: D$ len]

ReFlagNonaccessed:
    Push esi, ecx
        Mov esi NoDirectString, ecx D$NoDirectStringLength
        sub edi 2 | rep movsb
    Pop ecx, esi

  ; ebx > Start // ecx > End of Chunk that may be forced to ACCESSED, once the
  ; 'NoDirectString' Comment has been written:
    Push edi
        sub ecx ebx | inc ecx | Mov edi ebx, al ACCESSED | rep stosb
    Pop edi
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

[Prefixes: D$ ?]

CommentHexa:
   ; Mov al CR | stosb | Mov al LF | stosb ;;; for Ret and ret n:
    If W$edi-2 = 0A0D
        sub edi 2
    End_If
    Mov al SPC | While edi < D$AlignedComment | stosb | End_While

    Mov D$edi '  ; ' | add edi 4

    Mov ebx D$StartOfDisLine ;| sub ebx D$Prefixes |
    Mov D$Prefixes 0

    While ebx < esi
        movzx eax B$ebx | inc ebx
        Mov ecx eax | shr ecx 4
        and eax 0F | and ecx 0F
        Mov al B$STR.A.Hexa+eax, cl B$STR.A.Hexa+ecx
        shl eax 8 | or eax ecx | or eax 020200000 | stosd | dec edi
    End_While
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; StringsMap jobs

; Example: Call GetStringsMap RoutingMap, esi


____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE VB              ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
;;
  Special case of VB compiled PEs. The first Instructions of a VB PE are:
  
  > Push Vb6Header
  > Call 'MSVBVM50.064'
  
  The VB Header is a Structure that is saved in Code, and that discribes the
  organisation of the File:
  
  [VB6HEADER:|Vbsignature B 4|CompilerVersion W|SzLangDLL B 14|SzSecLangDLL B 14|
  RuntimeDLLVersion W|LanguageID D|BackupLanguageID D|
  >>> SubMain <<< D| >>> ProjectInfo <<< D|
  Flag2 W|Flag3 W|Flag4 D|ThreadSpace B|Const1 B|Flag5 W|Flag6 W|Flag7 W|FormCount W|
  ExternalComponentCount W|Flag8 B|Flag9 B|Flag10 W|DialogStructureGUI D|
  ExternalComponentTable D|Project D|ProjectExename D|ProjectTitle D|HelpFile D|
  ProjectName D|Flag11 D|Flag12 D|Flag13 D|Flag14 W
  
  
  Main Routine: 'MarkVbPe'
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

; VB6HEADER Structure (Displacements Equates):

[VBdis.VbsignatureDis 0
 VBdis.CompilerVersionDis 4
 VBdis.SzLangDLLDis 6
 VBdis.SzSecLangDLLDis 20
 VBdis.RuntimeDLLVersionDis 34
 VBdis.LanguageIDDis 36
 VBdis.BackupLanguageIDDis 40
 VBdis.SubMainDis 44
 VBdis.ProjectInfoDis 48
 VBdis.Flag2Dis 52
 VBdis.Flag3Dis 54
 VBdis.Flag4Dis 56
 VBdis.ThreadSpaceDis 60
 VBdis.Const1Dis 61
 VBdis.Flag5Dis 62
 VBdis.Flag6Dis 64
 VBdis.Flag7Dis 66
 VBdis.FormCountDis 68
 VBdis.ExternalComponentCountDis 70
 VBdis.Flag8Dis 72
 VBdis.Flag9Dis 73
 VBdis.Flag10Dis 74
 VBdis.DialogStructureGUIDis 76
 VBdis.ExternalComponentTableDis 80
 VBdis.ProjectDis 84
 VBdis.ProjectExenameDis 88
 VBdis.ProjectTitleDis 92
 VBdis.HelpFileDis 96
 VBdis.ProjectNameDis 100
 VBdis.Flag11Dis 104
 VBdis.Flag12Dis 108
 VBdis.Flag13Dis 112
 VBdis.Flag14Dis 116
 VB_HEADER_LEN 118]


; For flaging the 'SizesMap':

 [VBsizes:
  @Vbsignature: B$ BYTE+STRINGS #4
  @CompilerVersion: W$ WORD
  @SzLangDLL: B$ BYTE #14
  @SzSecLangDLL: B$ BYTE #14
  @RuntimeDLLVersion: W$ WORD
  @LanguageID: D$ DWORD
  @BackupLanguageID: D$ DWORD
  @SubMain: D$ DWORD
  @ProjectInfo: D$ DWORD
  @Flag2: W$ WORD
  @Flag3: W$ WORD
  @Flag4: D$ DWORD
  @ThreadSpace: B$ BYTE
  @Const1: B$ BYTE
  @Flag5: W$ WORD
  @Flag6: W$ WORD
  @Flag7: W$ WORD
  @FormCount: W$ WORD
  @ExternalComponentCount: W$ WORD
  @Flag8: B$ BYTE
  @Flag9: B$ BYTE
  @Flag10: W$ WORD
  @DialogStructureGUI: D$ DWORD
  @ExternalComponentTable: D$ DWORD
  @Project: D$ DWORD
  @ProjectExename: D$ DWORD
  @ProjectTitle: D$ DWORD
  @HelpFile: D$ DWORD
  @ProjectName: D$ DWORD
  @Flag11: D$ DWORD
  @Flag12: D$ DWORD
  @Flag13: D$ DWORD
  @Flag14: W$ WORD]


; For Flaging the 'RoutingMap':

[VBrouting:
 @Vbsignature: D$ EVOCATED+LABEL
 @CompilerVersion: W$ EVOCATED+LABEL
 @SzLangDLL: B$ 0 #14
 @SzSecLangDLL: B$ 0 #14
 @RuntimeDLLVersion: W$ EVOCATED+LABEL
 @LanguageID: D$ EVOCATED+LABEL
 @BackupLanguageID: D$ EVOCATED+LABEL
 @SubMain: D$ EVOCATED+LABEL+POINTER ; >>> Flag the pointed to Code later
 @ProjectInfo: D$ EVOCATED+LABEL
 @Flag2: W$ EVOCATED+LABEL
 @Flag3: W$ EVOCATED+LABEL
 @Flag4: D$ EVOCATED+LABEL
 @ThreadSpace: B$ EVOCATED+LABEL
 @Const1: B$ EVOCATED+LABEL
 @Flag5: W$ EVOCATED+LABEL
 @Flag6: W$ EVOCATED+LABEL
 @Flag7: W$ EVOCATED+LABEL
 @FormCount: W$ EVOCATED+LABEL
 @ExternalComponentCount: W$ EVOCATED+LABEL
 @Flag8: B$ EVOCATED+LABEL
 @Flag9: B$ EVOCATED+LABEL
 @Flag10: W$ EVOCATED+LABEL
 @DialogStructureGUI: D$ EVOCATED+LABEL+POINTER
 @ExternalComponentTable: D$ EVOCATED+LABEL
 @Project: D$ EVOCATED+LABEL
 @ProjectExename: D$ EVOCATED+LABEL
 @ProjectTitle: D$ EVOCATED+LABEL
 @HelpFile: D$ EVOCATED+LABEL
 @ProjectName: D$ EVOCATED+LABEL
 @Flag11: D$ EVOCATED+LABEL
 @Flag12: D$ EVOCATED+LABEL
 @Flag13: D$ EVOCATED+LABEL
 @Flag14: W$ EVOCATED+LABEL]


; ToDo: Implied SectionsMap Flags. Example, 'SubMain': At the DWORD >>> CODE

____________________________________________________________________________________________
____________________________________________________________________________________________

MarkVbPe:
    Mov eax D$DisEntryPoint | sub eax D$DisImageBase | add eax D$UserPeStart
    Mov esi D$eax+1 | sub esi D$DisImageBase | add esi D$UserPeStart
    On D$esi <> 'VB5!', ret

  ; Mark the VB Header Flags in the Tables. First, the 'SectionsMap' to Data:
    Mov edi esi | sub edi D$UserPeStart | add edi D$SectionsMap
    Mov ecx VB_HEADER_LEN, al DATAFLAG | rep stosb

  ; Routing Map according 'VB6HeaderRouting':
    Mov eax esi | sub eax D$UserPeStart | add eax D$RoutingMap
    Mov B$eax ACCESSED+LABEL
    Push esi
        Mov edi eax,  esi VBrouting, ecx VB_HEADER_LEN | rep movsb
    Pop esi

  ; Sizes Map according 'VB6HeaderSizes':
    sub eax D$RoutingMap | add eax D$SizesMap
    Push esi
        Mov edi eax,  esi VBSizes, ecx VB_HEADER_LEN | rep movsb
    Pop esi

    add esi VBdis.SubMainDis

    Mov eax D$esi | sub eax D$DisImageBase | add eax D$SectionsMap
    If eax < D$SectionsMap
        ; nop (There are VB PEs without any direct Code inside).
    Else_If eax < D$EndOfSectionsMap
        Mov B$eax CODEFLAG
        sub eax D$SectionsMap | add eax D$RoutingMap
        Mov B$eax INSTRUCTION+EVOCATED+LABEL+ACCESSED+PUSH_EBP
    End_If

    add esi VBdis.ProjectInfoDis ; >>> ProjectInfo Data

    Mov eax D$esi | sub eax D$DisImageBase | add eax D$SectionsMap
    If eax < D$SectionsMap
        ; nop (There are VB PEs without any direct Code inside).
    Else_If eax < D$EndOfSectionsMap
        Mov B$eax DATAFLAG
        sub eax D$SectionsMap | add eax D$RoutingMap
        Mov B$eax LABEL+ACCESSED
    End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE DisData         ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
  Write all Data and VirtualData, at once, at the Top of Source.

  3Dfun:
  
  [Data0404040: D$ 0 #03
                 D$ Data0404093]
  [<Data040404D: B$ "@@"]
  [<Data040404F: B$ 0]
  [Data0404050: B$ "Software\Chris Dragan\"]
  
  0408290 non flaged Resources 'IMAGE_RESOURCES_DATA_ENTRY'
;;

;;
; Obsolete
WriteAllDisData:
    Mov esi D$SectionsMap | add esi D$FirstSection
    Mov edx D$EndOfSectionsMap

L0: .While esi < edx
        test B$esi DATAFLAG+VIRTUALFLAG | jz L9>
            Mov cl B$esi
            Mov ebx esi, eax esi
            sub ebx D$SectionsMap | add ebx D$RoutingMap

L1:         inc ebx | inc esi | cmp esi edx | jae L2>
            If B$esi = cl
                test B$ebx LABEL+EVOCATED | jz L1<
            End_If

L2:         sub eax D$SectionsMap | add eax D$SizesMap
            sub ebx D$RoutingMap | add ebx D$SizesMap

            If cl = VIRTUALFLAG
                Call WriteOneVirtualDataChunk, eax, ebx
            Else
                Call WriteOneDataChunk eax, ebx
            End_If

            jmp L0<

L9:     inc esi
    .End_While
ret
;;

Proc WriteOneDataChunksAsFound:
    Argument @Section
    Local @ChunkSize, @Type

      ; Reset the output to the start of Line (first row):
        While B$edi-1 <= SPC | dec edi | End_While
        Mov D$edi CRLF2 | add edi 4

      ; esi points into 'UserPeStart'.

      ; Consider DATA or VIRTUALDATA Flags, in SectionsMap:
        Mov eax D@Section, edx eax, cl B$eax, D@ChunkSize 0, B@Type cl

        While B$edx = cl
            inc edx | inc D@ChunkSize | On edx = D$EndOfSectionsMap, jmp L0>
        End_While
;;
  This 'ChunSize' is the whole size of a 'Chunk'; that may hold several
  Labels, and so forth, several "[Chunk: XXXX]".
  
  'eax:edx' is now the 'Start:End' of the whole 'Chunk', inside 'SectionsMap'.
;;
L0:     .While eax < edx
            Mov ebx eax | sub ebx D$SectionsMap | add ebx D$RoutingMap
            Mov ecx edx | sub ecx D$SectionsMap | add ecx D$RoutingMap

L1:         inc ebx | cmp ebx ecx | jae L2>
            test B$ebx LABEL+EVOCATED ZERO L1<

L2:         sub eax D$SectionsMap | add eax D$SizesMap
            sub ebx D$RoutingMap | add ebx D$SizesMap

          ; Call BuildCommentedDataReference eax ; made by Guga

            Push ebx, edx
                If B@Type = VIRTUALFLAG
                    Call WriteOneVirtualDataChunk, eax, ebx
                Else
                    Call WriteOneDataChunk eax, ebx
                End_If
            Pop edx, eax

            sub eax D$SizesMap | add eax D$SectionsMap
        .End_While

        add esi D@ChunkSize
EndP


[NextDataOutputBreak: D$ ?]
;;
  Here, 'Chunk' stands for 'Chunk from Label to Label'.
;;

[NextDataChunkStart: D$ ?]

; Writes one Data Chunk, in between two 'LABEL+EVOCATED':

Proc WriteOneDataChunk:
    Arguments @SizesmapStart, @SizesmapEnd
    Uses esi, edx

        InitDataLineBreak | Mov B$edi '[' | inc edi

        test D@SizesmapStart 00_11 ZERO L0>
            Mov eax D@SizesmapStart
            If eax = D$NextDataChunkStart
                Mov B$edi '<' | inc edi
            Else
                Mov D$edi '<2 ' | add edi 3
            End_If

L0:     test D@SizesmapStart 00_1111 NOT_ZERO L0>
                Mov D$edi '<16 ' | add edi 4

L0:     Mov eax D@SizesmapStart | sub eax D$SizesMap | add eax D$SectionsMap
        Call WriteOneDataLabel eax

        Mov esi D@SizesmapStart, edx D@SizesmapEnd, cl B$esi
        Mov D$NextDataChunkStart edx

        Mov B$RepetitiveBytesDone &FALSE | Call DisDataTypeRouter

        While B$edi-1 <= SPC | dec edi | End_While
        On B$edi-1 = ',' dec edi

        Mov B$edi ']', W$edi+1 CRLF | add edi 3
EndP


[ActualSizeFlag: D$ ?
 LastSizeFlag: D$ ?
 RealDataChunkEdx: D$ ?]

DisDataTypeRouter:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag

 ; Mov eax esi | sub eax D$SizesMap | add eax D$DisImageBase
 ; On eax = 0403000, int3 ;map

    Mov B$ActualSizeFlag cl, D$RealDataChunkEdx edx

    Call AlignSizeOn ecx

    If edx = esi
        Mov edx D$RealDataChunkEdx
        Mov cl BYTE, B$ActualSizeFlag cl | Call WriteDisBytes | jmp L9>>
    End_If

    On cl = 0, Mov cl BYTE

    .If cl = BYTE
        Mov eax edx | sub eax esi | and eax 00_11
        If eax = 00_10
            Mov cl WORD
        Else_If eax = 00_00
            Mov cl DWORD
        End_If
    .End_If

    .If cl = BYTE
        Call WriteDisBytes
    .Else_If cl = WORD
        Call WriteDisWords
    .Else_If cl = DWORD
        Call WriteDisPointers ; WriteDisdWords
    .Else_If cl = POINTER
        Call WriteDisPointers
    .Else_If cl = POINTER+DWORD
        Call WriteDisPointers
    .Else_If cl = STRINGS+BYTE
        Call WriteDisAscii
    .Else_If cl = STRINGS+WORD
        Call WriteDisUnicode
    .Else_If cl = FP4
        Call WriteDisFP4
    .Else_If cl = FP8
        Call WriteDisFP8
    .Else_If cl = FP10
        Call WriteDisFP10
    .Else_If cl = FP4+POINTER
        Call WriteDisFP4
    .Else_If cl = FP8+POINTER
        Call WriteDisFP8
    .Else_If cl = FP10+POINTER
        Call WriteDisFP10
    .Else_If cl = STRINGS+BYTE+POINTER
        Mov cl STRINGS+BYTE, B$ActualSizeFlag cl
        Call WriteDisAscii
    .Else_If cl = STRINGS+WORD+POINTER
        Mov cl STRINGS+WORD, B$ActualSizeFlag cl
        Call WriteDisUnicode
    .Else_If cl = STRINGS+POINTER
        Mov cl STRINGS+BYTE, B$ActualSizeFlag cl
        Call WriteDisAscii
    .Else
        test cl STRINGS ZERO L1>
            If B$LastSizeFlag = STRINGS+BYTE
                Mov cl STRINGS+BYTE, B$ActualSizeFlag cl | Call WriteDisAscii
            Else_If B$LastSizeFlag = STRINGS+WORD
                Mov cl STRINGS+WORD, B$ActualSizeFlag cl | Call WriteDisUnicode
            Else
                Mov cl STRINGS+BYTE, B$ActualSizeFlag cl | Call WriteDisAscii
            End_If
            jmp L5>>

L1:     Mov eax edx | sub eax esi
        cmp eax 4 | jb L1>
            Call IsPointerCandidate

            If eax = &TRUE
                Mov cl POINTER, B$ActualSizeFlag cl
                Call AlignSizeOn ecx
                Call WriteDisPointers | jmp L5>>
            End_If

L1:   ; edx (end) has been aligned: Unalign:
        Mov edx D$RealDataChunkEdx | Call IsStringCandidate

        If eax = &TRUE
           ; Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
           ; Push esi, edx
                Mov cl STRINGS+BYTE, B$ActualSizeFlag cl | Call WriteDisAscii
           ; Pop edx, esi
           ; Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
        Else
            Mov cl BYTE, B$ActualSizeFlag cl | Call WriteDisBytes
        End_If

    .End_If

  ; Trailing Bytes may remain there because of the above Call to 'AlignSizeOn'. So:
L5: .If esi < D$RealDataChunkEdx
        Mov edx D$RealDataChunkEdx
        Mov W$edi '  ' | add edi 2
        Mov eax edx | sub eax esi
        If eax < 4
            Mov cl BYTE, B$ActualSizeFlag cl | Call WriteDisBytes
        Else
            jmp DisDataTypeRouter
        End_If
    .End_If

L9: Mov cl B$ActualSizeFlag, B$LastSizeFlag cl
ret

[ExportedDataWarning: B$ "
; This Data was an Export, in the original Application.
; RosAsm does not (yet) support such Exports.
" EOS]

Proc WriteOneDataLabel: ; 'WriteDisCodeLabel', 'WriteExportedFunctionLabel'
; called by 'WriteOneDataChunk' and 'WriteOneVirtualDataChunk'
    Argument @SectionsMapPtr

        Mov eax D@SectionsMapPtr | sub eax D$SectionsMap | add eax D$RoutingMap
        Test B$eax EXPORTNODE ZERO L1>  ; 'CheckExport'
            Mov ebx eax, eax D@SectionsMapPtr
            sub eax D$SectionsMap | add eax D$DisImageBase
            Call WriteExportedFunctionLabel

            Push esi | Mov esi ExportedDataWarning | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi

L1:     Mov eax D@SectionsMapPtr

        If B$eax = DATAFLAG
            Mov D$edi 'Data' | add edi 4
        Else_If B$eax = VIRTUALFLAG
            Mov D$edi 'Virt', D$edi+4 'ual' | add edi 7
        End_If

        sub eax D$SectionsMap | add eax D$DisImageBase
        Push eax
            Call WriteEax
        Pop eax

        ToStringsMapFrom DisImageBase,
                         eax


            ; !!! TODO D$eax = 0
            Push esi | Mov esi D$eax | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi



        End_If

        Mov W$edi ': ' | add edi 2
EndP


Proc AlignSizeOn:
    Argument @Unit
    Uses ecx

      ; esi = SizesmapStart, edx = SizesmapEnd
        Mov ecx D@Unit | and ecx (not STRINGS)

        .If cl = POINTER
            Mov ecx 4
        .Else
            and ecx (not POINTER)
            If cl = 0
                Mov ecx BYTE | ExitP
            Else_If cl = BYTE
                ExitP
            Else_If cl = WORD
                Mov ecx 2
            Else_If cl = DWORD
                Mov ecx 4
            Else_If cl = FP4
                Mov ecx 4
            Else_If cl = FP8
                Mov ecx 8
            Else_If cl = FP10
                Mov ecx 10
            End_If
        .End_If

        Mov eax edx | sub eax esi
        Mov edx 0 | div ecx | mul ecx
        Mov edx esi | add edx eax
EndP


[RepetitiveBytesDone: D$ ?
 NumberOfRepetitiveData: D$ ?]

IsRepetitiveBytes:
    If B$RepetitiveBytesDone = &TRUE
        Mov D$NumberOfRepetitiveData 0 | ret
    End_If

    Push esi, ecx, edx
        sub edx D$SizesMap | add edx D$UserPeStart

        Mov esi ebx, al B$esi, ecx 0

        While B$esi = al
            lodsb | inc ecx | cmp esi edx | jae L2>>
        End_While

L2:     If ecx > 1
            Mov D$NumberOfRepetitiveData ecx
        Else
            Mov D$NumberOfRepetitiveData 0
        End_If

    Pop edx, ecx, esi

    Mov B$RepetitiveBytesDone &TRUE
ret


IsRepetitiveWords:
    If B$RepetitiveBytesDone = &TRUE
        Mov D$NumberOfRepetitiveData 0 | ret
    End_If

    Push esi, ecx, edx
        sub edx D$SizesMap | add edx D$UserPeStart

        Mov esi ebx, ax W$esi, ecx 0

        While W$esi = ax
            lodsw | inc ecx | cmp esi edx | jae L2>>
        End_While

L2:     If ecx > 1
            Mov D$NumberOfRepetitiveData ecx
        Else
            Mov D$NumberOfRepetitiveData 0
        End_If

    Pop edx, ecx, esi

    Mov B$RepetitiveBytesDone &TRUE
ret


IsRepetitivedWords:
    If B$RepetitiveBytesDone = &TRUE
        Mov D$NumberOfRepetitiveData 0 | ret
    End_If

    Push esi, ecx, edx
        sub edx D$SizesMap | add edx D$UserPeStart

        Mov esi ebx, eax D$esi, ecx 0

        While D$esi = eax
            lodsd | inc ecx | cmp esi edx | jae L2>>
        End_While

L2:     If ecx > 1
            Mov D$NumberOfRepetitiveData ecx
        Else
            Mov D$NumberOfRepetitiveData 0
        End_If

    Pop edx, ecx, esi

    Mov B$RepetitiveBytesDone &TRUE
ret


WriteDisBytes: ; 'WriteBytesData', 'WriteAsciiData'
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    On B$edi-2 = '$', sub edi 3
    Mov D$edi 'B$ ' | add edi 3

    Mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart

    Call IsRepetitiveBytes

    If D$NumberOfRepetitiveData > 0
        movzx eax B$ebx | Push ebx | Call WriteEax | Pop ebx
        Mov W$edi ' #' | add edi 2
        Mov eax D$NumberOfRepetitiveData | Push ebx | Call WriteEax | Pop ebx
        add esi D$NumberOfRepetitiveData
        add ebx D$NumberOfRepetitiveData | cmp esi edx | jae L9>
        Call NextDisDataLine
    End_If

L0: movzx eax B$ebx | Push ebx | Call WriteEax | Pop ebx

    inc esi | inc ebx | cmp esi edx | jae L9>

        .If B$esi <> 0
            If B$esi <> cl
                Call NextDisDataLine
                Mov cl B$esi | ret
            End_If
        .End_If

        If edi > D$NextDataOutputBreak
            Call NextDisDataLine
        Else_If esi < edx
            Mov D$edi ', ' | add edi 2
        End_If

    jmp L0<
L9: ret


WriteDisWords:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
   On B$edi-2 = '$', sub edi 3
    Mov D$edi 'W$ ' | add edi 3

    Mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart

    Call IsRepetitiveWords

    If D$NumberOfRepetitiveData > 0
        movzx eax W$ebx | Push ebx | Call WriteEax | Pop ebx
        Mov W$edi ' #' | add edi 2
        Mov eax D$NumberOfRepetitiveData | Push ebx | Call WriteEax | Pop ebx
        Mov eax D$NumberOfRepetitiveData | shl eax 1
        add esi eax | add ebx eax | cmp esi edx | jae L9>
        Call NextDisDataLine
    End_If

L0: Mov eax edx | sub eax esi
    If eax < 2
        Mov cl BYTE | ret
    End_If

    movzx eax W$ebx | Push ebx | Call WriteEax | Pop ebx

    add esi 2 | add ebx 2 | cmp esi edx | jae L9>

        .If B$esi <> 0
            If B$esi <> cl
                Call NextDisDataLine
                Mov cl B$esi | ret
            End_If
        .End_If

        If edi > D$NextDataOutputBreak
            Call NextDisDataLine
        Else_If esi < edx
            Mov D$edi ', ' | add edi 2
        End_If

    jmp L0<
L9: ret


[WasValidPointer: D$ ?]

WriteDisPointers:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    On B$edi-2 = '$', sub edi 3
    Mov D$edi 'D$ ' | add edi 3

    Mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart

L0: Mov eax edx | sub eax esi
    If eax < 4
        Mov cl BYTE | ret
    End_If

    Mov eax D$ebx

    ;sub eax D$DisImageBase | add eax D$RoutingMap
    ;test B$eax LABEL | jz WriteDisdWords
    ;Mov eax D$ebx
;;
  This case of zeroed POINTERs should be turned DWORDs, in 'CheckFlagsCoherency'
;;
    .If eax = 0
        Call IsRepetitivedWords

        If D$NumberOfRepetitiveData > 0
            Mov eax D$ebx | Push ebx | Call WriteEax | Pop ebx
            Mov W$edi ' #' | add edi 2
            Mov eax D$NumberOfRepetitiveData | Push ebx | Call WriteEax | Pop ebx
            Mov eax D$NumberOfRepetitiveData | shl eax 2
            add esi eax | add ebx eax | cmp esi edx | jae L9>>
            Call NextDisDataLine | jmp L0<
        End_If

    .End_If

    Mov B$RepetitiveBytesDone &TRUE

    Push eax
        sub eax D$DisImageBase | add eax D$SectionsMap
        ..If eax > D$SectionsMap
            .If eax < D$EndOfSectionsMap
                sub eax D$SectionsMap | add eax D$RoutingMap
                test B$eax LABEL+INSTRUCTION+EVOCATED ZERO L2>
L1:             sub eax D$RoutingMap | add eax D$SectionsMap
                If B$eax = CODEFLAG
                    sub eax D$SectionsMap | add eax D$RoutingMap
                    test B$eax LABEL+INSTRUCTION ZERO L2>
                    Mov D$edi 'Code' | add edi 4
                Else_If B$eax = DATAFLAG
                    Mov D$edi 'Data' | add edi 4
                Else_If B$eax = VIRTUALFLAG
                    Mov D$edi 'Virt', D$edi+4 'ual' | add edi 7
                End_If
            .End_If
        ..End_If
L2: Pop eax

    .If D$edi-4 = 'tual'
        Mov B$WasValidPointer &TRUE
    .Else_If D$edi-4 = 'Data'
        Mov B$WasValidPointer &TRUE
    .Else_If D$edi-4 = 'Code'
        Mov B$WasValidPointer &TRUE
    .Else
        Mov B$WasValidPointer &FALSE
        Push eax
            Mov edx D$RealDataChunkEdx | Call IsStringCandidate
            If eax = &TRUE
                Pop eax
                Mov cl STRINGS+BYTE, B$ActualSizeFlag cl | Call WriteDisAscii | ret
            End_If
        Pop eax
    .End_If

    Push ebx, eax | Call WriteEax | Pop eax, ebx

    ..If B$WasValidPointer = &TRUE
        ToStringsMapFrom DisImageBase, eax
        .If D$eax <> 0
            Push esi
                If D$eax = MainWindowProcName
                    While D$edi <> 'Code' | dec edi | End_While
                End_If

                Mov esi D$eax | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0:

            Pop esi
        .End_If
    ..End_If

    add esi 4 | add ebx 4 | cmp esi edx | jae L9>

        .If B$esi <> 0
            If B$esi <> cl
                Call NextDisDataLine
                Mov cl B$esi | ret
            End_If
        .End_If

        If edi > D$NextDataOutputBreak
            Call NextDisDataLine
        Else_If esi < edx
            Mov D$edi ', ' | add edi 2
        End_If

    jmp L0<<
L9: ret


[InsideQuotes: D$ ?]

WriteDisAscii: ; 'WriteAsciiData'
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    Mov B$RepetitiveBytesDone &TRUE
    On B$edi-2 = '$', sub edi 3
    Mov D$edi 'B$ ' | add edi 3
    Mov B$InsideQuotes &FALSE

    Mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart

L0: movzx eax B$ebx
;On D$ebx = '3D F', int3
    Push ebx
        Mov ebx D$TruthAsciiTable

        ...If B$ebx+eax = GOODASCII
;;
  Isolated cases of 13 or 10 might be miss-interpretated as part of a CRLF:
;;
            If al = CR
                Pop ebx | Push ebx
                On B$ebx <> LF, jmp L2>
            Else_If al = LF
                Pop ebx | Push ebx
                On B$esi-2 <> CR, jmp L2>
            End_If

            On al = '"', jmp L2>

            If B$InsideQuotes = &FALSE
                Mov B$edi '"' | inc edi
                Mov B$InsideQuotes &TRUE
            End_If
            stosb

        ...Else
L2:         If B$InsideQuotes = &TRUE
                Mov B$edi '"' | inc edi
                Mov B$InsideQuotes &FALSE
            End_If
            .If W$edi-2 <> ', '
                If W$edi-3 <> 'B$'
                    Mov W$edi ', ' | add edi 2
                End_If
            .End_If
            Call WriteEax
            inc esi
            ..If esi < edx
                .If W$edi-2 <> ', '
                    If W$edi-3 <> 'B$'
                        Mov D$edi ', ' | add edi 2
                    End_If
                .End_If
            ..End_If
            dec esi
        ...End_If
    Pop ebx

    inc esi | inc ebx | cmp esi edx | jae L9>

        ..If B$esi <> 0
            .If B$esi <> cl
                If B$InsideQuotes = &TRUE
                    Mov B$edi '"' | inc edi
                    Mov B$InsideQuotes &FALSE
                End_If
                Call NextDisDataLine
                Mov cl B$esi | ret
            .End_If
        ..End_If

        jmp L0<<

L9: If B$InsideQuotes = &TRUE
        Mov B$edi '"' | inc edi
        Mov B$InsideQuotes &FALSE
    End_If
ret


WriteDisUnicode:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    Mov B$RepetitiveBytesDone &TRUE
    On B$edi-2 = '$', sub edi 3
    Mov D$edi 'U$ ' | add edi 3
    Mov B$InsideQuotes &FALSE

    Mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart

L0: movzx eax B$ebx

    Push ebx, ecx
        Mov ecx ebx, ebx D$TruthAsciiTable
        ..If B$ebx+eax = GOODASCII
            On al = '"', jmp L2>
            If al = CR
                On B$ecx+2 <> LF, jmp L2>
            Else_If al = LF
                On B$ecx-2 <> CR, jmp L2>
            End_If
            If B$InsideQuotes = &FALSE
                Mov B$edi '"' | inc edi
                Mov B$InsideQuotes &TRUE
            End_If
            stosb
        ..Else
L2:         If B$InsideQuotes = &TRUE
                Mov B$edi '"' | inc edi
                Mov B$InsideQuotes &FALSE
            End_If
            .If W$edi-2 <> ', '
                If W$edi-3 <> 'U$'
                    Mov W$edi ', ' | add edi 2
                End_If
            .End_If
            Call WriteEax
            inc esi
            .If esi < edx
                .If W$edi-2 <> ', '
                    If W$edi-3 <> 'U$'
                        Mov W$edi ', ' | add edi 2
                    End_If
                .End_If
            .End_If
            dec esi
        ..End_If
    Pop ecx, ebx

    add esi 2 | add ebx 2 | cmp esi edx | jae L9>

        ..If B$esi <> 0
            .If B$esi <> cl
                If B$InsideQuotes = &TRUE
                    Mov B$edi '"' | inc edi
                    Mov B$InsideQuotes &FALSE
                End_If
                Call NextDisDataLine
                Mov cl B$esi | ret
            .End_If
        ..End_If

        jmp L0<<

L9: If B$InsideQuotes = &TRUE
        Mov B$edi '"' | inc edi
        Mov B$InsideQuotes &FALSE
    End_If
ret


WriteDisFP4: ; WriteDisdWords
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    On B$edi-2 = '$', sub edi 3

L0: Mov eax edx | sub eax esi
    If eax < 4
        Mov cl BYTE | ret
    End_If

    Push esi, edx
        Mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart
        Call WriteFP4
    Pop edx, esi

    add esi 4

    .If B$esi <> 0
        If B$esi <> cl
            Call NextDisDataLine
            Mov cl B$esi | ret
        End_If
    .End_If

    .If esi < edx
        If edi > D$NextDataOutputBreak
            Call NextDisDataLine
        Else_If esi < edx
            Mov D$edi ', ' | add edi 2
        End_If

        jmp L0<
    .End_If

    Mov B$RepetitiveBytesDone &TRUE
ret


WriteDisFP8:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    On B$edi-2 = '$', sub edi 3

L0: Mov eax edx | sub eax esi
    If eax < 8
        Mov cl BYTE | ret
    End_If

    Push esi, edx
        Mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart
        Call WriteFP8
    Pop edx, esi

    add esi 8

    .If B$esi <> 0
        If B$esi <> cl
            Call NextDisDataLine
            Mov cl B$esi | ret
        End_If
    .End_If

    .If esi < edx
        If edi > D$NextDataOutputBreak
            Call NextDisDataLine
        Else_If esi < edx
            Mov D$edi ', ' | add edi 2
        End_If

        jmp L0<
    .End_If

    Mov B$RepetitiveBytesDone &TRUE
ret


WriteDisFP10:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    On B$edi-2 = '$', sub edi 3

L0: Mov eax edx | sub eax esi
    If eax < 10
        Mov cl BYTE | ret
    End_If

    Push esi, edx
        Mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart
        Call WriteFP10
    Pop edx, esi

    add esi 10

    .If B$esi <> 0
        If B$esi <> cl
            Call NextDisDataLine
            Mov cl B$esi | ret
        End_If
    .End_If

    .If esi < edx
        If edi > D$NextDataOutputBreak
            Call NextDisDataLine
        Else_If esi < edx
            Mov D$edi ', ' | add edi 2
        End_If

        jmp L0<
    .End_If

    Mov B$RepetitiveBytesDone &TRUE
ret


NextDisDataLine:
    InitDataLineBreak
    Mov D$edi 020200A0D, D$edi+4 '    ', D$edi+8 '    ', D$edi+12 '    ', D$edi+16 '    '
    add edi 19
ret

[InitDataLineBreak | Mov D$NextDataOutputBreak edi | add D$NextDataOutputBreak 70]


IsPointerCandidate:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    Push ecx, esi
        Mov ecx edx | sub ecx esi | shr ecx 2

        sub esi D$Sizesmap | add esi D$Routingmap

L0:     test B$esi INDIRECT ZERO L1>
            Mov eax esi
            sub eax D$Routingmap | add eax D$UserPeStart
            Mov eax D$eax
            sub eax D$DisImageBase | add eax D$RoutingMap

            If eax < D$Routingmap
                ;
            Else_If eax < D$EndOfRoutingMap
                test B$eax LABEL ZERO L1>
                    Mov eax &TRUE | jmp L9>
            End_If

L1:         add esi 4 | loop L0<

            Mov eax &FALSE
L9: Pop esi, ecx
ret


IsStringCandidate:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    Push esi, ecx, edx
L0:     Mov ecx edx | sub ecx esi
        sub esi D$Sizesmap | add esi D$UserPeStart | On B$esi = 0, jmp L8>

        Mov eax 0, edx D$TruthAsciiTable
L0:     lodsb | On B$edx+eax = GOODASCII, loop L0<
        jecxz L9>

L1:         If al = 0
                lodsb | loop L1<
                jecxz L9>
            Else_If B$edx+eax = GOODASCII
                jecxz L9>
                loop L0<
            End_If

L8:     Mov eax &FALSE
    Pop edx, ecx, esi
ret

L9:     Mov eax &TRUE
    Pop edx, ecx, esi
ret
____________________________________________________________________________________________

Proc WriteOneVirtualDataChunk:
    Arguments @SizesmapStart, @SizesmapEnd
    Uses esi, edx

        InitDataLineBreak | Mov B$edi '[' | inc edi

        test D@SizesmapStart 00_11 ZERO L0>
            Mov B$edi '<' | inc edi

L0:     Mov eax D@SizesmapStart | sub eax D$SizesMap | add eax D$SectionsMap
        Call WriteOneDataLabel eax

        Mov esi D@SizesmapStart, ecx D@SizesmapEnd | sub ecx esi

        ..If ecx = 1
            Mov D$edi 'B$ ?' | add edi 4
        ..Else_If ecx = 2
            Mov D$edi 'W$ ?' | add edi 4
        ..Else_If ecx = 4
            If B$esi = FP4
                Mov D$edi 'F$ ?'
            Else
                Mov D$edi 'D$ ?'
            End_If
            add edi 4
        ..Else
        ; LOOPVDATAMAX
L1:         Mov eax ecx | and eax 0011
            .If eax = 0
                If B$esi = FP4
                    Mov D$edi 'F$ ?'
                Else
                    Mov D$edi 'D$ ?'
                End_If
                Mov W$edi+4 ' #'  | add edi 6
                Mov eax ecx | shr eax 2
                On eax > LOOPVDATAMAX, Mov eax LOOPVDATAMAX
                Call WriteEax
            .Else
                Mov D$edi 'B$ ?', W$edi+4 ' #'  | add edi 6
                Mov eax ecx | On eax > LOOPVDATAMAX, Mov eax LOOPVDATAMAX
                Call WriteEax
            .End_If
        ..End_If
        Mov B$edi ']' | inc edi

      ; Case of set sizes > RosAsm Max, split into as many sub-sets as wanted:
        If ecx > LOOPVDATAMAX
            sub ecx LOOPVDATAMAX | NextDisLine
            Push esi
                Mov esi edi
                While B$esi <> '[' | dec esi | End_While
                While B$esi <> ':' | movsb | End_While
                Mov B$edi 'X' | inc edi
                While B$esi <> '$' | movsb | End_While | dec edi
            Pop esi
            jmp L1<<
        End_If

        Mov D$edi CRLF2 | add edi 4
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE DisEngine       ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

; This is the only one Table used in the Disassembler.
; Table of Pointers to each primary Opcode computation Routine:

[DisOp1:
 Op00 Op01 Op02 Op03 Op04 Op05 Op06 Op07 Op08 Op09 Op0A Op0B Op0C Op0D Op0E Op0F
 Op10 Op11 Op12 Op13 Op14 Op15 Op16 Op17 Op18 Op19 Op1A Op1B Op1C Op1D Op1E Op1F
 Op20 Op21 Op22 Op23 Op24 Op25 Op26 Op27 Op28 Op29 Op2A Op2B Op2C Op2D Op2E Op2F
 Op30 Op31 Op32 Op33 Op34 Op35 Op36 Op37 Op38 Op39 Op3A Op3B Op3C Op3D Op3E Op3F
 Op40 Op41 Op42 Op43 Op44 Op45 Op46 Op47 Op48 Op49 Op4A Op4B Op4C Op4D Op4E Op4F
 Op50 Op51 Op52 Op53 Op54 Op55 Op56 Op57 Op58 Op59 Op5A Op5B Op5C Op5D Op5E Op5F
 Op60 Op61 Op62 Op63 Op64 Op65 Op66 Op67 Op68 Op69 Op6A Op6B Op6C Op6D Op6E Op6F
 Op70 Op71 Op72 Op73 Op74 Op75 Op76 Op77 Op78 Op79 Op7A Op7B Op7C Op7D Op7E Op7F
 Op80 Op81 Op82 Op83 Op84 Op85 Op86 Op87 Op88 Op89 Op8A Op8B Op8C Op8D Op8E Op8F
 Op90 Op91 Op92 Op93 Op94 Op95 Op96 Op97 Op98 Op99 Op9A Op9B Op9C Op9D Op9E Op9F
 OpA0 OpA1 OpA2 OpA3 OpA4 OpA5 OpA6 OpA7 OpA8 OpA9 OpAA OpAB OpAC OpAD OpAE OpAF
 OpB0 OpB1 OpB2 OpB3 OpB4 OpB5 OpB6 OpB7 OpB8 OpB9 OpBA OpBB OpBC OpBD OpBE OpBF
 OpC0 OpC1 OpC2 OpC3 OpC4 OpC5 OpC6 OpC7 OpC8 OpC9 OpCA OpCB OpCC OpCD OpCE OpCF
 OpD0 OpD1 OpD2 OpD3 OpD4 OpD5 OpD6 OpD7 OpD8 OpD9 OpDA OpDB OpDC OpDD OpDE OpDF
 OpE0 OpE1 OpE2 OpE3 OpE4 OpE5 OpE6 OpE7 OpE8 OpE9 OpEA OpEB OpEC OpED OpEE OpEF
 OpF0 OpF1 OpF2 OpF3 OpF4 OpF5 OpF6 OpF7 OpF8 OpF9 OpFA OpFB OpFC OpFD OpFE OpFF]

[AMDassumed: &FALSE]
;;
  Prefixes: Op0F (EscapePrefix) , Op66 (OperandSizeOverride), Op67 (AddressSizeOverride)
;;


; Jcc Prefixes (02E / 03E) implemented as UTJ LTJ (Unlikely / Likely Taken Jump).
; Op2E > UTJ // Op3E > LTJ Followed by Jcc / (+JECXz ???).

;;
  Bad TD Files:

  115, impossible: Trick with create Window STATIC + Resource Name !!!!
  170, Menu? + Does not show the BitMaps (???...). Hang
  710, Strings IDs? BitMaps?

  810, Tricky (Auto-Write ?) Code (not Writeable in [Output].

* The Short Jumps Sizes adjustements do not seem to work (TD 170 example).
* Menu IDs replacement to be implemented.
* Some detail os wrong in the Menus until they be reloaded and resaved by the Menu Editor...
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

; 256 Routines for the primary Opcodes:
____________________________________________________________________________________________
____________________________________________________________________________________________

Op00:
    On D$esi-5 = 0, add D$UnLikelyCode 4
    On D$esi-1 = 0, add D$UnLikelyCode 1 ; ???...

; This hangs here, because a valid "add reg8 reg8" is found somewhere and
; produces something wrong in the Sections recognitions...
;
; To be analyzed on Calc.exe:
;
; RoutingMap differences with or without this added 'UnLikelyCode', in order
; to understand the failure point of the Recogitions...

   ; Push eax
   ;     Mov eax esi | add eax 7
   ;     If eax < D$UserPeEnd
   ;        ; On D$esi = 0,
;           add D$UnLikelyCode 1
   ;     End_If
   ; Pop eax

    .If B$EscapePrefix = &FALSE           ; add r/m8 r8
        Mov B$LockPrefix &FALSE
        Mov D$edi 'add ' | add edi 4 | jmp Dis_rm8_r8

    .Else
        Mov bl B$esi | inc esi | DigitMask bl To al

        If al = 0       ; 0F 00 /0 SLDT r/m16 ; 0F 00 /0 SLDT r/m32
            Mov D$edi 'sldt', B$edi+4 SPC | add edi 5 | jmp Dis_rm32_rm16
        Else_If al = 1  ; 0F 00 /1 STR r/m16
            Mov D$edi 'str ' | add edi 4
        Else_If al = 2  ; 0F 00 /2 LLDT r/m16
            Mov D$edi 'lldt', B$edi+4 SPC | add edi 5
        Else_If al = 3  ; 0F 00 /3 > LTR r/m16
            Mov D$edi 'ltr ' | add edi 4 | jmp EndWith.W.mem
        Else_If al = 4  ; 0F 00 /4 VERR r/m16
            Mov D$edi 'verr', B$edi+4 SPC | add edi 5 ; VERW
        Else_If al = 5  ; 0F 00 /5 VERW r/m16
            Mov D$edi 'verw', B$edi+4 SPC | add edi 5
        Else
            dec esi | ret
        End_If
        inc D$UnLikelyCode
        jmp EndWith.W.mem
    .End_If


Op01:
    ..If B$EscapePrefix = &FALSE
        Mov B$LockPrefix &FALSE
        Mov D$edi 'add ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16
        inc D$LikelyCode

    ..Else_If W$esi = 0C801 ; 0F,01,C8 MONITOR
        inc D$LikelyCode
        add esi 2
        Mov D$edi 'moni', D$edi+4 'tor ' | add edi 8
        Mov B$DisFlag DISDONE+DISLINEOVER | ret

    ..Else_If W$esi = 0C901 ; 0F,01,C9 MWAIT
        inc D$LikelyCode
        add esi 2
        Mov D$edi 'mwai', D$edi+4 't ' | add edi 6
        Mov B$DisFlag DISDONE+DISLINEOVER | ret

    ..Else
        Mov bl B$esi | inc esi | DigitMask bl To al
        inc D$UnLikelyCode

        .If al = 0          ; 0F 01 /0 SGDT m
            Mov D$edi 'sgdt', B$edi+4 SPC | add edi 5 | jmp EndWith.X.mem
        .Else_If al = 1     ; 0F 01 /1 SIDT m
            Mov D$edi 'sidt', B$edi+4 SPC | add edi 5 | jmp EndWith.X.mem
        .Else_If al = 2     ; LGDT m16&32
            Mov D$edi 'lgdt', B$edi+4 SPC | add edi 5 | jmp EndWith.X.mem
        .Else_If al = 3     ; LIDT m16&32
            Mov D$edi 'lidt', B$edi+4 SPC | add edi 5 | jmp EndWith.X.mem
        .Else_If al = 4     ; 0F 01 /4 SMSW r/m16 ; 0F 01 /4 SMSW r32/m16
            Mov D$edi 'smsw', B$edi+4 SPC | add edi 5 | jmp Dis_rm32_rm16
        .Else_If al = 6     ; LMSW r/m16
            Mov D$edi 'lmsw', B$edi+4 SPC | add edi 5 | jmp EndWith.W.mem
        .Else_If al = 7     ; INVLPG m
            Mov D$edi 'invl', D$edi+4 'pg  ' | add edi 7 | jmp EndWith.X.mem
        .Else
            dec esi | ret
        .End_If
    ..End_If


Op02:
    If B$EscapePrefix = &FALSE
        Mov B$LockPrefix &FALSE
        Mov D$edi 'add ' | add edi 4 | jmp Dis_r8_rm8
    Else       ; LAR r16,r/m16
        Mov D$edi 'lar ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16
    End_If


Op03:
    If B$EscapePrefix = &FALSE
        Mov D$edi 'add '
    Else     ; LSL r32,r/m32 ; LSL r16,r/m16
        Mov D$edi 'lsl '
        inc D$UnLikelyCode
    End_If
    add edi 4 | jmp Dis_r32_r16__rm32_rm16


Op04: ; add al imm8
    If D$esi-1 = 4
        inc D$UnlikelyCode
    Else
        inc D$LikelyCode
    End_If
    Mov D$edi 'add ' | add edi 4 | jmp Dis_al_imm8


Op05: ; add eax/ax imm32/imm16
    Mov D$edi 'add ' | add edi 4 | jmp Dis_eax_ax__imm32_imm16


Op06: ; clts
    inc D$UnLikelyCode
    If B$EscapePrefix = &TRUE
        Mov D$edi 'clts' | add edi 4 | Mov B$DisFlag DISDONE+DISLINEOVER
    Else        ; 06 Push ES
        Mov D$edi 'Push', D$edi+4 ' es ' | add edi 7 | Mov B$DisFlag DISDONE+DISLINEOVER
    End_If
ret


Op07: ; 07 Pop ES
    inc D$UnLikelyCode
    Mov D$edi 'Pop ', W$edi+4 'es' | add edi 6 | Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op08:
    If B$EscapePrefix = &FALSE        ; OR r/m8,r8
        inc D$LikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'or  ' | add edi 3 | jmp Dis_rm8_r8
    Else     ; INVD
        inc D$UnLikelyCode
        Mov D$edi 'invd' | add edi 4 | Mov B$DisFlag DISDONE+DISLINEOVER
    End_If
ret


Op09:
    If B$EscapePrefix = &FALSE    ; OR r/m16,r16 // OR r/m32,r32
        inc D$LikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'or  ' | add edi 3 | jmp Dis_rm32_rm16__r32_r16
    Else    ; 0F 09 WBINVD
        inc D$UnLikelyCode
        Mov D$edi 'wbin', D$edi+4 'vd  ' | add edi 6
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op0A: ; OR r8,r/m8
    inc D$LikelyCode
    Mov B$LockPrefix &FALSE
    Mov D$edi 'or  ' | add edi 3 | jmp Dis_r8_rm8


Op0B:
    If B$EscapePrefix = &FALSE    ; OR r32,r/m32 // OR r16,r/m16
        inc D$LikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'or  ' | add edi 3 | jmp Dis_r32_r16__rm32_rm16
    Else    ; 0F 0B UD2
        inc D$UnLikelyCode
        Mov D$edi 'ud2 ' | add edi 3
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op0C: ; OR AL,imm8
    inc D$LikelyCode
    Mov D$edi 'or  ' | add edi 3 | jmp Dis_al_imm8


Op0D: ; OR AX,imm16 ; OR EAX,imm32
    .If B$AMDassumed = &TRUE
         If B$EscapePrefix = &TRUE ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Looki
            Mov D$edi 'PREF', D$edi+4 'ETCH', W$edi+8 'W ' | add edi 10
            jmp Dis_rm8
        End_If
    .End_If
    inc D$LikelyCode
    Mov D$edi 'or  ' | add edi 3 | jmp Dis_eax_ax__imm32_imm16


Op0E: ; 0E Push CS
    .If B$AMDassumed = &TRUE
        If B$EscapePrefix = &TRUE ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Looki
            Mov D$edi 'FEMM', B$edi+4 'S' | add edi 5
            Mov B$DisFlag DISDONE+DISLINEOVER
            ret
        End_If
    .End_If

    inc D$UnLikelyCode
    Mov D$edi 'Push', D$edi+4 ' cs ' | add edi 7
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op0F:
    ...If B$AMDassumed = &TRUE
        ..If B$EscapePrefix = &TRUE ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<< new
            .If B$esi+1 = 0AE ; 0F 0F xx 0AE - PFACC
                Mov D$edi 'PFAC', W$edi+4 'C ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 09E ; 0F 0F xx 09E - PFADD
                Mov D$edi 'PFAD', W$edi+4 'D ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 09A ; 0F 0F xx 09A - PFSUB
                Mov D$edi 'PFSU', W$edi+4 'B ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 0B4 ; 0F 0F xx 0B4 - PFMUL
                Mov D$edi 'PFMU', W$edi+4 'L ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 096 ; 0F 0F xx 096 - PFRCP
                Mov D$edi 'PFRC', W$edi+4 'P ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 097 ; 0F 0F xx 097 - PFRSQRT <<<<<< until here all are common
                Mov D$edi 'PFRS', D$edi+4 'QRT ' | add edi 8
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 0BF ; 0F 0F xx 0BF - PAVGUSB
                Mov D$edi 'PAVG', D$edi+4 'USB ' | add edi 8
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 01D ; 0F 0F xx 01D - PF2ID
                Mov D$edi 'PF2I', W$edi+4 'D ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 090 ; 0F 0F xx 090 - PFCMPGE
                Mov D$edi 'PFCM', D$edi+4 'PGE ' | add edi 8
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 0A0 ; 0F 0F xx 0A0 - PFCMPGT
                Mov D$edi 'PFCM', D$edi+4 'PGT ' | add edi 8
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 0B0 ; 0F 0F xx 0B0 - PFCMPEQ
                Mov D$edi 'PFCM', D$edi+4 'PEQ ' | add edi 8
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 094 ; 0F 0F xx 094 - PFMIN
                Mov D$edi 'PFMI', W$edi+4 'N ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 0A4 ; 0F 0F xx 0A4 - PFMAX
                Mov D$edi 'PFMA', W$edi+4 'X ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 0A6 ; 0F 0F xx 0A6 - PFRCPIT1
                Mov D$edi 'PFRC', D$edi+4 'PIT1', B$edi+8 SPC | add edi 9
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 0A7 ; 0F 0F xx 0A7 - PFRSQIT1
                Mov D$edi 'PFRS', D$edi+4 'QIT1', B$edi+8 SPC | add edi 9
                jmp Dis_mmx1__mmx2_m64_v2
    ;
            .Else_If B$esi+1 = 0B6 ; 0F 0F xx 0B6 - PFRCPIT2
                Mov D$edi 'PFRC', D$edi+4 'PIT2', B$edi+8 SPC | add edi 9
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 0AA ; 0F 0F xx 0AA - PFSUBR
                Mov D$edi 'PFSU', W$edi+4 'BR', B$edi+6 SPC | add edi 7 ; ??????
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 0D ; 0F 0F xx 0D - PI2FD
                Mov D$edi 'PI2F', W$edi+4 'D ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 0B7 ; 0F 0F xx 0B7 - PMULHRW
                Mov D$edi 'PMUL', D$edi+4 'HRW ' | add edi 8
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 0C ; 0F 0F xx 0C - PI2FW*
                Mov D$edi 'PI2F', W$edi+4 'W ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 01C ; 0F 0F xx 01C - PF2IW*
                Mov D$edi 'PF2I', W$edi+4 'W ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 08E ; 0F 0F xx 08E - PFPNACC*
                Mov D$edi 'PFPN', D$edi+4 'ACC ' | add edi 8
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 08A ; 0F 0F xx 08A - PFNACC*
                Mov D$edi 'PFNA', W$edi+4 'CC', B$edi+6 SPC | add edi 7 ; ??????
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 0BB ; 0F 0F xx 0BB - PSWAPD*
                Mov D$edi 'PSWA', W$edi+4 'PD', B$edi+6 SPC | add edi 7 ; ??????
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 086 ; 0F 0F xx 086 - PFRCPV**
                Mov D$edi 'PFRC', W$edi+4 'PV', B$edi+6 SPC | add edi 7 ; ??????
                jmp Dis_mmx1__mmx2_m64_v2
            .Else_If B$esi+1 = 087 ; 0F 0F xx 087 - PFRSQRTV**
                Mov D$edi 'PFRS', D$edi+4 'QRTV', B$edi+8 SPC | add edi 9
    ;* Enhanced 3DNow! or Extended 3DNow! or 3DNow!+ (Athlon/XP+-Doc[22466.pdf])
    ;** 3DNow! Professional or 3DNow! Pro (Geode LX/GX)
            .Else
                inc D$UnLikelyCode
            .End_If
        ..End_If
    ...End_If

    On B$EscapePrefix = &TRUE, inc D$UnLikelyCode
    Mov B$EscapePrefix &TRUE, B$DisFlag DISDONE
    inc D$Prefixes
ret


Op10:
    .If B$EscapePrefix = &FALSE            ; adc r/m8 m8
        inc D$LikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'adc ' | add edi 4 | jmp Dis_rm8_m8

    .Else
        ;inc D$UnLikelyCode
        Mov D$edi 'movu'
        If B$OperandSizeOverride = &TRUE   ; 66 0F 10 /r MOVUPD xmm1, xmm2/m128
            Call MarkSSEdata SSE_2_R
            Mov D$edi+4 'pd  '
        Else       ; 0F 10 /r MOVUPS xmm1, xmm2/m128
            Call MarkSSEdata SSE_4_F
            Mov D$edi+4 'ps  '
        End_If
        add edi 7 | jmp Dis_xmm1__xmm2_m128

    .End_If


Op11:
    .If B$EscapePrefix = &FALSE         ; adc r/m32//r/m16 r32/r16
        inc D$LikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'adc ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16

    .Else
        ;inc D$UnLikelyCode
        Mov D$edi 'movu'
        If B$OperandSizeOverride = &TRUE   ; 66 0F 11 /r MOVUPD xmm2/m128, xmm
            Call MarkSSEdata SSE_2_R
            Mov D$edi+4 'pd  '
        Else       ; 0F 11 /r MOVUPS xmm2/m128, xmm1
            Call MarkSSEdata SSE_4_F
            Mov D$edi+4 'ps  '
        End_If
        add edi 7 | jmp Dis_xmm2_m128__xmm1

    .End_If


Op12:
    ..If B$EscapePrefix = &TRUE
       ; inc D$UnLikelyCode
        .If B$OperandSizeOverride = &TRUE        ; 66 0F 12 /r MOVLPD xmm, m64
            Call MarkSSEdata SSE_1_R
            Mov bl B$esi | inc esi
            Mov D$edi 'movl', D$edi+4 'ps  ' | add edi 7 | jmp Dis_xmm_m64
        .Else        ; OF 12 /r MOVHLPS xmm1, xmm2 // 0F 12 /r MOVLPS xmm, m64
            Mov bl B$esi | inc esi | ModMask bl to al

            If al = 3
                Mov D$edi 'movh', D$edi+4 'lps ' | add edi 8
                jmp Dis_xmm1_xmm2
            Else
                dec esi | Call MarkSSEdata SSE_2_F | inc esi
                Mov D$edi 'movl', D$edi+4 'ps  ' | add edi 7
                jmp Dis_xmm_m64
            Else
                inc D$UnLikelyCode | dec esi | ret
            End_If
        .End_If

    ..Else    ; adc r8 r/m8
        inc D$LikelyCode
        Mov D$edi 'adc ' | add edi 4 | jmp Dis_r8_rm8

    ..End_If


Op13:
    .If B$EscapePrefix = &TRUE
       ; inc D$UnLikelyCode
        Mov D$edi 'movl'
        If B$OperandSizeOverride = &TRUE        ; 66 0F 13 /r MOVLPD m64, xmm
            Call MarkSSEdata SSE_1_R
            Mov D$edi+4 'pd  '
        Else    ; 0F 13 /r MOVLPS m64, xmm
            Call MarkSSEdata SSE_2_F
            Mov D$edi+4 'ps  '
        End_If
        add edi 7 | Mov bl B$esi | inc esi | jmp Dis_m64_xmm

    .Else       ; adc r32/r16 r/m32//r/m16
        inc D$LikelyCode
        Mov D$edi 'adc ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16

    .End_If


Op14:
    .If B$EscapePrefix = &TRUE
       ; inc D$UnLikelyCode
        Mov D$edi 'unpc'
        If B$OperandSizeOverride = &TRUE    ; 66 0F 14 /r UNPCKLPD xmm1, xmm2/m128
            Call MarkSSEdata SSE_2_R
            Mov D$edi+4 'klpd'
        Else        ; 0F 14 /r UNPCKLPS xmm1, xmm2/m128
            Call MarkSSEdata SSE_4_F
            Mov D$edi+4 'klps'
        End_If
        Mov B$edi+8 SPC | add edi 9 | jmp Dis_xmm1__xmm2_m128

    .Else ; adc al imm8
        inc D$LikelyCode
        Mov D$edi 'adc ' | add edi 4 | jmp Dis_al_imm8

    .End_If
ret


Op15:
    .If B$EscapePrefix = &TRUE
       ; inc D$UnLikelyCode
        Mov D$edi 'unpc'
        If B$OperandSizeOverride = &TRUE    ; 66 0F 15 /r UNPCKHPD xmm1, xmm2/m128
            Call MarkSSEdata SSE_2_R
            Mov D$edi+4 'khpd'
        Else        ; 0F 15 /r UNPCKHPS xmm1, xmm2/m128
            Call MarkSSEdata SSE_4_F
            Mov D$edi+4 'khps'
        End_If
        Mov B$edi+8 SPC | add edi 9 | jmp Dis_xmm1__xmm2_m128

    .Else   ; adc eax/ax imm32/imm16
        inc D$LikelyCode
        Mov D$edi 'adc ' | add edi 4 | jmp Dis_eax_ax__imm32_imm16

    .End_If


Op16:

    ..If B$EscapePrefix = &TRUE
        .If B$OperandSizeOverride = &TRUE    ; 66 0F 16 /r MOVHPD xmm, m64
            Call MarkSSEdata SSE_1_R
            Mov bl B$esi | inc esi
            Mov D$edi 'movh', D$edi+4 'pd  ' | add edi 7 | jmp Dis_xmm_m64

        .Else            ; 0F 16 /r MOVHPS xmm, m64 // OF 16 /r MOVLHPS xmm1, xmm2
            Mov bl B$esi | inc esi | ModMask bl to al

            If al = 3
                Mov D$edi 'movl', D$edi+4 'hps ' | add edi 8
                jmp Dis_xmm1_xmm2
            Else
                dec esi | Call MarkSSEdata SSE_2_F | inc esi
                Mov D$edi 'movh', D$edi+4 'ps  ' | add edi 7
                jmp Dis_xmm_m64
            Else
                inc D$UnLikelyCode | dec esi | ret
            End_If
        .End_If

    ..Else  ; 16 Push SS
        Mov D$edi 'Push', D$edi+4 ' ss ' | add edi 7

    ..End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op17:
    .If B$EscapePrefix = &TRUE
        Mov D$edi 'movh'
        If B$OperandSizeOverride = &TRUE    ; 66 0F 17 /r MOVHPD m64, xmm
            Call MarkSSEdata SSE_1_R
            Mov D$edi+4 'pd  '
        Else            ; 0F 17 /r MOVHPS m64, xmm
            Call MarkSSEdata SSE_2_F
            Mov D$edi+4 'ps  '
        End_If
        add edi 7 | Mov bl B$esi | inc esi | jmp Dis_m64_xmm

    .Else       ; 17 Pop SS
        inc D$UnLikelyCode
        Mov D$edi 'Pop ', W$edi+4 'ss' | add edi 6

    .End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op18:
    .If B$EscapePrefix = &TRUE

        Mov D$edi 'pref', D$edi+4 'etch' | add edi 8
        Mov bl B$esi | inc esi | DigitMask bl to al

        If al = 0           ; 0F 18 /0 PREFETCHNTA m8
            Mov D$edi 'nta ' | add edi 4
        Else_If al = 1      ; 0F 18 /1 PREFETCHT1 m8
            Mov D$edi 't0  ' | add edi 3
        Else_If al = 2      ; 0F 18 /1 PREFETCHT2 m8
            Mov D$edi 't1  ' | add edi 3
        Else_If al = 3      ; 0F 18 /1 PREFETCHT3 m8
            Mov D$edi 't2  ' | add edi 3
        Else
            inc D$UnLikelyCode | dec esi | ret
        End_If
        jmp EndWith.B.mem

    .Else       ; 18 /r SBB r/m8,r8
        inc D$LikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'sbb ' | add edi 4 | jmp Dis_rm8_r8

    .End_If


Op19: ; 19 /r SBB r/m16,r16 ; 19 /r SBB r/m32,r32
    inc D$LikelyCode
    Mov B$LockPrefix &FALSE
    Mov D$edi 'sbb ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16


Op1A: ; 1A /r SBB r8,r/m8
    inc D$LikelyCode
    Mov D$edi 'sbb ' | add edi 4 | jmp Dis_r8_rm8


Op1B: ; 1B /r SBB r16,r/m16 ; 1B /r SBB r32,r/m32
    inc D$LikelyCode
    Mov D$edi 'sbb ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16


Op1C: ; 1C ib SBB AL,imm8
    inc D$LikelyCode
    Mov D$edi 'sbb ' | add edi 4 | jmp Dis_al_imm8


Op1D: ; 1D iw SBB AX,imm16  ; 1D id SBB EAX,imm32
    inc D$LikelyCode
    Mov D$edi 'sbb ' | add edi 4 | jmp Dis_eax_ax__imm32_imm16


Op1E:   ; 1E Push DS
    inc D$UnLikelyCode
    Mov D$edi 'Push', D$edi+4 ' ds ' | add edi 7
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op1F: ; 1F Pop DS
    inc D$UnLikelyCode
    Mov D$edi 'Pop ', W$edi+4 'ds' | add edi 6
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op20:
    If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'and ' | add edi 4 | jmp Dis_rm8_r8

    Else        ; Mov r32,CR0 // CR1...
        inc D$UnLikelyCode
        Mov bl B$esi | inc esi | BaseMask bl to al | and eax 0FF
        Mov D$edi 'Mov ' | add edi 4
        Move D$edi D$dWordRegsTable+eax*4 | add edi 4
        Mov D$edi 'CR0 ' | DigitMask bl To al | add B$edi+2 al | add edi 3
        Mov B$DisFlag DISDONE+DISLINEOVER

    End_If
ret


Op21:
    If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'and ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16

    Else        ; Mov r32, DR0-DR7
        inc D$UnLikelyCode
        Mov bl B$esi | inc esi | BaseMask bl to al | and eax 0FF
        Mov D$edi 'Mov ' | add edi 4
        Move D$edi D$dWordRegsTable+eax*4 | add edi 4
        Mov D$edi 'DR0 ' | DigitMask bl To al | add B$edi+2 al | add edi 3
        Mov B$DisFlag DISDONE+DISLINEOVER

    End_If
ret


Op22:
    If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        Mov D$edi 'and ' | add edi 4 | jmp Dis_r8_rm8

    Else        ; Mov CR0,r32 // CR1...
        inc D$UnLikelyCode
        Mov bl B$esi | inc esi | DigitMask bl To al
        Mov D$edi 'Mov ', D$edi+4 'CR0 '
        add B$edi+6 al | add edi 8
        BaseMask bl to al | and eax 0FF
        Move D$edi D$dWordRegsTable+eax*4 | add edi 3
        Mov B$DisFlag DISDONE+DISLINEOVER

    End_If
ret


Op23:
    If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        Mov D$edi 'and ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16

    Else        ; Mov DR0-DR7,r32
        inc D$UnLikelyCode
        Mov bl B$esi | inc esi | DigitMask bl To al
        Mov D$edi 'Mov ', D$edi+4 'DR0 '
        add B$edi+6 al | add edi 8
        BaseMask bl to al | and eax 0FF
        Move D$edi D$dWordRegsTable+eax*4 | add edi 3
        Mov B$DisFlag DISDONE+DISLINEOVER

    End_If
ret


Op24: ; and al imm8
    inc D$LikelyCode
    Mov D$edi 'and ' | add edi 4 | jmp Dis_al_imm8


Op25: ; 25 iw AND AX,imm16 ; 25 id AND EAX,imm32
    inc D$LikelyCode
    Mov D$edi 'and ' | add edi 4 | jmp Dis_eax_ax__imm32_imm16


Op26:
    inc D$UnLikelyCode
    inc D$Prefixes
    Mov D$SegmentOverride 'es: ', B$DisFlag DISDONE
ret


Op27: ; DAA
    inc D$LikelyCode
    Mov D$edi 'daa ' | add edi 3 | Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op28: ; 66 0F 28 /r > MOVAPD xmm1, xmm2/m128
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        Mov D$edi 'mova'
        If B$OperandSizeOverride = &TRUE
            Call MarkSSEdata SSE_2_R
            Mov D$edi+4 'pd  '
        Else        ; 0F 28 /r MOVAPS xmm1, xmm2/m128
            Call MarkSSEdata SSE_4_F
            Mov D$edi+4 'ps  '
        End_If
        add edi 7 | jmp Dis_xmm1__mmx2_m128

    .Else   ; 28 /r SUB r/m8,r8
        inc D$LikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'sub ' | add edi 4 | jmp Dis_rm8_r8

    .End_If


Op29:   ; 66 0F 29 /r MOVAPD xmm2/m128, xmm1
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        Mov D$edi 'mova'
        If B$OperandSizeOverride = &TRUE
            Call MarkSSEdata SSE_2_R
            Mov D$edi+4 'pd  '
        Else        ; 0F 29 /r MOVAPS xmm2/m128, xmm1
            Call MarkSSEdata SSE_4_F
            Mov D$edi+4 'ps  '
        End_If
        add edi 7 | jmp Dis_mmx2_m128__xmm1

    .Else   ; 29 /r SUB r/m16,r16 ; 29 /r SUB r/m32,r32
        inc D$LikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'sub ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16

    .End_If


Op2A:
    .If B$EscapePrefix = &TRUE
       ; inc D$UnLikelyCode
        Mov D$edi 'cvtp'
        If B$OperandSizeOverride = &TRUE  ; ; CVTPI2PD xmm, mm/m64
            Call MarkSSEdata SSE_2_D
            Mov D$edi+4 'i2pd'
        Else                                ; CVTPI2PS xmm, mm/m64
            Call MarkSSEdata SSE_2_D
            Mov D$edi 'cvtp', D$edi+4 'i2ps'
        End_If
        Mov B$edi+8 SPC | add edi 9 | jmp Dis_xmm1__mmx2_m64

    .Else       ; 2A /r SUB r8,r/m8
        inc D$LikelyCode
        Mov D$edi 'sub ' | add edi 4 | jmp Dis_r8_rm8

    .End_If


Op2B:
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        Mov D$edi 'movn'
        If B$OperandSizeOverride = &TRUE        ; 66 0F 2B /r MOVNTPD m128, xmm
            Call MarkSSEdata SSE_2_R
            Mov D$edi+4 'tpd '
        Else        ; 0F 2B /r MOVNTPS m128, xmm
            Call MarkSSEdata SSE_4_F
            Mov D$edi+4 'tps '
        End_If
        add edi 8 | Mov bl B$esi | inc esi | jmp Dis_m128_xmm

    .Else   ; 2B /r SUB r16,r/m16 ; 2B /r SUB r32,r/m32
        inc D$LikelyCode
        Mov D$edi 'sub ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16

    .End_If


Op2C: ; CVTTPD2PI mm, xmm/m128
    .If B$EscapePrefix = &TRUE
       ; inc D$UnLikelyCode
        Mov D$edi 'cvtt'
        If B$OperandSizeOverride = &TRUE    ; CVTTPD2PI mm, xmm/m128
            Call MarkSSEdata SSE_2_R
            Mov D$edi+4 'pd2p', W$edi+8 'i ' | add edi 10
            jmp Dis_mmx1__xmm2_m128
        Else  ; CVTTPS2PI mm, xmm/m64
            Call MarkSSEdata SSE_2_F
            Mov D$edi 'cvtt', D$edi+4 'ps2p', W$edi+8 'i ' | add edi 10
            jmp Dis_mmx1__xmm2_m64
        End_If

    .Else       ; 2C ib SUB AL,imm8
        If D$esi-1 = 02C
            inc D$UnlikelyCode
        Else
            inc D$LikelyCode
        End_If
        Mov D$edi 'sub ' | add edi 4 | jmp Dis_al_imm8

    .End_If


Op2D:
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        Mov D$edi 'cvtp'
        If B$OperandSizeOverride = &TRUE    ; CVTPD2PI mm, xmm/m128
            Call MarkSSEdata SSE_2_R
            Mov D$edi+4 'd2pi', B$edi+8 SPC | add edi 9
            jmp Dis_mmx1__xmm2_m128
        Else                                ; CVTPS2PI mm, xmm/m64
            Call MarkSSEdata SSE_2_F
            Mov D$edi+4 's2pi', B$edi+8 SPC | add edi 9
            jmp Dis_mmx1__xmm2_m64
        End_If

    .Else       ; 2D iw SUB AX,imm16 ; 2D id SUB EAX,imm32
        inc D$LikelyCode
        Mov D$edi 'sub ' | add edi 4 | jmp Dis_eax_ax__imm32_imm16

    .End_If


; Unikely Taken Jump: This is a Mnemonic non defined by Intel, which purpose is to
; reverse the Jump Prediction. UTJ / LTJ have been defined in collaboration with
; the NASM developers group. UTJ / LTJ are prefixes to Jcc Instructions. I have no
; info about if it is active or not before JECXZ. As i think it can't hurt, i allow
; it in RosAsm assembling.

Op2E:
    ;inc D$UnLikelyCode
    .If B$EscapePrefix = &TRUE
        Mov D$edi 'ucom'
        If B$OperandSizeOverride = &TRUE    ; 66 0F 2E /r UCOMISD xmm1, xmm2/m64
            Call MarkSSEdata SSE_2_R
            Mov D$edi+4 'isd ' | add edi 8 | jmp Dis_xmm1__xmm2_m64
        Else    ; 0F 2E /r UCOMISS xmm1, xmm2/m32
            Call MarkSSEdata SSE_4_F
            Mov D$edi+4 'iss ' | add edi 8 | jmp Dis_xmm1__xmm2_m32
        End_If

    .Else
        ; UTJ if Jcc:
        ;      op70 71 72 73 74 75 76 77 Op78 79 7A 7B 7C 7D 7E 7F  E3 (E3 is JCXZ JECXZ...)
        ; Of / 80 81 82 83 84 85 86 86 88 89 8A 8B 8C 8D 8E 8F
        Mov al B$esi
        .If al = 0F
            Mov al B$esi+1
            cmp al 080 | jb L5>
                cmp al 08F | ja L5>
                    inc esi | Mov B$EscapePrefix &TRUE | jmp L3>

        .Else
            cmp al 0E3 | je L3>
                cmp al 070 | jb L5>
                    cmp al 07F | ja L5>
L3:                     Mov D$edi 'utj ' | add edi 4
                            movzx eax B$esi
                            inc esi | Call D$DisOp1+eax*4
                        Mov B$DisFlag DISDONE+DISLINEOVER | ret

        .End_If

L5:     Mov D$SegmentOverride 'cs: '
        inc D$Prefixes
      ; Watcom-C incodes the Api calls in the form of Call D$cs:apiname:
        If W$esi <> 015FF
            inc D$UnLikelyCode
        Else
            Mov eax D$esi+2
            sub eax D$DisImageBase | add eax D$UserPeStart | Mov eax D$eax
            On eax < D$ApiBuffer, inc D$UnLikelyCode
            On eax >= D$EndOfApiBuffer, inc D$UnLikelyCode
        End_If

    .End_If

L9: Mov B$DisFlag DISDONE
ret


Op2F:
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        Mov D$edi 'comi'
        If B$OperandSizeOverride = &TRUE
            Call MarkSSEdata SSE_1_R
            Mov D$edi+4 'sd  ' | add edi 7
            jmp Dis_xmm1__xmm2_m64     ; COMISD xmm1, xmm2/m64
        Else
            Call MarkSSEdata SSE_1_F
            Mov D$edi+4 'ss  ' | add edi 7
            jmp Dis_xmm1__xmm2_m32     ; COMISS xmm1, xmm2/m32
        End_If

    .Else ; DAS
        inc D$LikelyCode
        Mov D$edi 'das ' | add edi 3 | Mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op30:
    If B$EscapePrefix = &FALSE  ; 30 /r XOR r/m8,r8
        inc D$LikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'xor ' | add edi 4 | jmp Dis_rm8_r8
    Else         ; 0F 30 WRMSR
        inc D$UnLikelyCode
        Mov D$edi 'wrms', B$edi+4 'r' | add edi 5
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op31: ; 0F 31 RDTSC
    If B$EscapePrefix = &FALSE  ; 31 /r XOR r/m16,r16 ; 31 /r XOR r/m32,r32
        inc D$LikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'xor ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16
    Else
        ;inc D$UnLikelyCode
        Mov D$edi 'rdts', B$edi+4 'c' | add edi 5  ; rdtsc
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op32:
    If B$EscapePrefix = &FALSE  ; 32 /r XOR r8,r/m8
        inc D$LikelyCode
        Mov D$edi 'xor ' | add edi 4 | jmp Dis_r8_rm8
    Else     ; 0F 32 RDMSR
        ;inc D$UnLikelyCode
        Mov D$edi 'rdms', B$edi+4 'r' | add edi 5
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op33:
    If B$EscapePrefix = &FALSE; 33 /r XOR r16,r/m16 ; 33 /r XOR r32,r/m32
        inc D$LikelyCode
        Mov D$edi 'xor ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16
    Else        ; 0F 33 RDPMC
        ;inc D$UnLikelyCode
        Mov D$edi 'rdpm', B$edi+4 'c' | add edi 5
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op34:
    If B$EscapePrefix = &FALSE        ; 34 ib XOR AL,imm8
        inc D$LikelyCode
        Mov D$edi 'xor ' | add edi 4 | jmp Dis_al_imm8
    Else         ; 0F 34 SYSENTER
        inc D$UnLikelyCode
        Mov D$edi 'syse', D$edi+4 'nter' | add edi 8
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op35:
    If B$EscapePrefix = &FALSE        ; 35 iw XOR AX,imm16 ; 35 id XOR EAX,imm32
        inc D$LikelyCode
        Mov D$edi 'xor ' | add edi 4 | jmp Dis_eax_ax__imm32_imm16
    Else             ; 0F 35 SYSEXIT
        inc D$UnLikelyCode
        Mov D$edi 'syse', D$edi+4 'xit ' | add edi 7
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op36:
    inc D$UnLikelyCode
    inc D$Prefixes
    Mov D$SegmentOverride 'ss: ', B$DisFlag DISDONE
ret


Op37: ; aaa
    inc D$LikelyCode
    Mov D$edi 'aaa ', B$DisFlag DISDONE+DISLINEOVER | add edi 3
ret


Op38: ; CMP rm8 r8
    inc D$LikelyCode
    Mov D$edi 'cmp ' | add edi 4 | jmp Dis_rm8_r8
ret


Op39: ; cmp rm32/rm16 r32/r16
    inc D$LikelyCode
    Mov D$edi 'cmp ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16
ret


Op3A: ; CMP r8 rm8

    inc D$LikelyCode
    Mov D$edi 'cmp ' | add edi 4 | jmp Dis_r8_rm8
ret


Op3B: ; r32/r16 cmp rm32/rm16
    inc D$LikelyCode
    Mov D$edi 'cmp ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16
ret


Op3C: ; cmp al imm8
    inc D$LikelyCode
    Mov D$edi 'cmp ' | add edi 4 | jmp Dis_al_imm8


Op3D: ; cmp eax // ax,  imm32 // imm16
    inc D$LikelyCode
    Mov D$edi 'cmp ' | add edi 4 | jmp Dis_eax_ax__imm32_imm16


; Likely Taken Jump: This is a Mnemonic non defined by Intel, which purpose is to
; reverse the Jump Prediction. UTJ / LTJ have been defined in collaboration with
; the NASM developers group. UTJ / LTJ are prefixes to Jcc Instructions. I have no
; info about if it is active or not before JECXZ. As i think it can't hurt, i allow
; it in RosAsm assembling.

Op3E: ; Op2E for UTJ

    ; LTJ if Jcc:
  ;      70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F E3
  ; Of / 80 81 82 83 84 85 86 86 88 89 8A 8B 8C 8D 8E 8F

    Mov al B$esi
        .If al = 0F
            Mov al B$esi+1
            cmp al 080 | jb L5>
                cmp al 08F | ja L5>
                    inc esi | Mov B$EscapePrefix &TRUE | jmp L3>

        .Else
            cmp al 0E3 | je L3>
                cmp al 070 | jb L5>
                    cmp al 07F | ja L5>
L3:                     Mov D$edi 'ltj ' | add edi 4
                        Push edi
                            movzx eax B$esi
                            inc esi | add edi 5 | Call D$DisOp1+eax*4
                        Pop eax
                        Mov B$eax SPC | Mov B$DisFlag DISDONE+DISLINEOVER | ret

        .End_If

L5: Mov D$SegmentOverride 'ds: '
    inc D$Prefixes
    inc D$UnLikelyCode

L9: Mov B$DisFlag DISDONE
ret


Op3F: ; aas
    inc D$LikelyCode
    Mov D$edi 'aas ', B$DisFlag DISDONE+DISLINEOVER | add edi 4
ret


Op40: ; cmovo
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        Mov D$edi 'cmov', W$edi+4 'o ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16

    .Else
        inc D$LikelyCode
        Mov D$edi 'inc ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            Mov B$edi 'e' | inc edi
        End_If
        Mov W$edi 'ax' | add edi 2 | Mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op41: ; cmovno
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        Mov D$edi 'cmov', D$edi+4 'no  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16

    .Else
        Mov D$edi 'inc ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov B$edi 'e' | inc edi
        End_If
        Mov W$edi 'cx' | add edi 2 | Mov B$DisFlag DISDONE+DISLINEOVER
    .End_If
ret


Op42: ; cmovb / cmovc / cmovnae
    .If B$EscapePrefix = &TRUE
        Mov D$edi 'cmov', W$edi+4 'c ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16

    .Else
        Mov D$edi 'inc ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov B$edi 'e' | inc edi
        End_If
        Mov W$edi 'dx' | add edi 2 | Mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op43: ; cmovae / cmovnb / cmovnc
    .If B$EscapePrefix = &TRUE
        Mov D$edi 'cmov', D$edi+4 'ae  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16

    .Else
        Mov D$edi 'inc ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov B$edi 'e' | inc edi
        End_If
        Mov W$edi 'bx' | add edi 2 | Mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op44: ; cmove / cmovz
    .If B$EscapePrefix = &TRUE
        Mov D$edi 'cmov', W$edi+4 'e ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16

    .Else
        Mov D$edi 'inc ' | add edi 4
        inc D$UnLikelyCode
        If B$OperandSizeOverride = &FALSE
            Mov B$edi 'e' | inc edi
        End_If
        Mov W$edi 'sp' | add edi 2 | Mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op45: ; cmovne / cmonnz
    .If B$EscapePrefix = &TRUE
        Mov D$edi 'cmov', D$edi+4 'ne  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16

    .Else
        Mov D$edi 'inc ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov B$edi 'e' | inc edi
        End_If
        Mov W$edi 'bp' | add edi 2 | Mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op46: ; cmovbe : cmovna
    .If B$EscapePrefix = &TRUE
        Mov D$edi 'cmov', D$edi+4 'be  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16

    .Else
        Mov D$edi 'inc ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov B$edi 'e' | inc edi
        End_If
        Mov W$edi 'si' | add edi 2 | Mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op47: ; cmova / cmovnbe
    .If B$EscapePrefix = &TRUE
        Mov D$edi 'cmov', W$edi+4 'a ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16

    .Else
        Mov D$edi 'inc ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov B$edi 'e' | inc edi
        End_If
        Mov W$edi 'di' | add edi 2 | Mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op48: ; cmovs
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'dec ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov B$edi 'e' | inc edi
        End_If
        Mov  W$edi 'ax' | add edi 2 | Mov B$DisFlag DISDONE+DISLINEOVER
    .Else
        Mov D$edi 'cmov', W$edi+4 's ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16
    .End_If
ret


Op49: ; cmovns
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'dec ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov B$edi 'e' | inc edi
        End_If
        Mov  W$edi 'cx' | add edi 2 | Mov B$DisFlag DISDONE+DISLINEOVER
    .Else
        Mov D$edi 'cmov', D$edi+4 'ns  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16
    .End_If
ret


Op4A: ; cmovp / cmovpe
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'dec ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov B$edi 'e' | inc edi
        End_If
        Mov  W$edi 'dx' | add edi 2 | Mov B$DisFlag DISDONE+DISLINEOVER
    .Else
        Mov D$edi 'cmov', W$edi+4 'p ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16
    .End_If
ret


Op4B: ; cmovnp / cmovpo
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'dec ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov B$edi 'e' | inc edi
        End_If
        Mov  W$edi 'bx' | add edi 2 | Mov B$DisFlag DISDONE+DISLINEOVER
    .Else
        Mov D$edi 'cmov', D$edi+4 'np  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16
    .End_If
ret


Op4C: ; cmovl / cmovnge
    If B$EscapePrefix = &FALSE
        inc D$UnLikelyCode
        Mov D$edi 'dec ', D$edi+4 'esp ' | add edi 7 | Mov B$DisFlag DISDONE+DISLINEOVER
    Else
        Mov D$edi 'cmov', W$edi+4 'l ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16
    End_If
ret


Op4D: ; cmovge / cmovnl
    If B$EscapePrefix = &FALSE
        Mov D$edi 'dec ', D$edi+4 'ebp ' | add edi 7 | Mov B$DisFlag DISDONE+DISLINEOVER
    Else
        Mov D$edi 'cmov', D$edi+4 'ge  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16
    End_If
ret


Op4E: ; cmovle / cmovng
    If B$EscapePrefix = &FALSE
        Mov D$edi 'dec ', D$edi+4 'esi ' | add edi 7 | Mov B$DisFlag DISDONE+DISLINEOVER
    Else
        Mov D$edi 'cmov', D$edi+4 'le  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16
    End_If
ret


Op4F: ; cmovg / cmovnle
    If B$EscapePrefix = &FALSE
        Mov D$edi 'dec ', D$edi+4 'edi ' | add edi 7 | Mov B$DisFlag DISDONE+DISLINEOVER
    Else
        Mov D$edi 'cmov', W$edi+4 'g ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16
    End_If
ret


Op50:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov D$edi ' eax' | add edi 4
        Else
           ; inc D$UnLikelyCode
            Mov D$edi ' ax ' | add edi 3
        End_If

     .Else
        ;inc D$UnLikelyCode
        Mov D$edi 'movm'
        If B$OperandSizeOverride = &TRUE ; 66 0F 50 /r MOVMSKPD r32, xmm
            Mov D$edi+4 'skpd'
        Else            ; 0F 50 /r MOVMSKPS r32, xmm
            Mov D$edi+4 'skps'
        End_If
        Mov B$edi+8 SPC | add edi 9 | jmp Dis_r32_xmm

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op51:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov D$edi ' ecx' | add edi 4
        Else
            ;inc D$UnLikelyCode
            Mov D$edi ' cx ' | add edi 3
        End_If

    .Else
       ; inc D$UnLikelyCode
        Mov D$edi 'sqrt'
        If B$OperandSizeOverride = &TRUE   ; 66 0F 51 /r SQRTPD xmm1, xmm2/m128
            Call MarkSSEdata SSE_2_R
            Mov D$edi+4 'pd  '
        Else        ; 0F 51 /r SQRTPS xmm1, xmm2/m128
            Call MarkSSEdata SSE_4_F
            Mov D$edi+4 'ps  '
        End_If
        add edi 7 | jmp Dis_xmm1__xmm2_m128

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op52:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov D$edi ' edx' | add edi 4
        Else
            ;inc D$UnLikelyCode
            Mov D$edi ' dx ' | add edi 3
        End_If

    .Else   ; 0F 52 /r RSQRTPS xmm1, xmm2/m128
        Call MarkSSEdata SSE_4_F
        Mov D$edi 'rsqr', D$edi+4 'tps ' | add edi 8 | jmp Dis_xmm1__xmm2_m128

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op53:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov D$edi ' ebx' | add edi 4
        Else
           ; inc D$UnLikelyCode
            Mov D$edi ' bx ' | add edi 3
        End_If

    .Else  ; 0F 53 /r RCPPS xmm1, xmm2/m128
        Call MarkSSEdata SSE_4_F
        Mov D$edi 'rcpp', W$edi+4 's ' | add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op54:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            Mov D$edi ' esp' | add edi 4
        Else
            inc D$UnlikelyCode
            Mov D$edi ' sp ' | add edi 3
        End_If

    .Else
        Mov D$edi 'andp' | add edi 4
        If B$OperandSizeOverride = &TRUE                ; 066 0F 054 ...
            Call MarkSSEdata SSE_2_R    ; ANDPD 66 0F 54 /r
            Mov W$edi 'd '
        Else
            Call MarkSSEdata SSE_4_F
            Mov W$edi 's '              ; ANDPS 0F 54 /r
        End_If
        add edi 2 | jmp Dis_xmm1__xmm2_m128

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op55:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov D$edi ' ebp' | add edi 4
        Else
            inc D$UnLikelyCode
            Mov D$edi ' bp ' | add edi 3
        End_If

    .Else
        ;inc D$UnLikelyCode
        Mov D$edi 'andn' | add edi 4
        If B$OperandSizeOverride = &TRUE
            Call MarkSSEdata SSE_2_R
            Mov D$edi 'pd  '    ; ANDNPD 66 0F 55 /r
        Else
            Call MarkSSEdata SSE_4_F
            Mov D$edi 'ps  '    ; ANDNPS 0F 55 /r
        End_If
        add edi 3 | jmp Dis_xmm1__xmm2_m128

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op56:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov D$edi ' esi' | add edi 4
        Else
            inc D$UnLikelyCode
            Mov D$edi ' si ' | add edi 3
        End_If

    .Else
        ;inc D$UnLikelyCode
        If B$OperandSizeOverride = &TRUE    ; ORPD xmm1, xmm2/m128
            Call MarkSSEdata SSE_2_R
            Mov D$edi 'orpd'
        Else        ; ORPS xmm1, xmm2/m128
            Call MarkSSEdata SSE_4_F
            Mov D$edi 'orps'
        End_If
        Mov B$edi+4 SPC | add edi 5 | jmp Dis_xmm1__xmm2_m128

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op57:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov D$edi ' edi' | add edi 4
        Else
            inc D$UnLikelyCode
            Mov D$edi ' di ' | add edi 3
        End_If

    .Else
        ;inc D$UnLikelyCode
        Mov D$edi 'xorp'
        If B$OperandSizeOverride = &TRUE  ; 66 0F 57 /r XORPD xmm1, xmm2/m128
            Call MarkSSEdata SSE_2_R
            Mov W$edi+4 'd '
        Else        ; 0F 57 /r XORPS xmm1, xmm2/m128
            Call MarkSSEdata SSE_4_F
            Mov W$edi+4 's '
        End_If
        add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op58:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov D$edi 'eax ' | add edi 3
        Else
           ; inc D$UnLikelyCode
            Mov W$edi 'ax' | add edi 2
        End_If

    .Else
        ;inc D$UnLikelyCode
        Mov D$edi 'addp'
        If B$OperandSizeOverride = &TRUE       ; 066 0F 058...
            Call MarkSSEdata SSE_2_R
            Mov W$edi+4 'd '                   ; ADDPD
        Else
            Call MarkSSEdata SSE_4_F
            Mov W$edi+4 's '                   ; ADDPS
        End_If
        add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op59:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov D$edi 'ecx ' | add edi 3
        Else
           ; inc D$UnLikelyCode
            Mov D$edi 'cx' | add edi 2
        End_If

    .Else
        ;inc D$UnLikelyCode
        Mov D$edi 'mulp'
        If B$OperandSizeOverride = &TRUE        ; 66 0F 59 /r MULPD xmm1, xmm2/m128
            Call MarkSSEdata SSE_2_R
            Mov W$edi+4 'd '
        Else        ; 0F 59 /r MULPS xmm1, xmm2/m128
            Call MarkSSEdata SSE_4_F
            Mov W$edi+4 's '
        End_If
        add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op5A:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov D$edi 'edx ' | add edi 3
        Else
           ; inc D$UnLikelyCode
            Mov W$edi 'dx' | add edi 2
        End_If

    .Else
        ;inc D$UnLikelyCode
        Mov D$edi 'cvtp'
        If B$OperandSizeOverride = &TRUE    ; CVTPD2PS xmm1, xmm2/m128
            Call MarkSSEdata SSE_2_R
            Mov D$edi+4 'd2ps', B$edi+8 SPC | add edi 9 | jmp Dis_xmm1__xmm2_m128
        Else                                ; CVTPS2PD xmm1, xmm2/m64
            Call MarkSSEdata SSE_2_F
            Mov D$edi+4 's2pd', B$edi+8 SPC | add edi 9 | jmp Dis_xmm1__xmm2_m64
        End_If

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op5B:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov D$edi 'ebx ' | add edi 3
        Else
           ; inc D$UnLikelyCode
            Mov W$edi 'bx' | add edi 2
        End_If

    .Else
        ;inc D$UnLikelyCode

        If B$OperandSizeOverride = &TRUE ; CVTPS2DQ xmm1, xmm2/m128
            Call MarkSSEdata SSE_4_F
            Mov D$edi 'cvtp', D$edi+4 's2dq'
        Else                             ; CVTDQ2PS xmm1, xmm2/m128
            Call MarkSSEdata SSE_4_D
            Mov D$edi 'cvtd', D$edi+4 'q2ps'
        End_If
        Mov B$edi+8 SPC | add edi 9 | jmp Dis_xmm1__xmm2_m128

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op5C:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            Mov D$edi 'esp ' | add edi 3
        Else
            inc D$UnLikelyCode
            Mov W$edi 'sp' | add edi 2
        End_If

    .Else
        Mov D$edi 'subp'
        If B$OperandSizeOverride = &TRUE    ; 66 0F 5C /r SUBPD xmm1, xmm2/m128
            Call MarkSSEdata SSE_2_R
            Mov W$edi+4 'd '
        Else    ; 0F 5C /r SUBPS xmm1 xmm2/m128
            Call MarkSSEdata SSE_4_F
            Mov W$edi+4 's '
        End_If
        add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op5D:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov D$edi 'ebp ' | add edi 3
        Else
            inc D$UnLikelyCode
            Mov W$edi 'bp' | add edi 2
        End_If

    .Else
        ;inc D$UnLikelyCode
        Mov D$edi 'minp'
        If B$OperandSizeOverride = &TRUE ; MINPD xmm1, xmm2/m128
            Call MarkSSEdata SSE_2_R
            Mov W$edi+4 'd '
        Else        ; MINPS xmm1, xmm2/m128
            Call MarkSSEdata SSE_4_F
            Mov W$edi+4 's '
        End_If
        add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op5E:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov D$edi 'esi ' | add edi 3
        Else
            inc D$UnLikelyCode
            Mov W$edi 'si' | add edi 2
        End_If

    .Else
        ;inc D$UnLikelyCode
        Mov D$edi 'divp'
        If B$OperandSizeOverride = &TRUE    ; DIVPD xmm1, xmm2/m128
            Call MarkSSEdata SSE_2_R
            Mov W$edi+4 'd '
        Else                                ; DIVPS xmm1, xmm2/m128
            Call MarkSSEdata SSE_4_F
            Mov W$edi+4 's '
        End_If
        add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op5F:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov D$edi 'edi ' | add edi 3
        Else
            inc D$UnLikelyCode
            Mov W$edi 'di' | add edi 2
        End_If

    .Else
        ;inc D$UnLikelyCode
        Mov D$edi 'maxp'
        If B$OperandSizeOverride = &TRUE    ; 66 0F 5F /r MAXPD xmm1, xmm2/m128
            Call MarkSSEdata SSE_2_R
            Mov W$edi+4 'd '
        Else                                ; MAXPS xmm1, xmm2/m128
            Mov W$edi+4 's '
        End_If
        add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op60:
    .If B$EscapePrefix = &FALSE   ; 60 PUSHA 60 PUSHAD
        inc D$LikelyCode
        Mov D$edi 'Push', B$edi+4 'a' | add edi 5
        If B$OperandSizeOverride = &FALSE
            Mov B$edi 'd' | inc edi
        End_If

    .Else; 0F 60 /r PUNPCKLBW mm, mm/m32   ; 66 0F 60 /r PUNPCKLBW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'punp', D$edi+4 'cklb', W$edi+8 'w ' | add edi 10
        If B$OperandSizeOverride = &TRUE
            jmp Dis_xmm1__xmm2_m128
        Else
            jmp Dis_mmx1__mmx2_m64
        End_If

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op61:
    .If B$EscapePrefix = &FALSE   ; 61 POPA     ; 61 POPAD
        inc D$LikelyCode
        Mov D$edi 'popa' | add edi 4
        If B$OperandSizeOverride = &FALSE
            Mov B$edi 'd' | inc edi
        End_If

    .Else ; 0F 61 /r PUNPCKLWD mm, mm/m32   ; 66 0F 61 /r PUNPCKLWD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'punp', D$edi+4 'cklw', W$edi+8 'd ' | add edi 10
        If B$OperandSizeOverride = &TRUE
            jmp Dis_xmm1__xmm2_m128
        Else
            jmp Dis_mmx1__mmx2_m64
        End_If
    .End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op62:
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
      ; 0F 62 /r PUNPCKLDQ mm, mm/m32   ; 66 0F 62 /r PUNPCKLDQ xmm1, xmm2/m128
        Mov D$edi 'punp', D$edi+4 'ckld', W$edi+8 'q ' | add edi 10
        If B$OperandSizeOverride = &TRUE
            jmp Dis_xmm1__xmm2_m128
        Else
            jmp Dis_mmx1__mmx2_m64
        End_If
    .Else
        inc D$UnLikelyCode
        Mov D$edi 'boun', W$edi+4 'd ' | add edi 6  ; BOUND
        jmp Dis_r32_r16__rm32_rm16
    .End_If



Op63:
    ;inc D$UnLikelyCode
    .If B$EscapePrefix = &TRUE
        Mov D$edi 'pack', D$edi+4 'sswb', B$edi+8 SPC | add edi 9
        If B$OperandSizeOverride = &TRUE    ; 66 0F 63 /r PACKSSWB xmm1, xmm2/m128
            jmp Dis_xmm1__xmm_m128
        Else        ; 0F 63 /r PACKSSWB mm1, mm2/m64
            jmp Dis_mmx1__mmx2_m64
        End_If

    .Else
        inc D$UnlikelyCode
        Mov D$edi 'arpl', B$edi+4 SPC | add edi 5 ; ARPL
        Mov B$OperandSizeOverride &TRUE             ; to avoid one more case for 16/16

        jmp Dis_rm32_rm16__r32_r16

    .End_If


Op64:
    .If B$EscapePrefix = &TRUE
      ;0F 64 /r PCMPGTB mm, mm/m64 ;66 0F 64 /r PCMPGTB xmm1, xmm2/m128
        Mov D$edi 'pcmp', D$edi+4 'gtb ' | add edi 8
        jmp MMX6428
    .Else
        Mov D$SegmentOverride 'fs: ', B$DisFlag DISDONE
        inc D$Prefixes

    .End_If
ret


Op65:
    .If B$EscapePrefix = &TRUE
      ; 0F 65 /r PCMPGTW mm, mm/m64   ; 66 0F 65 /r PCMPGTW xmm1, xmm2/m128
        Mov D$edi 'pcmp', D$edi+4 'gtw ' | add edi 8
        jmp MMX6428

    .Else
        Mov D$SegmentOverride 'gs: ', B$DisFlag DISDONE
        inc D$Prefixes
        inc D$UnLikelyCode
    .End_If
ret


Op66:
    .If B$EscapePrefix = &TRUE  ; 0F 66 /r PCMPGTD mm, mm/m64
        ;inc D$UnLikelyCode
        Mov D$edi 'pcmp', D$edi+4 'gtd ' | add edi 8
        jmp Dis_mmx1__mmx2_m64

    .Else_If W$esi = 0660F      ; 66 0F 66 /r PCMPGTD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        add esi 2
        Mov D$edi 'pcmp', D$edi+4 'gtd ' | add edi 8
        jmp Dis_xmm1__xmm2_m128

    .Else_If W$esi = 07C0F      ; 66,0F,7C,/r HADDPD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        add esi 2 | Call MarkSSEdata SSE_2_R
        Mov D$edi 'hadd', D$edi+4 'pd ' | add edi 7
        jmp Dis_xmm1__xmm2_m128

    .Else_If W$esi = 07D0F      ; 66,0F,7D,/r HSUBPD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        add esi 2 | Call MarkSSEdata SSE_2_R
        Mov D$edi 'hsub', D$edi+4 'pd ' | add edi 7
        jmp Dis_xmm1__xmm2_m128

    .Else_If W$esi = 0D00F      ; 66,0F,D0,/r ADDSUBPD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        add esi 2
        Call MarkSSEdata SSE_2_R
        Mov D$edi 'adds', D$edi+4 'ubpd', B$edi+8 SPC | add edi 9
        jmp Dis_xmm1__xmm2_m128

    .Else
        On B$OperandSizeOverride = &TRUE, inc D$UnLikelyCode
        Mov B$OperandSizeOverride &TRUE, B$DisFlag DISDONE, W$DisSizeMarker 'W$'
        inc D$Prefixes
    .End_If
ret


Op67:
    .If B$EscapePrefix = &FALSE
        On B$AddressSizeOverride = &TRUE, inc D$UnLikelyCode
        Mov B$AddressSizeOverride &TRUE, B$DisFlag DISDONE
        inc D$Prefixes

    .Else   ; 66 0F 67 /r PACKUSWB xmm1, xmm2/m128 ; 0F 67 /r PACKUSWB mm, mm/m64
        ;inc D$UnLikelyCode
        Mov D$edi 'pack', D$edi+4 'uswb', B$edi+8 SPC | add edi 9
        jmp  MMX6428

    .End_If
ret


Op68:
    .If B$EscapePrefix = &FALSE   ; 68 Push imm16 / 32
        inc D$LikelyCode
        If B$OperandSizeOverride = &FALSE
            Mov D$edi 'Push', B$edi+4 SPC | add edi 5
        Else
            Mov D$edi 'Push', W$edi+4 'W ' | add edi 6
        End_If
        jmp Dis_imm32_16

    .Else ; 0F 68 /r PUNPCKHBW mm, mm/m64   ; 66 0F 68 /r PUNPCKHBW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'punp', D$edi+4 'ckhb', W$edi+8 'w ' | add edi 10
        jmp  MMX6428
    .End_If
ret


Op69:
    .If B$EscapePrefix = &TRUE
      ; 0F 69 /r PUNPCKHWD mm, mm/m64   ; 66 0F 69 /r PUNPCKHWD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'punp', D$edi+4 'ckhw', W$edi+8 'd ' | add edi 10
        jmp  MMX6428

    .Else
      ; IMUL r16,r/m16,imm16 (word register r/m16 * immediate word) (+ 32)
        inc D$LikelyCode
        Mov D$edi 'imul', B$edi+4 SPC | add edi 5
        jmp Dis_r32_r16__rm32_rm16_OrNone__SignedImm16_32
    .End_If
ret


Op6A:
    .If B$EscapePrefix = &TRUE
      ; 0F 6A /r PUNPCKHDQ mm, mm/m64   ; 66 0F 6A /r PUNPCKHDQ xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'punp', D$edi+4 'ckhd', W$edi+8 'q ' | add edi 10
        jmp  MMX6428

    .Else       ; 6A Push imm8
        inc D$LikelyCode
        If B$OperandSizeOverride = &FALSE
            Mov D$edi 'Push', B$edi+4 SPC | add edi 5 | jmp Dis_Imm8
        Else
            Mov D$edi 'Push', W$edi+4 'W ' | add edi 6 | jmp Dis_Imm8
        End_If
    .End_If
ret


Op6B:
    .If B$EscapePrefix = &TRUE
      ; 66 0F 6B /r PACKSSDW xmm1, xmm2/m128 ; 0F 6B /r PACKSSDW mm1, mm2/m64
        ;inc D$UnLikelyCode
        Mov D$edi 'pack', D$edi+4 'ssdw', B$edi+8 SPC | add edi 9
        jmp  MMX6428

    .Else  ; 6B /r ib > IMUL r16,r/m16,imm8
        inc D$LikelyCode
        Mov D$edi 'imul', B$edi+4 SPC | add edi 5
        jmp Dis_r32_r16__rm32_rm16_OrNone__SignedImm8

    .End_If
ret


Op6C:
    .If B$EscapePrefix = &TRUE
      ; 66 0F 6C /r PUNPCKLQDQ xmm1, xmm2/m128
        Mov D$edi 'punp', D$edi+4 'cklq', D$edi+8 'dq  ' | add edi 11
        jmp  MMX6428

    .Else
      ; INS m8, DX (ins 'B$es:edi dx')
        inc D$UnLikelyCode
        Mov D$edi 'insb' | add edi 4

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op6D:

    .If B$EscapePrefix = &TRUE
      ; 66 0F 6D /r PUNPCKHQDQ xmm1, xmm2/m128
        Mov D$edi 'punp', D$edi+4 'ckhq', D$edi+8 'dq  ' | add edi 11
        jmp Dis_xmm1__xmm2_m128

    .Else ; INS m32, DX +16
        inc D$UnLikelyCode
        If B$OperandSizeOverride = &TRUE
            Mov D$edi 'insw'
        Else
            Mov D$edi 'insd'
        End_If
        add edi 4

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op6E:
    .If B$EscapePrefix = &TRUE
        inc D$LikelyCode
        Mov D$edi 'movd', B$edi+4 SPC | add edi 5
        If B$OperandSizeOverride = &TRUE    ; 66 0F 6E /r MOVD xmm, r/m32
            jmp Dis_xmm_rm32
        Else         ; 0F 6E /r MOVD mm, r/m32
            jmp Dis_mmx_rm32
        End_If

    .Else       ; OUTS DX, m8
        inc D$UnLikelyCode
        Mov D$edi 'outs', B$edi+4 'B' | add edi 5

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op6F:
    .If B$EscapePrefix = &TRUE
        inc D$LikelyCode
        If B$OperandSizeOverride = &TRUE        ; MOVDQA xmm1, xmm2/m128
            Mov D$edi 'movd', D$edi+4 'qa  ' | add edi 7 | jmp Dis_xmm1__xmm2_m128
        Else        ; 0F 6F /r MOVQ mm, mm/m64
            Mov D$edi 'movq', B$edi+4 SPC | add edi 5 | jmp Dis_mmx1__mmx2_m64
        End_If

    .Else       ; OUTSW OUTSD
        inc D$UnLikelyCode
        Mov D$edi 'outs' | add edi 4
        If B$OperandSizeOverride = &TRUE
            Mov D$edi 'W'
        Else
            Mov D$edi 'D'
        End_If
        inc edi

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op70:
    .If B$EscapePrefix = &FALSE        ; JO rel8
        inc D$LikelyCode
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', W$edi+4 'o ' | add edi 6
        jmp EndWithDisByteRelative

    .Else
        ;inc D$UnLikelyCode
        Mov D$edi 'pshu'
        If B$OperandSizeOverride = &TRUE    ; 66 0F 70 /r ib PSHUFD xmm1, xmm2/m128, imm8
            Mov D$edi+4 'fd  '
            add edi 7 | Call Dis_xmm1__xmm2_m128
        Else        ; 0F 70 /r ib PSHUFW mm1, mm2/m64, imm8
            Mov D$edi+4 'fw  '
            add edi 7 | Call Dis_mm1__mm2_m128
        End_If
        Mov D$edi SPC | inc edi | Call WriteImm8

    .End_If
     Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op71:
    .If B$EscapePrefix = &FALSE        ; JNO rel8
        inc D$LikelyCode
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 'no  ' | add edi 7
        jmp EndWithDisByteRelative

    .Else
        Mov bl B$esi | inc esi | DigitMask bl To al

        If al = 2   ; 0F 71 /2 ib PSRLW mm, imm8    ; 66 0F 71 /2 ib PSRLW xmm1, imm8
            Mov D$edi 'psrl'
        Else_If al = 4   ; 0F 71 /4 ib PSRAW mm, imm8   ; 66 0F 71 /4 ib PSRAW xmm1, imm8
            Mov D$edi 'psra'
        Else_If al = 6   ; 0F 71 /6 ib PSLLW mm, imm8 ; 66 0F 71 /6 ib PSLLW xmm1, imm8
            Mov D$edi 'psll'
        Else
            inc D$UnLikelyCode | dec esi | ret
        End_If
        Mov W$edi+4 'w ' | add edi 6 | jmp Dis_xmmx_imm8

    .End_If


Op72:
    .If B$EscapePrefix = &FALSE ; JB rel8 ; JNAE rel8
        inc D$LikelyCode
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', W$edi+4 'b ' | add edi 6
        jmp EndWithDisByteRelative

    .Else
        Mov bl B$esi | inc esi | DigitMask bl To al

        If al = 2      ; 0F 72 /2 ib PSRLD mm, imm8  ; 66 0F 72 /2 ib PSRLD xmm1, imm8
            Mov D$edi 'psrl'
        Else_If al = 4 ; 0F 72 /4 ib PSRAD mm, imm8  ; 66 0F 72 /4 ib PSRAD xmm1, imm8
            Mov D$edi 'psra'
        Else_If al = 6 ; 0F 72 /6 ib PSLLD mm, imm8  ; 66 0F 72 /6 ib PSLLD xmm1, imm8
            Mov D$edi 'psll'
        Else
            inc D$UnLikelyCode | dec esi | ret
        End_If
        Mov W$edi+4 'd ' | add edi 6 | jmp Dis_xmmx_imm8

    .End_If



Op73:
    ...If B$EscapePrefix = &TRUE
        Mov bl B$esi | inc esi | DigitMask bl To al

        .If al = 2   ; 0F 73 /2 ib PSRLQ mm, imm8  ; 66 0F 73 /2 ib PSRLQ xmm1, imm8
            Mov D$edi 'psrl', W$edi+4 'q ' | add edi 6
            jmp Dis_xmmx_imm8
        .Else_If al = 3    ; 66 0F 73 /3 ib PSRLDQ xmm1, imm8
            If B$OperandSizeOverride = &TRUE
                Mov D$edi 'psrl', D$edi+4 'dq  ' | add edi 7
                jmp Dis_xmm_imm8
            End_If
            inc D$UnLikelyCode
        .Else_If al = 6
              ; 0F 73 /6 ib PSLLQ mm, imm8 ; 66 0F 73 /6 ib PSLLQ xmm1, imm8
            Mov D$edi 'psll', W$edi+4 'q ' | add edi 6 | jmp Dis_xmmx_imm8
        .Else_If al = 7    ; 66 0F 73 /7 ib PSLLDQ xmm1, imm8
            If B$OperandSizeOverride = &TRUE
                Mov D$edi 'psll', D$edi+4 'dq  ' | add edi 7
                jmp Dis_xmm_imm8
            End_If
            inc D$UnLikelyCode
        .Else
            inc D$UnLikelyCode | dec esi | ret
        .End_If

    ...Else        ; JAE rel8 ; JNB rel8 ; JNC rel8
        inc D$LikelyCode
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 'ae  ' | add edi 7
        jmp EndWithDisByteRelative

    ...End_If
ret


Op74:
    If B$EscapePrefix = &FALSE  ; JE rel8 ; JZ rel8
        inc D$LikelyCode
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', W$edi+4 'e ' | add edi 6
        jmp EndWithDisByteRelative

    Else
      ; 0F 74 /r PCMPEQB mm, mm/m64    ; 66 0F 74 /r PCMPEQB xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'pcmp', D$edi+4 'eqb ', B$edi+8 SPC | add edi 8
        jmp MMX6428

    End_If


Op75:
    If B$EscapePrefix = &FALSE  ; JNE rel8 ; JNZ rel8
        inc D$LikelyCode
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 'ne  ' | add edi 7
        jmp EndWithDisByteRelative

    Else
      ; 0F 75 /r PCMPEQW mm, mm/m64     ; 66 0F 75 /r PCMPEQW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'pcmp', D$edi+4 'eqw ', B$edi+8 SPC | add edi 8
        jmp MMX6428

    End_If


Op76:
    If B$EscapePrefix = &FALSE        ; JBE rel8 ; JNA rel8
        inc D$LikelyCode
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 'be  ' | add edi 7
        jmp EndWithDisByteRelative

    Else
      ; 0F 76 /r PCMPEQD mm, mm/m64     ; 66 0F 76 /r PCMPEQD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'pcmp', D$edi+4 'eqd ', B$edi+8 SPC | add edi 8
        jmp MMX6428

    End_If


Op77:
    If B$EscapePrefix = &FALSE        ; JA rel8 ; JNBE rel8
        inc D$LikelyCode
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', W$edi+4 'a ' | add edi 6 | jmp EndWithDisByteRelative

    Else     ; EMMS
        Mov D$edi 'emms' | add edi 4

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op78: ; JS rel8
    inc D$LikelyCode
    Mov B$CALLInstruction &TRUE
    SubEdi6 | Mov D$edi ' | j', W$edi+4 's ' | add edi 6 | jmp EndWithDisByteRelative
ret


Op79: ; JNS rel8
    inc D$LikelyCode
    Mov B$CALLInstruction &TRUE
    SubEdi6 | Mov D$edi ' | j', D$edi+4 'ns  ' | add edi 7 | jmp EndWithDisByteRelative
ret


Op7A: ; JP rel8 ; JPE rel8
    inc D$LikelyCode
    Mov B$CALLInstruction &TRUE
    SubEdi6 | Mov D$edi ' | j', W$edi+4 'p ' | add edi 6 | jmp EndWithDisByteRelative
ret


Op7B: ; JNP rel8 ; JPO rel8
    inc D$LikelyCode
    Mov B$CALLInstruction &TRUE
    SubEdi6 | Mov D$edi ' | j', D$edi+4 'np  ' | add edi 7 | jmp EndWithDisByteRelative
ret


Op7C: ; JL rel8 ; JNGE rel8
    inc D$LikelyCode
    Mov B$CALLInstruction &TRUE
    SubEdi6 | Mov D$edi ' | j', W$edi+4 'l ' | add edi 6 | jmp EndWithDisByteRelative
ret


Op7D: ; JGE rel8 ; JNL rel8
    inc D$LikelyCode
    Mov B$CALLInstruction &TRUE
    SubEdi6 | Mov D$edi ' | j', D$edi+4 'ge  ' | add edi 7 | jmp EndWithDisByteRelative
ret


Op7E:
    inc D$LikelyCode
    If B$EscapePrefix = &FALSE     ; JLE rel8 ; JNG rel8
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 'le  ' | add edi 7
        jmp EndWithDisByteRelative

    Else
       ; 66 0F 7E /r MOVD r/m32, xmm ; 0F 7E /r MOVD r/m32, mm
         Mov D$edi 'movd', B$edi+4 SPC | add edi 5 | jmp Dis_rm32_xmmx

    End_If


Op7F:
    .If B$EscapePrefix = &FALSE  ; JG rel8 ; JNLE rel8
        inc D$LikelyCode
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', W$edi+4 'g ' | add edi 6
        jmp EndWithDisByteRelative

    .Else
        If B$OperandSizeOverride = &TRUE    ; 66 0F 7F /r MOVDQA xmm2/m128, xmm1
            Mov D$edi 'movd', D$edi+4 'qa  ' | add edi 7
            jmp Dis_xmm2_m128__xmm1
        Else        ; 0F 7F /r MOVQ mm/m64, mm
            Mov D$edi 'movq', B$edi+4 SPC | add edi 5
            jmp Dis_mmx1_m64__mmx2
        End_If

    .End_If


Op80:
    inc D$LikelyCode
    ..If B$EscapePrefix = &TRUE       ; 0F 80 cw/cd JO rel16/32
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', W$edi+4 'o ' | add edi 6
        jmp EndWithDisWordDwordRelative

    ..Else
        Mov bl B$esi | inc esi | DigitMask bl To al              ; ModRm with /2 ?

        .If al = 0
            Mov B$LockPrefix &FALSE
            Mov D$edi 'add ' | add edi 4
        .Else_If al = 1  ; OR r/m8,imm8
            Mov B$LockPrefix &FALSE
            Mov D$edi 'or  ' | add edi 3
        .Else_If al = 2  ; adc r/m8 imm8
            Mov B$LockPrefix &FALSE
            Mov D$edi 'adc ' | add edi 4
        .Else_If al = 3  ; 80 /3 ib SBB r/m8,imm8
            Mov B$LockPrefix &FALSE
            Mov D$edi 'sbb ' | add edi 4
        .Else_If al = 4
            Mov B$LockPrefix &FALSE
            Mov D$edi 'and ' | add edi 4
        .Else_If al = 5  ; 80 /5 ib SUB r/m8,imm8
            Mov B$LockPrefix &FALSE
            Mov D$edi 'sub ' | add edi 4
        .Else_If al = 6  ; 80 /6 ib XOR r/m8,imm8
            Mov B$LockPrefix &FALSE
            Mov D$edi 'xor ' | add edi 4
        .Else_If al = 7
            Mov D$edi 'cmp ' | add edi 4
        .End_If

        jmp Dis_rm8_imm8

    ..End_If


Op81:
    inc D$LikelyCode
    ..If B$EscapePrefix = &TRUE      ; JNO rel16/32
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 'no  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    ..Else
      ; adc r/m32//r/m16 imm32/imm16
        Mov bl B$esi | inc esi | DigitMask bl To al              ; ModRm with /2 ?

        .If al = 0
            Mov B$LockPrefix &FALSE
            Mov D$edi 'add ' | add edi 4
        .Else_If al = 1      ; OR r/m16,imm16 // OR r/m32,imm32
            Mov B$LockPrefix &FALSE
            Mov D$edi 'or  ' | add edi 3
        .Else_If al = 2
            Mov B$LockPrefix &FALSE
            Mov D$edi 'adc ' | add edi 4
        .Else_If al = 3  ; 81 /3 iw SBB r/m16,imm16  ; 81 /3 id SBB r/m32,imm32
            Mov B$LockPrefix &FALSE
            Mov D$edi 'sbb ' | add edi 4
        .Else_If al = 4
            Mov B$LockPrefix &FALSE
            Mov D$edi 'and ' | add edi 4
        .Else_If al = 5  ; 81 /5 iw SUB r/m16,imm16 ; 81 /5 id SUB r/m32,imm32
            Mov B$LockPrefix &FALSE
            Mov D$edi 'sub ' | add edi 4
        .Else_If al = 6  ; 81 /6 iw XOR r/m16,imm16 ; 81 /6 id XOR r/m32,imm32
            Mov B$LockPrefix &FALSE
            Mov D$edi 'xor ' | add edi 4
        .Else_If al = 7
            Mov D$edi 'cmp ' | add edi 4
        .End_If

        jmp Dis_rm32_rm16__imm32_imm16

    ..End_If


Op82:
    If B$EscapePrefix = &TRUE       ; JB rel16/32 ; JC rel16/32 ; JNAE rel16/32
        inc D$LikelyCode
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', W$edi+4 'b ' | add edi 6
        jmp EndWithDisWordDwordRelative
    End_If
ret


Op83:
    inc D$LikelyCode

    ..If B$EscapePrefix = &TRUE      ; JAE rel16/32 ; JNB rel16/32 ; JNC rel16/32
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 'ae  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    ..Else

        Mov bl B$esi | inc esi | DigitMask bl To al              ; ModRm with /2 ?

        .If al = 0
            Mov B$LockPrefix &FALSE
            Mov D$edi 'add ' | add edi 4
        .Else_If al = 1      ; OR r/m16,imm8 // OR r/m32,imm8
            Mov B$LockPrefix &FALSE
            Mov D$edi 'or  ' | add edi 3
        .Else_If al = 2   ; adc r/m32//r/m16 imm8
            Mov B$LockPrefix &FALSE
            Mov D$edi 'adc ' | add edi 4
        .Else_If al = 3  ; 83 /3 ib SBB r/m16,imm8   ; 83 /3 ib SBB r/m32,imm8
            Mov B$LockPrefix &FALSE
            Mov D$edi 'sbb ' | add edi 4
        .Else_If al = 4
            Mov B$LockPrefix &FALSE
            Mov D$edi 'and ' | add edi 4
        .Else_If al = 5  ; 83 /5 ib SUB r/m16,imm8 ; 83 /5 ib SUB r/m32,imm8
            Mov B$LockPrefix &FALSE
            Mov D$edi 'sub ' | add edi 4
        .Else_If al = 6  ; 83 /6 ib XOR r/m16,imm8 ; 83 /6 ib XOR r/m32,imm8
            Mov B$LockPrefix &FALSE
            Mov D$edi 'xor ' | add edi 4
        .Else_If al = 7
            Mov D$edi 'cmp ' | add edi 4
        .End_If

        jmp Dis_rm32_rm16__imm8

    ..End_If


Op84:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE       ; JE rel16/32 ; JZ rel16/32 ; JZ rel16/32
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', W$edi+4 'e ' | add edi 6
        jmp EndWithDisWordDwordRelative

    Else    ; 84 /r TEST r/m8,r8
        Mov D$edi 'test', B$edi+4 SPC | add edi 5 | jmp Dis_rm8_r8

    End_If


Op85:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE    ; JNE rel16/32 ; JNZ rel16/32
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 'ne  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    Else    ; 85 /r TEST r/m16,r16 ; 85 /r TEST r/m32,r32
        Mov D$edi 'test', B$edi+4 SPC | add edi 5 | jmp Dis_rm32_rm16__r32_r16

    End_If


Op86:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE    ; JBE rel16/32 ; JNA rel16/32
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 'be  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    Else        ; 86 /r XCHG r/m8, r8
        Mov B$LockPrefix &FALSE
        Mov D$edi 'xchg', B$edi+4 SPC | add edi 5 | jmp Dis_rm8_r8

    End_If


Op87:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE    ; 0F 87 cw/cd > JA rel16/32 ; JNBE rel16/32
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', W$edi+4 'a ' | add edi 6

        jmp EndWithDisWordDwordRelative

    Else        ; 87 /r XCHG r/m16, r16 ; 87 /r XCHG r/m32, r32 ( and reverse)
        Mov B$LockPrefix &FALSE
        Mov D$edi 'xchg', B$edi+4 SPC | add edi 5 | jmp Dis_r32_r16__rm32_rm16

    End_If


Op88:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE           ; JS rel16/32
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 's ' | add edi 6
        jmp EndWithDisWordDwordRelative

    Else    ; Mov r/m8,r8
        Mov D$edi 'Mov ' | add edi 4 | jmp Dis_rm8_r8

    End_If


Op89:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE           ; JNS rel16/32
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 'ns  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    Else        ; Mov r/m16,r16 ; Mov r/m32,r32
        Mov D$edi 'Mov ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16

    End_If


Op8A:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE           ; JP rel16/32 ; JPE rel16/32
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 'p ' | add edi 6
        jmp EndWithDisWordDwordRelative

    Else        ; Mov r8,r/m8
        Mov D$edi 'Mov ' | add edi 4 | jmp Dis_r8_rm8

    End_If


Op8B:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE           ; JNP rel16/32 ; JPO rel16/32
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 'np  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    Else        ; Mov r16,r/m16 ; Mov r32,r/m32
        Mov D$edi 'Mov ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16

    End_If


Op8C:
    .If B$EscapePrefix = &TRUE           ; JL rel16/32 ; JNGE rel16/32
        inc D$LikelyCode
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 'l ' | add edi 6
        jmp EndWithDisWordDwordRelative

    .Else        ; Mov r/m16,Sreg** (there was a 066...)
        inc D$UnLikelyCode
        Mov D$edi 'Mov ' | add edi 4
        If B$OperandSizeOverride = &TRUE
            jmp Dis_rm16_Sreg
        Else
            jmp Dis_rm32_Sreg
        End_If
    .End_If
ret


Op8D:
    inc D$LikelyCode

    .If B$EscapePrefix = &TRUE           ; JGE rel16/32 ; JNL rel16/32
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 'ge  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    .Else            ; LEA r16,m
        If B$esi > 00_10_111_111      ; Never: lea eax ebx
            inc D$UnLikelyCode
            ret
        Else

        ;If B$TestNow = 1
        ;    On D$esi+1 = 04398C0, int3
        ;End_If

            Mov B$LeaInstruction &TRUE
            Mov D$edi 'lea ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16
        End_If
    .End_If


Op8E:
    .If B$EscapePrefix = &TRUE           ; JLE rel16/32 ; JNG rel16/32
        inc D$LikelyCode
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', D$edi+4 'le  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    .Else        ; Mov Sreg,r/m16** (there was a 066...)
        inc D$UnLikelyCode
        Mov D$edi 'Mov ' | add edi 4
        If B$OperandSizeOverride = &TRUE
            jmp Dis_Sreg_rm16
        Else
            jmp Dis_Sreg_rm32 ;jE! ALLOWED!!
        End_If

    .End_If
ret


Op8F:
    .If B$EscapePrefix = &TRUE           ; JG rel16/32 ; JNLE rel16/32
        inc D$LikelyCode
        Mov B$CALLInstruction &TRUE
        SubEdi6 | Mov D$edi ' | j', W$edi+4 'g ' | add edi 6
        jmp EndWithDisWordDwordRelative

    .Else
        Mov bl B$esi | inc esi | DigitMask bl To al

        If al = 0       ; 8F /0 Pop m16
            Mov D$edi 'Pop ' | add edi 4 | jmp EndWithModRm
        Else
            inc D$UnLikelyCode | dec esi | ret
        End_If
    .End_If


Op90:
    If B$EscapePrefix = &FALSE  ; NOP ;  ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        Mov D$edi 'nop ' | add edi 4

    Else     ; 0F 90 SETO r/m8
       ; inc D$UnLikelyCode
        Mov D$edi 'seto', B$edi+4 SPC | add edi 5 | jmp Dis_rm8

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op91: ; 0F 91 SETNO r/m8
    If B$EscapePrefix = &TRUE
       ; inc D$UnLikelyCode
        Mov D$edi 'setn', W$edi+4 'o ' | add edi 6 | jmp Dis_rm8

    Else    ; ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        Mov D$edi 'xchg', B$edi+4 SPC | add edi 5 | jmp Dis_eax_ax__rd_rw

    End_If


Op92: ; 0F 92 SETB r/m8 ; 0F 92 SETC r/m8  ; 0F 92 SETNAE r/m8
    If B$EscapePrefix = &FALSE    ; ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        Mov D$edi 'xchg', B$edi+4 SPC | add edi 5 | jmp Dis_eax_ax__rd_rw

    Else
       ; inc D$UnLikelyCode
        Mov D$edi 'setc', B$edi+4 SPC | add edi 5 | jmp Dis_rm8

    End_If


Op93:
    If B$EscapePrefix = &FALSE   ; ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        Mov D$edi 'xchg', B$edi+4 SPC | add edi 5 | jmp Dis_eax_ax__rd_rw

    Else
       ; inc D$UnLikelyCode
      ; 0F 93 SETAE r/m8    ; 0F 93 SETNB r/m8  ; 0F 93 SETNC r/m8
        Mov D$edi 'seta', W$edi+4 'e ' | add edi 6 | jmp Dis_rm8

    End_If


Op94: ; 0F 94 SETE r/m8 ; 0F 94 SETZ r/m8
    If B$EscapePrefix = &FALSE    ; ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        Mov D$edi 'xchg', B$edi+4 SPC | add edi 5 | jmp Dis_eax_ax__rd_rw

    Else
       ; inc D$UnLikelyCode
        Mov D$edi 'sete', B$edi+4 SPC | add edi 5 | jmp Dis_rm8

    End_If


Op95: ; 0F 95 SETNE r/m8 ; 0F 95 SETNZ r/m8
    If B$EscapePrefix = &FALSE    ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        Mov D$edi 'xchg', B$edi+4 SPC | add edi 5 | jmp Dis_eax_ax__rd_rw

    Else
       ; inc D$UnLikelyCode
        Mov D$edi 'setn', W$edi+4 'e ' | add edi 6 | jmp Dis_rm8

    End_If


Op96:
    If B$EscapePrefix = &FALSE    ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        Mov D$edi 'xchg', B$edi+4 SPC | add edi 5 | jmp Dis_eax_ax__rd_rw

    Else         ; 0F 96 SETBE r/m8    ; 0F 96 SETNA r/m8
       ; inc D$UnLikelyCode
        Mov D$edi 'setb', W$edi+4 'e ' | add edi 6 | jmp Dis_rm8

    End_If


Op97:
    If B$EscapePrefix = &FALSE    ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        Mov D$edi 'xchg', B$edi+4 SPC | add edi 5 | jmp Dis_eax_ax__rd_rw

    Else         ; 0F 97 SETA r/m8 ; 0F 97 SETNBE r/m8
       ; inc D$UnLikelyCode
        Mov D$edi 'seta', B$edi+4 SPC | add edi 5 | jmp Dis_rm8

    End_If


Op98:
    .If B$EscapePrefix = &TRUE   ; 0F 98 SETS r/m8
        Mov D$edi 'sets', B$edi+4 SPC | add edi 5 | jmp Dis_rm8

    .Else ; cbw / cwde
        If B$OperandSizeOverride = &TRUE
            Mov D$edi 'cbw ' | add edi 3
        Else
            Mov D$edi 'cwde' | add edi 4
        End_If

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op99:
    .If B$EscapePrefix = &TRUE   ; 0F 99 SETNS r/m8
        Mov D$edi 'setn', W$edi+4 's ' | add edi 6 | jmp Dis_rm8

    .Else    ; CWD / CDQ
        If B$OperandSizeOverride = &FALSE
            Mov D$edi 'cdq ' | add edi 3
        Else
            Mov D$edi 'cwd ' | add edi 3
        End_If

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op9A:

    ..If B$EscapePrefix = &TRUE      ; 0F 9A SETP r/m8 ; 0F 9A SETPE r/m8
        Mov D$edi 'setp', B$edi+4 SPC | add edi 5 | jmp Dis_rm8

    ..Else
        add D$UnLikelyCode 0FF
        If B$OperandSizeOverride = &TRUE        ; Call far ptr16:selector16 ; callF16
            Mov D$edi 'Call', D$edi+4 'F W$' | add edi 8 ; jE! fix
            Push D$esi, esi
                Exchange W$esi, W$esi+2
                Call WriteImm16 | Mov B$edi SPC | inc edi | Call WriteImm16
            Pop eax, D$eax
        Else                                ;   Call far ptr32:selector16
            Mov D$edi 'Call', D$edi+4 'F D$' | add edi 8 ; jE! fix
            Push D$esi, D$esi+4, esi
                Mov eax D$esi, bx W$esi+4, W$esi bx, D$esi+2 eax
                Call WriteImm16 | Mov B$edi SPC | inc edi | Call WriteImm32
            Pop eax D$eax+4, D$eax
        End_If

        Mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8
    ..End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op9B:
    ..If B$EscapePrefix = &TRUE     ; 0F 9B SETNP r/m8 ; 0F 9B SETPO r/m8
        ;inc D$UnLikelyCode
        Mov D$edi 'setn', W$edi+4 'p ' | add edi 6 | jmp Dis_rm8

    ..Else
        .If W$esi = 0E2DB           ; 9B DB E2 > FCLEX
            Mov D$edi 'fcle', W$edi+4 'x ' | add edi 5 | add esi 2

        .Else_If W$esi = 0E3DB      ; 9B DB E3 >FINIT
            Mov D$edi 'fini', W$edi+4 't ' | add edi 5 | add esi 2

        .Else_If W$esi = 0E0DF      ; 9B DF E0 FSTSW AX
            Mov D$edi 'fsts', D$edi+4 'w ax' | add edi 8 | add esi 2

        .Else_If B$esi = 0DD
            Mov bl B$esi+1 | DigitMask bl to al

            If al = 6               ; 9B DD /6 > FSAVE m94/108byte
                Mov D$edi 'fsav', W$edi+4 'e ' | add edi 6 | inc esi | lodsb
                jmp EndWith.X.mem
            Else_If al = 7          ; 9B DD /7 FSTSW m2byte
                Mov D$edi 'fsts', W$edi+4 'w ' | add edi 6 | inc esi | lodsb
                jmp EndWith.W.mem
            Else
                jmp L5>
            End_If

        .Else_If B$esi = 0D9 ; opD9
            Mov bl B$esi+1 | DigitMask bl to al

            If al = 6               ; 9B D9 /6 FSTENV m14/28byte
                Mov D$edi 'fste', D$edi+4 'nv  ' | add edi 7 | inc esi | lodsb
                jmp EndWith.X.mem
            Else_If al = 7          ; 9B DD /6 > FSTCW m2byte
                Mov D$edi 'fstc', W$edi+4 'w ' | add edi 6 | inc esi | lodsb
                jmp EndWith.W.mem
            Else
                jmp L5>
            End_If

        .Else                       ; 9B WAIT
L5:         Mov D$edi 'wait' | add edi 4
        .End_If

    ..End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op9C: ; setl

    .If B$EscapePrefix = &TRUE   ; 0F 9C SETL r/m8 ; 0F 9C SETNGE r/m8
        Mov D$edi 'setl', B$edi+4 SPC | add edi 5 | jmp Dis_rm8

    .Else       ; 9C PUSHF 9C PUSHFD
        ;inc D$UnLikelyCode
        Mov D$edi 'Push', B$edi+4 'f' | add edi 5
        If B$OperandSizeOverride = &TRUE
            Mov B$edi 'd' | inc edi
        End_If

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op9D:

    .If B$EscapePrefix = &TRUE   ; 0F 9D SETGE r/m8 ; 0F 9D SETNL r/m8
        Mov D$edi 'setg', W$edi+4 'e ' | add edi 6 | jmp Dis_rm8

    .Else    ; 9D POPF  ; 9D POPFD
        ;inc D$UnLikelyCode
        Mov D$edi 'popf' | add edi 4
        If B$OperandSizeOverride = &TRUE
            Mov B$edi 'd' | inc edi
        End_If

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op9E:
    .If B$EscapePrefix = &TRUE   ; 0F 9E SETLE r/m8 ; 0F 9E SETNG r/m8
        Mov D$edi 'setl', W$edi+4 'e ' | add edi 6 | jmp Dis_rm8

    .Else       ; 9E SAHF
        ;inc D$UnLikelyCode
        Mov D$edi 'sahf' | add edi 4

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Op9F:

    If B$EscapePrefix = &TRUE   ; 0F 9F SETG r/m8 ; 0F 9F SETNLE r/m8
        Mov D$edi 'setg', B$edi+4 SPC | add edi 5 | jmp Dis_rm8

    Else    ; LAHF
        ;inc D$UnLikelyCode
        Mov D$edi 'lahf' | add edi 4

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA0:
    If B$EscapePrefix = &TRUE   ; 0F A0 Push FS
        inc D$UnLikelyCode
        Mov D$edi 'Push', D$edi+4 ' fs ' | add edi 7

    Else ; Mov AL,moffs8*
        Mov D$edi 'Mov ', D$edi+4 'al B', B$edi+8 '$' | add edi 9 | Call WriteImm32

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret



OpA1:
    .If B$EscapePrefix = &TRUE ; 0F A1 Pop FS
        inc D$UnLikelyCode
        Mov D$edi 'Pop ', W$edi+4 'fs' | add edi 6

    .Else        ; Mov EAX,moffs32* ; Mov AX,moffs16*
        Mov D$edi 'Mov ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            Mov D$edi 'eax ', W$edi+4 'D$' | add edi 6
        Else
            Mov D$edi 'ax W', B$edi+4 '$' | add edi 5
        End_If
        If D$SegmentOverride <> 0
            Move D$edi D$SegmentOverride | add edi 3
        End_If
        Call WriteDis32 ; WriteImm32

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA2:
    If B$EscapePrefix = &TRUE ; CPUID
        Mov D$edi 'cpui', B$edi+4 'd' | add edi 5

    Else        ; Mov moffs8*,AL
        Mov D$edi 'Mov ', D$edi+4 'B$  ' | add edi 6
        Call WriteImm32 | Mov D$edi ' al ' | add edi 3

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA3:
    .If B$EscapePrefix = &TRUE
        Mov D$edi 'bt  ' | add edi 3 | jmp Dis_rm32_rm16__r32_r16

    .Else        ; Mov moffs32*,EAX ; Mov moffs16*,AX
        Mov D$edi 'Mov '
        If B$OperandSizeOverride = &FALSE
            Mov D$edi+4 'D$  '
        Else
            Mov D$edi+4 'W$  '
        End_If
        add edi 6
        If D$SegmentOverride <> 0
            Move D$edi D$SegmentOverride | add edi 3
        End_If

        Call WriteDis32

        If B$OperandSizeOverride = &FALSE
            Mov D$edi ' eax' | add edi 4
        Else
            Mov D$edi ' ax ' | add edi 3
        End_If

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA4:
    inc  D$LikelyCode
    If B$EscapePrefix = &TRUE   ; 0F A4 SHLD r/m16, r16, imm8 ; 0F A4 SHLD r/m32, r32, imm8
        Mov D$edi 'shld', B$edi+4 SPC | add edi 5 | jmp Dis_rm32_rm16__r32_r16__imm8

    Else ; MOVSB
        Mov D$edi 'movs', B$edi+4 'b' | add edi 5

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA5:
    inc D$LikelyCode
    .If B$EscapePrefix = &TRUE   ; 0F A5 SHLD r/m16, r16, CL ; 0F A5 SHLD r/m32, r32, CL
        Mov D$edi 'shld', B$edi+4 SPC | add edi 5 | jmp Dis_rm32_rm16__r32_r16__cl

    .Else
        If B$OperandSizeOverride = &FALSE  ; MOVSD
            Mov D$edi 'movs', B$edi+4 'd'
        Else  ; MOVSW
            Mov D$edi 'movs', B$edi+4 'w'
        End_If
        add edi 5

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA6: ; cmpsb
    inc D$LikelyCode
    Mov D$edi 'cmps', B$edi+4 'b' | add edi 5
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA7: ; cmpsw / d
    inc D$LikelyCode
    Mov D$edi 'cmps' | add edi 4
    If B$OperandSizeOverride = &TRUE
        Mov B$edi 'w'
    Else
        Mov B$edi 'd'
    End_If
    inc edi
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA8:
    If B$EscapePrefix = &TRUE   ; 0F A8 Push GS
        inc D$UnLikelyCode
        Mov D$edi 'Push', D$edi+4 ' gs ' | add edi 7

    Else    ; A8 ib TEST AL,imm8
        inc D$LikelyCode
        Mov D$edi 'test', B$edi+4 SPC | add edi 5 | jmp Dis_al_imm8

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA9: ; 0F A9 Pop GS
    If B$EscapePrefix = &TRUE
        inc D$UnLikelyCode
        Mov D$edi 'Pop ', W$edi+4 'gs' | add edi 6

    Else   ; A9 iw TEST AX,imm16 ; A9 id TEST EAX,imm32
        inc D$LikelyCode
        Mov D$edi 'test', B$edi+4 SPC | add edi 5 | jmp Dis_eax_ax__imm32_imm16

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpAA:
    If B$EscapePrefix = &TRUE    ; 0F AA RSM
        inc D$UnLikelyCode
        Mov D$edi 'rsm ' | add edi 3

    Else       ; AA STOSB
        inc D$LikelyCode
        Mov D$edi 'stos', B$edi+4 'b' | add edi 5

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpAB:
    If B$EscapePrefix = &TRUE
        Mov B$LockPrefix &FALSE
        Mov D$edi 'bts ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16

    Else        ; AB STOSW ; AB STOSD
        inc D$LikelyCode
        Mov D$edi 'stos', B$edi+4 'd' | add edi 5
        On B$OperandSizeOverride = &TRUE, Mov B$edi-1 'w'

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpAC:
    If B$EscapePrefix = &TRUE   ; 0F AC SHRD r/m16, r16, imm8 ; 0F AC SHRD r/m32, r32, mm8
        Mov D$edi 'shrd', B$edi+4 SPC | add edi 5 | jmp Dis_rm32_rm16__r32_r16__imm8

    Else ; LODSB
        inc D$LikelyCode
        Mov D$edi 'lods', B$edi+4 'b' | add edi 5

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpAD:
    .If B$EscapePrefix = &TRUE   ; 0F AD SHRD r/m16, r16, CL ; 0F AD SHRD r/m32, r32, CL
        Mov D$edi 'shrd', B$edi+4 SPC | add edi 5 | jmp Dis_rm32_rm16__r32_r16__cl

    .Else    ; LODSD ; LODSW
        inc D$LikelyCode
        Mov D$edi 'lods', B$edi+4 'd'
        On B$OperandSizeOverride = &TRUE, Mov B$edi+4 'w'
        add edi 5

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpAE:
    ..If B$EscapePrefix = &TRUE
        movzx ebx B$esi | inc esi | DigitMask bl to al

        .If al = 0          ; FXSAVE m512byte
            Mov D$edi 'fxsa', D$edi+4 've  ' | add edi 7 | jmp EndWith.X.mem
        .Else_If al = 1     ; FXRSTOR m512byte
            Mov D$edi 'fxrs', D$edi+4 'tor ' | add edi 8 | jmp EndWith.X.mem
        .Else_If al = 2     ; LDMXCSR m32
            Mov D$edi 'ldmx', D$edi+4 'csr ' | add edi 8 | jmp EndWith.D.mem
        .Else_If al = 3     ; 0F AE /3 STMXCSR m32
            Mov D$edi 'stmx', D$edi+4 'csr ' | add edi 8 | jmp EndWith.D.mem
        .Else_If al = 5     ; LFENCE
            Mov D$edi 'lfen', W$edi+4 'ce' | add edi 6
        .Else_If al = 6     ; MFENCE
            Mov D$edi 'mfen', W$edi+4 'ce' | add edi 6
        .Else_If al = 7     ; 0F AE /7 CLFLUSH   ; 0F AE /7 SFENCE
            ModMask bl to al
            If al = 3
                Mov D$edi 'sfen', D$edi+4 'ce  '  | add edi 6
            Else
                Mov D$edi 'clfl', D$edi+4 'ush ' | add edi 8 | jmp Dis_m8
            End_If
        .Else
            dec esi | ret
        .End_If

    ..Else  ; AE SCASB
        Mov D$edi 'scas', B$edi+4 'b' | add edi 5
    ..End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpAF:  ; 0F AF /r > IMUL r16,r/m16 ou 32
    inc D$LikelyCode
    If B$EscapePrefix = &TRUE
        Mov D$edi 'imul', B$edi+4 SPC | add edi 5 | jmp Dis_r32_r16__rm32_rm16

    Else        ; AF SCASD AF SCASW
         Mov D$edi 'scas', B$edi+4 'd' | add edi 5
         On B$OperandSizeOverride = &TRUE, Mov B$edi-1 'w'

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB0:
    If B$EscapePrefix = &FALSE  ; Mov r8,imm8
        inc D$LikelyCode
        Mov D$edi 'Mov ', D$edi+4 'al  ' | add edi 7 | Call WriteImm8

    Else     ; CMPXCHG r/m8,r8
        ;inc D$UnLikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'cmpx', D$edi+4 'chg ' | add edi 8 | jmp Dis_rm8_r8

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB1: ; CMPXCHG r/m32,r32 (+16)
    If B$EscapePrefix = &FALSE
        Mov D$edi 'Mov ', D$edi+4 'cl  ' | add edi 7 | Call WriteImm8

    Else
        Mov B$LockPrefix &FALSE
        Mov D$edi 'cmpx', D$edi+4 'chg ' | add edi 8 | jmp Dis_rm32_rm16__r32_r16

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB2: ; 0F B2 > LSS r16,m16:16 ; LSS r32,m16:32
    If B$EscapePrefix = &FALSE
        Mov D$edi 'Mov ', D$edi+4 'dl  ' | add edi 7 | Call WriteImm8

    Else
        inc D$UnLikelyCode
        Mov D$edi 'lss ' | add edi 4 | Call Dis_r32_r16__rm32_rm16 ; LSL
        Mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB3:
    If B$EscapePrefix = &FALSE
        Mov D$edi 'Mov ', D$edi+4 'bl  ' | add edi 7 | Call WriteImm8

    Else
        ;inc D$UnLikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'btr ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16 ; BTR

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB4:
    If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        Mov D$edi 'Mov ', D$edi+4 'ah  ' | add edi 7 | Call WriteImm8

    Else     ; 0F B4 > LFS r16,m16:16 ; LFS r32,m16:32
        inc D$UnLikelyCode
        Mov D$edi 'lfs ' | add edi 4 | Call Dis_r32_r16__rm32_rm16
        Mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB5:
    If B$EscapePrefix = &FALSE
        Mov D$edi 'Mov ', D$edi+4 'ch  ' | add edi 7 | Call WriteImm8

    Else     ; LGS r16,m16:16 ; LGS r32,m16:32
        inc D$UnLikelyCode
        Mov D$edi 'lgs ' | add edi 4 | Call Dis_r32_r16__rm32_rm16
        Mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB6:
    If B$EscapePrefix = &FALSE
        Mov D$edi 'Mov ', D$edi+4 'dh  ' | add edi 7 | Call WriteImm8

    Else        ; 0F B6 /r MOVZX r16,r/m8 ; 0F B6 /r MOVZX r32,r/m8
        inc D$LikelyCode
        Mov D$edi 'movz', W$edi+4 'x ' | add edi 6 | jmp Dis_r32_r16__rm8

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB7:
    If B$EscapePrefix = &FALSE
        Mov D$edi 'Mov ', D$edi+4 'bh  ' | add edi 7 | Call WriteImm8

    Else        ; 0F B7 /r MOVZX r32,r/m16
        inc D$LikelyCode
        Mov D$edi 'movz', W$edi+4 'x ' | add edi 6 | jmp Dis_r32_rm16

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB8:
    inc D$LikelyCode
    If B$OperandSizeOverride = &FALSE
        Mov D$edi 'Mov ', D$edi+4 'eax ' | add edi 8 | Call WriteImm32
    Else
        Mov D$edi 'Mov ', D$edi+4 'ax  ' | add edi 7 | Call WriteImm16
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB9:
    inc D$LikelyCode
    If B$OperandSizeOverride = &FALSE
        Mov D$edi 'Mov ', D$edi+4 'ecx ' | add edi 8 | Call WriteImm32

    Else
        Mov D$edi 'Mov ', D$edi+4 'cx  ' | add edi 7 | Call WriteImm16

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpBA:
    .If B$EscapePrefix = &TRUE
        movzx ebx B$esi | inc esi | DigitMask bl to al

        If al = 4
            Mov D$edi 'bt  ' | add edi 3 ; bts, ...
        Else_If al = 5
            Mov B$LockPrefix &FALSE
            Mov D$edi 'bts ' | add edi 4
        Else_If al = 6
            Mov B$LockPrefix &FALSE
            Mov D$edi 'btr ' | add edi 4
        Else_If al = 7
            Mov B$LockPrefix &FALSE
            Mov D$edi 'btc ' | add edi 4
        Else
            dec esi | ret
        End_If
        jmp Dis_rm32_rm16__imm8

    .Else
        inc D$LikelyCode
        If B$OperandSizeOverride = &FALSE
            Mov D$edi 'Mov ', D$edi+4 'edx ' | add edi 8 | Call WriteImm32
        Else
            Mov D$edi 'Mov ', D$edi+4 'dx  ' | add edi 7 | Call WriteImm16
        End_If

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpBB:
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'btc ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16 ; BTC

    .Else
        inc D$LikelyCode
        If B$OperandSizeOverride = &FALSE
            Mov D$edi 'Mov ', D$edi+4 'ebx ' | add edi 8 | Call WriteImm32
        Else
            Mov D$edi 'Mov ', D$edi+4 'bx  ' | add edi 7 | Call WriteImm16
        End_If

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpBC:
    .If B$EscapePrefix = &TRUE
        Mov D$edi 'bsf ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16 ; bsf

    .Else
        If B$OperandSizeOverride = &FALSE
            Mov D$edi 'Mov ', D$edi+4 'esp ' | add edi 8 | Call WriteImm32
        Else
            inc D$UnLikelyCode
            Mov D$edi 'Mov ', D$edi+4 'sp  ' | add edi 7 | Call WriteImm16
        End_If

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpBD:
    .If B$EscapePrefix = &TRUE
        Mov D$edi 'bsr ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16 ; bsr

    .Else
        If B$OperandSizeOverride = &FALSE
            Mov D$edi 'Mov ', D$edi+4 'ebp ' | add edi 8 | Call WriteImm32
        Else
            inc D$UnLikelyCode
            Mov D$edi 'Mov ', D$edi+4 'bp  ' | add edi 7 | Call WriteImm16
        End_If

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpBE:
    inc D$LikelyCode
    .If B$EscapePrefix = &FALSE
        If B$OperandSizeOverride = &FALSE
            Mov D$edi 'Mov ', D$edi+4 'esi ' | add edi 8 | Call WriteImm32
        Else
            Mov D$edi 'Mov ', D$edi+4 'si  ' | add edi 7 | Call WriteImm16
        End_If

    .Else
      ; 0F BE ¯r MOVSX r32,r/m8  ; 0F BE /r MOVSX r16,r/m8
        Mov D$edi 'movs', W$edi+4 'x ' | add edi 6 | jmp Dis_r32_r16__rm8

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpBF:
    inc D$LikelyCode
    .If B$EscapePrefix = &FALSE
        If B$OperandSizeOverride = &FALSE
            Mov D$edi 'Mov ', D$edi+4 'edi ' | add edi 8
            Call WriteImm32
        Else
            Mov D$edi 'Mov ', D$edi+4 'di  ' | add edi 7
            Call WriteImm16
        End_If

    .Else       ; 0F BF /r MOVSX r32,r/m16
        Mov D$edi 'movs', W$edi+4 'x ' | add edi 6 | jmp Dis_r32_rm16

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpC0:
    .If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        Mov bl B$esi | inc esi | DigitMask bl to al

        If al = 0   ; C0 /0 ib ROL r/m8, imm8
            Mov D$edi 'rol '
        Else_If al = 1  ; C0 /1 ib ROR r/m8, imm8
            Mov D$edi 'ror '
        Else_If al = 2  ; C0 /2 ib RCL r/m8, imm8
            Mov D$edi 'rcl '
        Else_If al = 3  ; C0 /3 ib RCR r/m8, imm8
            Mov D$edi 'rcr '
        Else_If al = 4   ; C0 /4 ib SAL r/m8,imm8   ; C0 /4 ib SHL r/m8,imm8
            Mov D$edi 'shl '
        Else_If al = 5  ; C0 /5 ib SHR r/m8,imm8
           Mov D$edi 'shr '
        Else_If al = 7  ; C0 /7 ib SAR r/m8,imm8
            Mov D$edi 'sar '
        Else
            dec esi | ret
        End_If

        add edi 4 | jmp Dis_rm8_imm8

    .Else   ; 0F C0 /r XADD r/m8, r8
        Mov B$LockPrefix &FALSE
        Mov D$edi 'xadd', B$edi+4 SPC | add edi 5 | jmp Dis_rm8_r8

    .End_If


OpC1:
    .If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        movzx ebx B$esi | inc esi | DigitMask bl to al

        If al = 0   ; C1 /0 ib ROL r/m16, imm8  C1 /0 ib ROL r/m32, imm8
            Mov D$edi 'rol '
        Else_If al = 1    ; C1 /1 ib ROR r/m16, imm8    ; C1 /1 ib ROR r/m32, imm8
            Mov D$edi 'ror '
        Else_If al = 2    ; C1 /2 ib RCL r/m16, imm8 ; C1 /2 ib RCL r/m32,i mm8
            Mov D$edi 'rcl '
        Else_If al = 3  ; C1 /3 ib RCR r/m16, imm8  C1 /3 ib RCR r/m32, imm8
            Mov D$edi 'rcr '
        Else_If al = 4  ; C1 /4 ib SAL r/m16,imm8   ; C1 /4 ib SAL r/m32,imm8 ; C1 /4 ib SHL r/m32,imm8  ; C1 /4 ib SHL r/m16,imm8
            Mov D$edi 'shl '
        Else_If al = 5  ; C1 /5 ib SHR r/m16,imm8   ; C1 /5 ib SHR r/m32,imm8
            Mov D$edi 'shr '
        Else_If al = 7  ; C1 /7 ib SAR r/m16,imm8   ; C1 /7 ib SAR r/m32,imm8
            Mov D$edi 'sar '
        Else
            dec esi | ret
        End_If

        add edi 4 | jmp Dis_rm32_rm16__imm8

    .Else   ; 0F C1 /r XADD r/m16, r16 ; 0F C1 /r XADD r/m32, r32
        Mov B$LockPrefix &FALSE
        Mov D$edi 'xadd', B$edi+4 SPC | add edi 5 | jmp Dis_rm32_rm16__r32_r16

    .End_If


OpC2:
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        Mov D$edi 'cmp_'
        If B$OperandSizeOverride = &TRUE
          ; 66 0F C2 /r ib CMPPD xmm1, xmm2/m128, imm8
          ; 66 0F C2 _1D_ 010 34 42 00 01
            Call MarkSSEdata SSE_2_R    ; CMPPD 66 0F C2 /r ib
            Mov D$edi+4 'pd  '
        Else
          ; cmpps xmm1, xmm2/m128, imm8
            Call MarkSSEdata SSE_4_F    ; CMPPS 0F C2 /r ib
            Mov D$edi+4 'ps  '
        End_If

        add edi 7
        Call Dis_xmm1__xmm2_m128 | jmp WritePacketCondition

    .Else       ; C2 iw RET imm16
        inc D$LikelyCode
        Mov D$edi 'ret ' | add edi 4 | Call WriteImm16
        Mov al CR | stosb | Mov al LF | stosb
        Mov B$DisEndOfChunk &TRUE

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpC3:
    If B$EscapePrefix = &FALSE  ; C3 RET
        inc D$LikelyCode
        Mov D$edi 'ret ' | add edi 3
        Mov al CR | stosb | Mov al LF | stosb
        Mov B$DisEndOfChunk &TRUE

    Else        ; 0F C3 /r MOVNTI m32, r32
        ;inc D$UnLikelyCode
        Mov D$edi 'movn', D$edi+4 'ti  ' | add edi 7 | jmp Dis_m32_r32

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpC4:
    .If B$EscapePrefix = &TRUE
      ; 66 0F C4 /r ib PINSRW xmm, r32/m16, imm8 ; 0F C4 /r ib PINSRW mm, r32/m16, imm8
        Mov D$edi 'pins', D$edi+4 'rw  ' | add edi 7
        jmp Dis_PINSRW

    .Else        ; LES r16,m16:16 ; LES r32,m16:32
        Mov D$edi 'les ' | add edi 4 | Call Dis_r32_r16__rm32_rm16
        Mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8
        inc D$UnLikelyCode

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpC5:
    .If B$EscapePrefix = &TRUE
      ; 66 0F C5 /r ib PEXTRW r32, xmm, imm8 ; 0F C5 /r ib PEXTRW r32, mm, imm8
        Mov D$edi 'pext', D$edi+4 'rw  ' | add edi 7
        jmp Dis_r32_xmmx_imm8
       ; Call Dis_r32_xmmx | Mov B$edi SPC | inc edi | Call Writeimm8
;Dis_xmmx_r32
    .Else        ; LDS r16,m16:16
        inc D$UnLikelyCode
        Mov D$edi 'lds ' | add edi 4 | Call Dis_r32_r16__rm32_rm16
        Mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpC6:
    ..If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
      ; 66 0F C6 /r ib SHUFPD xmm1, xmm2/m128, imm8 ; 0F C6 /r ib SHUFPS xmm1, xmm2/m128, imm8
        Mov D$edi 'shuf'
        If B$OperandSizeOverride = &TRUE
            Call MarkSSEdata SSE_2_R
            Mov D$edi+4 'pd  '
        Else
            Call MarkSSEdata SSE_4_F
            Mov D$edi+4 'ps  '
        End_If
        add edi 7 | jmp Dis_xmm1__xmm2_m128__imm8

    ..Else
        Mov bl B$esi | inc esi | DigitMask bl To al

        If al = 0     ; Mov r/m8,imm8
            inc D$LikelyCode
            Mov D$edi 'Mov ' | add edi 4 | jmp Dis_rm8_imm8
        Else
            dec esi | ret
        End_If

    ..End_If


OpC7:
    movzx ebx B$esi | inc esi | DigitMask bl to al

    .If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        If al = 0       ; Mov r/m32,imm32 ; Mov r/m16,imm16
            Mov B$MovOrJmpImmInstruction &TRUE
            Mov D$edi 'Mov ' | add edi 4 | jmp Dis_rm32_rm16__imm32_imm16
        End_If

    .Else    ; 0F C7 /1 m64 CMPXCHG8B m64
        If al = 1
            ;inc D$UnLikelyCode
            Mov B$LockPrefix &FALSE
            Mov D$edi 'cmpx', D$edi+4 'chg8', W$edi+8 'b ' | add edi 10 | jmp Dis_m64
        End_If

    .End_If

    dec esi
ret


OpC8:
    .If B$EscapePrefix = &FALSE ; ENTER imm16,imm8
        Mov D$edi 'ente', W$edi+4 'r ' | add edi 6
      ; Enter Max is 0FFFC and must be 4 Bytes Aligned:
        If W$esi > 0FFFC
            add D$UnlikelyCode 5
        Else
            test W$esi 00_11 ZERO L1>
                add D$UnlikelyCode 5
        End_If

L1:     On B$esi+2 > 31, add D$UnlikelyCode 5
        Call WriteImm16 | Mov B$edi SPC | inc edi
        Call WriteImm8

    .Else
        Mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'eax ' | add edi 9

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpC9:
    If B$EscapePrefix = &FALSE
        Mov D$edi 'leav', B$edi+4 'e' | add edi 5

    Else
        Mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'ecx ' | add edi 9

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpCA:
    If B$EscapePrefix = &FALSE        ; CA iw RET imm16
        inc D$UnLikelyCode
        Mov D$edi 'retf', B$edi+4 SPC | add edi 5 | Call WriteImm16
        Mov B$DisEndOfChunk &TRUE

    Else
        Mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'edx ' | add edi 9

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpCB:
    If B$EscapePrefix = &FALSE        ; CB RET
        inc D$UnLikelyCode
        Mov D$edi 'retF' | add edi 4
        Mov B$DisEndOfChunk &TRUE

    Else
        Mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'ebx ' | add edi 9

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpCC:
    .If B$EscapePrefix = &TRUE
        inc D$UnLikelyCode
        Mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'esp ' | add edi 9

    .Else        ; INT 3
        Mov D$edi 'int ', B$edi+4 '3' | add edi 5
        If B$No0CC = &FALSE
            Mov B$DisEndOfChunk &TRUE
        Else
            inc D$UnLikelyCode
        End_If

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpCD:
    If B$EscapePrefix = &TRUE
        Mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'ebp ' | add edi 9

    Else        ; INT imm8
        inc D$UnLikelyCode
        Mov D$edi 'int ' | add edi 4 | Call WriteImm8

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpCE:
    If B$EscapePrefix = &TRUE
        Mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'esi ' | add edi 9

    Else        ; INTO
        inc D$UnLikelyCode
        Mov D$edi 'into' | add edi 4

    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpCF:
    .If B$EscapePrefix = &TRUE
        Mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'edi ' | add edi 9

    .Else       ; IRET IRETD
        inc D$UnLikelyCode
        Mov D$edi 'iret' | add edi 4
        If B$OperandSizeOverride = &FALSE
            Mov B$edi 'd' | inc edi
        End_If

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpD0:
    inc D$LikelyCode
    Mov bl B$esi | inc esi | DigitMask bl To al

    If al = 0       ; D0 /0 ROL r/m8, 1
        Mov D$edi 'rol '
    Else_If al = 1  ; D0 /1 ROR r/m8, 1
        Mov D$edi 'ror '
    Else_If al = 2  ; D0 /2 RCL r/m8, 1
        Mov D$edi 'rcl '
    Else_If al = 3  ; D0 /3 RCR r/m8, 1
        Mov D$edi 'rcr '
    Else_If al = 4  ; D0 /4 SAL r/m8,1  ; D0 /4 SHL r/m8,1
        Mov D$edi 'shl '
    Else_If al = 5  ; D0 /5 SHR r/m8,1
        Mov D$edi 'shr '
    Else_If al = 7  ; D0 /7 SAR r/m8,1
        Mov D$edi 'sar '
    Else
        dec esi | ret
    End_If

    add edi 4 | jmp Dis_rm8_1



OpD1:
    .If B$EscapePrefix = &TRUE ; Op0F
        ;inc D$UnLikelyCode
      ; 0F D1 /r PSRLW mm, mm/m64       ; 66 0F D1 /r PSRLW xmm1, xmm2/m128
        If B$esi-3 <> 0F
            Mov D$edi 'psrl', W$edi+4 'w ' | add edi 6
            jmp MMX6428
        End_If

    .Else
        inc D$LikelyCode
        Mov bl B$esi | inc esi | DigitMask bl To al

        If al = 0   ; D1 /0 ROL r/m16, 1    D1 /0 ROL r/m32, 1
            Mov D$edi 'rol '
        Else_If al = 1   ; D1 /1 ROR r/m16, 1   ; D1 /1 ROR r/m32, 1
            Mov D$edi 'ror '
        Else_If al = 2   ; D1 /2 RCL r/m16, 1 D1 /2 RCL r/m32, 1
            Mov D$edi 'rcl '
        Else_If al = 3  ; D1 /3 RCR r/m16, 1    ; D1 /3 RCR r/m32, 1
            Mov D$edi 'rcr '
        Else_If al = 4  ; D1 /4 SAL r/m16,1 ; D1 /4 SAL r/m32,1 ; D1 /4 SHL r/m16,1; D1 /4 SHL r/m32,1
            Mov D$edi 'shl '
        Else_If al = 5  ; D1 /5 SHR r/m16,1 ; D1 /5 SHR r/m32,1
            Mov D$edi 'shr '
        Else_If al = 7  ; D1 /7 SAR r/m16,1 ; D1 /7 SAR r/m32,1
            Mov D$edi 'sar '
        Else
            dec esi | ret
        End_If

        add edi 4 | jmp Dis_rm32_rm16__1

    .End_If


OpD2:
    .If B$EscapePrefix = &TRUE
      ; 0F D2 /r PSRLD mm, mm/m64   ; 66 0F D2 /r PSRLD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'psrl', W$edi+4 'd ' | add edi 6
        jmp MMX6428

    .Else
        inc D$LikelyCode
        Mov bl B$esi | inc esi | DigitMask bl to al

        If al = 0       ; D2 /0 ROL r/m8, CL
            Mov D$edi 'rol '
        Else_If al = 1      ;     D2 /1 ROR r/m8, CL
             Mov D$edi 'ror '
        Else_If al = 2      ; D2 /2 RCL r/m8, CL
            Mov D$edi 'rcl '
        Else_If al = 3 ; D2 /3 RCR r/m8, CL
            Mov D$edi 'rcr '
        Else_If al = 4   ; D2 /4 SAL r/m8,CL    ; D2 /4 SHL r/m8,CL
            Mov D$edi 'shl '
        Else_If al = 5  ; D2 /5 SHR r/m8,CL
            Mov D$edi 'shr '
        Else_If al = 7  ; D2 /7 SAR r/m8,CL
            Mov D$edi 'sar '
        Else
            dec esi | ret
        End_If

        add edi 4 | jmp Dis_rm8_cl

    .End_If


OpD3:
    .If B$EscapePrefix = &TRUE
      ; 0F D3 /r PSRLQ mm, mm/m64   ; 66 0F D3 /r PSRLQ xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'psrl', W$edi+4 'q ' | add edi 6
        jmp MMX6428

    .Else
        inc D$LikelyCode
        Mov bl B$esi | inc esi | DigitMask bl to al

        If al = 0   ; D3 /0 ROL r/m16, CL   D3 /0 ROL r/m32, CL
            Mov D$edi 'rol '
        Else_If al = 1      ; D3 /1 ROR r/m16, CL    ; D3 /1 ROR r/m32, CL
            Mov D$edi 'ror '
        Else_If al = 2      ; D3 /2 RCL r/m16, CL    D3 /2 RCL r/m32, CL
            Mov D$edi 'rcl '
        Else_If al = 3  ; D3 /3 RCR r/m16, CL   D3 /3 RCR r/m32, CL
            Mov D$edi 'rcr '
        Else_If al = 4  ; D3 /4 SAL r/m16,CL    ; D3 /4 SAL r/m32,CL  ;D3 /4 SHL r/m32,CL  ; D3 /4 SHL r/m16,CL
            Mov D$edi 'shl '
        Else_If al = 5  ; D3 /5 SHR r/m16,CL    ; D3 /5 SHR r/m32,CL
            Mov D$edi 'shr '
        Else_If al = 7  ; D3 /7 SAR r/m16,CL    ; D3 /7 SAR r/m32,CL
            Mov D$edi 'sar '
        Else
            dec esi | ret
        End_If

        add edi 4 | jmp Dis_rm32_rm16__cl

    .End_If


OpD4:
    .If B$EscapePrefix = &TRUE
        ; 66 0F D4 /r PADDQ xmm1,xmm2/m128       ; 0F D4 /r PADDQ mm1,mm2/m64
        ;inc D$UnLikelyCode
        Mov D$edi 'padd', W$edi+4 'q ' | add edi 6
        jmp MMX6428

    .Else
        Mov D$edi 'aam ', B$DisFlag DISDONE+DISLINEOVER | add edi 4
        lodsb
        If al <> 0A
            Call LoadedOpToHexa | stosw
        End_If

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpD5:
    .If B$EscapePrefix = &TRUE
      ; 0F D5 /r PMULLW mm, mm/m64      ; 66 0F D5 /r PMULLW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'pmul', D$edi+4 'lw  ' | add edi 7
        jmp MMX6428

    .Else
        Mov D$edi 'aad ', B$DisFlag DISDONE+DISLINEOVER | add edi 4
        lodsb
        If al <> 0A
            Call loadedOpToHexa | stosw
        End_If

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER

ret


OpD6:
    .If B$EscapePrefix = &TRUE
        If B$OperandSizeOverride = &TRUE    ; 66 0F D6 MOVQ xmm2/m64, xmm1
            Mov D$edi 'movq', B$edi+4 SPC | add edi 5 | jmp Dis_xmm2_m64__xmm1
        End_If
    .Else
        Mov D$edi 'salc'  | add edi 4
        Mov B$DisFlag DISDONE+DISLINEOVER
    .End_If
ret


OpD7:
    ;inc D$UnLikelyCode
    .If B$EscapePrefix = &TRUE
      ; 66 0F D7 /r PMOVMSKB r32, xmm ; 0F D7 /r PMOVMSKB r32, mm
        Mov D$edi 'pmov', D$edi+4 'mskb', B$edi+8 SPC | add edi 9 | jmp Dis_r32_xmmx

    .Else       ; D7 XLATB
        Mov D$edi 'xlat', B$edi+4 'b' | add edi 5

    .End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpD8:
    ..If B$EscapePrefix = &TRUE
      ; 0F D8 /r PSUBUSB mm, mm/m64 ; 66 0F D8 /r PSUBUSB xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'psub', D$edi+4 'usb ' | add edi 8
        jmp MMX6428

    ..Else
        Mov bl B$esi | inc esi | DigitMask bl To al

        .If al = 0          ; D8 /0 FADD m32fp ; D8 C0+i FADD ST(0), ST(i)
            Mov D$edi 'fadd', B$edi+4 SPC | add edi 5
        .Else_If al = 1     ; D8 /1 FMUL m32fp ; D8 C8+i FMUL ST(0), ST(i)
            Mov D$edi 'fmul', B$edi+4 SPC | add edi 5
        .Else_If al = 2  ; FCOM m32fp ; FCOM ST(i)
            Mov D$edi 'fcom', B$edi+4 SPC | add edi 5
        .Else_If al = 3     ; FCOMP m32fp; FCOMP ST(i)
           Mov D$edi 'fcom', W$edi+4 'p ' | add edi 6
        .Else_If al = 4     ; FSUB m32fp ; FSUB ST(0), ST(i)
            Mov D$edi 'fsub', B$edi+4 SPC | add edi 5
        .Else_If al = 5     ; FSUBR m32fp ; FSUBR ST(0), ST(i)
            Mov D$edi 'fsub', W$edi+4 'r ' | add edi 6
        .Else_If al = 6     ; FDIV m32fp ; FDIV ST(0), ST(i)
            Mov D$edi 'fdiv', B$edi+4 SPC | add edi 5
        .Else_If al = 7     ; FDIVR m32fp ; FDIVR ST(0), ST(i)
            Mov D$edi 'fdiv', W$edi+4 'r ' | add edi 6
        .End_If

        jmp Dis_St0Sti_or_Fmem

    ..End_If
ret


OpD9:
    If B$EscapePrefix = &TRUE
      ; 0F D9 /r PSUBUSW mm, mm/m64     ; 66 0F D9 /r PSUBUSW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'psub', D$edi+4 'usw ' | add edi 8
        jmp MMX6428
    End_If

    Mov bl B$esi | inc esi | ModMask bl to al  ; 0EE 0011_101_110

    ..If al = 3
        Mov al bl
        .If al = 0E4       ; D9 E4 FTST
            Mov D$edi 'ftst' | add edi 4
        .Else_If al = 0E5  ; FXAM
            Mov D$edi 'fxam' | add edi 4
        .Else_If al = 0F0  ; F2XM1
            Mov D$edi 'f2xm', B$edi+4 '1' | add edi 5
        .Else_If al = 0F1  ; FYL2X
            Mov D$edi 'fyl2', B$edi+4 'x' | add edi 5
        .Else_If al = 0F2  ; FPTAN
            Mov D$edi 'fpta', B$edi+4 'n' | add edi 5
        .Else_If al = 0F3  ; FPATAN
            Mov D$edi 'fpat', W$edi+4 'an' | add edi 6
        .Else_If al = 0F4  ; FXTRACT
            Mov D$edi 'fxtr', D$edi+4 'act ' | add edi 7
        .Else_If al = 0F5  ; FPREM1
            Mov D$edi 'fpre', W$edi+4 'm1' | add edi 6
        .Else_If al = 0F8  ; FPREM
            Mov D$edi 'fpre', B$edi+4 'm' | add edi 5
        .Else_If al = 0F9  ; FYL2XP1
            Mov D$edi 'fyl2', D$edi+4 'xp1 ' | add edi 7
        .Else_If al = 0FA  ; FSQRT
            Mov D$edi 'fsqr', B$edi+4 't' | add edi 5
        .Else_If al = 0FB  ; FSINCOS
            Mov D$edi 'fsin', D$edi+4 'cos ' | add edi 7
        .Else_If al = 0FC  ; FRNDINT
            Mov D$edi 'frnd', D$edi+4 'int ' | add edi 7
        .Else_If al = 0FD  ; FSCALE
            Mov D$edi 'fsca', W$edi+4 'le' | add edi 6
        .Else_If al = 0FE  ; FSIN
            Mov D$edi 'fsin' | add edi 4
        .Else_If al = 0D0  ; FNOP
            Mov D$edi 'fnop' | add edi 4
        .Else_If al = 0E1  ; FABS
            Mov D$edi 'fabs' | add edi 4
        .Else_If al = 0E0  ; FCHS
            Mov D$edi 'fchs' | add edi 4
        .Else_If al = 0E8  ; FLD1
            Mov D$edi 'fld1' | add edi 4
        .Else_If al = 0E9  ; FLDL2T
            Mov D$edi 'fldl', W$edi+4 '2t' | add edi 6
        .Else_If al = 0EA  ; FLDL2E
            Mov D$edi 'fldl', W$edi+4 '2e' | add edi 6
        .Else_If al = 0EB  ; FLDPI
            Mov D$edi 'fldp', B$edi+4 'i' | add edi 5
        .Else_If al = 0EC  ; FLDLG2
            Mov D$edi 'fldl', W$edi+4 'g2' | add edi 6
        .Else_If al = 0ED  ; FLDLN2
            Mov D$edi 'fldl', W$edi+4 'n2' | add edi 6
        .Else_If al = 0EE  ; FLDZ
            Mov D$edi 'fldz' | add edi 4
        .Else_If al = 0F6  ; FDECSTP
            Mov D$edi 'fdec', D$edi+4 'stp ' | add edi 7
        .Else_If al = 0F7  ; FINCSTP
            Mov D$edi 'finc', D$edi+4 'stp ' | add edi 7
        .Else_If al = 0FF  ; FCOS
            Mov D$edi 'fcos' | add edi 4
        .Else
            and eax (not 7)
            If al = 0C0         ; D9 C0+i > FLD ST(i)
                Mov D$edi 'fld ' | add edi 4
            Else_If al = 0C8    ; D9 C8+i FXCH ST(i)
                Mov D$edi 'fxch', B$edi+4 SPC | add edi 5
            Else
                inc D$UnLikelyCode | dec esi | ret
            End_If

            Call WriteSti

        .End_If

    ..Else
        DigitMask bl To al ; 0EE

        .If al = 0            ; D9 /0 > FLD m32fp
            Mov D$edi 'fld ' | add edi 4 | jmp EndWith.F.mem
        .Else_If al = 2       ; FST m32fp
            Mov D$edi 'fst ' | add edi 4 | jmp EndWith.F.mem
        .Else_If al = 3       ; FSTP m32fp
            Mov D$edi 'fstp', B$edi+4 SPC | add edi 5 | jmp EndWith.F.mem
        .Else_If al = 4       ; FLDENV m14/28byte
            Mov D$edi 'flde', D$edi+4 'nv  ' | add edi 7 | jmp EndWith.X.mem
        .Else_If al = 5       ; D9 /5 > FLDCW m2byte
            Mov D$edi 'fldc', W$edi+4 'w ' | add edi 6
        .Else_If al = 6       ; D9 /6FNSTENV* m14/28byte
            Mov D$edi 'fnst', D$edi+4 'env ' | add edi 8 | jmp EndWith.X.mem
        .Else_If al = 7       ; D9 /7 > FNSTCW m2byte
            Mov D$edi 'fnst', D$edi+4 'cw  ' | add edi 7
        .Else
            inc D$UnLikelyCode | dec esi | ret
        .End_If

        jmp EndWith.W.mem

    ..End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpDA:
    If B$EscapePrefix = &TRUE
      ; 0F DA /r PMINUB mm1, mm2/m64      ; 66 0F DA /r PMINUB xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'pmin', D$edi+4 'ub  ' | add edi 7
        jmp MMX6428
    End_If

    Mov bl B$esi | inc esi | ModMask bl to al

    ..If al = 3
        Mov al bl

        .If al = 0E9     ; FUCOMPP
            Mov D$edi 'fuco', D$edi+4 'mpp ' | add edi 7
            Mov B$DisFlag DISDONE+DISLINEOVER | ret

        .Else
            and eax (not 7)
            If al = 0C0         ; DA C0+i : FCMOVB ST(0), ST(i)
                Mov D$edi 'fcmo', D$edi+4 'vb  ' | add edi 7
            Else_If al = 0C8    ; FCMOVE ST(0), ST(i)
                Mov D$edi 'fcmo', D$edi+4 've  ' | add edi 7
            Else_If al = 0D0    ; FCMOVBE ST(0), ST(i)
                Mov D$edi 'fcmo', D$edi+4 'vbe ' | add edi 8
            Else_If al = 0D8    ; FCMOVU ST(0), ST(i)
                Mov D$edi 'fcmo', D$edi+4 'vu  ' | add edi 7
            Else
                inc D$UnLikelyCode | dec esi | ret
            End_If

        .End_If

        Call WriteSt0Sti

    ..Else
        DigitMask bl To al

        .If al = 0          ; FIADD m32int
            Mov D$edi 'fiad', W$edi+4 'd ' | add edi 6
        .Else_If al = 1     ; FIMUL m32int
            Mov D$edi 'fimu', W$edi+4 'l ' | add edi 6
        .Else_If al = 2     ; FICOM m32int
            Mov D$edi 'fico', W$edi+4 'm ' | add edi 6
        .Else_If al = 3     ; FICOMP m32int
            Mov D$edi 'fico', D$edi+4 'mp  ' | add edi 7
        .Else_If al = 4     ; FISUB m32int
            Mov D$edi 'fisu', W$edi+4 'b ' | add edi 6
        .Else_If al = 5     ; FISUBR m32int
            Mov D$edi 'fisu', D$edi+4 'br  ' | add edi 7
        .Else_If al = 6     ; FIDIV m32int
            Mov D$edi 'fidi', W$edi+4 'v ' | add edi 6
        .Else_If al = 7     ; FIDIVR m32int
            Mov D$edi 'fidi', D$edi+4 'vr  ' | add edi 7
        .End_If

        jmp EndWith.D.mem

    ..End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret




OpDB:
    If B$EscapePrefix = &TRUE
        ; 66 0F DB /r PAND xmm1, xmm2/m128      ; 0F DB /r PAND mm, mm/m64
        Mov D$edi 'pand', B$edi+4 SPC | add edi 5
        jmp MMX6428
    End_If

    Mov bl B$esi | inc esi | ModMask bl to al

    ..If al = 3
        Mov al bl

        If al = 0E3      ; DB E3 FNINIT >>> E3 DigitBit = 4
            Mov D$edi 'fnin', D$edi+4 'it  '
L0:         add edi 6 | Mov B$DisFlag DISDONE+DISLINEOVER | ret
        Else_If al = 0E2    ; DB E2 FNCLEX*
            Mov D$edi 'fncl', D$edi+4 'ex  ' | jmp L0<
        End_If

        and eax (not 7)

        .If al = 0C0        ; DA C0+i : FCMOVNB ST(0), ST(i)
            Mov D$edi 'fcmo', D$edi+4 'vnb ' | add edi 8
        .Else_If al = 0C8   ; FCMOVNE ST(0), ST(i)
            Mov D$edi 'fcmo', D$edi+4 'vne ' | add edi 8
        .Else_If al = 0D0   ; FCMOVNBE ST(0), ST(i)
            Mov D$edi 'fcmo', D$edi+4 'vnbe', B$edi+8 SPC | add edi 9
        .Else_If al = 0D8   ; FCMOVNU ST(0), ST(i)
            Mov D$edi 'fcmo', D$edi+4 'vnu ' | add edi 8
        .Else_If al = 0E8   ; FUCOMI ST, ST(i)
            Mov D$edi 'fuco', D$edi+4 'mi  ' | add edi 7
        .Else_If al = 0F0   ; FCOMI ST, ST(i)
            Mov D$edi 'fcom', W$edi+4 'i ' | add edi 6
        .Else
            inc D$UnLikelyCode | dec esi | ret
        .End_If

        Call WriteSt0Sti

    ..Else
        DigitMask bl To al

        .If al = 0     ; FILD m32int
            Mov D$edi 'fild', B$edi+4 SPC | add edi 5 | jmp EndWith.D.mem
        .Else_If al = 1        ; FISTTP  DB /1 FISTTP m32int
            Mov D$edi 'fist', D$edi+4 'tp ' | add edi 7 | jmp EndWith.D.mem
        .Else_If al = 2        ; FIST m32int
            Mov D$edi 'fist', B$edi+4 SPC | add edi 5 | jmp EndWith.D.mem
        .Else_If al = 3        ; FISTP m32int
            Mov D$edi 'fist', W$edi+4 'p ' | add edi 6 | jmp EndWith.D.mem
        .Else_If al = 5        ; FLD m80fp
            Mov D$edi 'fld ' | add edi 4 | jmp EndWith.T.mem
        .Else_If al = 7        ; FSTP m80fp
            Mov D$edi 'fstp', B$edi+4 SPC | add edi 5 | jmp EndWith.T.mem
        .Else
            inc D$UnLikelyCode | dec esi | ret
        .End_If

     ..End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpDC:
    If B$EscapePrefix = &TRUE
        ; 66 0F DC /r PADDUSB xmm1, xmm2/m128     ; 0F DC /r PADDUSB mm, mm/m64
        ;inc D$UnLikelyCode
        Mov D$edi 'padd', D$edi+4 'usb ' | add edi 8
        jmp MMX6428
    End_If

    Mov bl B$esi | inc esi | ModMask bl to al

    ..If al = 3
        Mov al bl | and eax (not 7)

        If al = 0C0             ; FADD ST(i), ST(0)
            Mov D$edi 'fadd', B$edi+4 SPC | add edi 5
        Else_If al = 0C8        ; FMUL ST(i), ST(0)
            Mov D$edi 'fmul', B$edi+4 SPC | add edi 5
        Else_If al = 0E0        ; FSUBR ST(i), ST(0)
            Mov D$edi 'fsub', W$edi+4 'r ' | add edi 6  ; fsubr
        Else_If al = 0E8        ; FSUB ST(i), ST(0)
            Mov D$edi 'fsub', B$edi+4 SPC | add edi 5
        Else_If al = 0F0        ; FDIVR ST(i), ST(0)
            Mov D$edi 'fdiv', W$edi+4 'r ' | add edi 6
        Else_If al = 0F8        ; FDIV ST(i), ST(0)
            Mov D$edi 'fdiv', B$edi+4 SPC | add edi 5
        Else
            inc D$UnLikelyCode | dec esi | ret
        End_If

        Call WriteStiSt0

    ..Else
        DigitMask bl To al

        .If al = 0          ; FADD m64fp
            Mov D$edi 'fadd', B$edi+4 SPC | add edi 5
        .Else_If al = 1     ; FMUL m64fp
            Mov D$edi 'fmul', B$edi+4 SPC | add edi 5
        .Else_If al = 2     ; FCOM m64fp
            Mov D$edi 'fcom', B$edi+4 SPC | add edi 5
        .Else_If al = 3     ; FCOMP m64fp
            Mov D$edi 'fcom', W$edi+4 'p ' | add edi 6
        .Else_If al = 4     ; FSUB m64fp
            Mov D$edi 'fsub', B$edi+4 SPC | add edi 5
        .Else_If al = 5      ; FSUBR m64fp
            Mov D$edi 'fsub', W$edi+4 'r ' | add edi 6
        .Else_If al = 6     ; FDIV m64fp
            Mov D$edi 'fdiv', B$edi+4 SPC | add edi 5
        .Else_If al = 7     ; FDIVR m64fp
            Mov D$edi 'fdiv', W$edi+4 'r ' | add edi 6
        .End_If

        jmp EndWith.R.mem

    ..End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpDD:
    If B$EscapePrefix = &TRUE
        ; 66 0F DD /r PADDUSW xmm1, xmm2/m128     ; 0F DD /r PADDUSW mm, mm/m64
        Mov D$edi 'padd', D$edi+4 'usw ' | add edi 8
        jmp MMX6428
    End_If

    Mov bl B$esi | inc esi | ModMask bl to al

    ..If al = 3
        Mov al bl | and eax (not 7)

        If al = 0C0     ; C0+i :  FFREE ST(i)
            Mov D$edi 'ffre', W$edi+4 'e ' | add edi 6
        Else_If al = 0D0    ; FST ST(i)
            Mov D$edi 'fst ' | add edi 4
        Else_If al = 0D8        ; FSTP ST(i)
            Mov D$edi 'fstp', B$edi+4 SPC | add edi 5
        Else_If al = 0E0        ; FUCOM ST(i)
            Mov D$edi 'fuco', W$edi+4 'm ' | add edi 6
        Else_If al = 0E8        ; FUCOMP ST(i)
            Mov D$edi 'fuco', D$edi+4 'mp  ' | add edi 7
        Else
            inc D$UnLikelyCode | dec esi | ret
        End_If

        Call WriteSti

    ..Else
        DigitMask bl To al

        .If al = 0          ; FLD m64fp
            Mov D$edi 'fld ' | add edi 4 | jmp EndWith.R.mem
        .Else_If al = 1     ; FISTTP  DD /1 FISTTP m64int
            Mov D$edi 'fst ', D$edi+4 'tp '| add edi 7 | jmp EndWith.R.mem
        .Else_If al = 2     ; FST m64fp
            Mov D$edi 'fst ' | add edi 4 | jmp EndWith.R.mem
        .Else_If al = 3     ; FSTP m64fp
            Mov D$edi 'fstp', B$edi+4 SPC | add edi 5 | jmp EndWith.R.mem
        .Else_If al = 4     ; FRSTOR m94/108byte
            Mov D$edi 'frst', D$edi+4 'or  ' | add edi 7 | jmp EndWith.X.mem
        .Else_If al = 6     ; FNSAVE* m94/108byte
            Mov D$edi 'fnsa', D$edi+4 've  ' | add edi 7 | jmp EndWith.X.mem
        .Else_If al = 7     ; DD /7 FNSTSW* m2byte
            Mov D$edi 'fnst', D$edi+4 'sw  ' | add edi 7 | jmp EndWith.W.mem
        .Else
            inc D$UnLikelyCode | dec esi | ret
        .End_If

    ..End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpDE:
    If B$EscapePrefix = &TRUE
        ; 0F DE /r PMAXUB mm1, mm2/m64      ; 66 0F DE /r PMAXUB xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'pmax', D$edi+4 'ub  ' | add edi 7
        jmp MMX6428
    End_If

    Mov bl B$esi | inc esi | ModMask bl to al

    ...If al = 3
        Mov al bl

        .If al = 0D9        ; FCOMPP
            Mov D$edi 'fcom', W$edi+4 'pp' | add edi 6
        .Else_If al = 0E9   ; FSUBP
            Mov D$edi 'fsub', W$edi+4 'p ' | add edi 6
            Call WriteStiSt0
        .Else
            and eax (not 7)

            If al = 0C0             ; FADDP ST(0), ST(i)
                Mov D$edi 'fadd', W$edi+4 'p ' | add edi 6 | jmp WriteStiSt0
            Else_If al = 0C8        ; FMULP ST(i), ST(0)
                Mov D$edi 'fmul', W$edi+4 'p ' | add edi 6
            Else_If al = 0E0        ; FSUBRP ST(i), ST(0)
                Mov D$edi 'fsub', D$edi+4 'rp ' | add edi 7
            Else_If al = 0E8        ; FSUBP ST(i), ST(0)
                Mov D$edi 'fsub', W$edi+4 'p ' | add edi 6
            Else_If al = 0F0        ; FDIVRP ST(i), ST(0)
                Mov D$edi 'fdiv', D$edi+4 'rp ' | add edi 7
            Else_If al = 0F8        ; FDIVP ST(i), ST(0)
                Mov D$edi 'fdiv', W$edi+4 'p ' | add edi 6
            Else
                inc D$UnLikelyCode | dec esi | ret
            End_If

            Call WriteStiSt0

        .End_If

    ...Else
        DigitMask bl To al

        .If al = 0             ; FIADD m16int
            Mov D$edi 'fiad', W$edi+4 'd ' | add edi 6
        .Else_If al = 1        ; FIMUL m16int
            Mov D$edi 'fimu', W$edi+4 'l ' | add edi 6
        .Else_If al = 2        ; FICOM m16int
            Mov D$edi 'fico', W$edi+4 'm ' | add edi 6
        .Else_If al = 3        ; FICOMP m16int
            Mov D$edi 'fico', D$edi+4 'mp  ' | add edi 7
        .Else_If al = 4        ; FISUB m16int
            Mov D$edi 'fisu', W$edi+4 'b ' | add edi 6
        .Else_If al = 5        ; FISUBR m16int
             Mov D$edi 'fisu', D$edi+4 'br  ' | add edi 7
        .Else_If al = 6        ; FIDIV m16int
            Mov D$edi 'fidi', W$edi+4 'v ' | add edi 6
        .Else_If al = 7        ; FIDIVR m16int
            Mov D$edi 'fidi', D$edi+4 'vr  ' | add edi 7
        .End_If

        jmp EndWith.W.mem

    ...End_If

L9: Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpDF:
    If B$EscapePrefix = &TRUE
        ; 66 0F DF /r PANDN xmm1, xmm2/m128     ; 0F DF /r PANDN mm, mm/m64
        ;inc D$UnLikelyCode
        Mov D$edi 'pand', W$edi+4 'n ' | add edi 6
        jmp MMX6428
    End_If

    Mov bl B$esi | inc esi | ModMask bl to al

    ...If al = 3
        Mov al bl

        .If al = 0E0       ; DF E0 FNSTSW* AX
            Mov D$edi 'fnst', D$edi+4 'sw a', B$edi+8 'x' | add edi 9
        .Else
            and eax (not 7)

            If al = 0F0        ; FCOMIP ST, ST(i)
                Mov D$edi 'fcom', D$edi+4 'ip  ' | add edi 7
            Else_If al = 0C0
                Mov D$edi 'ffre', D$edi+4 'ep  ' | add edi 7 | jmp WriteSti
            Else_If al = 0E8       ; FUCOMIP ST, ST(i)
                Mov D$edi 'fuco', D$edi+4 'mip ' | add edi 8
            Else
                inc D$UnLikelyCode | dec esi | ret
            End_If

            jmp WriteSt0Sti

        .End_If

    ...Else
        DigitMask bl To al

        ..If al = 0     ; FILD m16int
            Mov D$edi 'fild', B$edi+4 SPC | add edi 5 | jmp EndWith.W.mem
        ..Else_If al = 1        ; FISTTP  DF /1 FISTTP m16int
            Mov D$edi 'fist', D$edi+4 'tp ' | add edi 7 | jmp EndWith.W.mem
        ..Else_If al = 2        ; FIST m16int
            Mov D$edi 'fist', B$edi+4 SPC | add edi 5 | jmp EndWith.W.mem
        ..Else_If al = 3        ; FISTP m16int
            Mov D$edi 'fist', W$edi+4 'p ' | add edi 6 | jmp EndWith.W.mem
        ..Else_If al = 4           ; /4 > FBLD m80 dec
            Mov D$edi 'fbld', B$edi+4 SPC | add edi 5 | jmp EndWith.T.mem
            ; This is an m80 Binary coded decimal chunk.
        ..Else_If al = 5        ; FILD m64int
            Mov D$edi 'fild', B$edi+4 SPC | add edi 5 | jmp EndWith.Q.mem
        ..Else_If al = 6      ; /6 > FBSTP m80bcd
            Mov D$edi 'fbst', W$edi+4 'p ' | add edi 6 | jmp EndWith.T.mem
            ; This is an m80 Binary coded decimal chunk.
        ..Else_If al = 7        ; FISTP m64int
            Mov D$edi 'fist', W$edi+4 'p ' | add edi 6 | jmp EndWith.Q.mem
        ..Else
            inc D$UnLikelyCode | dec esi | ret
        ..End_If
    ...End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpE0:
    If B$EscapePrefix = &TRUE
        ; 66 0F E0, /r PAVGB xmm1, xmm2/m128     ; 0F E0 /r PAVGB mm1, mm2/m64
        ;inc D$UnLikelyCode
        Mov D$edi 'pavg', W$edi+4 'b ' | add edi 6
        jmp MMX6428

    Else        ; LOOPNE rel8 ; LOOPNZ rel8
        inc D$LikelyCode
        Mov D$edi 'loop', D$edi+4 'ne  ' | add edi 7
        Mov B$CALLInstruction &TRUE
        test B$esi 080 NOT_ZERO L1>
            add D$UnLikelyCode 0FF
L1:     jmp EndWithDisByteRelativeBack

    End_If


OpE1:
    If B$EscapePrefix = &TRUE
      ; 0F E1 /r PSRAW mm, mm/m64       ; 66 0F E1 /r PSRAW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'psra', W$edi+4 'w ' | add edi 6
        jmp MMX6428

    Else       ;  ; LOOPE rel8 ; LOOPZ rel8
        inc D$LikelyCode
        Mov D$edi 'loop', W$edi+4 'e ' | add edi 6
        Mov B$CALLInstruction &TRUE
        test B$esi 080 NOT_ZERO L1>
            add D$UnLikelyCode 0FF
L1:     jmp EndWithDisByteRelativeBack

    End_If


OpE2:
    If B$EscapePrefix = &TRUE
      ; 0F E2 /r PSRAD mm, mm/m64   ; 66 0F E2 /r PSRAD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'psra', W$edi+4 'd ' | add edi 6
        jmp MMX6428

    Else        ; LOOP rel8
        inc D$LikelyCode
        Mov D$edi 'loop', B$edi+4 SPC | add edi 5
        Mov B$CALLInstruction &TRUE
        test B$esi 080 NOT_ZERO L1>
            add D$UnLikelyCode 0FF
L1:     jmp EndWithDisByteRelativeBack

    End_If


OpE3:
    .If B$EscapePrefix = &TRUE
        ; 66 0F E3 /r PAVGW xmm1, xmm2/m128 ; 0F E3 /r PAVGW mm1, mm2/m64
        ;inc D$UnLikelyCode
        Mov D$edi 'pavg', W$edi+4 'w ' | add edi 6
        jmp MMX6428

    .Else
        Mov B$CALLInstruction &TRUE
        If B$OperandSizeOverride = &FALSE       ; JECXZ rel8
            inc D$LikelyCode
            SubEdi6 | Mov D$edi ' | j', D$edi+4 'ecxz', B$edi+8 SPC | add edi 9
        Else                                    ; JCXZ rel8
            inc D$UnLikelyCode
            SubEdi6 | Mov D$edi ' | j', D$edi+4 'cxz ' | add edi 8
        End_If
        jmp EndWithDisByteRelative

    .End_If


OpE4:
    .If B$EscapePrefix = &TRUE
      ; 0F E4 /r PMULHUW mm1, mm2/m64       ; 66 0F E4 /r PMULHUW xmm1, xmm2/m128
        Mov D$edi 'pmul', D$edi+4 'huw ' | add edi 8
        jmp MMX6428

    .Else        ; IN AL,imm8
        inc D$UnLikelyCode
        Mov D$edi 'in a', W$edi+4 'l ' | add edi 6 | Call WriteImm8

    .End_If

     Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpE5:

    .If B$EscapePrefix = &TRUE
      ; 0F E5 /r PMULHW mm, mm/m64      ; 66 0F E5 /r PMULHW xmm1, xmm2/m128
        Mov D$edi 'pmul', D$edi+4 'hw  ' | add edi 7
        jmp MMX6428

    .Else
        inc D$UnLikelyCode
        If B$OperandSizeOverride = &FALSE   ; IN AX,imm8 / IN EAX,imm8
            Mov D$edi 'in e', D$edi+4 'ax  ' | add edi 7
        Else
            Mov D$edi 'in a', W$edi+4 'x ' | add edi 6
        End_If
        Call WriteImm8

    .End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpE6: ; CVTTPD2DQ xmm1, xmm2/m128

    .If B$EscapePrefix = &TRUE
        If B$OperandSizeOverride = &TRUE    ; CVTTPD2DQ xmm1, xmm2/m128
            Call MarkSSEdata SSE_2_R
            Mov D$edi 'cvtt', D$edi+4 'pd2d', W$edi+8 'q ' | add edi 10
            jmp Dis_mmx1__xmm2_m128
        Else
            ret
        End_If
    .Else       ; OUT imm8, AL
        inc D$UnLikelyCode
        Mov D$edi 'out ' | add edi 4
        Call WriteImm8 | Mov D$edi ' al ' | add edi 3

    .End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpE7:
    .If B$EscapePrefix = &TRUE
        Mov bl B$esi | inc esi
        If B$OperandSizeOverride = &TRUE        ; 66 0F E7 /r MOVNTDQ m128, xmm
            Mov D$edi 'movn', D$edi+4 'tdq ' | add edi 8
            jmp Dis_m128_xmm
        Else        ; 0F E7 /r MOVNTQ m64, mm
            Mov D$edi 'movn', D$edi+4 'tq  ' | add edi 7
            jmp Dis_m64_mmx
        End_If

    .Else       ; OUT imm8, AX // OUT imm8, EAX
        inc D$UnLikelyCode
        Mov D$edi 'out ' | add edi 4
        Call WriteImm8
        If B$OperandSizeOverride = &TRUE
            Mov D$edi ' ax ' | add edi 3
        Else
            Mov D$edi ' eax' | add edi 4
        End_If

    .End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpE8:
    .If B$EscapePrefix = &TRUE
      ; 0F E8 /r PSUBSB mm, mm/m64  ; 66 0F E8 /r PSUBSB xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'psub', D$edi+4 'sb  ' | add edi 7
        jmp MMX6428

    .Else        ; Call rel 16/32
        Mov D$edi 'Call', B$edi+4 SPC | add edi 5
        Mov B$CALLInstruction &TRUE

        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            lodsd
        Else
            inc D$UnLikelyCode
            movsx eax W$esi | add esi 2
        End_If

        Mov D$LastCodeRef eax
        Call RelativeToAbsolute | Call WriteDisRelative

    .End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret

OpE9: ; jmp rel 16/32
    .If B$EscapePrefix = &TRUE
      ; 0F E9 /r PSUBSW mm, mm/m64  ; 66 0F E9 /r PSUBSW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        Mov D$edi 'psub', D$edi+4 'sw  ' | add edi 7
        jmp MMX6428

    .Else        ; jmp rel 16/32
        On B$edi-2 = ';', sub edi 4
        Mov D$edi 'jmp ' | add edi 4
        Mov B$CALLInstruction &TRUE, B$DisEndOfChunk &TRUE

        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            lodsd
        Else
            inc D$UnLikelyCode
            movsx eax W$esi | add esi 2
        End_If

        Mov D$LastCodeRef eax
        Call RelativeToAbsolute | Call WriteDisRelative

    .End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpEA:
    ;inc D$UnLikelyCode
    .If B$EscapePrefix = &TRUE
      ; 0F EA /r PMINSW mm1, mm2/m64        ; 66 0F EA /r PMINSW xmm1, xmm2/m128
        Mov D$edi 'pmin', D$edi+4 'sw  ' | add edi 7
        jmp MMX6428

    .Else
        inc D$UnLikelyCode
        If B$OperandSizeOverride = &TRUE    ; JMP ptr16:32, JMP ptr16:16 (jmp inter-segment).
            Mov D$edi 'jmpF', D$edi+4 ' W$ ' | add edi 7 ; jE! fix
            Push D$esi, esi
                Exchange W$esi, W$esi+2
                Call WriteImm16 | Mov B$edi SPC | inc edi | Call WriteImm16 ; jE! fix
            Pop eax, D$eax
        Else                                ;   JMP far ptr32:selector16
            Mov D$edi 'jmpF', D$edi+4 ' D$ ' | add edi 7 ; jE! fix
            Push D$esi, D$esi+4, esi
                Mov eax D$esi, bx W$esi+4, W$esi bx, D$esi+2 eax
                Call WriteImm16 | Mov B$edi SPC | inc edi | Call WriteImm32 ; jE! fix
            Pop eax, D$eax+4, D$eax
        End_If
        Mov B$DisEndOfChunk &TRUE
        Mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8

    .End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpEB:
    If B$EscapePrefix = &TRUE
      ; 0F EB /r POR mm, mm/m64     ; 66 0F EB /r POR xmm1, xmm2/m128
        Mov D$edi 'por ' | add edi 4
        jmp MMX6428

    Else        ; jmp rel 8
        inc D$LikelyCode
        On B$edi-2 <> ';', sub edi 4
        Mov D$edi 'jmp ' | add edi 4
        Mov B$CALLInstruction &TRUE, B$DisEndOfChunk &TRUE | jmp EndWithDisByteRelative

    End_If


OpEC:
    If B$EscapePrefix = &TRUE
        ; 66 0F EC /r PADDSB xmm1,xmm2/m128       ; 0F EC /r PADDSB mm, mm/m64
        Mov D$edi 'padd', D$edi+4 'sb  ' | add edi 7
        jmp MMX6428

    Else           ; IN AL,DX
        inc D$UnLikelyCode
        Mov D$edi 'in a', D$edi+4 'l dx' | add edi 8

    End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpED:
    .If B$EscapePrefix = &TRUE
        ; 66 0F ED /r PADDSW xmm1, xmm2/m128    ; 0F ED /r PADDSW mm, mm/m64
        Mov D$edi 'padd', D$edi+4 'sw  ' | add edi 7
        jmp MMX6428

    .Else        ; IN AX,DX / IN EAX,DX
        inc D$UnLikelyCode
        If B$OperandSizeOverride = &FALSE
            Mov D$edi 'in e', D$edi+4 'ax d', B$edi+8 'x' | add edi 9
        Else
            Mov D$edi 'in a', D$edi+4 'x dx' | add edi 8
        End_If

    .End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret

OpEE:

    If B$EscapePrefix = &TRUE
        ; 0F EE /r PMAXSW mm1, mm2/m64      ; 66 0F EE /r PMAXSW xmm1, xmm2/m128
        Mov D$edi 'pmax', D$edi+4 'sw  ' | add edi 7
        jmp MMX6428

    Else          ; OUT DX, AL
        inc D$UnLikelyCode
        Mov D$edi 'out ', D$edi+4 'dx a', B$edi+8 'l' | add edi 9

    End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpEF:
    .If B$EscapePrefix = &TRUE
      ; 0F EF /r PXOR mm, mm/m64    ; 66 0F EF /r PXOR xmm1, xmm2/m128
        Mov D$edi 'pxor', B$edi+4 SPC | add edi 5
        jmp MMX6428

    .Else
        inc D$UnLikelyCode
      ; OUT DX, AX // OUT DX, EAX
        Mov D$edi 'out ', W$edi+4 'dx' | add edi 6
        If B$OperandSizeOverride = &FALSE
            Mov D$edi ' eax' | add edi 4
        Else
            Mov D$edi ' ax ' | add edi 3
        End_If

    .End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret

[LockPrefix: D$ ?]

; ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR,
; SBB, SUB, XOR, XADD, XCHG

OpF0:
    Mov B$LockPrefix &TRUE
    inc D$Prefixes
    Mov D$edi 'lock', B$edi+4 SPC, B$DisFlag DISDONE | add edi 5
    Mov B$DisFlag DISDONE ;+DISLINEOVER
ret


OpF1:
    ;inc D$UnLikelyCode
    If B$EscapePrefix = &TRUE
      ; 0F F1 /r PSLLW mm, mm/m64  ; 66 0F F1 /r PSLLW xmm1, xmm2/m128
        Mov D$edi 'psll', W$edi+4 'w ' | add edi 6
        jmp MMX6428
    End_If
ret


OpF2:
    ..If B$esi = 0F
        .If B$esi+1 = 010       ; F2 0F 10 /r MOVSD xmm1, xmm2/m64 ; op10
            add esi 2 | Mov D$edi 'movs', W$edi+4 'd ' | add edi 6
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 011       ; F2 0F 11 /r MOVSD xmm2/m64, xmm
            add esi 2 | Mov D$edi 'movs', W$edi+4 'd ' | add edi 6
            jmp Dis_xmm2_m64__xmm1
        .Else_If B$esi+1 = 012       ; F2,0F,12,/r MOVDDUP xmm1, xmm2/m64
            add esi 2 | Call MarkSSEdata SSE_1_Q
            Mov D$edi 'movd', D$edi+4 'dup ' | add edi 8
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 02A       ; CVTSI2SD xmm, r/m32
            add esi 2 | Call MarkSSEdata SSE_1_D
            Mov D$edi 'cvts', D$edi+4 'i2sd', B$edi+8 SPC | add edi 9
            jmp Dis_xmm1__rm32
        .Else_If B$esi+1 = 02C       ; CVTTSD2SI r32, xmm/m64
            add esi 2 | Call MarkSSEdata SSE_1_R
            Mov D$edi 'cvtt', D$edi+4 'sd2s', W$edi+8 'i ' | add edi 10
            jmp Dis_r32__xmm_m64
        .Else_If B$esi+1 = 02D       ; CVTSD2SI r32, xmm/m64
            add esi 2 | Call MarkSSEdata SSE_1_R
            Mov D$edi 'cvts', D$edi+4 'd2si', B$edi+8 SPC | add edi 9
            jmp Dis_r32__xmm_m64
        .Else_If B$esi+1 = 051      ; F2 0F 51 /r SQRTSD xmm1, xmm2/m64
            add esi 2 | Call MarkSSEdata SSE_2_R
            Mov D$edi 'sqrt', D$edi+4 'sd  ' | add edi 7
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 058      ; ADDSD
            add esi 2 | Call MarkSSEdata SSE_1_R
            Mov D$edi 'adds', W$edi+4 'd ' | add edi 6 | Call Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 059      ; F2 0F 59 /r MULSD xmm1, xmm2/m64
            add esi 2 | Call MarkSSEdata SSE_1_R
            Mov D$edi 'muls', W$edi+4 'd ' | add edi 6
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 05A       ; CVTSD2SS xmm1, xmm2/m64
            add esi 2 | Call MarkSSEdata SSE_1_R
            Mov D$edi 'cvts', D$edi+4 'd2ss', B$edi+8 SPC | add edi 9
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 05C   ; F2 0F 5C /r SUBSD xmm1, xmm2/m64
            add esi 2 | Call MarkSSEdata SSE_2_R
            Mov D$edi 'subs', W$edi+4 'd ' | add edi 6
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 05D       ; MINSD xmm1, xmm2/m64
            add esi 2 | Call MarkSSEdata SSE_1_R
            Mov D$edi 'mins', W$edi+4 'd ' | add edi 6
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 05E         ; DIVSD xmm1, xmm2/m64
            add esi 2 | Call MarkSSEdata SSE_1_R
            Mov D$edi 'divs', W$edi+4 'd ' | add edi 6
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 05F      ; F2 0F 5F /r MAXSD xmm1, xmm2/m64
            add esi 2 | Call MarkSSEdata SSE_1_R
            Mov D$edi 'maxs', W$edi+4 'd ' | add edi 6
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 070      ; F2 0F 70 /r ib PSHUFLW xmm1, xmm2/m128, imm8
            add esi 2 | Mov D$edi 'pshu', D$edi+4 'flw ' | add edi 8
            Call Dis_xmm1__xmm2_m128 | Mov B$edi SPC | inc edi
            Call WriteImm8
        .Else_If B$esi+1 = 07C      ; F2,0F,7C,/r HADDPS xmm1, xmm2/m128
            add esi 2 | Call MarkSSEdata SSE_4_F
            Mov D$edi 'hadd', D$edi+4 'ps ' | add edi 7
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 07D      ; F2,0F,7D,/r HSUBPS xmm1, xmm2/m128
            add esi 2 | Call MarkSSEdata SSE_4_F
            Mov D$edi 'hsub', D$edi+4 'ps ' | add edi 7
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 0C2       ; CMPSD xmm1, xmm2/m64, imm8
            add esi 2 | Mov D$edi 'cmps', W$edi+4 'd ' | add edi 6
            Call Dis_xmm1__xmm2_m64 | jmp WritePacketCondition
        .Else_If B$esi+1 = 0D0          ; F2,0F,D0,/r ADDSUBPS xmm1, xmm2/m128
            add esi 2 | Call MarkSSEdata SSE_4_F
            Mov D$edi 'adds', D$edi+4 'ubps', B$edi+8 SPC | add edi 9
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 0D6          ; F2 0F D6 MOVDQ2Q mm, xmm
            add esi 2 | Mov D$edi 'movd', D$edi+4 'q2q ' | add edi 8
            jmp Dis_mmx_xmm
        .Else_If B$esi+1 = 0E6       ; CVTPD2DQ xmm1, xmm2/m128
            add esi 2 | Call MarkSSEdata SSE_2_R
            Mov D$edi 'cvtp', D$edi+4 'd2dq', B$edi+8 SPC | add edi 9
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 0F0       ; F2,0F,F0,/r LDDQU xmm, mem
            add esi 2 | Mov D$edi 'lddq', D$edi+4 'u ' | add edi 6
            jmp Dis_xmm1__xmm2_m128  ; Xmm2 is dummy, here.
        .Else
            inc D$UnLikelyCode | ret
        .End_If

    ..Else_If B$esi = 0A6   ; F2 A6 REPNE CMPS m8, m8
        inc esi | Mov D$edi 'repn', D$edi+4 'e cm', D$edi+8 'psb ' | add edi 11
    ..Else_If W$esi = 0A766   ; F2 A7 REPNE CMPS m16, m16 ; F2 A7 REPNE CMPS m32, m32
        add esi 2 | Mov D$edi 'repn', D$edi+4 'e cm', D$edi+8 'psw ' | add edi 11
    ..Else_If B$esi = 0A7   ; F2 A7 REPNE CMPS m16, m16 ; F2 A7 REPNE CMPS m32, m32
        inc esi | Mov D$edi 'repn', D$edi+4 'e cm', D$edi+8 'psd ' | add edi 11
    ..Else_If B$esi = 0AE   ; F2 AE REPNE SCAS m8
        inc esi | Mov D$edi 'repn', D$edi+4 'e sc', D$edi+8 'asb ' | add edi 11
    ..Else_If W$esi = 0AF66   ; F2 AF REPNE SCAS m16 ; F2 AF REPNE SCAS m32
        add esi 2 | Mov D$edi 'repn', D$edi+4 'e sc', D$edi+8 'asw ' | add edi 11
    ..Else_If B$esi = 0AF   ; F2 AF REPNE SCAS m16 ; F2 AF REPNE SCAS m32
        inc esi | Mov D$edi 'repn', D$edi+4 'e sc', D$edi+8 'asd ' | add edi 11
    ..Else
        .If B$EscapePrefix = &TRUE
          ; 0F F2 /r PSLLD mm, mm/m64   ;  66 0F F2 /r PSLLD xmm1, xmm2/m128
            Mov D$edi 'psll', W$edi+4 'd ' | add edi 6 | jmp MMX6428
        .Else
            inc D$UnLikelyCode | ret
        .End_If
    ..End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpF3:
    ..If B$esi = 0F
        .If B$esi+1 = 010       ; F3 0F 10 /r MOVSS xmm1, xmm2/m32
            add esi 2 | Call MarkSSEdata SSE_1_R
            Mov D$edi 'movs', W$edi+4 's ' | add edi 6
            jmp Dis_xmm1__xmm2_m32F
        .Else_If B$esi+1 = 011       ; F3 0F 11 /r MOVSS xmm2/m32, xmm
            add esi 2 | Call MarkSSEdata SSE_1_R
            Mov D$edi 'movs', W$edi+4 's ' | add edi 6
            jmp Dis_xmm2_m32F__xmm1
        .Else_If B$esi+1 = 012       ; F3,0F,12,/r MOVSLDUP xmm1, xmm2/m128
            add esi 2 | Call MarkSSEdata SSE_4_F
            Mov D$edi 'movs', D$edi+4 'ldup', B$edi+8 SPC | add edi 9
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 016       ; F3,0F,16,/r MOVSHDUP xmm1, xmm2/m128
            add esi 2 | Call MarkSSEdata SSE_4_F
            Mov D$edi 'movs', D$edi+4 'hdup', B$edi+8 SPC | add edi 9
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 051      ; F3 0F 51 /r SQRTSS xmm1, xmm2/m32
            add esi 2 | Call MarkSSEdata SSE_4_F
            Mov D$edi 'sqrt', D$edi+4 'ss  ' | add edi 7 | jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 052      ; F3 0F 52 /r RSQRTSS xmm1,xmm2/m32
            add esi 2 | Call MarkSSEdata SSE_4_F
            Mov D$edi 'rsqr', D$edi+4 'tss ' | add edi 8 | jmp Dis_xmm1__xmm2_m32
        .Else_If al = 053; F3 0F 53 /r RCPSS xmm1, xmm2/m32; F3 0F 53 /r RCPSS xmm1, xmm2/m32
            add esi 2 | Call MarkSSEdata SSE_4_F
            Mov D$edi 'rcpp', W$edi+4 's ' | add edi 6 | jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 058 ; F3 0F 58 /r ADDSS
            add esi 2 | Call MarkSSEdata SSE_1_F
            Mov D$edi 'adds', W$edi+4 's ' | add edi 6 | jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 059       ; F3 0F 59 /r MULSS xmm1, xmm2/m32
            add esi 2 | Call MarkSSEdata SSE_1_F
            Mov D$edi 'muls', W$edi+4 's ' | add edi 6
            jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 05C   ; F3 0F 5C /r SUBSS xmm1, xmm2/m32
            add esi 2 | Call MarkSSEdata SSE_4_F
            Mov D$edi 'subs', W$edi+4 's ' | add edi 6
            jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 05D       ; MINSS xmm1, xmm2/m32
            add esi 2 | Call MarkSSEdata SSE_1_F
            Mov D$edi 'mins', W$edi+4 's ' | add edi 6
            jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 05F      ; F3 0F 5F /r MAXSS xmm1, xmm2/m32
            add esi 2 | Call MarkSSEdata SSE_1_F
            Mov D$edi 'maxs', W$edi+4 's ' | add edi 6
            jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 070       ; F3 0F 70 /r ib PSHUFHW xmm1, xmm2/m128, imm8
            add esi 2 | Mov D$edi 'pshu', D$edi+4 'fhw ' | add edi 8
            Call Dis_xmm1__xmm2_m128 | Mov B$edi SPC | inc edi
            Call WriteImm8
        .Else_If B$esi+1 = 07E      ;  F3 0F 7E MOVQ xmm1, xmm2/m64
            add esi 2 | Mov D$edi 'movq', B$edi+4 SPC | add edi 5
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 0C2      ; CMPSD xmm1, xmm2/m64, imm8
            add esi 2 | Mov D$edi 'cmps', W$edi+4 's ' | add edi 6
            Call  Dis_xmm1__xmm2_m64 | jmp WritePacketCondition
        .Else_If B$esi+1 = 0D6        ; F3 0F D6 MOVQ2DQ xmm, mm
            add esi 2 | Mov D$edi 'movq', D$edi+4 '2dq ' | add edi 8
            jmp Dis_xmm_mmx
        .Else_If B$esi+1 = 0E6      ; CVTDQ2PD xmm1, xmm2/m64
            add esi 2 | Call MarkSSEdata SSE_2_D
            Mov D$edi 'cvtd', D$edi+4 'q2pd', B$edi+8 SPC | add edi 9
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 02A      ; CVTSI2SS xmm, r/m32
            add esi 2 | Call MarkSSEdata SSE_1_D
            Mov D$edi 'cvts', D$edi+4 'i2ss', B$edi+8 SPC | add edi 9
            jmp Dis_xmm1__rm32
        .Else_If B$esi+1 = 02C      ; CVTTSS2SI r32, xmm/m32
            add esi 2 | Call MarkSSEdata SSE_1_F
            Mov D$edi 'cvtt', D$edi+4 'ss2s', W$edi+8 'i ' | add edi 10
            jmp Dis_r32__xmm_m32
        .Else_If B$esi+1 = 05A      ; CVTSS2SD xmm1, xmm2/m32
            add esi 2 | Call MarkSSEdata SSE_1_F
            Mov D$edi 'cvts', D$edi+4 's2sd', B$edi+8 SPC | add edi 9
            jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 02D      ; CVTSS2SI r32, xmm/m32
            add esi 2 | Call MarkSSEdata SSE_1_F
            Mov D$edi 'cvts', D$edi+4 's2si', B$edi+8 SPC | add edi 9
            jmp Dis_r32__xmm_m32
        .Else_If B$esi+1 = 05B      ; CVTTPS2DQ xmm1, xmm2/m128
            add esi 2 | Call MarkSSEdata SSE_4_F
            Mov D$edi 'cvtt', D$edi+4 'ps2d', W$edi+8 'q ' | add edi 10
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 05E      ; DIVSS xmm1, xmm2/m32
            add esi 2 | Call MarkSSEdata SSE_1_F
            Mov D$edi 'divs', W$edi+4 's ' | add edi 6
            jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 06F      ; F3 0F 6F /r MOVDQU xmm1, xmm2/m128
            add esi 2 | Mov D$edi 'movd', D$edi+4 'qu  ' | add edi 7
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 07F      ; F3 0F 7F /r MOVDQU xmm2/m128, xmm1
            add esi 2 | Mov D$edi 'movd', D$edi+4 'qu  ' | add edi 7
            jmp Dis_xmm2_m128__xmm1
        .Else
            ret
        .End_If

    ..Else_If B$esi = 090   ; F3 90 PAUSE
        inc esi | Mov D$edi 'paus', B$edi+4 'e' | add edi 5
    ..Else_If W$esi = 0A766 ; F3 66 17
        add esi 2 | Mov D$edi 'rep ', D$edi+4 'cmps', B$edi+8 'w' | add edi 9
      ;  add esi 2 | Mov D$edi 'rep ', D$edi+4 'movs', B$edi+8 'w' | add edi 9
    ..Else_If W$esi = 0AF66 ; F3 66 17
        add esi 2 | Mov D$edi 'rep ', D$edi+4 'scas', B$edi+8 'w' | add edi 9
    ..Else_If W$esi = 0A566 ; F3 66 17
        add esi 2 | Mov D$edi 'rep ', D$edi+4 'movs', B$edi+8 'w' | add edi 9
      ;!!!!  add esi 2 | Mov D$edi 'rep ', D$edi+4 'cmps', B$edi+8 'w' | add edi 9
    ..Else_If B$esi = 06C       ; F3 6C REP INS r/m8, DX
        inc D$UnLikelyCode
        inc esi | Mov D$edi 'rep ', D$edi+4 'insb' | add edi 8 ; | jmp Dis_rm8_dx
    ..Else_If B$esi = 06D       ; F3 6D REP INS r/m16, DX ; F3 6D REP INS r/m32, DX
        inc D$UnLikelyCode
        inc esi | Mov D$edi 'rep ', D$edi+4 'insd' | add edi 8 ; | jmp Dis_rm32_rm16__dx
    ..Else_If W$esi = 06D66       ; F3 6D REP INS r/m16, DX ; F3 6D REP INS r/m32, DX
        inc D$UnLikelyCode
        add esi 2 | Mov D$edi 'rep ', D$edi+4 'insw' | add edi 8 ; | jmp Dis_rm32_rm16__dx
    ..Else_If B$esi = 06E       ; F3 6E REP OUTS DX, r/m8
        inc D$UnLikelyCode
        inc esi | Mov D$edi 'rep ', D$edi+4 'outs', B$edi+8 'b' | add edi 9 ;| jmp Dis_dx_rm8
    ..Else_If W$esi = 06F66       ; F3 6F REP OUTS DX, r/m16 ; F3 6F REP OUTS DX, r/m32
        inc D$UnLikelyCode
        add esi 2 | Mov D$edi 'rep ', D$edi+4 'outs', B$edi+8 'w' | add edi 9
    ..Else_If B$esi = 06F       ; F3 6F REP OUTS DX, r/m16 ; F3 6F REP OUTS DX, r/m32
        inc D$UnLikelyCode
        inc esi | Mov D$edi 'rep ', D$edi+4 'outs', B$edi+8 'd' | add edi 9 ;| jmp Dis_dx__rm32_rm16
    ..Else_If B$esi = 0A4       ; F3 A4 REP MOVS m8, m8
        inc esi | Mov D$edi 'rep ', D$edi+4 'movs', B$edi+8 'b' | add edi 9
    ..Else_If W$esi = 0A566       ; F3 A5 REP MOVS m16, m16 ; F3 A5 REP MOVS m32, m32
        add esi 2 | Mov D$edi 'rep ', D$edi+4 'movs', B$edi+8 'w' | add edi 9
    ..Else_If B$esi = 0A5       ; F3 A5 REP MOVS m16, m16 ; F3 A5 REP MOVS m32, m32
        inc esi | Mov D$edi 'rep ', D$edi+4 'movs', B$edi+8 'd' | add edi 9
    ..Else_If B$esi = 0A6       ; F3 A6 REPE CMPS m8, m8
        inc esi | Mov D$edi 'rep ', D$edi+4 'cmps', B$edi+8 'b' | add edi 9
    ..Else_If W$esi = 0A766       ; F3 A7 REPE CMPS m16, m16 ; F3 A7 REPE CMPS m32, m32
        add esi 2 | Mov D$edi 'rep ', D$edi+4 'cmps', B$edi+8 'w' | add edi 9
    ..Else_If B$esi = 0A7       ; F3 A7 REPE CMPS m16, m16 ; F3 A7 REPE CMPS m32, m32
        inc esi | Mov D$edi 'rep ', D$edi+4 'cmps', B$edi+8 'd' | add edi 9
    ..Else_If B$esi = 0AA       ; F3 AA REP STOS m8
        inc esi | Mov D$edi 'rep ', D$edi+4 'stos', B$edi+8 'b' | add edi 9
    ..Else_If W$esi = 0AB66       ; F3 AB REP STOS m16 ; F3 AB REP STOS m32
        add esi 2 | Mov D$edi 'rep ', D$edi+4 'stos', B$edi+8 'w' | add edi 9
    ..Else_If B$esi = 0AB       ; F3 AB REP STOS m16 ; F3 AB REP STOS m32
        inc esi | Mov D$edi 'rep ', D$edi+4 'stos', B$edi+8 'd' | add edi 9
    ..Else_If B$esi = 0AC       ; F3 AC REP LODS AL
        inc esi | Mov D$edi 'rep ', D$edi+4 'lods', B$edi+8 'b' | add edi 9
    ..Else_If W$esi = 0AD66       ; F3 AD REP LODS AX ; F3 AD REP LODS EAX
        add esi 2 | Mov D$edi 'rep ', D$edi+4 'lods', B$edi+8 'w' | add edi 9
    ..Else_If B$esi = 0AD       ; F3 AD REP LODS AX ; F3 AD REP LODS EAX
        inc esi | Mov D$edi 'rep ', D$edi+4 'lods', B$edi+8 'd' | add edi 9
    ..Else_If B$esi = 0AE       ; F3 AE REPE SCAS m8
        inc esi | Mov D$edi 'rep ', D$edi+4 'scas', B$edi+8 'b' | add edi 9
    ..Else_If W$esi = 0AF66       ; F3 AF REPE SCAS m16 ; F3 AF REPE SCAS m32
        add esi 2 | Mov D$edi 'rep ', D$edi+4 'scas', B$edi+8 'w' | add edi 9
    ..Else_If B$esi = 0AF       ; F3 AF REPE SCAS m16 ; F3 AF REPE SCAS m32
        inc esi | Mov D$edi 'rep ', D$edi+4 'scas', B$edi+8 'd' | add edi 9
    ..Else
        If B$EscapePrefix = &TRUE
            ; 0F F3 /r PSLLQ mm, mm/m64     ; 66 0F F3 /r PSLLQ xmm1, xmm2/m128
            Mov D$edi 'psll', W$edi+4 'q ' | add edi 6
            jmp MMX6428
        Else
            ret
        End_If
    ..End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpF4: ; HLT
    If B$EscapePrefix = &TRUE
      ; 0F F4 /r PMULUDQ mm1, mm2/m64       ; 66 OF F4 /r PMULUDQ xmm1, xmm2/m128
        Mov D$edi 'pmul', D$edi+4 'udq ' | add edi 8
        jmp MMX6428

    Else
        inc D$UnLikelyCode
        Mov D$edi 'hlt ' | add edi 3

    End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpF5: ; cmc
    If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
      ; 0F F5 /r PMADDWD mm, mm/m64       ; 66 0F F5 /r PMADDWD xmm1, xmm2/m128
        Mov D$edi 'pmad', D$edi+4 'dwd ' | add edi 8
        jmp MMX6428

    Else
        Mov D$edi 'cmc ' | add edi 3  ; cmc

    End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpF6:
    .If B$EscapePrefix = &TRUE
      ; 0F F6 /r PSADBW mm1, mm2/m64        ; 66 0F F6 /r PSADBW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
         Mov D$edi 'psad', D$edi+4 'bw  ' | add edi 7
        jmp MMX6428

    .Else
        inc D$LikelyCode
        Mov bl B$esi | inc esi | DigitMask bl To al              ; ModRm with /6 ?

        If al = 0   ; F6 /0 ib TEST r/m8,imm8
            Mov D$edi 'test', B$edi+4 SPC | add edi 5 | jmp Dis_rm8_imm8
        Else_If al = 2       ; F6 /2 NOT r/m8
            Mov B$LockPrefix &FALSE
            Mov D$edi 'not ' | add edi 4
        Else_If al = 3       ; F6 /3 NEG r/m8
            Mov B$LockPrefix &FALSE
            Mov D$edi 'neg ' | add edi 4
        Else_If al = 4           ; F6 /4 MUL r/m8
            Mov D$edi 'mul ' | add edi 4
        Else_If al = 5           ; IMUL r/m8
            Mov D$edi 'imul', B$edi+4 SPC | add edi 5
        Else_If al = 6      ; DIV r/m8
            Mov D$edi 'div ' | add edi 4
        Else_If al = 7      ; IDIV r/m8
            Mov D$edi 'idiv', B$edi+4 SPC | add edi 5
        Else
            inc D$UnLikelyCode | ret
        End_If

        jmp EndWith.B.mem

    .End_If
ret


OpF7:
    ..If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        Mov D$edi 'mask' | Mov bl B$esi | inc esi
        If B$OperandSizeOverride = &TRUE    ; 66 0F F7 /r MASKMOVDQU xmm1, xmm2
            Mov D$edi+4 'movd', D$edi+8 'qu  ' | add edi 11
            jmp Dis_xmm1_xmm2
        Else                                ; 0F F7 /r MASKMOVQ mm1, mm2
            Mov D$edi+4 'movq', B$edi+8 SPC | add edi 9
            jmp Dis_mmx1_mmx2
        End_If


    ..Else
        inc D$LikelyCode
        Mov bl B$esi | inc esi | DigitMask bl To al              ; ModRm with /6 ?

        .If al = 0  ; F7 /0 iw TEST r/m16,imm16 ; F7 /0 id TEST r/m32,imm32
            Mov D$edi 'test', B$edi+4 SPC | add edi 5 | jmp Dis_rm32_rm16__imm32_imm16
        .Else_If al = 2      ; F7 /2 NOT r/m16
            Mov B$LockPrefix &FALSE
            Mov D$edi 'not ' | add edi 4
        .Else_If al = 3       ; F7 /3 NEG r/m16
            Mov B$LockPrefix &FALSE
            Mov D$edi 'neg ' | add edi 4
        .Else_If al = 4           ; F7 /4 MUL r/m16
            Mov D$edi 'mul ' | add edi 4
        .Else_If al = 5           ; IMUL r/m16
            Mov D$edi 'imul', B$edi+4 SPC | add edi 5
        .Else_If al = 6      ; DIV r/m32 r/m16
            Mov D$edi 'div ' | add edi 4
        .Else_If al = 7      ; IDIV r/m32 // r/m16
            Mov D$edi 'idiv', B$edi+4 SPC | add edi 5
        .Else
            inc D$UnLikelyCode | ret
        .End_If

        On B$OperandSizeOverride = &TRUE, jmp EndWith.W.mem
        jmp EndWith.D.mem

    ..End_If
ret



OpF8:
    If B$EscapePrefix = &TRUE
      ; 0F F8 /r PSUBB mm, mm/m64   ; 66 0F F8 /r PSUBB xmm1, xmm2/m128
        Mov D$edi 'psub', W$edi+4 'b ' | add edi 6 | jmp MMX6428

    Else; clc
        Mov D$edi 'clc ' | add edi 3

    End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpF9:
    If B$EscapePrefix = &TRUE
      ; 0F F9 /r PSUBW mm, mm/m64   ; 66 0F F9 /r PSUBW xmm1, xmm2/m128
        Mov D$edi 'psub', W$edi+4 'w ' | add edi 6 | jmp MMX6428

    Else       ; F9 STC
        Mov D$edi 'stc ' | add edi 3

    End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpFA:
    If B$EscapePrefix = &TRUE
      ; 0F FA /r PSUBD mm, mm/m64   ; 66 0F FA /r PSUBD xmm1, xmm2/m128
        Mov D$edi 'psub', W$edi+4 'd ' | add edi 6 | jmp MMX6428

    Else
        inc D$UnLikelyCode
        Mov D$edi 'cli ' | add edi 3
    End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpFB:
    If B$EscapePrefix = &TRUE
      ; 0F FB /r PSUBQ mm1, mm2/m64 ; 66 0F FB /r PSUBQ xmm1, xmm2/m128
        Mov D$edi 'psub', W$edi+4 'q ' | add edi 6 | jmp MMX6428

    Else       ; FB STI
        inc D$UnLikelyCode
        Mov D$edi 'sti ' | add edi 3

    End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpFC:
    If B$EscapePrefix = &TRUE
        ; 66 0F FC /r PADDB xmm1,xmm2/m128    ; 0F FC /r PADDB mm, mm/m64
        Mov D$edi 'padd', W$edi+4 'b ' | add edi 6 | jmp MMX6428

    Else               ; cld
        Mov D$edi 'cld ' | add edi 3

    End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpFD:
    If B$EscapePrefix = &TRUE
        ; 66 0F FD /r PADDW xmm1, xmm2/m128     ;  0F FD /r PADDW mm, mm/m64
        Mov D$edi 'padd', W$edi+4 'w ' | add edi 6 | jmp MMX6428

    Else       ; FD STD
        Mov D$edi 'std ' | add edi 3

    End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


OpFE:
    .If B$EscapePrefix = &TRUE
        ; 66 0F FE /r PADDD xmm1, xmm2/m128    ; 0F FE /r PADDD mm, mm/m64
        ;inc D$UnLikelyCode
        Mov D$edi 'padd', W$edi+4 'd ' | add edi 6 | jmp MMX6428

    .Else
        movzx ebx B$esi | inc esi | DigitMask bl to al
        If al = 0           ; INC r/m8
            Mov B$LockPrefix &FALSE
            Mov D$edi 'inc '
        Else_If al = 1      ; DEC r/m8
            Mov B$LockPrefix &FALSE
            Mov D$edi 'dec '
        Else
            inc D$UnLikelyCode | ret
        End_If

        add edi 4 | jmp EndWith.B.mem
    .End_If
ret

;075 00_01_110_101

OpFF:
    movzx ebx B$esi | inc esi | DigitMask bl to al

    .If al = 0           ; INC r/m16 / r/m32
        inc D$LikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'inc ' | add edi 4 | jmp EndWith.WD.mem

    .Else_If al = 1      ; DEC r/m32 // DEC r/m16
        inc D$LikelyCode
        Mov B$LockPrefix &FALSE
        Mov D$edi 'dec ' | add edi 4 | jmp EndWith.WD.mem

    .Else_If al = 2     ;  ; FF /2 Call r/m16 ; FF /2 Call r/m32
        inc D$LikelyCode
        Mov D$edi 'Call', B$edi+4 SPC | add edi 5
      ; add here the DLL Functions calls.
      ; If BL = 15 and D$esi inside .import Address Table
      ;             or D$esi points to a JMP Pointer To .import Address Table
        jmp L5> ;;;Call Dis_rm32_rm16

    .Else_If al = 3
        inc D$UnLikelyCode
        If B$OperandSizeOverride = &TRUE
            Mov D$edi 'Call', D$edi+4 'F W$' | add edi 6 ; jE! fix
        Else
            Mov D$edi 'Call', D$edi+4 'F D$' | add edi 6 ; jE! fix
        End_If
        Call WriteEffectiveAddressFromModRm         ; Mem pointing to 16:16/32
        Mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8

    .Else_If al = 4      ; JMP r/m16 ; ; JMP r/m32
        inc D$LikelyCode
        Mov B$DisEndOfChunk &TRUE
        Mov D$edi 'jmp ' | add edi 4

L5:     ;Push D$LastCodeRef
            Call Dis_rm32_rm16
;       ;Pop eax
;;
        cmp eax D$LastCodeRef | je L9>>
      ; This 'D$LastCodeRef' may be, for example, 'Mov eax D$Codexxxx' or 'D$Dataxxxx'.
            Mov ebx D$LastCodeRef
            cmp ebx D$DisCodeMin | jb L9>>
            cmp ebx D$DisCodeMax | ja L9>>
                Call ExtendToSideCodePointers

L9:         cmp ebx D$DisDataMin | jb L9>>
            cmp ebx D$DisDataMax | ja L9>>
                Call ExtendToSideDataPointers
;;

  ; OpEA: ; JMP ptr16:32, JMP ptr16:16 (jmp inter-segment).
    .Else_If al = 5      ; JMP m16:32
        inc D$UnLikelyCode
        If B$OperandSizeOverride = &FALSE
            Mov D$edi 'jmpF', D$edi+4 ' W$ ' | add edi 5 ; jE! fix
        Else
            Mov D$edi 'jmpF', D$edi+4 ' D$ ' | add edi 5 ; jE! fix
        End_If
        Mov B$DisEndOfChunk &TRUE
        Call WriteEffectiveAddressFromModRm
        Mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8

    .Else_If al = 6     ; FF /6 Push r/m16  ; FF /6 Push r/m32
        inc D$LikelyCode
        Mov D$edi 'Push', B$edi+4 SPC | add edi 5 | jmp Dis_m32_16

    .Else
        inc D$UnLikelyCode
        ret

    .End_If

L9: Mov B$DisFlag DISDONE+DISLINEOVER
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; Routines usable by several encodings:
____________________________________________________________________________________________
____________________________________________________________________________________________

Dis_rm8_r8:
    Mov W$DisSizeMarker 'B$'
    movzx ebx B$esi | inc esi
    Push ebx
        Call WriteEffectiveAddressFromModRm | Mov B$edi SPC | inc edi
    Pop ebx
    Call WriteByteRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_al_imm8:
    Mov D$edi 'al  ' | add edi 3 | Call WriteImm8
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_eax_ax__imm32_imm16:
    If B$OperandSizeOverride = &TRUE
        Mov D$edi 'ax  ' | add edi 3 | Call WriteImm16
    Else
        Mov D$edi 'eax ' | add edi 4 | Call WriteImm32
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_eax_ax__rd_rw:
  ; See: ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
  ;
  ; the Reg is given in the last Opcode Byte, in the BaseMask

    movzx eax B$esi-1 | and eax 00_000_111

    If B$OperandSizeOverride = &TRUE
        Mov D$edi 'ax  ' | add edi 3
        Mov eax D$WordRegsTable+eax*4 | stosd | dec edi
    Else
        Mov D$edi 'eax ' | add edi 4
        Mov eax D$dWordRegsTable+eax*4 | stosd
    End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm8_m8:
    Mov W$DisSizeMarker 'B$'
    movzx ebx B$esi | inc esi
    Push ebx
        Call WriteEffectiveAddressFromModRm | Mov B$edi SPC | inc edi
    Pop ebx
    Call WriteByteRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm32_rm16__r32_r16:
    On B$OperandSizeOverride = &TRUE, Mov W$DisSizeMarker 'W$'
    movzx ebx B$esi | inc esi
    Push ebx
        Call WriteEffectiveAddressFromModRm | Mov B$edi SPC | inc edi
    Pop ebx
    Call WritedWordRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Dis_rm32_rm16__r32_r16__imm8:
    Call Dis_rm32_rm16__r32_r16 | Mov B$edi SPC | inc edi
    Call WriteImm8      ; not signed this is for SHLD / SHRD
ret

Dis_rm32_rm16__r32_r16__cl:
    Call Dis_rm32_rm16__r32_r16 | Mov D$edi ' cl ' | add edi 3
ret

Dis_m32_r32:
    Mov W$DisSizeMarker 'D$'
    movzx ebx B$esi | inc esi
    Push ebx
        Call WriteEffectiveAddressFromModRm | Mov B$edi SPC | inc edi
    Pop ebx
    Call WritedWordRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r8_rm8:
    Mov W$DisSizeMarker 'B$'
    movzx ebx B$esi | inc esi
    Call WriteByteRegsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWithModRm ;EndWith.D.mem
ret

Dis_r32_r16__rm32_rm16:
    On  B$OperandSizeOverride = &TRUE, Mov W$DisSizeMarker 'W$'
    movzx ebx B$esi | inc esi
    Call WritedWordRegsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWith.D.mem
ret

Dis_r32_r16__rm32_rm16_orNone__SignedImm8:
    On  B$OperandSizeOverride = &TRUE, Mov W$DisSizeMarker 'W$'
    movzx ebx B$esi | inc esi
    Call WritedWordRegsFromRegBits | Mov B$edi SPC | inc edi
    Test bl 00_11_000_000 ZERO L2>
        RegMask bl to al | RmMask bl to cl | ;on al = cl jmp L3>
            Call WriteEffectiveAddressFromModRm
            Mov B$edi SPC | inc edi | jmp L3>
L2: Call WriteEffectiveAddressFromModRm | Mov B$edi SPC | inc edi
L3: Call WriteSignedImm8
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r32_r16__rm32_rm16_OrNone__SignedImm16_32:
    On B$OperandSizeOverride = &TRUE, Mov W$DisSizeMarker 'W$'
    movzx ebx B$esi | inc esi
    Call WritedWordRegsFromRegBits | Mov B$edi SPC | inc edi
    Test bl 00_11_000_000 ZERO L2>
        RegMask bl to al | RmMask bl to cl | ;on al = cl jmp L3>
            Call WriteEffectiveAddressFromModRm
            Mov B$edi SPC | inc edi | jmp L3>
L2: Call WriteEffectiveAddressFromModRm | Mov B$edi SPC | inc edi
L3: If B$OperandSizeOverride = &TRUE
        Call WriteSignedImm16
    Else
        Call WriteSignedImm32
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Dis_rm8_1:
    Mov W$DisSizeMarker 'B$' | jmp Dis_rm32_1
Dis_rm16_1:
    Mov W$DisSizeMarker 'W$'
Dis_rm32_1:
  ;  movzx ebx B$esi | inc esi
    Call WriteEffectiveAddressFromModRm | Mov W$edi ' 1' | add edi 2
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm8:
    Mov W$DisSizeMarker 'B$'
    movzx ebx B$esi | inc esi
    Call WriteEffectiveAddressFromModRm
    Mov B$DisFlag DISDONE+DISLINEOVER
ret





Dis_rm32_rm16__1:
    If B$OperandSizeOverride = &FALSE
        jmp Dis_rm32_1
    Else
        jmp Dis_rm16_1
    End_If

Dis_rm8_cl:
    Mov W$DisSizeMarker 'B$' | jmp Dis_rm32_cl
Dis_rm16_cl:
    Mov W$DisSizeMarker 'W$'
Dis_rm32_cl:
   ; movzx ebx B$esi | inc esi
    Call WriteEffectiveAddressFromModRm | Mov D$edi ' cl ' | add edi 3
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm32_rm16:
    On B$OperandSizeOverride = &TRUE, Mov W$DisSizeMarker 'W$'
    Call WriteEffectiveAddressFromModRm
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm32_rm16__cl:
    If B$OperandSizeOverride = &FALSE
        jmp Dis_rm32_cl
    Else
        jmp Dis_rm16_cl
    End_If

;Dis_rm16_imm8:
;    Mov W$DisSizeMarker 'W$'
;    movzx ebx B$esi | inc esi
;    Call WriteEffectiveAddressFromModRm | Mov B$edi SPC | inc edi
;    Call WriteImm8
;    Mov B$DisFlag DISDONE+DISLINEOVER
;ret

Dis_rm16_Sreg:
    Mov W$DisSizeMarker 'W$'
    movzx ebx B$esi | inc esi
    Push ebx
        Call WriteEffectiveAddressFromModRm | Mov B$edi SPC | inc edi
    Pop ebx
    Call WriteSregsFromModRm
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm32_Sreg:
    Mov W$DisSizeMarker 'D$'
    movzx ebx B$esi | inc esi
    Push ebx
        Call WriteEffectiveAddressFromModRm | Mov B$edi SPC | inc edi
    Pop ebx
    Call WriteSregsFromModRm
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Dis_Sreg_rm16:
    Mov W$DisSizeMarker 'W$'
    movzx ebx B$esi | inc esi
    Call WriteSregsFromModRm | Mov B$edi SPC | inc edi
    Call WriteEffectiveAddressFromModRm
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_Sreg_rm32:
    Mov W$DisSizeMarker 'D$'
    movzx ebx B$esi | inc esi
    Call WriteSregsFromModRm | Mov B$edi SPC | inc edi
    Call WriteEffectiveAddressFromModRm
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm8_imm8:
    Mov W$DisSizeMarker 'B$'
    Call WriteEffectiveAddressFromModRm | Mov B$edi SPC | inc edi
    Call WriteImm8
    Mov B$DisFlag DISDONE+DISLINEOVER

ret

Dis_Imm8:
    Call WriteSignedImm8
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_imm32_16:
    If B$OperandSizeOverride = &FALSE
        Call WriteImm32
    Else
        Call WriteImm16
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm32_rm16__imm32_imm16:
    On B$OperandSizeOverride = &TRUE, Mov W$DisSizeMarker 'W$'
    Call WriteEffectiveAddressFromModRm | Mov B$edi SPC | inc edi
    If B$OperandSizeOverride = &FALSE
        Call WriteImm32
    Else
        Call WriteImm16
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm32_rm16__imm8:
    On  B$OperandSizeOverride = &TRUE, Mov W$DisSizeMarker 'W$'
    Call WriteEffectiveAddressFromModRm | Mov B$edi SPC | inc edi
    Call WriteSignedImm8
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r32_r16__rm8:
    On B$OperandSizeOverride = &TRUE, jmp Dis_r16_rm8

    Mov bl B$esi | inc esi
    Call WriteEregsFromRegBits | Mov B$edi SPC | inc edi
    Mov W$DisSizeMarker 'B$' | Call WriteEffectiveAddressFromModRm
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r16_rm8:
    Mov bl B$esi | inc esi
    Call WriteWordregsFromRegBits | Mov B$edi SPC | inc edi
    Mov W$DisSizeMarker 'B$' | Call WriteEffectiveAddressFromModRm
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r32_rm16:
    Mov bl B$esi | inc esi
    Call WriteEregsFromRegBits | Mov B$edi SPC | inc edi
    Mov W$DisSizeMarker 'W$' | Call WriteEffectiveAddressFromModRm
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r32_xmmx:
    On B$OperandSizeOverride = &FALSE, jmp Dis_r32_mmx
Dis_r32_xmm:
    Mov bl B$esi | inc esi
    Call WriteEregsFromRegBits | Mov B$edi SPC | inc edi
    Call WriteXmmRegsFromRmBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r32_mmx:
    Mov bl B$esi | inc esi
    Call WriteEregsFromRegBits | Mov B$edi SPC | inc edi
    Call WriteMMXRegsFromRmBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

; Some encodings like MOVMSKPD are in the form: 11 r32 mm
; Some like PMOVMSKB are: 11 mm r32.
; This 'Rev'ersed  form is for this second case:

; Was wronbg Doce of Intel-2001. Correct in Intel-2004
;;
Dis_r32_xmmx_Rev:
    On B$OperandSizeOverride = &FALSE, jmp Dis_r32_mmx_Rev
Dis_r32_xmmRev:
    Mov bl B$esi | inc esi
    Call WriteEregsFromRmBits | Mov B$edi SPC | inc edi
    Call WriteXmmRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r32_mmx_Rev:
    Mov bl B$esi | inc esi
    Call WriteEregsFromRmBits | Mov B$edi SPC | inc edi
    Call WriteMMXRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret
;;

Dis_r32_xmmx_imm8:
    On B$OperandSizeOverride = &FALSE, jmp Dis_r32_mmx_imm8

    Mov bl B$esi | inc esi
    Call WriteEregsFromRmBits | Mov B$edi SPC | inc edi
    Call WriteXmmRegsFromRegBits | jmp L9>

Dis_r32_mmx_imm8:
    Mov bl B$esi | inc esi
    Call WriteEregsFromRmBits | Mov B$edi SPC | inc edi
    Call WriteMMXRegsFromRegBits
L9: Mov B$edi SPC | inc edi | Call Writeimm8
    Mov B$DisFlag DISDONE+DISLINEOVER
ret





Dis_PINSRW:
    Mov W$DisSizeMarker 'D$'
    Mov bl B$esi | inc esi

    On B$OperandSizeOverride = &FALSE, jmp L2>

    Call WriteXmmRegsFromRegBits | Mov B$edi SPC | inc edi
    Push edi ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        Call WriteEffectiveAddressFromModRm | jmp L9>

L2:     Call WriteMMXRegsFromRegBits | Mov B$edi SPC | inc edi
    Push edi ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        Call WriteEffectiveAddressFromModRm

L9:     Mov B$edi SPC | inc edi | Call Writeimm8
    Pop eax ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    On B$eax = 'D', Mov B$eax 'W' ; <<<<<<<<<< Old EDI.
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


Dis_r32__xmm_m64:
    Mov bl B$esi | inc esi
    Call WriteEregsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWith.X.XMMmem
ret

Dis_r32__xmm_m32:
    Mov bl B$esi | inc esi
    Call WriteEregsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWith.X.XMMmem
ret

Dis_xmm1__xmm2_m128:
    Mov bl B$esi | inc esi
    Call WriteXMMRegsFromRegBits | Mov B$edi SPC | inc edi
    ModMask bl to al
    If al = 3
        Call WriteXMMRegsFromRmBits
    Else
        Call EndWith.X.XMMmem
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_mm1__mm2_m128:
    Mov bl B$esi | inc esi
    Call WriteMMXRegsFromRegBits | Mov B$edi SPC | inc edi
    ModMask bl to al
    If al = 3
        Call WriteMMXRegsFromRmBits
    Else
        Call EndWith.Q.mem
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_xmm1__xmm2_m128__imm8:
    Call Dis_xmm1__xmm2_m128 | Mov B$edi SPC | inc edi
    Call WriteImm8
ret

Dis_xmm2_m128__xmm1:
    Mov W$DisSizeMarker 'X$'
    Mov bl B$esi | inc esi
    Push ebx
        Call WriteEffectiveXMMAddressFromModRm | Mov B$edi SPC | inc edi
    Pop ebx
    Call WriteXMMRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_xmm1__xmm2_m64:
    Mov bl B$esi | inc esi
    Call WriteXMMRegsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWith.X.XMMmem
ret

Dis_xmm1__xmm2_m32:
    Mov bl B$esi | inc esi
    Call WriteXMMRegsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWith.X.XMMmem
ret

Dis_xmm1__xmm2_m32F:
    Mov bl B$esi | inc esi
    Call WriteXMMRegsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWith.F.mem
ret

Dis_mmx_rm32:
    Mov bl B$esi | inc esi
    Call WriteMMXRegsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWith.D.mem
ret

Dis_xmm_rm32:
    Mov bl B$esi | inc esi
    Call WriteXMMRegsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWith.D.mem
ret

Dis_rm32_xmmx:
    On B$OperandSizeOverride = &TRUE, jmp Dis_rm32_xmm

    Mov bl B$esi | inc esi
    Mov W$DisSizeMarker 'D$'
    Push ebx
        Call WriteEffectiveAddressFromModRm | Mov B$edi SPC | inc edi
    Pop ebx
    Call WriteMMXRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm32_xmm:
    Mov bl B$esi | inc esi
    Mov W$DisSizeMarker 'D$'
    Push ebx
        Call WriteEffectiveAddressFromModRm | Mov B$edi SPC | inc edi
    Pop ebx
    Call WriteXMMRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_mmx1__xmm2_m128:
    Mov bl B$esi | inc esi
    Call WriteMMXRegsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWith.X.XMMmem
ret

Dis_mmx1__xmm2_m64:
    Mov bl B$esi | inc esi
    Call WriteMMXRegsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWith.X.XMMmem
ret

Dis_xmm2_m64__xmm1:
    Mov bl B$esi | inc esi
    Mov W$DisSizeMarker 'X$'
    Push ebx
        Call WriteEffectiveXMMAddressFromModRm | Mov B$edi SPC | inc edi
    Pop ebx
    Call WriteXMMRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret



Dis_xmm2_m32F__xmm1:
    Mov bl B$esi | inc esi
    Mov W$DisSizeMarker 'F$'
    Push ebx
        Call WriteEffectiveAddressFromModRm | Mov B$edi SPC | inc edi
    Pop ebx
    Call WriteXMMRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_mmx1__mmx2_m64:
    Mov bl B$esi | inc esi
    Call WriteMMXRegsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWith.Q.MMXmem

Dis_mmx1__mmx2_m64_v2: ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Looki
    Mov bl B$esi | inc esi | inc esi
    Call WriteMMXRegsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWith.Q.MMXmem

MMX6428:
    If B$OperandSizeOverride = &TRUE
        jmp Dis_xmm1__xmm2_m128
    Else
        jmp Dis_mmx1__mmx2_m64
    End_If

Dis_xmm1_xmm_m128:
    Mov bl B$esi | inc esi
    Call WriteXMMRegsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWith.X.XMMmem



Dis_mmx_xmm:
    Mov bl B$esi | inc esi
    RegMask bl to al
    Mov D$edi 'MMX0', B$edi+4 SPC | add B$edi+3 al | add edi 5
    BaseMask bl to al
    Mov D$edi 'XMM0', B$edi+4 SPC | add B$edi+3 al | add edi 4
ret

Dis_xmm_mmx:
    Mov bl B$esi | inc esi
    RegMask bl to al
    Mov D$edi 'XMM0', B$edi+4 SPC | add B$edi+3 al | add edi 5
    BaseMask bl to al
    Mov D$edi 'MM0 ' | add B$edi+2 al | add edi 3
ret

Dis_xmm1__mmx2_m64:
Dis_xmm1__mmx2_m128:
    Mov bl B$esi | inc esi
    Call WriteXMMRegsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWith.X.XMMmem
ret

Dis_mmx2_m128__xmm1:
    Mov bl B$esi | inc esi
    Mov W$DisSizeMarker 'X$'
    Push ebx
        Call WriteEffectiveXMMAddressFromModRm | Mov B$edi SPC | inc edi
    Pop ebx
    Call WriteXMMRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_mmx1_m64__mmx2:
    Mov bl B$esi | inc esi
    Mov W$DisSizeMarker 'Q$'
    Push ebx
        Call WriteEffectiveMMXAddressFromModRm | Mov B$edi SPC | inc edi
    Pop ebx
    Call WriteMMXRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_xmm1__rm32:
    Mov bl B$esi | inc esi
    Call WriteXMMRegsFromRegBits | Mov B$edi SPC | inc edi | jmp EndWith.D.mem
ret

Dis_xmmx_imm8:
    On B$OperandSizeOverride = &FALSE, jmp Dis_mmx_imm8

Dis_xmm_imm8:
   ; Mov bl B$esi | inc esi
    Call WriteXMMRegsFromRmBits | Mov B$edi SPC | inc edi
    Call WriteImm8
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_mmx_imm8:
   ; Mov bl B$esi | inc esi
    Call WriteMMXRegsFromRmBits | Mov B$edi SPC | inc edi
    Call WriteImm8
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_m64:
    Mov W$DisSizeMarker 'Q$'
    Call WriteEffectiveAddressFromModRm
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_m32_16:
    On B$OperandSizeOverride = &TRUE, Mov W$DisSizeMarker 'W$'
    Call WriteEffectiveAddressFromModRm
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_m8:
    Mov W$DisSizeMarker 'B$'
    Call WriteEffectiveAddressFromModRm
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


WritePacketCondition:
    Mov B$edi SPC | inc edi | lodsb | and eax 0FF

    Push eax
        Call WriteEax
    Pop eax

    Mov D$edi ' ; (' | add edi 4

    If al = 0
        Mov D$edi 'EQ) ' | add edi 3
    Else_If al = 1
        Mov D$edi 'LT) ' | add edi 3
    Else_If al = 2
        Mov D$edi 'LE) ' | add edi 3
    Else_If al = 3
        Mov D$edi 'UNOR', W$edi 'D)' | add edi 6
    Else_If al = 4
        Mov D$edi 'NEQ)' | add edi 4
    Else_If al = 5
        Mov D$edi 'NLT)' | add edi 4
    Else_If al = 6
        Mov D$edi 'NLE)' | add edi 4
    Else_If al = 7
        Mov D$edi 'ORD)' | add edi 4
    Else
        add D$UnlikelyCode 5
    End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret


EndWith.B.mem:
    Mov W$DisSizeMarker 'B$' | jmp EndWithModRm
ret

EndWith.W.mem:
    Mov W$DisSizeMarker 'W$'
EndWith.D.mem:
EndWithModRm:
    Call WriteEffectiveAddressFromModRm
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

EndWith.WD.mem:
    On B$OperandSizeOverride = &TRUE, jmp EndWith.W.mem
    Call WriteEffectiveAddressFromModRm
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

EndWith.Q.mem:
    Mov W$DisSizeMarker 'Q$' | jmp EndWithModRm
ret

EndWith.F.mem:
    Mov W$DisSizeMarker 'F$' | jmp EndWithModRm
ret

EndWith.R.mem:
    Mov W$DisSizeMarker 'R$' | jmp EndWithModRm
ret

EndWith.T.mem:
    Mov W$DisSizeMarker 'T$' | jmp EndWithModRm
ret

EndWith.X.mem:
    Mov W$DisSizeMarker 'X$' | jmp EndWithModRm
ret

EndWith.X.XMMmem:

    Mov W$DisSizeMarker 'X$'
    ModMask bl to al
    If al = 3
        Call WriteXMMregsFromRmBits
    Else
        Call EndWithModRm
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

EndWith.Q.MMXmem:
    Mov W$DisSizeMarker 'Q$'
    ModMask bl to al
    If al = 3
        Call WriteMMXregsFromRmBits
    Else
        Call EndWithModRm
    End_If
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

;Dis_xmmx1_xmmx2:
    On B$OperandSizeOverride = &TRUE, jmp Dis_xmm1_xmm2

Dis_mmx1_mmx2:
    Call WriteMMXRegsFromRegBits | Mov B$edi SPC | inc edi
    Call WriteMMXRegsFromRmBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_xmm1_xmm2:
    Call WriteXMMRegsFromRegBits | Mov B$edi SPC | inc edi
    Call WriteXMMRegsFromRmBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_xmm_m64:
    Call WriteXMMRegsFromRegBits | Mov B$edi SPC | inc edi
    Mov W$DisSizeMarker 'X$' | jmp EndWithModRm
ret

Dis_m64_xmm:
    Mov W$DisSizeMarker 'X$' | Call WriteEffectiveAddressFromModRm
    Mov B$edi SPC | inc edi
    Call WriteXMMRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_m64_mmx:
    Mov W$DisSizeMarker 'Q$' | Call WriteEffectiveAddressFromModRm
    Mov B$edi SPC | inc edi
    Call WriteMMXRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_m128_xmm:
    Mov W$DisSizeMarker 'X$' | Call WriteEffectiveAddressFromModRm
    Mov B$edi SPC | inc edi
    Call WriteXMMRegsFromRegBits
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; Now come the terminal writing Routines.
____________________________________________________________________________________________
____________________________________________________________________________________________


[NextDisLine | Push eax | Mov eax 020200A0D | stosd | Mov eax '    ' | stosw | Pop eax]

[DisFlag: D$ ?
 SegmentOverride: D$ ?
 OperandSizeOverride: D$ ?
 AddressSizeOverride: D$ ?
 EscapePrefix: D$ ?]

[DISDONE 1    DISLINEOVER 2    DISFAILED 0]

; Reads a Byte, returns the Hexa in ax. If The Hexa is greater than '0F', writes the
; wanted leading '0'.

[STR.A.Hexa: B$ '0123456789ABCDEF']


LoadedOpToHexa:             ; If the Byte has already been loaded for some caller test.
    Mov ebx eax | shr ebx 4
    and eax 0F | and ebx 0F
    Mov al B$STR.A.Hexa+eax, bl B$STR.A.Hexa+ebx
    If ebx > '0'
        Mov B$edi '0' | inc edi
    End_If
    shl eax 8 | or eax ebx
ret


[ModMask | Mov #3 #1 | and #3 0011_000_000 | shr #3 6]
[DigitMask | Mov #3 #1 | and #3 00_111_000 | shr #3 3]
[RegMask   | Mov #3 #1 | and #3 00_111_000 | shr #3 3]
[RmMask    | Mov #3 #1 | and #3 00_000_111]

[ScaleMask | Mov #3 #1 | and #3 00_11_000_000 | shr #3 6]
[IndexMask | Mov #3 #1 | and #3 00_111_000 | shr #3 3]
[BaseMask  | Mov #3 #1 | and #3 00_000_111]
;;
 'DisSizeMarker' is set to 'D$' by default. If a 066 OpCode is encouneted, 'DisSizeMarker'
 is set to 'W$' at that time. So, All the OpCode Routines have the overwrite this Marker
 only in case of Bytes (which is always specific to one given OpCode).
;;
[DisSizeMarker: D$ ?]


[dWordRegsTable: B$ 'eax ecx edx ebx esp ebp esi edi '
 WordRegsTable: B$ 'ax  cx  dx  bx  sp  bp  si  di  '
 ByteRegsTable: B$ 'al  cl  dl  bl  ah  ch  dh  bh  '
 SregsTable: B$ 'es  cs  ss  ds  fs  gs          ']

WriteEregsFromRmBits:
    RmMask bl To al | and eax 0FF
    Move D$edi D$dWordRegsTable+eax*4 | add edi 3
ret

WriteEregsFromRegBits:
    RegMask bl To al | and eax 0FF
    Move D$edi D$dWordRegsTable+eax*4 | add edi 3
ret

WritedWordRegsFromRegBits:
    On B$OperandSizeOverride = &TRUE, jmp WriteWordRegsFromRegBits
    RegMask bl To al | and eax 0FF
    Move D$edi D$dWordRegsTable+eax*4 | add edi 3
Ret

WriteSregsFromModRm:
    RegMask bl To al | and eax 0FF
    Move D$edi D$SregsTable+eax*4 | add edi 2  ; 0010001110 08C 00111
ret

WriteWordRegsFromRegBits:
    RegMask bl To al | and eax 0FF
    Move D$edi D$WordRegsTable+eax*4 | add edi 2

Ret

WriteMMXRegsFromRegBits:
    RegMask bl To al
    Mov D$edi 'MM0 ' | add B$edi+2 al | add edi 3
Ret

WriteMMXRegsFromRmBits:
    RmMask bl To al
    Mov D$edi 'MM0 ' | add B$edi+2 al | add edi 3
Ret

WriteXMMRegsFromRegBits:
    RegMask bl To al
    Mov D$edi 'XMM0' | add B$edi+3 al | add edi 4
Ret

WriteXMMRegsFromRmBits:
    RmMask bl To al
    Mov D$edi 'XMM0' | add B$edi+3 al | add edi 4
Ret

WriteWordRegsFromRmBits:
    RmMask bl To al | and eax 0FF
    Move D$edi D$WordRegsTable+eax*4 | add edi 2
ret

WriteByteRegsFromRmBits:
    RmMask bl To al | and eax 0FF
    Move D$edi D$ByteRegsTable+eax*4 | add edi 2
ret

WriteByteRegsFromRegBits:
    RegMask bl To al | and eax 0FF
    Move D$edi D$ByteRegsTable+eax*4 | add edi 2
ret


; Writes, for example: 'D$', 'CS:B$cs:', ...
StartEffectiveAddress:
    Move W$edi W$DisSizeMarker | add edi 2

    If D$SegmentOverride <> 0
        Move D$edi D$SegmentOverride | add edi 3
    End_If
ret


WriteFromSib: ; 085  00_10_000_101
    ModMask bl To cl                                ; Saves the MOD Bits for Base5 case.
    lodsb | Mov bl al | BaseMask bl To al ; 025 00_00_100_101

    If al = 0      | Mov D$edi 'eax+' | add edi 4
    Else_If al = 1 | Mov D$edi 'ecx+' | add edi 4
    Else_If al = 2 | Mov D$edi 'edx+' | add edi 4
    Else_If al = 3 | Mov D$edi 'ebx+' | add edi 4
    Else_If al = 4 | Mov D$edi 'esp+' | add edi 4
    Else_If al = 5 | Call Base5                     ; No Base or ebp with dis 8 or 32
    Else_If al = 6 | Mov D$edi 'esi+' | add edi 4
    Else           | Mov D$edi 'edi+' | add edi 4
    End_If

    IndexMask bl To al

    .If al = 0      | Mov D$edi 'eax ' | add edi 3
    .Else_If al = 1 | Mov D$edi 'ecx ' | add edi 3
    .Else_If al = 2 | Mov D$edi 'edx ' | add edi 3
    .Else_If al = 3 | Mov D$edi 'ebx ' | add edi 3
    .Else_If al = 4
        If cl = 0FF
          ; Example: cmp ah B$078
            On W$DisSizeMarker <> 'D$', inc D$UnlikelyCode
        End_If
        On B$edi-1 = '+', dec edi             ; None / Strip the '+'
        jmp L9>
    .Else_If al = 5 | Mov D$edi 'ebp ' | add edi 3
    .Else_If al = 6 | Mov D$edi 'esi ' | add edi 3
    .Else           | Mov D$edi 'edi ' | add edi 3
    .End_If

    ScaleMask bl To al

    If al = 0                                       ; no need *1
    Else_If al = 1 | Mov W$edi '*2' | add edi 2
    Else_If al = 2 | Mov W$edi '*4' | add edi 2
    Else_If al = 3 | Mov W$edi '*8' | add edi 2
    End_If
L9: ret


Base5:          ; No Base or ebp with dis 8 or 32 (cl is the MOD bits from previous ModRm).
    If cl <> 0
        Mov D$edi 'ebp+' | add edi 4
    Else
        Mov cl 0FF
    End_If
ret


[ToJumpsTable: D$ ?] ; Might now be removed entirely.

WriteBase5dis32:
    If B$edi-1 <> '+'
        Mov B$edi '+' | inc edi
    End_If

WriteDis32:
    If B$AddressSizeOverride = &FALSE
        lodsd
    Else
WriteDis16:
        lodsw | and eax 0FFFF | Call WriteEax | ret
    End_If

WriteDisRelative:
    Mov D$LastCodeRef eax | On eax = 0, jmp L8>>

L0: If B$SimpleScan = &TRUE
        Mov B$DisFlag DISDONE+DISLINEOVER | ret
    End_If

L0: On B$WeAreInTheCodeBox = &TRUE, jmp L8>>
;On eax = 01013E38, int3
    sub eax D$DisImageBase | add eax D$SectionsMap

    On eax >= D$EndOfSectionsMap, jmp L8>>
    On eax <= D$SectionsMap, jmp L8>>

    Mov B$ToJumpsTable &FALSE
    Mov al B$eax | and al DATAFLAG+VIRTUALFLAG+IMPORTFLAG+CODEFLAG
;map
    ..If al = 0
        Mov eax D$LastCodeRef

        Mov ebx eax | sub ebx D$DisImageBase | add ebx D$SizesMap

            .If B$LeaInstruction = &TRUE
                Mov B$LeaInstruction &FALSE
                sub ebx D$SizesMap | add ebx D$SectionsMap | Mov B$ebx DATAFLAG
            .Else_If W$edi-2 = 'B$'
                or B$ebx BYTE
                sub ebx D$SizesMap | add ebx D$SectionsMap | Mov B$ebx DATAFLAG
            .Else_If W$edi-2 = 'W$'
                or B$ebx WORD
                sub ebx D$SizesMap | add ebx D$SectionsMap
                Mov B$ebx DATAFLAG, B$ebx+1 DATAFLAG
            .Else_If W$edi-2 = 'D$'
                or B$ebx DWORD
                sub ebx D$SizesMap | add ebx D$SectionsMap
                Mov D$ebx FOURDATAFLAGS
            .Else_If W$edi-2 = 'F$'
                or B$ebx FP4
                sub ebx D$SizesMap | add ebx D$SectionsMap
                Mov D$ebx FOURDATAFLAGS
            .Else_If W$edi-2 = 'R$'
                or B$ebx FP8
                sub ebx D$SizesMap | add ebx D$SectionsMap
                Mov D$ebx FOURDATAFLAGS, D$ebx+4 FOURDATAFLAGS
            .Else_If W$edi-2 = 'T$'
                or B$ebx FP10
                sub ebx D$SizesMap | add ebx D$SectionsMap
                Mov D$ebx FOURDATAFLAGS, D$ebx+4 FOURDATAFLAGS, D$ebx+6 FOURDATAFLAGS
            .Else
                jmp L8>>
               ; or B$ebx POINTER
            .End_If

    ..Else_If al = DATAFLAG
        Mov eax D$LastCodeRef | Call StoreDisSize
        sub eax D$DisImageBase | add eax D$RoutingMap | or B$eax LABEL+EVOCATED
        Mov D$edi 'Data' | add edi 4 | jmp L8>>

    ..Else_If al = CODEFLAG
      ; Is it a Call to a Jumps Table?
        Mov eax D$LastCodeRef
        sub eax D$DisImageBase | add eax D$UserPeStart

        If W$eax = 025FF ; Code of jmp relative long
            Mov ebx D$eax+2 | sub ebx D$DisImageBase | add ebx D$SectionsMap
            On ebx > D$EndOfSectionsMap, jmp L1>
            On ebx < D$SectionsMap, jmp L1>
                On B$ebx <> IMPORTFLAG, jmp L1>

                    Mov B$ApiCommentWanted &TRUE, ebx D$eax+2, D$PtrToApiName ebx
        End_If

L1:     Mov eax D$LastCodeRef
        sub eax D$DisImageBase | add eax D$RoutingMap
        test B$eax INSTRUCTION ZERO L8>>
        or B$eax NODE+LABEL | Mov D$edi 'Code' | add edi 4 | jmp L8>>

    ..Else_If al = VIRTUALFLAG
        Mov eax D$LastCodeRef | Call StoreDisSize
        sub eax D$DisImageBase | add eax D$RoutingMap | or B$eax LABEL+EVOCATED
        Mov D$edi 'Virt', D$edi+4 'ual ' | add edi 7 | jmp L8>>

    ..Else_If al = IMPORTFLAG
        Mov ebx D$LastCodeRef
L5:     sub ebx D$DisImageBase | add ebx D$UserPeStart | Mov ebx D$ebx
      ; May be a wrong pointing inside the .Import!
      ; Add a Pointer test!
        On ebx < D$ApiBuffer, ret
        On ebx >= D$EndOfApiBuffer, ret

        Push esi

            On W$edi-2 = 'D$', sub edi 2

            Mov esi ebx

            .If D$edi-4 = 'jmp '    ; Jumps Table?
                Call WriteApiJmpTableLabel

                While B$esi <> 0 | movsb | End_While

            .Else_If D$edi-4 = 'all '  ; Call api?
                Call FlagNoReturnApi
                Call FlagApiProcedures
                While B$esi <> 0 | movsb | End_While

            .Else_If D$edi-4 = '$cs:'
                sub edi 5 | jmp L6>

          ; Other case: Either "Mov eax D$ApiCall" or "Mov D$eax ApiCall"
            .Else
                Push edi
                    Mov al "'"
                    While B$edi > LF
                        dec edi
                        On B$edi = '$', Mov al 0
                    End_While
                Pop edi
L6:             Mov esi ebx
                If al = 0
                    While B$esi <> '.' | inc esi | End_While | inc esi
                End_If
                While B$esi <> 0 | movsb | End_While
                On al = 0, dec edi

            .End_If
        Pop esi

     ..End_If
ret

L8: On B$WeAreInTheCodeBox = &FALSE, jmp L8>

    INT3 | NOP ; ANCIEN TITLE LIB
;;
    
    On D$LibFileMemory = 0, jmp L8>
        Push esi
            Mov esi D$LastCodeRef
            .If esi > D$LibFileMemory
                Mov eax D$LibFileMemory | add eax D$LibFileLength
                If esi < eax
                    While B$esi <> 0 | movsb | End_While
                   ; Mov D$edi ' ; <', D$edi+4 '<<<<' | add edi 8
                Else
                    Pop esi | jmp L8>
                End_If
            .Else
                Pop esi | jmp L8>
            .End_If
        Pop esi
        ret
;;

L8: ;On D$LastCodeRef = 0438E28, int3

    .If B$edi-1 = '+'
        If W$edi-3 = '*2'
            Call TryWithIndice 2
        Else_If W$edi-3 = '*4'
            Call TryWithIndice 4
        Else_If W$edi-3 = '*8'
            Call TryWithIndice 8
        End_If
    .End_If

    If W$DisplacementFromLabel = 0
        Mov eax D$LastCodeRef | sub eax D$DisImageBase | add eax D$SizesMap
        Mov ebx D$SizesMap | add ebx 4
        On eax < ebx, jmp L8>
        On eax > D$EndOfSizesMap, jmp L8>
        test B$eax-4 FP8 ZERO L8>
            sub D$LastCodeRef 4 | Mov W$DisplacementFromLabel '+4'
    End_If

L8: Push 0-1

    Mov ebx D$LastCodeRef

L0: Mov eax ebx | shr ebx 4 | and eax 0F
    add eax '0' | On eax > '9', add eax 7
    Push eax
    cmp ebx 0 | ja L0<

    Mov B$edi '0' | inc edi
L0: Pop eax | cmp eax 0-1 | je L9>
    Mov B$edi al | inc edi | jmp L0<

L9: Mov ebx D$LastCodeRef | sub ebx D$DisImageBase | add ebx D$UserPeStart

    ..If ebx > D$UserPeStart
        .If ebx < D$UserPeEnd
            Mov ebx D$LastCodeRef | ToStringsMapFrom DisImageBase, ebx
            If D$ebx <> 0
                Push esi
                ;On D$LastCodeRef = 04037EC, showme D$ebx

                Push esi | Mov esi D$ebx | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi

                Pop esi
            End_If
        .End_If
    ..End_If

    If W$DisplacementFromLabel <> 0
        Mov ax W$DisplacementFromLabel | stosw
        Mov W$DisplacementFromLabel 0
    End_If

    Mov eax D$LastCodeRef | sub eax D$DisImageBase | add eax D$SectionsMap

    .If eax < D$SectionsMap
        ;
    .Else_If eax < D$EndOfSectionsMap
        If B$eax = DATAFLAG
            sub eax D$SectionsMap | add eax D$RoutingMap | or B$eax LABEL+EVOCATED
        End_If
    .End_If

    On B$ApiCommentWanted = &TRUE, Call WriteApiLabelComment
ret


[DisplacementFromLabel: D$ ?]

Proc TryWithIndice:
    Argument @Indice

        Mov eax D$LastCodeRef | add eax D@Indice
        sub eax D$DisImageBase | add eax D$SectionsMap

        ..If eax < D$SectionsMap
            ;
        ..Else_If eax < D$EndOfSectionsMap
            .If B$eax = DATAFLAG
                sub eax D$SectionsMap | add eax D$RoutingMap
                test B$eax LABEL+EVOCATED ZERO L9>
                    Mov eax D@Indice | add D$LastCodeRef eax
                    If eax = 2
                        Mov W$DisplacementFromLabel '-2'
                    Else_If eax = 4
                        Mov W$DisplacementFromLabel '-4'
                    Else_If eax = 8
                        Mov W$DisplacementFromLabel '-8'
                    End_If

                    Mov D$edi 'Data' | add edi 4
            .End_If
        ..End_If
L9:
EndP
____________________________________________________________________________________________

WriteApiLabel:
    While B$esi <> 0
        lodsb
;;
  ; No need as long as they are all Comments, now:
        If al = '$'
            Mov al 'S'
        Else_If al = '$'
            Mov al 'S'
        Else_If al = '@'
            Mov al 'a'
        End_If
;;
        stosb
    End_While
ret

[ApiCommentWanted: D$ ?
 PtrToApiName: D$ ?]

WriteApiLabelComment:
    Push esi
        Mov B$ApiCommentWanted &FALSE

        Mov D$edi ' ; ' | add edi 3
        Mov esi D$PtrToApiName
        sub esi D$DisImageBase | add esi D$UserPeStart
        Mov esi D$esi
        Push esi
            Call WriteApiLabel
        Pop esi
        Call FlagApiProcedures
    Pop esi
ret


WriteApiJmpTableLabel:
    While B$edi-1 > LF | dec edi | End_While

    Push esi
        Mov W$edi '; ' | add edi 2

        Mov esi ebx | inc esi

        Call WriteApiLabel
    Pop esi

    Mov B$edi-1 ':' | NextDisLine
    Mov D$edi 'jmp ' | add edi 4
ret
____________________________________________________________________________________________

FlagNoReturnApi:
    Push esi
        inc esi
;;
      ; MSVBVM50.064 ???
        ...If D$esi = 'MSVB'
            ..If D$esi+4 = 'VM50'
                .If D$esi+8 = '.064'
                    If B$esi+12 = "'"
                        Mov B$DisEndOfChunk &TRUE
                    End_If
                .End_If
            ..End_If
        ...End_If
;;
        While B$esi <> '.' | inc esi | End_While | inc esi

      ; ExitProcess
        ...If D$esi = 'Exit'
            ..If D$esi+4 = 'Proc'
                If D$esi+8 = "ess'"
                    Mov B$DisEndOfChunk &TRUE
                End_If
            ..End_If

      ; __vbaErrorOverflow
        ...Else_If D$esi = '__vb'
            ..If D$esi+4 = 'aErr'
                .If D$esi+8 = 'orOv'
                    If D$esi+12 = 'erfl'
                        On W$esi+16 = 'ow', Mov B$DisEndOfChunk &TRUE
                    End_If
                .End_If
            ..End_If

        ...Else
          ; For freezing the 'IsItNoReturnCall' test:
            Mov B$CallInstruction &FALSE

        ...End_If
    Pop esi
ret
____________________________________________________________________________________________

;;
  The 4 Dialogs Creations Functions:
  
        'USER32.CreateDialogParamA'         >>> second above Push
        'USER32.CreateDialogindirectParamA' >>> second above Push
        
        'USER32.DialogBoxParamA'            >>> second above Push
        'USER32.DialogBoxindirectParamA'    >>> second above Push

  The 'USER32.SetWindowLong' Function, with the "GWL_WNDPROC" Parameter
  GWL_WNDPROC >>> second above Push
  Procedure >>> first above Push

  The 'KERNEL32.CreateThread' Function.     >>> fourth above Push

  The 'USER32.SetWindowsHookExA' Function.          >>> third above Push
  
  List of Api with CallBacks:
  
    USER32.CreateDialogParamA
    USER32.CreateDialogindirectParamA
    USER32.DialogBoxParamA
    USER32.DialogBoxindirectParamA
    USER32.SetWindowLongA
    KERNEL32.CreateThread
    USER32.SetWindowsHookExA
    USER32.EnumChildWindows
;;

FlagApiProcedures:
    Push esi

    While B$esi <> '.' | inc esi | End_While | inc esi

      ; ExitProcess
        ...If D$esi = 'Crea'
            ..If D$esi+4 = 'teDi'
                .If D$esi+8 = "alog"
                    If D$esi+12 = 'Para'
                      ; 'USER32.CreateDialogParamA'
                        Call GetDialogProcedure

                    Else_If D$esi+12 = 'indi'
                      ; 'USER32.CreateDialogindirectParamA'
                        Call GetDialogProcedure

                    End_If
                .End_If
            ..End_If

        ...Else_If D$esi = 'Dial'
            ..If D$esi+4 = 'ogBo'
                If D$esi+8 = 'xPar'
                  ; 'USER32.DialogBoxParamA'
                    Call GetDialogProcedure

                Else_If D$esi+8 = 'indi'
                  ; 'USER32.DialogBoxindirectParamA'
                    Call GetDialogProcedure

                End_If
            ..End_If

        ...Else_If D$esi = 'SetW'
            ..If D$esi+4 =  'indo'
                .If D$esi+8 = 'wLon'
                  ; 'USER32.SetWindowLongA'
                    Call GetApiPush 2
                    If eax = &GWL_WNDPROC
                        Call GetApiPush 3
                        On eax <> 0, Call SetApiProcedure eax, WindowProcName
                    End_If
                .End_If
            ..End_If

        ...Else_If D$esi = 'Crea'
            ..If D$esi+4 = 'teTh'
                If D$esi+8 = 'read'
                  ; 'KERNEL32.CreateThread'
                    Call GetApiPush 3
                    On eax <> 0, Call SetApiProcedure eax, ThreadProcName
                End_If
            ..End_If

        ...Else_If D$esi = 'SetW'
            ..If D$esi+4 = 'indo'
                .If D$esi+8 = 'wsHo'
                    If D$esi+12 = 'okEx'
                      ; 'USER32.SetWindowsHookExA'
                        Call GetApiPush 2
                        On eax <> 0, Call SetApiProcedure eax, HookProcName
                    End_If
                .End_If
            ..End_If

        ...Else_If D$esi = 'Enum'
            ..If D$esi+4 = 'Chil'
                .If D$esi+8 = 'dWin'
                    If D$esi+12 = 'dows'
                      ; 'USER32.EnumChildWindows'
                        Call GetApiPush 2
                        On eax <> 0, Call SetApiProcedure eax, EnumChildWindowsProcName
                    End_If
                .End_If
            ..End_If

        ...Else_If D$esi = 'lstr'
            ..If D$esi+4 = 'cpyA'
              ; 'KERNEL32.lstrcpyA'
                Call GetApiPush 1
                On eax <> 0, Call SetApiData eax
                Call GetApiPush 2
                On eax <> 0, Call SetApiData eax
            ..End_If

        ...Else_If D$esi = 'Regi'
            ..If D$esi+4 = 'ster'
                .If D$esi+8 = 'Clas'
                    If D$esi+12 = 'sExA'
                      ; 'USER32.RegisterClassExA/W'
L1:                     Call GetApiPush 1 | On eax = 0, jmp L9>
                        Push eax
                            Call SelectMainWindowProc eax, 12
                        Pop eax
                        Call SetWINDCLASSEXData eax

                    Else_If D$esi+12 = 'sExW'
                        jmp L1<

                    Else_If B$esi+12 = 's'
                      ; 'USER32.RegisterClassA/W'
                        Call GetApiPush 1 | On eax = 0, jmp L9>
                        Push eax
                            Call SelectMainWindowProc eax, 10
                        Pop eax
                        Call SetWINDCLASSData eax
                    End_If

                .End_If
            ..End_If
        ...End_If
L9: Pop esi
ret


[DisMainWindowProc: D$ ?]

Proc SelectMainWindowProc:
    Argument @WNDCLASS, @N
    Uses edi, ebx, ecx

        Mov eax D@WNDCLASS | sub eax D$DisImageBase | add eax D$UserPeStart

        Mov eax D$eax+8

        ..If eax <> 0
            .If D$DisMainWindowProc = 0
                Mov D$DisMainWindowProc eax
                Call SetApiProcedure eax, MainWindowProcName

            .Else
              ; Several candidates: Take the one closer to 'Main':
                Mov ebx D$DisMainWindowProc | sub ebx D$DisEntryPoint | Absolute ebx
                Mov ecx eax | sub ecx D$DisEntryPoint | Absolute ecx
                If ecx < ebx
                    Call SetApiProcedure D$DisMainWindowProc, WindowProcName
                    Call SetApiProcedure eax, MainWindowProcName
                    Mov D$DisMainWindowProc eax
                Else_If ecx > ebx
                    Call SetApiProcedure eax, WindowProcName
                End_If
            .End_If
        ..End_If

        Mov edi D@WNDCLASS | sub edi D$DisImageBase | add edi D$SectionsMap

        Mov ecx D@N, eax FOURDATAFLAGS | rep stosd
EndP


[WNDCLASS.cbSize.Name: B$'_cbSize' EOS
 WNDCLASS.style.Name: B$ '_style' EOS
 WNDCLASS.lpfnWndProc.Name: B$ '_lpfnWndProc' EOS
 WNDCLASS.cbClsExtra.Name: B$ '_cbClsExtra' EOS
 WNDCLASS.cbWndExtra.Name: B$ '_cbWndExtra' EOS
 WNDCLASS.hInstance.Name: B$ '_hInstance' EOS
 WNDCLASS.hIcon.Name: B$ '_hIcon' EOS
 WNDCLASS.hCursor.Name: B$ '_hCursor' EOS
 WNDCLASS.hbrBackground.Name: B$ '_hbrBackground' EOS
 WNDCLASS.lpszMenuName.Name: B$ '_lpszMenuName' EOS
 WNDCLASS.lpszClassName.Name: B$ '_lpszClassName' EOS
 WNDCLASS.hIconSm.Name: B$ '_hIconSm' EOS]

Proc SetWINDCLASSData:
    Argument @Pointer
    Uses edi

        Mov eax D@Pointer

        ToStringsMapFrom DisImageBase eax
        Mov D$eax WNDCLASS.style.Name | add eax 16
        Mov D$eax WNDCLASS.lpfnWndProc.Name | add eax 16
        Mov D$eax WNDCLASS.cbClsExtra.Name | add eax 16
        Mov D$eax WNDCLASS.cbWndExtra.Name | add eax 16
        Mov D$eax WNDCLASS.hInstance.Name | add eax 16
        Mov D$eax WNDCLASS.hIcon.Name | add eax 16
        Mov D$eax WNDCLASS.hCursor.Name | add eax 16
        Mov D$eax WNDCLASS.hbrBackground.Name | add eax 16
        Mov D$eax WNDCLASS.lpszMenuName.Name | add eax 16
        Mov D$eax WNDCLASS.lpszClassName.Name

        Mov edi D@Pointer | sub edi D$DisImageBase | add edi D$RoutingMap
        Mov eax LABEL, ecx 10 | rep stosd

        Mov edi D@Pointer | sub edi D$DisImageBase | add edi D$SizesMap
        Mov eax DWORD, ecx 10 | rep stosd
EndP


Proc SetWINDCLASSEXData:
    Argument @Pointer
    Uses edi

        Mov eax D@Pointer | ToStringsMapFrom DisImageBase, eax

        Mov D$eax WNDCLASS.cbSize.Name | add eax 16
        Mov D$eax WNDCLASS.style.Name | add eax 16
        Mov D$eax WNDCLASS.lpfnWndProc.Name | add eax 16
        Mov D$eax WNDCLASS.cbClsExtra.Name | add eax 16
        Mov D$eax WNDCLASS.cbWndExtra.Name | add eax 16
        Mov D$eax WNDCLASS.hInstance.Name | add eax 16
        Mov D$eax WNDCLASS.hIcon.Name | add eax 16
        Mov D$eax WNDCLASS.hCursor.Name | add eax 16
        Mov D$eax WNDCLASS.hbrBackground.Name | add eax 16
        Mov D$eax WNDCLASS.lpszMenuName.Name | add eax 16
        Mov D$eax WNDCLASS.lpszClassName.Name | add eax 16
        Mov D$eax WNDCLASS.hIconSm.Name

        Mov edi D@Pointer | sub edi D$DisImageBase | add edi D$RoutingMap
        Mov eax LABEL+EVOCATED, ecx 12 | rep stosd

        Mov edi D@Pointer | sub edi D$DisImageBase | add edi D$SizesMap
        Mov eax DWORD, ecx 12 | rep stosd
EndP


Proc GetApiPush:
    Argument @Indice

        Mov D$PossibleApiPointer 0

        Mov esi D$TestLastLineLocation | On esi = 0, jmp L9>>

        dec esi | Mov ebx esi | sub ebx D$UserPeStart | add ebx D$RoutingMap

L0:     movzx eax B$ebx
        test eax INSTRUCTION ZERO L2>>
        test eax NODE+EXPORTNODE+PUSH_EBP NOT_ZERO L9>>

            Mov al B$esi
          ; IsItPush    >>>>>>>>>   Op68 !!!!!!!!!!!
            .If al = 060 ; pushad
                jmp L9>>
            .Else_If al = 0FF ; OpFF // /6   ; 75
                DigitMask B$esi+1 To al
                If al = 6
                    Mov eax &TRUE
                Else
                    Mov eax &FALSE
                End_If

            .Else_If al = 06A
                Mov eax &TRUE
            .Else_If al = 068
                Mov eax &TRUE
            .Else_If al < 050
                Mov eax &FALSE
            .Else_If al < 058
                Mov eax &TRUE       ; Push reg (050 to 057)
            .Else
                Mov eax &FALSE
            .End_If

            ...If eax = &TRUE
                dec D@Indice

                ..If D@Indice = 0
                    If B$esi = 0FF ; OpFF, 035 = 00_110_101
                        add esi 2 | lodsd
                        cmp eax D$UserPeStart | jb L9>>
                        cmp eax D$UserPeEnd | ja L9>>
                            Mov eax D$eax | ExitP

                    Else_If B$esi = 068 ; Op68
                        cmp B$esi-1 0F | je L9>  ; Op0F: Escape Prefix
                        cmp B$esi-1 066 | je L9>;   Op66 >>> Operand Size Override
                            inc esi | lodsd | ExitP
                    End_If

                ..End_If
            ...End_If

L2:     dec ebx | dec esi | jmp L0<<

L9:     Mov eax 0
EndP


[PossibleApiPointer: D$ ?
 PossibleApiPointerIndice: D$ ?]

GetDialogProcedure:
    Call GetApiPush 4

    .If eax <> 0
        Call SetApiProcedure eax, DialogProcName

    .Else_If D$PossibleApiPointer <> 0
;;
  There are case of:
  
        Call 'KERNEL32.GetModuleHandleA'  ; FF 15 80 C1 43 00 
        Push eax
        
        used inside the PUSHes flow, to set-up the 'H.Instance' Member.
;;
        If D$PossibleApiPointerIndice = 3
            Call GetApiPush 5
            On eax <> 0, Call SetApiProcedure eax, DialogProcName
        End_If

    .End_If
ret


[MainWindowProcName: B$ 'MainWindowProc' EOS]
[WindowProcName: B$ '_WindowProc' EOS]
[ThreadProcName: B$ '_ThreadProc' EOS]
[HookProcName: B$ '_HookProc' EOS]
[EnumChildWindowsProcName: B$ '_EnumChildWindowsProc' EOS]
[DialogProcName: B$ '_DialogProc' EOS]

Proc SetApiProcedure:
    Argument @Pointer, @Name
    Uses eax

        Mov eax D@Pointer

        sub eax D$DisImageBase | add eax D$SectionsMap

        .If eax > D$SectionsMap
            If eax < D$EndOfSectionsMap
                Mov B$eax CODEFLAG

                sub eax D$SectionsMap | add eax D$RoutingMap
                Mov B$eax LABEL+NODE+EVOCATED+INSTRUCTION+ACCESSED

                ToStringsMapFrom RoutingMap, eax
                Move D$eax D@Name
            End_If
        .End_If
EndP


Proc SetApiData:
    Argument @Pointer

        Mov eax D@Pointer

        sub eax D$DisImageBase | add eax D$SectionsMap

        .If eax > D$SectionsMap
            If eax < D$EndOfSectionsMap
                Mov B$eax DATAFLAG

                sub eax D$SectionsMap | add eax D$RoutingMap
                or B$eax LABEL+EVOCATED
            End_If
        .End_If

EndP


____________________________________________________________________________________________

; Storing the SizeOf the accessed element into 'SizesMap'. Before eax holds D$LastCodeRef.

StoreDisSize:
    Mov ebx eax | sub ebx D$DisImageBase | add ebx D$SizesMap

    .If B$LeaInstruction = &TRUE
        or B$ebx POINTER | Mov B$LeaInstruction &FALSE
    .Else_If W$edi-2 = 'B$'
        or B$ebx BYTE | Call FlagData 1
    .Else_If W$edi-2 = 'W$'
        or B$ebx WORD | Call FlagData 2
    .Else_If W$edi-2 = 'D$'
        or B$ebx DWORD | Call FlagPointerToPointer| Call FlagData 4
    .Else_If W$edi-2 = 'F$'
        or B$ebx FP4 | Call FlagData 4
    .Else_If W$edi-2 = 'R$'
        or B$ebx FP8 | Call FlagData 8
    .Else_If W$edi-2 = 'T$'
        or B$ebx FP10 | Call FlagData 10
    .Else
        ;or B$ebx POINTER
        Call FlagPointerToPointer
    .End_If
ret


Proc FlagData:
    Argument @N
    Uses edi, eax, ecx

        Mov edi ebx | sub edi D$SizesMap | add edi D$SectionsMap
        On B$edi = VIRTUALFLAG, Exitp
        Mov ecx D@N, al DATAFLAG | rep stosb
EndP


FlagPointerToPointer:
   Push ebx
      ; If it is a Pointer to Pointer, LABEL the final Location:
        Mov ebx eax | sub ebx D$DisImageBase | add ebx D$UserPeStart
      ; Here, eax still is 'D$LastCodeRef'
        ..If ebx < D$UserPeStart
            ;
        ..Else_If ebx < D$UserPeEnd
            sub ebx D$UserPeStart | add ebx D$RoutingMap | or B$ebx EVOCATED+LABEL

            sub ebx D$RoutingMap | add ebx D$UserPeStart
            Mov ebx D$ebx | sub ebx D$DisImageBase | add ebx D$UserPeStart
            .If ebx < D$UserPeStart
                ;
            .Else_If ebx < D$UserPeEnd
                Push eax
                    sub ebx D$UserPeStart | add ebx D$RoutingMap
                    Mov eax ebx | sub eax D$RoutingMap | add eax D$SectionsMap
                    If B$eax = CODEFLAG
                        or B$ebx EVOCATED;+LABEL
                    Else
                        or B$ebx EVOCATED+LABEL
                    End_If
                Pop eax
            .End_If

        ..End_If
    Pop ebx
ret

____________________________________________________________________________________________

[DisShortRef: B$ ?]

[EncreasedLocalJmp: D$ ?]

EndWithDisByteRelative:
    ;On B$esi = 0, add B$UnlikelyCode 5 ; Absurd, but really found in some Code.

    If B$SimpleScan = &TRUE
        inc esi | Mov B$DisFlag DISDONE+DISLINEOVER | ret
    End_If

    Mov B$EncreasedLocalJmp &FALSE
    movsx eax B$esi | inc esi | Mov D$LastCodeRef eax
    Call RelativeToAbsolute
    Push eax
        Call WriteLocalLabelFromEax
    Pop eax
    If eax > D$LastCodeRef
        Mov B$edi-1 '>'
    Else
        Mov B$edi-1 '<'
    End_If

    On B$WeAreInTheCodeBox = &TRUE, ret
;jmp L7>>
  ; Is the short jump out of range because of the replacement of a DLL Call Direct
  ; instead of Indirect?
    Push esi, eax
        Mov ecx 0
        Mov al B$esi-1, bl al, B$DisShortRef al | and bl 00_1000_0000

      ; Negatif short?
        ..If bl = 00_1000_0000
            sub esi 3 | neg al
            .While al <> 0
                dec esi
              ; Code of Call Indirect (To Jumps Table?).
                .If B$esi = 0E8
                  ; Yes, but is it an Instruction ?
                    Mov ebx esi | sub ebx D$UserPeStart | add ebx D$RoutingMap
                    test B$ebx INSTRUCTION ZERO L1>
                  ; Relative to absolute:
                    Mov ebx esi | add ebx D$esi+1 | add ebx 5
                    cmp ebx D$UserPeStart | jb L1>
                    cmp ebx D$UserPeEnd | ja L1>
                        If W$ebx = 025FF
                            Mov ebx D$ebx+2
                            sub ebx D$DisImageBase | add ebx D$SectionsMap

                            On ebx > D$EndOfSectionsMap, jmp L1>
                            On ebx < D$SectionsMap, jmp L1>
                                On B$ebx = IMPORTFLAG, inc ecx
L1:                     End_If
                .End_If
                dec al
            .End_While

        ..Else
            .While al <> 0
              ; Code of Call Direct (To Jumps Table?).
                .If B$esi = 0E8
                  ; Yes, but is it an Instruction ?
                    Mov ebx esi | sub ebx D$UserPeStart | add ebx D$RoutingMap
                    test B$ebx INSTRUCTION ZERO L1>
                  ; Relative to absolute:
                    Mov ebx esi | add ebx D$esi+1 | add ebx 5
                    cmp ebx D$UserPeStart | jb L1>
                    cmp ebx D$UserPeEnd | ja L1>
                        If W$ebx = 025FF  ; FF 25 XX XX XX XX > jmp D$xxxx
                            Mov ebx D$ebx+2
                            sub ebx D$DisImageBase | add ebx D$SectionsMap
                            cmp ebx D$SectionsMap | jb L1>
                            cmp ebx D$EndOfSectionsMap | ja L1>
                                On B$ebx = IMPORTFLAG, inc ecx
L1:                     End_If
                .End_If
                dec al | inc esi
            .End_While

        ..End_If

L2:     .If ecx <> 0
            Mov al B$DisShortRef
            If B$edi-1 = '>'
                add al cl | test al 00_1000_0000 ZERO L5>
                Mov B$edi '>' | inc edi
            Else
                sub al cl | test al 00_1000_0000 NOT_ZERO L5>
                Mov B$edi '<' | inc edi
            End_If
            Mov B$EncreasedLocalJmp &TRUE
        .End_If

L5: Pop eax, esi
L7:
    Mov D$edi '  ; ' | add edi 4

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;Mov D$edi 'Code' | add edi 4
    Call RelativeToAbsolute | Mov D$LastCodeRef eax
    ;Push eax
    ;    Call WriteEax
    ;Pop eax
    Mov ebx D$LastCodeRef
    sub ebx D$DisImageBase | add ebx D$SectionsMap | Mov B$ebx CODEFLAG
    Call WriteDisRelative
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


    If B$EncreasedLocalJmp = &TRUE
        NextDisLine
        Mov D$edi "; >>", D$edi+4 "> 'C", D$edi+8 "omme", D$edi+12 "nt1'"
        add edi 16
    End_If

    Mov B$DisFlag DISDONE+DISLINEOVER
ret

; Same as upper, but, in cases of Data in code, a LOOP L2>, might be generated. Not
; that important, but what is important is that this could mess up the targeted Code
; when re-aligning because of Code reference.

EndWithDisByteRelativeBack:
    movsx eax B$esi | On eax < 3, add B$UnlikelyCode 5

    inc esi | Mov D$LastCodeRef eax
    Call RelativeToAbsolute
    Push eax
        Call WriteLocalLabelFromEax
    Pop eax
    If eax > D$LastCodeRef
        Mov B$edi-1 '>'; ; ', D$edi+3 '!!!!' | add edi 7 ; jE! >>Agree DOWN_Loop
        ;Mov D$LastCodeRef 0, B$DisFlag DISDONE+DISLINEOVER | ret
    Else
        Mov B$edi-1 '<'
    End_If
    Mov D$edi '  ; ' | add edi 4
    Call RelativeToAbsolute | Mov D$LastCodeRef eax
    Call WriteDisRelative
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

EndWithDisWordDwordRelative:
    If B$OperandSizeOverride = &TRUE
        movsx eax W$esi | add esi 2
    Else
        lodsd
    End_If
    Mov D$LastCodeRef eax
    Call RelativeToAbsolute | Call WriteDisRelative
    Mov B$DisFlag DISDONE+DISLINEOVER
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; This is the Chunks of Macros to be saved at Top of the Disassembly Source:

[DisMacros2: B$ "TITLE CONVENTIONS     ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
TOPCODE: ; Version PE 00 00 000a

;;

    Displacements marks/ Balises de déplacements:
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        TODO <- Double-Click Left and 'Search from Top' in order to jump to the points being developped
                Double clic gauche et 'Search from Top' pour sauter aux points en cours de dev.

        [-Xxxxx-] <- Right Click to reach the explanation
                     Right clic pour atteindre l'explication

        [Xxxx] <- Right Click to reach the Label
                  Right clic pour atteindre le Label

        Arguments <- Macro (Mmmm): Right Click to reach the Macro Declarationou
                                 : Clic droit pour atteindre la déclaration de la Macro

        If, Mov, Call, Move <- Macro (Mmmm): Double Click to Unfold the Code Created by the Macro
                                           : Double-clic pour Unfold le code substitué par la Macro 

        &WM_SETFOCUS <- Right Click to Show the Hex/Dec Value of the Equate
                        Clic droit pour afficher la valeur Hex/Dec de l'Equate

        eax test movq <- Right Click to Show integrated Help
                         Clic droit pour afficher l'aide intégrée

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Labels et Labels:
    ~~~~~~~~~~~~~~~~~

        In order to increase (if necessary)the legibility of your loops and keep the jumps short,
        use reserved local labels S0 ~ S9 and L0 to L9(pourquoi difference)and add to them ,
        on the same line , a Localized Global Label:  MyLocalLabel.

        Pour augmenter (si besoin) la lisibilité de vos boucles et maintenir des sauts courts,
        utilisez les labels locaux réservés S0 ~ S9 et L0 à L9 et adjoignez-leur, sur la même
        ligne, un Label global localisé: MyLocalLabel

        L0:DO: ; ou  DO:L0:

                ...

                ...

                sub ecx DWORD ; [-DWORD-]

            test ecx ecx | jns L0< ; jns DO generate a long jump equivalent to jns L0<<
                                   ; jns DO génère un saut long équivalent à jns L0<<

        !!! ALWAYS watch the Orphan list and KEEP IT EMPTY
        !!! Dans tous les cas, veillez à conserver l'Orphans List constament vide

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Diverse Typing rules/ Typos diverses:
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        PAY ATTENTION: Important Remark / Attention, remarque importante

        Macros evocation:
        - Mov eax 45, Call, If, Comp:
          All Macros invocations have a CAPITAL First Letter        

        Macro évocation:
        - Mov eax 45, Call, If, Comp:
          Toutes les invocations de Macros ont une majuscule

        eax cmp test -> Right-clic open BUAsm
        Comp Call Push -> Right-clic Unfolding
        
        eax cmp test -> Clic-droit ouvre BUAsm
        Comp Call Push -> Clic-droit Unfold la Macro
         
    
        EQUATE ALWAYS in CAPITAL LETTERS / EQUATE toujours en majuscules

        '_' is allowed in Equates: MY_EQUATE MY_EQUATE
        '_' autorisé dans les Equates: MY_EQUATE MY_EQUATE 

        NO  '_' in the datas's names: MyData  OR My.Data but NOT My_Data NOR my_data
        Pas '_' dans les noms de datas: MaData ou Ma.Data mais pas Ma_Data ou ma_data

        Always : PREFIX.NameOfMyVariable PREFIX.NameOfMyVariable LabelPREFIX.NameOfMyVariable
        NEVER: NameOfMyVariable NameOfMyVariable LabelNameOfMyVariable
        * see [-PREFIXES-]

        Toujours: PREFIX.NomDeMaVariable PREFIX.NomDeMaVariable LabelPREFIX.NomDeMaVariable
        Jamais: NomDeMaVariable NomDeMaVariable LabelNomDeMaVariable (sans préfixe)
        * voir [-PREFIXES-]

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Separation and comments / Séparations et commentaires:
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        TITLE Commun: XXXXXXXX

             ; Version A.Bvvv DD.MM.YY maintainer email   
 TITLE DATAS ; Version A.Bxxx DD.MM.YY Nom(s) mainteneur(s) adresse(s) de courriel
____________________________________________________________________________________________

; ...
____________________________________________________________________________________________

        TITLE Spécifique: XxxxxxXxxx

                  ; Version A.Bvvv DD.MM.YY maintainer email
 TITLE MainWindow ; Version A.Bxxx DD.MM.YY Nom(s) mainteneur(s) adresse(s) de courriel
____________________________________________________________________________________________

;; 

    Global multilangual explanation of the architecture and workings of diverse mechanisms
    implemented in the specific TITLE

    Explication globale et multilingue de l'architecture et du fonctionement des divers
    mécanismes implémentés dans le TITLE Commun:

    - Use of module present in the TITLE, what it does, who for, why, how
    - Utilité du module présent dans le TITLE, ce qu'il fait, pour qui, pourquoi, comment

    - Simplified tree / Arborescence simplifiée:

    [XxxxA0]
    |   
    |--->[XxxxB0]
    |     |
    |     |--->[XxxxB1] 
    |     |
    |     |--->[XxxxB2]
    |     |  
    |     |--->[XxxxB3]
    |     °     |
    |           |--->[XxxxB3.1]
    |           |    | The branch carries on outside the TITLE / La branche continue en dehors du TITLE
    |           |
    |           |--->[XxxxB3.2]
    | suite...  °    ° End of branch / fin de branche

;;  
____________________________________________________________________________________________

LabelX:

    Code

L1: ...

        Code

    jmp L1<

L2: ...

        Code

L3:     ...

            Code

        jmp L3<

   jmp L2<
____________________________________________________________________________________________

LableY:

    Code

ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT

 (End Of Title)
    _________________________________

    ; Comments for code section
    ; Commentaire de section de code
    _________________________________

    ; Local comment on the line above the code / Commentaire local sur la ligne au dessus du code
    Mov eax 45 | xor edx edx | div..

    ; Global comment Call / Commentaire global Call
    Call 'MODULE.Api' P1,
                      P2, ; Specific comment for P2 / Commentaire spécifique sur P2
                      ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Structuration:
    ~~~~~~~~~~~~~

LabelRoutine:

    [If] A
 
        If A1

            Call TraitementA1 ; !!! NEVER any Code / Jamais de code

        [Else_If] A2

            Call TraitementA2

        [Else]
        
            [ExitR]

        [End_If]

    Else_If B

        Call TraitementB

    Else_If X

        !!! NEVER any Code / Jamais de code

    End_If

[RetR]   
     ______________________________________ F8

TraitementB:

    If B1

        Call TraitementB1

    Else_If X

        !!! NEVER any Code / Jamais de code

    Else_If B2

        Call TraitementB2

    Else_If B3

        Call TraitementB3

    End_If
    _________________________________________________________________

    ; Identation illustration, here with local labels, A 'spaghetti'
    ; construct a little complicated without comments
 
    ; Illustration d'indentations, ici avec Labels localisés, d'une
    ; imbrications spaghetti un peu compliquée et non commentée
    _________________________________________________________________

L1: Debut:

        Code

        [Comp] eax edx je L1<,
                          js S1>,
                          jz S2>>

    sub ecx [DWORD] | jns L1<
 
        Code

        L2: OK

                Mov ecx 16

S1: OK sub edx 1 | jnz L1<

            sub edx 1 | jnz L2<

S2: Fin

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;;
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
" @Label1:B$ "TITLE MACROS          ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

[STR.A.ApplicationVersion: B$ ' Xxxxxx Xxxxx Xxxxx: V. 00.00.000a EOS]

;;

    English:

    To understand what these Macros do for you you can click on them and choose UNFOLD.
    You will know what kind of code they generate. Macros are useful in assembly programming
    because they bring long-term READABILITY.

    All the Macros you plan to use should be here in this TITLE. Here are some important
    guidelines you should know when implementing Macros:

    1. Macros shouldn't use registers internally for their functionment.
    2. Macros shoudn't use global variables or global labels
    3. Don't encapsulate easy APIs.

    Français:

    Pour mieux (bien) comprendre ce que ces Macros 'génèrent' nous vous invitons à un double
    clic gauche sur leurs évocations dans le code. Choisissez l'option 'Unfold' dans le menu
    pop: Vous verrez ainsi que RosAsm ne substitue pas de code à votre insue mais que c'est
    VOUS qui construisez vos substitutions -> Pour gagner en lisibilisé, en souplesse et en
    facilité de maintenance de votre code. Plus il sera lisible et facilement compréhensible,
    plus vous pourrez y retourner facilement après plusieurs mois ou permettre à d'autres de
    participer sa la maintenance...

    Toutes les Macros utilisées dans RosASm doivent être déclarées ici et, dans la mesure du
    possible, regroupées par catégories. N'implémentez pas de nouvelles Macros utilisant en
    interne des registres, des variables globales ou des Label globaux (c'est une source de
    conflits).
    !!! Par principe, ne multipliez pas la création de nouvelles Macros -> Evitez, par-dessus
    toutes choses, les diverses formes d'encapsulations d'API: Cela n'apporte rien au niveau
    de la lisibilité (au contraire) et provoque de nombreuses sources d'erreurs:
    Soignez les commentaires et utilisez des Proc/routines communes
    ________________________________________________________________

    ; List of Local labels to use and that Macros use:

    ; Labels locaux utilisée au sein des Macros:
      (Liste à compléter en fonction des nouvelles implémentations)
    ________________________________________________________________

    P9 -> [ExitP]
    P7 -> [On]

    M0 ~ M9 et N0 ~N9 [If][Else_If][Else][End_If]

    O0 ~ O9 [Repeat][Until] [While][End_While]

    Jumps: S0 ~ S9

    Loops: L1 ~ L9 and L0 unique Loop or without link to other loops 
           L1 ~ L9 et L0 Boucle unique ou sans imbrication avec d'autres boucles
    _________________________________________________________________

    ; Internal variables of the Macro parser used inside the Macros:
      (List to complete when new implémentations are made)

    ; Variables interne du Macro parser utilisée au sein des Macros:
      (Liste à compléter en fonction des nouvelles implémentations)
    _________________________________________________________________

    &1 -> Size of arguments / Taille des arguments

    &2 -> Size of local variables and structures / Taille des variables locales et des structure

    &3 -> String of register or variable saved / Chaîne de registre ou variables préservées

    &4 -> Structure name / Nom de la structure

    &5 -> Structure offset counter / Compteur d'offsets de structure

    &6 -> Constructor of strings for debugg.dll macros / Constructeur de Châines pour les Macro de debugg.dll

    &&1 -> Compteur de Macros [If][Else] / Macros counter

    M N &&1 -> Counter of the times this macro was used. This is used to generate proper label names M0 to M9
    M N &&1 -> Compteur d'emboîtements, utilisés pour la création des labels M0..M9, N0..N9

    &&2 -> Compteur de Macros [Repeat][Until] [While][Wend] / Macros counter 

    O&&2 -> Pour la construction des labels [Repeat][Until] [While][End_While] 
            For the construction of the labels [Repeat][Until] [While][End_While] 

;;
_______________

; Basic macros
_______________

;;

    Description : Macros that Move data around
                  Macros de déplacement des données


    Examples:

        Mov eax 45 | Mov D$edi '0000'

        [Mov] eax D$eax, B$MyVar 0_7F, eax MyLp

        Mov eax {ARGB 0_C1 0_C2 0_C3 0_A0}

        Push ebx
        
        Pop ebx

        [Push] W$eax,
               D$eax,
               ax

        [Pop] ax,
              D$eax,
              W$eax

        [Move] D$MyVar D$eax, W$eax W$Mylp

;;

[Mov

    mov #1 #2

    #+2]

[ARGB

    (#1 or (#2 shl 8) or (#3 shl 16) or (#4 shl 24))]

[Push

    push #1

    #+1]

[Pop

    pop #1

    #+1]

[Move

    push #2 | pop #1

    #+2]

;;

    Description : Macros used to Call functions
                  Macros utilisées pour appeller vos fonctions et les API

    EOS = End of String Equate
          Equate de fin de chaîne

    Examples :

    [Call] Label

    STDCALL convention : The function will cleanup the stack
                         La fonction est résponable de la restauration de la pile

    Call Label D$MyParameter,
               MyLp ...

    Call Label D$MyParameter,
               {B$ 'StringASCII' EOS}, ; ParaMacro: Local label generation [xxx: B$ 'StringASCII' EOS]
                                       ;            Génération d'un Label local [xxx: B$ 'StringASCII' EOS]
               {U$ 'StringUNICODE' EOS},
               MyLp ...

    STDCALL convention : the DLL function will cleanup the stack
                         La dll est résponable de la restauration de la pile

    Call 'DLLNAME.FunctionName'

    Call 'DLLNAME.FunctionName' D$Parameter,
                                Lp ...

    cdecl convention (MSVCRT mainly)
    The caller must cleanup the stack (add esp, [DWORD]*numberOfArguments)
    !!! Le CCall est résponable de la restauration de la pile

    [CCall] 'NOMDLL.AdresseName' D$Parameter,
                                 Lp ...

;;

[Call

    push #L>2

    Call #1]
;;
[CCall

    push #L>2

    Call #1

    #If #N>1

        add esp ((#N-1)*DWORD)

    #EndIf]
;;
______________________________

; Macros HLL Proc / Functions
______________________________

;;

    For the GUI messages routines, if you don't modify the initial stack, you can use the MSG
    equates (they are coded to work with a typical stack value) See [CALLBACK]

    Pour les Routines de traitement des messages GUI, afin d'éviter la transmission redondante
    d'arguments, CE TANT QUE LA PILE N'EST PAS MODIFIEE PAR UN PASSAGE D'ARGUMENT(S) OU PAR UN
    PUSHs DE TYPE Uses OU PUSH EBX, il est possible d'utiliser les Equates de MSG voir [CALLBACK]

    ~~~~~~~~~~~~~~~~~
    Label:

        You can access the arguments like this when the EQUATES work
        D$[HWND] D$[MSG] D$[WPARAM] D$[LPARAM]

        Utilisables -> D$[HWND] D$[MSG] D$[WPARAM] D$[LPARAM]

    ret or [RetR]

    ~~~~~~~~~~~~~~~~~

        You can use -> D$HWND D$MSG D$WPARAM D$LPARAM
        Utilisables -> D$HWND D$MSG D$WPARAM D$LPARAM

        [StackOn]

            You can use these Macros when you are in StackOn : [Local]/[Locals] [Structure] [Uses]
            And you cannot use that now -> D$HWND D$MSG D$WPARAM D$LPARAM

            !!! Attention les Macros [Local]/[Locals] [Structure] [Uses] ne sont pas utilisables
            dans les routines en dehors de StackOn / StackOff
            Inutilisables -> D$HWND D$MSG D$WPARAM D$LPARAM

        [StackOff]

        You can use these again -> D$HWND D$MSG D$WPARAM D$LPARAM
        Utilisables ici à nouveau -> D$HWND D$MSG D$WPARAM D$LPARAM

    ret or Retr

    ~~~~~~~~~~~~~~~~~
      !!! Align your structures (From the biggest member (Q$) to the smallest (B$)
      !!! Alignez vos strutures (de la plus grande taille (Q$) à la plus petite (B$)

  *(1~5)  Structure STC.XXXXXX, -> (D)STRUC.XXXXXX contenant le Lp -> STC.XXXXXX
              QWORD .Q.Var1,     -> QSTRUC.Q.XXXXXX.Var1  ; QWORD or 2*DWORD aligned
              DWORD .DU.Var2,    -> DSTRUC.DU.XXXXXX.Var2 ; DWORD aligned LSD
              DWORD .DU.Var3,    -> DSTRUC.DU.XXXXXX.Var2 ; DWORD aligned MSD
               WORD .WU.Var4,    -> WSTRUC.WU.XXXXXX.Var3 ; WORD  aligned LSW
               WORD .WU.Var5,    -> WSTRUC.WU.XXXXXX.Var4 ; WORD  aligned MSW
               BYTE .BU.Var6,    -> BSTRUC.BU.XXXXXX.Var5 ; BYTE  aligned LSB
               BYTE .BU.Var7,    -> BSTRUC.BS.XXXXXX.Var6 ; BYTE  aligned MSB
               BYTE .BS.Var8,    -> BSTRUC.BU.XXXXXX.Var7 ; etc.
               BYTE .BU.Var9     -> BSTRUC.BU.XXXXXX.Var8

        (STC.XXXXXXSIZE is en equate generated by a Macro that contains the structure
         size -> mov eax (!!! not D) STC.XXXXXXSIZE)

        (STC.XXXXXXSIZE est une equate générée par la Macro et contenant la taille en bytes
         de la structure -> mov eax (!!! pas de préfixe de taille D) STC.XXXXXXSIZE)

;;

;;
[Proc

    #1                          ; Creation of global label / Création du label global

    StackOn]

[StackOn

    &1=0                        ; &1 = Size of arguments. We zero the counter
                                ; &1 = Taille des arguments. RAZ compteur

    &2=0                        ; &2 = Size of local variables and structures. We zero the counter
                                ; &2 = Taille des variables locales et des structure. RAZ compteur

    &3=                         ; &3 = String of saved variables. Set string to zero
                                ;      Chaîne de variables préservées. RAZ chaîne

    &4=                         ; &4 = Structure name / Nom de la structure

    &5=0                        ; Zero structure offset counter / RAZ compteur d'offsets de structure

    push ebp                    ; Stack frame init / Initialisation du cadre de pile

    mov ebp esp]

[Argument
                                ; Callback = 1*DWORD  Argument = 1*DWORD
    {#1 ebp+((1*DWORD)+DWORD)}  ; Equate creation [MyProcParamA ebp+8]
                                ; Fabrique equate [MyProcParamA ebp+8]

    &1=DWORD]                   ; Save size of arg / Sauvegarde la taille de l'arguments

[Arguments

    {#1 ebp+((#x*DWORD)+DWORD)} ; Equate creation ex:[MyProcParamA ebp+0C]
                                ; Fabrique equate ex:[MyProcParamA ebp+0C]

    #+1                         ; Next argument / Argument suivant

    &1=(#N*DWORD)]              ; Save size of args / Sauvegarde la taille des arguments

[Local

    {#1 ebp-DWORD}              ; Equate creation [MyProcLocalA ebp-4]
                                ; Fabrique equate [MyProcLocalA ebp-4]

    &2=DWORD                    ; Offset counter update / MAJ du compteur d'offet

    sub esp DWORD]              ; Save space for local variable on stack
                                ; Reserve la place pour la variable locale sur la pile

[Locals

    {#1 ebp-(&2+(#x*DWORD))}    ; Equate creation ex:[MyProcLocalA ebp-4]

    #+1                         ; Next local variable / Variable locale suivante

    &2=&2+(#N*DWORD)            ; Offset counter update / MAJ du compteur d'offet

    sub esp (#N*DWORD)]         ; Save space for local variables on stack
                                ; Reserve la place pour les variables locales sur la pile

[Structure

    &4=#1                       ; &4 structure name / &4 Nom structure

    &5=0                        ; Zero structure offset counter / RAZ compteur

    BuildMember #2 #L>2]        ; Create structure on stack / Fabrique la structure sur la pile

[BuildMember

     {&4#2 ebp-(&2+&5+#3)}      ; Member Equates creation ex:[MyProcMyStructure.MyMembre2 D$ebp-08]
                                ; Fabrique equates membre ex:[MyProcMyStructure.MyMembre2 D$ebp-08]

     &5=&5+#3                   ; Size counter incrementation / Inc le compteur de la taille

     #+2                        ; Next member/ Membre suivant

     {&4 D$ebp-(&2+&5+DWORD)}   ; Equate creation (Structure LP) ex:[MyProcMyStructure D$ebp-0C]
                                ; Fabrique equate Lp structure ex:[MyProcMyStructure D$ebp-0C]

     {&4Size (&5)}              ; Equate creation (Sizeof structure) ex: [MyProcMyStructureSize 08]
                                ; Fabrique equate taille structure ex: [MyProcMyStructureSize 08]

     sub esp (&5)               ; Save space on stack for the structure
                                ; Reserve la place pour la structure sur la pile

     push esp                   ; Save structure LP / Sauvegarde le Lp de la structure

     &2=&2+&5+DWORD]            ; Offset counter update / MAJ du compteur d'offet

[Uses

    push #1>L                   ; Save register/variables on the stack
                                ; Sauvegarde registres/variables sur la pile

    &3=pop #L>1]                ; Automatic reg restore pop code
                                ; Fabrique la chaîne de commande de restauration registres/variables
;;

[Return

    #If #N=1                    ; Test if there is a return argument / Test si un argument en retour

        mov eax #1              ; Return &TRUE -> mov eax &TRUE | jump P9> (EndP)

    #EndIf                      ; Single return  = Exit Proc / Return seul = Exit Proc

    jmp P9>] ; jmp ExitP]                  ; See next equate / Saute à EndP, voir equate suivante

;;

[ExitP P9>]                     ; Equate to exit proc / Equate pour sortie Proc -> cmp eax &NULL | je ExitP

[StackOff

    P9:                         ; Jump label for ExitP / Label de saut pour ExitP

    &2=0                        ; &2 = Size of local variables and structures. We zero the counter

    &3 | &3=                    ; If &3 >'' restore the registers/variables saved and reset to zero string &3
                                ; Si &3 >'' restaure les registres/variables sauvegardés et RAZ chaîne &3

    &4=                         ; &4 = Structure name / Nom de la structure

    &5=0                        ; Zero structure offset counter / RAZ compteur d'offsets de structure

    mov esp ebp                 ; Restore stack pointer / Restaure le pointeur de pile

    pop ebp]                    ; Restore ebp / Restaure le cadre de pile appelant

[EndP

    StackOff

    RetR]

[RetR

    ExitF

    ret &1                      ; Return to caller and clean the stack by numberofArgs*DWORD
                                ; Retour à l'appelant et retrait des arguments de la pile

    &1=0]                       ; We zero the counter / RAZ compteur

[ExitF

    #If &&1=> '0'               ; Check if If/Else Macros are paired
                                ; Vérifie si les Macros [If]/[Else_If]/[End_If] sont apairées

        #Error 'Unpaired use of If / End_If !'

    #EndIf

    #If &&2=> '0'               ; Check if while, repeat Macros are paired
                                ; Vérifie si les Macros [Repeat]/[Until] [While]/[Wend] sont apairées

        #Error 'Unpaired use of loop constructs !'

    #EndIf]
;;
_______________________________________

; Conditional Branch HLL macros

; Macros HLL branchements contitionels
_______________________________________

; [EQUATES_HLL] Equates for cond jumps / Equates pour la forme HLL integers signés et non-signés seulement

;;

    Multiple conditional branch (Maximum of 4 + a jmp):

    Multiple branchement conditionel (4 + jmp maxi.):

    Comp D$eax Label = S1>

    Comp eax edx > S1> < S2> = S3> NEGATIVE S9> -> [EQUATES_HLL]

    Comp eax D$LabelA = LabelB,
                      < S2>,
                      NEGATIVE L1<, -> [EQUATES_HLL]
                      ZERO S9>      -> [EQUATES_HLL]
                     
                      jmp S0>

    cmp is kept for spaguetti code / cmp est conservé pour le code spaghetti

;;

[Comp

    #If #N<4

        #Error '[A] [B] [Condition] [Label] !'

    #Else

        cmp #1 #2 | JmpIf #3>L

    #EndIf]

;;
    
    Conditi!!!!!onal execution / Exécution conditionelle
    On eax > ebx Mov ebx eax
    On eax = ebx Call Procedure
    On eax > ebx Mov ebx eax, jmp S1<

;;

[On

    cmp #1 #3 | jn#2 P7>

        #4>L

    P7:]

;;
    
    Conditional AND jmp / Saut AND conditionel

    sub eax 45 | JmpIf ZERO L1<

    sub D$ebx 127 |JmpIf ZERO S1>,
                         NEGATIVE S2>
   
    Test eax ebx ZERO S1>
    
    Test eax NA ZERO S1>,
                NEGATIVE S2>
    
    Test D$FL.Var &TRUE TRUE S1>
  
    Test D$FL.Var &TRUE FALSE S1>
    
    On eax = ebx Call Procedure
    On eax > ebx Mov ebx eax, jmp S1<

;;

[JmpIf

    j#1 #2

    #+2]

[Test

    test #1 #2

    JmpIf #3>L]

;;
    
    If/Else/Else_If/End_If -> !!! Short jumps only. Structure properly!
                              !!! Sauts courts uniquement (structurez convenablement).

    If eax = 0
        ...
    Else_If eax > 17, eax < 42
            ...

        If ebx = &FALSE
            ...

        Else
            ...

        End_If

        ...

    End_If
    
;;

;;
[IncCnt1

    #If &&1=0       ; Zero the counter / RAZ compteur l'ors de la première évocation de la macro

        &&1= '0'

    #Else

        &&1=&&1+1   ; Can be incremented up to 9 / Incrément jusqu'à '9'

    #EndIf]

[If.

    cmp #1 #3

    jn#2 M&&1>

    #+3]

[If

    IncCnt1

    If. #1>L]

[Else_If

    jmp N&&1>

 M&&1:

    If. #1>L]

[Else

    jmp N&&1>

 M&&1:]

[End_If

    M&&1:
    N&&1:

    &&1=&&1-1]
;;

;;

    Repeat macro

        ... 

    Until B$esi = EOS 

;;

[Repeat

    #If &&2=0

        &&2= '0'

    #Else

        &&2=&&2+1

    #EndIf

    O&&2:]

[Until

    cmp #1 #3 | jn#2 O&&2<

    O&&2: &&2=&&2-1]

;;

    While B$esi <> EOS 

        ... 

    EndWhile 

;;

[While

    #If &&2=0

        &&2= '0'

    #Else

        &&2=&&2+1

    #EndIf

    O&&2:

    cmp #1 #3 | jn#2 O&&2>]

[End_While

    jmp O&&2<

    O&&2: &&2=&&2-1]

;;

    !!! EXCEPTIONEL NE JAMAIS FAIRE DE MACROS D'ENCAPSULATION DE CE GENRE

    Macros pour utiliser le module de debuggage de la DEBUG.DLL:

        ; Saute une ligne
        OutPutStringLiteral CR LF

        ; Affiche le nom de la variable [FLOAT] et son contenu
        OutPutFloat F$F.Variable | OutPutStringLiteral CR LF

        ; Affiche le nom de la variable [REEL] et son contenu
        OutPutReel R$R.Variable | OutPutStringLiteral CR LF

        ; Affiche le nom de la variable [DWORD] non signé et son contenu au format decimal
        OutPutDec D$DU.Variable | OutPutStringLiteral CR LF

        ; Affiche le nom du Lp -> Préfixe.Variable et son adresse au format hexadecimal
        OutPutDec DU.Variable | OutPutStringLiteral CR LF

        ; Idem avec un registre
        Mov eax 1999 | OutPutDec eax | OutPutStringLiteral CR LF

        ; Affiche le nom de du registre et son contenu au format hexadecimal
        Mov eax 0_ABCDEF | OutPutHex eax | OutPutStringLiteral CR LF

        ; Affiche le nom de la variable [DWORD] non signé et son contenu au format hexadecimal
        OutPutHex D$DU.Variable | OutPutStringLiteral CR LF

        ; Affiche le nom du registre et son contenu signed au format decimal
        Mov eax 0-32000 | OutPutSignedDec eax | OutPutStringLiteral CR LF

        ; Idem
        Mov eax 0FFFF_FFFF | OutPutSignedDec eax | OutPutStringLiteral CR LF

        ; Affiche le nom du Lpointeur sur la chaine de bytes et son contenu au format ASCII
        OutPutString STR.A.Variable | OutPutStringLiteral CR LF

        ; Affiche le contenu ASCII transmis
        OutPutStringLiteral '1234567890123456789012345678901234567890123456789012345678901234567890123456' CR LF,
                            '1234567890123456789012345678901234567890123456789012345678901234567890123456' CR LF,
                            '1234567890123456789012345678901234567890123456789012345678901234567890123456' CR LF,
                            '1234567890123456789012345678901234567890123456789012345678901234567890123456' CR LF,
                            '1234567890123456789012345678901234567890123456789012345678901234567890123456' CR LF,
                            '1234567890123456789012345678901234567890123456789012345678901234567890123456' CR LF,
                            '1234567890123456789012345678901234567890123456789012345678901234567890123456' CR LF,
                            '1234567890123456789012345678901234567890123456789012345678901234567890123456' CR LF,

                            ;...

                            '1234567890123456789012345678901234567890123456789012345678901234567890123456' CR LF,
                            '1234567890123456789012345678901234567890123456789012345678901234567890123456' CR LF,
                            '1234567890123456789012345678901234567890123456789012345678901234567890123456' CR LF,
                            '1234567890123456789012345678901234567890123456789012345678901234567890123456' CR LF,
                            '1234567890123456789012345678901234567890123456789012345678901234567890123456' CR LF

        ; Ajoute dans le fichier DebugLog.txt le contenu ASCII transmis (EOS n'est pas
        ; nécessaire en fin de liste).
        ; !!! Le texte n'apparait pas dans la fenêtre de debugg, c'est une REM pour le fichier
        OutPutLog 'Texte enregistré dans le fichier DebugLog.txt' CR LF

        ; Affiche le dernier message d'erreur
        OutPutError

;;

[OutPutDec

    &6=#1

    {&0: B$ '&6' EOS}

    &6=

    Call 'DEBUGG.OutPutDec' &0,
                            #1]

[OutPutSignedDec

    &6=#1

    {&0: B$ '&6' EOS}

    &6=

    Call 'DEBUGG.OutPutSignedDec' &0,
                                  #1]

[OutPutHex

    &6=#1

    {&0: B$ '&6' EOS}

    &6=

    Call 'DEBUGG.OutPutHex' &0,
                            #1]

[OutPutFloat

    fld #1

    &6=#1

    {&0: B$ '&6' EOS}

    &6=

    Call 'DEBUGG.OutPutFloat' &0]

[OutPutReel

    fld #1

    &6=#1

    {&0: B$ '&6' EOS}

    &6=

    Call 'DEBUGG.OutPutReel' &0]

[OutPutString

    &6=#1

    {&0: B$ '&6' EOS}

    &6=

    Call 'DEBUGG.OutPutString' &0,
                               #1]

[OutPutError

    Call 'DEBUGG.OutPutError' ]

[OutPutStringLiteral

    {&0: B$ #F>L EOS}

    Call 'DEBUGG.OutPutStringSimple' &0]

[OutPutLog

    {&0: B$ #F>L EOS}

    Call 'DEBUGG.OutPutLogFile' &0]

[OutVideDebbug

    Call 'DEBUGG.VideDebbug']
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
" @Label2: B$ "TITLE EQUATES         ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;

    English:

    Equates guidelines:

    - All the global equates should be here in this TITLE.
      It applies to Individual equates and structure equates

    - They must be regrouped in categories

    - They must be in alphabetical order of their prefix

    - They must be in alphabetical order

    Français:

    - TOUTES les définitions d'EQUATES à portées globales doivent se trouver dans ce TITLE:
      que ce soit des EQUATES individuelles ou des structures d'EQUATES

    - Etre rangées par catégories

    - Etre rangées en ordre alphabétique de préfixe

    - Etre rangées en ordre alphabétique de nom (à moins que ce ne soit une Struture
      d'Equates évidement)

;;
________________________________________________________________________

; Message [MSG_PUMP] equates (Used in WindowProc or DialogProc)

; Equates pour manipuler les arguments provenant du [MSG_PUMP] dans les
; routines de traitements des WindowProc ou DialogProc
________________________________________________________________________

[CALLBACK ebp+(01*DWORD)  ; Adresse de retour
 HWND     ebp+(02*DWORD)  ; Handle de la fenêtre courante
 MSG      ebp+(03*DWORD)  ; Id message fenêtre courant
 WPARAM   ebp+(04*DWORD)  ; 32-bit message-specifique
 LPARAM   ebp+(05*DWORD)] ; 32-bit message-specifique
______________________________________________________________________

; Size equates : Mov eax D$esi+(2*DWORD),
;                     cl B$ah+(3*BYTE)

; Equates d'offsets taille: Mov eax D$esi+(2*DWORD),
;                           cl B$ah+(3*BYTE)
______________________________________________________________________

[BYTE     1  ; 0-128/+127 or 0/255 00/00_FF
 ASCII    1  ; Need the A suffix in some APIS (See also Tools menu -> Ascii Table)
 DWORD    4  ; 0-2147483648/+2147483647 or 0/4294967295 00/00_FFFF_FFFF
 FLOAT    4  ; http://en.wikipedia.org/wiki/IEEE_754-1985
 QWORD    8  ; 00/00_FFFF_FFFF_FFFF_FFFF
 REEL     8  ; http://en.wikipedia.org/wiki/IEEE_754-1985
 UNICODE  2  ; Need the W suffix in some APIs
 WORD     2  ; 0-32768/32767 ou 0/65535 00/00_FFFF
 XWORD   16] ; For SSE
______________________

; Equates for strings

; Equates chaînes
______________________

[EOS      0_0           ; End of string (BYTE)
 SPC      0_20          ; Space (BYTE)
 TAB      0_9           ; Tabulation (BYTE)
 CR       0_D           ; Carriage return (BYTE)
 CRCR     0_D_0D        ; Double carriage return (WORD)
 LF       0_A           ; Line feed (BYTE)
 LFLF     0_A_0A        ; Double line feed (WORD)
 CRLF     0_A_0D        ; Carriage return + line feed (WORD)
 LFCR     0_D_0A        ; Line feed + carriage return (WORD)
 CRLF2    0_A_0D_0A_0D  ; Double carriage return + line feed (DWORD)
 CRLFEOS0 0_A_0D_00     ; Carriage return + line feed + EOS + 0 (DWORD)
 MLC      0_D_3B_3B_0A] ; MLC: Multi-Lines Comment: LF;;CR (DWORD)
___________________

; Equates for HLL

; Equates pour HLL
___________________

EQUATES_HLL:

[= e    < b     > a     =< be   <= be   => ae   >= ae   <> ne

        <s l    >s g    =<s le  <=s le  =>s ge  >=s ge
        s< l    s> g    s=< le  s<= le  s=> ge  s>= ge

 FIND_EOS z   NOT_EOS  nz ; End Of String Search
 ZERO     z   NOT_ZERO nz ; Numérique
 NULL     z   NOT_NULL nz ; Lp
 FALSE    z   TRUE     nz ; Flags
 ODD      po  EVEN     pe ; Parité Impair/Pair
 NEGATIVE s   POSITIVE ns]; Sign
______________________________________

; Coordinates equate structures

; Structures d'equates de coordonnées
______________________________________

[PX (00*WORD)
 PY (01*WORD)]

[POINTX (00*DWORD)
 POINTY (01*DWORD)]

[LEFT   (00*DWORD)
 TOP    (01*DWORD)
 RIGHT  (02*DWORD)
 BOTTOM (03*DWORD)]

; MINMAXINFO Structure Equates Windows
[MINMAXINFO.ptReserved     (0*DWORD)
 MINMAXINFO.ptMaxSize      (2*DWORD)
 MINMAXINFO.ptMaxPosition  (4*DWORD)
 MINMAXINFO.ptTrackSize    (6*DWORD)
 MINMAXINFO.ptMaxTrackSize (8*DWORD)]
_______________

; Flag equates
_______________

[NA         0-1         ; 0-1 00_11111111_11111111_11111111_11111111 BYTE/WORD/DWORD
 NO         0_FFFF_FFFF ; 0-1 00_11111111_11111111_11111111_11111111 DWORD
 YES        0+1]        ; 1   00_00000000_00000000_00000000_00000001 0_1 &TRUE BYTE/WORD/DWORD
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
"
DisTitle: B$ CR LF ; ('1' is at DisTitle+12)

"TITLE Part01           ; Version A.Bvvv DD.MM.YY maintainer email and version number go here 
_____________________________________________________________________________________________

Comment1:
;;

    Many Compilers encode the DLLs calls under the form of a Call to JUMPs Table. This is
    to say that each Call to a DLL Function is encoded with two instructions: a Call plus
    a JMP.
  
    BUAsm performs these calls in one single Instruction (a direct Call to the .Import
    Section record).
  
    Unfortunately, the direct BUAsm form is one Byte longer than the indirect Call to a
    Jumps Table (the Instruction Opcode for 'Call D$Location' is two Bytes, whereas the
    one for 'Call Label' is one Byte).
  
    It may happend that, when a short JMP jumps over one or more DLLs calls, the shorter
    form found in the Disassembly becomes out of range because of these added Bytes.
  
    In such cases, the Disassembler replaces, for example, 'je K5>', by 'je K5>>'.
  
    All occurences of '>>' and '<<' found in a disassembly Source fall under that case.

;;
"
EOS]

WriteMacros:
    Mov esi DisMacros2 | While B$esi <> 0 | movsb | End_While
ret
____________________________________________________________________________________________


[FirstDisDataByte: D$ ?]








L9: Pop ecx, ebx
ret

WritedCommentedWordsData:
    Push ebx, ecx
        shr ecx 2 | jecxz L9<

        NextDisLine
        Mov D$edi '    ', D$edi+4 '    '
        add edi 7 | Mov D$edi ';   ' | add edi 3
L0:     Mov edx 0, D$edi 'D$  ' | add edi 3

L0:     Mov eax D$ebx
        Push ebx
            Mov ebx eax | sub ebx D$DisImageBase | add ebx D$RoutingMap
            cmp ebx D$RoutingMap | jb L2>>
                cmp ebx D$EndOfRoutingMap | jae L2>>
                    test B$ebx NODE ZERO L1>
                        sub ebx D$RoutingMap | add ebx D$SectionsMap

                        Mov bl B$ebx | and bl CODEFLAG+DATAFLAG+VIRTUALFLAG
                        If bl = CODEFLAG
                            Mov D$edi 'Code' | add edi 4
                        Else_If bl = DATAFLAG
                            Mov D$edi 'Data' | add edi 4
                        Else_If bl = VIRTUALFLAG
                            Mov D$edi 'Virt', D$edi+4 'ual' | add edi 7
                        End_If
                        jmp L2>

L1:                 test B$ebx Evocated ZERO L2>
                        Push ebx, eax
                            Call WriteEax | Mov D$edi '  ; ' | add edi 4
                        Pop eax, ebx
                        sub ebx D$RoutingMap | add ebx D$SectionsMap
                        Mov bl B$ebx | and bl CODEFLAG+DATAFLAG+VIRTUALFLAG
                        If bl = CODEFLAG
                            Mov D$edi 'Code' | add edi 4
                        Else_If bl = DATAFLAG
                            Mov D$edi 'Data' | add edi 4
                        Else_If bl = VIRTUALFLAG
                            Mov D$edi 'Virt', D$edi+4 'ual' | add edi 7
                        End_If
                        Call WriteEax
                        Mov D$edi '??? ' | add edi 3 | Mov edx 6 | jmp L3>


L2:                 Call WriteEax
L3:     Pop ebx
        Mov B$edi SPC | inc edi | inc edx
        .If edx = 7
            If ecx > 1
                NextDisLine
                Mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    '
                add edi 10 | Mov D$edi ';   ' | add edi 3 | Mov edx 0
            End_If
        .End_If
        add ebx 4 | dec ecx | cmp ecx 0 | ja L0<<
        Mov B$edi-1 ']'
L9: Pop ecx, ebx
ret


; ecx = how many Bytes
[ST0trash: T$ ?]
[SourceOfSpecialFPU: D$ ?
 SourceOfSpecialFPUSize: D$ ?]

WriteFP4:
    Mov D$SourceOfSpecialFPU ebx, D$SourceOfSpecialFPUSize 4
    finit
    fld F$ebx | add ebx 4 | Mov D$edi 'F$  ' | jmp L0>
WriteFP8:
    Mov D$SourceOfSpecialFPU ebx, D$SourceOfSpecialFPUSize 8
    finit
    fld R$ebx | add ebx 8 | Mov D$edi 'R$  ' | jmp L0>
WriteFP10:
    Mov D$SourceOfSpecialFPU ebx, D$SourceOfSpecialFPUSize 10
    finit
    fld T$ebx | add ebx 10 | Mov D$edi 'T$  '

L0: add edi 3
    pushad
        Push edi
            Mov eax 0, ecx 10 | rep stosd
        Pop edi

        fstp T$ST0trash | Call DisassemblerFloatToUString ST0trash edi
    popad

    While B$edi > 0 | inc edi | End_While

    .If B$SpecialFPU = &TRUE
        Push ecx
            While B$edi <> '$' | dec edi | End_While | dec edi
            Mov D$edi 'B$  ' | add edi 3
            Mov ecx D$SourceOfSpecialFPUSize, ebx D$SourceOfSpecialFPU

L0:         Mov al B$ebx
            Mov B$edi '0' | inc edi
            If al = 0
              ; Done above
            Else_If al > 0F
                shr al 4 | and eax 0F | Mov al B$STR.A.Hexa+eax | stosb
                Mov al B$ebx
                and eax 0F | Mov al B$STR.A.Hexa+eax | stosb
            Else
                and eax 0F | Mov al B$STR.A.Hexa+eax | stosb
            End_If

            Mov W$edi ', ' | add edi 2

            inc ebx | loop L0<

            sub edi 2
        Pop ecx

    .End_If
ret
____________________________________________________________________________________________

NextDataDisLine:
    NextDisLine
    Mov D$edi '    ', D$edi+4 '    ', D$edi+8 '  ; ' | add edi 12
ret
____________________________________________________________________________________________

[TruthAsciiTable: D$ ?]

[BADASCII 2
 GOODASCII 1]

BuildTruthAsciiTable:

    Call VirtualAlloc TruthAsciiTable,
                      256

    Mov edi D$TruthAsciiTable, al BADASCII, ecx 256 | rep stosb

    Mov edi D$TruthAsciiTable,
        B$edi 0

    Mov B$edi+LF GOODASCII,
        B$edi+CR GOODASCII,
        B$edi+0A7 GOODASCII,    ; $
        B$edi+025 GOODASCII,    ; %
        B$edi+0A9 GOODASCII,    ; ®
        B$edi+02F GOODASCII     ; /

    Mov ebx 32,
        ecx 127

    While ebx < ecx

        Mov B$edi+ebx GOODASCII | inc ebx

    End_While

ret

 [BadAsciiSum: D$ ?]

____________________________________________________________________________________________
;;
  Winner in matter of bad Strings Recognition:
  
  [Data0453031: B$ "=.midtd=.aift]=.au" EOS,
                   "tV=.sndtO=.wmatH=.jpgtA=.bmpt:=.gift3=.pict,=.imgt%=.tift"]
  [<Data045307D: B$ 01E]
  [<Data045307E: B$ "=.tgat"]
  [Data0453084: B$ 017]
  [<Data0453085: B$ "=.pcxt"]
  [<Data045308B: B$ 010]
  [Data045308C: B$ "=.jpgt"]
  [<Data0453092: B$ 09]
  [<Data0453093: B$ "=.jpet"]
  
  ... which is real Code... :)))))))
;;

[Forced: D$ ?]

Proc AsciiRecognition:
    Argument @Length
    Uses ecx

      ; First, for all Ascii Char, write a TEMPOFLAG into the relative SectionsMap Bytes:
        Mov esi D$UserPeStart | add esi D$FirstSection
        Mov ebx D$SectionsMap | add ebx D$FirstSection
        Mov edx D$TruthAsciiTable, eax 0

        sub D$UserPeEnd 3

        While esi < D$UserPeEnd
            test B$ebx IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG+CODEFLAG NOT_ZERO L2>
            Mov al B$esi

            .If B$edx+eax = GOODASCII
                If B$Forced = &TRUE
                    Mov B$ebx TEMPOFLAG
                Else
                    On B$ebx = 0, Mov B$ebx TEMPOFLAG
                End_If
            .End_If

L2:         inc esi | inc ebx
        End_While

      ; Append zero-ends:
        Mov esi D$SectionsMap | add esi D$FirstSection

        .While esi < D$EndOfSectionsMap
            .If B$esi = TEMPOFLAG
              ; Consider case of Strings Length >= D@length/2 :
                Mov ecx 0
                While B$esi = TEMPOFLAG | inc esi | inc ecx | End_While
                shl ecx 1 | cmp ecx D@Length | jb L2>

                If B$esi = 0
                  ; Write a TEMPOFLAG on the trailing zero, if any:
                    Mov ebx esi | sub ebx D$SectionsMap | add ebx D$UserPeStart
                    On B$ebx = 0, Mov B$esi TEMPOFLAG
                End_If
            .End_If

L2:         inc esi

        .End_While

      ; Delete too small Strings Chunks:
        Mov esi D$SectionsMap | add esi D$FirstSection
        Mov edx D$EndOfSectionsMap | sub edx 4

        .While esi < edx
            ..If B$esi = TEMPOFLAG
                Mov ecx 0, ebx esi
L0:             While B$esi = TEMPOFLAG
                    inc esi | inc ecx | On esi >= edx, jmp L0>
                End_While

              ; Append any following small Chunk (down to 5 uChars):
                .If B$esi+1 = TEMPOFLAG                 ; 1 Byte in between!
                    If D$esi+2 = FOURTEMPOFLAGS
                        add esi 6 | add ecx 5 | jmp L0<
                    End_If
                .Else_If B$esi+2 = TEMPOFLAG            ; 1 Word in between!
                    If D$esi+3 = FOURTEMPOFLAGS
                        add esi 7 | add ecx 5 | jmp L0<
                    End_If
               ; .Else_If B$esi+3 = TEMPOFLAG            ; 3 Bytes >>> unlikely!
                   ; If D$esi+4 = FOURTEMPOFLAGS
                   ;     add esi 8 | add ecx 5 | jmp L0<
                   ; End_If
              ;  .Else_If B$esi+4 = TEMPOFLAG            ; 1 dWord in between!
                   ; If D$esi+5 = FOURTEMPOFLAGS
                   ;     add esi 8 | add ecx 5 | jmp L0<
                   ; End_If
                .End_If

L0:             If ecx < D@Length
                  ; Too small > arase the TEMPOFLAGs
                    Push esi
L0:                     dec esi | Mov B$esi 0 | cmp esi ebx | ja L0<
                    Pop esi
                End_If
            ..End_If

            inc esi

        .End_While

      ; Now flag the long enough Chunks:
        Mov esi D$SectionsMap | add esi D$FirstSection

        .While esi < D$EndOfSectionsMap
            ..If B$esi = TEMPOFLAG
                Mov ebx esi
                While B$esi = TEMPOFLAG
                    inc esi | On esi >= D$EndOfSectionsMap, jmp L0>
                End_While

L0:             sub ebx D$SectionsMap | add ebx D$RoutingMap | or B$ebx EVOCATED
                sub ebx D$RoutingMap | add ebx D$SizesMap | Mov B$ebx STRINGS+BYTE
              ; and include trailing zeros in Data:
                Mov ebx esi | sub ebx D$SectionsMap | add ebx D$UserPeStart
                On ebx >= D$UserPeEnd, jmp L2>
                If W$ebx = 0
                    Mov eax esi | sub eax D$SectionsMap | add eax D$RoutingMap
                    or B$eax+2 EVOCATED
                    While B$ebx+1 = 0
                        Mov B$esi TEMPOFLAG | inc esi | inc ebx
                        On ebx >= D$UserPeEnd, jmp L2>
                    End_While
                Else
                    Mov eax esi | sub eax D$SectionsMap | add eax D$RoutingMap
                    or B$eax EVOCATED
                End_If

            ..End_If

            inc esi
        .End_While

L2:     Call ReplaceTempoFlagBy DATAFLAG, STRINGS+BYTE | add D$UserPeEnd 3
EndP
____________________________________________________________________________________________

Proc UnicodeRecognition:
    Argument @Length
    Uses ecx

      ; First, for all Ascii Char, write a TEMPOFLAG into the relative SectionsMap Bytes:
        Mov esi D$UserPeStart | add esi D$FirstSection
        Mov ebx D$SectionsMap | add ebx D$FirstSection
        Mov edx D$TruthAsciiTable, eax 0

        sub D$UserPeEnd 3

        While esi < D$UserPeEnd
            test B$ebx IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG+CODEFLAG NOT_ZERO L2>
            Mov al B$esi

            ..If B$edx+eax = GOODASCII
              ; If No Section Flag yet:
                On B$Forced = &TRUE, jmp L1>
                .If W$ebx = 0
L1:                 If B$esi+1 = 0
                        Mov B$ebx TEMPOFLAG, B$ebx+1 TEMPOFLAG
                        inc esi | inc ebx
                    End_If
                .End_If
            ..End_If

L2:         inc esi | inc ebx
        End_While

      ; Append zero-ends:
        Mov esi D$SectionsMap | add esi D$FirstSection

        .While esi < D$EndOfSectionsMap
            ..If B$esi = TEMPOFLAG
              ; Consider case of Strings Length >= D@length/2 :
                Mov ecx 0
                While B$esi = TEMPOFLAG | inc esi | inc ecx | End_While
                cmp ecx D@Length | jb L2>

                If W$esi = 0
                  ; Write a TEMPOFLAG on the trailing zero, if any:
                    Mov ebx esi | sub ebx D$SectionsMap | add ebx D$UserPeStart
                    On W$ebx = 0, Mov W$esi TWOTEMPOFLAGS
                End_If
            ..End_If

L2:         inc esi

        .End_While

      ; Delete too small Strings Chunks:
        Mov esi D$SectionsMap | add esi D$FirstSection

        .While esi < D$EndOfSectionsMap
            ..If B$esi = TEMPOFLAG
                Mov ecx 0, ebx esi
L0:             While B$esi = TEMPOFLAG
                    inc esi | inc ecx | On esi = D$EndOfSectionsMap, jmp L0>
                End_While

              ; Append any following small Chunk (down to 5 uChars):
                .If B$esi+1 = TEMPOFLAG                 ; 1 Byte in between!
                    If D$esi+2 = FOURTEMPOFLAGS
                        add esi 6 | add ecx 5 | jmp L0<
                    End_If
                .Else_If B$esi+2 = TEMPOFLAG            ; 1 Word in between!
                    If D$esi+3 = FOURTEMPOFLAGS
                        add esi 7 | add ecx 5 | jmp L0<
                    End_If
                .Else_If B$esi+3 = TEMPOFLAG            ; 3 Bytes >>> unlikely!
                   ; If D$esi+4 = FOURTEMPOFLAGS
                   ;     add esi 8 | add ecx 5 | jmp L0<
                   ; End_If
                .Else_If B$esi+4 = TEMPOFLAG            ; 1 dWord in between!
                    If D$esi+5 = FOURTEMPOFLAGS
                        add esi 8 | add ecx 5 | jmp L0<
                    End_If
                .End_If

L0:             shr ecx 1

                If ecx < D@Length
                  ; Too small > arase the TEMPOFLAGs
                    Push esi
L0:                     dec esi | Mov B$esi 0 | cmp esi ebx | ja L0<
                    Pop esi
                End_If
            ..End_If

            inc esi

        .End_While

      ; Now flag the long enough Chunks:
        Mov esi D$SectionsMap | add esi D$FirstSection

        .While esi < D$EndOfSectionsMap
            ..If B$esi = TEMPOFLAG
                Mov ebx esi
                While B$esi = TEMPOFLAG
                    inc esi | On esi = D$EndOfSectionsMap, jmp L0>
                End_While

L0:             sub ebx D$SectionsMap | add ebx D$RoutingMap | or B$ebx EVOCATED
                sub ebx D$RoutingMap | add ebx D$SizesMap | Mov B$ebx STRINGS+WORD
              ; and include trailing zeros in Data:
                Mov ebx esi | sub ebx D$SectionsMap | add ebx D$UserPeStart
                On ebx >= D$UserPeEnd, jmp L2>
                If W$ebx = 0
                    Mov eax esi | sub eax D$SectionsMap | add eax D$RoutingMap
                    or B$eax+2 EVOCATED
                    While W$ebx+2 = 0
                        Mov B$esi TEMPOFLAG | inc esi | inc ebx
                        Mov B$esi TEMPOFLAG | inc esi | inc ebx
                        On ebx >= D$UserPeEnd, jmp L2>
                    End_While
                Else
                    Mov eax esi | sub eax D$SectionsMap | add eax D$RoutingMap
                    or B$eax EVOCATED
                End_If

            ..End_If

            inc esi
        .End_While

L2:     Call ReplaceTempoFlagBy DATAFLAG, STRINGS+WORD | add D$UserPeEnd 3
EndP
____________________________________________________________________________________________

Proc ReplaceTempoFlagBy:
    Argument @SectionFlag, @FLAG

      ; replace, for example, all TEMPOFLAGs by DATAFLAGs:
L2:     Mov esi D$SectionsMap | add esi D$FirstSection
        Mov eax D@SectionFlag

        Mov ebx esi | sub ebx D$SectionsMap | add ebx D$SizesMap

        Mov ecx D@FLAG

        While esi < D$EndOfSectionsMap
            If B$esi = TEMPOFLAG
                Mov B$esi al
                or B$ebx cl
            End_If

            inc esi, ebx
        End_While
EndP



____________________________________________________________________________________________

;;
  Repetitive Bytes may be real Instructions. Example:
  
  05, 05, 05, 05, 05   ; add eax 05050505
  C7,80, BC,00,00,00, 00,00,00,00  ; Mov D$eax+0BC 0
;;

MarkRepetitiveDataBytes:
    Mov esi D$UserPeStart | add esi D$FirstSection
    Mov edx D$UserPeEnd | sub edx 8

    Mov ebx esi | sub ebx D$UserPeStart | add ebx D$SectionsMap

    .While esi < edx
L0:     cmp D$ebx 0 | jne L8>
        cmp D$ebx+4 0 | jne L8>

            Mov al B$esi | cmp al 090 | je L8> ; Op90 nop
                           cmp al 0CC | je L8> ; OpCC int3
                           cmp al 0A4 | je L8> ; OpA4 movsb
                           cmp al 0A5 | je L8> ; OpA5 movsd
                           cmp al 0C3 | je L8> ; OpC3 ret

            cmp B$esi+1 al | jne L8>
            cmp B$esi+2 al | jne L8>
            cmp B$esi+3 al | jne L8>
            cmp B$esi+4 al | jne L8>
            cmp B$esi+5 al | jne L8>
            cmp B$esi+6 al | jne L8>
            cmp B$esi+7 al | jne L8>

              ; Case of dummy "Push/Pop eax" for all Registers >>> 9 cases:
                cmp al 050 | je L1>     ; Op50 Push eax
                cmp al 058 | jne L2>    ; Op58 Pop eax
L1:                 cmp B$esi+8 al | jne L8>

L2:             While B$esi = al
                    Mov B$ebx DATAFLAG
                    inc esi | inc ebx | On esi = edx, ret
                    cmp B$ebx 0 | jne L8>
                End_While

                jmp L0<

L8:     inc esi | inc ebx
    .End_While
ret


MarkVeryRepetitiveDataBytes:
    Mov esi D$UserPeStart | add esi D$FirstSection
    Mov edx D$UserPeEnd | sub edx 15

    Mov ebx esi | sub ebx D$UserPeStart | add ebx D$SectionsMap

    .While esi < edx
L0:     cmp D$ebx 0 | jne L2>
        cmp D$ebx+4 0 | jne L2>
        cmp D$ebx+8 0 | jne L2>

            movzx eax B$esi | cmp al 090 | je L2> ; Op90 nop
                              cmp al 0CC | je L2> ; OpCC int3
                              cmp al 0A4 | je L2> ; OpA4 movsb
                              cmp al 0A5 | je L2> ; OpA5 movsd
                              cmp al 0C3 | je L2> ; OpC3 ret

                Mov ecx eax | shl ecx 8 | or ecx eax | shl ecx 16 | or ecx eax
                cmp D$esi ecx | jne L2>
                cmp D$esi+4 ecx | jne L2>
                cmp D$esi+8 ecx | jne L2>

                    While B$esi = al
                        Mov B$ebx DATAFLAG
                        inc esi | inc ebx | On esi = edx, ret
                        cmp B$ebx 0 | jne L2>
                    End_While

                    jmp L0<

L2:     inc esi | inc ebx
    .End_While
ret

____________________________________________________________________________________________

MarkEvocatedSizes:
    Mov esi D$SizesMap, edx D$EndOfSizesMap | add esi D$FirstSection

    .While esi < edx
        Mov al B$esi

        ..If al <> 0
            .If al = POINTER
L1:             Mov ebx esi | sub ebx D$SizesMap | add ebx D$UserPeStart
                Mov ecx ebx | add ecx 100
                Push esi, edx, ebx
                    Call IsItCode ebx, ecx, 25
                Pop ebx, edx, esi

                sub ebx D$UserPeStart | add ebx D$SectionsMap
                If eax = &TRUE
                    On B$ebx = 0, Mov B$ebx CODEFLAG
                Else
                    On D$ebx = 0, Mov D$ebx FOURDATAFLAGS
                End_If

            .Else_If al = DWORD
                jmp L1<

            .Else
              ; Bytes, Words, qWords, FP >>> Data:
                If al < FP4     ; BYTE 1, WORD 00_10, ; // ;DWORD  00_100
                    movzx ecx al
                Else_If al = FP4
                    Mov ecx 4
                Else_If al = FP8
                    Mov ecx 8
                Else_If al = FP10
                    Mov ecx 10
                Else
                    jmp L5>
                End_If

                Mov ebx esi | sub ebx D$SizesMap | add ebx D$SectionsMap
               ; Force it:
L0:             cmp B$ebx VIRTUALFLAG | je L5>
                    Mov B$ebx DATAFLAG | inc ebx | loop L0<

            .End_If
        ..End_If

L5:     inc esi
    .End_While
ret

____________________________________________________________________________________________

[FlowNumberOfPointers: D$ ?]

MarkPointersFlows:
    Mov esi D$UserPeStart | add esi D$FirstSection
    Mov edx D$UserPeEnd | sub edx 4
    Mov D$FlowNumberOfPointers 0

L0:     .While esi < edx
            Mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
            test B$eax IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG NOT_ZERO L5>>

            Mov eax D$esi | sub eax D$DisImageBase | add eax D$UserPeStart
            .If eax > D$UserPeStart
                If eax < D$UserPeEnd
                    sub eax D$UserPeStart | add eax D$SectionsMap
                    test B$eax IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG NOT_ZERO L5>>

                    inc D$FlowNumberOfPointers | add esi 4 | jmp L0<
                End_If
            .End_If

          ; Minimum number of Pointers in the flow: 4
            .If D$FlowNumberOfPointers > 3
                Mov ecx D$FlowNumberOfPointers | shl ecx 2 | sub esi ecx
                Mov edi esi | sub edi D$UserPeStart | add edi D$SizesMap
                Mov ebx edi | sub ebx D$SizesMap | add ebx D$RoutingMap
                Push edi
                    Mov ecx D$FlowNumberOfPointers

                    Mov D$edi POINTER | add edi 4
                    Mov D$ebx INDIRECT+LABEL+EVOCATED | add ebx 4
                    dec ecx

L1:                 Mov D$edi POINTER | add edi 4
                    Mov D$ebx INDIRECT | add ebx 4 | loop L1<
                Pop edi

                Mov ecx D$FlowNumberOfPointers | shl ecx 2
                sub edi D$SizesMap | add edi D$SectionsMap
                Mov al DATAFLAG | rep stosb
              ; Give a chance to downward Code Analyzes:
                sub edi D$SectionsMap | add edi D$RoutingMap | or B$edi EVOCATED

              ; Flag the Locations pointed to by the Pointers Flow:
                Mov ecx D$FlowNumberOfPointers
L1:             lodsd | sub eax D$DisImageBase | add eax D$RoutingMap
                or B$eax EVOCATED+LABEL | loop L1<

                Mov D$FlowNumberOfPointers 0 | jmp L0<<
            .End_If

L5:         Mov ecx 0

            inc esi | Mov D$FlowNumberOfPointers 0
        .End_While
ret


[NumberOfAlternatedPointers: D$ ?]

MarkAlternatedPointersFlows:
    Mov esi D$UserPeStart | add esi D$FirstSection
    Mov edx D$UserPeEnd | sub edx 4
    Mov D$NumberOfAlternatedPointers 0

L0: .While esi < edx
        Mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
        test B$eax IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG NOT_ZERO L5>>
;Mov eax esi | sub eax D$UserPeStart | add eax D$ImageBase
;On eax = 077ED83D4, int3
        Mov eax D$esi | sub eax D$DisImageBase | add eax D$UserPeStart
        .If eax > D$UserPeStart
            If eax < D$UserPeEnd
                sub eax D$UserPeStart | add eax D$SectionsMap
                test B$eax IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG NOT_ZERO L5>>
                Call IsNBytesInstruction 4 | On eax = &TRUE, jmp L5>>
                ;hexprint D$NumberOfAlternatedPointers
                inc D$NumberOfAlternatedPointers | add esi 8 | jmp L0<<
            End_If
        .End_If

      ; Minimum number of Pointers in the flow: 4
        .If D$NumberOfAlternatedPointers > 3
        ;hexprint D$NumberOfAlternatedPointers
            Mov ecx D$NumberOfAlternatedPointers | shl ecx 3 | sub esi ecx
            Mov edi esi | sub edi D$UserPeStart | add edi D$SizesMap
            Mov ebx edi | sub ebx D$SizesMap | add ebx D$RoutingMap
          ; ebx > RoutingMap // edi >> SizesMap
            Push edi
                Mov ecx D$NumberOfAlternatedPointers

                Mov D$edi POINTER | add edi 8
                Mov D$ebx INDIRECT+LABEL+EVOCATED | add ebx 8
                dec ecx

L1:             Mov D$edi POINTER | add edi 8
                Mov D$ebx INDIRECT | add ebx 8 | loop L1<
            Pop edi

            Mov ecx D$NumberOfAlternatedPointers | shl ecx 3 | sub ecx 4
            sub edi D$SizesMap | add edi D$SectionsMap
            Mov al DATAFLAG | rep stosb
          ; Give a chance to downward Code Analyzes:
            sub edi D$SectionsMap | add edi D$RoutingMap | or B$edi EVOCATED

          ; Flag the Locations pointed to by the Pointers Flow:

            Mov ecx D$NumberOfAlternatedPointers
L1:         lodsd | add esi 4 | sub eax D$DisImageBase | add eax D$RoutingMap
            or B$eax EVOCATED | loop L1<

            Mov D$NumberOfAlternatedPointers 0 | jmp L0<<
        .End_If

L5:     Mov D$NumberOfAlternatedPointers 0

        inc esi
    .End_While
ret
____________________________________________________________________________________________

Proc IsNBytesInstruction:
    Argument @N
    Local @Pointer, @End
    Uses esi, edx

      ; @N: Number of Byte before the four bytes Address.
      ; esi: Points to the Four Bytes Address.

      ; Like for 'DecodeOnly':
        Mov B$WeAreInTheCodeBox &TRUE, B$SimpleScan &TRUE

        Mov D@Pointer esi
      ; D@Pointer points to the first Byte of the Adress Candidate.
        lea eax D$esi+4 | Mov D@End eax
      ; D@End points to the next Byte after the Address Candidate.
        sub esi D@N
      ; Esi points to the start Address of an Instruction Candidate, to be now tested.

      ; Disassemble: (DisMain)
L0:     Mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
        Mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
        Mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE

        Mov edi DecodeText
L1:     movzx eax B$esi | inc esi | Call D$DisOp1+eax*4
        On B$DisFlag = DISDONE, jmp L1<

        .If esi = D@End
            Mov eax &TRUE
        .Else_If esi < D@Pointer
            jmp L0<
        ;.Else_If esi = D@Pointer
          ; The Pointer candidate could, itself, also be an Instruction:
        ;    Mov eax &TRUE
        .Else
            Mov eax &FALSE
        .End_If

        Mov B$WeAreInTheCodeBox &FALSE, B$SimpleScan &FALSE
EndP

____________________________________________________________________________________________

;;
  On a big File of 1 Mega, parsing the yet zeroed SectionsMap Bytes may be evaluated
  to parsing 500 Ko. (We execute this Recognition in between the positive and the
  megative Recognitions).
  ___________________________
  Probablity rude evaluations:
  
  * 500,000 on 4,294,967,295 (0_FFFF_FFFF) >>> say, 1 random chance on 2000.
  
    Two consecutive Pointer >>> say, 1 random chance on 4,000,000.
    Three consecutive Pointer >>> say, 1 random chance on 16,000,000,000,000.
    (Four consecutive Pointer and more are already identified erlier, by
    MarkPointersFlows'
  
  * For isolated Pointers (1 random chance on 2000) we also execute:
  
    'IsIsolatedPointer' >>> 'IsNBytesInstruction' that encreases a little bit
    the 1 on 2000 probablity when saying that the Pointer Candidate cannot be
    member of an Instruction (not guaranted at all, but better than nothing).
    
  * For Pointer to identified Code we also ensure that the Pointer does not
    point into the middle of a valid Instruction
;;

[PointerInData: D$ ?]

MarkIsolatedPointers: ; MarkPointersFlows
    Mov esi D$UserPeStart | add esi D$FirstSection
    Mov edx D$UserPeEnd | sub edx 4
    Mov D$FlowNumberOfPointers 0

L0: .While esi < edx
        Mov B$PointerInData &FALSE

        Mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
        If B$eax = 0
            ;
        Else_If B$eax = DATAFLAG
            Mov B$PointerInData &TRUE
        Else
            jmp L5>>
        End_If

        Mov eax D$esi | sub eax D$DisImageBase | add eax D$UserPeStart

        .If eax > D$UserPeStart
            If eax < D$UserPeEnd
                sub eax D$UserPeStart | add eax D$SectionsMap
                test B$eax IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG NOT_ZERO L5>>
                test B$eax+1 IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG NOT_ZERO L5>>
                test B$eax+2 IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG NOT_ZERO L5>>
                test B$eax+3 IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG NOT_ZERO L5>>

                inc D$FlowNumberOfPointers | add esi 4 | jmp L0<<
            End_If
        .End_If

        .If D$FlowNumberOfPointers = 0
            ;
        .Else_If D$FlowNumberOfPointers = 1
            If B$PointerInData = &TRUE
                lea eax D$esi-4 | sub eax D$UserPeStart | add eax D$SizesMap
               ; test B$eax POINTER | jnz L1>
               ; test B$eax DWORD | jnz L1>
                On B$eax = POINTER, jmp L1>
                On B$eax = DWORD, jmp L1>
                Mov eax D$esi-4 | sub eax D$DisImageBase | add eax D$RoutingMap
                Test B$eax EVOCATED+LABEL+INDIRECT NOT_ZERO L1>

                On B$eax <> 0, jmp L5>>

L1:             Mov eax D$esi-4 | sub eax D$DisImageBase | add eax D$SectionsMap
                On B$eax <> CODEFLAG, jmp L1>>
                    sub eax D$SectionsMap | add eax D$RoutingMap
                    test B$eax INSTRUCTION NOT_ZERO L1>
            End_If
;;
  There is no logic that would tell if an isolated Pointer Candidate is or not
  a Pointer, by scaning weither or not, it could be some Code.
;;
            jmp L5>>
            ;sub esi 4 | Call IsIsolatedPointer | add esi 4

            ;If eax = &TRUE
            ;    Mov eax D$esi-4 | sub eax D$DisImageBase | add eax D$SectionsMap
            ;    On D$eax = 0, jmp L1>
            ;End_If

        .Else_If D$FlowNumberOfPointers = 2
            If B$PointerInData = &TRUE
                lea eax D$esi-4 | sub eax D$UserPeStart | add eax D$SizesMap
                test B$eax STRINGS NOT_ZERO L5>>

                jmp L1>
            End_If

            ;sub esi 8 | Call IsIsolatedPointer | add esi 8
            ;On eax = &TRUE, jmp L1>

        .Else
          ; Restore esi to the first Pointer:
L1:         Mov ecx D$FlowNumberOfPointers | shl ecx 2 | sub esi ecx
            Mov edi esi | sub edi D$UserPeStart | add edi D$SizesMap
            Mov ebx edi | sub ebx D$SizesMap | add ebx D$RoutingMap
            Push edi
                Mov ecx D$FlowNumberOfPointers
              ; First Pointer of a list:
                Mov D$edi POINTER | add edi 4
                Mov D$ebx INDIRECT+LABEL+EVOCATED | add ebx 4
                dec ecx | jz L2>
              ; Other Pointers if any:
L1:             Mov D$edi POINTER | add edi 4
                and D$ebx 0_FF | or D$ebx INDIRECT | add ebx 4 | loop L1<
L2:         Pop edi

            Mov ecx D$FlowNumberOfPointers | shl ecx 2
            sub edi D$SizesMap | add edi D$SectionsMap
            Mov al DATAFLAG | rep stosb
          ; Give a chance to downward Code Analyzes:
            sub edi D$SectionsMap | add edi D$RoutingMap | or B$edi EVOCATED

          ; Flag the Locations pointed to by the Pointers Flow:
            Mov ecx D$FlowNumberOfPointers

L1:         lodsd | sub eax D$DisImageBase | add eax D$RoutingMap
            or B$eax EVOCATED+LABEL | loop L1<

            Mov D$FlowNumberOfPointers 0 | jmp L0<<
        .End_If

L5:     inc esi | Mov D$FlowNumberOfPointers 0
    .End_While
ret



____________________________________________________________________________________________

;;
  When all possible Recognitions are done we generalize the found Flags in all
  the coming Sections. Based on the 'DisRvaSectionAlignment'.
;;



StripSectionsZeroEnd:
    Mov esi D$UserPeStart, edx D$UserPeEnd | add esi D$FirstSection
    add esi D$DisRvaSectionAlignment | dec esi

    .While esi < edx
        Push esi

            Mov ecx 0
            While B$esi = 0
                Mov eax esi | sub eax D$UserPeStart | add eax D$RoutingMap
                On B$eax <> 0, jmp L1>
                inc ecx | dec esi | On ecx = D$DisRvaSectionAlignment, jmp L1>
            End_While
            inc esi

            .If ecx > 0
                Mov ebx esi | sub ebx D$UserPeStart | add ebx D$SectionsMap

                If B$ebx = DATAFLAG
                    sub ebx D$SectionsMap | add ebx D$RoutingMap
                    inc ebx | On ecx > 4, AlignOn 4 ebx
                    Mov B$ebx EVOCATED

                Else_If B$ebx = VIRTUALFLAG

                Else_If B$ebx <> KILLFLAG
                    Mov edi ebx, al 0 | rep stosb

                End_If

            .End_If

L1:     Pop esi

        add esi D$DisRvaSectionAlignment
    .End_While
ret
____________________________________________________________________________________________

[ItWasReallyAscii: D$ ?]

WriteCommentedAsciiData:
    ;Call CheckAsciiData |
    On D$BadAsciiSum = ecx, ret

    Push ebx, ecx, edi
        NextDisLine

        Mov D$NextStringBreak edi | add D$NextStringBreak 70

        .If B$ItWasReallyAscii = &TRUE
            If D$FirstDisDataByte <> 0
                Mov edi D$FirstDisDataByte | Mov B$edi '"' | inc edi | jmp L0>
            End_If
        .End_If

        Mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    '
        add edi 7 | Mov D$edi ';  B', D$edi+4 '$ " ' | add edi 7

K0:     Mov al B$ebx | inc ebx
            jmp L1>
L0:             loop K0<
                    jmp L9>>

L1:     ...If al = CR
            cmp B$ebx  LF | jne L2>
                 inc ebx | dec ecx | cmp ecx 0 | je L9>>
L1:         If B$ItWasReallyAscii = &TRUE
                On D$FirstDisDataByte = 0, jmp L1>
                NextDisLine
                Mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    ', D$edi+12 '    '
                add edi 13
            Else
L1:             Call NextDataDisLine
            End_If
            jmp L0<

        ...Else_If al = LF
L2:         Mov al '.' | inc edx

        ...Else_If al = 0
            inc edx
            ..If D$edi-4 = 'B$ "'
                Mov B$edi-1 '0'   ; > 'B$ 0'

            ..Else_If B$edi-1 = '0'
                If D$edi-4 = 'B$ 0'
                    Mov D$edi ', 0 ' | add edi 3
                Else_If W$edi-3 = '" '
                    Mov D$edi ', 0 ' | add edi 3
                Else_If W$edi-3 = ', '
                    Mov D$edi ', 0 ' | add edi 3
                Else
                    Mov D$edi '", 0' | add edi 4
                End_If

            ..Else
                Mov D$edi '" 0 ' | add edi 3

            ..End_If

            cmp ecx 1 | je L8>>
            .If B$ebx <> 0
                If B$ItWasReallyAscii = &TRUE
                    On D$FirstDisDataByte = 0, jmp L1>
                    NextDisLine
                    Mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    ', D$edi+12 '    '
                    add edi 13
                Else
L1:                 Call NextDataDisLine
                End_If
                Mov B$edi '"' | inc edi
            .End_If
            cmp ecx 1 | je L8>>
            jmp L0<<

        ...Else_If al = 9
            Mov eax '    ' | stosd

        ...Else_If al = '"'
            Mov D$edi '",02', D$edi+4 '2, "' | add edi 8 | jmp L0<<

        ...Else_If al < SPC
L2:         Mov al '.' | inc edx


        ...Else_If al > 127
            ; ... ???

        ...End_If

        .If B$edi-1 = '0'
            If W$edi-3 = '" '
                Mov D$edi ', " ' | add edi 3
            Else_If W$edi-3 = ', '
                Mov D$edi ', " ' | add edi 3
            Else
                ; ????
            End_If
        .End_If

        stosb

        If edi = D$NextStringBreak
            Mov W$edi '",', W$edi+2 CRLF | add edi 4
            Mov eax '    ' | stosd | stosd | stosd | stosd
            Mov W$edi-2 ';"'

            add D$NextStringBreak 88
        End_If

        jmp L0<<

L9:     Mov W$edi '" ' | add edi 2
L8:     Mov B$edi ']' | inc edi
    Pop eax, ecx, ebx
ret


[NextStringBreak: D$ ?]


WriteImm8:
    movzx ebx B$esi | inc esi | jmp S1>
WriteImm16:
    movzx ebx W$esi | add esi 2 | jmp S1>
WriteImm32:  ; WriteDis32
    On B$OperandSizeOverride = &TRUE, jmp WriteImm16

    lodsd | On B$SimpleScan = &TRUE, jmp WriteEax

    Mov ebx eax | sub ebx D$DisImageBase | add ebx D$SectionsMap
    If ebx >= D$EndOfSectionsMap
        ; >>> WriteEax
    Else_If ebx <= D$SectionsMap
        ; >>> WriteEax
    Else
        Mov bl B$ebx
        and bl DATAFLAG+VIRTUALFLAG+CODEFLAG | jnz WriteDisRelative
    End_If

WriteEax:

S1: Mov edx eax

    Push NA

L1: Mov eax edx

        shr edx 4 | and eax 0_F | Mov al B$STR.A.Hexa+eax

        Push eax

    Test edx NA NOT_ZERO L1<

    Mov al '0' | stosb

L2: Pop eax

        Comp eax NA = S0>

    stosb | jmp L2<

S0: ret


WriteSignedImm32:

    Mov ebx D$esi | add esi 4 | jmp L0>

WriteSignedImm16:

    movsx ebx W$esi | add esi 2 | jmp L0>

WriteSignedImm8:

    movsx ebx B$esi | inc esi

L0: Push 0-1

    test ebx DWORD_HIGH_BIT ZERO L0>

        If B$edi-1 = '+'

            Mov B$edi-1 '-'

        Else

            Mov W$edi '0-' | add edi 2

        End_If

        neg ebx

L0: Mov eax ebx | shr ebx 4 | and eax 0F

    Mov al B$STR.A.Hexa+eax

    Push eax

    cmp ebx 0 | ja L0<

    Mov B$edi '0' | inc edi

L0: Pop eax | cmp eax 0-1 | je L9>

    Mov B$edi al | inc edi | jmp L0<

L9: ret

UnlikelyOut:
    Push eax
        Mov eax D$esi
        sub eax D$DisImageBase | add eax D$SectionsMap
        On eax >= D$EndOfSectionsMap, jmp L8>
        On eax <= D$SectionsMap, jmp L8>
    Pop eax
ret

L8: If D$SegmentOverride = 0
      ; In case, for example of 'fs:0', this would be normal
        add B$UnlikelyCode 0F
    End_If
    Pop eax | ret

;;
UnlikelyOut:
    Push eax
        Mov eax D$esi
        sub eax D$DisImageBase | add eax D$SectionsMap
        On eax >= D$EndOfSectionsMap, jmp L8>
        On eax <= D$SectionsMap, jmp L8>
    Pop eax
ret

L8: add B$UnlikelyCode 0FF
    Pop eax | ret
;;

; Input: bl = Mod (0 / 1 / 2.  - 3 is already done before calling here by a Call to
; WriteEregsFromRmBits -)

WriteEffectiveAddressFromModRm:  ; 044 00_100_100    015 00_010_101
    On B$AddressSizeOverride = &TRUE, jmp WriteEffectiveAddressFromModRm16
    ModMask bl To al

    .If al = 0
        Call StartEffectiveAddress | RmMask bl To al

        If al = 0      | Mov D$edi 'eax ' | add edi 4
        Else_If al = 1 | Mov D$edi 'ecx ' | add edi 4
        Else_If al = 2 | Mov D$edi 'edx ' | add edi 4
        Else_If al = 3 | Mov D$edi 'ebx ' | add edi 4
        Else_If al = 4 | Call WriteFromSib
            ..If cl = 0FF
                Call WriteBase5dis32
            ..End_If
        Else_If al = 5
            Call UnlikelyOut
            Call Writedis32
        Else_If al = 6 | Mov D$edi 'esi ' | add edi 4
        Else           | Mov D$edi 'edi ' | add edi 4
        End_If

    .Else_If al = 1
        Call StartEffectiveAddress | RmMask bl To al

        If al = 0      | Mov D$edi 'eax+' | add edi 4
        Else_If al = 1 | Mov D$edi 'ecx+' | add edi 4
        Else_If al = 2 | Mov D$edi 'edx+' | add edi 4
        Else_If al = 3 | Mov D$edi 'ebx+' | add edi 4
        Else_If al = 4 | Call WriteFromSib
            ..If B$edi-1 <> '+'
                Mov B$edi '+' | inc edi
            ..End_If
        Else_If al = 5 | Mov D$edi 'ebp+' | add edi 4
        Else_If al = 6 | Mov D$edi 'esi+' | add edi 4
        Else           | Mov D$edi 'edi+' | add edi 4
        End_If

        Call WriteSignedImm8 ;| Mov W$edi ax | add edi 2  ; OpToHexa

    .Else_If al = 2
        Call StartEffectiveAddress | RmMask bl To al

        If al = 0      | Mov D$edi 'eax+' | add edi 4
        Else_If al = 1 | Mov D$edi 'ecx+' | add edi 4
        Else_If al = 2 | Mov D$edi 'edx+' | add edi 4
        Else_If al = 3 | Mov D$edi 'ebx+' | add edi 4
        Else_If al = 4 | Call WriteFromSib
            ..If B$edi-1 <> '+'
                Mov B$edi '+' | inc edi
            ..End_If
        Else_If al = 5 | Mov D$edi 'ebp+' | add edi 4
        Else_If al = 6 | Mov D$edi 'esi+' | add edi 4
        Else           | Mov D$edi 'edi+' | add edi 4
        End_If

        Call Writedis32

    .Else ; bl = 3
        If W$DisSizeMarker = 'D$'
            Call WriteEregsFromRmBits
        Else_If W$DisSizeMarker = 'B$'
            Call WriteByteRegsFromRmBits
        Else_If W$DisSizeMarker = 'W$'
            Call WriteWordRegsFromRmBits
        End_If

    .End_If

    If W$edi-2 = '00'
        On B$edi-3 = '+', sub edi 3
    End_If
ret


WriteEffectiveAddressFromModRm16:
    inc B$UnlikelyCode

    ModMask bl To al

    .If al = 0
        Call StartEffectiveAddress | RmMask bl To al

        If al = 0      | Mov D$edi 'bx+s', D$edi+4 'i ' | add edi 6
        Else_If al = 1 | Mov D$edi 'bx+d', D$edi+4 'i ' | add edi 6
        Else_If al = 2 | Mov D$edi 'bp+s', D$edi+4 'i ' | add edi 6
        Else_If al = 3 | Mov D$edi 'bp+d', D$edi+4 'i ' | add edi 6
        Else_If al = 4 | Mov D$edi 'si ' | add edi 3
        Else_If al = 5 | Mov D$edi 'di ' | add edi 3
        Else_If al = 6 | Call Writedis16
        Else           | Mov D$edi 'bx ' | add edi 3
        End_If

    .Else_If al = 1
        Call StartEffectiveAddress | RmMask bl To al

        If al = 0      | Mov D$edi 'bx+s', D$edi+4 'i ' | add edi 6
        Else_If al = 1 | Mov D$edi 'bx+d', D$edi+4 'i ' | add edi 6
        Else_If al = 2 | Mov D$edi 'bp+s', D$edi+4 'i ' | add edi 6
        Else_If al = 3 | Mov D$edi 'bp+d', D$edi+4 'i ' | add edi 6
        Else_If al = 4 | Mov D$edi 'si ' | add edi 3
        Else_If al = 5 | Mov D$edi 'di ' | add edi 3
        Else_If al = 6 | Mov D$edi 'bp ' | add edi 3
        Else           | Mov D$edi 'bx ' | add edi 3
        End_If

        Call WriteSignedImm8 ;| Mov W$edi ax | add edi 2  ; OpToHexa

    .Else_If al = 2
        Call StartEffectiveAddress | RmMask bl To al

        If al = 0      | Mov D$edi 'bx+s', D$edi+4 'i ' | add edi 6
        Else_If al = 1 | Mov D$edi 'bx+d', D$edi+4 'i ' | add edi 6
        Else_If al = 2 | Mov D$edi 'bp+s', D$edi+4 'i ' | add edi 6
        Else_If al = 3 | Mov D$edi 'bp+d', D$edi+4 'i ' | add edi 6
        Else_If al = 4 | Mov D$edi 'si ' | add edi 3
        Else_If al = 5 | Mov D$edi 'di ' | add edi 3
        Else_If al = 6 | Mov D$edi 'bp ' | add edi 3
        Else           | Mov D$edi 'bx ' | add edi 3
        End_If

        Call WriteSignedImm16

    .Else ; bl = 3
        If W$DisSizeMarker = 'D$'
            Call WriteEregsFromRmBits
        Else_If W$DisSizeMarker = 'B$'
            Call WriteByteRegsFromRmBits
        Else_If W$DisSizeMarker = 'W$'
            Call WriteWordRegsFromRmBits
        End_If

    .End_If

    If W$edi-2 = '00'
        On B$edi-3 = '+', sub edi 3
    End_If
ret


WriteEffectiveXMMAddressFromModRm:
    ModMask bl To al

    .If al = 0
        Call StartEffectiveAddress | RmMask bl To al

        If al = 0      | Mov D$edi 'eax ' | add edi 4
        Else_If al = 1 | Mov D$edi 'ecx ' | add edi 4
        Else_If al = 2 | Mov D$edi 'edx ' | add edi 4
        Else_If al = 3 | Mov D$edi 'ebx ' | add edi 4
        Else_If al = 4 | Call WriteFromSib | On cl = 0FF, Call WriteBase5dis32
        Else_If al = 5 | Call UnlikelyOut | Call Writedis32
        Else_If al = 6 | Mov D$edi 'esi ' | add edi 4
        Else           | Mov D$edi 'edi ' | add edi 4
        End_If

    .Else_If al = 1
        Call StartEffectiveAddress | RmMask bl To al

        If al = 0      | Mov D$edi 'eax+' | add edi 4
        Else_If al = 1 | Mov D$edi 'ecx+' | add edi 4
        Else_If al = 2 | Mov D$edi 'edx+' | add edi 4
        Else_If al = 3 | Mov D$edi 'ebx+' | add edi 4
        Else_If al = 4 | Call WriteFromSib | Mov B$edi '+' | inc edi
        Else_If al = 5 | Mov D$edi 'ebp+' | add edi 4
        Else_If al = 6 | Mov D$edi 'esi+' | add edi 4
        Else           | Mov D$edi 'edi+' | add edi 4
        End_If

        Call WriteSignedImm8 ;;;OpToHexa | Mov W$edi ax | add edi 2

    .Else_If al = 2
        Call StartEffectiveAddress | RmMask bl To al

        If al = 0      | Mov D$edi 'eax+' | add edi 4
        Else_If al = 1 | Mov D$edi 'ecx+' | add edi 4
        Else_If al = 2 | Mov D$edi 'edx+' | add edi 4
        Else_If al = 3 | Mov D$edi 'ebx+' | add edi 4
        Else_If al = 4 | Call WriteFromSib | Mov B$edi '+' | inc edi
        Else_If al = 5 | Mov D$edi 'ebp+' | add edi 4
        Else_If al = 6 | Mov D$edi 'esi+' | add edi 4
        Else           | Mov D$edi 'edi+' | add edi 4
        End_If

        Call Writedis32

    .Else ; bl = 3
        Call WriteXMMregsFromRmBits

    .End_If

    If W$edi-2 = '00'
        On B$edi-3 = '+', sub edi 3
    End_If
ret


WriteEffectiveMMXAddressFromModRm: ; 04  00_000_100
    ModMask bl To al

    .If al = 0
        Call StartEffectiveAddress | RmMask bl To al

        If al = 0      | Mov D$edi 'eax ' | add edi 4
        Else_If al = 1 | Mov D$edi 'ecx ' | add edi 4
        Else_If al = 2 | Mov D$edi 'edx ' | add edi 4
        Else_If al = 3 | Mov D$edi 'ebx ' | add edi 4
        Else_If al = 4 | Call WriteFromSib | On cl = 0FF, Call WriteBase5dis32
        Else_If al = 5 | Call UnlikelyOut | Call Writedis32
        Else_If al = 6 | Mov D$edi 'esi ' | add edi 4
        Else           | Mov D$edi 'edi ' | add edi 4
        End_If

    .Else_If al = 1
        Call StartEffectiveAddress | RmMask bl To al

        If al = 0      | Mov D$edi 'eax+' | add edi 4
        Else_If al = 1 | Mov D$edi 'ecx+' | add edi 4
        Else_If al = 2 | Mov D$edi 'edx+' | add edi 4
        Else_If al = 3 | Mov D$edi 'ebx+' | add edi 4
        Else_If al = 4 | Call WriteFromSib | Mov B$edi '+' | inc edi
        Else_If al = 5 | Mov D$edi 'ebp+' | add edi 4
        Else_If al = 6 | Mov D$edi 'esi+' | add edi 4
        Else           | Mov D$edi 'edi+' | add edi 4
        End_If

        Call WriteSignedImm8 ;;;OpToHexa | Mov W$edi ax | add edi 2

    .Else_If al = 2
        Call StartEffectiveAddress | RmMask bl To al

        If al = 0      | Mov D$edi 'eax+' | add edi 4
        Else_If al = 1 | Mov D$edi 'ecx+' | add edi 4
        Else_If al = 2 | Mov D$edi 'edx+' | add edi 4
        Else_If al = 3 | Mov D$edi 'ebx+' | add edi 4
        Else_If al = 4 | Call WriteFromSib | Mov B$edi '+' | inc edi
        Else_If al = 5 | Mov D$edi 'ebp+' | add edi 4
        Else_If al = 6 | Mov D$edi 'esi+' | add edi 4
        Else           | Mov D$edi 'edi+' | add edi 4
        End_If

        Call Writedis32

    .Else ; bl = 3
        Call WriteMMXregsFromRmBits

    .End_If

    If W$edi-2 = '00'
        On B$edi-3 = '+', sub edi 3
    End_If
ret
____________________________________________________________________________________________

[LabelWritten: D$ ?
 LastWrittenLabel: D$ ?]

WriteDisCodeLabel: ; 'WriteOneDataLabel'
    On esi = D$LastWrittenLabel, ret
    Mov D$LastWrittenLabel esi

    Mov eax esi | ToStringsMapFrom UserPeStart, eax
    .If D$eax <> 0
        Push esi
            If D$eax = EntryPointName

               Push esi | Mov esi D$eax | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi

            Else_If D$eax = MainWindowProcName
                Mov W$edi CRLF | add edi 2

                Push esi | Mov esi D$eax | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi

                Mov B$edi ':' | inc edi
            End_If
        Pop esi
    .End_If

    Mov eax esi | sub eax D$UserPeStart | add eax D$DisImageBase
  ; >>> eax = RVA. ebx = 'RoutingMap' pointer.

   ; Call BuildCommentedCodeReference ebx ; made by Guga

    test B$ebx EXPORTNODE ZERO L0>
        Call WriteExportedFunctionLabel

L0: Mov ecx ebx, ebx eax
    Push ebx
        If W$edi-3 <> '::'
            Mov W$edi CRLF | add edi 2
        End_If

        Mov D$edi 'Code' | add edi 4
        Push 0-1

L0:     Mov eax ebx | shr ebx 4 | and eax 0F
        add eax '0' | On eax > '9', add eax 7
        Push eax
        cmp ebx 0 | ja L0<
        Mov B$edi '0' | inc edi
L0:     Pop eax | cmp eax 0-1 | je L1>
        Mov B$edi al | inc edi | jmp L0<

L1: Pop eax | Push eax

    Mov eax esi | ToStringsMapFrom UserPeStart, eax
    .If D$eax <> 0
        If D$eax = EntryPointName
            ;
        Else_If D$eax = MainWindowProcName
            ;
        Else

            Push esi | Mov esi D$eax | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi

        End_If
    .End_If

    Mov W$edi ': ' | add edi 2

L2: Pop eax
    Mov ecx 10, edx 0 | div ecx | add dl '0'
    and al 001111 | add al 'A'
    Mov B$edi al, B$edi+1 dl, B$edi+2 ':' | add edi 3

L9: ret


WriteExportedFunctionLabel:
  ; >>> eax = RVA. ebx = 'RoutingMap' pointer.       'ExportSectionComments' 'CheckExport'

    Push eax, ebx, esi
        sub eax D$DisImageBase

      ; May be a wrong Flag resulting from a DLL Name pointer saved inside the
      ; 'RoutingMap'. If so, the relative 'SectionsMap' Byte is 'IMPORTFLAG':
        Mov ecx D$NumberOfDisExportedFunctions | cmp ecx 0 | je L9>>

        Mov esi D$DisExportFunctionsPointers, ebx D$DisExportNamesPointers

        .If esi < D$UserPeStart
            ; nop
        .Else_If esi > D$UserPeEnd
            ; nop
        .Else
          ; Scan the Functions Pointers, to get the Ordinal Indice:
            Mov edx D$UserPeEnd | sub edx 4
L0:         cmp esi edx | jae L9>>
            cmp D$esi eax | je L1>
K0:             add esi 4 | add ebx 4 | loop L0<
                    jmp L9>>

L1:         Push eax, ebx, ecx, edx, esi

            Mov eax D$NumberOfDisExportedFunctions | sub eax ecx

          ; Search the Ordinal Number, in the Ordinal Table
            Mov esi D$DisExportOrdinal, ecx D$NumberOfDisExportedFunctions

L2:         cmp esi edx | jae L8>>
            cmp W$esi ax | je L3>
              ; Ordinal are Words:
                add esi 2 | loop L2<
                    jmp L8>>

L3:         Mov eax D$NumberOfDisExportedFunctions | sub eax ecx

          ; Get the parallel Pointer, in the Functions Pointers Table:
            Mov esi D$DisExportNamesPointers | shl eax 2 | add esi eax
            Mov esi D$esi | add esi D$UserPeStart

            On esi < D$UserPeStart, jmp L8>>
                On esi > D$UserPeEnd, jmp L8>>
                    ;sub edi 4

                    While B$edi-1 = SPC | dec edi | End_While
                    If B$edi-3 > SPC
                        Mov W$edi CRLF | add edi 2
                    End_If
                    Push esi
                        Mov bl 0, dl 0
                        While B$esi <> 0
                            lodsb
                                If al = '@'
                                    On dl = 0, Mov al 'a', bl 1
                                Else_If al = '$'
                                    Mov al 'S', bl 1
                                Else_If al = '$'
                                    Mov al 'S', bl 1
                                Else_If al <> '_'
                                    inc dl
                                End_If
                            stosb
                        End_While
                        Mov D$edi '::  ' | add edi 3
                    Pop esi
                    If bl = 1

                        Push esi | Mov esi {B$ '; The_real_Name_was: ' EOS} | L0: test B$esi 0_FF ZERO P0> | movsb | jmp L0< | P0: Pop esi

                        While B$esi <> 0 | movsb | End_While
                        Mov D$edi '::  ' | add edi 3
                        Mov W$edi CRLF | add edi 2
                    End_If

                    Pop esi, edx, ecx, ebx, eax | jmp K0<<

L8:             Pop esi, edx, ecx, ebx, eax
        .End_If

L9: Pop esi ebx, eax
ret
____________________________________________________________________________________________

; Provides Local Labels, depending on the Code Pointer Value, in the range of
; A0-A9 to P0-P9:

WriteLocalLabelFromEax:
    Mov ecx 10, edx 0 | div ecx | add dl '0'
    and al 001111 | add al 'A'
    Mov B$edi al, B$edi+1 dl, B$edi+2 ':' | add edi 3
ret


[BadDecodeText: B$ "
 ; Downward Chunk would be bad if previous one was good. On Reference, aligning back: "
 BackSteps: "          
"
 BadDecodeTextLen: Len
 CommentItHexa: "; Get the Bytes Values with the Dialog option: [With Commented Hexa Code].
 ", CommentItHexaLen: Len]

BadDecode:
    Push eax, ebx, ecx, esi
        Push edi
            Mov D$BackSteps '    ', D$BackSteps+4 '    '
            Mov edi BackSteps
            Mov eax esi | sub eax ebx | Call WriteEax
        Pop edi

        Mov esi BadDecodeText, ecx D$BadDecodeTextLen | rep movsb

        If B$WithCommentedHexa = &FALSE
            Mov esi CommentItHexa, ecx D$CommentItHexaLen | rep movsb
        End_If
    Pop esi, ecx, ebx, eax
ret


[CALLInstruction: D$ ?
 MovOrJmpImmInstruction: D$ ?]

RelativeToAbsolute:
 ; When called, eax = relative Dis
    Mov eax D$LastCodeRef
    add eax esi | sub eax D$UserPeStart | add eax D$DisImageBase

    Push eax
        sub eax D$DisImageBase | add eax D$SectionsMap

        .If eax < D$EndOfSectionsMap
            If eax > D$SectionsMap
                jmp L1>
            End_If
        .End_If

        add D$UnlikelyCode 0F
L1: Pop eax
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

Dis_St0Sti_or_Fmem:
    ModMask bl to al | On al <> 3, jmp EndWith.F.mem

WriteSt0Sti: ; (Byte in bl).
    Mov D$edi 'ST0 ', D$edi+4 'ST0 '
    RmMask bl to al
    add B$edi+6 al
    add edi 7
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


WriteStiSt0:
    Mov D$edi 'ST0 ', D$edi+4 'ST0 '
    RmMask bl to al
    add B$edi+2 al
    add edi 7
    Mov B$DisFlag DISDONE+DISLINEOVER
ret


WriteSti:
    Mov D$edi 'ST0 '
    RmMask bl to al
    add B$edi+2 al
    add edi 3
    Mov B$DisFlag DISDONE+DISLINEOVER
ret
____________________________________________________________________________________________



;;; 'Dis_mmx2_m128__xmm1'
; When called, ESI position is on the Mod/Reg/Rm Byte.

Proc MarkSSEdata:
    Arguments @Type
    Uses esi

        On B$WeAreInTheCodeBox = &TRUE EndP

      ; Remove the 'reg' bits from the mod/r/m byte:
        lodsb | and al 00_11_000_111 | On al <> 00_000_101 EndP

        lodsd | sub eax D$DisImageBase | add eax D$RoutingMap

        .If eax < D$RoutingMap
            Mov B$UnlikelyCode 5

        .Else_If eax > D$EndOfRoutingMap
            Mov B$UnlikelyCode 5

        .Else
            or B$eax LABEL+EVOCATED

            sub eax D$RoutingMap | add eax D$SizesMap

            If D@Type = SSE_4_F
                Mov D$eax FP4, D$eax+4 FP4, D$eax+8 FP4, D$eax+12 FP4

L4:             sub eax D$SizesMap | add eax D$SectionsMap
                On D$eax <> VIRTUALFLAG,
                    Mov D$eax FOURDATAFLAGS, D$eax+4 FOURDATAFLAGS,
                        D$eax+8 FOURDATAFLAGS, D$eax+12 FOURDATAFLAGS

            Else_If D@Type = SSE_2_R
                Mov D$eax FP8, D$eax+8 FP8 | jmp L4<

            End_If

        .End_If
EndP

[SSE_4_F 1, SSE_2_R 2, SSE_1_R 3, SSE_1_F 4, SSE_2_F 5,
 SSE_4_D 6, SSE_2_D 7, SSE_1_D 8, SSE_1_Q 9]

;;
  List of SSE Mnemonics >>> Types:  (Call MarkSSEdata )
  
  addpd     Call MarkSSEdata SSE_2_R
  addps     Call MarkSSEdata SSE_4_F
  addsd     Call MarkSSEdata SSE_1_R
  addss     Call MarkSSEdata SSE_1_F
  addsubpd  Call MarkSSEdata SSE_2_R
  addsubps  Call MarkSSEdata SSE_4_F
  andnpd    Call MarkSSEdata SSE_2_R
  andnps    Call MarkSSEdata SSE_4_F
  andpd     Call MarkSSEdata SSE_2_R
  andps     Call MarkSSEdata SSE_4_F
  cmp..ps   Call MarkSSEdata SSE_4_F opc2
  cmp..ss   Call MarkSSEdata SSE_2_F
  comisd    Call MarkSSEdata SSE_1_R
  comiss    Call MarkSSEdata SSE_1_F
  cvtdq2pd  Call MarkSSEdata SSE_2_D
  cvtdq2ps  Call MarkSSEdata SSE_4_D
  cvtpd2dq  Call MarkSSEdata SSE_2_R   ; F2 0F E6 /r opf2
  cvtpd2pi  Call MarkSSEdata SSE_2_R
  cvtpd2ps  Call MarkSSEdata SSE_2_R
  cvtpi2pd  Call MarkSSEdata SSE_2_D
  cvtpi2ps  Call MarkSSEdata SSE_2_D
  cvtps2dq  Call MarkSSEdata SSE_4_F
  cvtps2pd  Call MarkSSEdata SSE_2_F
  cvtps2pi  Call MarkSSEdata SSE_2_F
  cvtsd2si  Call MarkSSEdata SSE_1_R
  cvtsd2ss  Call MarkSSEdata SSE_1_R
  cvtsi2sd  Call MarkSSEdata SSE_1_D
  cvtsi2ss  Call MarkSSEdata SSE_1_D
  cvtss2sd  Call MarkSSEdata SSE_1_F
  cvtss2si  Call MarkSSEdata SSE_1_F
  cvttpd2dq Call MarkSSEdata SSE_2_R
  cvttpd2pi Call MarkSSEdata SSE_2_R
  cvttps2dq Call MarkSSEdata SSE_4_F
  cvttps2pi Call MarkSSEdata SSE_2_F
  cvttsd2si Call MarkSSEdata SSE_1_R
  cvttss2si Call MarkSSEdata SSE_1_F
  divpd     Call MarkSSEdata SSE_2_R
  divps     Call MarkSSEdata SSE_4_F
  divsd     Call MarkSSEdata SSE_1_R
  divss     Call MarkSSEdata SSE_1_F
  haddpd    Call MarkSSEdata SSE_2_R
  haddps    Call MarkSSEdata SSE_4_F
  hsubpd    Call MarkSSEdata SSE_2_R
  hsubps    Call MarkSSEdata SSE_4_F
  maxpd     Call MarkSSEdata SSE_2_R
  maxsd     Call MarkSSEdata SSE_1_R
  maxss     Call MarkSSEdata SSE_1_F
  minpd     Call MarkSSEdata SSE_2_R
  minps     Call MarkSSEdata SSE_4_F
  minsd     Call MarkSSEdata SSE_1_R
  minss     Call MarkSSEdata SSE_1_F
  movapd    Call MarkSSEdata SSE_2_R
  movaps    Call MarkSSEdata SSE_4_F
  movddup   Call MarkSSEdata SSE_1_Q
  movhpd    Call MarkSSEdata SSE_1_R
  movhps    Call MarkSSEdata SSE_2_F
  movlpd    Call MarkSSEdata SSE_1_R
  movlps    Call MarkSSEdata SSE_2_F
  movshdup  Call MarkSSEdata SSE_4_F
  movsldup  Call MarkSSEdata SSE_4_F
  movntpd   Call MarkSSEdata SSE_2_R
  movntps   Call MarkSSEdata SSE_4_F
  movss     Call MarkSSEdata SSE_1_R
  movupd    Call MarkSSEdata SSE_2_R
  movups    Call MarkSSEdata SSE_4_F
  mulpd     Call MarkSSEdata SSE_2_R
  mulps     Call MarkSSEdata SSE_4_F
  mulsd     Call MarkSSEdata SSE_1_R
  mulss     Call MarkSSEdata SSE_1_F
  orpd      Call MarkSSEdata SSE_2_R
  orps      Call MarkSSEdata SSE_4_F
  rcpps     Call MarkSSEdata SSE_4_F
  rcpss     Call MarkSSEdata SSE_4_F
  rsqrtps   Call MarkSSEdata SSE_4_F
  rsqrtss   Call MarkSSEdata SSE_4_F
  shufpd    Call MarkSSEdata SSE_2_R
  shufps    Call MarkSSEdata SSE_4_F
  sqrtpd    Call MarkSSEdata SSE_2_R
  sqrtps    Call MarkSSEdata SSE_4_F
  sqrtsd    Call MarkSSEdata SSE_2_R
  sqrtss    Call MarkSSEdata SSE_4_F
  subpd     Call MarkSSEdata SSE_2_R
  subps     Call MarkSSEdata SSE_4_F
  subsd     Call MarkSSEdata SSE_2_R
  subss     Call MarkSSEdata SSE_4_F
  ucomisd   Call MarkSSEdata SSE_2_R
  ucomiss   Call MarkSSEdata SSE_4_F
  unpckhpd  Call MarkSSEdata SSE_2_R
  unpckhps  Call MarkSSEdata SSE_4_F
  unpcklpd  Call MarkSSEdata SSE_2_R
  unpcklps  Call MarkSSEdata SSE_4_F
  xorpd     Call MarkSSEdata SSE_2_R
  xorps     Call MarkSSEdata SSE_4_F
;;


____________________________________________________________________________________________
____________________________________________________________________________________________

; The Encode / Decode Dialog (Tool Menu).
____________________________________________________________________________________________
____________________________________________________________________________________________

ViewEncoding:
    Call 'USER32.DialogBoxParamA' D$H.Instance, 28000, &NULL, EncodingProc, &NULL
ret

[ZeroString: D$ ?]

[EncodeHelp: B$ 'Code_Viewer' EOS]

; This is the Source For Encoding (Upper Edite Control);
[EncodeSource: B$ "[DATA: 0 0 0 0]
LABEL0:
L0: ", EncodeText: "                                                                  
L1:
Label1:
"]
; This is to ensure that the Assembler do not overwrite the downward Data when ajusting,
; for example, the Asm Source ending CR/LF(s):
[EncodeSecurity: D$ ? # 10]

; This is the second Edit Control showing Text Hexa Code
[HexaCodeText: D$ ? # 10]

; This is the third read only EditBox for Disassembly:
[DummyDecodeText: D$ ? ?]
[DecodeText: D$ ? # 40] ; 40+2 >>> 168

; This is for storing Binary Hexa of Code when only Disassembling:
[DecodeOnlyHexa: D$ ? # 10]

Proc EncodingProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ...If D@msg = &WM_INITDIALOG

        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        Call 'USER32.GetDlgItem' D@hwnd 13
        Call 'USER32.SetFocus' eax
        jmp L8>>

    ...Else_If D@msg = &WM_COMMAND
        Mov eax D@wParam | and D@wParam 0FFFF | shr eax 16
        ..If eax = &CBN_SELCHANGE

        ..Else_If D@wParam = &IDCANCEL

            Call 'USER32.EndDialog' D@hwnd 0

        ..Else_If D@wParam = &IDOK
            Call 'USER32.GetFocus' | Call 'USER32.GetDlgCtrlID' eax
            On eax = 16, jmp L3>

            Mov eax '    ', edi EncodeText, ecx 15 | rep stosd
            Call 'USER32.GetDlgItemTextA' D@hwnd, 13, EncodeText, 60
            On eax = 0, jmp L3>

            Mov B$EncodeText+eax SPC | Call EncodeDecode

            Call 'USER32.SetDlgItemTextA' D@hwnd, 16, HexaCodeText
            Call 'USER32.SetDlgItemTextA' D@hwnd, 17, DecodeText

        ..Else_If D@wParam = 3
L3:         Call 'USER32.GetDlgItemTextA' D@hwnd, 16, HexaCodeText, 80

            Call DecodeOnly

            Call 'USER32.SetDlgItemTextA' D@hwnd, 13, ZeroString
            Call 'USER32.SetDlgItemTextA' D@hwnd, 17, DecodeText
            Call 'USER32.SetDlgItemTextA' D@hwnd, 16, HexaCodeText


        ..Else_If D@wParam = &IDHELP
            Call Help, B_U_AsmName, EncodeHelp, ContextHlpMessage

        ..End_If

    ...Else_If D@msg = &WM_CTLCOLOREDIT
        jmp L1>

    ...Else_If D@msg = &WM_CTLCOLORLISTBOX
L1:     Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | jmp L9>

    ...Else
L8:     popad | Mov eax &FALSE | jmp L9>

    ...End_If

    popad | Mov eax &TRUE

L9: EndP


[WeAreInTheCodeBox: D$ ?]

DecodeOnly:
    Mov B$WeAreInTheCodeBox &TRUE, B$SimpleScan &TRUE
    Mov esi HexaCodeText

    While B$esi > 0
        On B$esi <= SPC, Mov B$esi Space
        inc esi
    End_While
    Mov B$esi Space, D$esi+1 0

    Mov esi HexacodeText, edi DecodeOnlyHexa

    .While B$esi > 0
        Mov ebx 0,  edx 0, ecx 0, eax 0

        While B$esi < '0'
            inc esi | On B$esi = 0, jmp L9>
        End_While
        While B$esi = '0'
            inc esi
            On B$esi <= Space, jmp L8>
            On B$esi = 0, jmp L9>
        End_While

L0:     lodsb | On al > 'Z', and eax (not 32) | cmp al Space | jbe L8>
            sub al '0' | cmp al 9 | jbe L2>
                sub al 7
L2:     shld edx ebx 4 | shl ebx 4 | or bl al
        cmp edx ecx | jb L7>
        Mov ecx edx
        cmp al 0F | jbe L0<

L7:     Call Beep | ret

L8:     Mov eax ebx
        cmp eax 0FF | ja L7<

        stosb
    .End_While
L9:  Mov D$edi 0

  ; Disassemble: (DisMain)
    Mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
    Mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
    Mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE
    Mov esi DecodeOnlyHexa, edi DecodeText
L0: movzx eax B$esi | inc esi | Call D$DisOp1+eax*4
; WriteImm32 WeAreInTheCodeBox WriteDisRelative
    On B$DisFlag = DISDONE, jmp L0<
    Mov D$edi 0

  ; Re-write the Hexa Code Text (simply for clean up and striping extra-Bytes):
    Mov edx esi, esi DecodeOnlyHexa, edi HexacodeText
    While esi < edx
        movzx eax B$esi | inc esi
        Mov ebx eax | shr ebx 4
        and eax 0F | and ebx 0F
        Mov al B$STR.A.Hexa+eax, bl B$STR.A.Hexa+ebx
        shl eax 8 | or eax ebx | or eax 020200000 | stosd
    End_While
    Mov D$edi 0

  ; In case of text organisation (sub edi 6, for example), we reset:
    If D$DummyDecodeText+4 <> 0
        Mov eax DecodeText
        While B$eax-1 > 0
            dec eax
        End_While
        Mov ecx DecodeText | sub ecx eax
        Mov esi DecodeText | add esi 160-1 | Mov edi esi | sub esi ecx
        std
L0:         movsb | cmp edi DecodeText | jae L0<
        cld
        Mov D$DummyDecodeText 0, D$DummyDecodeText+4 0
    End_If

    Mov B$WeAreInTheCodeBox &FALSE, B$SimpleScan &FALSE
ret


[LastDisVirtualData: D$ ?]
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE DisInter        ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
  With each successful Disassembly, the Disassembler outputs 4 Files:
  
  * 3 of them are simple copies of 'SectionsMap', 'RoutingMap' and 'SizesMap'.
  
  * The 4th one is the 'ForcedRecordsTable', storing, at least, a header for
    'DisImageBase', and followed by the user defined Records, as edited with
    the 'ForcedFlags' Dialog, if any.
    
  -----------------
  The 
  
  'ForcedFlags' >>> 'ForcedFlagsProc'
  
  is called from the Float menu
  ('RightClickOnBlock' >>> DisLabel >>> Float Menu)
  
  When this interface is called, 'DisLabelTypeWas' says if this was CODEFLAG or
  DATAFLAG, 'DisAddressWas' holds the dWord Value of the selected Label (ex: 040506B),
  and 'CopyOfLabelHexa' is the Hexa Text form of the Label Number. Same is it for
  'NextDisAddressWas' and 'CopyOfNextLabelHexa', that hold the next matching Label,
  to assume then end of a Chunk, in Strings Cases.
  
  'ForcedFlagsProc' is the main Procedure that:
  
  * Reads the Files: 'MyAppSection.map', 'MyAppRouting.map', 'MyAppSize.map',
                     and, also, the 'MyAppForced.map' File.
                     
    These 3 Files are images of the Disassembler Tables, saves at the end of each
    Disassembling. When 'ForcedFlagsProc' reads them, this is just to get the
    actual Flags of the Bytes targetted by the last Location the User selected
    in the Disassembled Source. These Flags are just read to initialize the Dialog.
;;

____________________________________________________________________________________________
____________________________________________________________________________________________

; Main of the Forced Flag Box: 'ForcedFlags' >>> 'ForcedFlagsProc'.

ForcedFlags:
    Call GetOriginalDisFileNameFromSource

    If B$SaveFilter <> 0
        Call 'USER32.DialogBoxParamA' D$H.Instance, 2500, D$H.MainWindow, ForcedFlagsProc, &NULL

        On eax = &TRUE, Call ReRunDisassembler
    Else
        Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ "The expected Original File Name was not found,
at the Top of this Source" EOS}, {B$ 'Failure of Edition' EOS}, 0
    End_If
ret


[H.ForcedFlagsProc: D$ ?]

; Tag Dialog 2500

Proc ForcedFlagsProc:
    Arguments @hwnd, @msg, @wParam, @lParam

    pushad

    ..If D@msg = &WM_INITDIALOG
        Move D$H.ForcedFlagsProc D@hwnd
        Mov B$ForcedFlagsModified &FALSE

        Call 'USER32.SendDlgItemMessageA' D@hwnd, 10, &EM_SETLIMITTEXT, 8, 0
        Call 'USER32.SendDlgItemMessageA' D@hwnd, 11, &EM_SETLIMITTEXT, 8, 0

        Call 'USER32.SetClassLongA' D@hwnd &GCL_HICON D$STRUC.WINDOWCLASS@hIcon
        Mov eax &TRUE

        Call InitForcedFlagsDialog

        If D$ForcedRecordsTable = 0
            Call 'USER32.MessageBoxA' D$H.MainWindow,
            {B$ 'The Forced Records File was not found' EOS}, {B$ 'Failure of Edition' EOS}, 0
            Call 'USER32.EndDialog' D@hwnd, &FALSE
        End_If

    ..Else_If D@msg = &WM_CLOSE
        Call 'USER32.EndDialog' D@hwnd, &FALSE

    ..Else_If D@msg = &WM_COMMAND
        .If D@wParam = &IDCANCEL
            Call 'USER32.EndDialog' D@hwnd, &FALSE

        .Else_If D@wParam = &IDOK
            Call RegisterUserFlags
            If B$BadUserFlag = &FALSE
                Call WriteForcedRecordsFile  ; ReadForcedRecordsFile
                Call 'USER32.EndDialog' D@hwnd, &TRUE
            End_If

        .Else_If D@wparam = ID_HELP
            Call Help, B_U_AsmName, DisMap, ContextHlpMessage

      ; [x] Code Flag
        .Else_If D@wparam = 10
            Call 'USER32.SendDlgItemMessageA' D@hwnd, 10, &BM_GETCHECK, 0, 0
            Push eax
                xor eax &TRUE
                Call 'USER32.SendDlgItemMessageA' D@hwnd, 11, &BM_SETCHECK, eax, 0
            Pop eax
            If eax = &TRUE
                Call DisableDisDataFlags
              ; Code cannot be 'POINTER':
                Call 'USER32.SendDlgItemMessageA' D@hwnd, 23, &BM_SETCHECK, &FALSE, 0
              ; But should be 'INSTRUCTION'
                Call 'USER32.SendDlgItemMessageA' D@hwnd, 20, &BM_SETCHECK, &TRUE, 0
            Else
                Call EnableDisDataFlags
              ; Data cannot be 'INSTRUCTION', 'EXPORTED':
                Call 'USER32.SendDlgItemMessageA' D@hwnd, 20, &BM_SETCHECK, &FALSE, 0
                Call 'USER32.SendDlgItemMessageA' D@hwnd, 22, &BM_SETCHECK, &FALSE, 0
            End_If
      ; [x] Data Flag
        .Else_If D@wparam = 11
            Call 'USER32.SendDlgItemMessageA' D@hwnd, 11, &BM_GETCHECK, 0, 0
            xor eax &TRUE
            Push eax
                Call 'USER32.SendDlgItemMessageA' D@hwnd, 10, &BM_SETCHECK, eax, 0
            Pop eax
            xor eax &TRUE
            If eax = &TRUE
                Call EnableDisDataFlags
              ; Data cannot be 'INSTRUCTION', 'EXPORTED':
                Call 'USER32.SendDlgItemMessageA' D@hwnd, 20, &BM_SETCHECK, &FALSE, 0
                Call 'USER32.SendDlgItemMessageA' D@hwnd, 22, &BM_SETCHECK, &FALSE, 0
            Else
                Call DisableDisDataFlags
              ; Code cannot be 'POINTER':
                Call 'USER32.SendDlgItemMessageA' D@hwnd, 23, &BM_SETCHECK, &FALSE, 0
            End_If
       ; [x] Instruction
         .Else_If D@wparam = 20
            Call CheckForcedRouting 20
       ; [x] Label
         .Else_If D@wparam = 21
            Call CheckForcedRouting 21
       ; [x] Exported
         .Else_If D@wparam = 22
            Call CheckForcedRouting 22
       ; [x] Pointer
         .Else_If D@wparam = 23
            Call CheckForcedRouting 23

      ; [x] Previous
        .Else_If D@wparam = 60
            Call DecForcedRecord

      ; [x] Next
        .Else_If D@wparam = 62
            Call IncForcedRecord

      ; [x] Delete This Record
        .Else_If D@wparam = 70
            Call DeleteForcedRecord
            If D$DisForcedRecordIndice = 0
                Call WriteForcedRecordsFile
                Call 'USER32.EndDialog' D@hwnd 0
            End_If

        .Else_If D@wparam < 30
          ; nop

      ; [x] Byte / Word / Dword / FPU4/8/10
        .Else_If D@wparam < 36
            Call Disable D$H.ForcedFlagsProc, 51

      ;; [x] String or Unicode String
        .Else_If D@wparam < 38
            Call Enable D$H.ForcedFlagsProc, 51
            Call SetForcedNextAddressEditControl

        .End_If

    ..Else_If D@msg = &WM_CTLCOLOREDIT
        Call 'USER32.SendMessageA' D@lParam, &EM_SETSEL, 0-1, 0
        Call 'GDI32.SetBkColor' D@wParam D$ARVB.DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | ExitP

    ..Else
        popad | Mov eax &FALSE | jmp L9>

    ..End_If

    popad | Mov eax &TRUE

L9: EndP
____________________________________________________________________________________________

; For coherency of the Routing Flags:

Proc CheckForcedRouting:
    Argument @ID

        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, D@ID, &BM_GETCHECK, 0, 0

        .If eax = &TRUE
            If D@ID < 23
              ;  >>> Cannot be Pointer:
                Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 23,
                                                  &BM_SETCHECK, &FALSE, 0
            Else
              ; 23 (Pointer) >>> Cannot be Instruction, Exported:
                Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 20,
                                                  &BM_SETCHECK, &FALSE, 0
                Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 22,
                                                  &BM_SETCHECK, &FALSE, 0
              ; But must be a dWord (ID 32):
                Call CheckForcedData 32

            End_If
        .End_If
EndP


; Tag Dialog 2500

Proc CheckForcedData:
    Argument @ID

        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 30, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 31, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 32, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 33, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 34, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 35, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 36, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 37, &BM_SETCHECK, &FALSE, 0

        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, D@ID, &BM_SETCHECK, &TRUE, 0
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[H.MapFile: D$ ?]

; Called from DisMain:

WriteMapFiles:
    pushad

    Call TakeCopyOfDisName

    Push edi
        Mov D$edi 'Sect', D$edi+4 'ion.', D$edi+8 'map'

        Call 'KERNEL32.CreateFileA' DisassemblyMapName, &GENERIC_WRITE, 0, 0, &CREATE_ALWAYS,
                                    &FILE_ATTRIBUTE_NORMAL, 0

        If eax <> &INVALID_HANDLE_VALUE
            Mov D$H.MapFile eax

            Mov ecx D$EndOfSectionsMap | sub ecx D$SectionsMap

            Call 'KERNEL32.WriteFile' D$H.MapFile, D$SectionsMap, ecx,
                                      NumberOfReadBytes, 0

            Call 'KERNEL32.CloseHandle' D$H.MapFile
        End_If

    Pop edi
    Push edi
        Mov D$edi 'Rout', D$edi+4 'ing.', D$edi+8 'map'

        Call 'KERNEL32.CreateFileA' DisassemblyMapName, &GENERIC_WRITE, 0, 0, &CREATE_ALWAYS,
                                    &FILE_ATTRIBUTE_NORMAL, 0

        If eax <> &INVALID_HANDLE_VALUE
            Mov D$H.MapFile eax

            Mov ecx D$EndOfSectionsMap | sub ecx D$SectionsMap

            Call 'KERNEL32.WriteFile' D$H.MapFile, D$SectionsMap, ecx,
                                      NumberOfReadBytes, 0

            Call 'KERNEL32.CloseHandle' D$H.MapFile
        End_If

    Pop edi
    Push edi
        Mov D$edi 'Size', D$edi+4 '.map', B$edi+8 0

        Call 'KERNEL32.CreateFileA' DisassemblyMapName, &GENERIC_WRITE, 0, 0, &CREATE_ALWAYS,
                                    &FILE_ATTRIBUTE_NORMAL, 0

        If eax <> &INVALID_HANDLE_VALUE
            Mov D$H.MapFile eax

            Mov ecx D$EndOfSectionsMap | sub ecx D$SectionsMap

            Call 'KERNEL32.WriteFile' D$H.MapFile, D$SectionsMap, ecx,
                                      NumberOfReadBytes, 0

            Call 'KERNEL32.CloseHandle' D$H.MapFile
        End_If
    Pop edi

    popad
ret
____________________________________________________________________________________________
;;
  Called from DisMain.
  
  Must be executed in all case. For example, a user can change the AddressBase from
  exe to dll, without having yet used any Forced Record...
;;
WriteForcedRecordsFileBase:
  ; Is this usefull? (Case of empty File?)
    Call ReadForcedRecordsFile

    If D$ForcedRecordsTable = 0

        Call VirtualAlloc ForcedRecordsTable,
                          010

    End_If

  ; Really needed:
    Mov edi D$ForcedRecordsTable, eax D$DisImageBase | stosd

    Call WriteForcedRecordsFile

    Call VirtualFree ForcedRecordsTable

ret
____________________________________________________________________________________________
____________________________________________________________________________________________

DecForcedRecord:
    If D$DisForcedRecordIndice > 1
        Call GetForcedDialogFlags
        Call RegisterForcedRecord
        dec D$DisForcedRecordIndice
        Call SetForcedFlagsFromForcedRecord
        Call SetSourceToForcedRecord
    End_If
ret

IncForcedRecord:
    Call GetForcedRecordPointer | Mov esi eax | add esi FORCED_RECORD_LENGHT

    If D$esi <> 0
        Call GetForcedDialogFlags
        Call RegisterForcedRecord
        inc D$DisForcedRecordIndice
        Call SetForcedFlagsFromForcedRecord
        Call SetSourceToForcedRecord
    End_If
ret

DeleteForcedRecord:
    Call GetForcedRecordPointer | Mov esi eax

    On D$DisForcedRecordIndice > 1, dec D$DisForcedRecordIndice

    Mov edi esi | add esi FORCED_RECORD_LENGHT

L0: movsd | movsd | movsd | cmp D$esi 0 | ja L0<

    Mov D$edi 0, D$edi+4 0, D$edi+8 0

    sub D$ForcedRecordsSize FORCED_RECORD_LENGHT

    Call SetForcedFlagsFromForcedRecord
    Call SetSourceToForcedRecord
ret

; Called by the Disassembler, when the 'WithForcedMapFile' is set to &FALSE:

DeleteForcedFile:
    Call TakeCopyOfDisName
    Mov D$edi 'Forc', D$edi+4 'ed.m', D$edi+8 'ap'

    Call 'KERNEL32.DeleteFileA' DisassemblyMapName
ret
____________________________________________________________________________________________

RegisterForcedRecord:
    Call GetForcedRecordPointer | Mov ebx eax

    Move D$ebx+FORCED_RECORD_OFFSET1 D$DisAddressWas
    Move D$ebx+FORCED_RECORD_OFFSET2 D$NextDisAddressWas
    Call ForcedFlagsIntoEax | Mov D$ebx+FORCED_RECORD_FLAGS eax
ret


; Returns a Pointer to the actual Forced Record:

GetForcedRecordPointer:
    Push ecx
        Mov eax D$DisForcedRecordIndice | dec eax
        Mov ecx FORCED_RECORD_LENGHT | mul ecx
        add eax FORCED_FILE_HEADERLENGHT
        add eax D$ForcedRecordsTable
    Pop ecx
ret
____________________________________________________________________________________________

[SearchCopyOfForcedLabel: D$ ? # 4]

; Moves the Disassembly Source to the actually edited Forced Label ([Previous]/[Next]):

SetSourceToForcedRecord:
    Mov esi CopyOfLabelHexa, edi SearchCopyOfForcedLabel

    If B$UserSectionFlag = CODEFLAG
        Mov eax 'Code'
    Else
        Mov eax 'Data'
    End_If
    stosd
    Mov ebx 4
    While B$esi <> 0 | movsb | inc ebx | End_While | Mov B$edi 0

  ; We now have a Copy of the Edited Record Label in 'SearchCopyOfForcedLabel'.
  ; Call for a Search:
    Push ebx
        Call RestoreRealSource
    Pop ebx
    Mov edx SearchCopyOfForcedLabel

    Call InternSearch | Call AskForRedrawNow

    If D$FL.BlockInside = &TRUE
        Mov D$FL.BlockInside &FALSE
        Mov esi D$STRUCT.EditData@CurrentWritingPos | dec esi | dec esi | dec esi | Call InternalRightClick
        Mov D$FL.BlockInside &TRUE
    End_If

    Call SetPartialEditionFromPos
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[DisLabelTypeWas: D$ ?
 DisAddressWas: D$ ?
 NextDisAddressWas: D$ ?
 CopyOfLabelHexa: D$ ? ? ? ? ? ? ? ? ? ?
 CopyOfNextLabelHexa: D$ ? ? ? ? ? ? ? ? ? ?]

[DisassemblyMapName: B$ ? # &MAX_PATH]

TakeCopyOfDisName:

    Mov esi SaveFilter,
        edi DisassemblyMapName

    While B$esi <> EOS | movsb | End_While | Mov B$edi EOS

    While B$edi <> '.' | sub edi (1*ASCII) | End_While

  ; Returns with edi >>> '.'

ret

[OriginalFileComment: B$ "
; Do not remove this Comment. It is used by the Disassembler for the interactive
; Editions of the Disassemblies Flags. Without, it would fail to guess which was
; the original File Name:
;
; "

OriginalDisFilePath:]

WriteOriginalFileNameInSource:

    Mov esi OriginalFileComment,
        ecx OriginalDisFilePath

    sub ecx esi | rep movsb

    Mov esi SaveFilter

    While B$esi <> EOS | movsb | End_While

    Mov D$edi CRLF2 | add edi (4*ASCII)

ret


GetOriginalDisFileNameFromSource:
    Call RestoreRealSource

  ; Search, for example, for '; E:\':, as written by 'WriteOriginalFileNameInSource'
    Mov esi D$CodeSource
    Mov ecx OriginalDisFilePath | sub ecx OriginalFileComment
    add esi ecx

    Mov edi SaveFilter

    .If W$esi-2 = '; '
        If W$esi+1 = ':\'
            While B$esi > CR | movsb | End_While | Mov B$edi 0
        Else
            Mov B$edi 0
        End_If

    .Else
        Mov B$edi 0
    .End_If

    Call SetPartialEditionFromPos

    Call 'KERNEL32.FindFirstFileA' SaveFilter, STRUC.FindFile

    If eax = &INVALID_HANDLE_VALUE
        Mov D$SaveFilter 0
    Else
        Call 'KERNEL32.FindClose' eax
    End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

InitForcedFlagsDialog:
    Call ReadForcedRecordsFile

    Call Disable D$H.ForcedFlagsProc, 51

    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 50, &WM_SETTEXT, 0,
                                      CopyOfLabelHexa

    Mov esi D$ForcedRecordsTable, eax D$esi+FORCED_FILE_IMAGEBASE, D$DisImageBase eax

    Call GetUserSelectionIndice | On eax = 0, Call RegisterForcedRecord

    Call 'USER32.SetDlgItemInt' D$H.ForcedFlagsProc, 61,
                                D$DisForcedRecordIndice, &FALSE

    Call TakeCopyOfDisName

    Mov ebx edi
    Push ebx
        Mov D$ebx 'Sect', D$ebx+4 'ion.', D$ebx+8 'map'
        Call ReadMapFileByte D$DisAddressWas ; SectionsMap, EndOfSectionsMap
        .If D$H.DisassemblyMap = &INVALID_HANDLE_VALUE
           ; Call MessageBox {B$ 'Sections Map File not found' EOS}
L1:         Pop ebx | Call InitForcedFlagsFromSelection | ret

        .Else
            Call InitForcedSectionsDialog

        .End_If
    Pop ebx

    Push ebx
        Mov D$ebx 'Rout', D$ebx+4 'ing.', D$ebx+8 'map'
        Call ReadMapFileByte D$DisAddressWas ; SectionsMap, EndOfSectionsMap
        .If D$H.DisassemblyMap = &INVALID_HANDLE_VALUE
            Call MessageBox {B$ 'Routing Map File not found' EOS} | jmp L1<

        .Else
            Call InitForcedRoutingDialog

        .End_If
    Pop ebx

    Push ebx
        Mov D$ebx 'Size', D$ebx+4 '.map', B$ebx+8 0
        Call ReadMapFileByte D$DisAddressWas

        ..If D$H.DisassemblyMap = &INVALID_HANDLE_VALUE
            Call MessageBox {B$ 'Sizes Map File not found' EOS} | jmp L1<<

        ..Else
            Call InitForcedSizeDialog

        ..End_If
    Pop ebx
ret


InitForcedSectionsDialog:
    If eax = CODEFLAG
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 10, &BM_SETCHECK, &TRUE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 11, &BM_SETCHECK, &FALSE, 0
        Call DisableDisDataFlags
    Else
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 10, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 11, &BM_SETCHECK, &TRUE, 0
        Call EnableDisDataFlags
    End_If
ret


InitForcedRoutingDialog:
    test eax INSTRUCTION ZERO L1>
        Push eax
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 20, &BM_SETCHECK, &TRUE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 10, &BM_SETCHECK, &TRUE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 11, &BM_SETCHECK, &FALSE, 0
        Pop eax
L1: test eax NODE ZERO L1>
        Push eax
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 21, &BM_SETCHECK, &TRUE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 20, &BM_SETCHECK, &TRUE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 10, &BM_SETCHECK, &TRUE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 11, &BM_SETCHECK, &FALSE, 0
        Pop eax
L1: ;test eax LABEL ZERO L1> ; We suppose the Label always wanted
        Push eax
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 21, &BM_SETCHECK, &TRUE, 0
        Pop eax
L1: test eax EXPORTNODE ZERO L1>
        Push eax
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 22, &BM_SETCHECK, &TRUE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 21, &BM_SETCHECK, &TRUE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 20, &BM_SETCHECK, &TRUE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 10, &BM_SETCHECK, &TRUE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 11, &BM_SETCHECK, &FALSE, 0
        Pop eax
L1: test eax INDIRECT ZERO L1>
        Push eax
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 23, &BM_SETCHECK, &TRUE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 10, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 11, &BM_SETCHECK, &TRUE, 0
        Pop eax
L1: ret


InitForcedSizeDialog:
  ; Clear all Sizes Flags and disable the End Address Edit:
    Push eax
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 30, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 31, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 32, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 33, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 34, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 35, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 36, &BM_SETCHECK, &FALSE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 37, &BM_SETCHECK, &FALSE, 0
        Call Disable D$H.ForcedFlagsProc, 51
    Pop eax

    .If eax = BYTE
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 30, &BM_SETCHECK, &TRUE, 0
    .Else_If eax = WORD
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 31, &BM_SETCHECK, &TRUE, 0
    .Else_If eax = DWORD
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 32, &BM_SETCHECK, &TRUE, 0
    .Else_If eax = FP4
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 33, &BM_SETCHECK, &TRUE, 0
    .Else_If eax = FP8
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 34, &BM_SETCHECK, &TRUE, 0
    .Else_If eax = FP10
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 35, &BM_SETCHECK, &TRUE, 0
    .Else_If eax = POINTER
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 23, &BM_SETCHECK, &TRUE, 0
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 32, &BM_SETCHECK, &TRUE, 0
    .Else_If eax = STRINGS+BYTE
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 36, &BM_SETCHECK, &TRUE, 0
        Call Enable D$H.ForcedFlagsProc, 51
    .Else_If eax = STRINGS+WORD
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 37, &BM_SETCHECK, &TRUE, 0
        Call Enable D$H.ForcedFlagsProc, 51
    .End_If
ret
____________________________________________________________________________________________

; First Record, for a given Disassembly. We take the Infos from the user's selection:

InitForcedFlagsFromSelection:
    Mov eax D$DisLabelTypeWas | Call InitForcedSectionsDialog

    ..If D$DisLabelTypeWas = CODEFLAG

        Mov eax D$LP.BlockEndText

        If W$eax+(1*ASCII) = '::'

            Mov eax EXPORTNODE

        Else

            Mov eax &NULL

        End_If

        add eax INSTRUCTION+LABEL | Call InitForcedRoutingDialog

        Call DisableDisDataFlags

    ..Else

        Mov eax D$LP.BlockEndText,
            edx D$eax+(3*ASCII),
            bl B$eax+(6*ASCII),
            al B$eax+(3*ASCII)

        If edx = 'Data'

            Mov eax INDIRECT | Call InitForcedRoutingDialog

            Mov eax DWORD

        Else_If edx = 'Code'

            Mov eax INDIRECT | Call InitForcedRoutingDialog

            Mov eax DWORD

        Else_If al = 'B'

            Mov eax BYTE

            On bl = '"', add eax STRINGS

        Else_If al = 'W'

            Mov eax WORD

        Else_If al = 'D'

            Mov eax DWORD

        Else_If al = 'F'

            Mov eax FP4

        Else_If al = 'R'

            Mov eax FP8

        Else_If al = 'T'

            Mov eax FP10

        Else_If al = 'U'

            Mov eax STRINGS+WORD

        End_If

        Call InitForcedSizeDialog

    ..End_If

    Call Disable D$H.ForcedFlagsProc,
                 60

    Call Disable D$H.ForcedFlagsProc,
                  62
ret


DisableDisDataFlags:

    Call Disable D$H.ForcedFlagsProc,
                 30

    Call Disable D$H.ForcedFlagsProc,
                 31

    Call Disable D$H.ForcedFlagsProc,
                 32

    Call Disable D$H.ForcedFlagsProc,
                 33

    Call Disable D$H.ForcedFlagsProc,
                 34

    Call Disable D$H.ForcedFlagsProc,
                 35

    Call Disable D$H.ForcedFlagsProc,
                 36

    Call Disable D$H.ForcedFlagsProc,
                 37

    Call Disable D$H.ForcedFlagsProc,
                 51

ret


EnableDisDataFlags:

    Call Enable D$H.ForcedFlagsProc,
                30

    Call Enable D$H.ForcedFlagsProc,
                31

    Call Enable D$H.ForcedFlagsProc,
                32

    Call Enable D$H.ForcedFlagsProc,
                33

    Call Enable D$H.ForcedFlagsProc,
                34

    Call Enable D$H.ForcedFlagsProc,
                35

    Call Enable D$H.ForcedFlagsProc,
                36

    Call Enable D$H.ForcedFlagsProc,
                37

    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc,
                                      36,
                                      &BM_GETCHECK,
                                      0,
                                      0

    Push eax

        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc,
                                          37,
                                          &BM_GETCHECK,
                                          0,
                                          0

    Pop edx

    or eax edx

    If eax <> 0

        Call Enable D$H.ForcedFlagsProc,
                    51

    End_If

ret


SetForcedNextAddressEditControl:

    Call GetForcedRecordPointer | Mov eax D$eax+FORCED_RECORD_OFFSET2

    Mov D$CopyOfNextLabelHexa 0

    If eax <> 0

        Push edi

            Mov edi CopyOfNextLabelHexa | Call WriteEax | Mov B$edi EOS

        Pop edi

    End_If

    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc,
                                      51,
                                      &WM_SETTEXT,
                                      0,
                                      CopyOfNextLabelHexa

ret
____________________________________________________________________________________________

[H.DisassemblyMap: D$ ?
 DisassemblyMapPtr: D$ ?
 DisassemblyMapLen: D$ ?]
;;
  Reads one Byte, in any Map (SectionsMap, , 'RoutingMap' or 'SizesMap'):
;;
Proc ReadMapFileByte:
    Argument @Ptr
        Call 'KERNEL32.CreateFileA' DisassemblyMapName, &GENERIC_READ,
                                    &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                    &FILE_ATTRIBUTE_NORMAL, 0
        Mov D$H.DisassemblyMap eax

        .If eax <> &INVALID_HANDLE_VALUE

            Call 'KERNEL32.GetFileSize' eax, 0 | Mov D$DisassemblyMapLen eax
                add eax 10

            Call VirtualAlloc DisassemblyMapPtr,
                              eax

            Call 'KERNEL32.ReadFile' D$H.DisassemblyMap, D$DisassemblyMapPtr,
                                     D$DisassemblyMapLen, NumberOfReadBytes, 0

            Call 'KERNEL32.CloseHandle' D$H.DisassemblyMap

            Mov eax D@Ptr | sub eax D$DisImageBase | add eax D$DisassemblyMapPtr
            movzx eax B$eax
          ; Flags Byte in eax

            Call VirtualFree DisassemblyMapPtr

        .End_If

EndP
____________________________________________________________________________________________

[ForcedRecordsTable: D$ ?
 ForcedRecordsSize: D$ ?]
;;
  'ForcedRecordsTable' holds Records of 2 dWords.
  
  * The leading Record is only for storing the 'DisImageBase', and is written at
    the end of the Disassembly Process, by the Disassembler itself.
  
  * The next Records store the user Editions: ... // DWORD Offset / DWORD Flags // ...
    where "Offset" is the displacement inside any Flags Table ('SectionsMap',
    'RoutingMap' and 'SizesMap'), plus the 'DisImageBase', and where "Flags" holds
    the 3 Flags Types, in order:
    
    Low Byte = SizesMap (Example, if Data: STRINGS+BYTE)
    Next Byte = RoutingMap Flag (Example INSTRUCTION+LABEL+EXPORTNODE)
    Next Byte = SectionsMap Flag (Example CODEFLAG)
    
    ... that are managed by 'ForcedFlagsIntoEax', 'EaxIntoForcedFlags'
    
    An "empty" Forced Records Table holds 8 Bytes, at least, for the DisImageBase.
;;

[FORCED_FILE_IMAGEBASE 0, FORCED_FILE_HEADERLENGHT 4
 FORCED_RECORD_OFFSET1 0, FORCED_RECORD_OFFSET2 4, FORCED_RECORD_FLAGS 8,
 FORCED_RECORD_LENGHT 12]

ReadForcedRecordsFile: ; WriteForcedRecordsFile

    Call VirtualFree ForcedRecordsTable

    Call TakeCopyOfDisName
    Mov D$edi 'Forc', D$edi+4 'ed.m', D$edi+8 'ap'

    Call 'KERNEL32.CreateFileA' DisassemblyMapName, &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                &FILE_ATTRIBUTE_NORMAL, 0

    If eax <> &INVALID_HANDLE_VALUE
        Mov D$H.DisassemblyMap eax

        Call 'KERNEL32.GetFileSize' D$H.DisassemblyMap, 0
        Mov D$ForcedRecordsSize eax | add eax 010

        Call VirtualAlloc ForcedRecordsTable,
                          eax

        Call 'KERNEL32.ReadFile' D$H.DisassemblyMap, D$ForcedRecordsTable,
                                 D$ForcedRecordsSize, NumberOfReadBytes, 0

        Call 'KERNEL32.CloseHandle' D$H.DisassemblyMap

    Else
        Mov D$ForcedRecordsTable 0

    End_If
ret


IsForcedMapFile:
    Call TakeCopyOfDisName

    Mov D$edi 'Forc', D$edi+4 'ed.m', D$edi+8 'ap'

    Call 'KERNEL32.FindFirstFileA' DisassemblyMapName, STRUC.FindFile

    If eax <> &INVALID_HANDLE_VALUE
        Call 'KERNEL32.FindClose' eax
        Mov eax &TRUE
    Else
        Mov eax &FALSE
    End_If
ret
____________________________________________________________________________________________

; Called from 'DisMain':

ForceRecordsToMaps:
    Mov esi D$ForcedRecordsTable | Mov edx D$esi+FORCED_FILE_IMAGEBASE
    add esi FORCED_FILE_HEADERLENGHT

    .While D$esi <> 0
        Mov eax D$esi+FORCED_RECORD_FLAGS | Call EaxIntoForcedFlags

      ; Take the Displacement to the Map Tables:
        Mov ebx D$esi+FORCED_RECORD_OFFSET1
      ; edx is the previously saved 'DisImageBase':

        sub ebx edx

      ; Force the SectionsMap:
      ; Useless: Everything is empty at this stage:
      ;  Mov edi D$SectionsMap | add edi ebx
      ;  Mov ecx D$esi+FORCED_RECORD_OFFSET2 | sub ecx D$esi+FORCED_RECORD_OFFSET1 | jecxz L1>
      ;  Mov al 0 | rep stosb

L1:     Mov edi D$SectionsMap, al B$UserSectionFlag, B$edi+ebx al

      ; Force the RoutingMap:
        Mov edi D$RoutingMap, al B$UserRoutingFlag
        On B$UserSectionFlag = CODEFLAG, or al LABEL+NODE+EVOCATED+INSTRUCTION+ACCESSED
        Mov B$edi+ebx al

      ; Force the SizesMap:
        Mov edi D$SizesMap, al B$UserSizeFlag
        .If B$UserSectionFlag = CODEFLAG
            Mov B$edi+ebx 0
        .Else
;;
  If Data, we may have to Flag Chunks of Bytes, in the SizesMap, instead of one
  single Byte, and to also flag the SectionsMap as Data:
;;
            If al = BYTE
                Call ForceDataFlag eax, 1
            Else_If al = WORD
                Call ForceDataFlag eax, 2
            Else_If al = DWORD
                Call ForceDataFlag eax, 4
            Else_If al = FP4
                Call ForceDataFlag eax, 4
            Else_If al = FP8
                Call ForceDataFlag eax, 8
            Else_If al = FP10
                Call ForceDataFlag eax, 10
            Else_If al = POINTER
                Call ForceDataFlag eax, 4
            Else_If al = STRINGS+BYTE
                Call ForceDataFlag eax, 0-1
            Else_If al = STRINGS+WORD
                Call ForceDataFlag eax, 0-1
            End_If
        .End_If

        add esi FORCED_RECORD_LENGHT
    .End_While
;map
ret

Proc ForceDataFlag:
    Argument @Flag, @n

        Mov al B@Flag

        .If D@n = 0-1
          ; Flag Strings down to the next Label:
            Mov ecx D$esi+FORCED_RECORD_OFFSET2 | sub ecx D$esi+FORCED_RECORD_OFFSET1

            Push ebx, ecx
L0:             Mov B$edi+ebx al | inc ebx | loop L0<
            Pop ecx, ebx

            Mov edi D$SectionsMap
L0:         Mov B$edi+ebx DATAFLAG | inc ebx | loop L0<

        .Else
            Push ebx
                Mov ecx D@n
L0:             Mov B$edi+ebx al | inc ebx | loop L0<
            Pop ebx

            Push ebx
                Mov ecx D@n, edi D$SectionsMap
L0:             Mov B$edi+ebx DATAFLAG | inc ebx | loop L0<
            Pop ebx
        .End_If
EndP
____________________________________________________________________________________________

WriteForcedRecordsFile: ; ReadForcedRecordsFile
    Call TakeCopyOfDisName
    Mov D$edi 'Forc', D$edi+4 'ed.m', D$edi+8 'ap'

    Call 'KERNEL32.CreateFileA' DisassemblyMapName, &GENERIC_WRITE,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &CREATE_ALWAYS,
                                &FILE_ATTRIBUTE_NORMAL, 0
    Mov D$H.DisassemblyMap eax

    If eax <> &INVALID_HANDLE_VALUE
        Mov esi D$ForcedRecordsTable, ecx FORCED_FILE_HEADERLENGHT
        add esi ecx

        While D$esi <> 0
            add esi FORCED_RECORD_LENGHT | add ecx FORCED_RECORD_LENGHT
        End_While

        Call 'KERNEL32.WriteFile' D$H.DisassemblyMap, D$ForcedRecordsTable,
                                  ecx, NumberOfReadBytes, 0

        Call 'KERNEL32.CloseHandle' D$H.DisassemblyMap
    End_If
ret
____________________________________________________________________________________________

[DisForcedRecordIndice: D$ ?]

GetUserSelectionIndice:
  ; Substract the 'DisImageBase' from the selected Label dWord:
    Mov eax D$DisAddressWas
;;
  Scan all Records, in 'ForcedRecordsTable'. In case a same Offest would already
  have been edited, we lock on that one. If none found, we start the Edition of
  a new Record, at the end.
;;
    Mov esi D$ForcedRecordsTable | add esi FORCED_FILE_HEADERLENGHT

    Mov ecx 1

    While D$esi <> 0
        cmp D$esi eax | je L1>
        add esi FORCED_RECORD_LENGHT | inc ecx
    End_While

  ; No matching Record found >>> Return 0
    Mov eax 0

L1: Mov D$DisForcedRecordIndice ecx
ret
____________________________________________________________________________________________
;;
  Job similar to the one already done by the Init of 'InitForcedFlagsDialog' (the caller),
  but done from the Values Recorded in 'ForcedRecordsTable', at the wanted Indice:
;;
SetForcedFlagsFromForcedRecord:
        Call Disable D$H.ForcedFlagsProc, 51

        Call 'USER32.SetDlgItemInt' D$H.ForcedFlagsProc, 61,
                                    D$DisForcedRecordIndice, &FALSE

      ; Take the DisImageBase:
        Mov esi D$ForcedRecordsTable
        Mov eax D$esi+FORCED_FILE_IMAGEBASE | Mov D$DisImageBase eax

      ; Point with esi to the proper Record
        Mov ecx D$DisForcedRecordIndice | dec ecx
        Mov eax FORCED_RECORD_LENGHT | mul ecx
        add eax FORCED_FILE_HEADERLENGHT
        add esi eax

      ; Write the Address to the EditBox:
        Mov eax D$esi+FORCED_RECORD_OFFSET1
        Push esi
            Mov edi CopyOfLabelHexa | Call WriteEax | Mov B$edi 0
            Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 50, &WM_SETTEXT,
                                              0, CopyOfLabelHexa
        Pop esi

      ; Split the Flags onto the wanted Variables:
        Mov eax D$esi+FORCED_RECORD_FLAGS | Call EaxIntoForcedFlags
      ; And set the Radio and CheckBoxes:
        Push esi
            Mov eax D$UserSectionFlag | Call InitForcedSectionsDialog
            Mov eax D$UserRoutingFlag | Call InitForcedRoutingDialog
            Mov eax D$UserSizeFlag | Call InitForcedSizeDialog
        Pop esi

        Test B$UserSizeFlag STRINGS ZERO L2>
            Mov eax D$esi+FORCED_RECORD_OFFSET2

          ; And write it to the EditBox:
            Mov edi CopyOfNextLabelHexa | Call WriteEax | Mov B$edi 0
            Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 51, &WM_SETTEXT,
                                              0, CopyOfNextLabelHexa
L2:
        If D$UserSectionFlag = CODEFLAG
            Call DisableDisDataFlags
        End_If
ret
____________________________________________________________________________________________

[ForcedFlagsModified: D$ ?]

[ForcedStartAddressBuffer: D$ ? # 3]

[UserSectionFlag: D$ ?
 UserRoutingFlag: D$ ?
 UserSizeFlag: D$ ?
 BadUserFlag: D$ ?]

; The order, from High to low is: Empty/Section/Routing/Size.

ForcedFlagsIntoEax:
    Mov eax D$UserSectionFlag | shl eax 8
    or al B$UserRoutingFlag | shl eax 8
    or al B$UserSizeFlag
ret

EaxIntoForcedFlags:
    Mov B$UserSizeFlag al | shr eax 8
    Mov B$UserRoutingFlag al | shr eax 8
    Mov B$UserSectionFlag al
ret
____________________________________________________________________________________________

GetForcedDialogFlags:
    Mov B$BadUserFlag &FALSE

  ; Get the targetted Address:
    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 50, &WM_GETTEXT,
                                      10, ForcedStartAddressBuffer

    Call GetHexaFromText ForcedStartAddressBuffer

    If B$GetHexaFromTextError = &TRUE

        Call MessageBox {B$ 'The Address must be given in Hexa Format' EOS}

        Mov B$BadUserFlag &TRUE

ret

    End_If

    Mov D$DisAddressWas eax

    Call GetForcedEndAddress | On eax <> 0, Mov D$NextDisAddressWas eax

  ; Get the SectionsMap Flag:
    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 10, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        Mov B$UserSectionFlag CODEFLAG
    Else
        Mov B$UserSectionFlag DATAFLAG
    End_If

  ; Get the RoutingMap Flags:
  ; [x] Instruction
    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 20, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        Mov B$UserRoutingFlag INSTRUCTION
    Else
        Mov B$UserRoutingFlag 0
    End_If
  ; [x] Label
    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 21, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        or B$UserRoutingFlag LABEL+EVOCATED
    End_If
  ; [x] Exported
    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 22, &BM_GETCHECK, 0, 0
    On eax = &TRUE, or B$UserRoutingFlag EXPORTNODE+NODE+EVOCATED+ACCESSED+LABEL
  ; [x] Pointer
    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 23, &BM_GETCHECK, 0, 0
    On eax = &TRUE, or B$UserRoutingFlag INDIRECT

  ; Get the SizesMap Flags:
    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 30, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        Mov B$UserSizeFlag BYTE | ret
    End_If

    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 31, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        Mov B$UserSizeFlag WORD | ret
    End_If

    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 32, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        Mov B$UserSizeFlag DWORD | ret
    End_If

    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 33, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        Mov B$UserSizeFlag FP4 | ret
    End_If

    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 34, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        Mov B$UserSizeFlag FP8 | ret
    End_If

    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 35, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        Mov B$UserSizeFlag FP10 | ret
    End_If

    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 36, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        Mov B$UserSizeFlag STRINGS+BYTE | ret
    End_If

    Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 37, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        Mov B$UserSizeFlag STRINGS+WORD | ret
    End_If
ret
____________________________________________________________________________________________

RegisterUserFlags:
    Call GetForcedDialogFlags

    If B$BadUserFlag = &FALSE
        Call GetForcedRecordPointer | Mov edi eax

        Mov eax D$DisAddressWas | Mov D$edi+FORCED_RECORD_OFFSET1 eax
        Mov eax D$NextDisAddressWas | Mov D$edi+FORCED_RECORD_OFFSET2 eax

        Call ForcedFlagsIntoEax | Mov D$edi+FORCED_RECORD_FLAGS eax

        Push edi
            Call GetForcedEndAddress
        Pop edi

        On eax <> 0, Mov D$edi+FORCED_RECORD_OFFSET2 eax
    End_If
ret
____________________________________________________________________________________________

GetForcedEndAddress:
    Call 'USER32.GetDlgItem' D$H.ForcedFlagsProc, 51
    Call 'USER32.IsWindowEnabled' eax

    .If eax = &TRUE
        Call 'USER32.SendDlgItemMessageA' D$H.ForcedFlagsProc, 51, &WM_GETTEXT,
                                          10, ForcedStartAddressBuffer
        If eax = 0
            Call 'USER32.MessageBoxA' D$H.MainWindow,
            {B$ 'You must give the End Address of the String (Excluded Label)' EOS},
            {B$ 'Missing Address' EOS}, &MB_OK

            Mov B$BadUserFlag &TRUE | jmp L2>
        End_If

        Call GetHexaFromText ForcedStartAddressBuffer

        If B$GetHexaFromTextError = &TRUE

            Call MessageBox {B$ 'The Address must be given in Hexa Format' EOS}

            Mov B$BadUserFlag &TRUE | jmp L2>
        End_If
      ; eax = Value of the End Label

    .Else
L2:      Mov eax 0

    .End_If
ret
____________________________________________________________________________________________

[AddressToBeForced: D$ ?
 ForcedUpperLine: D$ ?
 ForcedCurrentWritingPos: D$ ?]

ReRunDisassembler:
    Mov B$AddressToBeForced &TRUE

    Call RestoreRealSource

    Mov eax D$STRUCT.EditData@UpperLine | sub eax D$CodeSource
    Mov D$ForcedUpperLine eax
    Mov eax D$STRUCT.EditData@CurrentWritingPos | sub eax D$CodeSource
    Mov D$ForcedCurrentWritingPos eax

    Call SetPartialEditionFromPos | Call AskForRedrawNow

    Call ReInitUndo | Call ClearBackTable | Mov D$TABLE.Titles &NULL

    Call ReleaseMainFile | Call StoreChoosenName SaveFilter | Call ClearBackTable

    Call VirtualFree UserPeStart

    Mov B$WithForcedMapFile &TRUE | Call LastLoading

    Mov eax D$ForcedUpperLine | add eax D$CodeSource
    Mov D$STRUCT.EditData@UpperLine eax
    Mov eax D$ForcedCurrentWritingPos | add eax D$CodeSource
    Mov D$STRUCT.EditData@CurrentWritingPos eax
    Mov D$PreviousPartialSourceLen 0

    Call SetPartialEditionFromPos
    Call SetCaret D$STRUCT.EditData@CurrentWritingPos

    Mov D$FL.BlockInside &FALSE, B$AddressToBeForced &FALSE
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT

TITLE Libs            ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________
____________________________________________________________________________________________
____________________________________________________________________________________________

;              FIRST PART: TRANSLATING THE WHOLE LIBARY INTO ROSASM SYNTAX

;              Authors: Guga and Betov. August/September 2005?
____________________________________________________________________________________________
____________________________________________________________________________________________

;;

  * Main function:
        LibScanner

  * Main Procedure (Dialog): 'ScanLibFile'
  
  * GUI Functions:

    LibScanCleanUp, LibScanDialog_EnableContinueMenu, SaveLibFileAs, LibScanDialog_ToggleToolbarText,
    LibScanDialog_HoverToolbarText, LibScanDialog_EnableContinuePrevTabMenu, LibScanDialog_EnableContinueNextTabMenu,
    OpenLibFile, LibScanDisplayFileSize, WriteObjectTypeinTitle, CoolControl_LVBeginSort, LibScanDialog_OnNotify,
    CoolControlTB_CreateImageList, CoolControlDlg_CreateTab, Tab1Proc, Tab2Proc, CoolControlWin_CreateToolbar,
    SetupListview, CoolControl_LVBeginSort, ListViewLibSort

  * Library Parsing Routines:
    
    LibCoffMarking, GetLibListing, GetOneCoffListing
    >>> 'OpenLibFile', 'LibSignatureCheck'
  
    >>> either 'GetLibListing' or 'GetOneCoffListing'
    
    'ParseLibObj' calls for 'GetCoffListing', in case of Obj Files in .Lib.
    
    CodeView Checking:
        WriteRawDataDebugS


  * Routines in charge of the IMAGE_FILE_MACHINE Equates:
  
    'WriteIMAGE_FILE_MACHINE', 'IsIMAGE_FILE_MACHINE'
    
    
  * 'WriteAuxiliarySymbolsRecords'

    ToDo:
    
    -   Build the steps for the DIS System. Need to identify all symbols, accordying to the DataTypes. I mean,
        we need to interpret them when they are found inside a CodeView file or inside regular Symbol Structures
        (Auxiliary or not). This is a hell of a work, but it is worthfull, because they contains full info.

    -   Analyze and parse OMF Files (Borland and Microsoft, Libs and Objs). They are not too hard to parse, but there are
        minor differences between M$ and Borland ones.

    -   Analyze and Parse all Delphi DCU files. They are not too hard to parse (Check Dede and DMFtoINT), but
        we must take care of the different delphi versions, because the structures varies sometimes.

;;
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  File Jobs:
;;

;;
[LibsFileFilter: B$ 'Supported Files (*.lib, *.a, *.obj, *.o, *.dcu, *.pdb, *.dbg)' EOS  '*.lib;*.a;*.obj;*.o;*.dcu;*.pdb;*.dbg' EOS
                 B$ 'Library Files (*.lib)' EOS  '*.lib' EOS
                 B$ 'Library Files MingWin32/Gcc (*.a)' EOS  '*.a' EOS
                 B$ 'Object Files (*.obj)' EOS  '*.obj' EOS
                 B$ 'Object Files MingWin32/Gcc (*.o)' EOS  '*.o' EOS
                 B$ 'Delphi and Kilyx Control Unit Files  (*.dcu)' EOS  '*.dcu' EOS
                 B$ 'Program DataBase Files (*.pdb)' EOS  '*.pdb' EOS
                 B$ 'Debugging Files  (*.dbg)' EOS  '*.dbg' EOS
                 B$ 'All Files' EOS  '*.*' EOS 0]

[CustomLibsFileFilter:  D$ ? # &MAX_PATH]
[LibSaveFilter: D$ ? # &MAX_PATH]
[ChoosenLibFile: D$ ? # &MAX_PATH]
[OpenLibFileTitle: B$ 'Choose a Lib file...' EOS]

; OpenFile Structure for Libs:

[OPENLIB:
 @lStructSize: D$ Len
 @hwndOwner: D$ 0
 @hInstance: D$ 0
 @lpstrFilter: D$ LibsFileFilter
 @lpstrCustomFilter: D$ CustomLibsFileFilter
 @nMaxCustFilter: D$ 260
 @nFilterIndex: D$ 1
 @lpstrFile: D$ LibSaveFilter
 @nMaxFile: D$ 260
 @lpstrFileTitle: D$ ChoosenLibFile
 @nMaxFileTitle: D$ 260
 @lpstrInitialDir: D$ 0
 @lpstrTitle: D$ OpenLibFileTitle
 @Flags: D$ &OFN_EXPLORER__&OFN_FILEMUSTEXIST__&OFN_LONGNAMES__&OFN_PATHMUSTEXIST
 @nFileOffset: W$ 0
 @nFileExtension: W$ 0
 @lpstrDefExt: D$ 0
 @lCustData: D$ 0
 @lpfnHook: D$ 0
 @lpTemplateName: D$ 0]
____________________________________________________________________________________________

[H.LibFile: D$ ?
 LibFileLength: D$ ?
 LibFileMemory: D$ ?
 LibFileMemoryEnd: D$ ?]

Proc OpenLibFile:
    Arguments @hwnd

    Call 'KERNEL32.CreateFileA' LibSaveFilter, &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                &FILE_ATTRIBUTE_NORMAL, 0
    Mov D$H.LibFile eax

    Call 'KERNEL32.GetFileSize' eax, 0 | Mov D$LibFileLength eax

    Call LibScanDisplayFileSize D@hwnd

    If eax = 0
        Call LibScanDialog_EnableContinueMenu &FALSE
        Call 'USER32.MessageBoxA' D$H.MainWindow, {B$ "Dumping process aborted !!!", D$ CRLF2, B$ "The file you are trying to load is empty (The size of the file is Zero)." EOS}, {B$ 'LibScan' EOS},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL
    Else

        add eax 10

        Call VirtualAlloc LibFileMemory,
                          eax

        add D$LibFileMemory 10

        Call 'KERNEL32.ReadFile' D$H.LibFile, D$LibFileMemory,
                                 D$LibFileLength, NumberOfReadBytes, 0

        Call 'KERNEL32.CloseHandle' D$H.LibFile

        Mov eax D$LibFileMemory | add eax D$LibFileLength | Mov D$LibFileMemoryEnd eax
    End_If
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________
;;
;;
  Called from 'ScanLibFile' Dialog Proc:
  
      Main Procedures for the RosAsm syntax translation of a Library
;;
;;
____________________________________________________________________________________________

; Object and Library Constants
[UNKNOWN_LIB_FILE 0]
[COFF_LIB_FILE 1]
[COFF_OBJ_FILE 2]
[DCU1_KILYX_OBJ_FILE 3]
[DCU2_KILYX_OBJ_FILE 4]
[DCU3_KILYX_OBJ_FILE 5]
[DCU2_OBJ_FILE 6]
[DCU3_OBJ_FILE 7]
[DCU4_OBJ_FILE 8]
[DCU5_OBJ_FILE 9]
[DCU6_OBJ_FILE 10]
[DCU7_OBJ_FILE 11]
[OMF_OBJ_FILE 12]
[PDB_OBJ_FILE 13]
[DBG_OBJ_FILE 14]

; Verification Buffer to hold the above constants
[ValidLib: D$ 0]

Proc LibSignatureCheck:
    pushad

  ; Valid Tag?
    Mov esi D$LibFileMemory

    .If D$esi+2 = 'arch'
        ; Valid .lib
        Mov D$ValidLib COFF_LIB_FILE

    .Else_If D$esi = 0F21F148C ; Borland Kylix 1.0 unit file (DCU). Ver=100
        Mov D$ValidLib DCU1_KILYX_OBJ_FILE

    .Else_If D$esi = 0E1011DD ; Borland Kylix 2.0 unit file (DCU). Ver=101
        Mov D$ValidLib DCU2_KILYX_OBJ_FILE

    .Else_If D$esi = 0E0001DD ; Borland Kylix 2.0 unit file (kind $00) (DCU). Ver=101
        Mov D$ValidLib DCU2_KILYX_OBJ_FILE

    .Else_If D$esi = 0F1001DD ; Borland Kylix 3.0 unit file (DCU). Ver=102
        Mov D$ValidLib DCU3_KILYX_OBJ_FILE

    .Else_If D$esi = 050505348 ; Borland Delphi 2.0 unit file (DCU). Ver=2
        Mov D$ValidLib DCU2_OBJ_FILE

    .Else_If D$esi = 044518641 ; Borland Delphi 3.0 unit file (DCU). Ver=3
        Mov D$ValidLib DCU3_OBJ_FILE

    .Else_If D$esi = 04768A6D8 ; Borland Delphi 4.0 unit file (DCU). Ver=4
        Mov D$ValidLib DCU4_OBJ_FILE

    .Else_If D$esi = 0F21F148B ; Borland Delphi 5.0 unit file (DCU). Ver=5
        Mov D$ValidLib DCU5_OBJ_FILE

    .Else_If D$esi = 0E0000DD ; Borland Delphi 6.0 unit file (DCU). Ver=6
        Mov D$ValidLib DCU6_OBJ_FILE

    .Else_If D$esi = 0E8000DD ; Borland Delphi 6.0 unit file (kind $80) (DCU). Ver=6
        Mov D$ValidLib DCU6_OBJ_FILE

    .Else_If D$esi = 0FF80FFFF ; Borland Delphi 7.0 (Free) (DCU). Ver=7
        Mov D$ValidLib DCU7_OBJ_FILE

    .Else_If D$esi = 0FF0000DF ; Borland Delphi 7.0 unit file (DCU). Ver=7
        Mov D$ValidLib DCU7_OBJ_FILE

    .Else_If D$esi = 0F0000DF ; Borland Delphi 7.0 unit file (DCU). Ver=7
        Mov D$ValidLib DCU7_OBJ_FILE

    .Else_If_Or W$esi = &IMAGE_FILE_MACHINE_UNKNOWN, W$esi = &IMAGE_FILE_MACHINE_ALPHA,
                W$esi = &IMAGE_FILE_MACHINE_ALPHA64, W$esi = &IMAGE_FILE_MACHINE_ARM,
                W$esi = &IMAGE_FILE_MACHINE_AXP64, W$esi = &IMAGE_FILE_MACHINE_CEF,
                W$esi = &IMAGE_FILE_MACHINE_I386, W$esi = &IMAGE_FILE_MACHINE_I486,
                W$esi = &IMAGE_FILE_MACHINE_I586, W$esi = &IMAGE_FILE_MACHINE_IA64,
                W$esi = &IMAGE_FILE_MACHINE_M68K, W$esi = &IMAGE_FILE_MACHINE_MIPS16,
                W$esi = &IMAGE_FILE_MACHINE_MIPSFPU, W$esi = &IMAGE_FILE_MACHINE_MIPSFPU16,
                W$esi = &IMAGE_FILE_MACHINE_POWERPC, W$esi = &IMAGE_FILE_MACHINE_R10000,
                W$esi = &IMAGE_FILE_MACHINE_R3000, W$esi = &IMAGE_FILE_MACHINE_R4000,
                W$esi = &IMAGE_FILE_MACHINE_R6000, W$esi = &IMAGE_FILE_MACHINE_SH3,
                W$esi = &IMAGE_FILE_MACHINE_SH3E, W$esi = &IMAGE_FILE_MACHINE_SH4,
                W$esi = &IMAGE_FILE_MACHINE_SH5, W$esi = &IMAGE_FILE_MACHINE_SH3DSP,
                W$esi = &IMAGE_FILE_MACHINE_THUMB, W$esi = &IMAGE_FILE_MACHINE_WCEMIPSV2,
                W$esi = &IMAGE_FILE_MACHINE_AM33, W$esi = &IMAGE_FILE_MACHINE_AMD64,
                W$esi = &IMAGE_FILE_MACHINE_CEE, W$esi = &IMAGE_FILE_MACHINE_EBC,
                W$esi = &IMAGE_FILE_MACHINE_M32R, W$esi = &IMAGE_FILE_MACHINE_POWERPCFP,
                W$esi = &IMAGE_FILE_MACHINE_TRICORE

        ; Valid .obj, if here:
        Mov D$ValidLib COFF_OBJ_FILE

    .Else_If_And B$esi = 080, W$esi+1 < 1024, W$esi+1 > 0 ; the W$esi+1 is the record lenght. The max size of the record len is 1024(The entire record, inclusind the magic signature), and it must not be 0
        ; Valid OMF .obj
        Mov D$ValidLib OMF_OBJ_FILE

    .Else_If D$esi+40 = 0474A
        ; Valid Pdb file
        Mov D$ValidLib PDB_OBJ_FILE

    .Else_If D$esi = 04944
        ; Possible dbg file found
        Mov D$ValidLib DBG_OBJ_FILE

    .Else
;;
;;
        cmp B$esi 0F0; LibHdr
        jnz @TestFileType2
        
            Mov eax eax
        @TestFileType2: ; Object File Found

        cmp B$esi 080; THEADDR ; Object OMF Sig
        jz @TestFileType3
        cmp B$esi 082; LHEADDR ; Library OMF Sig (Microsoft)
        jnz @TestFileType4

        @TestFileType3:
            movzx eax B$esi+2
            inc esi
            movzx eax B$esi+1 ; The Record length is a word, but the Low order must be 0, because the lenght must be only 255 bytes long
            movzx ecx al
            
@TestFileType4: ; Not OMF
;;
;;
        Mov D$ValidLib UNKNOWN_LIB_FILE
    .End_If
    popad
EndP
____________________________________________________________________________________________

; All Identified Libs and Objects are identified by this function.

Proc ParseIdentifiedLibs:
    Arguments @hwnd
    pushad

    Mov esi D$LibFileMemory

    .If D$ValidLib = COFF_LIB_FILE
        Call WriteObjectTypeinTitle D@hwnd, {B$ "Library COFF" EOS}
        Call CoffLibFound
        Call GetLibListing D@hwnd, hLibReportEdit, hLibReportEditLength

    .Else_If D$ValidLib = COFF_OBJ_FILE
         Call WriteObjectTypeinTitle D@hwnd, {B$ "Object COFF" EOS}
         Call GetOneCoffListing D@hwnd, hLibReportEdit, hLibReportEditLength


    .Else_If D$ValidLib = DCU1_KILYX_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        Call LibScanDialog_EnableContinueMenu &FALSE
        Call WriteObjectTypeinTitle D@hwnd, {B$ "Delphi Kilyx 1" EOS}
        Call 'USER32.MessageBoxA' D@hwnd, {B$ "Delphi Kilyx 1 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet." EOS}, {B$ 'LibScan' EOS},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU2_KILYX_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        Call LibScanDialog_EnableContinueMenu &FALSE
        Call WriteObjectTypeinTitle D@hwnd, {B$ "Delphi Kilyx 2" EOS}
        Call 'USER32.MessageBoxA' D@hwnd, {B$ "Delphi Kilyx2 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet." EOS}, {B$ 'LibScan' EOS},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU3_KILYX_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        Call LibScanDialog_EnableContinueMenu &FALSE
        Call WriteObjectTypeinTitle D@hwnd, {B$ "Delphi Kilyx 3" EOS}
        Call 'USER32.MessageBoxA' D@hwnd, {B$ "Delphi Kilyx3 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet." EOS}, {B$ 'LibScan' EOS},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU2_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        Call LibScanDialog_EnableContinueMenu &FALSE
        Call WriteObjectTypeinTitle D@hwnd, {B$ "Delphi 2" EOS}
        Call 'USER32.MessageBoxA' D@hwnd, {B$ "Delphi 2 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet." EOS}, {B$ 'LibScan' EOS},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU3_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        Call LibScanDialog_EnableContinueMenu &FALSE
        Call WriteObjectTypeinTitle D@hwnd, {B$ "Delphi 3" EOS}
        Call 'USER32.MessageBoxA' D@hwnd, {B$ "Delphi 3 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet." EOS}, {B$ 'LibScan' EOS},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU4_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        Call LibScanDialog_EnableContinueMenu &FALSE
        Call WriteObjectTypeinTitle D@hwnd, {B$ "Delphi 4" EOS}
        Call 'USER32.MessageBoxA' D@hwnd, {B$ "Delphi 4 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet." EOS}, {B$ 'LibScan' EOS},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU5_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        Call LibScanDialog_EnableContinueMenu &FALSE
        Call WriteObjectTypeinTitle D@hwnd, {B$ "Delphi 5" EOS}
        Call 'USER32.MessageBoxA' D@hwnd, {B$ "Delphi 5 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet." EOS}, {B$ 'LibScan' EOS},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU6_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        Call LibScanDialog_EnableContinueMenu &FALSE
        Call WriteObjectTypeinTitle D@hwnd, {B$ "Delphi 6" EOS}
        Call 'USER32.MessageBoxA' D@hwnd, {B$ "Delphi 6 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet." EOS}, {B$ 'LibScan' EOS},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU7_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        Call LibScanDialog_EnableContinueMenu &FALSE
        Call WriteObjectTypeinTitle D@hwnd, {B$ "Delphi 7" EOS}
        Call 'USER32.MessageBoxA' D@hwnd, {B$ "Delphi 7 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet." EOS}, {B$ 'LibScan' EOS},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = OMF_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        Call LibScanDialog_EnableContinueMenu &FALSE
        Call WriteObjectTypeinTitle D@hwnd, {B$ "OMF Object" EOS}
        Call 'USER32.MessageBoxA' D@hwnd, {B$ "Object Module Format (OMF) Signature was Found..", D$ CRLF2, B$ "Sorry, but OMF objects are not handled by this dumper yet." EOS}, {B$ 'LibScan' EOS},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = PDB_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        Call LibScanDialog_EnableContinueMenu &FALSE
        Call WriteObjectTypeinTitle D@hwnd, {B$ "Pdb File" EOS}
        Call 'USER32.MessageBoxA' D@hwnd, {B$ "Program DataBase (Pdb) Signature was Found..", D$ CRLF2, B$ "Sorry, but PDB files are not handled by this dumper yet." EOS}, {B$ 'LibScan' EOS},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DBG_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        Call LibScanDialog_EnableContinueMenu &FALSE
        Call WriteObjectTypeinTitle D@hwnd, {B$ "Dbg File" EOS}
        Call 'USER32.MessageBoxA' D@hwnd, {B$ "Degug Format (dbg) Signature was Found..", D$ CRLF2, B$ "Sorry, but dbg files are not handled by this dumper yet." EOS}, {B$ 'LibScan' EOS},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .End_If
    popad
EndP
____________________________________________________________________________________________

Proc CoffLibFound:

  ; Tag:
    add esi 8
   ____________________________________________
  ; First Lib Header:
    If W$esi = '/ '
        Push esi
            lea esi D$esi+48 | Call GetMemberSize
        Pop esi
        add esi 03C | add esi eax | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Second Optional Lib Header:
    If W$esi = '/ '
        Push esi
            lea esi D$esi+48 | Call GetMemberSize
        Pop esi
        add esi 03C | add esi eax | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Third optional Lib Header:
    If W$esi = '//'
        Push esi
            lea esi D$esi+48 | Call GetMemberSize
        Pop esi
        add esi 03C | add esi eax | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Coff Files:
L5: Call InitCoffIndice
;;
;;
  We overwrite the "UserID", at +28. We will use this Ordinal to build Synthetic
  Labels (in replacement of the real Names), to save from Duplications, when we
  recompie the output, with RosAsm, for testing the validity of the Rendering
  (Asm Source Form version).

;;
;;
    While B$esi <> 0
        Mov eax D$LibObjIndice, D$esi+LIB_USER_ID eax
        Mov ax W$LibObjIndice+4, W$esi+LIB_USER_ID+4 ax

        Call IncrementLibCoffIndice

        Push esi
            lea esi D$esi+LIB_MEMBER_SIZE
            Call GetMemberSize
        Pop esi

        add esi COFF_HEADER_SIZE | add esi D$MemberSize
        On esi >= D$LibFileMemoryEnd, ExitP
        On B$esi = 0A, inc esi
    End_While

EndP

;;
;;
Proc LibCoffMarking:

  ; Valid Tag?
    Mov esi D$LibFileMemory

    .If D$esi+2 = 'arch'
        ; Valid .lib
        Mov D$ValidLib COFF_LIB_FILE

    .Else
        Call IsIMAGE_FILE_MACHINE D$esi

        If eax = &TRUE
          ; Valid .obj, if here:
            Mov D$ValidLib COFF_OBJ_FILE | ExitP

        Else
            Call 'USER32.MessageBoxA' 0, {B$ "The 'arch' Magic Signature Tag was not found.", D$ CRLF2, B$ "This is not a COFF Object File" EOS}, {B$ 'LibScan' EOS},
                                      &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL
            Mov D$ValidLib UNKNOWN_LIB_FILE | ExitP
        End_If

    .End_If
   ____________________________________________
  ; Tag:
    add esi 8
   ____________________________________________
  ; First Lib Header:
    If W$esi = '/ '
        Push esi
            lea esi D$esi+48 | Call GetMemberSize
        Pop esi
        add esi 03C | add esi eax | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Second Optional Lib Header:
    If W$esi = '/ '
        Push esi
            lea esi D$esi+48 | Call GetMemberSize
        Pop esi
        add esi 03C | add esi eax | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Third optional Lib Header:
    If W$esi = '//'
        Push esi
            lea esi D$esi+48 | Call GetMemberSize
        Pop esi
        add esi 03C | add esi eax | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Coff Files:
L5: Call InitCoffIndice

;  We overwrite the "UserID", at +28. We will use this Ordinal to build Synthetic
 ; Labels (in replacement of the real Names), to save from Duplications, when we
  ;recompie the output, with RosAsm, for testing the validity of the Rendering
;  (Asm Source Form version).

    While B$esi <> 0
        Mov eax D$LibObjIndice, D$esi+LIB_USER_ID eax
        Mov ax W$LibObjIndice+4, W$esi+LIB_USER_ID+4 ax

        Call IncrementLibCoffIndice

        Push esi
            lea esi D$esi+LIB_MEMBER_SIZE
            Call GetMemberSize
        Pop esi

        add esi COFF_HEADER_SIZE | add esi D$MemberSize
        On esi >= D$LibFileMemoryEnd, ExitP
        On B$esi = 0A, inc esi
    End_While

EndP

;;

____________________________________________________________________________________________
;;
  To save from Duplications, the Ordinal Coff Indice are stored inside each Heasder
  upon the LIB_USER_ID.
  
  Before writing each Names, we Call for 'CopyCoffIndice'.
;;
;;
CopyCoffIndice:
    Mov D$edi 'Obj_'
    Mov eax D$esi+LIB_USER_ID, D$edi+4 eax,
        ax W$esi+LIB_USER_ID+4, W$edi+8 ax,
        D$edi+10 ' ; '
    add edi 13
ret

____________________________________________________________________________________________

;[@LibHexaMem: D$ ?    @COFFnumber: D$ ?    @Base: D$ ?]
Proc GetLibListing:
    Argument @hwnd, @OutPut, @OutputSize

    pushad

        On D$LookUpValidNameCharsTable = 0, Call InitLookUpValidNameCharsTable

        ; The Parsed Data will be stored in edi
        Mov edi D@OutPut

        Mov ecx D$LibFileLength | shl ecx 6

        Call VirtualAlloc edi,
                          ecx

        Call GetLongNamesBase

        Mov esi D$LibFileMemory, edi D$edi

        ____________________________________________
        ; RosAsm Notice
        Mov esi WriteNotice | While B$esi <> 0 | movsb | End_While
        ____________________________________________
        ; Tag:
        Call WriteLibTag

        Mov D$ARCHIVE_MEMBER_HEADER_Indice '0000', W$ARCHIVE_MEMBER_HEADER_Indice+4 '01'
       ____________________________________________
      ; First Lib Header:
        If W$esi = '/ '
            Call Write_IMAGE_ARCHIVE_MEMBER_HEADER_1
          ; First Lib Member:
            Push esi
                Call WriteHeaderMember1
            Pop esi
            add esi D$MemberSize | On B$esi = 0A, inc esi
        End_If
       ____________________________________________
      ; Second optional Lib Header:
        If W$esi = '/ '
            Call WriteSecondLibHeaderComment
            Call Write_IMAGE_ARCHIVE_MEMBER_HEADER_2
            Push esi
                Call WriteHeaderMember2
            Pop esi
            add esi D$MemberSize | On B$esi = 0A, inc esi
        End_If
       ____________________________________________
      ; Third optional Lib Header:
        If W$esi = '//'

            Call WriteThirdLibHeaderComment

            Call GetLongNamesPointer
            Call Write_IMAGE_ARCHIVE_MEMBER_HEADER_3
            Push esi
                Call WriteHeaderMember3
            Pop esi
            add esi D$MemberSize | On B$esi = 0A, inc esi
        End_If
       ____________________________________________
      ; Coff Files:
        Push esi
            Mov esi CoffComment
            While B$esi <> 0 | movsb | End_While
        Pop esi

        Call InitCoffIndice

        sub D$LibFileMemoryEnd 20

        While esi < D$LibFileMemoryEnd
            Call WriteCoffTitle
            Call Write_Obj_IMAGE_ARCHIVE_MEMBER_HEADER
            Call ParseLibObj
            ; To be used in the listview control
            Call AddListviewItem, D$H.List

            add esi D$MemberSize | On esi >= D$LibFileMemoryEnd, jmp L2>
            On B$esi = 0A, inc esi
            Call IncrementLibCoffIndice

        End_While

L2:
        ; The Parsed Data, must be displayed in the edit box
        Mov eax D@OutPut    ;   Initial Address of the parsed data
        Mov eax D$eax       ;   eax is now at the start of the address

        Call 'USER32.SetDlgItemTextA' D$H.TabDlg1, IDC_LIB_SOURCE, eax

        ; Computed and store the outputed size of the Parsed Data displayed in the edit control
        Mov eax D@OutputSize
        Mov ecx D@OutPut
        Mov ecx D$ecx
        sub edi ecx
        Mov D$eax edi

    popad

EndP

_________________________________________________________________________________________________

[hLibReportEdit: D$ ?];    @COFFnumber: D$ ?    @Base: D$ ?]
[hLibReportEditLength: D$ 0]

Proc GetOneCoffListing:
    Argument @hwnd, @OutPut, @OutputSize

    pushad

    ; The Parsed Data will be stored in edi
    Mov edi D@OutPut

    Call InitCoffIndice

    Mov ecx D$LibFileLength | shl ecx 6

    Call VirtualAlloc edi,
                      ecx

    Mov esi D$LibFileMemory, edi D$edi

    ____________________________________________
    ; RosAsm Notice
    Push esi
    Mov esi WriteNotice | While B$esi <> 0 | movsb | End_While
    Pop esi

    Call ParseLibObj

    Call ParseOpenedFilePath LibSaveFilter

    Move D$MemberSize D$LibFileLength
    Call AddListviewItem, D$H.List

    ; The Parsed Data, must be displayed in the edit box
    Mov eax D@OutPut    ;   Initial Address of the parsed data
    Mov eax D$eax       ;   eax is now at the start of the address
    Call 'USER32.SetDlgItemTextA' D$H.TabDlg1 , IDC_LIB_SOURCE, eax; SHOW ALL Parsed Data in the 1st Tab dialog...

    ; Computed and store the outpued size of the Parsed Data displayed in the edit control
    Mov eax D@OutputSize
    Mov ecx D@OutPut
    Mov ecx D$ecx
    sub edi ecx
    Mov D$eax edi

    popad
EndP

_________________________________________________________________________________________________

; This function is to be used for displaying the object file name in the list view

; Built this way to solve really weird file namings paths. This is similar to ParseLibObjectSymbolName


Proc ParseOpenedFilePath:
    Arguments @StartAddress
    Local @TempEndAddr, @TempStartAddr, @StartExportObjAddr, @EndObjPathAddr, @StartObjExtensionAddr, @UseExportedLibrary

    pushad

    ; Always clear the loaded data before use.
    Call ClearDwordBuffer ObjectName,
                          (256/DWORD)
    
    Call ClearDwordBuffer ObjExtensionStr,
                          (16/DWORD)
    
    Call ClearDwordBuffer ObjPathStr,
                          (256/DWORD)

    ; Initialize all the data
    Mov D$ObjFileNameType 0
    Mov D$UseObjPath 0
    Mov D$UseObjExtension 0
    Mov D@TempStartAddr 0
    Mov D@TempEndAddr 0
    Mov D@StartExportObjAddr 0
    Mov D@UseExportedLibrary 0

    Mov esi D@StartAddress

    While B$esi <> 0
        inc esi
    End_While
    Mov D@TempEndAddr esi

    ; 1st Step. Now that we have our full string, we need to see if it have any path inside.
    ; We must start from the end to the beginning of the string to find the path chars.
    Mov esi D@StartAddress
    Mov ecx D@TempEndAddr

    .While esi <> ecx

        If_Or B$ecx = '/', B$ecx = '\'

            Mov D@EndObjPathAddr ecx
            Mov D$UseObjPath 1
            jmp L1>
        End_If

        dec ecx
    .End_While

   L1:

    ; 2nd Step. If we have a Path, we will copy it to the proper Buffer (ObjPathStr)

    .If D$UseObjPath = 1
        ; Here esi is already defined as the starting point. We don't need to change it now.
        Mov ecx D@EndObjPathAddr
        Mov edi ObjPathStr

        .While esi <> ecx
            movsb
            ;inc esi
        .End_While
        inc esi ; Bypass the last "/" or "\" char preceeding the object name.
        Mov D@StartAddress esi ; Will points to the beginning of the object name only

    .End_If


    ; 3rd Step. Chekc the file name Type. If the len of the object name is equal or bigger then 16 bytes, it is a LongName.
    ; Otherwise it is short name.

    Mov eax D@TempEndAddr
    sub eax D@StartAddress

    If eax <= 16
        Mov D$ObjFileNameType 0
    Else
        Mov D$ObjFileNameType 1
    End_If



    ; 4th Step. At this point we have only the name of the object and it's extension (if any).
    ; So we must find and copy the object extension.

    Mov esi D@StartAddress
    Mov ecx D@TempEndAddr
    Mov edi ObjectName

    .Do

        .If B$esi = '.'
            Mov D$UseObjExtension 1
            Mov edi ObjExtensionStr
            inc esi ; Bypass the "." char
            While esi <> ecx
                movsb
            End_While
            jmp L2>
        .End_If

        movsb
    .Loop_Until esi = ecx

   L2:

    popad
EndP

_________________________________________________________________________________________________


[CoffListingTitle: B$ "
; -------------------- Coff Listing: -------------------------

[IMAGE_FILE_HEADER_" EOS]

[ObjMachineText: B$ 'Machine: W$ ' EOS]
[ObjNumberOfSectionsText: B$ 'NumberOfSections: W$ ' EOS]
[ObjTimeDateStampText: B$ 'TimeDateStamp: D$ ' EOS]
[ObjPointerToSymbolTableText: B$ 'PointerToSymbolTable: D$ ' EOS]
[ObjPbjNumberOfSymbolsText: B$ 'NumberOfSymbols: D$ ' EOS]
[ObjSizeOfOptionalHeaderText: B$ 'SizeOfOptionalHeader: W$ ' EOS]
[ObjCharacteristicsText: B$ 'Characteristics: W$ ' EOS]
[SymbolTableText: B$ 'ImgSym000001 - IMAGE_FILE_HEADER_' EOS]



[SizeOfOptionalHeaderInObj: D$ ?
 ObjNumberOfSections: D$ ?
 FirstSectionPointer: D$ ?]

GetCoffIMAGE_FILE_HEADER:
    Push esi
        Mov esi CoffListingTitle
        While B$esi <> 0 | movsb | End_While
        Call WriteIndiceOnly
        Mov B$edi ':', W$edi+1 CRLF | add edi 3
    Pop esi

    ; To be used in AddListviewItem
    Push esi
        Mov D$LvOffsetCOFF 0 ; always initialize at 0 1st, due to the several loopings for each object.
        sub esi D$LibFileMemory
        Mov D$LvOffsetCOFF esi
    Pop esi

    Call WriteLibImportObjItem ObjMachineText, &FALSE | sub edi 2
        ; To be used in AddListviewItem
        Mov W$CoffMachineType 0 ; always initialize at 0 1st, due to the several loopings for each object.
        Move W$CoffMachineType W$esi
    Call Write_IMAGE_FILE_MACHINE D$esi | Mov W$edi CRLF | add edi 2

    add esi 2 | movzx eax W$esi | Mov D$ObjNumberOfSections eax

    Call WriteLibImportObjItem ObjNumberOfSectionsText, &TRUE

    add esi 2 | Mov eax D$esi
    Call WriteLibImportObjItem ObjTimeDateStampText, &TRUE
    Call WriteLinkerMemberTimeDateStamp D$esi

    add esi 4 | Mov eax D$esi
    Mov D$CoffSymbolsPointer eax ; To be used in WriteImageSymbolTable
    Call WriteLibImportObjItem ObjPointerToSymbolTableText, &FALSE | sub edi 2

    If eax <> 0
        Call WriteLibImportObjItem SymbolTableText, &FALSE | sub edi 2
        Call WriteIndiceOnly
        Push esi
            Mov esi {B$ ' ; Hex Value:  ' EOS}
            While B$esi <> 0 | movsb | End_While
        Pop esi
    End_If

    Call Writeeax | Mov W$edi CRLF | add edi 2 ; Write the Value of the SymbolTable Pointer in Hexadecimal string


    add esi 4 | Mov eax D$esi
    Mov D$CoffSymbolsNumber eax ; To be used in WriteImageSymbolTable
    Mov D$ObjSymbolsNumber eax ; To be used in AddListviewItem
    Call WriteLibImportObjItem ObjPbjNumberOfSymbolsText, &TRUE

    add esi 4 | movzx eax W$esi | Mov D$SizeOfOptionalHeaderInObj eax
    Call WriteLibImportObjItem ObjSizeOfOptionalHeaderText, &TRUE

    add esi 2 | movzx eax W$esi
    Call WriteLibImportObjItem ObjCharacteristicsText, &TRUE | sub edi 2
    movzx eax W$esi
    If eax <> 0
        Call WriteObjCharacteristics
    End_If

    Mov W$edi CRLF
    Mov B$edi+2 ']'
    Mov D$edi+3 CRLF2 | add edi 7

    add esi 2
ret


[CoffListingIMAGE_OPTIONAL_HEADERTitle: B$ "[IMAGE_OPTIONAL_HEADER_" EOS

 ImgOptHdr.Magic: W$'ImgOptHdr.Magic: W$ ' EOS ; !!! W$ -> U$...
 ImgOptHdr.MajorLinkerVersion: 'ImgOptHdr.MajorLinkerVersion: B$ ' EOS
 ImgOptHdr.MinorLinkerVersion: 'ImgOptHdr.MinorLinkerVersion: B$ ' EOS
 ImgOptHdr.SizeOfCode: 'ImgOptHdr.SizeOfCode: D$ ' EOS
 ImgOptHdr.SizeOfInitializedData: 'ImgOptHdr.SizeOfInitializedData: D$ ' EOS
 ImgOptHdr.SizeOfUninitializedData: 'ImgOptHdr.SizeOfUninitializedData: D$ ' EOS
 ImgOptHdr.AddressOfEntryPoint: 'ImgOptHdr.AddressOfEntryPoint: D$ ' EOS
 ImgOptHdr.BaseOfCode: 'ImgOptHdr.BaseOfCode: D$ ' EOS
 ImgOptHdr.BaseOfData: 'ImgOptHdr.BaseOfData: D$ ' EOS
 ImgOptHdr.ImageBase: 'ImgOptHdr.ImageBase: D$ ' EOS
 ImgOptHdr.SectionAlignment: 'ImgOptHdr.SectionAlignment: D$ ' EOS
 ImgOptHdr.FileAlignment: 'ImgOptHdr.FileAlignment: D$ ' EOS
 ImgOptHdr.MajorOperatingSystemVersion: 'ImgOptHdr.MajorOperatingSystemVersion: W$ ' EOS
 ImgOptHdr.MinorOperatingSystemVersion: 'ImgOptHdr.MinorOperatingSystemVersion: W$ ' EOS
 ImgOptHdr.MajorImageVersion: 'ImgOptHdr.MajorImageVersion: W$ ' EOS
 ImgOptHdr.MinorImageVersion: 'ImgOptHdr.MinorImageVersion: W$ ' EOS
 ImgOptHdr.MajorSubsystemVersion: 'ImgOptHdr.MajorSubsystemVersion: W$ ' EOS
 ImgOptHdr.MinorSubsystemVersion: 'ImgOptHdr.MinorSubsystemVersion: W$ ' EOS
 ImgOptHdr.Win32VersionValue: 'ImgOptHdr.Win32VersionValue: D$ ' EOS
 ImgOptHdr.SizeOfImage: 'ImgOptHdr.SizeOfImage: D$ ' EOS
 ImgOptHdr.SizeOfHeaders: 'ImgOptHdr.SizeOfHeaders: D$ ' EOS
 ImgOptHdr.CheckSum: 'ImgOptHdr.CheckSum: D$ ' EOS
 ImgOptHdr.Subsystem: 'ImgOptHdr.Subsystem: W$ ' EOS
 ImgOptHdr.DllCharacteristics: 'ImgOptHdr.DllCharacteristics: W$ ' EOS
 ImgOptHdr.SizeOfStackReserve: 'ImgOptHdr.SizeOfStackReserve: D$ ' EOS
 ImgOptHdr.SizeOfStackCommit: 'ImgOptHdr.SizeOfStackCommit: D$ ' EOS
 ImgOptHdr.SizeOfHeapReserve: 'ImgOptHdr.SizeOfHeapReserve: D$ ' EOS
 ImgOptHdr.SizeOfHeapCommit: 'ImgOptHdr.SizeOfHeapCommit: D$ ' EOS
 ImgOptHdr.LoaderFlags: 'ImgOptHdr.LoaderFlags: D$ ' EOS
 ImgOptHdr.NumberOfRvaAndSizes: 'ImgOptHdr.NumberOfRvaAndSizes: D$ ' EOS

 ImgDataDir.Export: 'ImgDataDir.Export: D$ ' EOS
 ImgDataDir.ExportSize: 'ImgDataDir.ExportSize: D$ ' EOS
 ImgDataDir.Import: 'ImgDataDir.Import: D$ ' EOS
 ImgDataDir.ImportSize: 'ImgDataDir.ImportSize: D$ ' EOS
 ImgDataDir.Resource: 'ImgDataDir.Resource: D$ ' EOS
 ImgDataDir.ResourceSize: 'ImgDataDir.ResourceSize: D$ ' EOS
 ImgDataDir.Exception: 'ImgDataDir.Exception: D$ ' EOS
 ImgDataDir.ExceptionSize: 'ImgDataDir.ExceptionSize: D$ ' EOS
 ImgDataDir.Certificate: 'ImgDataDir.Certificate: D$ ' EOS
 ImgDataDir.CertificateSize: 'ImgDataDir.CertificateSize: D$ ' EOS
 ImgDataDir.Relocation: 'ImgDataDir.Relocation: D$ ' EOS
 ImgDataDir.RelocationSize: 'ImgDataDir.RelocationSize: D$ ' EOS
 ImgDataDir.Debug: 'ImgDataDir.Debug: DebugDir: D$ ' EOS
 ImgDataDir.DebugSize: 'ImgDataDir.DebugSize: D$ ' EOS
 ImgDataDir.Architecture: 'ImgDataDir.Architecture: D$ ' EOS
 ImgDataDir.ArchitectureSize: 'ImgDataDir.ArchitectureSize: D$ ' EOS
 ImgDataDir.GPReg: 'ImgDataDir.GPReg: D$ ' EOS
 ImgDataDir.GPRegSize: 'ImgDataDir.GPRegSize: D$ ' EOS
 ImgDataDir.Thread: 'ImgDataDir.Thread: D$ ' EOS
 ImgDataDir.ThreadSize: 'ImgDataDir.ThreadSize: D$ ' EOS
 ImgDataDir.ConfigTable: 'ImgDataDir.ConfigTable: D$ ' EOS
 ImgDataDir.ConfigTableSize: 'ImgDataDir.ConfigTableSize: D$ ' EOS
 ImgDataDir.BoundIAT: 'ImgDataDir.BoundIAT: D$ ' EOS
 ImgDataDir.BoundIATSize: 'ImgDataDir.BoundIATSize: D$ ' EOS
 ImgDataDir.IAT: 'ImgDataDir.IAT: D$ ' EOS
 ImgDataDir.IATSize: 'ImgDataDir.IATSize: D$ ' EOS
 ImgDataDir.DelayID: 'ImgDataDir.DelayID: D$ ' EOS
 ImgDataDir.DelayIDSize: 'ImgDataDir.DelayIDSize: D$ ' EOS
 ImgDataDir.COM: 'ImgDataDir.COM: D$ ' EOS
 ImgDataDir.COMSize: 'ImgDataDir.COMSize: D$ ' EOS
 ImgDataDir.Reserved: 'ImgDataDir.Reserved: D$ ' EOS
 ImgDataDir.ReservedSize: 'ImgDataDir.ReservedSize: D$ ' EOS]

[IMAGE_DATA_DIRECTORY_Title: B$ '; ---- IMAGE_DATA_DIRECTORY ----' EOS]


Write_IMAGE_DATA_DIRECTORY_Title:
    
    Mov W$edi CRLF | add edi 2

    Push esi | Mov esi IMAGE_DATA_DIRECTORY_Title | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi
                 
    Mov D$edi CRLF2 | add edi 4

ret


WriteObjMagic:
    Push esi
        If eax = &IMAGE_NT_OPTIONAL_HDR32_MAGIC

            Push esi | Mov esi {B$ ' ; &IMAGE_NT_OPTIONAL_HDR32_MAGIC' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Else_If eax = &IMAGE_NT_OPTIONAL_HDR64_MAGIC

            Push esi | Mov esi {B$ ' ; &IMAGE_NT_OPTIONAL_HDR64_MAGIC' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Else

            Push esi | Mov esi {B$ ' ; Likely corrupted unknown Magic Value' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        End_If
    Pop esi

    Mov W$edi CRLF | add edi 2
ret


WriteObjSubSystem:
    Push esi
        .If eax = &IMAGE_SUBSYSTEM_UNKNOWN
 
            Push esi | Mov esi {B$ ' ; &IMAGE_SUBSYSTEM_UNKNOWN' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SUBSYSTEM_NATIVE
  
            Push esi | Mov esi {B$ ' ; &IMAGE_SUBSYSTEM_NATIVE' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SUBSYSTEM_WINDOWS_GUI
 
            Push esi | Mov esi {B$ ' ; &IMAGE_SUBSYSTEM_WINDOWS_GUI' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SUBSYSTEM_WINDOWS_CUI
 
            Push esi | Mov esi {B$ ' ; &IMAGE_SUBSYSTEM_WINDOWS_CUI' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SUBSYSTEM_OS2_CUI
 
            Push esi | Mov esi {B$ ' ; &IMAGE_SUBSYSTEM_OS2_CUI' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SUBSYSTEM_POSIX_CUI
 
            Push esi | Mov esi {B$ ' ; &IMAGE_SUBSYSTEM_POSIX_CUI' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SUBSYSTEM_WINDOWS_CE_GUI
 
            Push esi | Mov esi {B$ ' ; &IMAGE_SUBSYSTEM_WINDOWS_CE_GUI' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SUBSYSTEM_EFI_APPLICATION

            Push esi | Mov esi {B$ ' ; &IMAGE_SUBSYSTEM_EFI_APPLICATION' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER
 
            Push esi | Mov esi {B$ ' ; &IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER

            Push esi | Mov esi {B$ ' ; &IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SUBSYSTEM_NATIVE_WINDOWS
  
            Push esi | Mov esi {B$ ' ; &IMAGE_SUBSYSTEM_NATIVE_WINDOWS' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else

            Push esi | Mov esi {B$ ' ; Likely corrupted unknown SubSystem Record' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .End_If
    Pop esi

    Mov W$edi CRLF | add edi 2
ret


WriteDllCharacteristics:
    .If eax <> 0
        Push esi
            Mov D$edi ' ; ' | add edi 3

            test eax &IMAGE_DLLCHARACTERISTICS_PPROCESS_LIB_INIT | jz L1>
               
                Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_PPROCESS_LIB_INIT__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1:         test eax &IMAGE_DLLCHARACTERISTICS_PPROCESS_LIB_TERM | jz L1>

                Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_PPROCESS_LIB_TERM__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1:         test eax &IMAGE_DLLCHARACTERISTICS_PTHREAD_LIB_INIT | jz L1>

                Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_PTHREAD_LIB_INIT__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1:         test eax &IMAGE_DLLCHARACTERISTICS_PTHREAD_LIB_TERM | jz L1>

                Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_PTHREAD_LIB_TERM__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1:         test eax &IMAGE_DLLCHARACTERISTICS_NO_BIND | jz L1>

                Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_NO_BIND__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1:         test eax &IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE | jz L1>

                Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1:         test eax &IMAGE_DLLCHARACTERISTICS_WDM_DRIVER | jz L1>

                Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1:         While B$edi = '_' | dec edi | End_While
        Pop esi
    .End_If

    Mov W$edi CRLF | add edi 2
ret


GetCoffIMAGE_OPTIONAL_HEADER:
    Push esi
        Mov esi CoffListingIMAGE_OPTIONAL_HEADERTitle
        While B$esi <> EOS | movsb | End_While
        Call WriteIndiceOnly
        Mov B$edi ':', W$edi+1 CRLF | add edi 3
    Pop esi

    movzx eax W$esi
    Push eax
    Call WriteLibImportObjItem ImgOptHdr.Magic, &TRUE | sub edi 2
    Pop eax
    Call WriteObjMagic

    add esi 2 | movzx eax B$esi
    Call WriteLibImportObjItem ImgOptHdr.MajorLinkerVersion, &TRUE

    inc esi | movzx eax B$esi
    Call WriteLibImportObjItem ImgOptHdr.MinorLinkerVersion, &TRUE

    inc esi
    lodsd | Call WriteLibImportObjItem ImgOptHdr.SizeOfCode, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.SizeOfInitializedData, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.SizeOfUninitializedData, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.AddressOfEntryPoint, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.BaseOfCode, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.BaseOfData, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.ImageBase, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.SectionAlignment, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.FileAlignment, &TRUE

    lodsw | and eax 0FFFF
    Call WriteLibImportObjItem ImgOptHdr.MajorOperatingSystemVersion, &TRUE

    lodsw | and eax 0FFFF
    Call WriteLibImportObjItem ImgOptHdr.MinorOperatingSystemVersion, &TRUE

    lodsw | and eax 0FFFF
    Call WriteLibImportObjItem ImgOptHdr.MajorImageVersion, &TRUE

    lodsw | and eax 0FFFF
    Call WriteLibImportObjItem ImgOptHdr.MinorImageVersion, &TRUE

    lodsw | and eax 0FFFF
    Call WriteLibImportObjItem ImgOptHdr.MajorSubsystemVersion, &TRUE

    lodsw | and eax 0FFFF
    Call WriteLibImportObjItem ImgOptHdr.MinorSubsystemVersion, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.Win32VersionValue, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.SizeOfImage, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.SizeOfHeaders, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.CheckSum, &TRUE

    lodsw | and eax 0FFFF
    Push eax
    Call WriteLibImportObjItem ImgOptHdr.Subsystem, &TRUE | sub edi 2
    Pop eax
    Call WriteObjSubSystem

    lodsw | and eax 0FFFF
    Push eax
    Call WriteLibImportObjItem ImgOptHdr.DllCharacteristics, &TRUE | sub edi 2
    Pop eax
    Call WriteDllCharacteristics

    lodsd | Call WriteLibImportObjItem ImgOptHdr.SizeOfStackReserve, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.SizeOfStackCommit, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.SizeOfHeapReserve, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.SizeOfHeapCommit, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.LoaderFlags, &TRUE

    lodsd | Call WriteLibImportObjItem ImgOptHdr.NumberOfRvaAndSizes, &TRUE


    Call Write_IMAGE_DATA_DIRECTORY_Title


    lodsd | Call WriteLibImportObjItem ImgDataDir.Export, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.ExportSize, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.Import, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.ImportSize, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.Resource, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.ResourceSize, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.Exception, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.ExceptionSize, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.Certificate, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.CertificateSize, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.Relocation, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.RelocationSize, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.Debug, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.DebugSize, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.Architecture, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.ArchitectureSize, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.GPReg, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.GPRegSize, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.Thread, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.ThreadSize, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.ConfigTable, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.ConfigTableSize, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.BoundIAT, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.BoundIATSize, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.IAT, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.IATSize, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.DelayID, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.DelayIDSize, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.COM, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.COMSize, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.Reserved, &TRUE

    lodsd | Call WriteLibImportObjItem ImgDataDir.ReservedSize, &TRUE

    sub edi 2 | Mov B$edi ']', D$edi+1 CRLF2 | add edi 5

ret
____________________________________________________________________________________________



[CoffSectionHeaderTitle: "
;;

;;
_____________________________________________________

The Section Header
_____________________________________________________
_____________________________________________________

IMAGE_SECTION_HEADER Structure

;;
;;

" EOS]

[SectionHeaderNumber: B$ '001' EOS]

InitSectionHeaderNumber:
    Mov D$SectionHeaderNumber '001'
ret



IncrementSectionHeaderNumber:

    Push ebx
        lea ebx D$SectionHeaderNumber+2

        inc B$ebx
        While B$ebx > '9'
            Mov B$ebx '0' | dec ebx | inc B$ebx
        End_While
    Pop ebx
ret

[CoffSectionHeaderName: B$ 'Name1' EOS]
[CoffSectionHeaderVirtualSize: B$ 'MiscVirtualSize' EOS]
[CoffSectionHeaderRVA: B$ 'VirtualAddress' EOS]
[CoffSectionHeaderSize: B$ 'SizeOfRawData' EOS]
[CoffSectionHeaderPointerToData: B$ 'PointerToRawData' EOS]
[CoffSectionHeaderPointerToReloc: B$ 'PointerToRelocations' EOS]
[CoffSectionHeaderPointerToLinesNumbers: B$ 'PointerToLinenumbers' EOS]
[CoffSectionHeaderNumberOfRelocations: B$ 'NumberOfRelocations' EOS]
[CoffSectionHeaderNumberOfLinesNumbers: B$ 'NumberOfLinenumbers' EOS]
[CoffSectionHeaderCharacteristics: B$ 'Characteristics' EOS]

Proc WriteObjSectionHeaderItem:
    Argument @Text1, @Text2

        Push esi
            Call WriteObjIndice
           
            Mov esi {B$ 'ImgSecHdr' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0:
            Mov esi SectionHeaderNumber | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0:

            Mov B$edi '.' | inc edi
        
            Mov esi D@Text1 | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0:

            Mov esi D@Text2 | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0:

        Pop esi

        Mov eax D@Text2, al B$eax+2

        ...If al = 'B'
            Mov edx esi | add edx 8
            Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:         Mov B$edi "'" | inc edi
            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ...Else_If al = 'W'
            lodsw | and eax 0FFFF | Call WriteEax

        ...Else

            ..If D$esi <> 0
                Mov eax D@Text1

                .If D$eax = 'Size' ; from "SizeOfRawData" string

                    Call WriteSectionHeaderRawSizeDiffLabel
                    
                    Push esi | Mov esi {B$ " ; Hex Value:  " EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

                .Else_If D$eax+8 = 'oRaw'; From "PointerToRawData" string
                    ;Mov eax D$esi-4
                    If D$esi-4 = 0
                        Mov D$esi 0
                    Else

                        Call WriteSectionHeaderPointerToDataDiffLabel
                
                        Push esi | Mov esi {B$ " ; Hex Value:  " EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

                    End_If
                .Else_If D$eax+9 = 'Relo'; From "PointerToRelocations" string
                    Call InitSectionRelocNumber
                    ;movzx eax W$esi+4+4
                    ; Fix the value at esi when the Reloc Number is 0, but it is pointing somewhere
                    If W$esi+4+4 = 0
                        Mov D$esi 0
                    Else
                        Call WriteSectionHeaderPointerToRelocDiffLabel
                
                        Push esi | Mov esi {B$ " ; Hex Value:  " EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

                    End_If
                .Else_If D$eax+9 = 'Line'; From "PointerToLinenumbers" string
                    Call InitSectionLineNumber
                    ;movzx eax W$esi+4+2
                    If W$esi+4+2 = 0
                        Mov D$esi 0
                    Else
                        Call WriteSectionHeaderPointerToLineNumberDiffLabel
                        
                        Push esi | Mov esi {B$ " ; Hex Value:  " EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

                    End_If

;;
;;
                Else_If D$eax = 'Misc'; From "MiscVirtualSize" string

                    Call WriteSectionHeaderVirtualSizeDiffLabel
                    Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi
;;
;;

                .End_If

            ..End_If

            lodsd | Call WriteEax

        ...End_If

        Mov W$edi CRLF | add edi 2
EndP


WriteCharacteristicsEquates:

    If eax <> 0
        Mov D$edi ' ; ' | add edi 3
    End_If

    test eax &IMAGE_SCN_TYPE_REG | jz L1>
      
        Push esi | Mov esi {B$ '&IMAGE_SCN_TYPE_REG__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_TYPE_DSECT | jz L1>
       
        Push esi | Mov esi {B$ '&IMAGE_SCN_TYPE_DSECT__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_TYPE_NOLOAD | jz L1>
        
        Push esi | Mov esi {B$ '&IMAGE_SCN_TYPE_NOLOAD__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_TYPE_GROUP | jz L1>
        
        Push esi | Mov esi {B$ '&IMAGE_SCN_TYPE_GROUP__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_TYPE_NO_PAD | jz L1>
        
        Push esi | Mov esi {B$ '&IMAGE_SCN_TYPE_NO_PAD__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_TYPE_COPY | jz L1>
        
        Push esi | Mov esi {B$ '&IMAGE_SCN_TYPE_COPY__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_CNT_CODE | jz L1>
        
        Push esi | Mov esi {B$ '&IMAGE_SCN_CNT_CODE__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_CNT_INITIALIZED_DATA | jz L1>
        
        Push esi | Mov esi {B$ '&IMAGE_SCN_CNT_INITIALIZED_DATA__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_CNT_UNINITIALIZED_DATA | jz L1>
        
        Push esi | Mov esi {B$ '&IMAGE_SCN_CNT_UNINITIALIZED_DATA__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_LNK_OTHER | jz L1>
        
        Push esi | Mov esi {B$ '&IMAGE_SCN_LNK_OTHER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_LNK_INFO | jz L1>
        
        Push esi | Mov esi {B$ '&IMAGE_SCN_LNK_INFO__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_TYPE_OVER | jz L1>
        
        Push esi | Mov esi {B$ '&IMAGE_SCN_TYPE_OVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_LNK_REMOVE | jz L1>
        
        Push esi | Mov esi {B$ '&IMAGE_SCN_LNK_REMOVE__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_LNK_COMDAT | jz L1>
        zCopy {B$ '&IMAGE_SCN_LNK_COMDAT__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_MEM_FARDATA | jz L1>
        zCopy {B$ '&IMAGE_SCN_MEM_FARDATA__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_MEM_PURGEABLE | jz L1>
        zCopy {B$ '&IMAGE_SCN_MEM_PURGEABLE__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_MEM_16BIT | jz L1>
        zCopy {B$ '&IMAGE_SCN_MEM_16BIT__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_MEM_LOCKED | jz L1>
        zCopy {B$ '&IMAGE_SCN_MEM_LOCKED__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_MEM_PRELOAD | jz L1>
        zCopy {B$ '&IMAGE_SCN_MEM_PRELOAD__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: Mov ebx eax | and ebx 0FF_0000

    .If ebx = &IMAGE_SCN_ALIGN_1BYTES                ; 010_0000
        zCopy {B$ '&IMAGE_SCN_ALIGN_1BYTES__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If ebx = &IMAGE_SCN_ALIGN_2BYTES           ; 020_0000
        zCopy {B$ '&IMAGE_SCN_ALIGN_2BYTES__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If ebx = &IMAGE_SCN_ALIGN_4BYTES           ; 030_0000
        zCopy {B$ '&IMAGE_SCN_ALIGN_4BYTES__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If ebx = &IMAGE_SCN_ALIGN_8BYTES           ; 040_0000
        zCopy {B$ '&IMAGE_SCN_ALIGN_8BYTES__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If ebx = &IMAGE_SCN_ALIGN_16BYTES          ; 050_0000
        zCopy {B$ '&IMAGE_SCN_ALIGN_16BYTES__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If ebx = &IMAGE_SCN_ALIGN_32BYTES          ; 060_0000
        zCopy {B$ '&IMAGE_SCN_ALIGN_32BYTES__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If ebx = &IMAGE_SCN_ALIGN_64BYTES          ; 070_0000
        zCopy {B$ '&IMAGE_SCN_ALIGN_64BYTES__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If ebx = &IMAGE_SCN_ALIGN_128BYTES         ; 080_0000
        zCopy {B$ '&IMAGE_SCN_ALIGN_128BYTES__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If ebx = &IMAGE_SCN_ALIGN_256BYTES         ; 090_0000
        zCopy {B$ '&IMAGE_SCN_ALIGN_256BYTES__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If ebx = &IMAGE_SCN_ALIGN_512BYTES         ; 0A0_0000
        zCopy {B$ '&IMAGE_SCN_ALIGN_512BYTES__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If ebx = &IMAGE_SCN_ALIGN_1024BYTES        ; 0B0_0000
        zCopy {B$ '&IMAGE_SCN_ALIGN_1024BYTES__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If ebx = &IMAGE_SCN_ALIGN_2048BYTES        ; 0C0_0000
        zCopy {B$ '&IMAGE_SCN_ALIGN_2048BYTES__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If ebx = &IMAGE_SCN_ALIGN_4096BYTES        ; 0D0_0000
        zCopy {B$ '&IMAGE_SCN_ALIGN_4096BYTES__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If ebx = &IMAGE_SCN_ALIGN_8192BYTES        ; 0E0_0000
        zCopy {B$ '&IMAGE_SCN_ALIGN_8192BYTES__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .End_If

L1: test eax &IMAGE_SCN_LNK_NRELOC_OVFL | jz L1>
        zCopy {B$ '&IMAGE_SCN_LNK_NRELOC_OVFL__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_MEM_DISCARDABLE | jz L1>
        zCopy {B$ '&IMAGE_SCN_MEM_DISCARDABLE__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_MEM_NOT_CACHED | jz L1>
        zCopy {B$ '&IMAGE_SCN_MEM_NOT_CACHED__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_MEM_NOT_PAGED | jz L1>
        zCopy {B$ '&IMAGE_SCN_MEM_NOT_PAGED__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_MEM_SHARED | jz L1>
        zCopy {B$ '&IMAGE_SCN_MEM_SHARED__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_MEM_EXECUTE | jz L1>
        zCopy {B$ '&IMAGE_SCN_MEM_EXECUTE__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_MEM_READ | jz L1>
        zCopy {B$ '&IMAGE_SCN_MEM_READ__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1: test eax &IMAGE_SCN_MEM_WRITE | jz L1>
        zCopy {B$ '&IMAGE_SCN_MEM_WRITE__' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

L1:

    While B$edi-1 = '_' | dec edi | End_While
ret



____________________________________________________________________________________________

[MemberName1Offset: D$ ?]

Proc GetName1Offset:
    pushad
        ; edi  is used as a Byte Counter
        Mov edi 8 ; Size of the Name1 member
        inc esi ; ByPass the 1st '/'
        Mov ecx 10, ebx 0, eax 0

        Do
            On B$esi = 0, jmp L0> ; If we reach 0 jmp over
            On B$esi = SPC, jmp L0> ; If we reach SPC jmp over
            mul ecx
            Push eax
                lodsb | sub al '0' | Mov bl al
            Pop eax
            add eax ebx
            dec edi
        Loop_Until edi = 0

L0:

        Mov D$MemberName1Offset eax

    popad
EndP

____________________________________________________________________________________________



Proc WriteSectionNameStringTablePointerComment:
    Uses esi, eax, edx


    ; Initialize the String Record Counter
    Call InitStringTableRecord

    ; eax is pointing to the Offset of the String on the String Table
    Mov eax D$MemberName1Offset
    Mov edx D$PointerToStringTable
    Mov esi edx ; esi is pointing to the Beginning of the String Table
    add edx eax ; edx will be using as a counter of the total amount of strings untill we reach the String where we are.
    add esi 4   ; Bypass the String Table Size. and Point to the beginning of the 1st String

    .Do

        While B$esi <> 0 | inc esi | End_While | inc esi | On B$esi = 0, Mov edx 0

        Call IncrementStringTableRecord

    .Loop_Until esi >= edx


        Push esi
            Call WriteObjIndice
            zCopy {B$ 'StringData' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy StringTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi


    ; Restore the Value of StringTableRecord

    Call InitStringTableRecord


EndP

___________________________________________

[SectionNameIndirectMessage: B$ "________________________________________________________________________

; Section Name indirectly addressed in Name1 member.
; The name of the Section is: " EOS]


Proc WriteIndirectSectionName:
    Uses esi

        Call GetName1Offset ; convert the Offset to hexadecimal
        Call GetStringTablePointer

        ;zCopy SymbolTableTitle
        Mov esi D$CoffSectionBase
        add esi D$CoffSymbolsPointer

        Push esi
            zCopy SectionNameIndirectMessage
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi

            Mov ecx D$PointerToStringTable

        Push esi
            add ecx D$MemberName1Offset | Mov esi ecx
            While B$esi <> 0 | movsb | End_While
        Pop esi

        Push esi
            zCopy {W$ CRLF, B$ "; Referenced in String Table data at: " EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Call WriteSectionNameStringTablePointerComment
            zCopy {W$ CRLF, B$ "________________________________________________________________________", D$ CRLF2 0}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi

EndP

___________________________________________________
;;
;;

Section Name    Content                     Characteristics
.arch           Alpha architecture info     &IMAGE_SCN_MEM_READ__&IMAGE_SCN_CNT_INITIALIZED_DATA (...) &IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_DISCARDABLE
.bss            Uninitialized data          &IMAGE_SCN_CNT_UNINITIALIZED_DATA__&IMAGE_SCN_MEM_READ (...) &IMAGE_SCN_MEM_WRITE
.data           Initialized data            &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ (...) &IMAGE_SCN_MEM_WRITE
.edata          Export tables               &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ
.idata          Import tables               &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.pdata          Exception information       &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ
.rdata          Read-only initialized data  &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ
.reloc          Image relocations           &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ (...) &IMAGE_SCN_MEM_DISCARDABLE
.rsrc           Resource directory          &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ (...) &IMAGE_SCN_MEM_WRITE
.text           Executable code             &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_MEM_EXECUTE (...) &IMAGE_SCN_MEM_READ
.tls            Thread-local storage        &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ (...) &IMAGE_SCN_MEM_WRITE
.xdata          Exception information       &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ


&IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE = 0E0000040

&IMAGE_SCN_CNT_UNINITIALIZED_DATA__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE = 0E0000080

Some common Names and their Flag values:

.bss C0300080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.bss C0301080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.bss C0400080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.bss C0401080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.bss C0500080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA__&IMAGE_SCN_ALIGN_16BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.CRT C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.data C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.data C0301040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.data C0400040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.data C0401040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.data C0500040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_16BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.debug 42000048 &IMAGE_SCN_TYPE_NO_PAD__&IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_DISCARDABLE__&IMAGE_SCN_MEM_READ
.debug 42100040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_1BYTES__&IMAGE_SCN_MEM_DISCARDABLE__&IMAGE_SCN_MEM_READ
.debug 42100048 &IMAGE_SCN_TYPE_NO_PAD__&IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_1BYTES__&IMAGE_SCN_MEM_DISCARDABLE__&IMAGE_SCN_MEM_READ
.debug 42101040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_1BYTES__&IMAGE_SCN_MEM_DISCARDABLE__&IMAGE_SCN_MEM_READ
.debug 42101048 &IMAGE_SCN_TYPE_NO_PAD__&IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_1BYTES__&IMAGE_SCN_MEM_DISCARDABLE__&IMAGE_SCN_MEM_READ
.debug 42400048 &IMAGE_SCN_TYPE_NO_PAD__&IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_DISCARDABLE__&IMAGE_SCN_MEM_READ
.drectve 100A00 &IMAGE_SCN_LNK_INFO__&IMAGE_SCN_LNK_REMOVE__&IMAGE_SCN_ALIGN_1BYTES
.idata C0000048 &IMAGE_SCN_TYPE_NO_PAD__&IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.idata C0100040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_1BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.idata C0200040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_2BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.idata C0201040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_2BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.idata C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.idata C0301040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.orpc 60501020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_16BYTES__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.rdata 40300040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ
.rdata 40301040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ
.rdata 40400040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_READ
.rdata 40401040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_READ
.rdata 40500040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_16BYTES__&IMAGE_SCN_MEM_READ
.text 400020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_ALIGN_8BYTES
.text 60000020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.text 60101020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_1BYTES__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.text 60201020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_2BYTES__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.text 60300020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.text 60301020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.text 60500020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_ALIGN_16BYTES__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.text 60501020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_16BYTES__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.tls C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.xdata 40401040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_READ


__________________________________

Detailed sections found on several Libraries and executables files

.text 400020 &IMAGE_SCN_CNT_CODE   &IMAGE_SCN_ALIGN_8BYTES  
.orpc 60501020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_16BYTES &IMAGE_SCN_LNK_COMDAT 
.text 60000020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ   
.text 60101020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_1BYTES &IMAGE_SCN_LNK_COMDAT 
.text 60201020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_2BYTES &IMAGE_SCN_LNK_COMDAT 
.text 60300020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_4BYTES  
.text 60301020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_4BYTES &IMAGE_SCN_LNK_COMDAT 
.text 60500020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_16BYTES  
.text 60501020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_16BYTES &IMAGE_SCN_LNK_COMDAT 

; Data Flags

.CRT C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES 
.data C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES 
.data C0301040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES &IMAGE_SCN_LNK_COMDAT
.data C0400040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_8BYTES 
.data C0401040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_8BYTES &IMAGE_SCN_LNK_COMDAT
.data C0500040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_16BYTES 

.edata 040000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  
.rdata 040000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  
.rsrc 040000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  
.rdata 040000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  
.INIT 042000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  &IMAGE_SCN_MEM_DISCARDABLE
.reloc 042000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  &IMAGE_SCN_MEM_DISCARDABLE
.rdata 050000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  &IMAGE_SCN_MEM_SHARED
.reloc 050000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  &IMAGE_SCN_MEM_SHARED
.rsrc 050000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  &IMAGE_SCN_MEM_SHARED
BSS 0C0000000  &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE 
.tls 0C0000000  &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE 
.idata 0C0000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE 
DATA 0C0000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE 
.data 0C0000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE 
.shared 0D0000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_MEM_SHARED
.idata 040000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  
.bss 0C0000080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE 
.CRT 0C0000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE 

; Really weird sections at C:\WINNT\Driver Cache\i386 
; It is worthfull to analyze to fix them like I was doing for the Dumped files. (RosAsm crashes, for example at ftdisk.sys)

PAGE 060000020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ  
INIT 0E2000020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_MEM_DISCARDABLE

.rdata 048000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_NOT_PAGED  
.data 0C8000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_NOT_PAGED &IMAGE_SCN_MEM_WRITE 
.rsrc 042000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE  
.reloc 042000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE  
.rsrc 048000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_NOT_PAGED  


; Debug Data
; Name Types .debug$S; .debug$F; .debug$T; .debug$P

.debug$S 42000048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  
.debug$F 42100040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE   &IMAGE_SCN_ALIGN_1BYTES
.debug$S 42100040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE   &IMAGE_SCN_ALIGN_1BYTES
.debug$T 42100040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE   &IMAGE_SCN_ALIGN_1BYTES
.debug$P 42100048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  &IMAGE_SCN_ALIGN_1BYTES
.debug$S 42100048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  &IMAGE_SCN_ALIGN_1BYTES
.debug$T 42100048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  &IMAGE_SCN_ALIGN_1BYTES
.debug$S 42101040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE  &IMAGE_SCN_LNK_COMDAT &IMAGE_SCN_ALIGN_1BYTES
.debug$F 42101048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD &IMAGE_SCN_LNK_COMDAT &IMAGE_SCN_ALIGN_1BYTES
.debug$S 42101048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD &IMAGE_SCN_LNK_COMDAT &IMAGE_SCN_ALIGN_1BYTES
.debug$F 42400048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  &IMAGE_SCN_ALIGN_8BYTES

.debug 42100040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE   &IMAGE_SCN_ALIGN_1BYTES
.debug 42101040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE  &IMAGE_SCN_LNK_COMDAT &IMAGE_SCN_ALIGN_1BYTES
.debug 42000048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  
.debug 42100048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  &IMAGE_SCN_ALIGN_1BYTES
.debug 42101048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD &IMAGE_SCN_LNK_COMDAT &IMAGE_SCN_ALIGN_1BYTES
.debug 42400048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  &IMAGE_SCN_ALIGN_8BYTES

.idata C0100040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_1BYTES  
.idata C0200040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_2BYTES  
.idata C0201040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_2BYTES  &IMAGE_SCN_LNK_COMDAT
.idata C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES  
.idata C0301040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES  &IMAGE_SCN_LNK_COMDAT
.idata C0000048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE  &IMAGE_SCN_TYPE_NO_PAD 

.rdata 040300040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_4BYTES 
.rdata 040301040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_4BYTES &IMAGE_SCN_LNK_COMDAT
.rdata 040400040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_8BYTES 
.rdata 040401040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_8BYTES &IMAGE_SCN_LNK_COMDAT
.rdata 040500040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_16BYTES 

.tls 0C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES


.xdata 040401040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_8BYTES &IMAGE_SCN_LNK_COMDAT

; Virtual Data Flags

.bss 0C0300080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES 
.bss 0C0301080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES &IMAGE_SCN_LNK_COMDAT
.bss 0C0400080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_8BYTES 
.bss 0C0401080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_8BYTES &IMAGE_SCN_LNK_COMDAT
.bss 0C0500080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_16BYTES 

; Linker Directive Flags

.drectve 0100A00 &IMAGE_SCN_LNK_INFO &IMAGE_SCN_LNK_REMOVE &IMAGE_SCN_ALIGN_1BYTES




;;
;;
[RawDataType: D$ 0]

; RawData Types Constants

[RDT_DATA 0] ; This is the default. If everything fails, it always set to DATA
[RDT_LNKDIRECTIVE 1]
[RDT_CODE 2]
[RDT_VIRTUALDATA 3]
[RDT_DEBUGS 4]
[RDT_DEBUGF 5]
[RDT_DEBUGT 6]
[RDT_DEBUGP 7]
[RDT_IDATA 8]
[RDT_RDATA 9]
[RDT_XDATA 10]
[RDT_PDATA 11]
[RDT_EDATA 12]
[RDT_TLSDATA 13]
[RDT_RELOCDATA 14]
[RDT_RSRCDATA 15]
[RDT_ERROR 16] ; This is DATA, but we set this Flag to identify some error cases messages
[RDT_STABSTR 17] ; .stabstr ; NetFramework stab string section. This section contains only strings.

Proc IdentifyRawDataType:
    Uses eax, esi, ecx

    Mov eax D$esi+36 ; eax points to the Characteristics member

    ; Reinitialize the Raw Data to make sure it always will be set to 0 when the below
    ; checkings fails.

    Mov D$RawDataType 0

    ; Check if it is .text or .code or any other section that is related to code only
    .Test_If eax &IMAGE_SCN_CNT_CODE
            jmp L0>
    .Test_Else_If eax &IMAGE_SCN_MEM_EXECUTE
    L0:
            Test_If eax &IMAGE_SCN_CNT_UNINITIALIZED_DATA
                Mov D$RawDataType RDT_VIRTUALDATA
            Test_Else
                Mov D$RawDataType RDT_CODE
            Test_End

    .Test_Else

        ; All the rest is Data. Let's analyze what kind of data it is.
        ; Find Virtual Data
        ; Guga Note: Look at CTLFWR32.LIB we will need a Virtual data. Like we did for the raw data.

        Test_If eax &IMAGE_SCN_CNT_UNINITIALIZED_DATA
            Mov D$RawDataType RDT_VIRTUALDATA

EndP

        Test_End

        ; Check for long section names (KSGUID.LIB)
        If B$esi = '/'
            ; Similar to what we found at WriteIndirectSectionName
            Call GetName1Offset ; convert the Offset to hexadecimal
            Call GetStringTablePointer
            Mov esi D$CoffSectionBase
            add esi D$CoffSymbolsPointer
            Mov ecx D$PointerToStringTable
            add ecx D$MemberName1Offset | Mov esi ecx
        End_If

        ; Find Virtual Data
        ; convert all section names to small caps and compare them.
        ; save the address of esi to be restored later
        Push D$esi, D$esi+4
        or D$esi 020202020
        or D$esi+4 020202020

        .If D$esi = 'bss' ; BSS or bss
            jmp L0>
        .Else_If D$esi = '.bss'

        L0:
            Mov D$RawDataType RDT_VIRTUALDATA

        ; Find Debug Data. It will use the proper Debug structures to display in the raw data.
        .Else_If D$esi = '.deb'

            If D$esi+4 = 'ug$s' ; .debug$s , .debug$S or Big caps
                Mov D$RawDataType RDT_DEBUGS
            Else_If D$esi+4 = 'ug$f' ; .debug$f , .debug$F or Big caps
                Mov D$RawDataType RDT_DEBUGF
            Else_If D$esi+4 = 'ug$t' ; .debug$t , .debug$T or Big caps
                Mov D$RawDataType RDT_DEBUGT
            Else_If D$esi+4 = 'ug$p' ; .debug$p , .debug$P or Big caps
                Mov D$RawDataType RDT_DEBUGP
            Else
                Mov D$RawDataType RDT_ERROR
            End_If

        ; Find NetFramework Stab Structure. It will use the proper Debug structures to display in the raw data.
        .Else_If_And D$esi = '.sta', D$esi+4 = 'bstr'
            Mov D$RawDataType RDT_STABSTR

        ; Check for Linker Directive data. esi points to the Characteristics member.

        .Else_If_And D$esi = '.dre', D$esi+4 = 'ctve' ; .drectve

            Test_If eax &IMAGE_SCN_LNK_INFO
                ; PointerToRelocations and PointerToLinenumbers must be 0, because
                ; the section must not have relocations or line numbers.
                If_And D$esi+24 = 0, D$esi+28 = 0
                    Mov D$RawDataType RDT_LNKDIRECTIVE
                Else
                    Mov D$RawDataType RDT_ERROR
                End_If

            Test_Else
                Mov D$RawDataType RDT_ERROR
            Test_End

        ; Find Common Data. (.data; .idata; .rdata; .xdata; .pdata; .edata)

        .Else_If_And D$esi = '.dat', B$esi+4 = 'a'
            Mov D$RawDataType RDT_DATA

        .Else_If D$esi+2 = 'data'

            If W$esi = '.i' ; Import Data Tables. Need to use proper structures or Data arrays.
                            ; Using IMAGE_IMPORT_DESCRIPTOR structure. Take a look at ACLCLS.LIB to we identify the proper structures and Data Bytes
                Mov D$RawDataType RDT_IDATA
            Else_If W$esi = '.r' ; Read Only Data. In general, it is a series of Dwords, but it can be anything, like a serie of structures etc.
                Mov D$RawDataType RDT_RDATA
            Else_If W$esi = '.x' ; Exception information Data Tables. Need to use proper structures EXCEPTION_RECORD. _msExcept _msExcInfo
                Mov D$RawDataType RDT_XDATA
            Else_If W$esi = '.p' ; Exception information Data Tables. Need to use proper structures (EXCEPTION_RECORD ?)
                Mov D$RawDataType RDT_PDATA
            Else_If W$esi = '.e' ; Export Data Tables. Need to use proper structures or Data arrays (IMAGE_EXPORT_DIRECTORY ?)
                Mov D$RawDataType RDT_EDATA
            Else
                Mov D$RawDataType RDT_ERROR
            End_If

        .Else_If D$esi = '.tls' ; Thread-local storage Data. Some section uses the IMAGE_TLS_DIRECTORY32 to point to
                                ; some data inside this .tls section. See MSVCRT.LIB, MSVCRTD.LIB, LIBCMT.LIB, LIBCMTD.LIB
            Mov D$RawDataType RDT_TLSDATA

        .Else_If_And D$esi = '.rel', W$esi+4 = 'oc' ; Image relocations. We must use the (IMAGE_RELOCATION ?) for this
            Mov D$RawDataType RDT_RELOCDATA

        .Else_If_And D$esi = '.rsr', B$esi+4 = 'c' ; Resource Section. We must use the IMAGE_RESOURCE_DIRECTORY structure.
            Mov D$RawDataType RDT_RSRCDATA

        .Else
            ; When everything Else fails or we have some unknown section names, we always set to DATA
            Mov D$RawDataType RDT_DATA
        .End_If

        Pop D$esi+4, D$esi

    .Test_End

EndP

___________________________________________________

GetCoffSectionHeader:

    Push esi
        zCopy CoffSectionHeaderTitle
    Pop esi

    ; The name of the section is indirected addressed on the String Table ?
    ; Yes, do next line. No, jmp over. Example: KSGUID.LIB

    If B$esi = '/'
        Call WriteIndirectSectionName
    End_If

    Push esi
        Mov B$edi '[' | inc edi
        Call WriteObjIndice
        zCopy {B$ 'ImgSecHdr' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Mov B$edi ':', W$edi+1 CRLF | add edi 3
    Pop esi

;    Call IdentifyRawDataType

    Call WriteObjSectionHeaderItem CoffSectionHeaderName, {B$ ': B$ ' EOS}

    If B$esi-8 = '/'
        Call WriteLinkerMemberSizeHex D$MemberName1Offset
    End_If

    Call WriteObjSectionHeaderItem CoffSectionHeaderVirtualSize, {B$ ': D$ ' EOS}
    Call WriteObjSectionHeaderItem CoffSectionHeaderRVA, {B$ ': D$ ' EOS}
    Call WriteObjSectionHeaderItem CoffSectionHeaderSize, {B$ ': D$ ' EOS}
    Call WriteObjSectionHeaderItem CoffSectionHeaderPointerToData, {B$ ': D$ ' EOS}
    Call WriteObjSectionHeaderItem CoffSectionHeaderPointerToReloc, {B$ ': D$ ' EOS}
    Call WriteObjSectionHeaderItem CoffSectionHeaderPointerToLinesNumbers, {B$ ': D$ ' EOS}
    Call WriteObjSectionHeaderItem CoffSectionHeaderNumberOfRelocations, {B$ ': W$ ' EOS}
    Call WriteObjSectionHeaderItem CoffSectionHeaderNumberOfLinesNumbers, {B$ ': W$ ' EOS}
    Call WriteObjSectionHeaderItem CoffSectionHeaderCharacteristics, {B$ ': D$ ' EOS}
    Push esi
        sub edi 2 | Mov eax D$esi-4 | Call WriteCharacteristicsEquates
        Mov W$edi CRLF, B$edi+2 ']', D$edi+3 CRLF2 | add edi 7
    Pop esi
ret
____________________________________________________________________________________________

WriteSectionHeaderVirtualSizeDiffLabel:
    Push esi

        Call WriteObjIndice
        zCopy {B$ "VirtualDataEnd" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Mov D$edi ' - ' | add edi 3

        Call WriteObjIndice
        zCopy {B$ "VirtualData" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    Pop esi
ret


WriteSectionHeaderRawSizeDiffLabel:

    If D$esi+4 = 0 ; Is PointerToRawData = 0 ? If so, it means we are dealing with Virtual data. Do next line
        Push esi | lodsd | Call WriteEax | Pop esi | ret
    End_If

    Push esi

        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {B$ ".RawDataEnd" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Mov D$edi ' - ' | add edi 3

        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {B$ ".RawData" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    Pop esi
ret

[IMAGE_FILE_HEADER_Comment1: B$ 'IMAGE_FILE_HEADER_' EOS]

WriteSectionHeaderPointerToDataDiffLabel:
    Push esi

        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {B$ ".RawData" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Mov D$edi ' - ' | add edi 3

        zCopy IMAGE_FILE_HEADER_Comment1
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Call WriteIndiceOnly

    Pop esi
ret


Proc FixRelocDiffLabel:
    uses eax, ebx, ecx, esi, edi

    ; reinitialize the sectino counter
    Call InitSectionHeaderNumber

    movzx ecx W$ObjNumberOfSections
    Mov ebx D$FirstSectionPointer
    Mov edi D$esi ; edi hold the value of our PointerToRelocations to be compared

L0:

    ; Points to PointerToRelocations starting at the 1st section
   .If edi = D$ebx+018 ; is our relocs equal to the relocs on section where we are ?
        If W$ebx+020 <> 0 ; Is NumberOfRelocations = 0 ? Yes, we are analysing our own section
            ExitP
        End_If
   .End_If

   Call IncrementSectionHeaderNumber
   add ebx 028 ; go to the next section
   Loop L0<


EndP


WriteSectionHeaderPointerToRelocDiffLabel:

    Push D$SectionHeaderNumber

    If W$esi+4+4 = 0 ; Points to NumberOfRelocations. aclcls.lib
        ; Check how many relocs we have. If we have 0, it means that the pointer is being referenced by another section.
         Call FixRelocDiffLabel
    End_If

    Push esi

        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {B$ ".ImgReloc" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy RelocNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Mov D$edi ' - ' | add edi 3

        zCopy IMAGE_FILE_HEADER_Comment1
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Call WriteIndiceOnly

    Pop esi

    Pop D$SectionHeaderNumber

ret


WriteSectionHeaderPointerToLineNumberDiffLabel:
    Push esi

        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {B$ ".LineNumber" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy CoffLineNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Mov D$edi ' - ' | add edi 3

        zCopy IMAGE_FILE_HEADER_Comment1
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Call WriteIndiceOnly

    Pop esi
ret


; It should display for example: ; Stringdata15 - StringTableSize

Proc WriteSectionHeaderPointerToStringTableDiffLabel:
    Uses esi, eax, edx

    ; Initialize the String Record Counter

    Call InitStringTableRecord

    ; On this case, the Stringtable must be initialized with 0. Otherwise our counter will already start at 01
    ; So, we must reset the counter to '000000'.

    Mov D$StringTableRecord+4 '00'

    lodsd ; eax is pointing to the Offset of the String on the String Table
    Mov edx D$PointerToStringTable
    add edx 4 ; Bypass the String Table Size. and Point to the beginning of the 1st String
    Mov esi edx ; esi is pointing to the 1st string
    add edx eax ; edx will be using as a counter of the total amount of strings untill we reach the String where we are.

    .Do

        While B$esi <> 0 | inc esi | End_While | inc esi | On B$esi = 0, Mov edx 0

        Call IncrementStringTableRecord

    .Loop_Until esi >= edx


        Push esi
            Call WriteObjIndice
            zCopy {B$ 'StringData' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy StringTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi

        Mov D$edi ' - ' | add edi 3

        Call WriteObjIndice
        zCopy {B$ 'StringTableSize' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {B$ ' ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi


EndP

____________________________________________________________________________________________


Proc WriteSectionHeaderSymbolConstantIndex:
    uses eax, ecx, ebx, esi

    Call InitSymbolIndexRecord
    Call WriteObjIndice

    ; Fix the label to show in Caps and replace the '." with an "_"
    ; The 1st char in "Obj000000." is in Caps, so we don't need to overwrite the "O" char

    Push edi
    Mov B$edi-1 '_', W$edi-9 'BJ'
    Pop edi

    Push esi
    zCopy {B$ 'SYMBOLINDEX' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    Pop esi

    Mov ecx D$esi

    ; Note to René: Replacing this with a hex to decimal ascii string is better,
    ; but i couldn't make it be on the same style as SymbolTableIndex

    While ecx <> 0
        Call IncrementSymbolIndexRecord
        dec ecx
    End_While

    zCopy SymbolTableIndex
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    ; restore the SymbolTableIndex
    Call InitSymbolIndexRecord

EndP
____________________________________________________________________________________________



[CoffRelocHeaderTitle: B$ "; IMAGE_RELOCATION Structure, pointed at: " EOS]

[CoffRelocHeaderRelocRVA: B$ 'VirtualAddress' EOS]
[CoffRelocHeaderRelocCount: B$ 'RelocCount' EOS]
[CoffRelocHeaderSymbolTableIndex: B$ 'SymbolTableIndex' EOS]
[CoffRelocHeaderType: B$ 'Type1' EOS]

Proc WriteObjRelocHeaderItem:
    Argument @Text1, @Text2

        Push esi
            Call WriteObjIndice

            zCopy {B$ "Sec" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy {B$ '.ImgReloc' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy RelocNumber;SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Mov B$edi '.' | inc edi
            zCopy D@Text1
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy D@Text2
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi

        Mov eax D@Text2, al B$eax+2

        ..If al = 'D'

            .If D$esi <> 0

                Mov eax D@Text1

                If D$eax = 'Virt' ; from "VirtualAddress" string

                    lodsd | Call WriteEax
                    Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

                ;Else_If D$eax = 'Relo'; From "RelocCount" string

                    ;Call WriteSectionHeaderPointerToDataDiffLabel
                    ;Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi

                Else_If D$eax = 'Symb'; From "SymbolTableIndex" string
                    Call WriteSectionHeaderSymbolConstantIndex
                    add esi 4 ; we need to increment esi by 4 to we adjust at the end of the End_If macro
                    Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi

                End_If

            .Else
                add esi 4


            .End_If
            ; We need to subtract esi by 4 (01 Dword) to we get back to the path again. It was increased above.
            sub esi 4 | lodsd | Call WriteEax

        ..Else_If al = 'W'
            lodsw | and eax 0FFFF | Call WriteEax

        ;..Else

        ..End_If

        Mov W$edi CRLF | add edi 2
EndP

_________________________________________________________
;;
;;
a) When the  Machine member of IMAGE_FILE_HEADER is settlled to one of 
theses: IMAGE_FILE_MACHINE_I386, IMAGE_FILE_MACHINE_I486, 
IMAGE_FILE_MACHINE_I586,  IMAGE_FILE_MACHINE_IA64 (So, INtel compatible 
processors), the equates are:

&IMAGE_REL_I386_ABSOLUTE
&IMAGE_REL_I386_DIR16
&IMAGE_REL_I386_REL16
&IMAGE_REL_I386_DIR32
&IMAGE_REL_I386_DIR32NB
&IMAGE_REL_I386_SEG12
&IMAGE_REL_I386_SECTION
&IMAGE_REL_I386_SECREL
&IMAGE_REL_I386_REL32

b) When the  Machine member of IMAGE_FILE_HEADER is settlled to one of 
theses: IMAGE_FILE_MACHINE_MIPS16, IMAGE_FILE_MACHINE_MIPSFPU, 
IMAGE_FILE_MACHINE_MIPSFPU16 , IMAGE_FILE_MACHINE_R10000, 
IMAGE_FILE_MACHINE_R3000,
IMAGE_FILE_MACHINE_R4000, IMAGE_FILE_MACHINE_WCEMIPSV2
(So, MIPS compatible processors), the equates are:

&IMAGE_REL_MIPS_ABSOLUTE
&IMAGE_REL_MIPS_REFHALF
&IMAGE_REL_MIPS_REFWORD
&IMAGE_REL_MIPS_JMPADDR
&IMAGE_REL_MIPS_REFHI
&IMAGE_REL_MIPS_REFLO
&IMAGE_REL_MIPS_GPREL
&IMAGE_REL_MIPS_LITERAL
&IMAGE_REL_MIPS_SECTION
&IMAGE_REL_MIPS_SECREL
&IMAGE_REL_MIPS_SECRELLO
&IMAGE_REL_MIPS_SECRELHI
&IMAGE_REL_MIPS_JMPADDR16
&IMAGE_REL_MIPS_REFWORDNB
&IMAGE_REL_MIPS_PAIR

c) When the  Machine member of IMAGE_FILE_HEADER is settlled to one of 
theses: IMAGE_FILE_MACHINE_ALPHA, IMAGE_FILE_MACHINE_ALPHA64, 
IMAGE_FILE_MACHINE_AXP64 (So, Alpha compatible processors), the equates are:

&IMAGE_REL_ALPHA_ABSOLUTE
&IMAGE_REL_ALPHA_REFLONG
&IMAGE_REL_ALPHA_REFQUAD
&IMAGE_REL_ALPHA_GPREL32
&IMAGE_REL_ALPHA_LITERAL
&IMAGE_REL_ALPHA_LITUSE
&IMAGE_REL_ALPHA_GPDISP
&IMAGE_REL_ALPHA_BRADDR
&IMAGE_REL_ALPHA_HINT
&IMAGE_REL_ALPHA_INLINE_REFLONG
&IMAGE_REL_ALPHA_REFHI
&IMAGE_REL_ALPHA_REFLO
&IMAGE_REL_ALPHA_PAIR
&IMAGE_REL_ALPHA_MATCH
&IMAGE_REL_ALPHA_SECTION
&IMAGE_REL_ALPHA_SECREL
&IMAGE_REL_ALPHA_REFLONGNB
&IMAGE_REL_ALPHA_SECRELLO
&IMAGE_REL_ALPHA_SECRELHI
&IMAGE_REL_ALPHA_REFQ3
&IMAGE_REL_ALPHA_REFQ2
&IMAGE_REL_ALPHA_REFQ1
&IMAGE_REL_ALPHA_GPRELLO
&IMAGE_REL_ALPHA_GPRELHI

d) When the  Machine member of IMAGE_FILE_HEADER is settlled to one of 
theses: IMAGE_FILE_MACHINE_POWERPC, IMAGE_FILE_MACHINE_POWERPCFP, (So, IBM 
POwer PC compatible processors), the equates are:

&IMAGE_REL_PPC_ABSOLUTE
&IMAGE_REL_PPC_ADDR64
&IMAGE_REL_PPC_ADDR32
&IMAGE_REL_PPC_ADDR24
&IMAGE_REL_PPC_ADDR16
&IMAGE_REL_PPC_ADDR14
&IMAGE_REL_PPC_REL24
&IMAGE_REL_PPC_REL14
&IMAGE_REL_PPC_ADDR32NB
&IMAGE_REL_PPC_SECREL
&IMAGE_REL_PPC_SECTION
&IMAGE_REL_PPC_SECREL16
&IMAGE_REL_PPC_REFHI
&IMAGE_REL_PPC_REFLO
&IMAGE_REL_PPC_PAIR
&IMAGE_REL_PPC_SECRELLO
&IMAGE_REL_PPC_SECRELHI
&IMAGE_REL_PPC_GPREL

e) When the  Machine member of IMAGE_FILE_HEADER is settlled to one of 
theses: IMAGE_FILE_MACHINE_SH3, IMAGE_FILE_MACHINE_SH3DSP, 
IMAGE_FILE_MACHINE_SH3E, IMAGE_FILE_MACHINE_SH4, IMAGE_FILE_MACHINE_SH5,  
(So, Hitachi SuperH compatible processors), the equates are:

&IMAGE_REL_SH3_ABSOLUTE
&IMAGE_REL_SH3_DIRECT16
&IMAGE_REL_SH3_DIRECT32
&IMAGE_REL_SH3_DIRECT8
&IMAGE_REL_SH3_DIRECT8_WORD
&IMAGE_REL_SH3_DIRECT8_LONG
&IMAGE_REL_SH3_DIRECT4
&IMAGE_REL_SH3_DIRECT4_WORD
&IMAGE_REL_SH3_DIRECT4_LONG
&IMAGE_REL_SH3_PCREL8_WORD
&IMAGE_REL_SH3_PCREL8_LONG
&IMAGE_REL_SH3_PCREL12_WORD
&IMAGE_REL_SH3_STARTOF_SECTION
&IMAGE_REL_SH3_SIZEOF_SECTION
&IMAGE_REL_SH3_SECTION
&IMAGE_REL_SH3_SECREL
&IMAGE_REL_SH3_DIRECT32_NB

f) When the  Machine member of IMAGE_FILE_HEADER is settlled to one of 
theses: IMAGE_FILE_MACHINE_ARM,  (So, ARM compatible processors), the 
equates are:

&IMAGE_REL_ARM_ABSOLUTE
&IMAGE_REL_ARM_ADDR32
&IMAGE_REL_ARM_ADDR32NB
&IMAGE_REL_ARM_BRANCH24
&IMAGE_REL_ARM_BRANCH11
&IMAGE_REL_ARM_SECTION
&IMAGE_REL_ARM_SECREL
;;
;;
WriteRelocHeaderTypeEquate:
    Push esi

    movzx eax W$esi-2 | Mov ebx D$CoffSectionBase | movzx ebx W$ebx

    Mov D$edi ' ; ' | add edi 3

    ; Intel Compatible: IMAGE_FILE_MACHINE_I386, IMAGE_FILE_MACHINE_I486,
    ; IMAGE_FILE_MACHINE_I586,  IMAGE_FILE_MACHINE_IA64

    ..If ebx = &IMAGE_FILE_MACHINE_I386
L1:     .If eax = &IMAGE_REL_I386_ABSOLUTE
            zCopy {B$ '&IMAGE_REL_I386_ABSOLUTE' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_I386_DIR16
            zCopy {B$ '&IMAGE_REL_I386_DIR16' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_I386_REL16
            zCopy {B$ '&IMAGE_REL_I386_REL16' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_I386_DIR32
            zCopy {B$ '&IMAGE_REL_I386_DIR32' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_I386_DIR32NB
            zCopy {B$ '&IMAGE_REL_I386_DIR32NB' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_I386_SEG12
            zCopy {B$ '&IMAGE_REL_I386_SEG12' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_I386_SECTION
            zCopy {B$ '&IMAGE_REL_I386_SECTION' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_I386_SECREL
            zCopy {B$ '&IMAGE_REL_I386_SECREL' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_I386_REL32
            zCopy {B$ '&IMAGE_REL_I386_REL32' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .End_If

    ..Else_If ebx = &IMAGE_FILE_MACHINE_I486
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_I586
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_IA64
        jmp L1<<


    ; Mips Compatible: IMAGE_FILE_MACHINE_MIPS16, IMAGE_FILE_MACHINE_MIPSFPU,
    ; IMAGE_FILE_MACHINE_MIPSFPU16 , IMAGE_FILE_MACHINE_R10000,
    ; IMAGE_FILE_MACHINE_R3000, IMAGE_FILE_MACHINE_R4000, IMAGE_FILE_MACHINE_WCEMIPSV2

    ..Else_If ebx = &IMAGE_FILE_MACHINE_MIPS16
L1:     .If eax = &IMAGE_REL_MIPS_ABSOLUTE
            zCopy {B$ '&IMAGE_REL_I386_ABSOLUTE' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_MIPS_REFHALF
            zCopy {B$ '&IMAGE_REL_MIPS_REFHALF' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_MIPS_REFWORD
            zCopy {B$ '&IMAGE_REL_MIPS_REFWORD' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_MIPS_JMPADDR
            zCopy {B$ '&IMAGE_REL_MIPS_JMPADDR' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_MIPS_REFHI
            zCopy {B$ 'IMAGE_REL_MIPS_REFHI' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_MIPS_REFLO
            zCopy {B$ '&IMAGE_REL_MIPS_REFLO' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_MIPS_GPREL
            zCopy {B$ '&IMAGE_REL_MIPS_GPREL' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_MIPS_LITERAL
            zCopy {B$ '&IMAGE_REL_MIPS_LITERAL' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_MIPS_SECTION
            zCopy {B$ '&IMAGE_REL_MIPS_SECTION' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_MIPS_SECREL
            zCopy {B$ '&IMAGE_REL_MIPS_SECREL' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_MIPS_SECRELLO
            zCopy {B$ '&IMAGE_REL_MIPS_SECRELLO' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_MIPS_SECRELHI
            zCopy {B$ '&IMAGE_REL_MIPS_SECRELHI' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_MIPS_JMPADDR16
            zCopy {B$ '&IMAGE_REL_MIPS_JMPADDR16' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_MIPS_REFWORDNB
            zCopy {B$ '&IMAGE_REL_MIPS_REFWORDNB' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_MIPS_PAIR
            zCopy {B$ '&IMAGE_REL_MIPS_PAIR' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .End_If


    ..Else_If ebx = &IMAGE_FILE_MACHINE_MIPSFPU
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_MIPSFPU16
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_R10000
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_R3000
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_R4000
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_WCEMIPSV2
        jmp L1<<


    ; Alpha Compatible: IMAGE_FILE_MACHINE_ALPHA, IMAGE_FILE_MACHINE_ALPHA64, IMAGE_FILE_MACHINE_AXP64

    ..Else_If ebx = &IMAGE_FILE_MACHINE_ALPHA
L1:     .If eax = &IMAGE_REL_ALPHA_ABSOLUTE
            zCopy {B$ '&IMAGE_REL_ALPHA_ABSOLUTE' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_REFLONG
            zCopy {B$ '&IMAGE_REL_ALPHA_REFLONG' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_REFQUAD
            zCopy {B$ '&IMAGE_REL_ALPHA_REFQUAD' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_GPREL32
            zCopy {B$ '&IMAGE_REL_ALPHA_GPREL32' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_LITERAL
            zCopy {B$ '&IMAGE_REL_ALPHA_LITERAL' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_LITUSE
            zCopy {B$ '&IMAGE_REL_ALPHA_LITUSE' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_GPDISP
            zCopy {B$ '&IMAGE_REL_ALPHA_GPDISP' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_BRADDR
            zCopy {B$ '&IMAGE_REL_ALPHA_BRADDR' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_HINT
            zCopy {B$ '&IMAGE_REL_ALPHA_HINT' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_INLINE_REFLONG
            zCopy {B$ '&IMAGE_REL_ALPHA_INLINE_REFLONG' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_REFHI
            zCopy {B$ '&IMAGE_REL_ALPHA_REFHI' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_REFLO
            zCopy {B$ '&IMAGE_REL_ALPHA_REFLO' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_PAIR
            zCopy {B$ '&IMAGE_REL_ALPHA_PAIR' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_MATCH
            zCopy {B$ '&IMAGE_REL_ALPHA_MATCH' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_SECTION
            zCopy {B$ '&IMAGE_REL_ALPHA_SECTION' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_SECREL
            zCopy {B$ '&IMAGE_REL_ALPHA_SECREL' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_REFLONGNB
            zCopy {B$ '&IMAGE_REL_ALPHA_REFLONGNB' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_SECRELLO
            zCopy {B$ '&IMAGE_REL_ALPHA_SECRELLO' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_SECRELHI
            zCopy {B$ '&IMAGE_REL_ALPHA_SECRELHI' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_REFQ3
            zCopy {B$ '&IMAGE_REL_ALPHA_REFQ3' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_REFQ2
            zCopy {B$ '&IMAGE_REL_ALPHA_REFQ2' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_REFQ1
            zCopy {B$ '&IMAGE_REL_ALPHA_REFQ1' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_GPRELLO
            zCopy {B$ '&IMAGE_REL_ALPHA_GPRELLO' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ALPHA_GPRELHI
            zCopy {B$ '&IMAGE_REL_ALPHA_GPRELHI' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .End_If

    ..Else_If ebx = &IMAGE_FILE_MACHINE_ALPHA64
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_AXP64
        jmp L1<<

    ; IBM Power PC compatible: IMAGE_FILE_MACHINE_POWERPC, IMAGE_FILE_MACHINE_POWERPCFP

    ..Else_If ebx = &IMAGE_FILE_MACHINE_POWERPC
L1:     .If eax = &IMAGE_REL_PPC_ABSOLUTE
            zCopy {B$ '&IMAGE_REL_PPC_ABSOLUTE' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_ADDR64
            zCopy {B$ '&IMAGE_REL_PPC_ADDR64' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_ADDR32
            zCopy {B$ '&IMAGE_REL_PPC_ADDR32' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_ADDR24
            zCopy {B$ '&IMAGE_REL_PPC_ADDR24' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_ADDR16
            zCopy {B$ '&IMAGE_REL_PPC_ADDR16' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_ADDR14
            zCopy {B$ '&IMAGE_REL_PPC_ADDR14' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_REL24
            zCopy {B$ '&IMAGE_REL_PPC_REL24' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_REL14
            zCopy {B$ '&IMAGE_REL_PPC_REL14' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_ADDR32NB
            zCopy {B$ '&IMAGE_REL_PPC_ADDR32NB' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_SECREL
            zCopy {B$ '&IMAGE_REL_PPC_SECREL' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_SECTION
            zCopy {B$ '&IMAGE_REL_PPC_SECTION' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_SECREL16
            zCopy {B$ '&IMAGE_REL_PPC_SECREL16' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_REFHI
            zCopy {B$ '&IMAGE_REL_PPC_REFHI' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_REFLO
            zCopy {B$ '&IMAGE_REL_PPC_REFLO' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_PAIR
            zCopy {B$ '&IMAGE_REL_PPC_PAIR' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_SECRELLO
            zCopy {B$ '&IMAGE_REL_PPC_SECRELLO' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_SECRELHI
            zCopy {B$ '&IMAGE_REL_PPC_SECRELHI' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_PPC_GPREL
            zCopy {B$ '&IMAGE_REL_PPC_GPREL' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .End_If

    ..Else_If ebx = &IMAGE_FILE_MACHINE_POWERPCFP
        jmp L1<<

    ; Hitachi SuperH compatible: IMAGE_FILE_MACHINE_SH3, IMAGE_FILE_MACHINE_SH3DSP, IMAGE_FILE_MACHINE_SH3E, IMAGE_FILE_MACHINE_SH4, IMAGE_FILE_MACHINE_SH5

    ..Else_If ebx = &IMAGE_FILE_MACHINE_SH3
L1:     .If eax = &IMAGE_REL_SH3_ABSOLUTE
            zCopy {B$ '&IMAGE_REL_SH3_ABSOLUTE' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_DIRECT16
            zCopy {B$ '&IMAGE_REL_SH3_DIRECT16' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_DIRECT32
            zCopy {B$ '&IMAGE_REL_SH3_DIRECT32' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_DIRECT8
            zCopy {B$ '&IMAGE_REL_SH3_DIRECT8' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_DIRECT8_WORD
            zCopy {B$ '&IMAGE_REL_SH3_DIRECT8_WORD' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_DIRECT8_LONG
            zCopy {B$ '&IMAGE_REL_SH3_DIRECT8_LONG' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_DIRECT4
            zCopy {B$ '&IMAGE_REL_SH3_DIRECT4' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_DIRECT4_WORD
            zCopy {B$ '&IMAGE_REL_SH3_DIRECT4_WORD' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_DIRECT4_LONG
            zCopy {B$ '&IMAGE_REL_SH3_DIRECT4_LONG' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_PCREL8_WORD
            zCopy {B$ '&IMAGE_REL_SH3_PCREL8_WORD' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_PCREL8_LONG
            zCopy {B$ '&IMAGE_REL_SH3_PCREL8_LONG' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_PCREL12_WORD
            zCopy {B$ '&IMAGE_REL_SH3_PCREL12_WORD' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_STARTOF_SECTION
            zCopy {B$ '&IMAGE_REL_SH3_STARTOF_SECTION' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_SIZEOF_SECTION
            zCopy {B$ '&IMAGE_REL_SH3_SIZEOF_SECTION' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_SECTION
            zCopy {B$ '&IMAGE_REL_SH3_SECTION' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_SECREL
            zCopy {B$ '&IMAGE_REL_SH3_SECREL' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_SH3_DIRECT32_NB
            zCopy {B$ '&IMAGE_REL_SH3_DIRECT32_NB' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .End_If

    ..Else_If ebx = &IMAGE_FILE_MACHINE_SH3DSP
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_SH3E
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_SH4
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_SH5
        jmp L1<<

    ; ARM compatible: IMAGE_FILE_MACHINE_ARM

    ..Else_If ebx = &IMAGE_FILE_MACHINE_ARM
        .If eax = &IMAGE_REL_ARM_ABSOLUTE
            zCopy {B$ '&IMAGE_REL_ARM_ABSOLUTE' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ARM_ADDR32
            zCopy {B$ '&IMAGE_REL_ARM_ADDR32' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ARM_ADDR32NB
            zCopy {B$ '&IMAGE_REL_ARM_ADDR32NB' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ARM_BRANCH24
            zCopy {B$ '&IMAGE_REL_ARM_BRANCH24' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ARM_BRANCH11
            zCopy {B$ '&IMAGE_REL_ARM_BRANCH11' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ARM_SECTION
            zCopy {B$ '&IMAGE_REL_ARM_SECTION' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_REL_ARM_SECREL
            zCopy {B$ '&IMAGE_REL_ARM_SECREL' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .End_If

    ..End_If

    Pop esi


ret

; GugaNote
; Problem of multiple section with different relocs with DX9SDKSampleFramework.lib
; Most often, they may contains relocs offset, but size is 0 (ForceLibrary.lib)

Proc GetCoffRelocHeader:
    uses ecx, ebx

    Push esi
        zCopy CoffRelocHeaderTitle
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Call WriteObjIndice
        zCopy {B$ "ImgSecHdr" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {B$ ".PointerToRelocations" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {B$ " Member" D$ CRLF2 B$ "[" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi


        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {B$ ".ImgReloc" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy RelocNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Mov B$edi ':', W$edi+1 CRLF | add edi 3
    Pop esi

    Call WriteObjRelocHeaderItem CoffRelocHeaderRelocRVA, {B$ ': D$ ' EOS}
    Call WriteObjRelocHeaderItem CoffRelocHeaderSymbolTableIndex, {B$ ': D$ ' EOS}
    Call WriteObjRelocHeaderItem CoffRelocHeaderType, {B$ ': W$ ' EOS}
    sub edi 2 | Call WriteRelocHeaderTypeEquate
    Mov W$edi CRLF | add edi 2

    Push esi
        Mov B$edi ']', D$edi+1 CRLF2 | add edi 5
    Pop esi
EndP
____________________________________________________________

[RelocNumber: B$ '000001' EOS]


InitSectionRelocNumber:
    Mov D$RelocNumber '0000', D$RelocNumber+4 '01'
ret


IncrementSectionRelocNumber:
    lea ebx D$RelocNumber+5 | inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret




____________________________________________________________

Proc WriteObjLineHeaderItem:
    Argument @Text1, @Text2
    Uses edx

        Push esi
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {B$ ".LineNumber" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy CoffLineNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy D@Text1
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy D@Text2
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi


                Mov eax D@Text1

                .If D$eax = 'Symb' ; from "SymbolTableIndex" string
                    Call WriteSectionHeaderSymbolConstantIndex
                    Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi
                    lodsd | Call WriteEax

                .Else_If D$eax = 'Virt'; From "VirtualAddress" string
                    lodsd | Call WriteEax

                .Else_If D$eax = 'Line'; From "Linenumber" string
                    xor eax eax
                    lodsw | Call WriteEax

                .End_If


        Mov W$edi CRLF | add edi 2
EndP
;;
;;
[IMAGE_LINENUMBER:
 SymbolTableIndex: VirtualAddress: D$ 0
 Linenumber: W$ 0]
;;
;;
[CoffLineNumberTitle: "
__________________________________________________

; IMAGE_LINENUMBER Structure, pointed at: " EOS]

[CoffLineHeaderSymbolTableIndex: B$ 'SymbolTableIndex' EOS]
[CoffLineHeaderVirtualAddress: B$ 'VirtualAddress' EOS]
[CoffLineHeaderLinenumber: B$ 'Linenumber' EOS]

Proc GetCoffLineHeader:
    uses ecx, ebx


    Push esi
        zCopy CoffLineNumberTitle
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Call WriteObjIndice
        zCopy {B$ "ImgSecHdr" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {B$ ".PointerToLinenumbers Member" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    Pop esi

    Mov D$edi CRLF2 | add edi 4

    If W$esi+4 <> 0
        Push esi
        zCopy {B$ "; This Structure contains the correspondent line number on the original source specified at LineNumber member." EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {W$ CRLF, B$ "; Also it is related only to Code and contains the Virtual Address of some referenced data that can" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {W$ CRLF, B$ "; be a Local Variable, Argument, or a Data Pointer", D$ CRLF2, 0}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi
    End_If


    Push esi
        Mov B$edi "[" | inc edi
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {B$ ".LineNumber" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy CoffLineNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Mov B$edi ':', W$edi+1 CRLF | add edi 3
    Pop esi

    ; problem in ATLDLOAD.LIB

    If W$esi+4 = 0

        Call WriteObjLineHeaderItem CoffLineHeaderSymbolTableIndex, {B$ ': D$ ' EOS}
    Else

        Call WriteObjLineHeaderItem CoffLineHeaderVirtualAddress, {B$ ': D$ ' EOS}

    End_If

    Call WriteObjLineHeaderItem CoffLineHeaderLinenumber, {B$ ': W$ ' EOS}

;    sub edi 2 | Call WriteRelocHeaderTypeEquate
 ;   Mov W$edi CRLF | add edi 2

    Push esi
        Mov B$edi ']', D$edi+1 CRLF2 | add edi 5
    Pop esi
EndP



[CoffLineNumber: B$ '000001' EOS]


InitSectionLineNumber:
    Mov D$CoffLineNumber '0000', D$CoffLineNumber+4 '01'
ret


IncrementSectionLineNumber:
    lea ebx D$CoffLineNumber+5 | inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret


____________________________________________________________

[CoffSectionSize: D$ ?
 CoffPointerToData: D$ ?
 CoffPointerToReloc: D$ ?
 NumberOfRelocations: D$ ?
 CoffPointerToLineNumber: D$ ?
 NumberOfLineNumbers: D$ ?]

GetCoffSectionsVariables:

    add esi 8   ;  CoffSectionHeaderName, {B$ ': B$ ' EOS}

    add esi 4   ; CoffSectionHeaderVirtualSize, {B$ ': D$ ' EOS}

    add esi 4   ; CoffSectionHeaderRVA, {B$ ': D$ ' EOS} / VirtualAddress

    Move D$CoffSectionSize D$esi
    add esi 4   ; CoffSectionHeaderSize, {B$ ': D$ ' EOS} / SizeOfRawData

    Move D$CoffPointerToData D$esi
    add esi 4   ;  CoffSectionHeaderPointerToData, {B$ ': D$ ' EOS} / PointerToRawData

    Move D$CoffPointerToReloc D$esi
    add esi 4   ; CoffSectionHeaderPointerToReloc, {B$ ': D$ ' EOS} / PointerToRelocations

    Move D$CoffPointerToLineNumber D$esi
    add esi 4   ; CoffSectionHeaderPointerToLinesNumbers, {B$ ': D$ ' EOS} / PointerToLinenumbers

    Move W$NumberOfRelocations W$esi
    add esi 2   ; CoffSectionHeaderNumberOfRelocations, {B$ ': W$ ' EOS}

    Move W$NumberOfLineNumbers W$esi
    add esi 2   ; CoffSectionHeaderNumberOfLinesNumbers, {B$ ': W$ ' EOS}


  ; CoffSectionHeaderNumberOfRelocations, {B$ ': W$ ' EOS}

  ; CoffSectionHeaderNumberOfLinesNumbers, {B$ ': W$ ' EOS}
  ; CoffSectionHeaderCharacteristics, {B$ ': D$ ' EOS}
ret


[CoffSymbolsPointer: D$ ?
 CoffSymbolsNumber: D$ ?
 PointerToSymbolsStringTable: D$ ?
 SizeOfSymbolsStringsTable: D$ ?
 EndOfSymbolsStringsTable: D$ ?]

GetImageSymbolsVariables:
    Push esi
        Mov esi D$CoffSectionBase
        Mov eax D$esi+8
        If eax <> 0
            add eax esi | Mov D$CoffSymbolsPointer eax
        Else
            Mov D$CoffSymbolsPointer 0
        End_If

        Move D$CoffSymbolsNumber D$esi+12

        If D$CoffSymbolsPointer <> 0
          ; Search the Pointer to the Symbols Strings Table (18 is the Size of one Symbol Record):
            Mov ecx D$CoffSymbolsNumber, eax 18
            mul ecx
            add eax D$CoffSymbolsPointer
            Mov D$PointerToSymbolsStringTable eax
            Move D$SizeOfSymbolsStringsTable D$eax
            add eax D$eax | Mov D$EndOfSymbolsStringsTable eax
        End_If
    Pop esi
ret
____________________________________________________________________________________________

Proc WriteAuxSymFmt1DiffLabel:
    Uses esi, ebx, ecx, eax, edx, D$SectionHeaderNumber, D$CoffLineNumber


    Push esi

    Mov ebx D$FirstSectionPointer

    movzx ecx W$esi-14 ; ecx is pointing to the previous section value
    ; we need to recompute the sectionheader number

    Call InitSectionHeaderNumber
    Call InitSectionLineNumber

    Mov edx edi ; for keeping the path to edi, let's save it at edx

    ; Guga note this is the errros on DX9SDKSampleFramework.lib We have an 0 previous section

    On ecx = 0 EndP

    If ecx <> 1 ; Are we pointing to thye 1st section ?
        Push ecx

            Do
                Call IncrementSectionHeaderNumber
                dec ecx
            Loop_Until ecx = 1

        Pop ecx

    End_If

    sub esi 18+8 ; esi is pointing to the beginning of previous Symbol

    Push edx

    If ecx <> 1     ; If we are pointing to the 1st Section, we don´ need to add it to the offset of the IMAGE_SECTION_HEADER
        Mov eax 40  ; eax is the Size of the IMAGE_SECTON_HEADER
        imul ecx    ; multiply by the section where we must go
        add ebx eax
        sub ebx 40  ; need to subtract from the Size of IMAGE_SECTION_HEADER to get back to the proper path.
    End_If

    Pop edx


    Pop esi ; restore our value at esi

    ; we must point to the proper Section (IMAGE_SECTION_HEADER)
    add ebx 28 ; we are pointing to PointerToLinenumbers
    Mov eax D$ebx ; eax points to the value of linenumber in the ImgSec where we are

    Mov edi D$esi ; edi is pointing to the LineNumber value to be compare

    .If eax <> edi ; is the pointer where we are is equal to the value found in the linenumber ?
                   ; Yes, jmp over.


        movzx ecx W$ebx+6 ; ecx is our counter it points to the number of line numbers
        ; No. the values are different. We are dealing with several linenumbers in the same section.
        ; Let's check for their values.

        L0:

            On eax = edi, jmp @OutLoop
            add eax 6 ; we need to add the value in edi (IMAGE_SECTION_HEADER where we are) 6 that is the size of the line number structure
            Call IncrementSectionLineNumber
        Loop L0<

@OutLoop:


    .End_If


        Mov edi edx ; retore the path to edi

        Push esi

        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {B$ ".LineNumber" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy CoffLineNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi


        Mov D$edi ' - ' | add edi 3

        zCopy IMAGE_FILE_HEADER_Comment1
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Call WriteIndiceOnly
        zcopy {B$ " ; Hex Value:  " EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi

EndP



Proc WriteAuxiliarySymbolsRecordsFormat1Item:
    Argument @Text1, @Text2
    Uses edx,  D$SymbolTableIndex , D$SymbolTableIndex+4

        Push esi
            Call WriteObjIndice
            zCopy {B$ 'ImgAuxFmt1.Ind' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SymbolTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Mov B$edi '.' | inc edi
            zCopy D@Text1
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy D@Text2
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi


        Mov eax D@Text1

        .If D$eax = 'TagI' ; from "TagIndex" string
            ;Call WriteAuxSymFmt5DiffLabel
            Call WriteSectionHeaderSymbolConstantIndex
            Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            lodsd | Call WriteEax

        .Else_If D$eax = 'Tota'; From "TotalSize" string
            lodsd | Call WriteEax

        .Else_If D$eax+9 = 'Line'; From "PointerToLinenumber" string
            If D$esi <> 0
                Call WriteAuxSymFmt1DiffLabel
             End_If
            lodsd | Call WriteEax

        .Else_If D$eax+9 = 'Next'; From "PointerToNextFunction" string

            If D$esi <> 0
                Call WriteSectionHeaderSymbolConstantIndex
                Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            End_If

            lodsd | Call WriteEax

        .Else_If D$eax = 'Rese'; From "Reserved" string
            xor eax eax
            lodsw | Call WriteEax

        .End_If


        Mov W$edi CRLF | add edi 2


EndP


;[ImgAuxSym: B$ 'ImgAuxSym' EOS] ; Guga Note: Remove this data variable. It is not used anymore


[Fmt1TagIndex: B$ 'TagIndex' EOS]
[Fmt1TotalSize: B$ 'TotalSize' EOS]
[Fmt1PointerToLinenumber: B$ 'PointerToLinenumber' EOS]
[Fmt1PointerToNextFunction: B$ 'PointerToNextFunction' EOS]
[Fmt1Reserved: B$ 'Reserved' EOS]

Proc WriteAuxiliarySymbolsRecordsFormat1:

        Push esi
            Call WriteObjIndice
            zCopy {B$ 'ImgAuxFmt1.Ind' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SymbolTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Mov B$edi ':', W$edi+1 CRLF | add edi 3
        Pop esi

        Call WriteAuxiliarySymbolsRecordsFormat1Item Fmt1TagIndex, {B$ ': D$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat1Item Fmt1TotalSize, {B$ ': D$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat1Item Fmt1PointerToLinenumber, {B$ ': D$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat1Item Fmt1PointerToNextFunction, {B$ ': D$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat1Item Fmt1Reserved, {B$ ': W$ ' EOS}
        sub edi 2

EndP

_________________________________________________________

Proc WriteAuxiliarySymbolsRecordsFormat2Item:
    Argument @Text1, @Text2
    Uses edx, ecx, D$SymbolTableIndex, D$SymbolTableIndex+4

        Push esi
            Call WriteObjIndice
            zCopy {B$ 'ImgAuxFmt2.Ind' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SymbolTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Mov B$edi '.' | inc edi
            zCopy D@Text1
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy D@Text2
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi


        Mov eax D@Text1


        .If D$eax+5 = 'ved1' ; from "Reserved1" string
            lodsd | Call WriteEax

        .Else_If D$eax = 'Line'; From "LineNumber" string
            xor eax eax
            lodsw | Call WriteEax
            Push esi | zcopy {B$ " ; Base Line Number" EOS} | Pop esi
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If D$eax+5 = 'ved2'; From "Reserved2" string
            xor eax eax
            Mov ecx 6
            L0:
                lodsb | Call WriteEax
                Mov W$edi ", " | add edi 2
            Loop L0<
            sub edi 2

        .Else_If D$eax = 'Poin'; From "PointerToNextFunction" string

            If D$esi <> 0
                Call WriteSectionHeaderSymbolConstantIndex
                Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            End_If

            lodsd | Call WriteEax

        .Else_If D$eax+5 = 'ved3'; From "Reserved3" string
            xor eax eax
            lodsw | Call WriteEax

        .End_If

        Mov W$edi CRLF | add edi 2

EndP



[Fmt2Reserved1: B$ 'Reserved1' EOS]
[Fmt2LineNumber: B$ 'LineNumber' EOS]
[Fmt2Reserved2: B$ 'Reserved2' EOS]
[Fmt2PointerToNextFunction: B$ 'PointerToNextFunction' EOS]
[Fmt2Reserved3: B$ 'Reserved3' EOS]

Proc WriteAuxiliarySymbolsRecordsFormat2:

        Push esi
            Call WriteObjIndice
            zCopy {B$ 'ImgAuxFmt2.Ind' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SymbolTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Mov B$edi ':', W$edi+1 CRLF | add edi 3
        Pop esi

        Call WriteAuxiliarySymbolsRecordsFormat2Item Fmt2Reserved1, {B$ ': D$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat2Item Fmt2LineNumber, {B$ ': W$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat2Item Fmt2Reserved2, {B$ ': B$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat2Item Fmt2PointerToNextFunction, {B$ ': D$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat2Item Fmt2Reserved3, {B$ ': W$ ' EOS}
        sub edi 2

EndP

_________________________________________________________

Proc WriteAuxSymFmt3CharacteristicEquates:
    Uses esi;, ebx

    ;Mov ebx esi

    .If D$esi = &IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY
        zCopy {B$ '&IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If D$esi = &IMAGE_WEAK_EXTERN_SEARCH_LIBRARY
        zCopy {B$ '&IMAGE_WEAK_EXTERN_SEARCH_LIBRARY ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If D$esi = &IMAGE_WEAK_EXTERN_SEARCH_ALIAS
        zCopy {B$ '&IMAGE_WEAK_EXTERN_SEARCH_ALIAS ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .End_If


EndP

Proc WriteAuxiliarySymbolsRecordsFormat3Item:
    Argument @Text1, @Text2
    Uses edx, ecx, D$SymbolTableIndex, D$SymbolTableIndex+4

        Push esi
            Call WriteObjIndice
            zCopy {B$ 'ImgAuxFmt3.Ind' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SymbolTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Mov B$edi '.' | inc edi
            zCopy D@Text1
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy D@Text2
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi


        Mov eax D@Text1


        .If D$eax = 'TagI' ; from "TagIndex" string
            If D$esi <> 0
               Call WriteSectionHeaderSymbolConstantIndex
               Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            End_If

            lodsd | Call WriteEax

        .Else_If D$eax = 'Char'; From "Characteristics" string
            ;lodsd | Call WriteEax
            Call WriteAuxSymFmt3CharacteristicEquates
            lodsd | Call WriteEax

        .Else_If D$eax = 'Rese'; From "Reserved" string
            xor eax eax
            Mov ecx 10
            L0:
                lodsb | Call WriteEax
                Mov W$edi ", " | add edi 2
            Loop L0<
            sub edi 2

        .End_If

        Mov W$edi CRLF | add edi 2

EndP



[Fmt3TagIndex: B$ 'TagIndex' EOS]
[Fmt3Characteristics: B$ 'Characteristics' EOS]
[Fmt3Reserved: B$ 'Reserved' EOS]

Proc WriteAuxiliarySymbolsRecordsFormat3:

        Push esi
            Call WriteObjIndice
            zCopy {B$ 'ImgAuxFmt3.Ind' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SymbolTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Mov B$edi ':', W$edi+1 CRLF | add edi 3
        Pop esi

        Call WriteAuxiliarySymbolsRecordsFormat3Item Fmt3TagIndex, {B$ ': D$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat3Item Fmt3Characteristics, {B$ ': D$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat3Item Fmt3Reserved, {B$ ': B$ ' EOS}
        sub edi 2

EndP


_________________________________________________________


Proc WriteAuxiliarySymbolsRecordsFormat4:

        Push esi
            Call WriteObjIndice
            zCopy {B$ 'ImgAuxFmt4.Ind' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SymbolTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Mov B$edi ':', W$edi+1 CRLF | add edi 3
            Call WriteObjIndice
            zCopy {B$ 'ImgAuxFmt4.Ind' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SymbolTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy {B$ '.FileName: B$ ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi

        Mov edx esi | add edx 18

        .If B$esi = 0
            Mov B$edi '0' | inc edi | inc esi
        .Else

        Mov B$edi "'" | inc edi
L0:     lodsb
            If al = 0
                dec esi | jmp L1>
            End_If
        stosb | On esi < edx, jmp L0<
L1:     Mov B$edi "'" | inc edi

        .End_If

        While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ;Mov W$edi CRLF | add edi 2


EndP


__________________________________________________________



Proc WriteAuxSymFmt5DiffLabel:
    Uses esi, ebx, ecx, eax, edx

    Mov ebx D$FirstSectionPointer

    movzx ecx W$esi-18+12 ; ecx is pointing to the previous section value
    ; we need to recompute the sectionheader number

    Call InitSectionHeaderNumber

    Mov edx edi ; for keeping the path to edi, let's save it at edx

    ; Guga note this is the errros on DX9SDKSampleFramework.lib We have an 0 previous section

    On ecx = 0 , jmp C2>>

    If ecx <> 1 ; Are we pointing to thye 1st section ?
        Push ecx

            Do
                Call IncrementSectionHeaderNumber
                dec ecx
            Loop_Until ecx = 1

        Pop ecx

    End_If

    sub esi 18 ; esi is pointing to the beginning of previous Symbol

    Push edx

    If ecx <> 1     ; If we are pointing to the 1st Section, we don´ need to add it to the offset of the IMAGE_SECTION_HEADER
        Mov eax 40  ; eax is the Size of the IMAGE_SECTON_HEADER
        imul ecx    ; multiply by the section where we must go
        add ebx eax
        sub ebx 40  ; need to subtract from the Size of IMAG_SECTION_HEADER to get back to the proper path.
    End_If

    Pop edx

    ; we must point to the proper Section (IMAGE_SECTION_HEADER)

    Mov eax ebx ; The 1st String where we are (The Section in IMAGE_SECTION_HEADER)
    Mov edi esi ; edi is pointing to the beginning of the previous section. (Our string to be compared)

    Mov ecx 8   ;how many bytes in the string...char= one byte
    repe cmpsb
    jne C2>

        Mov edi edx ; retore the path to edi

        add eax 20 ; eax is pointing to PointerToRawData on IMAGE_SECTION_HEADER from the structure we label
        Mov esi D$eax ; now we point it to esi

        .If D$eax <> 0 ; Is PointerToRawData = 0 ? Is it Virtual data ? No, do next line.

            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy {B$ ".RawDataEnd" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Mov D$edi ' - ' | add edi 3

            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SectionHeaderNumber
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy {B$ ".RawData ; Hex Value:  " EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .End_If

        ExitP

    C2:

    Mov edi edx ; retore the path to edi

EndP


Proc WriteAuxSymFmt5TypeEquates:
    Uses esi, ebx

    Mov ebx esi


    .If B$ebx = &IMAGE_COMDAT_SELECT_NODUPLICATES
        zCopy {B$ '&IMAGE_COMDAT_SELECT_NODUPLICATES ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If B$ebx = &IMAGE_COMDAT_SELECT_ANY
        zCopy {B$ '&IMAGE_COMDAT_SELECT_ANY ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If B$ebx = &IMAGE_COMDAT_SELECT_SAME_SIZE
        zCopy {B$ '&IMAGE_COMDAT_SELECT_SAME_SIZE ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If B$ebx = &IMAGE_COMDAT_SELECT_EXACT_MATCH
        zCopy {B$ '&IMAGE_COMDAT_SELECT_EXACT_MATCH ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If B$ebx = &IMAGE_COMDAT_SELECT_ASSOCIATIVE
        zCopy {B$ '&IMAGE_COMDAT_SELECT_ASSOCIATIVE ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .Else_If B$ebx = &IMAGE_COMDAT_SELECT_LARGEST
        zCopy {B$ '&IMAGE_COMDAT_SELECT_LARGEST ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    .End_If


EndP


[Fmt5Length: B$ 'Length' EOS]
[Fmt5NumberOfRelocations: B$ 'NumberOfRelocations' EOS]
[Fmt5NumberOfLinenumbers: B$ 'NumberOfLinenumbers' EOS]
[Fmt5CheckSum: B$ 'CheckSum' EOS]
[Fmt5Number: B$ 'Number' EOS]
[Fmt5Selection: B$ 'Selection' EOS]
[Fmt5Reserved: B$ 'Reserved' EOS]

Proc WriteAuxiliarySymbolsRecordsFormat5Item:
    Argument @Text1, @Text2
    Uses edx, ecx;, D$SymbolTableIndex, D$SymbolTableIndex+4

        Push esi
            Call WriteObjIndice
            zCopy {B$ 'ImgAuxFmt5.Ind' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SymbolTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Mov B$edi '.' | inc edi
            zCopy D@Text1
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy D@Text2
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi


                Mov eax D@Text1

                .If D$eax = 'Leng' ; from "Length" string
                    Call WriteAuxSymFmt5DiffLabel
                    lodsd | Call WriteEax

                .Else_If D$eax+8 = 'Relo'; From "NumberOfRelocations" string
                    xor eax eax
                    lodsw | Call WriteEax

                .Else_If D$eax+8 = 'Line'; From "NumberOfLinenumbers" string
                    xor eax eax
                    lodsw | Call WriteEax

                .Else_If D$eax = 'Chec'; From "CheckSum" string
                    lodsd | Call WriteEax

                .Else_If D$eax = 'Numb'; From "Number" string

                    xor eax eax
                    lodsw | Call WriteEax

                .Else_If D$eax = 'Sele'; From "Selection" string
                    Call WriteAuxSymFmt5TypeEquates
                    xor eax eax
                    lodsb | Call WriteEax

                .Else_If D$eax = 'Rese'; From "Reserved" string
                    xor eax eax
                    Mov ecx 3
                    L0:
                        xor eax eax
                        lodsb | Call WriteEax
                        Mov W$edi ", " | add edi 2
                    Loop L0<
                    sub edi 2

                .End_If


        Mov W$edi CRLF | add edi 2


EndP


Proc WriteAuxiliarySymbolsRecordsFormat5:

        Push esi
            Call WriteObjIndice
            zCopy {B$ 'ImgAuxFmt5.Ind' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SymbolTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Mov B$edi ':', W$edi+1 CRLF | add edi 3
        Pop esi

        Call WriteAuxiliarySymbolsRecordsFormat5Item Fmt5Length, {B$ ': D$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat5Item Fmt5NumberOfRelocations, {B$ ': W$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat5Item Fmt5NumberOfLinenumbers, {B$ ': W$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat5Item Fmt5CheckSum, {B$ ': D$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat5Item Fmt5Number, {B$ ': W$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat5Item Fmt5Selection, {B$ ': B$ ' EOS}
        Call WriteAuxiliarySymbolsRecordsFormat5Item Fmt5Reserved, {B$ ': B$ ' EOS}
        sub edi 2

EndP


_______________________________________________________________


; Examples: frmMainNET.obj, program_PadraoCOM.obj, Hello World_PAdraoNET.obj
; GIven to me (Guga) by Fabricio

Proc WriteAuxiliarySymbolsRecordsFormatUnknown:
    ;Argument @Pointer

    Push esi
        Call WriteObjIndice
        zCopy {B$ 'ImgAuxSym' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SymbolTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy {B$ 'FormatUnknwon: B$ ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    Pop esi

;        Mov esi D@Pointer, ecx 18
        Mov ecx 18

L0:     lodsb | and eax 0FF | Call WriteEax
        Mov W$edi ', ' | add edi 2 | loop L0<
        sub edi 2
        ;Mov B$edi-2 "'" | dec edi
EndP

_______________________________________________________________

Proc WriteAuxiliarySymbolsRecords:
    Arguments @Number
    Uses ecx, ebx

    .Do

        Call WriteSymbolConstantIndex
        Call IncrementSymbolIndexRecord

        Mov W$edi CRLF | add edi 2
        Mov B$edi '[' | inc edi

        Call IncrementSymbolTableRecord

            ..If D$SymbolStorageClass = &IMAGE_SYM_CLASS_EXTERNAL
            ; example at libgccguga.a

                .If B$esi-4 = (&IMAGE_SYM_DTYPE_FUNCTION shl 4) + &IMAGE_SYM_TYPE_NULL ; Type1Complex = 020
                    ;If W$esi-6 >= 0  ;
                    ; SectionNumber >= 0. Once again the documentation lied. We can have a 0 section number
                        Call WriteAuxiliarySymbolsRecordsFormat1
                    ;End_If
                .End_If

            ..Else_If D$SymbolStorageClass = &IMAGE_SYM_CLASS_FUNCTION
            ; example at shit.obj
                Call WriteAuxiliarySymbolsRecordsFormat2

            ..Else_If D$SymbolStorageClass = &IMAGE_SYM_CLASS_WEAK_EXTERNAL
            ; example at stats.lib ; Libdc.lib
                .If W$esi-6 = &IMAGE_SYM_UNDEFINED  ; SectionNumber = &IMAGE_SYM_UNDEFINED
                    If D$esi-10 = 0 ; Value member = 0
                        Call WriteAuxiliarySymbolsRecordsFormat3
                    End_If
                .End_If

            ..Else_If D$SymbolStorageClass = &IMAGE_SYM_CLASS_FILE
                Call WriteAuxiliarySymbolsRecordsFormat4

            ..Else_If D$SymbolStorageClass = &IMAGE_SYM_CLASS_STATIC
                Call WriteAuxiliarySymbolsRecordsFormat5

            ..Else
                Call WriteAuxiliarySymbolsRecordsFormatUnknown

            ..End_If

        Mov B$edi ']', D$edi+1 CRLF2 | add edi 5
        dec D$CoffSymbolsNumber ; decrement our counter from the total amount symbols
        dec D@Number ; decrement the total amount of Auxiliary Symbols

    .Loop_Until D@Number = 0

EndP

____________________________________________________________________________________________


[SymbolTableTitle: "
_________________________________________________________

; Symbols Table Structure IMAGE_SYMBOL
_________________________________________________________


" EOS]
[SymbolTableShortName: B$ 'NameShort' EOS]
[SymbolTableLongNameZero: B$ 'NameZero' EOS]
[SymbolTableLongNameOffset: B$ 'NameLongOffset' EOS]
[SymbolTableValue: B$ 'Value' EOS]
[SymbolTableSectionNumber: B$ 'SectionNumber' EOS]
[SymbolTableTypeComplex: B$ 'Type1Complex' EOS]
[SymbolTableTypeBase: B$ 'Type1Base' EOS]
[SymbolTableStorageClass: B$ 'StorageClass' EOS]
[SymbolTableNumberOfAuxSymbols: B$ 'NumberOfAuxSymbols' EOS]


;[PointerToSymbolsRecords: D$ ?]

[SymbolTableRecord: B$ '000001' EOS]


InitSymbolTableRecord:
    Mov D$SymbolTableRecord '0000', D$SymbolTableRecord+4 '01'
ret


IncrementSymbolTableRecord:
    lea ebx D$SymbolTableRecord+5 | inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret


Proc WriteImageSymbolTableFieldName:
    Argument @String1 @String2
    Uses esi, ecx, ebx

   ; If D@String2 < SymbolTableShortName1
   ;      Mov eax D@String1, ebx D@String2
   ;      int3
   ; End_If

        Call WriteObjIndice
        zCopy D@String1
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy SymbolTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        zCopy D@String2
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

EndP
;;

;;
&IMAGE_SYM_UNDEFINED 0 Symbol record is not yet assigned a section.
    If the value is 0 this indicates a references to an external symbol 
    defined Elsewhere. If the value is non-zero this is a common symbol 
    with a size specified by the value. 
&IMAGE_SYM_ABSOLUTE -1 The symbol has an absolute (non-relocatable) value 
    and is not an address. 
&IMAGE_SYM_DEBUG -2 The symbol provides general type or debugging information 
    but does not correspond to a section. Microsoft tools use this setting 
    along with .file records (storage class FILE). 
;;
;;
WriteRelocSectionNumberEquate:
    Push esi
        ;Mov ebx D$PointerToSymbolsRecords

        If W$esi = &IMAGE_SYM_UNDEFINED
            zCopy {B$ '&IMAGE_SYM_UNDEFINED ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Else_If W$esi = &IMAGE_SYM_ABSOLUTE
            zCopy {B$ '&IMAGE_SYM_ABSOLUTE ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Else_If W$esi = &IMAGE_SYM_DEBUG
            zCopy {B$ '&IMAGE_SYM_DEBUG ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        End_If
    Pop esi
ret
;;
;;
WriteRelocSectionNumberEquate_Old:
    Push esi
        Mov ebx D$PointerToSymbolsRecords

        If W$ebx = &IMAGE_SYM_UNDEFINED
            zCopy {B$ ' ; &IMAGE_SYM_UNDEFINED' EOS}
        Else_If W$ebx = &IMAGE_SYM_ABSOLUTE
            zCopy {B$ ' ; &IMAGE_SYM_ABSOLUTE' EOS}
        Else_If W$ebx = &IMAGE_SYM_DEBUG
            zCopy {B$ ' ; &IMAGE_SYM_DEBUG' EOS}
        End_If
    Pop esi
ret
;;

;;
The most significative byte equates are:

&IMAGE_SYM_DTYPE_NULL
&IMAGE_SYM_DTYPE_POINTER
&IMAGE_SYM_DTYPE_FUNCTION
&IMAGE_SYM_DTYPE_ARRAY


The less signfiicative byte are:

&IMAGE_SYM_TYPE_NULL
&IMAGE_SYM_TYPE_VOID
&IMAGE_SYM_TYPE_CHAR
&IMAGE_SYM_TYPE_SHORT
&IMAGE_SYM_TYPE_INT
&IMAGE_SYM_TYPE_LONG
&IMAGE_SYM_TYPE_FLOAT
&IMAGE_SYM_TYPE_DOUBLE
&IMAGE_SYM_TYPE_STRUCT
&IMAGE_SYM_TYPE_UNION
&IMAGE_SYM_TYPE_ENUM
&IMAGE_SYM_TYPE_MOE
&IMAGE_SYM_TYPE_BYTE
&IMAGE_SYM_TYPE_WORD
&IMAGE_SYM_TYPE_UINT
&IMAGE_SYM_TYPE_DWORD
;;
;;
[RelocTypeD: D$ ?
 RelocType: D$ ?]
;;
;;
        .If_And eax >= 32, eax <= 65535 ; Check for Corrupted library. Reserved Bits are not 0

            Call LibScan_ErrManager IMP_OBJ_RESBIT_ERR

            If eax = &FALSE ; The user pressed No
                ExitP

            Else_If eax = &TRUE ; The user pressed Yes. We will Zero all reserved bits for him continue the parsing.
                Mov eax D@Flags ; Restore the original value of eax to be fixed
                Mov ah 0 ; Clear High Bits Flags
                btr eax 5 | btr eax 6 | btr eax 7 ; Clear Bits 5 to 7

            End_If

        .End_If

;;
;;
;WriteRelocTypeEquates:
Proc WriteSymbolTypeEquates:
    Uses esi, ebx

        .If B$esi > 63 ; Check for Corrupted library. The actual maximum value is 63 (03F)

            Call LibScan_ErrManager IMP_OBJ_RESBIT_ERR

            If eax = &FALSE ; The user pressed No

EndP

            Else_If eax = &TRUE ; The user pressed Yes. We will Zero all reserved bits for him continue the parsing.

                ; Clear all high flags, returning only in the targeting Byte
                xor eax eax | lodsb | btr eax 6 | btr eax 7 ; Clear Bits 6 and , that are what exceed the limit of 63
                Mov ebx eax
            End_If

        .Else

            xor eax eax | lodsb | Mov ebx eax

        .End_If

        and eax 0F | shr ebx 4

        ;Mov D$RelocType eax, D$RelocTypeD ebx

        If ebx = &IMAGE_SYM_DTYPE_NULL
            zCopy {B$ '(&IMAGE_SYM_DTYPE_NULL shl 4)' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Else_If ebx = &IMAGE_SYM_DTYPE_POINTER
            zCopy {B$ '(&IMAGE_SYM_DTYPE_POINTER shl 4)' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Else_If ebx = &IMAGE_SYM_DTYPE_FUNCTION
            zCopy {B$ '(&IMAGE_SYM_DTYPE_FUNCTION shl 4)' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Else_If ebx = &IMAGE_SYM_DTYPE_ARRAY
            zCopy {B$ '(&IMAGE_SYM_DTYPE_ARRAY shl 4)' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        End_If

        .If eax = &IMAGE_SYM_TYPE_NULL
            zCopy {B$ ' + &IMAGE_SYM_TYPE_NULL' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_TYPE_VOID
            zCopy {B$ ' + &IMAGE_SYM_TYPE_VOID' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_TYPE_CHAR
            zCopy {B$ ' + &IMAGE_SYM_TYPE_CHAR' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_TYPE_SHORT
            zCopy {B$ ' + &IMAGE_SYM_TYPE_SHORT' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_TYPE_INT
            zCopy {B$ ' + &IMAGE_SYM_TYPE_INT' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_TYPE_LONG
            zCopy {B$ ' + &IMAGE_SYM_TYPE_LONG' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_TYPE_FLOAT
            zCopy {B$ ' + &IMAGE_SYM_TYPE_FLOAT' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_TYPE_DOUBLE
            zCopy {B$ ' + &IMAGE_SYM_TYPE_DOUBLE' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_TYPE_STRUCT
            zCopy {B$ ' + &IMAGE_SYM_TYPE_STRUCT' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_TYPE_UNION
            zCopy {B$ ' + &IMAGE_SYM_TYPE_UNION' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_TYPE_ENUM
            zCopy {B$ ' + &IMAGE_SYM_TYPE_ENUM' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_TYPE_MOE
            zCopy {B$ ' + &IMAGE_SYM_TYPE_MOE' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_TYPE_BYTE
            zCopy {B$ ' + &IMAGE_SYM_TYPE_BYTE' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_TYPE_WORD
            zCopy {B$ ' + &IMAGE_SYM_TYPE_WORD' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_TYPE_UINT
            zCopy {B$ ' + &IMAGE_SYM_TYPE_UINT' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_TYPE_DWORD
            zCopy {B$ ' + &IMAGE_SYM_TYPE_DWORD' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .End_If

        zCopy {B$ ' ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

EndP

;;
;;
&IMAGE_SYM_CLASS_END_OF_FUNCTION -1 Special symbol representing end of function, for debugging purposes. 
&IMAGE_SYM_CLASS_NULL 0 No storage class assigned. 
&IMAGE_SYM_CLASS_AUTOMATIC 1 Automatic (stack) variable. The Value field specifies stack frame offset. 
&IMAGE_SYM_CLASS_EXTERNAL 2 Used by Microsoft tools for external symbols. The Value field indicates the size if the section number is IMAGE_SYM_UNDEFINED (0). If the section number is not 0, then the Value field specifies the offset within the section. 
&IMAGE_SYM_CLASS_STATIC 3 The Value field specifies the offset of the symbol within the section. If the Value is 0, then the symbol represents a section name. 
&IMAGE_SYM_CLASS_REGISTER 4 Register variable. The Value field specifies register number. 
&IMAGE_SYM_CLASS_EXTERNAL_DEF 5 Symbol is defined externally. 
&IMAGE_SYM_CLASS_LABEL 6 Code label defined within the module. The Value field specifies the offset of the symbol within the section. 
&IMAGE_SYM_CLASS_UNDEFINED_LABEL 7 Reference to a code label not defined. 
&IMAGE_SYM_CLASS_MEMBER_OF_STRUCT 8 Structure member. The Value field specifies nth member. 
&IMAGE_SYM_CLASS_ARGUMENT 9 Formal argument (parameter)of a function. The Value field specifies nth argument. 
&IMAGE_SYM_CLASS_STRUCT_TAG 10 Structure tag-name entry. 
&IMAGE_SYM_CLASS_MEMBER_OF_UNION 11 Union member. The Value field specifies nth member. 
&IMAGE_SYM_CLASS_UNION_TAG 12 Union tag-name entry. 
&IMAGE_SYM_CLASS_TYPE_DEFINITION 13 Typedef entry. 
&IMAGE_SYM_CLASS_UNDEFINED_STATIC 14 Static data declaration. 
&IMAGE_SYM_CLASS_ENUM_TAG 15 Enumerated type tagname entry. 
&IMAGE_SYM_CLASS_MEMBER_OF_ENUM 16 Member of enumeration. Value specifies nth member. 
&IMAGE_SYM_CLASS_REGISTER_PARAM 17 Register parameter. 
&IMAGE_SYM_CLASS_BIT_FIELD 18 Bit-field reference. Value specifies nth bit in the bit field. 
&IMAGE_SYM_CLASS_BLOCK 100 A .bb (beginning of block) or .eb (end of block) record. Value is the relocatable address of the code location. 
&IMAGE_SYM_CLASS_FUNCTION 101 Used by Microsoft tools for symbol records that define the extent of a function: begin function (named .bf), end function (.ef), and lines in function (.lf). For .lf records, Value gives the number of source lines in the function. For .ef records, Value gives the size of function code. 
&IMAGE_SYM_CLASS_END_OF_STRUCT 102 End of structure entry. 
&IMAGE_SYM_CLASS_FILE 103 Used by Microsoft tools, as well as traditional COFF format, for the source-file symbol record. The symbol is followed by auxiliary records that name the file. 
&IMAGE_SYM_CLASS_SECTION 104 Definition of a section (Microsoft tools use STATIC storage class instead). 
&IMAGE_SYM_CLASS_WEAK_EXTERNAL 105 Weak external. See Section 5.5.3, Auxiliary Format 3: Weak Externals, for more information. 
;;
;;


[SymbolStorageClass: D$ 0]

WriteRelocStorageClassEquate:
    Push esi

        movzx eax B$esi | Mov D$SymbolStorageClass eax

        .If eax = &IMAGE_SYM_CLASS_ARGUMENT
            zCopy {B$ '&IMAGE_SYM_CLASS_ARGUMENT ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_AUTOMATIC
            zCopy {B$ '&IMAGE_SYM_CLASS_AUTOMATIC ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_BIT_FIELD
            zCopy {B$ '&IMAGE_SYM_CLASS_BIT_FIELD ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_BLOCK
            zCopy {B$ '&IMAGE_SYM_CLASS_BLOCK ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

         .Else_If eax = &IMAGE_SYM_CLASS_END_OF_FUNCTION
            zCopy {B$ '&IMAGE_SYM_CLASS_END_OF_FUNCTION ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

         .Else_If eax = &IMAGE_SYM_CLASS_END_OF_STRUCT
            zCopy {B$ '&IMAGE_SYM_CLASS_END_OF_STRUCT ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_ENUM_TAG
            zCopy {B$ '&IMAGE_SYM_CLASS_ENUM_TAG ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_EXTERNAL
            zCopy {B$ '&IMAGE_SYM_CLASS_EXTERNAL ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_EXTERNAL_DEF
            zCopy {B$ '&IMAGE_SYM_CLASS_EXTERNAL_DEF ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_FAR_EXTERNAL
            zCopy {B$ '&IMAGE_SYM_CLASS_FAR_EXTERNAL ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_FILE
            zCopy {B$ '&IMAGE_SYM_CLASS_FILE ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_FUNCTION
            zCopy {B$ '&IMAGE_SYM_CLASS_FUNCTION ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_LABEL
            zCopy {B$ '&IMAGE_SYM_CLASS_LABEL ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_MEMBER_OF_ENUM
            zCopy {B$ '&IMAGE_SYM_CLASS_MEMBER_OF_ENUM ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_MEMBER_OF_STRUCT
            zCopy {B$ '&IMAGE_SYM_CLASS_MEMBER_OF_STRUCT ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_MEMBER_OF_UNION
            zCopy {B$ '&IMAGE_SYM_CLASS_MEMBER_OF_UNION ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_NULL
            zCopy {B$ '&IMAGE_SYM_CLASS_NULL ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_REGISTER
            zCopy {B$ '&IMAGE_SYM_CLASS_REGISTER ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_REGISTER_PARAM
            zCopy {B$ '&IMAGE_SYM_CLASS_REGISTER_PARAM ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_SECTION
            zCopy {B$ '&IMAGE_SYM_CLASS_SECTION ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_STATIC
            zCopy {B$ '&IMAGE_SYM_CLASS_STATIC ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_STRUCT_TAG
            zCopy {B$ '&IMAGE_SYM_CLASS_STRUCT_TAG ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_TYPE_DEFINITION
            zCopy {B$ '&IMAGE_SYM_CLASS_TYPE_DEFINITION ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_UNDEFINED_LABEL
            zCopy {B$ '&IMAGE_SYM_CLASS_UNDEFINED_LABEL ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_UNDEFINED_STATIC
            zCopy {B$ '&IMAGE_SYM_CLASS_UNDEFINED_STATIC ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_UNION_TAG
            zCopy {B$ '&IMAGE_SYM_CLASS_UNION_TAG ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .Else_If eax = &IMAGE_SYM_CLASS_WEAK_EXTERNAL
            zCopy {B$ '&IMAGE_SYM_CLASS_WEAK_EXTERNAL ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        .End_If

    Pop esi
ret



Proc WriteSymbolTableHeaderItem:
    Argument @Text1, @Text2
    Uses edx;, eax

        Push esi
            Call WriteObjIndice
            zCopy {B$ 'ImgSym' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SymbolTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Mov B$edi '.' | inc edi
            zCopy D@Text1
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy D@Text2
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi


                Mov eax D@Text1

                ..If D$eax+4 = 'Shor' ; from "NameShort" string

                    Mov edx esi | add edx 8
                    Mov B$edi "'" | inc edi
L0:                 lodsb
                    If al = 0
                        dec esi | jmp L1>
                    End_If
                    stosb | On esi < edx, jmp L0<
L1:                 Mov B$edi "'" | inc edi
                    While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

                ..Else_If D$eax+4 = 'Zero'; From "NameZero" string
                    lodsd | Call WriteEax

                ..Else_If D$eax+8 = 'Offs'; From "NameLongOffset" string

                    Call WriteSectionHeaderPointerToStringTableDiffLabel
                    lodsd | Call WriteEax

                ..Else_If D$eax = 'Valu'; From "Value" string

                    ;Call WriteCharacteristicsEquates
                    lodsd | Call WriteEax

                        .If D$esi-4 <> 0 ; If the Value member is not Zero, do next line
                            If B$esi+4 = &IMAGE_SYM_CLASS_SECTION ; If StorageClass member is IMAGE_SYM_CLASS_SECTION, do next line
                                Push esi
                                Push D$esi-4
                                Push eax
                                Mov eax D$esi-4
                                Call WriteCharacteristicsEquates
                                Pop eax
                                Pop D$esi-4
                                Pop esi

                            End_If
                        .End_If

                ..Else_If D$eax = 'Sect'; From "SectionNumber" string
                    Call WriteRelocSectionNumberEquate
                    xor eax eax
                    lodsw | Call WriteEax

                ..Else_If D$eax = 'Type'; From "Type1Complex" string
                    Call WriteSymbolTypeEquates
                    xor eax eax
                    lodsb | Call WriteEax

                ..Else_If D$eax = '1Bas'; From "Type1Base" string
                    Call WriteSymbolTypeEquates
                    xor eax eax
                    lodsb | Call WriteEax

                ..Else_If D$eax = 'Stor'; From "StorageClass" string

                    Call WriteRelocStorageClassEquate
                    xor eax eax
                    lodsb | Call WriteEax

                ..Else_If D$eax+8 = 'AuxS'; From "NumberOfAuxSymbols" string
                    xor eax eax
                    lodsb | Call WriteEax

;;
;;
                ..Else_If D$eax = 'Misc'; From "MiscVirtualSize" string

                    Call WriteSectionHeaderVirtualSizeDiffLabel
                    Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi
;;
;;

                ;..Else

                    ;lodsd | Call WriteEax

                ..End_If


        Mov W$edi CRLF | add edi 2
EndP

____________________________________________________________

[SymbolTableIndex: B$ '000000' EOS]


InitSymbolIndexRecord:
    Mov D$SymbolTableIndex '0000', D$SymbolTableIndex+4 '00'
ret


IncrementSymbolIndexRecord:
    lea ebx D$SymbolTableIndex+5 | inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret

Proc WriteSymbolConstantIndex:
    Uses esi, ecx

            Mov B$edi '[' | inc edi
            Call WriteObjIndice

            ; Fix the label to show in Caps and replace the '." with an "_"
            ; The 1st char in "Obj000000." is in Caps, so we don't need to overwrite the "O" char

            Push edi
                Mov B$edi-1 '_', W$edi-9 'BJ'
            Pop edi

            zCopy {B$ 'SYMBOLINDEX' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SymbolTableIndex
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Mov B$edi SPC | inc edi

            Mov esi SymbolTableIndex

            .If_And D$esi = '0000', D$SymbolTableIndex+4 = '00'

                Mov B$edi '0' | inc edi
            .Else

                Mov ecx 6 ; Size of the SymbolTable String
            L0:

                While B$esi <> '0'

                    L1:
                        movsb
                    Loop L1<
                    On ecx = 0, jmp @Out

                End_While

                inc esi
            Loop L0<

            .End_If
@Out:
            zCopy {B$ "] ; Symbol Index Constant used in IMAGE_RELOCATION Structure.", W$ CRLF, 0}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi


EndP

____________________________________________________________


; What do we need here ?
; CoffSymbolsPointer = Pointer to the Coff symbols Table
; CoffSymbolsNumber = Amount of Symbols Table structures

; The values where from GetCoffIMAGE_FILE_HEADER

[AuxSymbolCount: D$ 0]

[StringtableCheckFlag: D$ &FALSE]

[SymbolTableNameLongMessage: B$ "________________________________________________________________________

; Name Label indirectly addressed at NameLongOffset.
; The name of the Symbol is: " EOS]


WriteImageSymbolTable:

    ; Initialise the String Table Checking.

    Mov D$StringtableCheckFlag &FALSE

    Call InitSymbolTableRecord
    Call InitSymbolIndexRecord

    zCopy SymbolTableTitle
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    Mov esi D$CoffSectionBase
    add esi D$CoffSymbolsPointer

.Do

    If B$esi = 0

        Push esi
            zCopy SymbolTableNameLongMessage
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi

            Mov ecx D$PointerToStringTable

        Push esi
            add ecx D$esi+4 | Mov esi ecx
            While B$esi <> 0 | movsb | End_While
            zCopy {W$ CRLF, B$ "________________________________________________________________________", D$ CRLF2 0}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi

    End_If

        Call WriteSymbolConstantIndex
        Call IncrementSymbolIndexRecord ; Increment it for the next Normal Symbol or Auxiliary Symbol
        Mov W$edi CRLF | add edi 2

    .If_And W$esi+12 = &IMAGE_SYM_UNDEFINED, B$esi+16 = &IMAGE_SYM_CLASS_EXTERNAL
        Push esi
        zCopy {B$ "; This symbol is defined externally. It can be a Dll function or a runtime function", D$ CRLF2 0}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi

    .Else_If B$esi+16 = &IMAGE_SYM_CLASS_SECTION

        If W$esi+12 = &IMAGE_SYM_UNDEFINED
            Push esi
            zCopy {B$ "; This symbol represents the Section Name. It's not used because it is not defined in any Section." , W$ CRLF, B$ "; However, the value member is the Characteristics of a Section if existant." , D$ CRLF2 0}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Pop esi
        Else
            Push esi
            zCopy {B$ "; This symbol represents the Section Name. The value member is the Characteristics of the Section," , W$ CRLF, B$ "; but it may not be the same as what is found on the Section Structure.", D$ CRLF2 0}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Pop esi
        End_If
    .End_If

        Push esi
            Mov B$edi '[' | inc edi
            Call WriteObjIndice
            zCopy {B$ 'ImgSym' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy SymbolTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            Mov B$edi ':', W$edi+1 CRLF | add edi 3
        Pop esi

    .If B$esi = 0

        If D$esi+4 <> 0 ; need this flag to check if we have String Table pointer or not.
            Mov D$StringtableCheckFlag &TRUE
        End_If

        Call WriteSymbolTableHeaderItem SymbolTableLongNameZero, {B$ ': D$ ' EOS}
        Call WriteSymbolTableHeaderItem SymbolTableLongNameOffset, {B$ ': D$ ' EOS}

    .Else

        Call WriteSymbolTableHeaderItem SymbolTableShortName, {B$ ': B$ ' EOS}

    .End_If


    Call WriteSymbolTableHeaderItem SymbolTableValue, {B$ ': D$ ' EOS}
    Call WriteSymbolTableHeaderItem SymbolTableSectionNumber, {B$ ': W$ ' EOS}
    Call WriteSymbolTableHeaderItem SymbolTableTypeComplex, {B$ ': B$ ' EOS}
    Call WriteSymbolTableHeaderItem SymbolTableTypeBase, {B$ ': B$ ' EOS}
    Call WriteSymbolTableHeaderItem SymbolTableStorageClass, {B$ ': B$ ' EOS}
    Call WriteSymbolTableHeaderItem SymbolTableNumberOfAuxSymbols, {B$ ': B$ ' EOS}

    sub edi 2
    Mov B$edi ']' | inc edi ; Close the bracket

    dec D$CoffSymbolsNumber ; decrement our counter

    If B$esi-1 <> 0 ; Is Auxiliary Value = 0 ? No, do next line.

        movzx eax B$esi-1 | Mov D$AuxSymbolCount eax
        Mov D$edi CRLF2 | add edi 4
        Call WriteAuxiliarySymbolsRecords eax

    Else
        ; To prevent adding extra Paragraphs (8 Bytes) we need this Else macro, because the end of the
        ; auxiliary record before, already is adding 4 bytes (CRLF2) on exit.
        Mov D$edi CRLF2 | add edi 4

    End_If

        Call IncrementSymbolTableRecord

    .Loop_Until D$CoffSymbolsNumber = 0

ret


[PointerToStringTable: D$ 0]

; This function is used to calculate the Pointer to the String table. All we are doing is compute
; the real size of the Symbols Structures (With the Auxiliary Symbols) and adding it to the Coff Base

GetStringTablePointer:
    pushad

    Mov esi D$CoffSectionBase
    add esi D$CoffSymbolsPointer
    Mov ecx D$CoffSymbolsNumber

    .Do
        add esi 18 ; The size of each IMAGE_SYMBOL Structure
        dec ecx

        If B$esi-1 <> 0 ; Is Auxiliary Value = 0 ? No, do next line.
            movzx eax B$esi-1; | Mov D$AuxSymbolCount eax The amount of auxiliary symbols found on this Symbol structure
                ;Call WriteAuxiliarySymbolsRecords eax

            Do
                add esi 18 ; Add to the size of each Auxiliary Symbol
                dec ecx ;decrement our counter from the total amount of Symbols
                dec eax ; decrement the total amount of Auxiliary Symbols
            Loop_Until eax = 0 ; Did we finished all Auxiliary symbols for this Symbol ?

        End_If

    .Loop_Until ecx = 0

    Mov D$PointerToStringTable esi

    popad

ret



[StringTableRecord: B$ '000001' EOS]


InitStringTableRecord:
    Mov D$StringTableRecord '0000', D$StringTableRecord+4 '01'
ret


IncrementStringTableRecord:
    lea ebx D$StringTableRecord+5 | inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret


[StringTableTitle: "
_________________________________________________________

; Strings Table
_________________________________________________________


" EOS]


WriteImageSymbolStringsTable:

    ; Initialize the String Record Counter

    Call InitStringTableRecord

    Push esi
        zCopy StringTableTitle
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Mov B$edi '[' | inc edi
        Call WriteObjIndice
        zCopy {B$ 'StringTableSize: D$ ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Call WriteObjIndice
        zCopy {B$ 'StringDataEnd - ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Call WriteObjIndice
        zCopy {B$ 'StringTableSize] ; Hex Value:  ' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

    Pop esi

    Mov edx esi | add edx D$esi ; We will use edx as a counter delimiter for the strings

    lodsd | Call WriteEax
    Push esi | zCopy {D$ CRLF2, B$ "; Strings Array", D$ CRLF2 0} | Pop esi
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi


    Push esi
        Mov B$edi '[' | inc edi
        Call WriteObjIndice
        zCopy {B$ 'StringData' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Mov B$edi ':', W$edi+1 CRLF | add edi 3
    Pop esi


   .Do

        Push esi
            Call WriteObjIndice
            zCopy {B$ 'StringData' EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy StringTableRecord
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

            zCopy {B$ ": B$ '" EOS}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi


        While B$esi <> 0 | movsb | End_While | inc esi | On B$esi = 0, Mov edx 0

        Mov D$edi "', 0" | add edi 4
        Mov W$edi CRLF | add edi 2

        Call IncrementStringTableRecord

    .Loop_Until esi >= edx

    sub edi 2

       Push esi
            Mov W$edi CRLF | add edi 2
            Call WriteObjIndice
            zCopy {B$ "StringDataEnd:]", W$ CRLF, 0}
        Push esi | Mov esi {B$ '&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__' EOS} | L0: test B$esi 0_FF | jz P0> | movsb | jmp L0< | P0: Pop esi

        Pop esi

ret


____________________________________________________________________________________________

[CoffSectionBase: D$ ?]

GetCoffListing:
    Mov D$CoffSectionBase esi

    Call GetCoffIMAGE_FILE_HEADER

    If D$SizeOfOptionalHeaderInObj <> 0
        Push esi
            Call GetCoffIMAGE_OPTIONAL_HEADER
        Pop esi
        add esi D$SizeOfOptionalHeaderInObj
    End_If

    Call InitSectionHeaderNumber
    Mov ecx D$ObjNumberOfSections

    .If ecx <> 0 ; If Section NUmber is not 0, do all checkings

        Mov D$FirstSectionPointer esi

        Push esi, ecx
        L0:
            Push ecx
            Call GetCoffSectionHeader
            Call IncrementSectionHeaderNumber
            Pop ecx
        loop L0<
        Pop ecx, esi

        Call InitSectionHeaderNumber
        Call InitSectionRelocNumber
        Mov esi D$FirstSectionPointer

        If D$ObjNumberOfSections <> 0
            L0:
                Push ecx, esi
                Call IdentifyRawDataType
                Call GetCoffSectionsVariables
                Call WriteCoffSectionData
                On W$NumberOfRelocations <> 0, Call WriteCoffReloc
                On W$NumberOfLineNumbers <> 0, Call WriteCoffLineNumber
                Call IncrementSectionHeaderNumber
                Pop esi, ecx
                add esi 40
            loop L0<
        End_If

        If D$CoffSymbolsPointer <> 0
            Call GetStringTablePointer
            Call WriteImageSymbolTable
            ; When we don´t have any StringTable pointers, we bypass the next Call
            On D$StringtableCheckFlag = &TRUE, Call WriteImageSymbolStringsTable
        End_If

    .Else ; Else, if section number is 0, perform only the checkings for the Symbol Pointer. Only this because the Optional
          ; Header check were already performed. This was because a problem like this in corelibc.lib (Pelles file)

        If D$CoffSymbolsPointer <> 0
            Call GetStringTablePointer
            Call WriteImageSymbolTable
            ; When we don´t have any StringTable pointers, we bypass the next Call
            On D$StringtableCheckFlag = &TRUE, Call WriteImageSymbolStringsTable
        End_If


    .End_If

ret
____________________________________________________________________________________________
;;
;;
  Values set in 'FirstSectionPointer', 'CoffSectionSize', 'CoffPointerToData'
  by 'GetCoffSectionsVariables'.
;;
;;

__________________________________________________________________

Proc WriteRawDataLinkerDirectiveReport:
    Uses esi, eax, edx

        Mov edx esi | add edx ecx

        .If B$esi = 0
            Mov B$edi '0' | inc edi | inc esi
        .Else

            Mov D$edi '    ' | add edi 4
L0:         lodsb
            If al = 0
                dec esi | jmp L1>

            Else_If al = SPC
                Mov W$edi CRLF, D$edi+2 '    ' | add edi 6

            Else
                stosb
            End_If
            On esi < edx, jmp L0<

L1:

        .End_If
;ret
EndP

__________________________________________________________________

;WriteRelocStorageClassEquate

[DebugSIndexValue: D$ 0]

WriteDebugSIndexEquate:
    Push esi

        movzx eax W$esi | Mov D$DebugSIndexValue eax

        .If eax = &S_COMPILE
            zCopy {B$ '&S_COMPILE ; Hex Value:  ' EOS}
        .Else_If eax = &S_REGISTER
            zCopy {B$ '&S_REGISTER ; Hex Value:  ' EOS}
        .Else_If eax = &S_CONSTANT
            zCopy {B$ '&S_CONSTANT ; Hex Value:  ' EOS}
        .Else_If eax = &S_UDT
            zCopy {B$ '&S_UDT ; Hex Value:  ' EOS}
        .Else_If eax = &S_SSEARCH
            zCopy {B$ '&S_SSEARCH ; Hex Value:  ' EOS}
        .Else_If eax = &S_END
            zCopy {B$ '&S_END ; Hex Value:  ' EOS}
        .Else_If eax = &S_SKIP
            zCopy {B$ '&S_SKIP ; Hex Value:  ' EOS}
        .Else_If eax = &S_CVRESERVE
            zCopy {B$ '&S_CVRESERVE ; Hex Value:  ' EOS}
        .Else_If eax = &S_OBJNAME
            zCopy {B$ '&S_OBJNAME ; Hex Value:  ' EOS}
        .Else_If eax = &S_ENDARG
            zCopy {B$ '&S_ENDARG ; Hex Value:  ' EOS}
        .Else_If eax = &S_COBOLUDT
            zCopy {B$ '&S_COBOLUDT ; Hex Value:  ' EOS}
        .Else_If eax = &S_MANYREG
            zCopy {B$ '&S_MANYREG ; Hex Value:  ' EOS}
        .Else_If eax = &S_RETURN
            zCopy {B$ '&S_RETURN ; Hex Value:  ' EOS}
        .Else_If eax = &S_ENTRYTHIS
            zCopy {B$ '&S_ENTRYTHIS ; Hex Value:  ' EOS}
        .Else_If eax = &S_BPREL16
            zCopy {B$ '&S_BPREL16 ; Hex Value:  ' EOS}
        .Else_If eax = &S_LDATA16
            zCopy {B$ '&S_LDATA16 ; Hex Value:  ' EOS}
        .Else_If eax = &S_GDATA16
            zCopy {B$ '&S_GDATA16 ; Hex Value:  ' EOS}
        .Else_If eax = &S_PUB16
            zCopy {B$ '&S_PUB16 ; Hex Value:  ' EOS}
        .Else_If eax = &S_LPROC16
            zCopy {B$ '&S_LPROC16 ; Hex Value:  ' EOS}
        .Else_If eax = &S_GPROC16
            zCopy {B$ '&S_GPROC16 ; Hex Value:  ' EOS}
        .Else_If eax = &S_THUNK16
            zCopy {B$ '&S_THUNK16 ; Hex Value:  ' EOS}
        .Else_If eax = &S_BLOCK16
            zCopy {B$ '&S_BLOCK16 ; Hex Value:  ' EOS}
        .Else_If eax = &S_WITH16
            zCopy {B$ '&S_WITH16 ; Hex Value:  ' EOS}
        .Else_If eax = &S_LABEL16
            zCopy {B$ '&S_LABEL16 ; Hex Value:  ' EOS}
        .Else_If eax = &S_CEXMODEL16
            zCopy {B$ '&S_CEXMODEL16 ; Hex Value:  ' EOS}
        .Else_If eax = &S_VFTPATH16
            zCopy {B$ '&S_VFTPATH16 ; Hex Value:  ' EOS}
        .Else_If eax = &S_REGREL16
            zCopy {B$ '&S_REGREL16 ; Hex Value:  ' EOS}
        .Else_If eax = &S_BPREL32
            zCopy {B$ '&S_BPREL32 ; Hex Value:  ' EOS}
        .Else_If eax = &S_LDATA32
            zCopy {B$ '&S_LDATA32 ; Hex Value:  ' EOS}
        .Else_If eax = &S_GDATA32
            zCopy {B$ '&S_GDATA32 ; Hex Value:  ' EOS}
        .Else_If eax = &S_PUB32
            zCopy {B$ '&S_PUB32 ; Hex Value:  ' EOS}
        .Else_If eax = &S_LPROC32
            zCopy {B$ '&S_LPROC32 ; Hex Value:  ' EOS}
        .Else_If eax = &S_GPROC32
            zCopy {B$ '&S_GPROC32 ; Hex Value:  ' EOS}
        .Else_If eax = &S_THUNK32
            zCopy {B$ '&S_THUNK32 ; Hex Value:  ' EOS}
        .Else_If eax = &S_BLOCK32
            zCopy {B$ '&S_BLOCK32 ; Hex Value:  ' EOS}
        .Else_If eax = &S_VFTPATH32
            zCopy {B$ '&S_VFTPATH32 ; Hex Value:  ' EOS}
        .Else_If eax = &S_REGREL32
            zCopy {B$ '&S_REGREL32 ; Hex Value:  ' EOS}
        .Else_If eax = &S_LTHREAD32
            zCopy {B$ '&S_LTHREAD32 ; Hex Value:  ' EOS}
        .Else_If eax = &S_GTHREAD32
            zCopy {B$ '&S_GTHREAD32 ; Hex Value:  ' EOS}
        .Else_If eax = &S_LPROCMIPS
            zCopy {B$ '&S_LPROCMIPS ; Hex Value:  ' EOS}
        .Else_If eax = &S_GPROCMIPS
            zCopy {B$ '&S_GPROCMIPS ; Hex Value:  ' EOS}
        .Else_If eax = &S_PROCREF
            zCopy {B$ '&S_PROCREF ; Hex Value:  ' EOS}
        .Else_If eax = &S_DATAREF
            zCopy {B$ '&S_DATAREF ; Hex Value:  ' EOS}
        .Else_If eax = &S_ALIGN
            zCopy {B$ '&S_ALIGN ; Hex Value:  ' EOS}
        .Else_If eax = &S_BLOCK_CV2
            zCopy {B$ '&S_BLOCK_CV2; Hex Value:  ' EOS}
        .Else_If eax = &S_BPREL_CV2
            zCopy {B$ '&S_BPREL_CV2; Hex Value:  ' EOS}
        .Else_If eax = &S_BPREL32_CV3
            zCopy {B$ '&S_BPREL32_CV3; Hex Value:  ' EOS}
        .Else_If eax = &S_COBOLUDT_CV3
            zCopy {B$ '&S_COBOLUDT_CV3; Hex Value:  ' EOS}
        .Else_If eax = &S_COMPILE_CV2
            zCopy {B$ '&S_COMPILE_CV2; Hex Value:  ' EOS}
        .Else_If eax = &S_COMPILE_CV3
            zCopy {B$ '&S_COMPILE_CV3; Hex Value:  ' EOS}
        .Else_If eax = &S_CONSTANT_CV2
            zCopy {B$ '&S_CONSTANT_CV2; Hex Value:  ' EOS}
        .Else_If eax = &S_CONSTANT_CV3
            zCopy {B$ '&S_CONSTANT_CV3; Hex Value:  ' EOS}
        .Else_If eax = &S_GDATA_CV2
            zCopy {B$ '&S_GDATA_CV2; Hex Value:  ' EOS}
        .Else_If eax = &S_GDATA_CV3
            zCopy {B$ '&S_GDATA_CV3; Hex Value:  ' EOS}
        .Else_If eax = &S_GPROC_CV2
            zCopy {B$ '&S_GPROC_CV2; Hex Value:  ' EOS}
        .Else_If eax = &S_GPROC32_CV3
            zCopy {B$ '&S_GPROC32_CV3; Hex Value:  ' EOS}
        .Else_If eax = &S_GTHREAD_CV3
            zCopy {B$ '&S_GTHREAD_CV3; Hex Value:  ' EOS}
        .Else_If eax = &S_LABEL_CV2
            zCopy {B$ '&S_LABEL_CV2; Hex Value:  ' EOS}
        .Else_If eax = &S_LDATA_CV2
            zCopy {B$ '&S_LDATA_CV2; Hex Value:  ' EOS}
        .Else_If eax = &S_LDATA_CV3
            zCopy {B$ '&S_LDATA_CV3; Hex Value:  ' EOS}
        .Else_If eax = &S_LPROC_CV2
            zCopy {B$ '&S_LPROC_CV2; Hex Value:  ' EOS}
        .Else_If eax = &S_LPROC_CV3
            zCopy {B$ '&S_LPROC_CV3; Hex Value:  ' EOS}
        .Else_If eax = &S_LTHREAD_CV3
            zCopy {B$ '&S_LTHREAD_CV3; Hex Value:  ' EOS}
        .Else_If eax = &S_MANYREG_CV3
            zCopy {B$ '&S_MANYREG_CV3; Hex Value:  ' EOS}
        .Else_If eax = &S_MSTOOL_CV2
            zCopy {B$ '&S_MSTOOL_CV2; Hex Value:  ' EOS}
        .Else_If eax = &S_PUB_CV3
            zCopy {B$ '&S_PUB_CV3; Hex Value:  ' EOS}
        .Else_If eax = &S_PUB_DATA_CV2
            zCopy {B$ '&S_PUB_DATA_CV2; Hex Value:  ' EOS}
        .Else_If eax = &S_PUB_FUNC1_CV2
            zCopy {B$ '&S_PUB_FUNC1_CV2; Hex Value:  ' EOS}
        .Else_If eax = &S_PUB_FUNC2_CV2
            zCopy {B$ '&S_PUB_FUNC2_CV2; Hex Value:  ' EOS}
        .Else_If eax = &S_REGISTER_CV3
            zCopy {B$ '&S_REGISTER_CV3; Hex Value:  ' EOS}
        .Else_If eax = &S_REGREL_CV3
            zCopy {B$ '&S_REGREL_CV3; Hex Value:  ' EOS}
        .Else_If eax = &S_THUNK_CV2
            zCopy {B$ '&S_THUNK_CV2; Hex Value:  ' EOS}
        .Else_If eax = &S_UDT_CV2
            zCopy {B$ '&S_UDT_CV2; Hex Value:  ' EOS}
        .Else_If eax = &S_UDT_CV3
            zCopy {B$ '&S_UDT_CV3; Hex Value:  ' EOS}
        .Else_If eax = &S_VFTTABLE_CV3
            zCopy {B$ '&S_VFTTABLE_CV3; Hex Value:  ' EOS}
        .End_If
    Pop esi
ret


__________________________________________________________________

Proc WriteRawDataDebugSItem:
    Argument @Text1, @Text2
    uses eax

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice

            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy D@Text1
            zCopy D@Text2
        Pop esi

        Mov eax D@Text1

        If D$eax = 'Leng' ; from "Length" string
            xor eax eax
            lodsw | Call WriteEax

        Else_If D$eax = 'Inde'; From "Index" string
            Call WriteDebugSIndexEquate
            xor eax eax
            lodsw | Call WriteEax

        End_If

        Mov W$edi CRLF | add edi 2
EndP

__________________________________________________________________


Proc WriteCVdataTitle:
    Uses esi, ecx

    Mov D$edi '    ' | add edi 4
    Call WriteObjIndice
    zCopy {B$ "Sec" EOS}
    zCopy SectionHeaderNumber
    zCopy {B$ ".Index" EOS}
    zCopy DebugNumber
    zCopy D$CVLabel
    zCopy {B$ 'DummyBytes' EOS}
    If D$NestedLeafType = &TRUE
        zCopy {B$ '.Arr' EOS}
        zCopy LeafTypeArrayObjIndice
    End_If
    Mov D$edi ': B$', B$edi+4 SPC | add edi 5

EndP
__________________________________________________________________

[DebugNumber: B$ '000001' EOS]


InitSectionDebugNumber:
    Mov D$DebugNumber '0000', D$DebugNumber+4 '01'
ret


IncrementSectionDebugNumber:
    lea ebx D$DebugNumber+5 | inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret


__________________________________________________________________


__________________________________________________________________
;;
;;
Flag1 Member:

The Flag1 member is a Byte value responsable for several different computatiions accordying to specified bits.
We need to shr the founded values to find the proper equates used.


PCodePresent : 1 Uses Bit 0. When the bit is flagged the file uses PCode. Otherwise it don't use.
                Equates :   CV4_PCODE_ENABLED 01
                            CV4_PCODE_DISABLED 0

FloatPrecision :2   Uses Bits 1 and 2. The FloatPrecision flag is set to 1 if the compiler follows the
                    ANSI C floating-point precision rules. This is specified for Microsoft C compilers
                    by setting the -Op option. So, i builded 4 equates:
    
                    CV4_FP_PRECISION_RESERVED1 0
                    CV4_FP_PRECISION_ANSI 1
                    CV4_FP_PRECISION_RESERVED2 2
                    CV4_FP_PRECISION_RESERVED3 3

FloatPackage :2     Uses bits 3 and 4. The equates used are:

                    CV4_FP8087_PROCESSOR 0 Hardware processor (80x87 for Intel 80x86 processors)
                    CV4_FP8087_EMULATOR 1 Emulator
                    CV4_FP8087_ALTMATH 2 Altmath
                    CV4_FP8087_RESERVED 3 Reserved

AmbientData :3      Uses bits 5, 6, 7 . The equates used are:

                    Ambient code and data memory model enumeration:
                    CV4_AMBIENTDATA_NEAR 0 Near
                    CV4_AMBIENTDATA_FAR 1 Far
                    CV4_AMBIENTDATA_HUGE 2 Huge
                    CV4_AMBIENTDATA_RESERVED3 3 Reserved
                    CV4_AMBIENTDATA_RESERVED4 4 Reserved
                    CV4_AMBIENTDATA_RESERVED5 5 Reserved
                    CV4_AMBIENTDATA_RESERVED6 6 Reserved
                    CV4_AMBIENTDATA_RESERVED7 7 Reserved

                    Note: Values  3 - 7 Reserved
;;

;;
Proc WriteCVCompileFlag1Equates:
    Uses esi, ebx, eax

    xor eax eax | lodsb | Mov ebx eax

    Push ebx
    Push eax

    shr ebx 5 ; This is to calculate AmbientData. Shr by 5 because the Bit 5 is the one that is starting to be flagged.

    .If ebx = &CV4_AMBIENTDATA_NEAR
        zCopy {B$ '(&CV4_AMBIENTDATA_NEAR shl 5)' EOS}
    .Else_If ebx = &CV4_AMBIENTDATA_FAR
        zCopy {B$ '(&CV4_AMBIENTDATA_FAR shl 5)' EOS}
    .Else_If ebx = &CV4_AMBIENTDATA_HUGE
        zCopy {B$ '(&CV4_AMBIENTDATA_HUGE shl 5)' EOS}
    .Else_If ebx = &CV4_AMBIENTDATA_RESERVED3
        zCopy {B$ '(&CV4_AMBIENTDATA_RESERVED3 shl 5)' EOS}
    .Else_If ebx = &CV4_AMBIENTDATA_RESERVED4
        zCopy {B$ '(&CV4_AMBIENTDATA_RESERVED4 shl 5)' EOS}
    .Else_If ebx = &CV4_AMBIENTDATA_RESERVED5
        zCopy {B$ '(&CV4_AMBIENTDATA_RESERVED5 shl 5)' EOS}
    .Else_If ebx = &CV4_AMBIENTDATA_RESERVED6
        zCopy {B$ '(&CV4_AMBIENTDATA_RESERVED6 shl 5)' EOS}
    .Else
        zCopy {B$ '(&CV4_AMBIENTDATA_RESERVED7 shl 5)' EOS}
    .End_If

        zCopy {B$ ' + ' EOS}
        ; Now we must Zero bits 5 to 7 to shr again to find the next records for FloatPackage (Bits 3-4)
        btr eax 5 | btr eax 6 | btr eax 7
        ; After clearing the bits, we need to compute only the needed bits to be shred
        shr eax 3 ; This is to calculate FloatPackage. Shr by 3 because the Bit 3 is the one that is starting to be flagged.

    .If eax = &CV4_FP8087_PROCESSOR
        zCopy {B$ '(&CV4_FP8087_PROCESSOR shl 3)' EOS}
    .Else_If eax = &CV4_FP8087_EMULATOR
        zCopy {B$ '(&CV4_FP8087_EMULATOR shl 3)' EOS}
    .Else_If eax = &CV4_FP8087_ALTMATH
        zCopy {B$ '(&CV4_FP8087_ALTMATH shl 3)' EOS}
    .Else
        zCopy {B$ '(&CV4_FP8087_RESERVED shl 3)' EOS}
    .End_If

    Pop eax
    Pop ebx

        zCopy {B$ ' + ' EOS}

    ; Now we restored the values of ebx and eax. We will going to find the values for
    ; PCodePresent (Bit 0) and FloatPrecision (Bits 1 and 2)
    ; Since we restored the values we must clear bits 3 to 7

    ; zeroes bits 3 to 7
    btr eax 3 | btr eax 4 | btr eax 5 | btr eax 6 | btr eax 7


    shr eax 1 ; This is to calculate FloatPrecision. Shr by 1 because the Bit 1 is the one that is starting to be flagged.

    .If eax = &CV4_FP_PRECISION_RESERVED1
        zCopy {B$ '(&CV4_FP_PRECISION_RESERVED1 shl 1)' EOS}
    .Else_If eax = &CV4_FP_PRECISION_ANSI
        zCopy {B$ '(&CV4_FP_PRECISION_ANSI shl 1)' EOS}
    .Else_If eax = &CV4_FP_PRECISION_RESERVED2
        zCopy {B$ '(&CV4_FP_PRECISION_RESERVED2 shl 1)' EOS}
    .Else
        zCopy {B$ '(&CV4_FP_PRECISION_RESERVED3 shl 1)' EOS}
    .End_If

        zCopy {B$ ' + ' EOS}

    and ebx 01 ; This is to calculate PCodePresent.
               ; The value of 1 is because it is the maximum value of all bits flagged. (Bit 0)

    .If ebx = &CV4_PCODE_ENABLED
        zCopy {B$ '&CV4_PCODE_ENABLED' EOS}
    .Else
        zCopy {B$ '&CV4_PCODE_DISABLED' EOS}
    .End_If

        zCopy {B$ ' ; Hex Value:  ' EOS}

EndP

;;
;;
Flag2 Member:

The Flag2 member is a Byte value responsable for several different computatiions accordying to specified bits.
We need to shr the founded values to find the proper equates used.


AmbientCode :3  Uses bits 0, 1 , 2. The equates used are:

                CV4_AMBIENTCODE_NEAR 0 Near
                CV4_AMBIENTCODE_FAR 1 Far
                CV4_AMBIENTCODE_HUGE 2 Huge
                CV4_AMBIENTCODE_RESERVED3 3 Reserved
                CV4_AMBIENTCODE_RESERVED4 4 Reserved
                CV4_AMBIENTCODE_RESERVED5 5 Reserved
                CV4_AMBIENTCODE_RESERVED6 6 Reserved
                CV4_AMBIENTCODE_RESERVED7 7 Reserved

                Note: Values  3 - 7 Reserved

Mode32 :1       Uses Bit 3. When the bit is flagged the file is compiled for 32-bit addresses, otherwise it is not.
                Equates used are:
                
                CV4_MODE32_ENABLED 1 ; Compiled for 32-bit addresses
                CV4_MODE32_DISABLED 0  ; Not compiled for 32-bit addresses

Reserved :4     Used Bits 4,5,6,7. Those bits are reserved. So, they shoulnd't be used, we can set them all to 0.

;;
;;
_______________________________________________

Proc WriteCVCompileFlag2Equates:
    Uses esi, ebx, eax

    If B$esi > 15
        xor eax eax
        lodsb | btr eax 4 | btr eax 5 | btr eax 6 | btr eax 7 ; Clear Bits 4 to 7, that are what exceed the limit of 15
        Mov ebx eax
    Else
        xor eax eax | lodsb | Mov ebx eax
    End_If

    and eax 07 ; This is to calculate AmbientCode.
               ; The value of 7 is because it is the maximum value of all bits flagged. (0 to 3)

    shr ebx 3 ; This is to calculate Mode32. Shr by 3 because the Bit 3 is the one that is flagged.

    If ebx = &CV4_MODE32_ENABLED
        zCopy {B$ '(&CV4_MODE32_ENABLED shl 3)' EOS}
    Else
        zCopy {B$ '(&CV4_MODE32_DISABLED shl 3)' EOS}
    End_If

    .If eax = &CV4_AMBIENTCODE_NEAR
        zCopy {B$ ' + &CV4_AMBIENTCODE_NEAR' EOS}
    .Else_If eax = &CV4_AMBIENTCODE_FAR
        zCopy {B$ ' + &CV4_AMBIENTCODE_FAR' EOS}
    .Else_If eax = &CV4_AMBIENTCODE_HUGE
        zCopy {B$ ' + &CV4_AMBIENTCODE_HUGE' EOS}
    .Else_If eax = &CV4_AMBIENTCODE_RESERVED3
        zCopy {B$ ' + &CV4_AMBIENTCODE_RESERVED3' EOS}
    .Else_If eax = &CV4_AMBIENTCODE_RESERVED4
        zCopy {B$ ' + &CV4_AMBIENTCODE_RESERVED4' EOS}
    .Else_If eax = &CV4_AMBIENTCODE_RESERVED5
        zCopy {B$ ' + &CV4_AMBIENTCODE_RESERVED5' EOS}
    .Else_If eax = &CV4_AMBIENTCODE_RESERVED6
        zCopy {B$ ' + &CV4_AMBIENTCODE_RESERVED6' EOS}
    .Else
        zCopy {B$ ' + &CV4_AMBIENTCODE_RESERVED7' EOS}
    .End_If
        zCopy {B$ ' ; Hex Value:  ' EOS}

EndP
_______________
;;
;;
Used Equates. All that is not listed is reserved

&CV4_COMPILE_LANG_C 0 ; C
&CV4_COMPILE_LANG_CPLUS 01 ; C++
&CV4_COMPILE_LANG_FORTRAN 02; Fortran
&CV4_COMPILE_LANG_MASM 03; Masm
&CV4_COMPILE_LANG_PASCAL 04; Pascal
&CV4_COMPILE_LANG_BASIC 05; Basic
&CV4_COMPILE_LANG_COBOL 06; Cobol

;;
;;
Proc WriteCVCompileLanguageEquates:
    Uses esi

    .If B$esi = &CV4_COMPILE_LANG_C
        zCopy {B$ '&CV4_COMPILE_LANG_C ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_LANG_CPLUS
        zCopy {B$ '&CV4_COMPILE_LANG_CPLUS ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_LANG_FORTRAN
        zCopy {B$ '&CV4_COMPILE_LANG_FORTRAN ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_LANG_MASM
        zCopy {B$ '&CV4_COMPILE_LANG_MASM ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_LANG_PASCAL
        zCopy {B$ '&CV4_COMPILE_LANG_PASCAL ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_LANG_BASIC
        zCopy {B$ '&CV4_COMPILE_LANG_BASIC ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_LANG_COBOL
        zCopy {B$ '&CV4_COMPILE_LANG_COBOL ; Hex Value:  ' EOS}
    .End_If


EndP

_______________
;;
;;

Used Equates. All that is not listed is reserved

&CV4_COMPILE_MACHINE_I80 ; Intel 8080
&CV4_COMPILE_MACHINE_I86 ; Intel 8086
&CV4_COMPILE_MACHINE_I286 ; Intel 80286
&CV4_COMPILE_MACHINE_I386 ; Intel 80386
&CV4_COMPILE_MACHINE_I486 ; Intel 80486
&CV4_COMPILE_MACHINE_I586 ; Intel Pentium
&CV4_COMPILE_MACHINE_R4000 ; MIPS R4000
&CV4_COMPILE_MACHINE_MIPSRESERVED1 ; Reserved for future MIPS processor
&CV4_COMPILE_MACHINE_MIPSRESERVED2 ; Reserved for future MIPS processor
&CV4_COMPILE_MACHINE_MC68000 ; MC68000
&CV4_COMPILE_MACHINE_MC68010 ; MC68010
&CV4_COMPILE_MACHINE_MC68020 ; MC68020
&CV4_COMPILE_MACHINE_MC68030 ; MC68030
&CV4_COMPILE_MACHINE_MC68040 ; MC68040
&CV4_COMPILE_MACHINE_ALPHA ; DEC Alpha
;;
;;

Proc WriteCVCompileMachineEquates:
    Uses esi

    .If B$esi = &CV4_COMPILE_MACHINE_I80
        zCopy {B$ '&CV4_COMPILE_MACHINE_I80 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_I86
        zCopy {B$ '&CV4_COMPILE_MACHINE_I86 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_I286
        zCopy {B$ '&CV4_COMPILE_MACHINE_I286 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_I386
        zCopy {B$ '&CV4_COMPILE_MACHINE_I386 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_I486
        zCopy {B$ '&CV4_COMPILE_MACHINE_I486 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_I586
        zCopy {B$ '&CV4_COMPILE_MACHINE_I586 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_R4000
        zCopy {B$ '&CV4_COMPILE_MACHINE_R4000 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_MIPSRESERVED1
        zCopy {B$ '&CV4_COMPILE_MACHINE_MIPSRESERVED1 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_MIPSRESERVED2
        zCopy {B$ '&CV4_COMPILE_MACHINE_MIPSRESERVED2 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_MC68000
        zCopy {B$ '&CV4_COMPILE_MACHINE_MC68000 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_MC68010
        zCopy {B$ '&CV4_COMPILE_MACHINE_MC68010 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_MC68020
        zCopy {B$ '&CV4_COMPILE_MACHINE_MC68020 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_MC68030
        zCopy {B$ '&CV4_COMPILE_MACHINE_MC68030 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_MC68040
        zCopy {B$ '&CV4_COMPILE_MACHINE_MC68040 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_ALPHA
        zCopy {B$ '&CV4_COMPILE_MACHINE_ALPHA ; Hex Value:  ' EOS}
    .End_If


EndP
________________

Proc WriteRawDataDebugSCompileItem:
    Argument @Text1, @Text2, @DataSize
    uses eax, ecx

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'Compile.' EOS}
            zCopy D@Text1
            zCopy D@Text2
        Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Mach' ; from "Machine" string
            Call WriteCVCompileMachineEquates
            If D@DataSize = 4
                lodsd | Call WriteEax
            Else
                xor eax eax
                lodsb | Call WriteEax
            End_If
        ..Else_If D$eax = 'Lang'; From "Language" string
            Call WriteCVCompileLanguageEquates
            If D@DataSize = 4
                lodsd | Call WriteEax
            Else
                xor eax eax
                lodsb | Call WriteEax
            End_If

        ..Else_If D$eax+2 = 'ags1'; From "Flags1" string
            Call WriteCVCompileFlag1Equates
            If D@DataSize = 4
                lodsd | Call WriteEax
            Else
                xor eax eax
                lodsb | Call WriteEax
            End_If

        ..Else_If D$eax+2 = 'ags2'; From "Flags2" string
            Call WriteCVCompileFlag2Equates
            If D@DataSize = 4
                lodsd | Call WriteEax
            Else
                xor eax eax
                lodsb | Call WriteEax
            End_If

        ..Else_If D$eax = 'Unkn'; From "Unknown" string
            If D@DataSize = 4
                lodsd | Call WriteEax
            Else
                xor eax eax
                lodsw | Call WriteEax
            End_If

        ..Else_If D$eax = 'Comp'; From "CompilerID" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            If D@DataSize = 2 ; this happens only in S_COMPILE_CV2. It´' size is not 2, but we use this to identify this type.
                Push eax
                    Call StrLenProc esi
                    Mov ecx eax
                    inc ecx ; The size is increased to we alow including the zero byte
                Pop eax
            Else
                movzx ecx B$esi-1
            End_If

            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2
EndP

_________________________________________

[CVNonLeafIndexPad03Unknown01: B$ 'Unknown01' EOS]
[CVNonLeafIndexPad03Unknown02: B$ 'Unknown02' EOS]
[CVNonLeafIndexPad03Unknown03: B$ 'Unknown03' EOS]
[CVNonLeafIndexPad03NameLenght: B$ 'NameLenght' EOS]
[CVNonLeafIndexPad03Name: B$ 'Name' EOS]

Proc WriteRawDataDebugSNonLeafIndexPad03:
    Uses ecx, eax, ebx
    ; This is to avoid that the Structure have dummy bytes at the end.
   ; Mov ebx esi
  ;  sub ebx 2
 ;   Mov ecx D$SizeAdd
;    add ebx ecx

;    Push ebx

    Call WriteRawDataDebugSNonLeafIndexPad03Item CVNonLeafIndexPad03Unknown01, {B$ ': B$ ' EOS}
    Call WriteRawDataDebugSNonLeafIndexPad03Item CVNonLeafIndexPad03Unknown02, {B$ ': B$ ' EOS}
    Call WriteRawDataDebugSNonLeafIndexPad03Item CVNonLeafIndexPad03Unknown03, {B$ ': B$ ' EOS}
    Call WriteRawDataDebugSNonLeafIndexPad03Item CVNonLeafIndexPad03NameLenght, {B$ ': D$ ' EOS}

    Mov ebx esi
    Mov ecx D$SizeAdd
    add ebx ecx
    add ebx D$esi-4

    If D$esi-4 <> 0 ; is the Name Lenght = 0 ? jmp over.

        Push ebx
            Call WriteRawDataDebugSNonLeafIndexPad03Item CVNonLeafIndexPad03Name, {B$ ': B$ ' EOS}
        Pop ebx

    End_If
    ; Is the end of this structure ends on the proper place ?

    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________

Proc WriteRawDataDebugSNonLeafIndexPad03Item:
    Argument @Text1, @Text2
    uses eax, ecx, ebx

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'NoIndexLeafPad03.' EOS}
            zCopy D@Text1
            zCopy D@Text2
        Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Unkn' ; from "Unknown01", "Unknown02", "Unknown03" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            lodsd | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-4
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2
EndP

________________________

[CVCompileMachine: B$ 'Machine' EOS]
[CVCompileLanguage: B$ 'Language' EOS]
[CVCompileFlags1: B$ 'Flags1' EOS]
[CVCompileFlags2: B$ 'Flags2' EOS]
[CVCompileUnknown: B$ 'Unknown' EOS]
[CVCompileCompilerID: B$ 'CompilerID' EOS]
[CVCompileNameLenght: B$ 'NameLenght' EOS]
[CVCompileName: B$ 'Name' EOS]


Proc WriteRawDataDebugSCompile:
    Uses ecx, eax, ebx
    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx

    .If W$esi-2 = &S_COMPILE
        Call WriteRawDataDebugSCompileItem CVCompileMachine, {B$ ': B$ ' EOS}, 1
        Call WriteRawDataDebugSCompileItem CVCompileLanguage, {B$ ': B$ ' EOS}, 1
        Call WriteRawDataDebugSCompileItem CVCompileFlags1, {B$ ': B$ ' EOS}, 1
        Call WriteRawDataDebugSCompileItem CVCompileFlags2, {B$ ': B$ ' EOS}, 1
        Call WriteRawDataDebugSCompileItem CVCompileNameLenght, {B$ ': B$ ' EOS}, 1
        Call WriteRawDataDebugSCompileItem CVCompileName, {B$ ': B$ ' EOS}, 1
    .Else_If W$esi-2 = &S_COMPILE_CV3
        Call WriteRawDataDebugSCompileItem CVCompileLanguage, {B$ ': D$ ' EOS}, 4
        Call WriteRawDataDebugSCompileItem CVCompileMachine, {B$ ': D$ ' EOS}, 4
        Call WriteRawDataDebugSCompileItem CVCompileFlags2, {B$ ': D$ ' EOS}, 4
        Call WriteRawDataDebugSCompileItem CVCompileFlags1, {B$ ': D$ ' EOS}, 4
        Call WriteRawDataDebugSCompileItem CVCompileCompilerID, {B$ ': W$ ' EOS}, 2
        Call WriteRawDataDebugSCompileItem CVCompileNameLenght, {B$ ': B$ ' EOS}, 1
        Call WriteRawDataDebugSCompileItem CVCompileName, {B$ ': B$ ' EOS}, 1

    .Else_If W$esi-2 = &S_COMPILE_CV2
        ; The members below seems to be a variation of the S_OBJNAME structured data.
        ; The Unknown seems to be the Signature
        ; The name is the object name, with full path. (And not the name of the object only as in S_OBJECT)
        Call WriteRawDataDebugSCompileItem CVCompileUnknown, {B$ ': D$ ' EOS}, 4
        Call WriteRawDataDebugSCompileItem CVCompileName, {B$ ': B$ ' EOS}, 2
    .End_If

    Pop ebx

    ; Is the end of this structure ends on the proper place ?

    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP


________________________________________________________________________________

[CVMsToolMachine: B$ 'Machine' EOS]
[CVMsToolLanguage: B$ 'Language' EOS]
[CVMsToolUnknown1: B$ 'Unknown1' EOS]
[CVMsToolUnknown2: B$ 'Unknown2' EOS]
[CVMsToolUnknown3: B$ 'Unknown3' EOS]
[CVMsToolUnknown4: B$ 'Unknown4' EOS]
[CVMsToolUnknown5: B$ 'Unknown5' EOS]
[CVMsToolUnknown6: B$ 'Unknown6' EOS]
[CVMsToolUnknown7: B$ 'Unknown7' EOS]
[CVMsToolUnknown8: B$ 'Unknown8' EOS]
[CVMsToolName: B$ 'Name' EOS]

Proc WriteRawDataDebugSMsTool:
    Uses ecx, eax, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx

    .If W$esi-2 = &S_MSTOOL_CV2
        Call WriteRawDataDebugSMsToolItem CVMsToolMachine, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSMsToolItem CVMsToolLanguage, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSMsToolItem CVMsToolUnknown1, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSMsToolItem CVMsToolUnknown2, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSMsToolItem CVMsToolUnknown3, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSMsToolItem CVMsToolUnknown4, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSMsToolItem CVMsToolUnknown5, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSMsToolItem CVMsToolUnknown6, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSMsToolItem CVMsToolUnknown7, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSMsToolItem CVMsToolUnknown8, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSMsToolItem CVMsToolName, {B$ ': B$ ' EOS}
    .End_If

    Pop ebx

    ; Is the end of this structure ends on the proper place ?

    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP
_________________________________

Proc WriteRawDataDebugSMsToolItem:
    Argument @Text1, @Text2
    uses eax, ecx

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'MsTool.' EOS}
            zCopy D@Text1
            zCopy D@Text2
        Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Mach' ; from "Machine" string
            Call WriteCVCompileMachineEquates
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Lang'; From "Language" string
            Call WriteCVCompileLanguageEquates
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax+4 = 'own1'; From "Unknown1" string
                xor eax eax
                lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'own2'; From "Unknown2" string
                xor eax eax
                lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'own3'; From "Unknown3" string
                xor eax eax
                lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'own4'; From "Unknown4" string
                xor eax eax
                lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'own5'; From "Unknown5" string
                xor eax eax
                lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'own6'; From "Unknown6" string
                xor eax eax
                lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'own7'; From "Unknown7" string
                xor eax eax
                lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'own8'; From "Unknown8" string
                xor eax eax
                lodsw | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name. On this case (S_MSTOOL_CV2) The name is a null terminated string
                Push eax
                    Call StrLenProc esi
                    Mov ecx eax
                    inc ecx ; The size is increased to we alow including the zero byte
                Pop eax

            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2
EndP

________________________________________________________________________________

[CVRegisterType: B$ 'Type' EOS]
[CVRegisterOldCVType: B$ 'OldCVType' EOS]
[CVRegisterRegister: B$ 'Register' EOS]
[CVRegisterNameLenght: B$ 'NameLenght' EOS]
[CVRegisterName: B$ 'Name' EOS]
[CVRegisterTrackingInfo: B$ 'TrackingInfo' EOS]

Proc WriteRawDataDebugSRegister:
    Local @EndPos, @OldCodeView
    Uses ecx, eax

    Mov D@OldCodeView &FALSE
    If W$esi-2 = &S_REGISTER_CV3
        Mov D@OldCodeView &TRUE
    End_If


    ; 1st find start of symbol (Address of index -> S_REGISTER)
    Mov ecx esi
    sub ecx 2 ; at ecx we point to the Index value
    movzx eax W$esi-4 ; find the len of the symbol
    add ecx eax
    Mov D@EndPos ecx

    If D@OldCodeView = &TRUE
        Call WriteRawDataDebugSRegisterItem CVRegisterOldCVType , {B$ ': W$ ' EOS}
    End_If
    Call WriteRawDataDebugSRegisterItem CVRegisterType, {B$ ': W$ ' EOS}
    Call WriteRawDataDebugSRegisterItem CVRegisterRegister, {B$ ': W$ ' EOS}
    Call WriteRawDataDebugSRegisterItem CVRegisterNameLenght, {B$ ': B$ ' EOS}
    Call WriteRawDataDebugSRegisterItem CVRegisterName, {B$ ': B$ ' EOS}

    ..If esi <> D@EndPos ; is esi ending at EndPos ? No, do next line. Yes, jmp over

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'Register.TrackingInfo: B$ ' EOS}
        Pop esi

        Mov ecx D@EndPos
        sub ecx esi

        .Do
            Push ecx
            xor eax eax
            lodsb | Call WriteEax
            Mov W$edi ', ' | add edi 2
            Pop ecx
            dec ecx
        .Loop_Until ecx = 0
            sub edi 2
            Mov W$edi CRLF | add edi 2
    ..End_If

    ; bypass esi. Need to review this stuff
;    Call WriteRawDataDebugSRegisterItem CVRegisterTrackingInfo, {B$ ': B$ ' EOS}

; type equates here: WriteCVBPRel32TypeEquates
; Call Write_IMAGE_FILE_MACHINE D$CoffMachineType
EndP
________________________________________________________________________________

Proc WriteRawDataDebugSRegisterItem:
    Argument @Text1, @Text2
    uses eax, ecx

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'Register.' EOS}
            zCopy D@Text1
            zCopy D@Text2
        Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Type' ; from "Type" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'OldC' ; from "OldCVType" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Regi'; From "Register" string
            .If_Or D$CoffMachineType = &IMAGE_FILE_MACHINE_I386, D$CoffMachineType = &IMAGE_FILE_MACHINE_I486, D$CoffMachineType = &IMAGE_FILE_MACHINE_I586
                Call WriteCVRegisterIntelRegEquates
            .Else_If D$CoffMachineType = &IMAGE_FILE_MACHINE_M68K
                Call WriteCVRegisterM68KRegEquates
            .Else_If_Or D$CoffMachineType = &IMAGE_FILE_MACHINE_MIPS16, D$CoffMachineType = &IMAGE_FILE_MACHINE_MIPSFPU, D$CoffMachineType = &IMAGE_FILE_MACHINE_MIPSFPU16
                Call WriteCVRegisterMipsRegEquates
            .End_If
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2
EndP

________________________________________________________________________________

Proc WriteCVRegisterIntelRegEquates:
    Uses esi

    .If B$esi = &CV4_REGISTER_INTEL_REG_NONE
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_NONE ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_AL
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_AL ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_CL
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_CL ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_DL
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_DL ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_BL
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_BL ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_AH
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_AH ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_CH
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_CH ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_DH
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_DH ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_BH
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_BH ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_AX
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_AX ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_CX
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_CX ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_DX
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_DX ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_BX
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_BX ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_SP
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_SP ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_BP
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_BP ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_SI
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_SI ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_DI
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_DI ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_EAX
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_EAX ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_ECX
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_ECX ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_EDX
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_EDX ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_EBX
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_EBX ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_ESP
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_ESP ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_EBP
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_EBP ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_ESI
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_ESI ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_EDI
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_EDI ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_ES
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_ES ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_CS
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_CS ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_SS
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_SS ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_DS
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_DS ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_FS
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_FS ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_GS
        zCopy {B$ '&CV4_REGISTER_INTEL_REG_GS ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SPECIALREGCASE_IP
        zCopy {B$ '&CV4_REGISTER_INTEL_SPECIALREGCASE_IP ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SPECIALREGCASE_FLAGS
        zCopy {B$ '&CV4_REGISTER_INTEL_SPECIALREGCASE_FLAGS ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SPECIALREGCASE_EIP
        zCopy {B$ '&CV4_REGISTER_INTEL_SPECIALREGCASE_EIP ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SPECIALREGCASE_EFLAGS
        zCopy {B$ '&CV4_REGISTER_INTEL_SPECIALREGCASE_EFLAGS ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_TEMP
        zCopy {B$ '&CV4_REGISTER_INTEL_PCODEREG_TEMP ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_TEMPH
        zCopy {B$ '&CV4_REGISTER_INTEL_PCODEREG_TEMPH ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_QUOTE
        zCopy {B$ '&CV4_REGISTER_INTEL_PCODEREG_QUOTE ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_RESERVED1
        zCopy {B$ '&CV4_REGISTER_INTEL_PCODEREG_RESERVED1 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_RESERVED2
        zCopy {B$ '&CV4_REGISTER_INTEL_PCODEREG_RESERVED2 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_RESERVED3
        zCopy {B$ '&CV4_REGISTER_INTEL_PCODEREG_RESERVED3 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_RESERVED4
        zCopy {B$ '&CV4_REGISTER_INTEL_PCODEREG_RESERVED4 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_RESERVED5
        zCopy {B$ '&CV4_REGISTER_INTEL_PCODEREG_RESERVED5 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_CR0
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREG_CR0 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_CR1
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREG_CR1 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_CR2
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREG_CR2 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_CR3
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREG_CR3 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR0
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREG_DR0 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR1
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREG_DR1 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR2
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREG_DR2 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR3
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREG_DR3 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR4
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREG_DR4 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR5
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREG_DR5 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR6
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREG_DR6 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR7
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREG_DR7 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ST0
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_ST0 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ST2
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_ST2 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ST3
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_ST3 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ST4
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_ST4 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ST5
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_ST5 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ST6
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_ST6 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ST7
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_ST7 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_CONTROL
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_CONTROL ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_STATUS
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_STATUS ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_TAG
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_TAG ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_FPIP
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_FPIP ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_FPCS
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_FPCS ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_FPDO
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_FPDO ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_FPDS
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_FPDS ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ISEM
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_ISEM ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_FPEIP
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_FPEIP ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_FPEDO
        zCopy {B$ '&CV4_REGISTER_INTEL_SYSREGEXTENSION_FPEDO ; Hex Value:  ' EOS}
    .End_If

EndP
________________________________________________________________________________

Proc WriteCVRegisterM68KRegEquates:
    Uses esi

    .If B$esi = &CV4_REGISTER_M68K_DATA_REG0
        zCopy {B$ '&CV4_REGISTER_M68K_DATA_REG0 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_DATA_REG1
        zCopy {B$ '&CV4_REGISTER_M68K_DATA_REG1 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_DATA_REG2
        zCopy {B$ '&CV4_REGISTER_M68K_DATA_REG2 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_DATA_REG3
        zCopy {B$ '&CV4_REGISTER_M68K_DATA_REG3 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_DATA_REG4
        zCopy {B$ '&CV4_REGISTER_M68K_DATA_REG4 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_DATA_REG5
        zCopy {B$ '&CV4_REGISTER_M68K_DATA_REG5 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_DATA_REG6
        zCopy {B$ '&CV4_REGISTER_M68K_DATA_REG6 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_DATA_REG7
        zCopy {B$ '&CV4_REGISTER_M68K_DATA_REG7 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG0
        zCopy {B$ '&CV4_REGISTER_M68K_ADDRESS_REG0 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG1
        zCopy {B$ '&CV4_REGISTER_M68K_ADDRESS_REG1 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG2
        zCopy {B$ '&CV4_REGISTER_M68K_ADDRESS_REG2 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG3
        zCopy {B$ '&CV4_REGISTER_M68K_ADDRESS_REG3 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG4
        zCopy {B$ '&CV4_REGISTER_M68K_ADDRESS_REG4 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG5
        zCopy {B$ '&CV4_REGISTER_M68K_ADDRESS_REG5 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG6
        zCopy {B$ '&CV4_REGISTER_M68K_ADDRESS_REG6 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG7
        zCopy {B$ '&CV4_REGISTER_M68K_ADDRESS_REG7 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_CCR
        zCopy {B$ '&CV4_REGISTER_M68K_R68_CCR ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_SR
        zCopy {B$ '&CV4_REGISTER_M68K_R68_SR ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_USP
        zCopy {B$ '&CV4_REGISTER_M68K_R68_USP ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_MSP
        zCopy {B$ '&CV4_REGISTER_M68K_R68_MSP ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_SFC
        zCopy {B$ '&CV4_REGISTER_M68K_R68_SFC ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_DFC
        zCopy {B$ '&CV4_REGISTER_M68K_R68_DFC ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_CACR
        zCopy {B$ '&CV4_REGISTER_M68K_R68_CACR ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_VBR
        zCopy {B$ '&CV4_REGISTER_M68K_R68_VBR ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_CAAR
        zCopy {B$ '&CV4_REGISTER_M68K_R68_CAAR ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_ISP
        zCopy {B$ '&CV4_REGISTER_M68K_R68_ISP ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_PC
        zCopy {B$ '&CV4_REGISTER_M68K_R68_PC ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED1
        zCopy {B$ '&CV4_REGISTER_M68K_RESERVED1 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_FPCR
        zCopy {B$ '&CV4_REGISTER_M68K_R68_FPCR ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_FPSR
        zCopy {B$ '&CV4_REGISTER_M68K_R68_FPSR ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_FPIAR
        zCopy {B$ '&CV4_REGISTER_M68K_R68_FPIAR ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED2
        zCopy {B$ '&CV4_REGISTER_M68K_RESERVED2 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT0
        zCopy {B$ '&CV4_REGISTER_M68K_FLOATING_POINT0 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT1
        zCopy {B$ '&CV4_REGISTER_M68K_FLOATING_POINT1 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT2
        zCopy {B$ '&CV4_REGISTER_M68K_FLOATING_POINT2 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT3
        zCopy {B$ '&CV4_REGISTER_M68K_FLOATING_POINT3 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT4
        zCopy {B$ '&CV4_REGISTER_M68K_FLOATING_POINT4 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT5
        zCopy {B$ '&CV4_REGISTER_M68K_FLOATING_POINT5 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT6
        zCopy {B$ '&CV4_REGISTER_M68K_FLOATING_POINT6 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT7
        zCopy {B$ '&CV4_REGISTER_M68K_FLOATING_POINT7 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED3
        zCopy {B$ '&CV4_REGISTER_M68K_RESERVED3 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED4
        zCopy {B$ '&CV4_REGISTER_M68K_RESERVED4 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED5
        zCopy {B$ '&CV4_REGISTER_M68K_RESERVED5 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED6
        zCopy {B$ '&CV4_REGISTER_M68K_RESERVED6 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED7
        zCopy {B$ '&CV4_REGISTER_M68K_RESERVED7 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED8
        zCopy {B$ '&CV4_REGISTER_M68K_RESERVED8 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED9
        zCopy {B$ '&CV4_REGISTER_M68K_RESERVED9 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED10
        zCopy {B$ '&CV4_REGISTER_M68K_RESERVED10 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED11
        zCopy {B$ '&CV4_REGISTER_M68K_RESERVED11 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED12
        zCopy {B$ '&CV4_REGISTER_M68K_RESERVED12 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED13
        zCopy {B$ '&CV4_REGISTER_M68K_RESERVED13 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_CV_R68_PSR
        zCopy {B$ '&CV4_REGISTER_M68K_CV_R68_PSR ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_M68K_CV_R68_PCSR
        zCopy {B$ '&CV4_REGISTER_M68K_CV_R68_PCSR ; Hex Value:  ' EOS}
    .End_If

EndP
________________________________________________________________________________

Proc WriteCVRegisterMipsRegEquates:
    Uses esi

    .If B$esi = &CV4_REGISTER_MIPS_NOREGISTER
        zCopy {B$ '&CV4_REGISTER_MIPS_NOREGISTER ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_ZERO
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_ZERO ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_AT
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_AT ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_V0
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_V0 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_V1
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_V1 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_A0
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_A0 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_A1
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_A1 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_A2
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_A2 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_A3
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_A3 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T0
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_T0 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T1
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_T1 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T2
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_T2 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T3
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_T3 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T4
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_T4 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T5
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_T5 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T6
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_T6 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T7
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_T7 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S0
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_S0 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S1
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_S1 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S2
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_S2 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S3
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_S3 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S4
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_S4 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S5
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_S5 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S6
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_S6 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S7
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_S7 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T8
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_T8 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T9
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_T9 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_KT0
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_KT0 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_KT1
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_KT1 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_GP
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_GP ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_SP
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_SP ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S8
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_S8 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_RA
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_RA ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_LO
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_LO ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_HI
        zCopy {B$ '&CV4_REGISTER_MIPS_INT_HI ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FIR
        zCopy {B$ '&CV4_REGISTER_MIPS_FIR ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_PSR
        zCopy {B$ '&CV4_REGISTER_MIPS_PSR ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT0
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT0 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT1
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT1 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT2
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT2 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT3
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT3 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT4
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT4 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT5
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT5 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT6
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT6 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT7
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT7 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT8
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT8 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT9
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT9 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT10
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT10 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT11
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT11 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT12
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT12 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT13
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT13 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT14
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT14 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT15
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT15 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT16
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT16 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT17
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT17 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT18
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT18 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT19
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT19 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT20
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT20 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT21
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT21 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT22
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT22 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT23
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT23 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT24
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT24 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT25
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT25 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT26
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT26 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT27
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT27 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT28
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT28 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT29
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT29 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT30
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT30 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT31
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT31 ; Hex Value:  ' EOS}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT_STATUS_REG
        zCopy {B$ '&CV4_REGISTER_MIPS_FLOATING_POINT_STATUS_REG ; Hex Value:  ' EOS}
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeStructureItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.VarStr' EOS}
        zCopy D@Text1
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Coun'; From "Count" string
            xor eax eax
            lodsw | Call WriteEax
        ..Else_If D$eax = 'Fiel'; From "Field" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'OldC'; From "OldCVType" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax
        ..Else_If D$eax+13 = 'own1'; From "OldCVTypeUnknown1" string
            xor eax eax
            lodsw | Call WriteEax
        ..Else_If D$eax+13 = 'own2'; From "OldCVTypeUnknown2" string
            xor eax eax
            lodsw | Call WriteEax
         ..Else_If D$eax = 'Prop'; From "Property" string
            xor eax eax
            lodsw | Call WriteEax
        ..Else_If D$eax = 'dLis'; From "dList" string
            xor eax eax
            lodsw | Call WriteEax
        ..Else_If D$eax = 'vSha'; From "vShape" string
            xor eax eax
            lodsw | Call WriteEax
        ..Else_If D$eax = 'Stru'; From "StructLen" string
            xor eax eax
            lodsw | Call WriteEax


        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP
___________________________________________________

[CVLeafTypeStructureCount: B$ 'Count' EOS]
[CVLeafTypeStructureField: B$ 'Field' EOS]
[CVLeafTypeStructureOldCVType: B$ 'OldCVType' EOS]
[CVLeafTypeStructureOldCVTypeUnkn1: B$ 'OldCVTypeUnknown1' EOS]
[CVLeafTypeStructureOldCVTypeUnkn2: B$ 'OldCVTypeUnknown2' EOS]
[CVLeafTypeStructureProperty: B$ 'Property' EOS]
[CVLeafTypeStructuredList: B$ 'dList' EOS]
[CVLeafTypeStructurevshape: B$ 'vShape' EOS]
[CVLeafTypeStructuredStructLen: B$ 'StructLen' EOS]

Proc WriteRawDataDebugSContantLeafTypeStructure:
    Local @OldCodeView
    Uses eax, ecx

    Mov D@OldCodeView &FALSE
    If W$esi-2 = &LF_STRUCTURE_CV3
        Mov D@OldCodeView &TRUE
    End_If

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx

        Call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructureCount, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructureField, {B$ ': W$ ' EOS}
        If D@OldCodeView = &TRUE
            Call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeUnionOldCVType, {B$ ': W$ ' EOS}
            Call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructureOldCVTypeUnkn1, {B$ ': W$ ' EOS}
            Call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructureOldCVTypeUnkn2, {B$ ': W$ ' EOS}
        End_If
        Call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructureProperty, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructuredList, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructurevshape, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructuredStructLen, {B$ ': W$ ' EOS}

        Call WriteRawDataDebugSContantLeafTypeStructureItem CVCompileNameLenght, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeStructureItem CVCompileName, {B$ ': B$ ' EOS}
        sub edi 2

    Pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If


EndP
________________________________________________________________________________

[CVLeafTypeUnionCount: B$ 'Count' EOS]
[CVLeafTypeUnionField: B$ 'Field' EOS]
[CVLeafTypeUnionOldCVType: B$ 'OldCVType' EOS]
[CVLeafTypeUnionProperty: B$ 'Property' EOS]
[CVLeafTypeUnionUnionLen: B$ 'UnionLength' EOS]
;LF_UNION count @field property length
; WriteRawDataDebugSContantLeafTypeMember
Proc WriteRawDataDebugSContantLeafTypeUnion:
    Local @OldCodeView
    Uses eax, ecx


    Mov D@OldCodeView &FALSE
    If W$esi-2 = &LF_UNION_CV3
        Mov D@OldCodeView &TRUE
    End_If

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx

        Call WriteRawDataDebugSContantLeafTypeUnionItem CVLeafTypeUnionCount, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeUnionItem CVLeafTypeUnionField, {B$ ': W$ ' EOS}
        If D@OldCodeView = &TRUE
            Call WriteRawDataDebugSContantLeafTypeUnionItem CVLeafTypeUnionOldCVType, {B$ ': W$ ' EOS}
        End_If
        Call WriteRawDataDebugSContantLeafTypeUnionItem CVLeafTypeUnionProperty, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeUnionItem CVLeafTypeUnionUnionLen, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeUnionItem CVCompileNameLenght, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeUnionItem CVCompileName, {B$ ': B$ ' EOS}
        sub edi 2

    Pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If


EndP
________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeUnionItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.Union.' EOS}
        zCopy D@Text1
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Coun'; From "Count" string
            xor eax eax
            lodsw | Call WriteEax
        ..Else_If D$eax = 'Fiel'; From "Field" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax
        ..Else_If D$eax = 'OldC'; From "OldCVType" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax
        ..Else_If D$eax = 'Prop'; From "Property" string
            xor eax eax
            lodsw | Call WriteEax
        ..Else_If D$eax = 'Unio'; From "UnionLength" string
            xor eax eax
            lodsw | Call WriteEax


        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP
________________________________________________________________________________


Proc WriteRawDataDebugSContantLeafTypePointerItem:
   Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.Pointer.' EOS}
        zCopy D@Text1
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        ..If D$eax = 'OldC'; From "OldCVType" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Type'; From "Type" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP
_______________________________________________________________________

[CVLeafTypeModifierOldCVType: B$ 'OldCVType' EOS]
[CVLeafTypeModifierAttribute: B$ 'Attribute' EOS]
[CVLeafTypeModifierIndex: B$ 'Index' EOS]

Proc WriteRawDataDebugSContantLeafTypeModifier:
    Local @OldCodeView
    Uses eax, ecx

    Mov D@OldCodeView &FALSE
    If W$esi-2 = &LF_MODIFIER_CV3
        Mov D@OldCodeView &TRUE
    End_If


    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        If D@OldCodeView = &TRUE
            Call WriteRawDataDebugSContantLeafTypeModifierItem CVLeafTypeModifierOldCVType, {B$ ': W$ ' EOS}
        End_If
        Call WriteRawDataDebugSContantLeafTypeModifierItem CVLeafTypeModifierAttribute, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeModifierItem CVLeafTypeModifierIndex, {B$ ': W$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If


EndP
_________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeModifierItem:
   Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.Modifier.' EOS}
        zCopy D@Text1
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        ..If D$eax = 'OldC'; From "OldCVType" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Attr'; From "Attribute" string
            ; same as in WriteCVCompileFlag2Equates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Inde'; From "Type" string
            xor eax eax
            lodsw | Call WriteEax

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

_________________________________________________________________________________


[CVLeafTypePointerOldCVType: B$ 'OldCVType' EOS]
[CVLeafTypePointerAttribute: B$ 'Attribute' EOS]
[CVLeafTypePointerType: B$ 'Type' EOS]

Proc WriteRawDataDebugSContantLeafTypePointer:
    Local @OldCodeView
    Uses eax, ecx

    Mov D@OldCodeView &FALSE
    If W$esi-2 = &LF_POINTER_CV3
        Mov D@OldCodeView &TRUE
    End_If


    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        If D@OldCodeView = &TRUE
            Call WriteRawDataDebugSContantLeafTypePointerItem CVLeafTypePointerOldCVType, {B$ ': W$ ' EOS}
        End_If
        Call WriteRawDataDebugSContantLeafTypePointerItem CVLeafTypePointerAttribute, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypePointerItem CVLeafTypePointerType, {B$ ': W$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If


EndP
________________________________________________________________________________

            ;WriteRawDataDebugSBPRel32
[CVLeafTypeArrayElemType: B$ 'ElemType' EOS]
[CVLeafTypeArrayIdxType: B$ 'IdxType' EOS]
[CVLeafTypeArrayLength: B$ 'Length' EOS]
[CVLeafTypeArrayNamelenght: B$ 'NameLenght' EOS]
[CVLeafTypeArrayName: B$ 'Name' EOS]

Proc WriteRawDataDebugSContantLeafTypeArray:
    Uses eax, ecx


    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayElemType , {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayIdxType , {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayLength, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayNamelenght, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayName, {B$ ': B$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP
________________________________________________________________________________
Proc WriteRawDataDebugSContantLeafTypeArrayItem:
    Argument @Text1, @Text2
    uses eax, ecx

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'Constant.LeafType.Array.' EOS}
            zCopy D@Text1
            zCopy D@Text2
        Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Elem' ; from "ElemType" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'IdxT'; From "IdxType" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Leng'; From "Lenght" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

________________________________________________________________________________
Proc WriteRawDataDebugSContantLeafTypeProcedureItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.Procedure.' EOS}
        zCopy D@Text1
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

         ..If D$eax = 'rvTy'; From "rvType" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Call'; From "Call" string
            Call WriteCVLF_ProcCallConvTypeEquates
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Rese'; From "Reserved" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Parm'; From "Parms" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'ArgL'; From "ArgList" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

_________________________________________

[CVLeafTypeProcrvType: B$ 'rvType' EOS]
[CVLeafTypeProcCall: B$ 'Call' EOS]
[CVLeafTypeProcrvReserved: B$ 'Reserved' EOS]
[CVLeafTypeProcrvParms: B$ 'Parms' EOS]
[CVLeafTypeProcrvArgList: B$ 'ArgList' EOS]

Proc WriteRawDataDebugSContantLeafTypeProcedure:
    Uses eax, ecx


    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeProcedureItem CVLeafTypeProcrvType, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeProcedureItem CVLeafTypeProcCall, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeProcedureItem CVLeafTypeProcrvReserved, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeProcedureItem CVLeafTypeProcrvParms, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeProcedureItem CVLeafTypeProcrvArgList, {B$ ': W$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

[CVLeafTypeMFunctionRvType: B$ 'RvType' EOS]
[CVLeafTypeMFunctionClass: B$ 'Class' EOS]
[CVLeafTypeMFunctionThis: B$ 'This' EOS]
[CVLeafTypeMFunctionCall: B$ 'Call' EOS]
[CVLeafTypeMFunctionRes: B$ 'Res' EOS]
[CVLeafTypeMFunctionParms: B$ 'Parms' EOS]
[CVLeafTypeMFunctionOldCVType: B$ 'OldCVType' EOS]
[CVLeafTypeMFunctionArglist: B$ 'Arglist' EOS]
[CVLeafTypeMFunctionThisAdjust: B$ 'ThisAdjust' EOS]

Proc WriteRawDataDebugSContantLeafTypeMFunction:
    Local @OldCodeView
    Uses eax, ecx


    Mov D@OldCodeView &FALSE
    If W$esi-2 = &LF_MFUNCTION_CV3
        Mov D@OldCodeView &TRUE
    End_If

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx

        If D@OldCodeView = &TRUE
            Call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionRvType, {B$ ': D$ ' EOS}, &TRUE
            Call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionClass, {B$ ': D$ ' EOS}, &TRUE
            Call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionThis, {B$ ': D$ ' EOS}, &TRUE
        Else
            Call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionRvType, {B$ ': W$ ' EOS}, &FALSE
            Call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionClass, {B$ ': W$ ' EOS}, &FALSE
            Call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionThis, {B$ ': W$ ' EOS}, &FALSE

        End_If
        Call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionCall, {B$ ': B$ ' EOS}, &FALSE
        Call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionRes, {B$ ': B$ ' EOS}, &FALSE
        Call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionParms, {B$ ': W$ ' EOS}, &FALSE
        If D@OldCodeView = &TRUE
            Call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionOldCVType, {B$ ': W$ ' EOS}, &TRUE
        End_If
        Call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionArglist, {B$ ': W$ ' EOS}, &FALSE
        Call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionThisAdjust, {B$ ': D$ ' EOS}, &FALSE
        sub edi 2

    Pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP
________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeMFunctionItem:
    Argument @Text1, @Text2, @UseOldCVType
    uses eax, ecx, ebx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.MFunction.' EOS}
        zCopy D@Text1
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        ..If D$eax = 'RvTy'; From "RvType" string
            Call WriteCVBPRel32TypeEquates
            If D@UseOldCVType = &TRUE
                lodsd | Call WriteEax
            Else
                xor eax eax
                lodsw | Call WriteEax
            End_If
        ..Else_If D$eax = 'Clas'; From "Class" string
            Call WriteCVBPRel32TypeEquates
            If D@UseOldCVType = &TRUE
                lodsd | Call WriteEax
            Else
                xor eax eax
                lodsw | Call WriteEax
            End_If
        ..Else_If D$eax = 'This'; From "This" string
            .If D$eax+4 = 'Adju'; From "ThisAdjust" string
                lodsd | Call WriteEax
            .Else   ; From "This" string
                Call WriteCVBPRel32TypeEquates
                If D@UseOldCVType = &TRUE
                    lodsd | Call WriteEax
                Else
                    xor eax eax
                    lodsw | Call WriteEax
                End_If
            .End_If
        ..Else_If D$eax = 'Call'; From "Call" string
            Call WriteCVLF_ProcCallConvTypeEquates
            xor eax eax
            lodsb | Call WriteEax
        ..Else_If W$eax = 'Re'; From "Res" string
            xor eax eax
            lodsb | Call WriteEax
        ..Else_If D$eax = 'Parm'; From "Parms" string
            xor eax eax
            lodsw | Call WriteEax
        ..Else_If D$eax = 'OldC'; From "OldCVType" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax
        ..Else_If D$eax = 'Argl'; From "Arglist" string
            xor eax eax
            lodsw | Call WriteEax
        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

________________________________________________________________________________

Proc WriteCVLF_ProcCallConvTypeEquates:
    Uses esi

    ..If W$esi = &CV4_CALL_NEAR_C
        zCopy {B$ '&CV4_CALL_NEAR_C; Near C (arguments pushed right to left, caller pops arguments) - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_FAR_C
        zCopy {B$ '&CV4_CALL_FAR_C; Far C - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_NEAR_PASCAL
        zCopy {B$ '&CV4_CALL_NEAR_PASCAL; Near Pascal (arguments pushed left to right, callee pops arguments) - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_FAR_PASCAL
        zCopy {B$ '&CV4_CALL_FAR_PASCAL; Far Pascal - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_NEAR_FASTCALL
        zCopy {B$ '&CV4_CALL_NEAR_FASTCALL; Near fastcall - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_FAR_FASTCALL
        zCopy {B$ '&CV4_CALL_FAR_FASTCALL; Far fastcall - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED6
        zCopy {B$ '&CV4_CALL_RESERVED6; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_NEAR_STDCALL
        zCopy {B$ '&CV4_CALL_NEAR_STDCALL; Near stdcall - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_FAR_STDCALL
        zCopy {B$ '&CV4_CALL_FAR_STDCALL; Far stdcall - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_NEAR_SYSCALL
        zCopy {B$ '&CV4_CALL_NEAR_SYSCALL; Near syscall - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_FAR_SYSCALL
        zCopy {B$ '&CV4_CALL_FAR_SYSCALL; Far syscall - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_THIS_CALL
        zCopy {B$ '&CV4_CALL_THIS_CALL; This Call - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_MIPS_CALL
        zCopy {B$ '&CV4_CALL_MIPS_CALL; MIPS Call - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_GENERIC
        zCopy {B$ '&CV4_CALL_GENERIC; Generic - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED14
        zCopy {B$ '&CV4_CALL_RESERVED14; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED15
        zCopy {B$ '&CV4_CALL_RESERVED15; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED16
        zCopy {B$ '&CV4_CALL_RESERVED16; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED17
        zCopy {B$ '&CV4_CALL_RESERVED17; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED18
        zCopy {B$ '&CV4_CALL_RESERVED18; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED19
        zCopy {B$ '&CV4_CALL_RESERVED19; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED20
        zCopy {B$ '&CV4_CALL_RESERVED20; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED21
        zCopy {B$ '&CV4_CALL_RESERVED21; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED22
        zCopy {B$ '&CV4_CALL_RESERVED22; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED23
        zCopy {B$ '&CV4_CALL_RESERVED23; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED24
        zCopy {B$ '&CV4_CALL_RESERVED24; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED25
        zCopy {B$ '&CV4_CALL_RESERVED25; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED26
        zCopy {B$ '&CV4_CALL_RESERVED26; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED27
        zCopy {B$ '&CV4_CALL_RESERVED27; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED28
        zCopy {B$ '&CV4_CALL_RESERVED28; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED29
        zCopy {B$ '&CV4_CALL_RESERVED29; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED30
        zCopy {B$ '&CV4_CALL_RESERVED30; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED31
        zCopy {B$ '&CV4_CALL_RESERVED31; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED32
        zCopy {B$ '&CV4_CALL_RESERVED32; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED33
        zCopy {B$ '&CV4_CALL_RESERVED33; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED34
        zCopy {B$ '&CV4_CALL_RESERVED34; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED35
        zCopy {B$ '&CV4_CALL_RESERVED35; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED36
        zCopy {B$ '&CV4_CALL_RESERVED36; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED37
        zCopy {B$ '&CV4_CALL_RESERVED37; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED38
        zCopy {B$ '&CV4_CALL_RESERVED38; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED39
        zCopy {B$ '&CV4_CALL_RESERVED39; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED40
        zCopy {B$ '&CV4_CALL_RESERVED40; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED41
        zCopy {B$ '&CV4_CALL_RESERVED41; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED42
        zCopy {B$ '&CV4_CALL_RESERVED42; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED43
        zCopy {B$ '&CV4_CALL_RESERVED43; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED44
        zCopy {B$ '&CV4_CALL_RESERVED44; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED45
        zCopy {B$ '&CV4_CALL_RESERVED45; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED46
        zCopy {B$ '&CV4_CALL_RESERVED46; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED47
        zCopy {B$ '&CV4_CALL_RESERVED47; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED48
        zCopy {B$ '&CV4_CALL_RESERVED48; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED49
        zCopy {B$ '&CV4_CALL_RESERVED49; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED50
        zCopy {B$ '&CV4_CALL_RESERVED50; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED51
        zCopy {B$ '&CV4_CALL_RESERVED51; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED52
        zCopy {B$ '&CV4_CALL_RESERVED52; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED53
        zCopy {B$ '&CV4_CALL_RESERVED53; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED54
        zCopy {B$ '&CV4_CALL_RESERVED54; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED55
        zCopy {B$ '&CV4_CALL_RESERVED55; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED56
        zCopy {B$ '&CV4_CALL_RESERVED56; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED57
        zCopy {B$ '&CV4_CALL_RESERVED57; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED58
        zCopy {B$ '&CV4_CALL_RESERVED58; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED59
        zCopy {B$ '&CV4_CALL_RESERVED59; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED60
        zCopy {B$ '&CV4_CALL_RESERVED60; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED61
        zCopy {B$ '&CV4_CALL_RESERVED61; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED62
        zCopy {B$ '&CV4_CALL_RESERVED62; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED63
        zCopy {B$ '&CV4_CALL_RESERVED63; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED64
        zCopy {B$ '&CV4_CALL_RESERVED64; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED65
        zCopy {B$ '&CV4_CALL_RESERVED65; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED66
        zCopy {B$ '&CV4_CALL_RESERVED66; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED67
        zCopy {B$ '&CV4_CALL_RESERVED67; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED68
        zCopy {B$ '&CV4_CALL_RESERVED68; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED69
        zCopy {B$ '&CV4_CALL_RESERVED69; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED70
        zCopy {B$ '&CV4_CALL_RESERVED70; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED71
        zCopy {B$ '&CV4_CALL_RESERVED71; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED72
        zCopy {B$ '&CV4_CALL_RESERVED72; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED73
        zCopy {B$ '&CV4_CALL_RESERVED73; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED74
        zCopy {B$ '&CV4_CALL_RESERVED74; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED75
        zCopy {B$ '&CV4_CALL_RESERVED75; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED76
        zCopy {B$ '&CV4_CALL_RESERVED76; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED77
        zCopy {B$ '&CV4_CALL_RESERVED77; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED78
        zCopy {B$ '&CV4_CALL_RESERVED78; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED79
        zCopy {B$ '&CV4_CALL_RESERVED79; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED80
        zCopy {B$ '&CV4_CALL_RESERVED80; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED81
        zCopy {B$ '&CV4_CALL_RESERVED81; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED82
        zCopy {B$ '&CV4_CALL_RESERVED82; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED83
        zCopy {B$ '&CV4_CALL_RESERVED83; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED84
        zCopy {B$ '&CV4_CALL_RESERVED84; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED85
        zCopy {B$ '&CV4_CALL_RESERVED85; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED86
        zCopy {B$ '&CV4_CALL_RESERVED86; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED87
        zCopy {B$ '&CV4_CALL_RESERVED87; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED88
        zCopy {B$ '&CV4_CALL_RESERVED88; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED89
        zCopy {B$ '&CV4_CALL_RESERVED89; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED90
        zCopy {B$ '&CV4_CALL_RESERVED90; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED91
        zCopy {B$ '&CV4_CALL_RESERVED91; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED92
        zCopy {B$ '&CV4_CALL_RESERVED92; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED93
        zCopy {B$ '&CV4_CALL_RESERVED93; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED94
        zCopy {B$ '&CV4_CALL_RESERVED94; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED95
        zCopy {B$ '&CV4_CALL_RESERVED95; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED96
        zCopy {B$ '&CV4_CALL_RESERVED96; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED97
        zCopy {B$ '&CV4_CALL_RESERVED97; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED98
        zCopy {B$ '&CV4_CALL_RESERVED98; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED99
        zCopy {B$ '&CV4_CALL_RESERVED99; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED100
        zCopy {B$ '&CV4_CALL_RESERVED100; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED101
        zCopy {B$ '&CV4_CALL_RESERVED101; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED102
        zCopy {B$ '&CV4_CALL_RESERVED102; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED103
        zCopy {B$ '&CV4_CALL_RESERVED103; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED104
        zCopy {B$ '&CV4_CALL_RESERVED104; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED105
        zCopy {B$ '&CV4_CALL_RESERVED105; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED106
        zCopy {B$ '&CV4_CALL_RESERVED106; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED107
        zCopy {B$ '&CV4_CALL_RESERVED107; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED108
        zCopy {B$ '&CV4_CALL_RESERVED108; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED109
        zCopy {B$ '&CV4_CALL_RESERVED109; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED110
        zCopy {B$ '&CV4_CALL_RESERVED110; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED111
        zCopy {B$ '&CV4_CALL_RESERVED111; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED112
        zCopy {B$ '&CV4_CALL_RESERVED112; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED113
        zCopy {B$ '&CV4_CALL_RESERVED113; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED114
        zCopy {B$ '&CV4_CALL_RESERVED114; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED115
        zCopy {B$ '&CV4_CALL_RESERVED115; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED116
        zCopy {B$ '&CV4_CALL_RESERVED116; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED117
        zCopy {B$ '&CV4_CALL_RESERVED117; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED118
        zCopy {B$ '&CV4_CALL_RESERVED118; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED119
        zCopy {B$ '&CV4_CALL_RESERVED119; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED120
        zCopy {B$ '&CV4_CALL_RESERVED120; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED121
        zCopy {B$ '&CV4_CALL_RESERVED121; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED122
        zCopy {B$ '&CV4_CALL_RESERVED122; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED123
        zCopy {B$ '&CV4_CALL_RESERVED123; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED124
        zCopy {B$ '&CV4_CALL_RESERVED124; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED125
        zCopy {B$ '&CV4_CALL_RESERVED125; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED126
        zCopy {B$ '&CV4_CALL_RESERVED126; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED127
        zCopy {B$ '&CV4_CALL_RESERVED127; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED128
        zCopy {B$ '&CV4_CALL_RESERVED128; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED129
        zCopy {B$ '&CV4_CALL_RESERVED129; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED130
        zCopy {B$ '&CV4_CALL_RESERVED130; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED131
        zCopy {B$ '&CV4_CALL_RESERVED131; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED132
        zCopy {B$ '&CV4_CALL_RESERVED132; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED133
        zCopy {B$ '&CV4_CALL_RESERVED133; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED134
        zCopy {B$ '&CV4_CALL_RESERVED134; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED135
        zCopy {B$ '&CV4_CALL_RESERVED135; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED136
        zCopy {B$ '&CV4_CALL_RESERVED136; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED137
        zCopy {B$ '&CV4_CALL_RESERVED137; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED138
        zCopy {B$ '&CV4_CALL_RESERVED138; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED139
        zCopy {B$ '&CV4_CALL_RESERVED139; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED140
        zCopy {B$ '&CV4_CALL_RESERVED140; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED141
        zCopy {B$ '&CV4_CALL_RESERVED141; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED142
        zCopy {B$ '&CV4_CALL_RESERVED142; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED143
        zCopy {B$ '&CV4_CALL_RESERVED143; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED144
        zCopy {B$ '&CV4_CALL_RESERVED144; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED145
        zCopy {B$ '&CV4_CALL_RESERVED145; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED146
        zCopy {B$ '&CV4_CALL_RESERVED146; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED147
        zCopy {B$ '&CV4_CALL_RESERVED147; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED148
        zCopy {B$ '&CV4_CALL_RESERVED148; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED149
        zCopy {B$ '&CV4_CALL_RESERVED149; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED150
        zCopy {B$ '&CV4_CALL_RESERVED150; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED151
        zCopy {B$ '&CV4_CALL_RESERVED151; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED152
        zCopy {B$ '&CV4_CALL_RESERVED152; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED153
        zCopy {B$ '&CV4_CALL_RESERVED153; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED154
        zCopy {B$ '&CV4_CALL_RESERVED154; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED155
        zCopy {B$ '&CV4_CALL_RESERVED155; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED156
        zCopy {B$ '&CV4_CALL_RESERVED156; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED157
        zCopy {B$ '&CV4_CALL_RESERVED157; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED158
        zCopy {B$ '&CV4_CALL_RESERVED158; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED159
        zCopy {B$ '&CV4_CALL_RESERVED159; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED160
        zCopy {B$ '&CV4_CALL_RESERVED160; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED161
        zCopy {B$ '&CV4_CALL_RESERVED161; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED162
        zCopy {B$ '&CV4_CALL_RESERVED162; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED163
        zCopy {B$ '&CV4_CALL_RESERVED163; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED164
        zCopy {B$ '&CV4_CALL_RESERVED164; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED165
        zCopy {B$ '&CV4_CALL_RESERVED165; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED166
        zCopy {B$ '&CV4_CALL_RESERVED166; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED167
        zCopy {B$ '&CV4_CALL_RESERVED167; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED168
        zCopy {B$ '&CV4_CALL_RESERVED168; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED169
        zCopy {B$ '&CV4_CALL_RESERVED169; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED170
        zCopy {B$ '&CV4_CALL_RESERVED170; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED171
        zCopy {B$ '&CV4_CALL_RESERVED171; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED172
        zCopy {B$ '&CV4_CALL_RESERVED172; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED173
        zCopy {B$ '&CV4_CALL_RESERVED173; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED174
        zCopy {B$ '&CV4_CALL_RESERVED174; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED175
        zCopy {B$ '&CV4_CALL_RESERVED175; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED176
        zCopy {B$ '&CV4_CALL_RESERVED176; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED177
        zCopy {B$ '&CV4_CALL_RESERVED177; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED178
        zCopy {B$ '&CV4_CALL_RESERVED178; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED179
        zCopy {B$ '&CV4_CALL_RESERVED179; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED180
        zCopy {B$ '&CV4_CALL_RESERVED180; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED181
        zCopy {B$ '&CV4_CALL_RESERVED181; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED182
        zCopy {B$ '&CV4_CALL_RESERVED182; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED183
        zCopy {B$ '&CV4_CALL_RESERVED183; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED184
        zCopy {B$ '&CV4_CALL_RESERVED184; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED185
        zCopy {B$ '&CV4_CALL_RESERVED185; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED186
        zCopy {B$ '&CV4_CALL_RESERVED186; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED187
        zCopy {B$ '&CV4_CALL_RESERVED187; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED188
        zCopy {B$ '&CV4_CALL_RESERVED188; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED189
        zCopy {B$ '&CV4_CALL_RESERVED189; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED190
        zCopy {B$ '&CV4_CALL_RESERVED190; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED191
        zCopy {B$ '&CV4_CALL_RESERVED191; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED192
        zCopy {B$ '&CV4_CALL_RESERVED192; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED193
        zCopy {B$ '&CV4_CALL_RESERVED193; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED194
        zCopy {B$ '&CV4_CALL_RESERVED194; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED195
        zCopy {B$ '&CV4_CALL_RESERVED195; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED196
        zCopy {B$ '&CV4_CALL_RESERVED196; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED197
        zCopy {B$ '&CV4_CALL_RESERVED197; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED198
        zCopy {B$ '&CV4_CALL_RESERVED198; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED199
        zCopy {B$ '&CV4_CALL_RESERVED199; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED200
        zCopy {B$ '&CV4_CALL_RESERVED200; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED201
        zCopy {B$ '&CV4_CALL_RESERVED201; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED202
        zCopy {B$ '&CV4_CALL_RESERVED202; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED203
        zCopy {B$ '&CV4_CALL_RESERVED203; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED204
        zCopy {B$ '&CV4_CALL_RESERVED204; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED205
        zCopy {B$ '&CV4_CALL_RESERVED205; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED206
        zCopy {B$ '&CV4_CALL_RESERVED206; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED207
        zCopy {B$ '&CV4_CALL_RESERVED207; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED208
        zCopy {B$ '&CV4_CALL_RESERVED208; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED209
        zCopy {B$ '&CV4_CALL_RESERVED209; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED210
        zCopy {B$ '&CV4_CALL_RESERVED210; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED211
        zCopy {B$ '&CV4_CALL_RESERVED211; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED212
        zCopy {B$ '&CV4_CALL_RESERVED212; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED213
        zCopy {B$ '&CV4_CALL_RESERVED213; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED214
        zCopy {B$ '&CV4_CALL_RESERVED214; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED215
        zCopy {B$ '&CV4_CALL_RESERVED215; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED216
        zCopy {B$ '&CV4_CALL_RESERVED216; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED217
        zCopy {B$ '&CV4_CALL_RESERVED217; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED218
        zCopy {B$ '&CV4_CALL_RESERVED218; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED219
        zCopy {B$ '&CV4_CALL_RESERVED219; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED220
        zCopy {B$ '&CV4_CALL_RESERVED220; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED221
        zCopy {B$ '&CV4_CALL_RESERVED221; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED222
        zCopy {B$ '&CV4_CALL_RESERVED222; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED223
        zCopy {B$ '&CV4_CALL_RESERVED223; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED224
        zCopy {B$ '&CV4_CALL_RESERVED224; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED225
        zCopy {B$ '&CV4_CALL_RESERVED225; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED226
        zCopy {B$ '&CV4_CALL_RESERVED226; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED227
        zCopy {B$ '&CV4_CALL_RESERVED227; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED228
        zCopy {B$ '&CV4_CALL_RESERVED228; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED229
        zCopy {B$ '&CV4_CALL_RESERVED229; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED230
        zCopy {B$ '&CV4_CALL_RESERVED230; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED231
        zCopy {B$ '&CV4_CALL_RESERVED231; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED232
        zCopy {B$ '&CV4_CALL_RESERVED232; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED233
        zCopy {B$ '&CV4_CALL_RESERVED233; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED234
        zCopy {B$ '&CV4_CALL_RESERVED234; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED235
        zCopy {B$ '&CV4_CALL_RESERVED235; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED236
        zCopy {B$ '&CV4_CALL_RESERVED236; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED237
        zCopy {B$ '&CV4_CALL_RESERVED237; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED238
        zCopy {B$ '&CV4_CALL_RESERVED238; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED239
        zCopy {B$ '&CV4_CALL_RESERVED239; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED240
        zCopy {B$ '&CV4_CALL_RESERVED240; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED241
        zCopy {B$ '&CV4_CALL_RESERVED241; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED242
        zCopy {B$ '&CV4_CALL_RESERVED242; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED243
        zCopy {B$ '&CV4_CALL_RESERVED243; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED244
        zCopy {B$ '&CV4_CALL_RESERVED244; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED245
        zCopy {B$ '&CV4_CALL_RESERVED245; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED246
        zCopy {B$ '&CV4_CALL_RESERVED246; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED247
        zCopy {B$ '&CV4_CALL_RESERVED247; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED248
        zCopy {B$ '&CV4_CALL_RESERVED248; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED249
        zCopy {B$ '&CV4_CALL_RESERVED249; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED250
        zCopy {B$ '&CV4_CALL_RESERVED250; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED251
        zCopy {B$ '&CV4_CALL_RESERVED251; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED252
        zCopy {B$ '&CV4_CALL_RESERVED252; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED253
        zCopy {B$ '&CV4_CALL_RESERVED253; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED254
        zCopy {B$ '&CV4_CALL_RESERVED254; Reserved - Hex Value:  ' EOS}
    ..Else_If W$esi = &CV4_CALL_RESERVED255
        zCopy {B$ '&CV4_CALL_RESERVED255; Reserved - Hex Value:  ' EOS}
    ..End_If

EndP
________________________________________________________________________________


Proc WriteRawDataDebugSContantLeafTypeArgListItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.ArgList' EOS}
        zCopy D@Text1
        If D$ArgListIndexCount <> 0
            ZCopy LeafTypeArgListIndice
        End_If
        zCopy D@Text2
    Pop esi

    Call WriteCVBPRel32TypeEquates
    xor eax eax
    lodsw | Call WriteEax
    Mov W$edi CRLF | add edi 2

EndP

_________________________________________________

[CVLeafTypeArgListIndice: B$ 'Indice' EOS]
[CVLeafTypeArgListOldCVType: B$ 'OldCVType' EOS]


;    Mov D$LeafTypeArgListIndice '0000', D$LeafTypeArgListIndice+4 '01'
;            Call IncrementLeafTypeArgListIndex

[LeafTypeArgListIndice: B$ '000001' EOS]

IncrementLeafTypeArgListIndex:
    lea ebx D$LeafTypeArgListIndice+5 | inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret

[ArgListIndexCount: D$ 0]

Proc WriteRawDataDebugSContantLeafTypeArgList:
    Local @OldCodeView
    Uses eax, ecx, ebx

    Mov D@OldCodeView &FALSE
    If W$esi-2 = &LF_ARGLIST_CV3
        Mov D@OldCodeView &TRUE
    End_If

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Push ecx
        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'Constant.LeafType.ArgList.' EOS}
            zCopy {B$ 'ArgCount: W$ ' EOS}
        Pop esi
        xor eax eax
        lodsw | Call WriteEax
        Mov W$edi CRLF | add edi 2
        Pop ecx

        movzx ecx W$esi-2

    Mov D$ArgListIndexCount ecx
    Mov D$LeafTypeArgListIndice '0000', D$LeafTypeArgListIndice+4 '01'

    .If ecx <> 0 ; if the amount of bytes is 0 jmp over

        L0:
            Call WriteRawDataDebugSContantLeafTypeArgListItem CVLeafTypeArgListIndice, {B$ ': W$ ' EOS}
            If D@OldCodeView = &TRUE
                Call WriteRawDataDebugSContantLeafTypeArgListItem CVLeafTypeArgListOldCVType, {B$ ': W$ ' EOS}
            End_If

            Call IncrementLeafTypeArgListIndex
        Loop L0<

    .End_If

    Pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP


________________________________________________________________________________

[NestedLeafType: D$ 0]

Proc WriteRawDataDebugSContantLeafTypeFieldList:
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx
    ;Mov D@EndAddr ebx


    Mov D$NestedLeafType &TRUE
    Mov D$LeafTypeArrayObjIndice '0000', D$LeafTypeArrayObjIndice+4 '01'

    .Do

        Push esi
            Mov W$edi CRLF | add edi 2
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'Constant.LeafType.Descriptor' EOS}
        Pop esi

        ; from here we must insert a Buffer flag saying it is nested to we use the array indexs
;            Push ebx

        ..If W$esi = &LF_BCLASS
            Push esi | zCopy {B$ '.BClass.Arr' EOS} | Pop esi
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_BCLASS' EOS}
            Call WriteRawDataDebugSContantLeafTypeBClass &FALSE

        ..Else_If W$esi = &LF_VBCLASS
            Push esi | zCopy {B$ '.VBClass.Arr' EOS} | Pop esi
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_VBCLASS' EOS}
            Call WriteRawDataDebugSContantLeafTypeVBClass &FALSE

        ..Else_If W$esi = &LF_IVBCLASS
            Push esi | zCopy {B$ '.IVBClass.Arr' EOS} | Pop esi
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_IVBCLASS' EOS}
            Call WriteRawDataDebugSContantLeafTypeIVBClass &FALSE

        ..Else_If W$esi = &LF_ENUMERATE
            Push esi | zCopy {B$ '.Enumerate.Arr' EOS} | Pop esi
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_ENUMERATE' EOS}
            Call WriteRawDataDebugSContantLeafTypeEnumerate &FALSE

        ..Else_If W$esi = &LF_FRIENDFCN
            Push esi | zCopy {B$ '.FriendFcn.Arr' EOS} | Pop esi
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_FRIENDFCN' EOS}
            Call WriteRawDataDebugSContantLeafTypeFriendFcn &FALSE

        ..Else_If W$esi = &LF_INDEX
            Push esi | zCopy {B$ '.Index.Arr' EOS} | Pop esi
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_INDEX' EOS}
            Call WriteRawDataDebugSContantLeafTypeIndex &FALSE

        ..Else_If W$esi = &LF_MEMBER;, W$esi = 01405
            ;WriteRawDataDebugSRegister
            ;Push ebx
            Push esi | zCopy {B$ '.Member.Arr' EOS} | Pop esi
                If W$esi = &LF_MEMBER
                    Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_MEMBER' EOS}
                Else
                    ;Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_MEMBER_CV3' EOS}
                End_If
                Call WriteRawDataDebugSContantLeafTypeMember &FALSE
            ;Pop ebx
        ..Else_If W$esi = &LF_STMEMBER
            Push esi | zCopy {B$ '.STMember.Arr' EOS} | Pop esi
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_STMEMBER' EOS}
            Call WriteRawDataDebugSContantLeafTypeSTMember &FALSE

        ..Else_If W$esi = &LF_METHOD
            Push esi | zCopy {B$ '.Method.Arr' EOS} | Pop esi
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_METHOD' EOS}
            Call WriteRawDataDebugSContantLeafTypeMethod &FALSE

        ..Else_If W$esi = &LF_NESTTYPE
            Push esi | zCopy {B$ '.NestType.Arr' EOS} | Pop esi
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_NESTTYPE' EOS}
            Call WriteRawDataDebugSContantLeafTypeNestType &FALSE

        ..Else_If W$esi = &LF_VFUNCTAB
            Push esi | zCopy {B$ '.VFuncTab.Arr' EOS} | Pop esi
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_VFUNCTAB' EOS}
            Call WriteRawDataDebugSContantLeafTypeVFuncTab &FALSE

        ..Else_If W$esi = &LF_FRIENDCLS
            Push esi | zCopy {B$ '.FriendCls.Arr' EOS} | Pop esi
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_FRIENDCLS' EOS}
            Call WriteRawDataDebugSContantLeafTypeFriendCls &FALSE

        ..Else_If W$esi = &LF_ONEMETHOD
            Push esi | zCopy {B$ '.OneMethod.Arr' EOS} | Pop esi
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_ONEMETHOD' EOS}
            Call WriteRawDataDebugSContantLeafTypeOneMethod &FALSE

        ..Else_If W$esi = &LF_VFUNCOFF
            Push esi | zCopy {B$ '.VFuncOffset.Arr' EOS} | Pop esi
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_VFUNCOFF' EOS}
            Call WriteRawDataDebugSContantLeafTypeVFuncOffset &FALSE

        ..End_If
;            Push ebx
            .If_And B$esi > &LF_PAD0, B$esi =< &LF_PAD15

                movzx ecx B$esi
                sub ecx 0F0
                Mov W$edi CRLF | add edi 2
                Call WriteCVdataTitle

                    Mov edx 0
                    xor eax eax

                L0:

                    movzx eax B$esi
                    Push ebx | Call WriteEax | Pop ebx

                    Mov W$edi ', ' | add edi 2 | inc esi
                    inc edx
                    If edx > 15
                        Mov W$edi CRLF | add edi 2 | Mov edx 0
                        Mov D$edi '    ', D$edi+4 '    ' | add edi 8
                    End_If
                Loop L0<
                sub edi 2
                dec edi
                Mov W$edi+1 CRLF | add edi 2
                inc edi

            .End_If

            Call IncrementLeafTypeArrayIndex
;            Pop ebx
            ;Pop ebx
        .Loop_Until esi = ebx
;L2:
    Mov D$NestedLeafType &FALSE
    Mov W$edi CRLF | add edi 2
;    sub edi 2
 ;   dec edi
  ;  Mov W$edi+1 CRLF | add edi 2
   ; inc edi

EndP


________________________________________________________________________________

[LeafTypeArrayObjIndice: B$ '000001' EOS]

Proc IncrementLeafTypeArrayIndex:

    pushad

    lea ebx D$LeafTypeArrayObjIndice+5 | inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx | inc B$ebx
    End_While

    popad

EndP
____________________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeBClassItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.BClass.' EOS}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {B$ '.Arr' EOS}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Type'; From "Type" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Offs'; From "Offset" string
            xor eax eax
            lodsw | Call WriteEax

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeBClassType: B$ 'Type' EOS]
[CVLeafTypeVFuncTypeBClassAttribute: B$ 'Attribute' EOS]
[CVLeafTypeVFuncTypeBClassOffset: B$ 'Offset' EOS]

Proc WriteRawDataDebugSContantLeafTypeBClass:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeBClassItem CVLeafTypeVFuncTypeBClassType, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeBClassItem CVLeafTypeVFuncTypeBClassAttribute, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeBClassItem CVLeafTypeVFuncTypeBClassOffset, {B$ ': W$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeVBClassItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.VBClass.' EOS}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {B$ '.Arr' EOS}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Inde'; From "Index" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'bTyp'; From "bType" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'VbTy'; From "VbType" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Vbpo'; From "Vbpoff" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Vbof'; From "Vboff" string
            xor eax eax
            lodsw | Call WriteEax

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeVBClassType: B$ 'Index' EOS]
[CVLeafTypeVFuncTypeVBClassbType: B$ 'bType' EOS]
[CVLeafTypeVFuncTypeVBClassvbType: B$ 'VbType' EOS]
[CVLeafTypeVFuncTypeVBClassAttribute: B$ 'Attribute' EOS]
[CVLeafTypeVFuncTypeVBClassvbpoff: B$ 'Vbpoff' EOS]
[CVLeafTypeVFuncTypeVBClassvboff: B$ 'Vboff' EOS]

Proc WriteRawDataDebugSContantLeafTypeVBClass:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeVBClassItem CVLeafTypeVFuncTypeVBClassType, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeVBClassItem CVLeafTypeVFuncTypeVBClassbType, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeVBClassItem CVLeafTypeVFuncTypeVBClassvbType, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeVBClassItem CVLeafTypeVFuncTypeVBClassAttribute, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeVBClassItem CVLeafTypeVFuncTypeVBClassvbpoff, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeVBClassItem CVLeafTypeVFuncTypeVBClassvboff, {B$ ': W$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeIVBClassItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.IVBClass.' EOS}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {B$ '.Arr' EOS}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Inde'; From "Index" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'bTyp'; From "bType" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'VbTy'; From "VbType" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Vbpo'; From "Vbpoff" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Vbof'; From "Vboff" string
            xor eax eax
            lodsw | Call WriteEax

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeIVBClassType: B$ 'Index' EOS]
[CVLeafTypeVFuncTypeIVBClassbType: B$ 'bType' EOS]
[CVLeafTypeVFuncTypeIVBClassvbType: B$ 'VbType' EOS]
[CVLeafTypeVFuncTypeIVBClassAttribute: B$ 'Attribute' EOS]
[CVLeafTypeVFuncTypeIVBClassvbpoff: B$ 'Vbpoff' EOS]
[CVLeafTypeVFuncTypeIVBClassvboff: B$ 'Vboff' EOS]


Proc WriteRawDataDebugSContantLeafTypeIVBClass:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeIVBClassItem CVLeafTypeVFuncTypeIVBClassType, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeIVBClassItem CVLeafTypeVFuncTypeIVBClassbType, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeIVBClassItem CVLeafTypeVFuncTypeIVBClassvbType, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeIVBClassItem CVLeafTypeVFuncTypeIVBClassAttribute, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeIVBClassItem CVLeafTypeVFuncTypeIVBClassvbpoff, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeIVBClassItem CVLeafTypeVFuncTypeIVBClassvboff, {B$ ': W$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeEnumerateItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.Enumerate.' EOS}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {B$ '.Arr' EOS}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1


        ..If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Valu'; From "Value" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeEnumerateAttribute: B$ 'Attribute' EOS]
[CVLeafTypeVFuncTypeEnumerateValue: B$ 'Value' EOS]
[CVLeafTypeVFuncTypeEnumerateNameLenght: B$ 'NameLenght' EOS]
[CVLeafTypeVFuncTypeEnumerateName: B$ 'Name' EOS]

Proc WriteRawDataDebugSContantLeafTypeEnumerate:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeEnumerateItem CVLeafTypeVFuncTypeEnumerateAttribute, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeEnumerateItem CVLeafTypeVFuncTypeEnumerateValue, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeEnumerateItem CVLeafTypeVFuncTypeEnumerateNameLenght, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeEnumerateItem CVLeafTypeVFuncTypeEnumerateName, {B$ ': B$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeFriendFcnItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.FriendFcn.' EOS}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {B$ '.Arr' EOS}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Type'; From "Type" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeFriendFcnType: B$ 'Type' EOS]
[CVLeafTypeVFuncTypeFriendFcnNameLenght: B$ 'NameLenght' EOS]
[CVLeafTypeVFuncTypeFriendFcnName: B$ 'Name' EOS]

Proc WriteRawDataDebugSContantLeafTypeFriendFcn:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeFriendFcnItem CVLeafTypeVFuncTypeFriendFcnType, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeFriendFcnItem CVLeafTypeVFuncTypeFriendFcnNameLenght, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeFriendFcnItem CVLeafTypeVFuncTypeFriendFcnName, {B$ ': B$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeIndexItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.Type.' EOS}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {B$ '.Arr' EOS}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        xor eax eax
        lodsw | Call WriteEax

        Mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeTypeIndex: B$ 'Index' EOS]

Proc WriteRawDataDebugSContantLeafTypeIndex:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeIndexItem CVLeafTypeVFuncTypeTypeIndex, {B$ ': W$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeMemberItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.Member.' EOS}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {B$ '.Arr' EOS}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        ..If D$eax = 'OldC' ; from "OldCVType" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Type'; From "Type" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Offs'; From "Offset" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeMemberOldCVType: B$ 'OldCVType' EOS]
[CVLeafTypeVFuncTypeMemberType: B$ 'Type' EOS]
[CVLeafTypeVFuncTypeMemberAttribute: B$ 'Attribute' EOS]
[CVLeafTypeVFuncTypeMemberOffset: B$ 'Offset' EOS]
[CVLeafTypeVFuncTypeMemberNameLenght: B$ 'NameLenght' EOS]
[CVLeafTypeVFuncTypeMemberName: B$ 'Name' EOS]
;WriteRawDataDebugSRegister
Proc WriteRawDataDebugSContantLeafTypeMember:
    Arguments @Nested
    Local @OldCodeView
    Uses eax, ecx, ebx

    Mov D@OldCodeView &FALSE
    If W$esi-2 = 01405
        Mov D@OldCodeView &TRUE
    End_If
    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        If D@OldCodeView = &TRUE
            Call WriteRawDataDebugSContantLeafTypeMemberItem CVLeafTypeVFuncTypeMemberOldCVType , {B$ ': W$ ' EOS}
        End_If
        Call WriteRawDataDebugSContantLeafTypeMemberItem CVLeafTypeVFuncTypeMemberType, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeMemberItem CVLeafTypeVFuncTypeMemberAttribute, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeMemberItem CVLeafTypeVFuncTypeMemberOffset, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeMemberItem CVLeafTypeVFuncTypeMemberNameLenght, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeMemberItem CVLeafTypeVFuncTypeMemberName, {B$ ': B$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeSTMemberItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.StMember.' EOS}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {B$ '.Arr' EOS}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Type'; From "Type" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeStMemberType: B$ 'Type' EOS]
[CVLeafTypeVFuncTypeStMemberAttribute: B$ 'Attribute' EOS]
[CVLeafTypeVFuncTypeStMemberNameLenght: B$ 'NameLenght' EOS]
[CVLeafTypeVFuncTypeStMemberName: B$ 'Name' EOS]

Proc WriteRawDataDebugSContantLeafTypeSTMember:
    Arguments @Nested
    Uses eax, ecx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeSTMemberItem CVLeafTypeVFuncTypeStMemberType, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeSTMemberItem CVLeafTypeVFuncTypeStMemberAttribute, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeSTMemberItem CVLeafTypeVFuncTypeStMemberNameLenght, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeSTMemberItem CVLeafTypeVFuncTypeStMemberName, {B$ ': B$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeMethodItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.Method.' EOS}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {B$ '.Arr' EOS}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Coun'; From "Count" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'mLis'; From "mList" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeMethodCount: B$ 'Count' EOS]
[CVLeafTypeVFuncTypeMethodmList: B$ 'mList' EOS]
[CVLeafTypeVFuncTypeMethodNameLenght: B$ 'NameLenght' EOS]
[CVLeafTypeVFuncTypeMethodTypeName: B$ 'Name' EOS]

Proc WriteRawDataDebugSContantLeafTypeMethod:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeMethodItem CVLeafTypeVFuncTypeMethodCount, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeMethodItem CVLeafTypeVFuncTypeMethodmList, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeMethodItem CVLeafTypeVFuncTypeMethodNameLenght, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeMethodItem CVLeafTypeVFuncTypeMethodTypeName, {B$ ': B$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP
_________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeNestTypeItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.NestedType.' EOS}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {B$ '.Arr' EOS}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Inde'; From "Index" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeNestTypeIndex: B$ 'Index' EOS]
[CVLeafTypeVFuncTypeNestTypeNameLenght: B$ 'NameLenght' EOS]
[CVLeafTypeVFuncTypeNestTypeName: B$ 'Name' EOS]

Proc WriteRawDataDebugSContantLeafTypeNestType:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeNestTypeItem CVLeafTypeVFuncTypeNestTypeIndex, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeNestTypeItem CVLeafTypeVFuncTypeNestTypeNameLenght, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeNestTypeItem CVLeafTypeVFuncTypeNestTypeName, {B$ ': B$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP
_________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeVFuncTabItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.VFuncTab.' EOS}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {B$ '.Arr' EOS}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        xor eax eax
        lodsw | Call WriteEax

        Mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeVFuncTabType: B$ 'Type' EOS]

Proc WriteRawDataDebugSContantLeafTypeVFuncTab:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeVFuncTabItem CVLeafTypeVFuncTypeVFuncTabType, {B$ ': W$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeFriendClsItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.FriendClass.' EOS}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {B$ '.Arr' EOS}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        xor eax eax
        lodsw | Call WriteEax

        Mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeFriendClsType: B$ 'Type' EOS]

Proc WriteRawDataDebugSContantLeafTypeFriendCls:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeFriendClsItem CVLeafTypeVFuncTypeFriendClsType, {B$ ': W$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

__________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeOneMethodItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.OneMethod.' EOS}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {B$ '.Arr' EOS}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Type'; From "Type" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'vBas'; From "vBaseOffset" string
            lodsd | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeOneMethodattribute: B$ 'Attribute' EOS]
[CVLeafTypeVFuncTypeOneMethodType: B$ 'Type' EOS]
[CVLeafTypeVFuncTypeOneMethodvBaseOffset: B$ 'vBaseOffset' EOS]
[CVLeafTypeVFuncTypeOneMethodNameLenght: B$ 'NameLenght' EOS]
[CVLeafTypeVFuncTypeOneMethodName: B$ 'Name' EOS]

Proc WriteRawDataDebugSContantLeafTypeOneMethod:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeOneMethodItem CVLeafTypeVFuncTypeOneMethodattribute, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeOneMethodItem CVLeafTypeVFuncTypeOneMethodType, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeOneMethodItem CVLeafTypeVFuncTypeOneMethodvBaseOffset, {B$ ': D$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeOneMethodItem CVLeafTypeVFuncTypeOneMethodNameLenght, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeOneMethodItem CVLeafTypeVFuncTypeOneMethodName, {B$ ': B$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeVFuncOffsetItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.VFunc.' EOS}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {B$ '.Arr' EOS}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

         ..If D$eax = 'Type'; From "Type" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Offs'; From "Offset" string
            lodsd | Call WriteEax

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncType: B$ 'Type' EOS]
[CVLeafTypeVFuncOffset: B$ 'Offset' EOS]

Proc WriteRawDataDebugSContantLeafTypeVFuncOffset:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeVFuncOffsetItem CVLeafTypeVFuncType, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeVFuncOffsetItem CVLeafTypeVFuncOffset, {B$ ': D$ ' EOS}
        sub edi 2
    Pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeComplexNumber:
    Argument @Text, @Size
    Uses eax, ecx

    Mov ebx esi
    Mov ecx D@Size
    add ebx ecx

    .If esi <> ebx
        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'Constant.LeafType.' EOS}
            zCopy D@Text
            zCopy {B$ ': B$ ' EOS}
        Pop esi

        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

        sub edi 2
        dec edi
        Mov W$edi+1 CRLF | add edi 2
        Pop ecx
        inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP
________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeVarStrItem:
    Argument @Text1, @Text2
    uses eax, ecx

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'Constant.LeafType.VarStr' EOS}
        zCopy D@Text1
        zCopy D@Text2
    Pop esi

        Mov eax D@Text1

        ..If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx W$esi-2
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

______________________________________________

Proc WriteRawDataDebugSContantLeafTypeVarStr:
    Uses eax, ecx

    Call WriteRawDataDebugSContantLeafTypeVarStrItem CVCompileNameLenght, {B$ ': W$ ' EOS}
    Call WriteRawDataDebugSContantLeafTypeVarStrItem CVCompileName, {B$ ': B$ ' EOS}
    sub edi 2

EndP
______________________________________________

Proc WriteRawDataDebugSContantLeafTypeEquate:
    Argument @Text
    uses eax, ecx, ebx


    If D$NestedLeafType = &TRUE
        Push esi | zCopy LeafTypeArrayObjIndice | Pop esi
    End_If
    Push esi
        zCopy {B$ ': W$ ' EOS}
        zCopy D@Text
        zCopy {B$ ' ; Hex Value:  ' EOS}
    Pop esi
    xor eax eax
    lodsw | Call WriteEax
    Mov W$edi CRLF | add edi 2

EndP

___________________________________________

[LeafTypeError: D$ &TRUE]

; The PDebug section is nothing but a Type.
; Note: Check the file SDKUTIL from lcc library

Proc WriteRawDataDebugSContantLeafTypeItem:
    Uses eax, ecx

    Mov D$LeafTypeError &TRUE ; In Any case, the default is True, meaning that we have no errors.

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'Constant.LeafType' EOS}
        Pop esi

    ; 1st we need to identify the Undefined Leaf Types. Accordying to the documentation, we have:

    ; a) No LF_... index can have a value of 0x0000.
    ; b) Because of the method used to maintain natural alignment in complex lists, no leaf index can
    ;    have a value greater than or equal to 0xf000.
    ; c) Also, no leaf index can have a value such that the least significant 8 bits of the value
    ;    is greater than or equal to 0xf0.

    ...If W$esi = 0
        jmp L0>
    ...Else_If W$esi >= 0F000
L0:     Push esi | zCopy {B$ ': W$ ' EOS} | Pop esi
        xor eax eax
        lodsw | Call WriteEax
        zCopy {B$ ' ; No Defined Type' EOS}

        Mov D$LeafTypeError &FALSE ; Set the error case

    ...Else_If B$esi >= 0F0

        Push esi | zCopy {B$ '.Padding: B$ ' EOS} | Pop esi

        Push esi

        .If B$esi = &LF_PAD0
            zCopy {B$ '&LF_PAD0 ; Hex Value:  ' EOS}
        .Else_If B$esi = &LF_PAD1
            zCopy {B$ '&LF_PAD1 ; Hex Value:  ' EOS}
        .Else_If B$esi = &LF_PAD2
            zCopy {B$ '&LF_PAD2 ; Hex Value:  ' EOS}
        .Else_If B$esi = &LF_PAD3
            zCopy {B$ '&LF_PAD3 ; Hex Value:  ' EOS}
        .Else_If B$esi = &LF_PAD4
            zCopy {B$ '&LF_PAD4 ; Hex Value:  ' EOS}
        .Else_If B$esi = &LF_PAD5
            zCopy {B$ '&LF_PAD5 ; Hex Value:  ' EOS}
        .Else_If B$esi = &LF_PAD6
            zCopy {B$ '&LF_PAD6 ; Hex Value:  ' EOS}
        .Else_If B$esi = &LF_PAD7
            zCopy {B$ '&LF_PAD7 ; Hex Value:  ' EOS}
        .Else_If B$esi = &LF_PAD8
            zCopy {B$ '&LF_PAD8 ; Hex Value:  ' EOS}
        .Else_If B$esi = &LF_PAD9
            zCopy {B$ '&LF_PAD9 ; Hex Value:  ' EOS}
        .Else_If B$esi = &LF_PAD10
            zCopy {B$ '&LF_PAD10 ; Hex Value:  ' EOS}
        .Else_If B$esi = &LF_PAD11
            zCopy {B$ '&LF_PAD11 ; Hex Value:  ' EOS}
        .Else_If B$esi = &LF_PAD12
            zCopy {B$ '&LF_PAD12 ; Hex Value:  ' EOS}
        .Else_If B$esi = &LF_PAD13
            zCopy {B$ '&LF_PAD13 ; Hex Value:  ' EOS}
        .Else_If B$esi = &LF_PAD14
            zCopy {B$ '&LF_PAD14 ; Hex Value:  ' EOS}
        .Else_If B$esi = &LF_PAD15
            zCopy {B$ '&LF_PAD15 ; Hex Value:  ' EOS}
        .End_If

        Pop esi

        xor eax eax
        lodsb | Call WriteEax

        Push esi
            zCopy {B$ ' - No Defined Type' EOS}
            Mov W$edi CRLF | add edi 2
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ '.Undefined: B$ ' EOS}
        Pop esi

        xor eax eax
        lodsb | Call WriteEax
        zCopy {B$ ' ; No Defined Type' EOS}

        Mov D$LeafTypeError &FALSE ; Set the error case

    ; 2nd We must now identify the known defined Types.

    ...Else

        ..If_Or W$esi = &LF_MODIFIER, W$esi = &LF_MODIFIER_CV3
            If W$esi = &LF_MODIFIER
                Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_MODIFIER' EOS}
            Else
                Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_MODIFIER_CV3' EOS}
            End_If
            Call WriteRawDataDebugSContantLeafTypeModifier

        ..Else_If_Or W$esi = &LF_POINTER, W$esi = &LF_POINTER_CV3 ; see sdkutil.lib to we handle the equates for the different Bits (A true hell)
            If W$esi = &LF_POINTER
                Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_POINTER' EOS}
            Else
                Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_POINTER_CV3' EOS}
            End_If
            Call WriteRawDataDebugSContantLeafTypePointer

        ..Else_If W$esi = &LF_ARRAY
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_ARRAY' EOS}
            Call WriteRawDataDebugSContantLeafTypeArray

        ..Else_If W$esi = &LF_CLASS
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_CLASS' EOS}
            Call WriteRawDataDebugSContantLeafTypeStructure

        ..Else_If_Or W$esi = &LF_STRUCTURE, W$esi = &LF_STRUCTURE_CV3
            If W$esi = &LF_STRUCTURE
                Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_STRUCTURE' EOS}
            Else
                Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_STRUCTURE_CV3' EOS}
            End_If
            Call WriteRawDataDebugSContantLeafTypeStructure

        ..Else_If_Or W$esi = &LF_UNION, W$esi = &LF_UNION_CV3
            If W$esi = &LF_UNION
                Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_UNION' EOS}
            Else
                Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_UNION_CV3' EOS}
            End_If
            Call WriteRawDataDebugSContantLeafTypeUnion

        ..Else_If W$esi = &LF_ENUM
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_ENUM' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_PROCEDURE
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_PROCEDURE' EOS}
            Call WriteRawDataDebugSContantLeafTypeProcedure

        ..Else_If_Or W$esi = &LF_MFUNCTION, W$esi = &LF_MFUNCTION_CV3
            If W$esi = &LF_MFUNCTION
                Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_MFUNCTION' EOS}
            Else
                Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_MFUNCTION_CV3' EOS}
            End_If
                Call WriteRawDataDebugSContantLeafTypeMFunction

        ..Else_If W$esi = &LF_VTSHAPE
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_VTSHAPE' EOS}
            sub esi 2
            jmp L0>>
            ; Note to Guga. The error in sdkutil is here. Missing this parse

        ..Else_If W$esi = &LF_COBOL0
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_COBOL0' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_COBOL1
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_COBOL1' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_BARRAY
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_BARRAY' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_LABEL
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_LABEL' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_NULL
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_NULL' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_NOTTRAN
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_NOTTRAN' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_DIMARRAY
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_DIMARRAY' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_VFTPATH
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_VFTPATH' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_PRECOMP
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_PRECOMP' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_ENDPRECOMP
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_ENDPRECOMP' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_OEM
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_OEM' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_RESERVED
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_RESERVED' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_SKIP
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_SKIP' EOS}
            jmp L0>>

        ..Else_If_Or W$esi = &LF_ARGLIST, W$esi = &LF_ARGLIST_CV3
            If W$esi = &LF_ARGLIST
                Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_ARGLIST' EOS}
            Else
                Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_ARGLIST_CV3' EOS}
            End_If
            Call WriteRawDataDebugSContantLeafTypeArgList

        ..Else_If W$esi = &LF_DEFARG
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_DEFARG' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_LIST
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_LIST' EOS}
            jmp L0>>

        ..Else_If_Or W$esi = &LF_FIELDLIST;, W$esi = 01203
        ;WriteRawDataDebugSRegister
            If W$esi = &LF_FIELDLIST
                Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_FIELDLIST' EOS}
            Else
                ;Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_FIELDLIST_CV3' EOS}
            End_If
            Call WriteRawDataDebugSContantLeafTypeFieldList

        ..Else_If W$esi = &LF_DERIVED
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_DERIVED' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_BITFIELD
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_BITFIELD' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_METHODLIST
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_METHODLIST' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_DIMCONU
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_DIMCONU' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_DIMCONLU
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_DIMCONLU' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_DIMVARU
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_DIMVARU' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_DIMVARLU
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_DIMVARLU' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_REFSYM
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_REFSYM' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_BCLASS
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_BCLASS' EOS}
            Call WriteRawDataDebugSContantLeafTypeBClass &FALSE

        ..Else_If W$esi = &LF_VBCLASS
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_VBCLASS' EOS}
            Call WriteRawDataDebugSContantLeafTypeVBClass &FALSE

        ..Else_If W$esi = &LF_IVBCLASS
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_IVBCLASS' EOS}
            Call WriteRawDataDebugSContantLeafTypeIVBClass &FALSE

        ..Else_If W$esi = &LF_ENUMERATE
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_ENUMERATE' EOS}
            Call WriteRawDataDebugSContantLeafTypeEnumerate &FALSE

        ..Else_If W$esi = &LF_FRIENDFCN
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_FRIENDFCN' EOS}
            Call WriteRawDataDebugSContantLeafTypeFriendFcn &FALSE

        ..Else_If W$esi = &LF_INDEX
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_INDEX' EOS}
            Call WriteRawDataDebugSContantLeafTypeIndex &FALSE

        ..Else_If W$esi = &LF_MEMBER
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_MEMBER' EOS}
            Call WriteRawDataDebugSContantLeafTypeMember &FALSE

        ..Else_If W$esi = &LF_STMEMBER
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_STMEMBER' EOS}
            Call WriteRawDataDebugSContantLeafTypeSTMember &FALSE

        ..Else_If W$esi = &LF_METHOD
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_METHOD' EOS}
            Call WriteRawDataDebugSContantLeafTypeMethod &FALSE

        ..Else_If W$esi = &LF_NESTTYPE
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_NESTTYPE' EOS}
            Call WriteRawDataDebugSContantLeafTypeNestType &FALSE

        ..Else_If W$esi = &LF_VFUNCTAB
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_VFUNCTAB' EOS}
            Call WriteRawDataDebugSContantLeafTypeVFuncTab &FALSE

        ..Else_If W$esi = &LF_FRIENDCLS
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_FRIENDCLS' EOS}
            Call WriteRawDataDebugSContantLeafTypeFriendCls &FALSE

        ..Else_If W$esi = &LF_ONEMETHOD
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_ONEMETHOD' EOS}
            Call WriteRawDataDebugSContantLeafTypeOneMethod &FALSE

        ..Else_If W$esi = &LF_VFUNCOFF
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_VFUNCOFF' EOS}
            Call WriteRawDataDebugSContantLeafTypeVFuncOffset &FALSE

        ..Else_If W$esi = &LF_NUMERIC
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_NUMERIC' EOS}
            jmp L0>>

        ..Else_If W$esi = &LF_CHAR
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_CHAR' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Char' EOS}, 1

        ..Else_If W$esi = &LF_SHORT
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_SHORT' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Short' EOS}, 2

        ..Else_If W$esi = &LF_USHORT
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_USHORT' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'UShort' EOS}, 2

        ..Else_If W$esi = &LF_LONG
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_LONG' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Long' EOS}, 4

        ..Else_If W$esi = &LF_ULONG
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_ULONG' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'ULong' EOS}, 4

        ..Else_If W$esi = &LF_REAL32
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_REAL32' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Float32Bit' EOS}, 4

        ..Else_If W$esi = &LF_REAL64
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_REAL64' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Float64Bit' EOS}, 8

        ..Else_If W$esi = &LF_REAL80
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_REAL80' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Float80Bit' EOS}, 10

        ..Else_If W$esi = &LF_REAL128
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_REAL128' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Float128Bit' EOS}, 16

        ..Else_If W$esi = &LF_QUADWORD
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_QUADWORD' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Quadword' EOS}, 8

        ..Else_If W$esi = &LF_UQUADWORD
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_UQUADWORD' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'UQuadword' EOS}, 8

        ..Else_If W$esi = &LF_REAL48
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_REAL48' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Real48Bit' EOS}, 6

        ..Else_If W$esi = &LF_COMPLEX32
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_COMPLEX32' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Complex32BitReal' EOS}, 4
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Complex32BitImaginary' EOS}, 4

        ..Else_If W$esi = &LF_COMPLEX64
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_COMPLEX64' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Complex64BitReal' EOS}, 8
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Complex64BitImaginary' EOS}, 8

        ..Else_If W$esi = &LF_COMPLEX80
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_COMPLEX80' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Complex80BitReal' EOS}, 10
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Complex80BitImaginary' EOS}, 10

        ..Else_If W$esi = &LF_COMPLEX128
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_COMPLEX128' EOS}
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Complex128BitReal' EOS}, 16
            Call WriteRawDataDebugSContantLeafTypeComplexNumber {B$ 'Complex128BitImaginary' EOS}, 16

        ..Else_If W$esi = &LF_VARSTRING
            Call WriteRawDataDebugSContantLeafTypeEquate {B$ '&LF_VARSTRING' EOS}
            Call WriteRawDataDebugSContantLeafTypeVarStr

        ..Else
L0:

            Push ecx
            Push eax
            Push esi
                If D$NestedLeafType = &TRUE
                    zCopy LeafTypeArrayObjIndice
                End_If
                zCopy {B$ '.TypeUnknown: W$ ' EOS}
            Pop esi
            xor eax eax
            lodsw | Call WriteEax
            Mov W$edi CRLF | add edi 2
            Pop eax
            Pop ecx
            sub D$SizeAdd 2


        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'Constant.LeafType' EOS}
        Pop esi


            Call WriteRawDataDebugSContantLeafTypeUnkown
            Mov D$LeafTypeError &FALSE ; Set the error case

        ..End_If

    ...End_If

    Mov W$edi CRLF | add edi 2

EndP
__________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeUnkown:
    Uses eax, ecx


    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
;    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx
;;
;;
    Push ebx

                    Push esi
                        Mov D$edi '    ' | add edi 4
                        Call WriteObjIndice
                        zCopy {B$ "Sec" EOS}
                        zCopy SectionHeaderNumber
                        zCopy {B$ ".Index" EOS}
                        zCopy DebugNumber
                        zCopy D$CVLabel
                        zCopy {B$ 'Constant.LeafType.Unknown: B$ ' EOS}
                    Pop esi
    Pop ebx
;;
;;

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayElemType , {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayIdxType , {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayLength, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayNamelenght, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayName, {B$ ': B$ ' EOS}
        sub edi 2
    Pop ebx
;;

;;
    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
;;
;;
        Mov W$edi CRLF | add edi 2
        ;Call WriteCVdataTitle
                    Push esi
                        Mov D$edi '    ' | add edi 4
                        Call WriteObjIndice
                        zCopy {B$ "Sec" EOS}
                        zCopy SectionHeaderNumber
                        zCopy {B$ ".Index" EOS}
                        zCopy DebugNumber
                        zCopy D$CVLabel
                        zCopy {B$ 'Constant.LeafType.Unknown: B$ ' EOS}
                    Pop esi

;;
;;
        Push esi | ZCopy {B$ '.Unknown: B$ ' EOS} | Pop esi

        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP
__________________________________________________________________

Proc WriteRawDataDebugSContantItem:
    Argument @Text1, @Text2, @UseLen
    uses eax, ecx, edx

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'Constant.' EOS}
            zCopy D@Text1
            zCopy D@Text2
        Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Type' ; from "Type" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'OldC' ; from "OldCVType" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            If D@UseLen = &TRUE ; this happens only in S_CONSTANT_CV2.
                Push eax
                    Call StrLenProc esi
                    Mov ecx eax
                    inc ecx ; The size is increased to we alow including the zero byte
                Pop eax
            Else
                movzx ecx B$esi-1
            End_If

            Mov edx esi | add edx ecx


            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP
_______________________________________
;;

;;
Structures used:

. Note, in all equates used to dirrefernciate the structures, when Type member is 0 (&T_NOTYPE), the structure
is related to a enumeration, and the leaf member types (achieved from WriteRawDataDebugSContantLeafTypeItem) are not
used. Instead, the Constant.LeafType is replaced by an EnumerationValue member

 - S_CONSTANT_CV3 uses:
 
     CV3.Length: W$ 015
     CV3.Index: W$ &S_CONSTANT_CV3; Hex Value:  01002
     CV3.Constant.OldCVType: W$ 01058
     CV3.Constant.Type: W$ &T_NOTYPE ; Uncharacterized type (no type) - Hex Value:  0
     CV3.Constant.EnumerationValue: W$ 02 ; This symbol is an enumeration constant type.
     CV3.Constant.NameLenght: B$ 0C
     CV3.Constant.Name: B$ 'STUB_MARSHAL'

 - S_CONSTANT_CV2 uses:
 
     CV3.Length: W$ 015
     CV3.Index: W$ &S_CONSTANT_CV2; Hex Value:  01107
     CV3.Constant.OldCVType: W$ 01058
     CV3.Constant.Type: W$ &T_NOTYPE ; Uncharacterized type (no type) - Hex Value:  0
     CV3.Constant.EnumerationValue: W$ 02 ; This symbol is an enumeration constant type.
     CV3.Constant.NameLenght: B$ 0C
     CV3.Constant.Name: B$ 'STUB_MARSHAL'

;;
;;
[CVConstantOldCVType: B$ 'OldCVType' EOS]
[CVConstantType: B$ 'Type' EOS]
[CVConstantNameLenght: B$ 'NameLenght' EOS]
[CVConstantName: B$ 'Name' EOS]

Proc WriteRawDataDebugSContant:
    Local @OldCodeView
    Uses ecx, eax


    Mov D@OldCodeView &FALSE
    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx

    If W$esi-2 = &S_CONSTANT_CV3
        Call WriteRawDataDebugSContantItem CVConstantOldCVType, {B$ ': W$ ' EOS}, &FALSE
    Else_If W$esi-2 = &S_CONSTANT_CV2
        Call WriteRawDataDebugSContantItem CVConstantOldCVType, {B$ ': W$ ' EOS}, &FALSE
        Mov D@OldCodeView &TRUE
    End_If

    Call WriteRawDataDebugSContantItem CVConstantType, {B$ ': W$ ' EOS}, &FALSE

    .If W$esi-2 = &T_NOTYPE
        Push ecx
        Push eax
        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'Constant.EnumerationValue: W$ ' EOS}
        Pop esi
        xor eax eax
        lodsw | Call WriteEax

        Push esi | zCopy {B$ ' ; This symbol is an enumeration constant type.' EOS} | Pop esi
        Mov W$edi CRLF | add edi 2
        Pop eax
        Pop ecx
    .Else
        Call WriteRawDataDebugSContantLeafTypeItem
    .End_If

    .If D$LeafTypeError <> &FALSE ; No Errors. Do next Line. Jmp otherwise
        If D@OldCodeView = &FALSE
            Call WriteRawDataDebugSContantItem CVCompileNameLenght, {B$ ': B$ ' EOS}, &FALSE
            Call WriteRawDataDebugSContantItem CVCompileName, {B$ ': B$ ' EOS}, &FALSE
        Else
            Call WriteRawDataDebugSContantItem CVCompileName, {B$ ': B$ ' EOS}, &TRUE
        End_If
    .End_If


    Pop ebx

    ; Is the end of this structure ends on the proper place ?

    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

__________________________________________________________________

[CVUDTOldCVType: B$ 'OldCVType' EOS]
[CVUDTType: B$ 'Type' EOS]
[CVUDTNamelenght: B$ 'NameLenght' EOS]
[CVUDTName: B$ 'Name' EOS]

Proc WriteRawDataDebugSUDT:
    Local @OldCodeView
    Uses ecx

    Mov D@OldCodeView 0
    If W$esi-2 = &S_UDT_CV3
        Mov D@OldCodeView 1
    Else_If W$esi-2 = &S_UDT_CV2
        Mov D@OldCodeView 2
    End_If

    If D@OldCodeView <> 0
        Call WriteRawDataDebugSUDTItem CVUDTOldCVType , {B$ ': W$ ' EOS}, &FALSE
    End_If

    Call WriteRawDataDebugSUDTItem CVUDTType , {B$ ': W$ ' EOS}, &FALSE

    If D@OldCodeView = 2
        Call WriteRawDataDebugSUDTItem CVUDTName , {B$ ': B$ ' EOS}, &TRUE
    Else
        Call WriteRawDataDebugSUDTItem CVUDTNamelenght , {B$ ': B$ ' EOS}, &FALSE
        Call WriteRawDataDebugSUDTItem CVUDTName , {B$ ': B$ ' EOS}, &FALSE
    End_If
EndP
__________________________________________________________________

Proc WriteRawDataDebugSUDTItem:
    Argument @Text1, @Text2, @UseLen
    uses eax, ecx

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'UDT.' EOS}
            zCopy D@Text1
            zCopy D@Text2
        Pop esi

        Mov eax D@Text1

        ..If D$eax = 'OldC'; From "OldCVType" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Type'; From "Type" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            If D@UseLen = &TRUE ; this happens only in S_CONSTANT_CV2.
                Push eax
                    Call StrLenProc esi
                    Mov ecx eax
                    inc ecx ; The size is increased to we alow including the zero byte
                Pop eax
            Else
                movzx ecx B$esi-1
            End_If

            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP
__________________________________________________________________



;WriteCVCompileFlag1Equates
;WriteCVGlobalProcFlagEquates
;;
;;
Flag Member:

The Flag member is a Byte value responsable for several different computations accordying to specified bits.
We need to shr the founded values to find the proper equates used. This member is the Flags for the specified
procedure.

Fpo :1  Uses Bit 0. When this bit is flagged the function has frame pointer omitted. Otherwise it don't use.
        Equates:    CV4_FUNCTION_FPO_ENABLED 01
                    CV4_FUNCTION_FPO_DISABLED 0

Interrupt :1  Uses Bit 1. When this bit is flagged the function is interrupt routine. Otherwise it is not.
              Equates:    CV4_FUNCTION_INT_ENABLED 01
                          CV4_FUNCTION_INT_DISABLED 0

Return :1  Uses Bit 2. When this bit is flagged the function performs Far return. Otherwise it doesn't.
            Equates:    CV4_FUNCTION_RET_ENABLED 01
                        CV4_FUNCTION_RET_DISABLED 0

Never :1  Uses Bit 3. When this bit is flagged the function never returns. Otherwise it does.
            Equates:    CV4_FUNCTION_NORET_ENABLED 01
                        CV4_FUNCTION_NORET_DISABLED 0

Bits 4 to 7 are not used. They must be settled to 0.

;;
;;
Proc WriteCVGlobalProcFlagEquates:
    Uses esi, ebx, eax

    xor eax eax | lodsb
   ; We must clear Bits 4 to 7 because they are not used
    btr eax 4 | btr eax 5 | btr eax 6 | btr eax 7
    Mov ebx eax

    Push ebx
    Push eax

    shr ebx 3 ; This is to calculate Never member. Shr by 3 because the Bit 3 is the one that is starting to be flagged.

    .If ebx = &CV4_FUNCTION_NORET_ENABLED
        zCopy {B$ '(&CV4_FUNCTION_NORET_ENABLED shl 3)' EOS}
    .Else;_If ebx = CV4_FUNCTION_NORET_DISABLED
        zCopy {B$ '(&CV4_FUNCTION_NORET_DISABLED shl 3)' EOS}
    .End_If

        zCopy {B$ ' + ' EOS}
        ; Now we must Zero bit 3 to shr again to find the next records for Return Member (Bit 2)
        btr eax 3
        ; After clearing the bits, we need to compute only the needed bits to be shred
        shr eax 2 ; This is to calculate Return member. Shr by 2 because the Bit 2 is the one that is starting to be flagged.

    .If eax = &CV4_FUNCTION_RET_ENABLED
        zCopy {B$ '(&CV4_FUNCTION_RET_ENABLED shl 2)' EOS}
    .Else;_If eax = CV4_FUNCTION_RET_DISABLED
        zCopy {B$ '(&CV4_FUNCTION_RET_DISABLED shl 2)' EOS}
    .End_If

    Pop eax
    Pop ebx

        zCopy {B$ ' + ' EOS}

    ; Now we restored the values of ebx and eax. We will going to find the values for
    ; Interrupt (Bit 1) and Fpo (Bit 0)
    ; Since we restored the values we must clear bits 2 to 3 (Rememeber that bits 4 to 7 are already cleared)

    ; zeroes bits 2 to 3
    btr eax 2 | btr eax 3

    shr eax 1 ; This is to calculate Interrupt. Shr by 1 because the Bit 1 is the one that is starting to be flagged.

    .If eax = &CV4_FUNCTION_INT_ENABLED
        zCopy {B$ '(&CV4_FUNCTION_INT_ENABLED shl 1)' EOS}
    .Else;_If eax = CV4_FUNCTION_INT_DISABLED
        zCopy {B$ '(&CV4_FUNCTION_INT_DISABLED shl 1)' EOS}
    .End_If

        zCopy {B$ ' + ' EOS}

    and ebx 01 ; This is to calculate Fpo.
               ; The value of 1 is because it is the maximum value of all bits flagged. (Bit 0)

    .If ebx = &CV4_FUNCTION_FPO_ENABLED
        zCopy {B$ '&CV4_FUNCTION_FPO_ENABLED' EOS}
    .Else
        zCopy {B$ '&CV4_FUNCTION_FPO_DISABLED' EOS}
    .End_If

        zCopy {B$ ' ; Hex Value:  ' EOS}

EndP

______________________________________

Proc WriteRawDataDebugSGlobalProcItem:
    Argument @Text1, @Text2
    uses eax, ecx

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy D$CVGlobalProcLabel;{B$ 'GlobalProcedure.' EOS}
            zCopy D@Text1
            zCopy D@Text2
        Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Ppar' ; from "Pparent" string
            lodsd | Call WriteEax

        ..Else_If D$eax = 'Pend'; From "Pend" string
            lodsd | Call WriteEax

        ..Else_If D$eax = 'Pnex'; From "Pnext" string
            lodsd | Call WriteEax

        ..Else_If D$eax+2 = 'ocLe'; From "ProcLength" string
            lodsd | Call WriteEax

        ..Else_If D$eax+4 = 'gSta'; From "DebugStart" string
            lodsd | Call WriteEax

        ..Else_If D$eax+4 = 'gEnd'; From "DebugEnd" string
            lodsd | Call WriteEax

        ..Else_If D$eax = 'OldC'; From "OldCVType" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Offs'; From "Offset" string
            lodsd | Call WriteEax

        ..Else_If D$eax = 'Segm'; From "Segment" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+2 = 'octy'; From "Proctype" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax
            .If W$esi-2 >= &CV_FIRST_NONPRIM
                Push esi | ZCopy {B$ "; This is a Non-Primitive Type. The value is: " EOS} | Pop esi
                movzx eax W$esi-2
                sub eax &CV_FIRST_NONPRIM
                Call WriteEax
            .End_If

        ..Else_If D$eax = 'Flag'; From "Flags" string
            Call WriteCVGlobalProcFlagEquates
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                ;Mov B$edi "'" | inc edi
                Mov B$edi '"' | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             ;Mov B$edi "'" | inc edi
                Mov B$edi '"' | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

________________________

[CVGlobalProcPparent: B$ 'Pparent' EOS]
[CVGlobalProcPend: B$ 'Pend' EOS]
[CVGlobalProcPnext: B$ 'Pnext' EOS]
[CVGlobalProcLength: B$ 'ProcLength' EOS]
[CVGlobalProcDebugStart: B$ 'DebugStart' EOS]
[CVGlobalProcDebugEnd: B$ 'DebugEnd' EOS]
[CVGlobalProcOldCVType: B$ 'OldCVType' EOS] ; for obsolete versinos of CodeView (V 3 and earlier)
[CVGlobalProcOffset: B$ 'Offset' EOS]
[CVGlobalProcSegment: B$ 'Segment' EOS]
[CVGlobalProcProctype: B$ 'Proctype' EOS]
[CVGlobalProcFlags: B$ 'Flags' EOS]
[CVGlobalProcNamelenght: B$ 'NameLenght' EOS]
[CVGlobalProcName: B$ 'Name' EOS]

[CVGlobalProcLabel: B$ 0 # 20]

Proc WriteRawDataDebugSGlobalProc:
    Local @OldCodeView
    Uses ecx

    Mov D@OldCodeView &FALSE

    If W$esi-2 = &S_LPROC32
        Move D$CVGlobalProcLabel {B$ 'LocalProcedure.' EOS}
    Else
        Move D$CVGlobalProcLabel {B$ 'GlobalProcedure.' EOS}
    End_If

    If W$esi-2 = &S_GPROC32_CV3
        Mov D@OldCodeView &TRUE
    End_If

    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcPparent , {B$ ': D$ ' EOS}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcPend , {B$ ': D$ ' EOS}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcPnext , {B$ ': D$ ' EOS}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcLength , {B$ ': D$ ' EOS}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcDebugStart , {B$ ': D$ ' EOS}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcDebugEnd , {B$ ': D$ ' EOS}

    If D@OldCodeView = &TRUE
        Call WriteRawDataDebugSGlobalProcItem CVGlobalProcOldCVType , {B$ ': W$ ' EOS}
    End_If

    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcOffset , {B$ ': D$ ' EOS}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcSegment , {B$ ': W$ ' EOS}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcProctype , {B$ ': W$ ' EOS}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcFlags , {B$ ': B$ ' EOS}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcNamelenght , {B$ ': B$ ' EOS}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcName , {B$ ': B$ ' EOS}

EndP

__________________________________________________________________

Proc WriteRawDataDebugSObjectName:
;    Uses ecx
    Uses ecx, eax, ebx
    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx



    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'ObjName.Signature: D$ ' EOS}
    Pop esi

        lodsd | Call WriteEax
        Mov W$edi CRLF | add edi 2

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'ObjName.NameLenght: B$ ' EOS}
    Pop esi

        xor eax eax
        lodsb | Call WriteEax

        Mov W$edi CRLF | add edi 2

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ ".Index" EOS}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {B$ 'ObjName.Name: B$ ' EOS}
    Pop esi

        ; ecx points to the size of the Name
        movzx ecx B$esi-1
        Mov edx esi | add edx ecx

        .If B$esi = 0
            Mov B$edi '0' | inc edi | inc esi
        .Else

        Mov B$edi "'" | inc edi
L0:     lodsb
            If al = 0
                dec esi | jmp L1>
            End_If
        stosb | On esi < edx, jmp L0<
L1:     Mov B$edi "'" | inc edi

        .End_If

        While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        Mov W$edi CRLF | add edi 2

    Pop ebx

    ; Is the end of this structure ends on the proper place ?

    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If


EndP

__________________________________________________________________

[CVThunkStart1632Pparent: B$ 'Pparent' EOS]
[CVThunkStart1632Pend: B$ 'Pend' EOS]
[CVThunkStart1632Pnext: B$ 'Pnext' EOS]
[CVThunkStart1632Offset: B$ 'Offset' EOS]
[CVThunkStart1632Segment: B$ 'Segment' EOS]
[CVThunkStart1632ThunkLength: B$ 'ThunkLength' EOS]
[CVThunkStart1632Ordinal: B$ 'Ordinal' EOS]
[CVThunkStart1632Namelenght: B$ 'NameLenght' EOS]
[CVThunkStart1632Name: B$ 'Name' EOS]
[CVThunkStart1632VariantAdjustorDelta: B$ 'VariantAdjustor.Delta' EOS]
[CVThunkStart1632VariantAdjustorTargetFunctionNameLen: B$ 'VariantAdjustor.TargetFunctionNameLenght' EOS]
[CVThunkStart1632VariantAdjustorTargetFunctionName: B$ 'VariantAdjustor.TargetFunctionName' EOS]
[CVThunkStart1632VariantVCallVTableDisplacement: B$ 'VariantVCall.VTableDisplacement' EOS]
[CVThunkStart1632VariantPCodeSegment: B$ 'VariantPCode.Segment' EOS]
[CVThunkStart1632VariantPCodeOffset: B$ 'VariantPCode.Offset' EOS]

Proc WriteRawDataDebugSThunkStart1632:
    Local @OrdinalValue
    Uses ecx, eax

    Mov D@OrdinalValue 0

    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Pparent , {B$ ': D$ ' EOS}
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Pend , {B$ ': D$ ' EOS}
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Pnext , {B$ ': D$ ' EOS}
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Offset , {B$ ': D$ ' EOS}
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Segment , {B$ ': W$ ' EOS}
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632ThunkLength , {B$ ': W$ ' EOS}
    movzx eax B$esi
    Mov D@OrdinalValue eax
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Ordinal , {B$ ': B$ ' EOS}
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Namelenght , {B$ ': B$ ' EOS}
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Name , {B$ ': B$ ' EOS}

    ; Below are some members that i have no files to check, but accordying to the documentation, it seems correct.
    .If D@OrdinalValue = &CV4_THUNK32_ADJUSTOR
        Push edi | Push esi | Call 'USER32.MessageBoxA' 0, {B$ "CV4 - S_THUNK32 / Variant. Please, send this file to us to we check if the CV4 structure is correct" EOS}, {B$ "Attention !!!!" EOS}, &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL | Pop esi | Pop edi
        Call WriteRawDataDebugSThunkStart1632VariantItem CVThunkStart1632VariantAdjustorDelta, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSThunkStart1632VariantItem CVThunkStart1632VariantAdjustorTargetFunctionNameLen, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSThunkStart1632VariantItem CVThunkStart1632VariantAdjustorTargetFunctionName, {B$ ': B$ ' EOS}
    .Else_If D@OrdinalValue = &CV4_THUNK32_VCALL
        Push edi | Push esi | Call 'USER32.MessageBoxA' 0, {B$ "CV4 - S_THUNK32 / Variant. Please, send this file to us to we check if the CV4 structure is correct" EOS}, {B$ "Attention !!!!" EOS}, &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL | Pop esi | Pop edi
        Call WriteRawDataDebugSThunkStart1632VariantItem CVThunkStart1632VariantVCallVTableDisplacement, {B$ ': W$ ' EOS}
    .Else_If D@OrdinalValue = &CV4_THUNK32_PCODE
        Push edi | Push esi | Call 'USER32.MessageBoxA' 0, {B$ "CV4 - S_THUNK32 / Variant. Please, send this file to us to we check if the CV4 structure is correct" EOS}, {B$ "Attention !!!!" EOS}, &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL | Pop esi | Pop edi
        Call WriteRawDataDebugSThunkStart1632VariantItem CVThunkStart1632VariantPCodeSegment, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSThunkStart1632VariantItem CVThunkStart1632VariantPCodeOffset, {B$ ': D$ ' EOS}
    .End_If

EndP
__________________________________________________________________

Proc WriteRawDataDebugSThunkStart1632Item:
    Argument @Text1, @Text2
    uses eax, ecx

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'ThunkStart1632.' EOS}
            zCopy D@Text1
            zCopy D@Text2
        Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Ppar' ; from "Pparent" string
            lodsd | Call WriteEax

        ..Else_If D$eax = 'Pend'; From "Pend" string
            lodsd | Call WriteEax

        ..Else_If D$eax = 'Pnex'; From "Pnext" string
            lodsd | Call WriteEax

        ..Else_If D$eax = 'Offs'; From "Offset" string
            lodsd | Call WriteEax

        ..Else_If D$eax = 'Segm'; From "Segment" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Thun'; From "ThunkLength" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Ordi'; From "Ordinal" string
            Call WriteCVThunkStart1632OrdinalEquates
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

__________________________________________________________________

Proc WriteRawDataDebugSThunkStart1632VariantItem:
    Argument @Text1, @Text2
    uses eax, ecx

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'ThunkStart1632.' EOS}
            zCopy D@Text1
            zCopy D@Text2
        Pop esi

        Mov eax D@Text1


        ..If D$eax+16 = 'Delt' ; from "VariantAdjustor.Delta" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+34 = 'Leng'; From "VariantAdjustor.TargetFunctionNameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax+30 = 'Name'; From "VariantAdjustor.TargetFunctionName" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..Else_If D$eax+13 = 'VTab'; From "VariantVCall.VTableDisplacement" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+13 = 'Segm'; From "VariantPCode.Segment" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+13 = 'Offs'; From "VariantPCode.Offset" string
            lodsd | Call WriteEax

         ..End_If

        Mov W$edi CRLF | add edi 2

EndP

__________________________________________________________________

Proc WriteCVThunkStart1632OrdinalEquates:
    Uses esi;, ebx, eax

    .If B$esi = &CV4_THUNK32_NOTYPE
        zCopy {B$ '&CV4_THUNK32_NOTYPE' EOS}
    .Else_If B$esi = &CV4_THUNK32_ADJUSTOR
        zCopy {B$ '&CV4_THUNK32_ADJUSTOR' EOS}
    .Else_If B$esi = &CV4_THUNK32_VCALL
        zCopy {B$ '&CV4_THUNK32_VCALL' EOS}
    .Else_If B$esi = &CV4_THUNK32_PCODE
        zCopy {B$ '&CV4_THUNK32_PCODE' EOS}

    .End_If

        zCopy {B$ ' ; Hex Value:  ' EOS}

EndP
__________________________________________________________________
;;

;;
These are the primitives Types Listings. All values not used below are unknown or not specified.

Equates used:

Special Types

T_NOTYPE 0x0000 Uncharacterized type (no type)
T_ABS 0x0001 Absolute symbol
T_SEGMENT 0x0002 Segment type
T_VOID 0x0003 Void
T_PVOID 0x0103 Near pointer to void
T_PFVOID 0x0203 Far pointer to void
T_PHVOID 0x0303 Huge pointer to void
T_32PVOID 0x0403 32-bit near pointer to void
T_32PFVOID 0x0503 32-bit far pointer to void
T_CURRENCY 0x0004 Basic 8-byte currency value
T_NBASICSTR 0x0005 Near Basic string
T_FBASICSTR 0x0006 Far Basic string
T_NOTTRANS 0x0007 Untranslated type record from Microsoft symbol format
T_BIT 0x0060 Bit
T_PASCHAR 0x0061 Pascal CHAR

Character Types

T_CHAR 0x0010 8-bit signed
T_UCHAR 0x0020 8-bit unsigned
T_PCHAR 0x0110 Near pointer to 8-bit signed
T_PUCHAR 0x0120 Near pointer to 8-bit unsigned
T_PFCHAR 0x0210 Far pointer to 8-bit signed
T_PFUCHAR 0x0220 Far pointer to 8-bit unsigned
T_PHCHAR 0x0310 Huge pointer to 8-bit signed
T_PHUCHAR 0x0320 Huge pointer to 8-bit unsigned
T_32PCHAR 0x0410 16:32 near pointer to 8-bit signed
T_32PUCHAR 0x0420 16:32 near pointer to 8-bit unsigned
T_32PFCHAR 0x0510 16:32 far pointer to 8-bit signed
T_32PFUCHAR 0x0520 16:32 far pointer to 8-bit unsigned

Real Character Types

T_RCHAR 0x0070 Real char
T_PRCHAR 0x0170 Near pointer to a real char
T_PFRCHAR 0x0270 Far pointer to a real char
T_PHRCHAR 0x0370 Huge pointer to a real char
T_32PRCHAR 0x0470 16:32 near pointer to a real char
T_32PFRCHAR 0x0570 16:32 far pointer to a real char

Wide Character Types

T_WCHAR 0x0071 Wide char
T_PWCHAR 0x0171 Near pointer to a wide char
T_PFWCHAR 0x0271 Far pointer to a wide char
T_PHWCHAR 0x0371 Huge pointer to a wide char
T_32PWCHAR 0x0471 16:32 near pointer to a wide char
T_32PFWCHAR 0x0571 16:32 far pointer to a wide char

Real 16-bit Integer Types

T_INT2 0x0072 Real 16-bit signed int
T_UINT2 0x0073 Real 16-bit unsigned int
T_PINT2 0x0172 Near pointer to 16-bit signed int
T_PUINT2 0x0173 Near pointer to 16-bit unsigned int
T_PFINT2 0x0272 Far pointer to 16-bit signed int
T_PFUINT2 0x0273 Far pointer to 16-bit unsigned int
T_PHINT2 0x0372 Huge pointer to 16-bit signed int
T_PHUINT2 0x0373 Huge pointer to 16-bit unsigned int
T_32PINT2 0x0472 16:32 near pointer to 16-bit signed int
T_32PUINT2 0x0473 16:32 near pointer to 16-bit unsigned int
T_32PFINT2 0x0572 16:32 far pointer to 16-bit signed int
T_32PFUINT2 0x0573 16:32 far pointer to 16-bit unsigned int

16-bit Short Types

T_SHORT 0x0011 16-bit signed
T_USHORT 0x0021 16-bit unsigned
T_PSHORT 0x0111 Near pointer to 16-bit signed
T_PUSHORT 0x0121 Near pointer to 16-bit unsigned
T_PFSHORT 0x0211 Far pointer to 16-bit signed
T_PFUSHORT 0x0221 Far pointer to 16-bit unsigned
T_PHSHORT 0x0311 Huge pointer to 16-bit signed
T_PHUSHORT 0x0321 Huge pointer to 16-bit unsigned
T_32PSHORT 0x0411 16:32 near pointer to 16-bit signed
T_32PUSHORT 0x0421 16:32 near pointer to 16-bit unsigned
T_32PFSHORT 0x0511 16:32 far pointer to 16-bit signed
T_32PFUSHORT 0x0521 16:32 far pointer to 16-bit unsigned

Real 32-bit Integer Types

T_INT4 0x0074 Real 32-bit signed int
T_UINT4 0x0075 Real 32-bit unsigned int
T_PINT4 0x0174 Near pointer to 32-bit signed int
T_PUINT4 0x0175 Near pointer to 32-bit unsigned int
T_PFINT4 0x0274 Far pointer to 32-bit signed int
T_PFUINT4 0x0275 Far pointer to 32-bit unsigned int
T_PHINT4 0x0374 Huge pointer to 32-bit signed int
T_PHUINT4 0x0375 Huge pointer to 32-bit unsigned int
T_32PINT4 0x0474 16:32 near pointer to 32-bit signed int
T_32PUINT4 0x0475 16:32 near pointer to 32-bit unsigned int
T_32PFINT4 0x0574 16:32 far pointer to 32-bit signed int
T_32PFUINT4 0x0575 16:32 far pointer to 32-bit unsigned int

32-bit Long Types

T_LONG 0x0012 32-bit signed
T_ULONG 0x0022 32-bit unsigned
T_PLONG 0x0112 Near pointer to 32-bit signed
T_PULONG 0x0122 Near pointer to 32-bit unsigned
T_PFLONG 0x0212 Far pointer to 32-bit signed
T_PFULONG 0x0222 Far pointer to 32-bit unsigned
T_PHLONG 0x0312 Huge pointer to 32-bit signed
T_PHULONG 0x0322 Huge pointer to 32-bit unsigned
T_32PLONG 0x0412 16:32 near pointer to 32-bit signed
T_32PULONG 0x0422 16:32 near pointer to 32-bit unsigned
T_32PFLONG 0x0512 16:32 far pointer to 32-bit signed
T_32PFULONG 0x0522 16:32 far pointer to 32-bit unsigned

Real 64-bit int Types

T_INT8 0x0076 64-bit signed int
T_UINT8 0x0077 64-bit unsigned int
T_PINT8 0x0176 Near pointer to 64-bit signed int
T_PUINT8 0x0177 Near pointer to 64-bit unsigned int
T_PFINT8 0x0276 Far pointer to 64-bit signed int
T_PFUINT8 0x0277 Far pointer to 64-bit unsigned int
T_PHINT8 0x0376 Huge pointer to 64-bit signed int
T_PHUINT8 0x0377 Huge pointer to 64-bit unsigned int
T_32PINT8 0x0476 16:32 near pointer to 64-bit signed int
T_32PUINT8 0x0477 16:32 near pointer to 64-bit unsigned int
T_32PFINT8 0x0576 16:32 far pointer to 64-bit signed int
T_32PFUINT8 0x0577 16:32 far pointer to 64-bit unsigned int

64-bit Integral Types

T_QUAD 0x0013 64-bit signed
T_UQUAD 0x0023 64-bit unsigned
T_PQUAD 0x0113 Near pointer to 64-bit signed
T_PUQUAD 0x0123 Near pointer to 64-bit unsigned
T_PFQUAD 0x0213 Far pointer to 64-bit signed
T_PFUQUAD 0x0223 Far pointer to 64-bit unsigned
T_PHQUAD 0x0313 Huge pointer to 64-bit signed
T_PHUQUAD 0x0323 Huge pointer to 64-bit unsigned
T_32PQUAD 0x0413 16:32 near pointer to 64-bit signed
T_32PUQUAD 0x0423 16:32 near pointer to 64-bit unsigned
T_32PFQUAD 0x0513 16:32 far pointer to 64-bit signed
T_32PFUQUAD 0x0523 16:32 far pointer to 64-bit unsigned

32-bit Real Types

T_REAL32 0x0040 32-bit real
T_PREAL32 0x0140 Near pointer to 32-bit real
T_PFREAL32 0x0240 Far pointer to 32-bit real
T_PHREAL32 0x0340 Huge pointer to 32-bit real
T_32PREAL32 0x0440 16:32 near pointer to 32-bit real
T_32PFREAL32 0x0540 16:32 far pointer to 32-bit real

48-bit Real Types

T_REAL48 0x0044 48-bit real
T_PREAL48 0x0144 Near pointer to 48-bit real
T_PFREAL48 0x0244 Far pointer to 48-bit real
T_PHREAL48 0x0344 Huge pointer to 48-bit real
T_32PREAL48 0x0444 16:32 near pointer to 48-bit real
T_32PFREAL48 0x0544 16:32 far pointer to 48-bit real

64-bit Real Types

T_REAL64 0x0041 64-bit real
T_PREAL64 0x0141 Near pointer to 64-bit real
T_PFREAL64 0x0241 Far pointer to 64-bit real
T_PHREAL64 0x0341 Huge pointer to 64-bit real
T_32PREAL64 0x0441 16:32 near pointer to 64-bit real
T_32PFREAL64 0x0541 16:32 far pointer to 64-bit real

80-bit Real Types

T_REAL80 0x0042 80-bit real
T_PREAL80 0x0142 Near pointer to 80-bit real
T_PFREAL80 0x0242 Far pointer to 80-bit real
T_PHREAL80 0x0342 Huge pointer to 80-bit real
T_32PREAL80 0x0442 16:32 near pointer to 80-bit real
T_32PFREAL80 0x0542 16:32 far pointer to 80-bit real

128-bit Real Types
T_REAL128 0x0043 128-bit real
T_PREAL128 0x0143 Near pointer to 128-bit real
T_PFREAL128 0x0243 Far pointer to 128-bit real
T_PHREAL128 0x0343 Huge pointer to 128-bit real
T_32PREAL128 0x0443 16:32 near pointer to 128-bit real
T_32PFREAL128 0x0543 16:32 far pointer to 128-bit real

32-bit Complex Types

T_CPLX32 0x0050 32-bit complex
T_PCPLX32 0x0150 Near pointer to 32-bit complex
T_PFCPLX32 0x0250 Far pointer to 32-bit complex
T_PHCPLX32 0x0350 Huge pointer to 32-bit complex
T_32PCPLX32 0x0450 16:32 near pointer to 32-bit complex
T_32PFCPLX32 0x0550 16:32 far pointer to 32-bit complex

64-bit Complex Types

T_CPLX64 0x0051 64-bit complex
T_PCPLX64 0x0151 Near pointer to 64-bit complex
T_PFCPLX64 0x0251 Far pointer to 64-bit complex
T_PHCPLX64 0x0351 Huge pointer to 64-bit complex
T_32PCPLX64 0x0451 16:32 near pointer to 64-bit complex
T_32PFCPLX64 0x0551 16:32 far pointer to 64-bit complex

80-bit Complex Types

T_CPLX80 0x0052 80-bit complex
T_PCPLX80 0x0152 Near pointer to 80-bit complex
T_PFCPLX80 0x0252 Far pointer to 80-bit complex
T_PHCPLX80 0x0352 Huge pointer to 80-bit complex
T_32PCPLX80 0x0452 16:32 near pointer to 80-bit complex
T_32PFCPLX80 0x0552 16:32 far pointer to 80-bit complex

128-bit Complex Types

T_CPLX128 0x0053 128-bit complex
T_PCPLX128 0x0153 Near pointer to 128-bit complex
T_PFCPLX128 0x0253 Far pointer to 128-bit complex
T_PHCPLX128 0x0353 Huge pointer to 128-bit real
T_32PCPLX128 0x0453 16:32 near pointer to 128-bit complex
T_32PFCPLX128 0x0553 16:32 far pointer to 128-bit complex

Boolean Types

T_BOOL08 0x0030 8-bit Boolean
T_BOOL16 0x0031 16-bit Boolean
T_BOOL32 0x0032 32-bit Boolean
T_BOOL64 0x0033 64-bit Boolean
T_PBOOL08 0x0130 Near pointer to 8-bit Boolean
T_PBOOL16 0x0131 Near pointer to 16-bit Boolean
T_PBOOL32 0x0132 Near pointer to 32-bit Boolean
T_PBOOL64 0x0133 Near pointer to 64-bit Boolean
T_PFBOOL08 0x0230 Far pointer to 8-bit Boolean
T_PFBOOL16 0x0231 Far pointer to 16-bit Boolean
T_PFBOOL32 0x0232 Far pointer to 32-bit Boolean
T_PFBOOL32 0x0233 Far pointer to 64-bit Boolean
T_PHBOOL08 0x0330 Huge pointer to 8-bit Boolean
T_PHBOOL16 0x0331 Huge pointer to 16-bit Boolean
T_PHBOOL32 0x0332 Huge pointer to 32-bit Boolean
T_PHBOOL64 0x0333 Huge pointer to 64-bit Boolean
T_32PBOOL08 0x0430 16:32 near pointer to 8-bit Boolean
T_32PBOOL16 0x0431 16:32 near pointer to 16-bit Boolean
T_32PBOOL32 0x0432 16:32 near pointer to 32-bit Boolean
T_32PBOOL64 0x0433 16:32 near pointer to 64-bit Boolean
T_32PFBOOL08 0x0530 16:32 far pointer to 8-bit Boolean
T_32PFBOOL16 0x0531 16:32 far pointer to 16-bit Boolean
T_32PFBOOL32 0x0532 16:32 far pointer to 32-bit Boolean
T_32PFBOOL64 0x0533 16:32 far pointer to 64-bit Boolean
;;
;;
Proc WriteCVBPRel32TypeEquates:
    Uses esi

    ..If W$esi = &T_NOTYPE
        zCopy {B$ '&T_NOTYPE ; Uncharacterized type (no type) - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_ABS
        zCopy {B$ '&T_ABS ; Absolute symbol - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_SEGMENT
        zCopy {B$ '&T_SEGMENT ; Segment type - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_VOID
        zCopy {B$ '&T_VOID ; Void - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PVOID
        zCopy {B$ '&T_PVOID ; Near pointer to void - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFVOID
        zCopy {B$ '&T_PFVOID ; Far pointer to void - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHVOID
        zCopy {B$ '&T_PHVOID ; Huge pointer to void - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PVOID
        zCopy {B$ '&T_32PVOID ; 32-bit near pointer to void - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFVOID
        zCopy {B$ '&T_32PFVOID ; 32-bit far pointer to void - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_CURRENCY
        zCopy {B$ '&T_CURRENCY ; Basic 8-byte currency value - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_NBASICSTR
        zCopy {B$ '&T_NBASICSTR ; Near Basic string - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_FBASICSTR
        zCopy {B$ '&T_FBASICSTR ; Far Basic string - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_NOTTRANS
        zCopy {B$ '&T_NOTTRANS ; Untranslated type record from Microsoft symbol format - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_BIT
        zCopy {B$ '&T_BIT ; Bit - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PASCHAR
        zCopy {B$ '&T_PASCHAR ; Pascal CHAR - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_CHAR
        zCopy {B$ '&T_CHAR ; 8-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_UCHAR
        zCopy {B$ '&T_UCHAR ; 8-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PCHAR
        zCopy {B$ '&T_PCHAR ; Near pointer to 8-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PUCHAR
        zCopy {B$ '&T_PUCHAR ; Near pointer to 8-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFCHAR
        zCopy {B$ '&T_PFCHAR ; Far pointer to 8-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFUCHAR
        zCopy {B$ '&T_PFUCHAR ; Far pointer to 8-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHCHAR
        zCopy {B$ '&T_PHCHAR ; Huge pointer to 8-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHUCHAR
        zCopy {B$ '&T_PHUCHAR ; Huge pointer to 8-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PCHAR
        zCopy {B$ '&T_32PCHAR ; 16:32 near pointer to 8-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PUCHAR
        zCopy {B$ '&T_32PUCHAR ; 16:32 near pointer to 8-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFCHAR
        zCopy {B$ '&T_32PFCHAR ; 16:32 far pointer to 8-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFUCHAR
        zCopy {B$ '&T_32PFUCHAR ; 16:32 far pointer to 8-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_RCHAR
        zCopy {B$ '&T_RCHAR ; Real char - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PRCHAR
        zCopy {B$ '&T_PRCHAR ; Near pointer to a real char - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFRCHAR
        zCopy {B$ '&T_PFRCHAR ; Far pointer to a real char - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHRCHAR
        zCopy {B$ '&T_PHRCHAR ; Huge pointer to a real char - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PRCHAR
        zCopy {B$ '&T_32PRCHAR ; 16:32 near pointer to a real char - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFRCHAR
        zCopy {B$ '&T_32PFRCHAR ; 16:32 far pointer to a real char - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_WCHAR
        zCopy {B$ '&T_WCHAR ; Wide char - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PWCHAR
        zCopy {B$ '&T_PWCHAR ; Near pointer to a wide char - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFWCHAR
        zCopy {B$ '&T_PFWCHAR ; Far pointer to a wide char - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHWCHAR
        zCopy {B$ '&T_PHWCHAR ; Huge pointer to a wide char - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PWCHAR
        zCopy {B$ '&T_32PWCHAR ; 16:32 near pointer to a wide char - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFWCHAR
        zCopy {B$ '&T_32PFWCHAR ; 16:32 far pointer to a wide char - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_INT2
        zCopy {B$ '&T_INT2 ; Real 16-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_UINT2
        zCopy {B$ '&T_UINT2 ; Real 16-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PINT2
        zCopy {B$ '&T_PINT2 ; Near pointer to 16-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PUINT2
        zCopy {B$ '&T_PUINT2 ; Near pointer to 16-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFINT2
        zCopy {B$ '&T_PFINT2 ; Far pointer to 16-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFUINT2
        zCopy {B$ '&T_PFUINT2 ; Far pointer to 16-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHINT2
        zCopy {B$ '&T_PHINT2 ; Huge pointer to 16-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHUINT2
        zCopy {B$ '&T_PHUINT2 ; Huge pointer to 16-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PINT2
        zCopy {B$ '&T_32PINT2 ; 16:32 near pointer to 16-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PUINT2
        zCopy {B$ '&T_32PUINT2 ; 16:32 near pointer to 16-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFINT2
        zCopy {B$ '&T_32PFINT2 ; 16:32 far pointer to 16-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFUINT2
        zCopy {B$ '&T_32PFUINT2 ; 16:32 far pointer to 16-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_SHORT
        zCopy {B$ '&T_SHORT ; 16-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_USHORT
        zCopy {B$ '&T_USHORT ; 16-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PSHORT
        zCopy {B$ '&T_PSHORT ; Near pointer to 16-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PUSHORT
        zCopy {B$ '&T_PUSHORT ; Near pointer to 16-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFSHORT
        zCopy {B$ '&T_PFSHORT ; Far pointer to 16-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFUSHORT
        zCopy {B$ '&T_PFUSHORT ; Far pointer to 16-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHSHORT
        zCopy {B$ '&T_PHSHORT ; Huge pointer to 16-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHUSHORT
        zCopy {B$ '&T_PHUSHORT ; Huge pointer to 16-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PSHORT
        zCopy {B$ '&T_32PSHORT ; 16:32 near pointer to 16-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PUSHORT
        zCopy {B$ '&T_32PUSHORT ; 16:32 near pointer to 16-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFSHORT
        zCopy {B$ '&T_32PFSHORT ; 16:32 far pointer to 16-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFUSHORT
        zCopy {B$ '&T_32PFUSHORT ; 16:32 far pointer to 16-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_INT4
        zCopy {B$ '&T_INT4 ; Real 32-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_UINT4
        zCopy {B$ '&T_UINT4 ; Real 32-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PINT4
        zCopy {B$ '&T_PINT4 ; Near pointer to 32-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PUINT4
        zCopy {B$ '&T_PUINT4 ; Near pointer to 32-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFINT4
        zCopy {B$ '&T_PFINT4 ; Far pointer to 32-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFUINT4
        zCopy {B$ '&T_PFUINT4 ; Far pointer to 32-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHINT4
        zCopy {B$ '&T_PHINT4 ; Huge pointer to 32-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHUINT4
        zCopy {B$ '&T_PHUINT4 ; Huge pointer to 32-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PINT4
        zCopy {B$ '&T_32PINT4 ; 16:32 near pointer to 32-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PUINT4
        zCopy {B$ '&T_32PUINT4 ; 16:32 near pointer to 32-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFINT4
        zCopy {B$ '&T_32PFINT4 ; 16:32 far pointer to 32-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFUINT4
        zCopy {B$ '&T_32PFUINT4 ; 16:32 far pointer to 32-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_LONG
        zCopy {B$ '&T_LONG ; 32-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_ULONG
        zCopy {B$ '&T_ULONG ; 32-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PLONG
        zCopy {B$ '&T_PLONG ; Near pointer to 32-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PULONG
        zCopy {B$ '&T_PULONG ; Near pointer to 32-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFLONG
        zCopy {B$ '&T_PFLONG ; Far pointer to 32-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFULONG
        zCopy {B$ '&T_PFULONG ; Far pointer to 32-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHLONG
        zCopy {B$ '&T_PHLONG ; Huge pointer to 32-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHULONG
        zCopy {B$ '&T_PHULONG ; Huge pointer to 32-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PLONG
        zCopy {B$ '&T_32PLONG ; 16:32 near pointer to 32-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PULONG
        zCopy {B$ '&T_32PULONG ; 16:32 near pointer to 32-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFLONG
        zCopy {B$ '&T_32PFLONG ; 16:32 far pointer to 32-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFULONG
        zCopy {B$ '&T_32PFULONG ; 16:32 far pointer to 32-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_INT8
        zCopy {B$ '&T_INT8 ; 64-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_UINT8
        zCopy {B$ '&T_UINT8 ; 64-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PINT8
        zCopy {B$ '&T_PINT8 ; Near pointer to 64-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PUINT8
        zCopy {B$ '&T_PUINT8 ; Near pointer to 64-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFINT8
        zCopy {B$ '&T_PFINT8 ; Far pointer to 64-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFUINT8
        zCopy {B$ '&T_PFUINT8 ; Far pointer to 64-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHINT8
        zCopy {B$ '&T_PHINT8 ; Huge pointer to 64-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHUINT8
        zCopy {B$ '&T_PHUINT8 ; Huge pointer to 64-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PINT8
        zCopy {B$ '&T_32PINT8 ; 16:32 near pointer to 64-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PUINT8
        zCopy {B$ '&T_32PUINT8 ; 16:32 near pointer to 64-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFINT8
        zCopy {B$ '&T_32PFINT8 ; 16:32 far pointer to 64-bit signed int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFUINT8
        zCopy {B$ '&T_32PFUINT8 ; 16:32 far pointer to 64-bit unsigned int - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_QUAD
        zCopy {B$ '&T_QUAD ; 64-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_UQUAD
        zCopy {B$ '&T_UQUAD ; 64-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PQUAD
        zCopy {B$ '&T_PQUAD ; Near pointer to 64-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PUQUAD
        zCopy {B$ '&T_PUQUAD ; Near pointer to 64-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFQUAD
        zCopy {B$ '&T_PFQUAD ; Far pointer to 64-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFUQUAD
        zCopy {B$ '&T_PFUQUAD ; Far pointer to 64-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHQUAD
        zCopy {B$ '&T_PHQUAD ; Huge pointer to 64-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHUQUAD
        zCopy {B$ '&T_PHUQUAD ; Huge pointer to 64-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PQUAD
        zCopy {B$ '&T_32PQUAD ; 16:32 near pointer to 64-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PUQUAD
        zCopy {B$ '&T_32PUQUAD ; 16:32 near pointer to 64-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFQUAD
        zCopy {B$ '&T_32PFQUAD ; 16:32 far pointer to 64-bit signed - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFUQUAD
        zCopy {B$ '&T_32PFUQUAD ; 16:32 far pointer to 64-bit unsigned - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_REAL32
        zCopy {B$ '&T_REAL32 ; 32-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PREAL32
        zCopy {B$ '&T_PREAL32 ; Near pointer to 32-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFREAL32
        zCopy {B$ '&T_PFREAL32 ; Far pointer to 32-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHREAL32
        zCopy {B$ '&T_PHREAL32 ; Huge pointer to 32-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PREAL32
        zCopy {B$ '&T_32PREAL32 ; 16:32 near pointer to 32-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFREAL32
        zCopy {B$ '&T_32PFREAL32 ; 16:32 far pointer to 32-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_REAL48
        zCopy {B$ '&T_REAL48 ; 48-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PREAL48
        zCopy {B$ '&T_PREAL48 ; Near pointer to 48-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFREAL48
        zCopy {B$ '&T_PFREAL48 ; Far pointer to 48-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHREAL48
        zCopy {B$ '&T_PHREAL48 ; Huge pointer to 48-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PREAL48
        zCopy {B$ '&T_32PREAL48 ; 16:32 near pointer to 48-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFREAL48
        zCopy {B$ '&T_32PFREAL48 ; 16:32 far pointer to 48-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_REAL64
        zCopy {B$ '&T_REAL64 ; 64-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PREAL64
        zCopy {B$ '&T_PREAL64 ; Near pointer to 64-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFREAL64
        zCopy {B$ '&T_PFREAL64 ; Far pointer to 64-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHREAL64
        zCopy {B$ '&T_PHREAL64 ; Huge pointer to 64-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PREAL64
        zCopy {B$ '&T_32PREAL64 ; 16:32 near pointer to 64-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFREAL64
        zCopy {B$ '&T_32PFREAL64 ; 16:32 far pointer to 64-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_REAL80
        zCopy {B$ '&T_REAL80 ; 80-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PREAL80
        zCopy {B$ '&T_PREAL80 ; Near pointer to 80-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFREAL80
        zCopy {B$ '&T_PFREAL80 ; Far pointer to 80-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHREAL80
        zCopy {B$ '&T_PHREAL80 ; Huge pointer to 80-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PREAL80
        zCopy {B$ '&T_32PREAL80 ; 16:32 near pointer to 80-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFREAL80
        zCopy {B$ '&T_32PFREAL80 ; 16:32 far pointer to 80-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_REAL128
        zCopy {B$ '&T_REAL128 ; 128-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PREAL128
        zCopy {B$ '&T_PREAL128 ; Near pointer to 128-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFREAL128
        zCopy {B$ '&T_PFREAL128 ; Far pointer to 128-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHREAL128
        zCopy {B$ '&T_PHREAL128 ; Huge pointer to 128-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PREAL128
        zCopy {B$ '&T_32PREAL128 ; 16:32 near pointer to 128-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFREAL128
        zCopy {B$ '&T_32PFREAL128 ; 16:32 far pointer to 128-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_CPLX32
        zCopy {B$ '&T_CPLX32 ; 32-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PCPLX32
        zCopy {B$ '&T_PCPLX32 ; Near pointer to 32-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFCPLX32
        zCopy {B$ '&T_PFCPLX32 ; Far pointer to 32-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHCPLX32
        zCopy {B$ '&T_PHCPLX32 ; Huge pointer to 32-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PCPLX32
        zCopy {B$ '&T_32PCPLX32 ; 16:32 near pointer to 32-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFCPLX32
        zCopy {B$ '&T_32PFCPLX32 ; 16:32 far pointer to 32-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_CPLX64
        zCopy {B$ '&T_CPLX64 ; 64-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PCPLX64
        zCopy {B$ '&T_PCPLX64 ; Near pointer to 64-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFCPLX64
        zCopy {B$ '&T_PFCPLX64 ; Far pointer to 64-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHCPLX64
        zCopy {B$ '&T_PHCPLX64 ; Huge pointer to 64-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PCPLX64
        zCopy {B$ '&T_32PCPLX64 ; 16:32 near pointer to 64-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFCPLX64
        zCopy {B$ '&T_32PFCPLX64 ; 16:32 far pointer to 64-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_CPLX80
        zCopy {B$ '&T_CPLX80 ; 80-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PCPLX80
        zCopy {B$ '&T_PCPLX80 ; Near pointer to 80-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFCPLX80
        zCopy {B$ '&T_PFCPLX80 ; Far pointer to 80-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHCPLX80
        zCopy {B$ '&T_PHCPLX80 ; Huge pointer to 80-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PCPLX80
        zCopy {B$ '&T_32PCPLX80 ; 16:32 near pointer to 80-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFCPLX80
        zCopy {B$ '&T_32PFCPLX80 ; 16:32 far pointer to 80-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_CPLX128
        zCopy {B$ '&T_CPLX128 ; 128-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PCPLX128
        zCopy {B$ '&T_PCPLX128 ; Near pointer to 128-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFCPLX128
        zCopy {B$ '&T_PFCPLX128 ; Far pointer to 128-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHCPLX128
        zCopy {B$ '&T_PHCPLX128 ; Huge pointer to 128-bit real - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PCPLX128
        zCopy {B$ '&T_32PCPLX128 ; 16:32 near pointer to 128-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFCPLX128
        zCopy {B$ '&T_32PFCPLX128 ; 16:32 far pointer to 128-bit complex - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_BOOL08
        zCopy {B$ '&T_BOOL08 ; 8-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_BOOL16
        zCopy {B$ '&T_BOOL16 ; 16-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_BOOL32
        zCopy {B$ '&T_BOOL32 ; 32-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_BOOL64
        zCopy {B$ '&T_BOOL64 ; 64-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PBOOL08
        zCopy {B$ '&T_PBOOL08 ; Near pointer to 8-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PBOOL16
        zCopy {B$ '&T_PBOOL16 ; Near pointer to 16-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PBOOL32
        zCopy {B$ '&T_PBOOL32 ; Near pointer to 32-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PBOOL64
        zCopy {B$ '&T_PBOOL64 ; Near pointer to 64-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFBOOL08
        zCopy {B$ '&T_PFBOOL08 ; Far pointer to 8-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFBOOL16
        zCopy {B$ '&T_PFBOOL16 ; Far pointer to 16-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFBOOL32
        zCopy {B$ '&T_PFBOOL32 ; Far pointer to 32-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PFBOOL32
        zCopy {B$ '&T_PFBOOL32 ; Far pointer to 64-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHBOOL08
        zCopy {B$ '&T_PHBOOL08 ; Huge pointer to 8-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHBOOL16
        zCopy {B$ '&T_PHBOOL16 ; Huge pointer to 16-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHBOOL32
        zCopy {B$ '&T_PHBOOL32 ; Huge pointer to 32-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_PHBOOL64
        zCopy {B$ '&T_PHBOOL64 ; Huge pointer to 64-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PBOOL08
        zCopy {B$ '&T_32PBOOL08 ; 16:32 near pointer to 8-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PBOOL16
        zCopy {B$ '&T_32PBOOL16 ; 16:32 near pointer to 16-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PBOOL32
        zCopy {B$ '&T_32PBOOL32 ; 16:32 near pointer to 32-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PBOOL64
        zCopy {B$ '&T_32PBOOL64 ; 16:32 near pointer to 64-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFBOOL08
        zCopy {B$ '&T_32PFBOOL08 ; 16:32 far pointer to 8-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFBOOL16
        zCopy {B$ '&T_32PFBOOL16 ; 16:32 far pointer to 16-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFBOOL32
        zCopy {B$ '&T_32PFBOOL32 ; 16:32 far pointer to 32-bit Boolean - Hex Value:  ' EOS}
    ..Else_If W$esi = &T_32PFBOOL64
        zCopy {B$ '&T_32PFBOOL64 ; 16:32 far pointer to 64-bit Boolean - Hex Value:  ' EOS}
    ..End_If

EndP
_____________________________________
; Non Primitive Types, can be interpreted as the leaf types, for values bigger then 01000
Proc WriteCVNonPrimitiveTypeEquates:
    Uses esi

        ; For values bigger or equal to 01000, it is probably that they are related to leaf type indices, because
        ; they are related to Non-Primitive types

        .If W$esi = &LF_ENUMERATE_CV2
            zCopy {B$ '&LF_ENUMERATE_CV2; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_ARRAY_CV2
            zCopy {B$ '&LF_ARRAY_CV2; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_CLASS_CV2
            zCopy {B$ '&LF_CLASS_CV2; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_STRUCTURE_CV2
            zCopy {B$ '&LF_STRUCTURE_CV2; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_UNION_CV2
            zCopy {B$ '&LF_UNION_CV2; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_ENUM_CV2
            zCopy {B$ '&LF_ENUM_CV2; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_MEMBER_CV2
            zCopy {B$ '&LF_MEMBER_CV2; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_MODIFIER_CV3
            zCopy {B$ '&LF_MODIFIER_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_POINTER_CV3
            zCopy {B$ '&LF_POINTER_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_ARRAY_CV3
            zCopy {B$ '&LF_ARRAY_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_CLASS_CV3
            zCopy {B$ '&LF_CLASS_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_STRUCTURE_CV3
            zCopy {B$ '&LF_STRUCTURE_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_UNION_CV3
            zCopy {B$ '&LF_UNION_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_ENUM_CV3
            zCopy {B$ '&LF_ENUM_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_PROCEDURE_CV3
            zCopy {B$ '&LF_PROCEDURE_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_MFUNCTION_CV3
            zCopy {B$ '&LF_MFUNCTION_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_COBOL0_CV3
            zCopy {B$ '&LF_COBOL0_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_BARRAY_CV3
            zCopy {B$ '&LF_BARRAY_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_DIMARRAY_CV3
            zCopy {B$ '&LF_DIMARRAY_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_VFTPATH_CV3
            zCopy {B$ '&LF_VFTPATH_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_PRECOMP_CV3
            zCopy {B$ '&LF_PRECOMP_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_OEM_CV3
            zCopy {B$ '&LF_OEM_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_SKIP_CV3
            zCopy {B$ '&LF_SKIP_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_ARGLIST_CV3
            zCopy {B$ '&LF_ARGLIST_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_DEFARG_CV3
            zCopy {B$ '&LF_DEFARG_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_FIELDLIST_CV3
            zCopy {B$ '&LF_FIELDLIST_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_DERIVED_CV3
            zCopy {B$ '&LF_DERIVED_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_BITFIELD_CV3
            zCopy {B$ '&LF_BITFIELD_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_METHODLIST_CV3
            zCopy {B$ '&LF_METHODLIST_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_DIMCONU_CV3
            zCopy {B$ '&LF_DIMCONU_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_DIMCONLU_CV3
            zCopy {B$ '&LF_DIMCONLU_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_DIMVARU_CV3
            zCopy {B$ '&LF_DIMVARU_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_DIMVARLU_CV3
            zCopy {B$ '&LF_DIMVARLU_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_BCLASS_CV3
            zCopy {B$ '&LF_BCLASS_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_VBCLASS_CV3
            zCopy {B$ '&LF_VBCLASS_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_IVBCLASS_CV3
            zCopy {B$ '&LF_IVBCLASS_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_FRIENDFCN_CV3
            zCopy {B$ '&LF_FRIENDFCN_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_INDEX_CV3
            zCopy {B$ '&LF_INDEX_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_MEMBER_CV3
            zCopy {B$ '&LF_MEMBER_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_STMEMBER_CV3
            zCopy {B$ '&LF_STMEMBER_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_METHOD_CV3
            zCopy {B$ '&LF_METHOD_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_NESTTYPE_CV3
            zCopy {B$ '&LF_NESTTYPE_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_VFUNCTAB_CV3
            zCopy {B$ '&LF_VFUNCTAB_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_FRIENDCLS_CV3
            zCopy {B$ '&LF_FRIENDCLS_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_ONEMETHOD_CV3
            zCopy {B$ '&LF_ONEMETHOD_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_VFUNCOFF_CV3
            zCopy {B$ '&LF_VFUNCOFF_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_NESTTYPEEX_CV3
            zCopy {B$ '&LF_NESTTYPEEX_CV3; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_CHAR
            zCopy {B$ '&LF_CHAR; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_NUMERIC
            zCopy {B$ '&LF_NUMERIC; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_SHORT
            zCopy {B$ '&LF_SHORT; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_USHORT
            zCopy {B$ '&LF_USHORT; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_LONG
            zCopy {B$ '&LF_LONG; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_ULONG
            zCopy {B$ '&LF_ULONG; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_REAL32
            zCopy {B$ '&LF_REAL32; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_REAL64
            zCopy {B$ '&LF_REAL64; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_REAL80
            zCopy {B$ '&LF_REAL80; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_REAL128
            zCopy {B$ '&LF_REAL128; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_QUADWORD
            zCopy {B$ '&LF_QUADWORD; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_UQUADWORD
            zCopy {B$ '&LF_UQUADWORD; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_REAL48
            zCopy {B$ '&LF_REAL48; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_COMPLEX32
            zCopy {B$ '&LF_COMPLEX32; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_COMPLEX64
            zCopy {B$ '&LF_COMPLEX64; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_COMPLEX80
            zCopy {B$ '&LF_COMPLEX80; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_COMPLEX128
            zCopy {B$ '&LF_COMPLEX128; - Hex Value:  ' EOS}
        .Else_If W$esi = &LF_VARSTRING
            zCopy {B$ '&LF_VARSTRING; - Hex Value:  ' EOS}
        .Else_If W$esi = &CV_FIRST_NONPRIM
            zCopy {B$ '&CV_FIRST_NONPRIM; - Hex Value:  ' EOS}
        .End_If

EndP

[MemberSize2: D$ ?]

Proc WriteCVBPRel32OffsetComment:
    Arguments @dwValue
    Uses esi, eax, ebx, edx, ecx

    Mov eax D@dwValue

    If eax = 0
        zCopy {B$ " ; This symbol cannot be evaluated because its location is unknown." EOS}
    End_If

    jns @sign
        Push eax
            zCopy {B$ " ; This is a Local variable: ebp-" EOS}
            neg eax
            Call WriteEax
        Pop eax
            zCopy {B$ " , ebp+" EOS}
            Call WriteEax

EndP

@sign:

        ..If eax < 8
            zCopy {B$ " ; Incorrect Symbol Allocation. This can be a Data Pointer, and not a Local Var or a Argument for this function." EOS}
        ..Else
            Mov ecx eax
            sub eax 8

            ..If eax = 0
                zCopy {B$ " ; This is a Parameter: ebp+08. Argument = 1. RosAsm Style: Arg1" EOS}
            ..Else

                ; divide eax by 4 to calculate how many parameters we have, and if it is a multiple of 4 or not.
                Mov edx 0, ebx 4
                div ebx

                If edx = 0

                    inc eax ; Increment eax to display the proper amount of Arguments.

                    Push eax
                        zCopy {B$ " ; This is a Parameter: ebp+" EOS}
                        Mov eax ecx | Call WriteEax
                    Pop eax

                    zCopy {B$ ". Argument = " EOS}

                    Push esi
                    Push edi
                    Push eax
                        ; Calculate and Display Size (Convert Hexa do Decimal String)
                        Mov D$membersize2 eax
                        Mov esi membersize2, ecx 4
                        Call toUDword
                        Mov esi edi, edi DecimalBuffer
                        Do | movsb | LoopUntil B$esi-1 = 0
                    Pop eax
                    Pop edi
                    Pop esi

                    zCopy DecimalBuffer
                    zCopy {B$ ". RosAsm Style: Arg" EOS}
                    zCopy DecimalBuffer
                Else
                    zCopy {B$ " ; Incorrect Symbol Allocation. This can be a Data Pointer, and not a Local Var or a Argument for this function." EOS}
                End_If

            ..End_If

        ..End_If

EndP
_____________________________________

Proc WriteRawDataDebugSBPRel32Item:
    Argument @Text1, @Text2
    uses eax, ecx

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {B$ 'BPRel32.' EOS}
            zCopy D@Text1
            zCopy D@Text2
        Pop esi

        Mov eax D@Text1

        ..If D$eax = 'Offs' ; from "Offset" string
            lodsd | Call WriteEax
            Call WriteCVBPRel32OffsetComment D$esi-4

        ..Else_If D$eax = 'OldC'; From "OldCVType" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Type'; From "Type" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP

________________

[CVBPRel32Offset: B$ 'Offset' EOS]
[CVBPRel32OldCVType: B$ 'OldCVType' EOS]
[CVBPRel32Type: B$ 'Type' EOS]
[CVBPRel32Namelenght: B$ 'NameLenght' EOS]
[CVBPRel32Name: B$ 'Name' EOS]


Proc WriteRawDataDebugSBPRel32:
    Local @OldCodeView
    Uses ecx

    Mov D@OldCodeView &FALSE
    If W$esi-2 = &S_BPREL32_CV3
        Mov D@OldCodeView &TRUE
    End_If


    Call WriteRawDataDebugSBPRel32Item CVBPRel32Offset , {B$ ': D$ ' EOS}
    If D@OldCodeView = &TRUE
        Call WriteRawDataDebugSBPRel32Item CVBPRel32OldCVType , {B$ ': W$ ' EOS}
    End_If
    Call WriteRawDataDebugSBPRel32Item CVBPRel32Type , {B$ ': W$ ' EOS}
    Call WriteRawDataDebugSBPRel32Item CVBPRel32Namelenght , {B$ ': B$ ' EOS}
    Call WriteRawDataDebugSBPRel32Item CVBPRel32Name , {B$ ': B$ ' EOS}

EndP

__________________________________________________________________

[CVLocalData32OldCVType: B$ 'OldCVType' EOS]
[CVLocalData32Offset: B$ 'Offset' EOS]
[CVLocalData32Segment: B$ 'Segment' EOS]
[CVLocalData32Type: B$ 'Type' EOS]
[CVLocalData32Namelenght: B$ 'NameLenght' EOS]
[CVLocalData32Name: B$ 'Name' EOS]

[CVLocalData32Label: B$ 0 # 20]

Proc WriteRawDataDebugSLData32:
    Local @OldCodeView
;    Uses ecx
    Uses ecx, eax, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx

    Push ebx

    If W$esi-2 = &S_LDATA32
        Move D$CVLocalData32Label {B$ 'LocalData32.' EOS}
    Else_If_Or W$esi-2 = &S_GDATA32, W$esi-2 = &S_GDATA_CV3
        Move D$CVLocalData32Label {B$ 'GlobalData32.' EOS}
    Else
        Move D$CVLocalData32Label {B$ 'PublicData32.' EOS}
    End_If

    If W$esi-2 = &S_GDATA_CV3
        Mov D@OldCodeView &TRUE
    End_If

    If D@OldCodeView = &TRUE
        Call WriteRawDataDebugSLData32Item CVLocalData32OldCVType , {B$ ': D$ ' EOS}
    End_If

    Call WriteRawDataDebugSLData32Item CVLocalData32Offset , {B$ ': D$ ' EOS}
    Call WriteRawDataDebugSLData32Item CVLocalData32Segment , {B$ ': W$ ' EOS}
    Call WriteRawDataDebugSLData32Item CVLocalData32Type , {B$ ': W$ ' EOS}
    Call WriteRawDataDebugSLData32Item CVLocalData32Namelenght , {B$ ': B$ ' EOS}
    Call WriteRawDataDebugSLData32Item CVLocalData32Name , {B$ ': B$ ' EOS}

    Pop ebx

    ; Is the end of this structure ends on the proper place ?

    .If esi <> ebx
        Mov W$edi CRLF | add edi 2
        Call WriteCVdataTitle
        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If


EndP

______________________________________

Proc WriteRawDataDebugSLData32Item:
    Argument @Text1, @Text2
    uses eax, ecx

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ ".Index" EOS}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy D$CVLocalData32Label
            zCopy D@Text1
            zCopy D@Text2
        Pop esi

        Mov eax D@Text1


        ..If D$eax = 'OldC'; From "OldCVType" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Offs'; From "Offset" string
            lodsd | Call WriteEax

        ..Else_If D$eax = 'Segm'; From "Segment" string
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax = 'Type'; From "Type" string
            Call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | Call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | Call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            Mov edx esi | add edx ecx

            .If B$esi = 0
                Mov B$edi '0' | inc edi | inc esi
            .Else

                Mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             Mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        Mov W$edi CRLF | add edi 2

EndP


__________________________________________________________________


[CVDataLenght: B$ 'Length' EOS]
[CVDataIndex: B$ 'Index' EOS]

[SizeAdd: D$ 0]
[CVLabel: B$ 0 # 6]
[CV5Label: B$ '.CV5.' EOS] ; found in some .NET Object Files
[CV4Label: B$ '.CV4.' EOS]
[CV3Label: B$ '.CV3.' EOS]
[CV2Label: B$ '.CV2.' EOS] ; Unknown CV Signature

Proc WriteRawDataDebugS:
    Local @CVSize, @RawDataEnd
    Uses ecx, esi, eax

    Mov ecx esi
    add ecx D$CoffSectionSize
    Mov D@RawDataEnd ecx

    ; If Signature is not 1. Do a byte chain. Signature = 1 is Code or CodeView 4 ?. Other values are data or CodeView older versions ?

    .If D$esi = 1
        Move D$CVLabel CV4Label
        jmp L0>>
    .Else_If D$esi = 2
        Move D$CVLabel CV3Label
        jmp L0>>
    .Else_If D$esi = 4
        sub edi 4
        Push esi | ZCopy {D$ CRLF2, B$ '; This Codeview format is unespecified. It is common for Dot NET files. ' D$ CRLF2 B$ '    B$: B$ ' EOS} | Pop esi
        Mov ecx D$CoffSectionSize
        Call WriteRawDataDataSection

EndP

    .Else    ;   Sometimes they do not contain signatures like in: clusapi2.obj
        Move D$CVLabel CV2Label
        Mov D$SizeAdd 0
        Call InitSectionDebugNumber
        Move D@CVSize D$CoffSectionSize
        sub edi 4
        add D@CVSize esi ; CVSize points to the beginning of the Debug Raw Data
        Mov W$edi CRLF | add edi 2
        Mov D$edi '    ' | add edi 4
        Push esi | zCopy {B$ '; This Debug Section have no signature.' EOS} | Pop esi
        Mov W$edi CRLF | add edi 2
        jmp L1>>

    .End_If

L0:

    Mov D$SizeAdd 0

    Call InitSectionDebugNumber

    Move D@CVSize D$CoffSectionSize
    sub edi 4

    Mov D$edi CRLF2 | add edi 4

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy D$CVLabel
        zCopy {B$ 'Signature: D$ ' EOS}
    Pop esi


        add D@CVSize esi ; CVSize points to the beginning of the Debug Raw Data

        lodsd | Call WriteEax

        If D$esi-4 = 1
            Push esi | ZCopy {B$ " ; The compiler that made this Object File, emitted OMF (Object Module Format) types on it's symbols and Types below" EOS} | Pop esi
        End_If

        Mov W$edi CRLF | add edi 2

   L1:

    .While esi <> D@RawDataEnd

        movzx eax W$esi
        Mov D$SizeAdd eax

        ...If_Or W$esi = 0, W$esi+2 = 0 ; If lenght = 0 , or index = 0 do next line
            add esi 2 ; only increment esi by 2
        ...Else

            .If_Or W$esi+2 = &S_GPROC32, W$esi+2 = &S_LPROC32, W$esi+2 = &S_THUNK32, W$esi+2 = &S_GPROC32_CV3
                Push esi | ZCopy {D$ CRLF2, B$ '; ---------------------- Procedure Start  ---------------------- ', W$ CRLF, 0} | Pop esi
            .End_If

            Call WriteRawDataDebugSItem CVDataLenght, {B$ ': W$ ' EOS}
            Call WriteRawDataDebugSItem CVDataIndex, {B$ ': W$ ' EOS}

            ..If_Or W$esi-2 = &S_COMPILE, W$esi-2 = &S_COMPILE_CV3, W$esi-2 = &S_COMPILE_CV2
                Call WriteRawDataDebugSCompile

            ..Else_If W$esi-2 = &S_MSTOOL_CV2 ; found in acos.obj This is a variation of S_COMPILE found in older versions of codeview
                Call WriteRawDataDebugSMsTool

            ..Else_If_Or W$esi-2 = &S_REGISTER, W$esi-2 = &S_REGISTER_CV3; Register variable
                Call WriteRawDataDebugSRegister

            ..Else_If_Or W$esi-2 = &S_CONSTANT, W$esi-2 = &S_CONSTANT_CV3, W$esi-2 = &S_CONSTANT_CV2 ; Constant symbol (frmMainNET.obj)
                Call WriteRawDataDebugSContant

            ..Else_If_Or W$esi-2 = &S_UDT, W$esi-2 = &S_UDT_CV3, W$esi-2 = &S_UDT_CV2; User-defined Type (frmMainNET.obj)
                Call WriteRawDataDebugSUDT

            ..Else_If W$esi-2 = &S_SSEARCH ; Start search
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_END ; End block, procedure, with, or thunk
                Push esi | ZCopy {W$ CRLF, B$ '; ---------------------- Procedure End  ---------------------- ', D$ CRLF2, 0} | Pop esi

            ..Else_If W$esi-2 = &S_SKIP ; Skip - Reserve symbol space
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_CVRESERVE ; Reserved for internal use by the Microsoft debugger
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_OBJNAME ; Specify name of object file
                Call WriteRawDataDebugSObjectName

            ..Else_If W$esi-2 = &S_ENDARG ; Specify end of arguments in function symbols
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_COBOLUDT ; Microfocus COBOL user-defined type
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_MANYREG ; Many register symbol
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_RETURN ; Function return description
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_ENTRYTHIS ; Description of this pointer at entry
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_BPREL16 ; BP relative 16:16
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_LDATA16 ; Local data 16:16
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_GDATA16 ; Global data 16:16
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_PUB16 ; Public symbol 16:16
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_LPROC16 ; Local procedure start 16:16
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_GPROC16 ; Global procedure start 16:16
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_THUNK16 ; Thunk start 16:16
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_BLOCK16 ; Block start 16:16
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_WITH16 ; With start 16:16
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_LABEL16 ; Code label 16:16
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_CEXMODEL16 ; Change execution model 16:16
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_VFTPATH16 ; Virtual function table path descriptor 16:16
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_REGREL16 ; Specify 16:16 offset relative to arbitrary register
                Mov eax eax
                jmp L0>>

            ..Else_If_Or W$esi-2 = &S_BPREL32, W$esi-2 = &S_BPREL32_CV3 ; BP relative 16:32
                Call WriteRawDataDebugSBPRel32
            ..Else_If W$esi-2 = &S_LDATA32 ; Local data 16:32
                Call WriteRawDataDebugSLData32

            ..Else_If_Or W$esi-2 = &S_GDATA32, W$esi-2 = &S_GDATA_CV3 ; Global data 16:32
                Call WriteRawDataDebugSLData32

            ..Else_If W$esi-2 = &S_PUB32 ; Public symbol 16:32
                Call WriteRawDataDebugSLData32

            ..Else_If W$esi-2 = &S_LPROC32 ; Local (Static) procedure start 16:32
                Call WriteRawDataDebugSGlobalProc
            ..Else_If_Or W$esi-2 = &S_GPROC32, W$esi-2 = &S_GPROC32_CV3 ; Global procedure start 16:32
                Call WriteRawDataDebugSGlobalProc
            ..Else_If W$esi-2 = &S_THUNK32 ; Thunk start 16:32
                Call WriteRawDataDebugSThunkStart1632

            ..Else_If W$esi-2 = &S_BLOCK32 ; Block start 16:32
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_VFTPATH32 ; Virtual function table path descriptor 16:32
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_REGREL32 ; 16:32 offset relative to arbitrary register
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_LTHREAD32 ; Local Thread Storage data
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_GTHREAD32 ; Global Thread Storage data
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_LPROCMIPS ; Local procedure start MIPS
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_GPROCMIPS ; Global procedure start MIPS
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_PROCREF ; Reference to a procedure
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_DATAREF ; Reference to data
                Mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_ALIGN ; Page align symbols
                Mov eax eax
                jmp L0>>

            ..Else_If_Or W$esi-2 >= 01000;, W$esi-2 >= 0
L0:
                Push esi
                    Mov D$edi '    ' | add edi 4
                    Call WriteObjIndice
                    zCopy {B$ "Sec" EOS}
                    zCopy SectionHeaderNumber
                    zCopy {B$ ".Index" EOS}
                    zCopy DebugNumber
                    zCopy D$CVLabel
                    zCopy {B$ 'Unknown' EOS}
                Pop esi
                Call WriteRawDataDebugSUnknown

        ..End_If

    ...End_If

        Call IncrementSectionDebugNumber
        Mov eax D@CVSize
        Mov W$edi CRLF | add edi 2

;    .Loop_Until esi >= eax
    .End_While
EndP
__________________________________________________________________

Proc WriteRawDataDebugSUnknown:
    Uses eax, ecx


    ; This is to avoid that the Structure have dummy bytes at the end.
    Mov ebx esi
    sub ebx 2
    Mov ecx D$SizeAdd
    add ebx ecx
;;
;;
    Push ebx

                    Push esi
                        Mov D$edi '    ' | add edi 4
                        Call WriteObjIndice
                        zCopy {B$ "Sec" EOS}
                        zCopy SectionHeaderNumber
                        zCopy {B$ ".Index" EOS}
                        zCopy DebugNumber
                        zCopy D$CVLabel
                        zCopy {B$ 'Constant.LeafType.Unknown: B$ ' EOS}
                    Pop esi
    Pop ebx
;;
;;

    Push ebx
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayElemType , {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayIdxType , {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayLength, {B$ ': W$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayNamelenght, {B$ ': B$ ' EOS}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayName, {B$ ': B$ ' EOS}
        sub edi 2
    Pop ebx
;;
;;
    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
;;
;;
        Mov W$edi CRLF | add edi 2
        ;Call WriteCVdataTitle
                    Push esi
                        Mov D$edi '    ' | add edi 4
                        Call WriteObjIndice
                        zCopy {B$ "Sec" EOS}
                        zCopy SectionHeaderNumber
                        zCopy {B$ ".Index" EOS}
                        zCopy DebugNumber
                        zCopy D$CVLabel
                        zCopy {B$ 'Constant.LeafType.Unknown: B$ ' EOS}
                    Pop esi

;;
;;
        Push esi | ZCopy {B$ '.Unknown: B$ ' EOS} | Pop esi

        Push ecx

        Mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            Push ebx | Call WriteEax | Pop ebx

            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            Mov W$edi+1 CRLF | add edi 2
            Pop ecx
            inc edi
    .Else
        Mov W$edi CRLF | add edi 2
    .End_If

EndP

__________________________________________________________________



Proc WriteRawDataDebugT:
    Local @CVSize, @RawDataEnd
    Uses ecx, esi, eax

    Mov ecx esi
    add ecx D$CoffSectionSize
    Mov D@RawDataEnd ecx

    ; If Signature is not 1. Do a byte chain. Signature = 1 is Code or CodeView 4 ?. Other values are data or CodeView older versions ?
    If D$esi = 1
        Move D$CVLabel CV4Label
        jmp L0>
    Else_If D$esi = 2
        Move D$CVLabel CV3Label
        jmp L0>
    Else_If D$esi = 4
        Move D$CVLabel CV5Label ; found in NET files. This is really really painfull.
        jmp L0>
    Else
        Call WriteRawDataDataSection

EndP

    End_If

L0:

    Mov D$SizeAdd 0

    Call InitSectionDebugNumber

    Move D@CVSize D$CoffSectionSize
    sub edi 4

    Mov D$edi CRLF2 | add edi 4

    Push esi
        Mov D$edi '    ' | add edi 4
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy D$CVLabel
        zCopy {B$ 'Signature: D$ ' EOS}
    Pop esi

        add D@CVSize esi ; CVSize points to the beginning of the Debug Raw Data

        lodsd | Call WriteEax
        If D$esi-4 = 1
            Push esi | ZCopy {B$ " ; The compiler that made this Object File, emitted OMF (Object Module Format) types on it's symbols and Types below" EOS} | Pop esi
        End_If

        Mov W$edi CRLF | add edi 2

        ; sometimes we may have a file with only the Signature Byte. (Size of raw data is 4 in VBAEXE6.LIB)
        On D@RawDataEnd = esi EndP


    .Do
        movzx eax W$esi
        Mov D$SizeAdd eax

        ...If W$esi = 0 ; If lenght = 0 do next line
            add esi 2 ; only increment esi by 2

        ...Else

            Push eax

            Push esi
                Mov D$edi '    ' | add edi 4
                Call WriteObjIndice

                zCopy {B$ "Sec" EOS}
                zCopy SectionHeaderNumber
                zCopy {B$ ".Index" EOS}
                zCopy DebugNumber
                zCopy D$CVLabel
                zCopy {B$ "Length: W$ " EOS}
            Pop esi

                xor eax eax
                lodsw | Call WriteEax

            Mov W$edi CRLF | add edi 2
            Pop eax

            Call WriteRawDataDebugSContantLeafTypeItem

    ...End_If

        Call IncrementSectionDebugNumber
        Mov eax D@CVSize
        Mov W$edi CRLF | add edi 2

    .Loop_Until esi >= eax

EndP

__________________________________________________________________

Proc WriteRawDataDebugFItem:
    Argument @Text1, @Text2
    uses eax

        Push esi
            Mov D$edi '    ' | add edi 4
            Call WriteObjIndice

            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber

            zCopy {B$ '.FPOData' EOS}
            Mov B$edi '.' | inc edi
            zCopy D@Text1
            zCopy D@Text2
        Pop esi

                Mov eax D@Text1

                If D$eax = 'ulOf' ; from "ulOffStart" string
                    lodsd | Call WriteEax
                    ;Call WriteSectionHeaderRawSizeDiffLabel
                    ;Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi

                Else_If D$eax+2 = 'Proc'; From "cbProcSize" string
                    lodsd | Call WriteEax
                    ;Call WriteSectionHeaderPointerToDataDiffLabel
                    ;Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi

                Else_If D$eax = 'cdwL'; From "cdwLocals" string
                    lodsd | Call WriteEax
                    ;Call InitSectionRelocNumber
                    ;Call WriteSectionHeaderPointerToRelocDiffLabel
                    ;Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi

                Else_If D$eax = 'cdwP'; From "cdwParams" string
                    xor eax eax
                    lodsw | Call WriteEax
                    ;Call InitSectionLineNumber
                    ;Call WriteSectionHeaderPointerToLineNumberDiffLabel
                    ;Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi

                Else_If D$eax+2 = 'Prol'; From "cbProlog" string
                    xor eax eax
                    lodsb | Call WriteEax
                    ;Call InitSectionLineNumber
                    ;Call WriteSectionHeaderPointerToLineNumberDiffLabel
                    ;Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi

                Else_If D$eax = 'Func'; From "FunctionSpec" string
                    xor eax eax
                    lodsb | Call WriteEax
                    ;Call InitSectionLineNumber
                    ;Call WriteSectionHeaderPointerToLineNumberDiffLabel
                    ;Push esi | zcopy {B$ " ; Hex Value:  " EOS} | Pop esi

                End_If

        Mov W$edi CRLF | add edi 2
EndP

;;
;;
 similar to WriteImageSymbolTable and GetCoffSectionHeader
 Uses FPO_DATA Structure. The FPO_DATA in the structures.str is wrong, the correct is:

[FPOData:
 FPOData.ulOffStart: D$ 0
 FPOData.cbProcSize: D$ 0
 FPOData.cdwLocals: D$ 0
 FPOData.cdwParams: W$ 0
 FPOData.cbProlog: B$ 0
 FPOData.FunctionSpec: B$ 0]
;;
;;
[RawDataulOffStart: 'ulOffStart' EOS]
[RawDatacbProcSize: B$ 'cbProcSize' EOS]
[RawDatacdwLocals: B$ 'cdwLocals' EOS]
[RawDatacdwParams: B$ 'cdwParams' EOS]
[RawDatacbProlog: B$ 'cbProlog' EOS]
[RawDataFunctionSpec: B$ 'FunctionSpec' EOS]


WriteRawDataDebugF:

    sub edi 4

    Mov D$edi CRLF2 | add edi 4
    Call WriteRawDataDebugFItem RawDataulOffStart, {B$ ': D$ ' EOS}
    Call WriteRawDataDebugFItem RawDatacbProcSize, {B$ ': D$ ' EOS}
    Call WriteRawDataDebugFItem RawDatacdwLocals, {B$ ': D$ ' EOS}
    Call WriteRawDataDebugFItem RawDatacdwParams, {B$ ': W$ ' EOS}
    Call WriteRawDataDebugFItem RawDatacbProlog, {B$ ': B$ ' EOS}
    Call WriteRawDataDebugFItem RawDataFunctionSpec, {B$ ': B$ ' EOS}

ret
__________________________________________________________________

WriteRawDataOnlyStringsSection:

    ; Initialize the String Record Counter

    Call InitStringTableRecord
    Push esi
        Call WriteObjIndice
        zCopy {B$ "Sec" EOS}
        zCopy SectionHeaderNumber
        zCopy {B$ '.StringData.Signature' EOS}
        Mov D$edi ': B$', B$edi+4 SPC | add edi 5
    Pop esi
        While B$esi <> 0 | movsb | End_While
    xor eax eax
    lodsb | Call WriteEax

    Mov W$edi CRLF | add edi 2

    Mov edx D$CoffSectionSize
    dec edx
    add edx, esi ; We will use edx as a counter delimiter for the strings

   .Do

        Push esi
            Call WriteObjIndice
            zCopy {B$ "Sec" EOS}
            zCopy SectionHeaderNumber
            zCopy {B$ '.StringData.Arr' EOS}
            zCopy StringTableRecord
            zCopy {B$ ": B$ '" EOS}
        Pop esi


        While B$esi <> 0 | movsb | End_While | inc esi | On B$esi = 0, Mov edx 0

        Mov D$edi "', 0" | add edi 4
        Mov W$edi CRLF | add edi 2

        Call IncrementStringTableRecord

    .Loop_Until esi >= edx

    sub edi 2
    Mov W$edi CRLF | add edi 2
ret

__________________________________________________________________

WriteRawDataDataSection:

L0:         movzx eax B$esi | Call WriteEax
            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If
            loop L0<

            sub edi 2
ret
__________________________________________________________________

WriteRawDataCodeSection:

L0:         movzx eax B$esi | Call WriteEax
            Mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                Mov W$edi CRLF | add edi 2 | Mov edx 0
                Mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If
            loop L0<

            sub edi 2

ret
__________________________________________________________________

WriteRawDataLinkerDirective:

    Mov edx esi | add edx ecx

    .If B$esi = 0
        Mov B$edi '0' | inc edi | inc esi
    .Else

        Mov B$edi "'" | inc edi
L0:     lodsb
        If al = 0
            dec esi | jmp L1>
        End_If
        stosb | On esi < edx, jmp L0<
L1:     Mov B$edi "'" | inc edi

    .End_If

    While esi < edx | lodsb | Mov D$edi ', 0' | add edi 3 | End_While

ret
__________________________________________________________________

WriteRawdataEnd:

    Mov W$edi CRLF | add edi 2
    Call WriteObjIndice
    zCopy {B$ "Sec" EOS}
    zCopy SectionHeaderNumber
    zCopy {B$ ".RawDataEnd" EOS}
    zCopy {B$ ":]" D$ CRLF2} ; EOS ?
ret
__________________________________________________________________

Proc WriteRawdataTitle:
    Uses esi, ecx

    zCopy CoffRawDataSectionTitle
    Call WriteObjIndice
    zCopy {B$ "ImgSecHdr" EOS}
    zCopy SectionHeaderNumber
    zCopy {B$ ".PointerToRawData", W$ CRLF, 0}

    Mov W$edi CRLF, B$edi+2 '[' | add edi 3
    Call WriteObjIndice
    zCopy {B$ "Sec" EOS}
    zCopy SectionHeaderNumber
    zCopy {B$ '.RawData' EOS}
    Mov D$edi ': B$', B$edi+4 SPC | add edi 5

EndP
__________________________________________________________________

[CoffRawDataInfoTitle: B$ "_________________________________________________________

; Raw Data Info
_________________________________________________________
" EOS]

[CoffRawDataSectionTitle: "
; These are the Raw Data Values referenced at: " EOS]

Proc WriteCoffSectionData:
    Uses esi, eax, ecx, edx


    ...If D$CoffSectionSize = 0

    ...Else_If D$CoffPointerToData = 0 ; Is the Pointer to Raw Data = 0 ? Yes, exit

    ...Else

        Push esi | zCopy CoffRawDataInfoTitle | Pop esi
        ; esi points to the Begin of the Raw data section, ecx points to the size of the raw data
        Mov esi D$CoffSectionBase | add esi D$CoffPointerToData
        Mov ecx D$CoffSectionSize, edx 0

        ..If D$RawDataType = RDT_LNKDIRECTIVE
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    Linker Directive Reports:", D$ CRLF2, 0} | Pop esi
                Call WriteRawDataLinkerDirectiveReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            Call WriteRawDataLinkerDirective

        ..Else_If D$RawDataType = RDT_CODE
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to CODE", D$ CRLF2, 0} | Pop esi
                ; Call WriteRawDataCodeSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            Call WriteRawDataCodeSection

        ..Else_If D$RawDataType = RDT_VIRTUALDATA
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to Virtual Data", D$ CRLF2, 0} | Pop esi
                ; Call WriteRawDataDataSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            Call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_DEBUGS
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to Debug$S", D$ CRLF2, 0} | Pop esi
                ; Call WriteRawDataDataSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            ;Call WriteRawDataDebugS
            Call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_DEBUGF
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to Debug$F - Frame Point Omission", D$ CRLF2, 0} | Pop esi
            ; Call WriteRawDataDebugFReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            Call WriteRawDataDebugF

        ..Else_If D$RawDataType = RDT_DEBUGT
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to Debug$T - Debug Type", D$ CRLF2, 0} | Pop esi
            ; Call WriteRawDataDataSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            Call WriteRawDataDataSection
            ;Call WriteRawDataDebugT

        ..Else_If D$RawDataType = RDT_DEBUGP
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to Debug$P", D$ CRLF2, 0} | Pop esi
            ; Call WriteRawDataDataSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle
            Call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_STABSTR
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to NetFramework strings section - stabstr", D$ CRLF2, 0} | Pop esi
            ; Call WriteRawDataDataSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle
            sub edi 4
            Mov W$edi CRLF | add edi 2
            Call WriteRawDataOnlyStringsSection

        ..Else_If D$RawDataType = RDT_IDATA
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to Import Table Data - idata", D$ CRLF2, 0} | Pop esi
            ; Call WriteRawDataDataSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            Call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_RDATA
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to Read-Only Data - rdata", D$ CRLF2, 0} | Pop esi
            ; Call WriteRawDataDataSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            Call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_XDATA
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to Exception information - xdata", D$ CRLF2, 0} | Pop esi
            ; Call WriteRawDataDataSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            Call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_PDATA
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to Exception information - pdata", D$ CRLF2, 0} | Pop esi
            ; Call WriteRawDataDataSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            Call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_EDATA
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to Export tables - edata", D$ CRLF2, 0} | Pop esi
            ; Call WriteRawDataDataSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            Call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_TLSDATA
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to Thread-local storage - tls", D$ CRLF2, 0} | Pop esi
            ; Call WriteRawDataDataSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            Call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_RELOCDATA
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to Image relocations - reloc", D$ CRLF2, 0} | Pop esi
            ; Call WriteRawDataDataSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            Call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_RSRCDATA
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to resources - rsrc", D$ CRLF2, 0} | Pop esi
            ; Call WriteRawDataDataSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            Call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_ERROR
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    There was an error on the debug or the data section. These raw values will be assumed as DATA", D$ CRLF2, 0} | Pop esi
            ; Call WriteRawDataDataSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            Call WriteRawDataDataSection

        ..Else
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Push esi | zCopy {B$ "    This Raw Data is related only to DATA", D$ CRLF2, 0} | Pop esi
            ; Call WriteRawDataDataSectionReport
            Mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            Call WriteRawdataTitle

            Call WriteRawDataDataSection

        ..End_If

        Call WriteRawdataEnd

    ...End_If

EndP


;;
;;
  Values set in 'FirstSectionPointer', 'NumberOfRelocations', 'CoffPointerToReloc'
  by 'GetCoffSectionsVariables'.
;;
;;
WriteCoffReloc:

    Call InitSectionRelocNumber

    Push esi
        Mov esi D$CoffSectionBase | add esi D$CoffPointerToReloc
        Mov ecx D$NumberOfRelocations

L0:     Push ecx
            Call GetCoffRelocHeader
            Call IncrementSectionRelocNumber
        Pop ecx

        loop L0<
    Pop esi
ret



WriteCoffLineNumber:
    Call InitSectionLineNumber
    Push esi
        Mov esi D$CoffSectionBase | add esi D$CoffPointerToLineNumber
        Mov ecx D$NumberOfLineNumbers

L0:     Push ecx
            Call GetCoffLineHeader
            Call IncrementSectionLineNumber
        Pop ecx

        loop L0<
    Pop esi
ret


____________________________________________________________________________________________




[ImageFileEquate: B$ '&IMAGE_FILE_' EOS]
[IMAGE_FILE_16BIT_MACHINE: B$ '16BIT_MACHINE' EOS]
[IMAGE_FILE_32BIT_MACHINE: B$ '32BIT_MACHINE__' EOS]
[IMAGE_FILE_AGGRESSIVE_WS_TRIM: B$ 'AGGRESSIVE_WS_TRIM' EOS]
[IMAGE_FILE_BYTES_REVERSED_HI: B$ 'BYTES_REVERSED_HI__' EOS]
[IMAGE_FILE_BYTES_REVERSED_LO: B$ 'BYTES_REVERSED_LO__' EOS]
[IMAGE_FILE_DEBUG_STRIPPED: B$ 'DEBUG_STRIPPED__' EOS]
[IMAGE_FILE_DLL: B$ 'DLL__' EOS]
[IMAGE_FILE_EXECUTABLE_IMAGE: B$ 'EXECUTABLE_IMAGE__' EOS]
[IMAGE_FILE_LARGE_ADDRESS_AWARE: B$ 'LARGE_ADDRESS_AWARE__' EOS]
[IMAGE_FILE_LINE_NUMS_STRIPPED: B$ 'LINE_NUMS_STRIPPED__' EOS]
[IMAGE_FILE_LOCAL_SYMS_STRIPPED: B$ 'LOCAL_SYMS_STRIPPED__' EOS]
[IMAGE_FILE_NET_RUN_FROM_SWAP: B$ 'NET_RUN_FROM_SWAP__' EOS]
[IMAGE_FILE_RELOCS_STRIPPED: B$ 'RELOCS_STRIPPED__' EOS]
[IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP: B$ 'REMOVABLE_RUN_FROM_SWAP__' EOS]
[IMAGE_FILE_SYSTEM: B$ 'SYSTEM__' EOS]
[IMAGE_FILE_UP_SYSTEM_ONLY: B$ 'UP_SYSTEM_ONLY__' EOS]


WriteObjCharacteristics:
    Push esi

    Mov D$edi ' ; ' | add edi 3

    test eax &IMAGE_FILE_32BIT_MACHINE | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_32BIT_MACHINE

L1: test eax &IMAGE_FILE_16BIT_MACHINE | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_16BIT_MACHINE

L1: test eax &IMAGE_FILE_BYTES_REVERSED_HI | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_BYTES_REVERSED_HI

L1: test eax &IMAGE_FILE_AGGRESSIVE_WS_TRIM | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_AGGRESSIVE_WS_TRIM

L1: test eax &IMAGE_FILE_BYTES_REVERSED_LO | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_BYTES_REVERSED_LO

L1: test eax &IMAGE_FILE_DEBUG_STRIPPED | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_DEBUG_STRIPPED

L1: test eax &IMAGE_FILE_DLL | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_DLL

L1: test eax &IMAGE_FILE_EXECUTABLE_IMAGE | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_EXECUTABLE_IMAGE

L1: test eax &IMAGE_FILE_LARGE_ADDRESS_AWARE | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_LARGE_ADDRESS_AWARE

L1: test eax &IMAGE_FILE_LINE_NUMS_STRIPPED | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_LINE_NUMS_STRIPPED

L1: test eax &IMAGE_FILE_LOCAL_SYMS_STRIPPED | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_LOCAL_SYMS_STRIPPED

L1: test eax &IMAGE_FILE_NET_RUN_FROM_SWAP | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_NET_RUN_FROM_SWAP

L1: test eax &IMAGE_FILE_RELOCS_STRIPPED | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_RELOCS_STRIPPED

L1: test eax &IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP

L1: test eax &IMAGE_FILE_SYSTEM | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_SYSTEM

L1: test eax &IMAGE_FILE_UP_SYSTEM_ONLY | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_UP_SYSTEM_ONLY

L1: Pop esi

    While B$edi-1 = '_' | dec edi | End_While
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
;;
  Data, Equates used more than once
;;
;;

[COFF_HEADER_SIZE 03C    ARCH_TAG 8
 LIB_USER_ID 01C         LIB_MEMBER_SIZE 030]

[IMAGE_ARCHIVE_MEMBER_HEADERstring: B$ ' Structure: IMAGE_ARCHIVE_MEMBER_HEADER' EOS]
____________________________________________________________________________________________

;;
;;
  This is called multiple times
;;
;;

[MemberSize: D$ ?]

GetMemberSize:
    Push esi
        Mov ecx 10, ebx 0, eax 0
        While B$esi > SPC
            mul ecx
            Push eax
                lodsb | sub al '0' | Mov bl al
            Pop eax
            add eax ebx
        End_While
        Mov D$MemberSize eax
    Pop esi
ret

______________________________

[MemberDate: D$ ?]

GetMemberDate:
    Push esi
        Mov ecx 10, ebx 0, eax 0
        While B$esi > SPC
            mul ecx
            Push eax
                lodsb | sub al '0' | Mov bl al
            Pop eax
            add eax ebx
        End_While
        Mov D$MemberDate eax
    Pop esi
ret

______________________________

Proc WriteNamesLinkerMemberX:
    Argument @Name, @n, @LinkerMember
    Local @Item

        Push esi
            Mov esi D@LinkerMember
            While B$esi <> 0 | movsb | End_While

            Mov B$edi '.' | inc edi
            Mov esi D@Name

            Move D@Item D$esi

            If D$esi = 'Size'
                Pop esi | Push esi
                Call GetMemberSize
                Mov esi D@Name

            Else_If D$esi = 'Date'
                Pop esi | Push esi
                Call GetMemberDate
                Mov esi D@Name
            End_If

            While B$esi <> 0 | movsb | End_While
        Pop esi

        Mov D$edi ': B$' | add edi 4

        .If D@n <> 0-2

            Mov W$edi " '" | add edi 2
            Mov ecx D@n

            If D@Item = 'User'
                Mov D$edi '****', W$edi+4 '**' | add edi 6 | sub ecx 6 | add esi 6
            End_If

            rep movsb

            While B$edi-1 = 0 | dec edi | End_While

            Mov B$edi "'" | inc edi
            Mov W$edi CRLF | add edi 2

        .Else
            Mov B$edi SPC | inc edi
            Mov ecx D@n | neg ecx
L0:         lodsb | and eax 0FF | Call WriteEax | Mov W$edi ', ' | add edi 2 | loop L0<
            sub edi 2

        .End_If
EndP

____________________________________________________________________________________________

[LibObjIndice: B$ '000001' EOS]

InitCoffIndice:
    Mov D$LibObjIndice '0000', D$LibObjIndice+4 '01'
ret

IncrementLibCoffIndice:
    lea ebx D$LibObjIndice+5 | inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret

WriteCoffIndice:
    Push esi
        Mov D$edi 'Obj_' | add edi 4
        Mov eax D$LibObjIndice, D$edi eax
        Mov ax W$LibObjIndice+4, W$edi+4 ax
        Mov D$edi+6 ': ; ' | add edi 10
    Pop esi
ret


_________________________________________________________

[szDateString: B$ ? # 64]
[szTimeString: B$ ? # 64]

Proc WriteLinkerMemberTimeDateStamp:
    Arguments @TimeDate
    Uses esi

        ; Write the Value of the Date in Hexadecimal string
        Mov esi {B$ ' ; Hex Value:  ' EOS}
        sub edi 2 ; We need to subtract 02 Bytes, to bypass the CRLF
        While B$esi <> 0 | movsb | End_While
        Mov eax D@TimeDate
        Call Writeeax

        Mov esi {B$ ' - TimeDate Stamp: ' EOS}
        While B$esi <> 0 | movsb | End_While

      ; Get the DateTime Stamp

      ; Time date stamp to string Function
        Call TimeDateStampToString D@TimeDate, {B$ "yyyy/MM/dd ddd " EOS},
                                   {B$ "HH:mm:ss UTC" EOS}, szDateString, szTimeString

      ; Write the TimeDate Stamp strings
        Mov esi szDateString
        While B$esi <> 0 | movsb | End_While

        Mov esi szTimeString
        While B$esi <> 0 | movsb | End_While

      ; We now Add the paragraphs marks, and add 02 Bytes at edi:
        Mov W$edi CRLF | add edi 2


EndP

_________________________________________________________

Proc WriteLinkerMemberSizeHex:
    Arguments @SizeValue
    Uses esi
    ; Write the Value of the Size in Hexadecimal string

        Mov esi {B$ ' ; Hex Value:  ' EOS}
        sub edi 2 ; We need to subtract 02 Bytes, to bypass the CRLF
        While B$esi <> 0 | movsb | End_While
        Mov eax D@SizeValue
        Call Writeeax
        Mov W$edi CRLF | add edi 2 ; We now Add the paragraphs marks, and add 02 Bytes at edi

EndP
_________________________________________________________


[NamesLinkerMember: B$ 'NamesLinkerMember'
 ARCHIVE_MEMBER_HEADER_Indice: B$ '000001' EOS]


[NamesLinkerMember1: B$ 'NamesLinkerMember_1' EOS]

Write_IMAGE_ARCHIVE_MEMBER_HEADER_1:
    Mov B$edi '[' | inc edi

    Call WriteNamesLinkerMemberX {B$ 'Name1' EOS}, 16, NamesLinkerMember1
    Call WriteNamesLinkerMemberX {B$ 'Date' EOS}, 12, NamesLinkerMember1
    Call WriteLinkerMemberTimeDateStamp D$MemberDate
    Call WriteNamesLinkerMemberX {B$ 'UserID' EOS}, 6, NamesLinkerMember1
    Call WriteNamesLinkerMemberX {B$ 'GroupID' EOS}, 6, NamesLinkerMember1
    Call WriteNamesLinkerMemberX {B$ 'Mode' EOS}, 8, NamesLinkerMember1
    Call WriteNamesLinkerMemberX {B$ 'Size1' EOS}, 10, NamesLinkerMember1
    Call WriteLinkerMemberSizeHex D$MemberSize
    Call WriteNamesLinkerMemberX {B$ 'EndHeader' EOS}, 0-2, NamesLinkerMember1

    Mov B$edi ']', D$edi+1 CRLF2 | add edi 5

    lea ebx D$ARCHIVE_MEMBER_HEADER_Indice+5 | inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret


[NamesLinkerMember2: B$ 'NamesLinkerMember_2' EOS]

Write_IMAGE_ARCHIVE_MEMBER_HEADER_2:
    Mov B$edi '[' | inc edi

    Call WriteNamesLinkerMemberX {B$ 'Name1' EOS}, 16, NamesLinkerMember2
    Call WriteNamesLinkerMemberX {B$ 'Date' EOS}, 12, NamesLinkerMember2
    Call WriteLinkerMemberTimeDateStamp D$MemberDate
    Call WriteNamesLinkerMemberX {B$ 'UserID' EOS}, 6, NamesLinkerMember2
    Call WriteNamesLinkerMemberX {B$ 'GroupID' EOS}, 6, NamesLinkerMember2
    Call WriteNamesLinkerMemberX {B$ 'Mode' EOS}, 8, NamesLinkerMember2
    Call WriteNamesLinkerMemberX {B$ 'Size1' EOS}, 10, NamesLinkerMember2
    Call WriteLinkerMemberSizeHex D$MemberSize
    Call WriteNamesLinkerMemberX {B$ 'EndHeader' EOS}, 0-2, NamesLinkerMember2

    Mov B$edi ']', D$edi+1 CRLF2 | add edi 5

    lea ebx D$ARCHIVE_MEMBER_HEADER_Indice+3 | inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret


[NamesLinkerMember3: B$ 'NamesLinkerMember_3' EOS]

Write_IMAGE_ARCHIVE_MEMBER_HEADER_3:
    Mov B$edi '[' | inc edi

    Call WriteNamesLinkerMemberX {B$ 'Name1' EOS}, 16, NamesLinkerMember3
    Call WriteNamesLinkerMemberX {B$ 'Date' EOS}, 12, NamesLinkerMember3
    Call WriteLinkerMemberTimeDateStamp D$MemberDate
    Call WriteNamesLinkerMemberX {B$ 'UserID' EOS}, 6, NamesLinkerMember3
    Call WriteNamesLinkerMemberX {B$ 'GroupID' EOS}, 6, NamesLinkerMember3
    Call WriteNamesLinkerMemberX {B$ 'Mode' EOS}, 8, NamesLinkerMember3
    Call WriteNamesLinkerMemberX {B$ 'Size1' EOS}, 10, NamesLinkerMember3
    Call WriteLinkerMemberSizeHex D$MemberSize
    Call WriteNamesLinkerMemberX {B$ 'EndHeader' EOS}, 0-2, NamesLinkerMember3

    Mov B$edi ']', D$edi+1 CRLF2 | add edi 5

    lea ebx D$ARCHIVE_MEMBER_HEADER_Indice+5 | inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret

[CoffTitle: B$ "

_____________________________________________________________________________________________
_____________________________________________________________________________________________

; The Coff File Format Starts here. Indice: " EOS]

WriteCoffTitle:
    Push esi
        Mov esi CoffTitle | While B$esi <> 0 | movsb | End_While
        Mov eax D$LibObjIndice, D$edi eax,
            ax W$LibObjIndice+4, W$edi+4 ax,
            D$edi+6 CRLF2 | add edi 10
    Pop esi
ret


[Obj_LIB_USER_ID: B$ 'Obj_' CopyOf_LIB_USER_ID: B$ '000001' EOS]

Proc Write_Obj_IMAGE_ARCHIVE_MEMBER_HEADER:
    Local @StartAddress

    Mov B$edi '[' | inc edi

    ...If B$esi = '/'
      ; First or Second Header: nop
        ..If B$esi+1 <> SPC
          ; Case of Obj with LongNames Table in the Third Header:
            Call WriteCoffIndice
            Push esi
                inc esi
                If D$LongNamesBase <> 0
                    Call CheckLongNameDisplacement | On eax = &FALSE, jmp L1>
                    ; to be used in AddListviewItem
                    Mov D$StartObjNameAddress edi
                    Call WriteLongName esi
                Else

   L1:
                    ; to be used in AddListviewItem
                    Mov D$StartObjNameAddress edi
                    Call CopyObjSymbolName

                End_If
                Mov esi IMAGE_ARCHIVE_MEMBER_HEADERstring
                While B$esi <> 0 | movsb | End_While
                Mov W$edi CRLF | add edi 2
            Pop esi
        ..Else
            ; There seem to exist case of Functions called by Number, here
            Mov D$StartObjNameAddress edi

            Call WriteCoffIndice
            While B$esi <> 0 | movsb | End_While
            Push esi
                Mov esi IMAGE_ARCHIVE_MEMBER_HEADERstring
                While B$esi <> 0 | movsb | End_While
                Mov W$edi CRLF | add edi 2
            Pop esi

        ..End_If

    ...Else
      ; Case of Obj without LongNames Table (No Third Header) Ex.: UUID.LIB ; WLDAP32.LIB:
        Call WriteCoffIndice

        Mov D$StartObjNameAddress edi
        Push esi

            Call CopyObjSymbolName
            Mov esi IMAGE_ARCHIVE_MEMBER_HEADERstring
            While B$esi <> 0 | movsb | End_While
            Mov W$edi CRLF | add edi 2
        Pop esi

    ...End_If

    Call ParseLibObjectSymbolName D$StartObjNameAddress

    Mov eax D$esi+LIB_USER_ID, D$CopyOf_LIB_USER_ID eax,
        ax W$esi+LIB_USER_ID+4, W$CopyOf_LIB_USER_ID+4 ax

    Call WriteNamesLinkerMemberX {B$ 'Name1' EOS}, 16, Obj_LIB_USER_ID
    Call WriteNamesLinkerMemberX {B$ 'Date' EOS}, 12, Obj_LIB_USER_ID
    Call WriteLinkerMemberTimeDateStamp D$MemberDate
    Call WriteNamesLinkerMemberX {B$ 'UserID' EOS}, 6, Obj_LIB_USER_ID
    Call WriteNamesLinkerMemberX {B$ 'GroupID' EOS}, 6, Obj_LIB_USER_ID
    Call WriteNamesLinkerMemberX {B$ 'Mode' EOS}, 8, Obj_LIB_USER_ID
    Call WriteNamesLinkerMemberX {B$ 'Size1' EOS}, 10, Obj_LIB_USER_ID
    Call WriteLinkerMemberSizeHex D$MemberSize
    Call WriteNamesLinkerMemberX {B$ 'EndHeader' EOS}, 0-2, Obj_LIB_USER_ID

    Mov B$edi ']', D$edi+1 CRLF2 | add edi 5

    lea ebx D$ARCHIVE_MEMBER_HEADER_Indice+5 | inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx | inc B$ebx
    End_While

EndP
____________________________________________________________________________________________


; This function is to be used for displaying the object file name in the list view

; Built this way to solve really weird file nameings paths like:

;;
;;
[Obj_000009: ; Long Name: wizard\wizard.obj Structure: IMAGE_ARCHIVE_MEMBER_HEADER
[Obj_000001: ; Short Name: poide.exe Structure: IMAGE_ARCHIVE_MEMBER_HEADER
[Obj_000004: ; Short Name: poide.exe Function Name: _WizAddProjectFileA@4 Structure: IMAGE_ARCHIVE_MEMBER_HEADER
[Obj_000050: ; Long Name: unwind-dw2-fde.o Structure: IMAGE_ARCHIVE_MEMBER_HEADER
[Obj_000235 ; Short Name: $UWD\except.obj Structure: IMAGE_ARCHIVE_MEMBER_HEADER
[Obj_000235 ; Long Name: $UWD\validadd.obj Structure: IMAGE_ARCHIVE_MEMBER_HEADER
[Obj_000135 ; Long Name: ../XXX\nanonano.obj Structure: IMAGE_ARCHIVE_MEMBER_HEADER
[Obj_000134 ; Long Name: ./.XXX/nanonano.obj Structure: IMAGE_ARCHIVE_MEMBER_HEADER
;;
;;

[ObjectName: B$ ? # 256]
[StartObjNameAddress: D$ ?]
[EndObjNameAddress: D$ ?]
[ObjExtensionStr: B$ ? # 16]
[UseObjExtension: D$ ?]
[ExportedLibrary: D$ ?]
[ExportedLibraryStr: B$ ? # 256]
[UseObjPath: D$ ?]
[ObjPathStr: B$ ? # 256]

Proc ParseLibObjectSymbolName:
    Arguments @StartAddress
    Local @TempEndAddr, @TempStartAddr, @StartExportObjAddr, @EndObjPathAddr, @StartObjExtensionAddr, @UseExportedLibrary

    pushad

    ; Always clear the loaded data before use.
    Call ClearDwordBuffer ObjectName,
                          (256/DWORD)
    
    Call ClearDwordBuffer ObjExtensionStr,
                          (16/DWORD)
    
    Call ClearDwordBuffer ObjPathStr,
                          (256/DWORD)

    ; Initialize all the data
    Mov D$ObjFileNameType 0
    Mov D$UseObjPath 0
    Mov D$UseObjExtension 0
    Mov D@TempStartAddr 0
    Mov D@TempEndAddr 0
    Mov D@StartExportObjAddr 0
    Mov D@UseExportedLibrary 0

    Mov esi D@StartAddress

    ; 1St Step. Locate the start and the end of the String, and also get the FileNameType and the check Exported Library
    Mov ecx 0 ; we will use ecx as a counter.
              ; The maximum size allowed for this is 784 bytes (Max path + Max Object Name + Max exported Lib string + Max extension)
    .While ecx <> (256*3+16)

        .If_And D$esi = 'Long', D$esi+4 = ' Nam' ; is it a Long Name string type ?

            ; to be used in AddListviewItem
            Mov D$ObjFileNameType 1
            add D@StartAddress 11 ; (String len) "Long Name: "

        .Else_If_And D$esi = 'Shor', D$esi+4 = 't Na' ; is it a Short Name string type ?

            ; to be used in AddListviewItem
            Mov D$ObjFileNameType 0
            add D@StartAddress 12 ; (String len) "Short Name: "

        .Else_If_And D$esi = ' Fun', D$esi+4 = 'ctio', D$esi+8 = 'n Na', D$esi+12 = 'me: '

            ; to be used in AddListviewItem
            Mov D@StartExportObjAddr esi
            Mov D@UseExportedLibrary 1

        .Else_If_And D$esi = ' Str', D$esi+4 = 'uctu', D$esi+8 = 're: ' ; Did we reached the end of the string ?
                                                                        ; Our string always ends with " Structure: "
            Mov D@TempEndAddr esi
            jmp L1>

        .End_If
        inc ecx
        inc esi
    .End_While

   L1:


    ; 2nd Step. Now that we have the start and ending address, we must check if we are dealing with a non-common format.
    ; These formats always have the String " Function Name: " on it. Copy it to the proper buffer (ExportedLibraryStr)

    .If D@UseExportedLibrary = 1
        Mov esi D@StartExportObjAddr
        Move D@TempEndAddr D@StartExportObjAddr
    .End_If


    ; 3rd Step. Now that we have our full string, we need to see if it have any path inside.
    ; We must start from the end to the beginning of the string to find the path chars.
    Mov esi D@StartAddress
    Mov ecx D@TempEndAddr

    .While esi <> ecx

        If_Or B$ecx = '/', B$ecx = '\'

            Mov D@EndObjPathAddr ecx
            Mov D$UseObjPath 1
            jmp L1>
        End_If

        dec ecx
    .End_While

   L1:

    ; 4th Step. If we have a Path, we will copy it to the proper Buffer (ObjPathStr)

    .If D$UseObjPath = 1
        ; Here esi is already defined as the starting point. We don't need to change it now.
        Mov ecx D@EndObjPathAddr
        Mov edi ObjPathStr

        .While esi <> ecx
            movsb
            ;inc esi
        .End_While
        inc esi ; Bypass the last "/" or "\" char preceeding the object name.
        Mov D@StartAddress esi ; Will points to the beginning of the object name only

    .End_If

    ; 5th Step. At this point we have only the name of the object and it's extension (if any).
    ; So we must find and copy the object extension.

    Mov esi D@StartAddress
    Mov ecx D@TempEndAddr
    Mov edi ObjectName

    On esi = ecx, jmp L2> ; If the end and starting address is teh same ones, it is an empty string

    .Do

        .If B$esi = '.'
            Mov D$UseObjExtension 1
            Mov edi ObjExtensionStr
            inc esi ; Bypass the "." char
            While esi <> ecx
                movsb
            End_While
            jmp L2>
        .End_If

        movsb
    .Loop_Until esi = ecx

   L2:

    popad
EndP

____________________________________________________________________________________________


ParseLibObj:
    Push esi
        ...If W$esi = &IMAGE_FILE_MACHINE_UNKNOWN
            ..If W$esi+2 = &IMPORT_OBJECT_HDR_SIG2
              ; +12 is the 'NameType'. 0 >>> Ordinal for the Function,
              ; that should be at +10...
                .If W$esi+012 <> 0
                    Call WriteLibImportObj
                    add esi 014
                    Call WriteImportObjStrings

                .Else
                    ;Call SendMeThisLib
                    Call WriteLibImportObj

                    movzx eax W$esi+010
                    Mov edx D$esi+0C
                    add esi 014
                    add edx esi
                    Mov ebx esi | While B$ebx <> 0 | inc ebx | End_While | inc ebx
                    If ebx < edx
                        Call WriteImportObjStrings
                    Else
                        Call WriteImportObjStringAndOrdinal eax
                    End_If
                .End_If

            ..Else
                ; to be added in AddListviewItem
                ; Always clear the loaded data before use.
                Call ClearDwordBuffer ExportedLibraryStr,
                                      (256/DWORD)
                
                Mov D$ExportedLibrary 0
                
                Call GetCoffListing

            ..End_If

        ...Else
            ; to be added in AddListviewItem
            ; Always clear the loaded data before use.
            Call ClearDwordBuffer ExportedLibraryStr,
                                  (256/DWORD)
   
            Mov D$ExportedLibrary 0
   
            Call GetCoffListing

        ...End_If
    Pop esi
ret
____________________________________________________________________________________________

[IMAGE_FILE_MACHINE_Text:
 &IMAGE_FILE_MACHINE_UNKNOWN, '&IMAGE_FILE_MACHINE_UNKNOWN' EOS
 &IMAGE_FILE_MACHINE_ALPHA, '&IMAGE_FILE_MACHINE_ALPHA' EOS
 &IMAGE_FILE_MACHINE_ALPHA64, '&IMAGE_FILE_MACHINE_ALPHA64' EOS
 &IMAGE_FILE_MACHINE_ARM, '&IMAGE_FILE_MACHINE_ARM' EOS
 &IMAGE_FILE_MACHINE_AXP64, '&IMAGE_FILE_MACHINE_AXP64' EOS
 &IMAGE_FILE_MACHINE_CEF, '&IMAGE_FILE_MACHINE_CEF' EOS
 &IMAGE_FILE_MACHINE_I386, '&IMAGE_FILE_MACHINE_I386' EOS
 &IMAGE_FILE_MACHINE_I486, '&IMAGE_FILE_MACHINE_I486' EOS
 &IMAGE_FILE_MACHINE_I586, '&IMAGE_FILE_MACHINE_I586' EOS
 &IMAGE_FILE_MACHINE_IA64, '&IMAGE_FILE_MACHINE_IA64' EOS

 &IMAGE_FILE_MACHINE_M68K, '&IMAGE_FILE_MACHINE_M68K' EOS
 &IMAGE_FILE_MACHINE_MIPS16, '&IMAGE_FILE_MACHINE_MIPS16' EOS
 &IMAGE_FILE_MACHINE_MIPSFPU, '&IMAGE_FILE_MACHINE_MIPSFPU' EOS
 &IMAGE_FILE_MACHINE_MIPSFPU16, '&IMAGE_FILE_MACHINE_MIPSFPU16' EOS
 &IMAGE_FILE_MACHINE_POWERPC, '&IMAGE_FILE_MACHINE_POWERPC' EOS
 &IMAGE_FILE_MACHINE_R10000, '&IMAGE_FILE_MACHINE_R10000' EOS
 &IMAGE_FILE_MACHINE_R3000, '&IMAGE_FILE_MACHINE_R3000' EOS
 &IMAGE_FILE_MACHINE_R4000, '&IMAGE_FILE_MACHINE_R4000' EOS
 &IMAGE_FILE_MACHINE_R6000, '&IMAGE_FILE_MACHINE_R6000' EOS
 &IMAGE_FILE_MACHINE_SH3, '&IMAGE_FILE_MACHINE_SH3' EOS

 &IMAGE_FILE_MACHINE_SH3E, '&IMAGE_FILE_MACHINE_SH3E' EOS
 &IMAGE_FILE_MACHINE_SH4, '&IMAGE_FILE_MACHINE_SH4' EOS
 &IMAGE_FILE_MACHINE_SH5, '&IMAGE_FILE_MACHINE_SH5' EOS
 &IMAGE_FILE_MACHINE_SH3DSP, '&IMAGE_FILE_MACHINE_SH3DSP' EOS
 &IMAGE_FILE_MACHINE_THUMB, '&IMAGE_FILE_MACHINE_THUMB' EOS
 &IMAGE_FILE_MACHINE_WCEMIPSV2, '&IMAGE_FILE_MACHINE_WCEMIPSV2' EOS
 &IMAGE_FILE_MACHINE_AM33, '&IMAGE_FILE_MACHINE_AM33' EOS
 &IMAGE_FILE_MACHINE_AMD64, '&IMAGE_FILE_MACHINE_AMD64' EOS
 &IMAGE_FILE_MACHINE_CEE, '&IMAGE_FILE_MACHINE_CEE' EOS
 &IMAGE_FILE_MACHINE_EBC, '&IMAGE_FILE_MACHINE_EBC' EOS

 &IMAGE_FILE_MACHINE_M32R, '&IMAGE_FILE_MACHINE_M32R' EOS
 &IMAGE_FILE_MACHINE_POWERPCFP, '&IMAGE_FILE_MACHINE_POWERPCFP' EOS
 &IMAGE_FILE_MACHINE_TRICORE, '&IMAGE_FILE_MACHINE_TRICORE' EOS, 0-1, 0-1]

[UnKown_IMAGE_FILE_MACHINE: B$ ' ; Unknown or corrupted IMAGE_FILE_MACHINE' EOS]

Proc WriteIMAGE_FILE_MACHINE:
    Argument @Type
    Uses esi

        Mov esi IMAGE_FILE_MACHINE_Text, eax D@Type | and eax 0FFFF

        ..While D$esi <> 0-1
            .If D$esi = eax
                add esi 4 | While B$esi <> 0 | movsb | End_While | ExitP
            .Else
                add esi 5
                .While B$esi <> '&'
                    inc esi
                    If D$esi = 0-1
                        Call WriteEax
                        Mov esi UnKown_IMAGE_FILE_MACHINE
                        While B$esi <> 0 | movsb | End_While | ExitP
                    End_If
                .End_While
                sub esi 4
            .End_If
        ..End_While
EndP


Proc IsIMAGE_FILE_MACHINE:
    Argument @Type
    Uses esi

        Mov esi IMAGE_FILE_MACHINE_Text, eax D@Type | and eax 0FFFF

        .While D$esi <> 0-1
            .If D$esi = eax
                Mov eax &TRUE | ExitP
            .Else
                add esi 5
                While B$esi <> '&'
                    inc esi
                    If D$esi = 0-1
                        Mov eax &FALSE | ExitP
                    End_If
                End_While
                sub esi 4
            .End_If
        .End_While
EndP

____________________________________________________________________________________________

;;

;;
 
 
 LibScan_ErrManager
 _____________________
 
    This function manages the error cases of the LIbScanner system
 
 Parameters: 
 
    ErrFlag: Handle to the error message. The equates used on this function are:

    IMP_OBJ_RESBIT_ERR = 01 ; Reserved Bits are not Zero
    IMP_OBJ_UNKTYPE_ERR = 02 ; Unknown Type
    

        PE_DATADIRSMALL 01 = The Directory Entry is located before the 1st section, on the DosHeader or in the PEHeader.
 
 Return values:
 
    Return &TRUE if  the user wants to contine analysing the file.
    Return &FALSE if he wants to stop the analysis.
 
 
;;

;[PE_DATADIRSMALL 01]
;[PE_DIRDATADOS 02]
;[PE_DIRDATASIZE 03]
;[PE_DIRDATAUNKNOWN 04]
;;

[IMP_OBJ_RESBIT_ERR 01]
[IMP_OBJ_UNKTYPE_ERR 02]


Proc LibScan_ErrManager:
    Arguments @ErrFlag
    Uses edx ; messagebox function changes the value of edx...So we need to preserve it, because we will use it.

    Mov eax D@ErrFlag

    .If eax = IMP_OBJ_RESBIT_ERR


        Call 'USER32.MessageBoxA' 0, {B$ "CORRUPTED LIBRARY !!!

The reserved Bits for the ImpObjHdr.Type member of the structure IMPORT_OBJECT_HEADER
on this Library are not Zero.

RosAsm can continue loading this file, but we will set the reserved Bits to ZERO to you be able to load this safelly.

* Press the YES button to set the necessary bits to Zero.
* Press the NO button to end analysing this file.
  
If after the automatically fix, this file still have errors, please, report this error to the author at:
  Betov@free.fr

Or report this error to the Development Team at the main RosAsm Forum.

Many thanks in advance. Betov.
  
" EOS}, {B$ 'Corrupted Library' EOS}, &MB_SYSTEMMODAL__&MB_ICONEXCLAMATION__&MB_YESNO

            If eax = &IDNO
                Mov eax &FALSE
            Else_If eax = &IDYES
                Mov eax &TRUE
            End_If

    .Else_If eax = IMP_OBJ_UNKTYPE_ERR

          Call 'USER32.MessageBoxA' D$H.MainWindow {B$ "UNKNOWN TYPE !!!.

The reserved Bits for the ImpObjHdr.Type member of the structure IMPORT_OBJECT_HEADER
on this Library are of a Unknown Type.

The regular Type values of this member can not be 3, 7, 11, 15 to 31.

Your file have one of those unknown types.

RosAsm can't continue loading this file.

Please, report this error to the author, and send this file to the author at:
  Betov@free.fr

Or report this error to the Development Team at the main RosAsm Forum.

Many thanks in advance. Betov." EOS} {B$ "Unknown Type" EOS} &MB_SYSTEMMODAL__&MB_ICONEXCLAMATION

            Mov eax &FALSE

    .End_If

EndP


____________________________________________________________________________________________

[ImpObjHdrSig1Text: B$ 'ImpObjHdr.Sig1: W$ &IMAGE_FILE_MACHINE_UNKNOWN' EOS]
[ImpObjHdrSig2Text: B$ 'ImpObjHdr.Sig2: W$ &IMPORT_OBJECT_HDR_SIG2' EOS]
[ImpObjHdrVersionText: B$ 'ImpObjHdr.Version: W$ ' EOS]
[ImpObjHdrMachineText: B$ 'ImpObjHdr.Machine: W$ ' EOS]
[ImpObjHdrTimeDateStampText: B$ 'ImpObjHdr.TimeDateStamp: D$ ' EOS]
[ImpObjHdrSizeOfDataText: B$ 'ImpObjHdr.SizeOfData: D$ ' EOS]
[ImpObjHdrOrdinalText: B$ 'ImpObjHdr.Ordinal.Hint: W$ ' EOS]
[ImpObjHdrType: B$ 'ImpObjHdr.Type: W$ ' EOS]

WriteObjIndice:
    Mov D$edi 'Obj',
        ecx D$LibObjIndice, D$edi+3 ecx,
        cx W$LibObjIndice+4, W$edi+7 cx

    add edi 9

    Mov B$edi '.' | inc edi
ret


WriteIndiceOnly:
    Mov ecx D$LibObjIndice, D$edi ecx, cx W$LibObjIndice+4, W$edi+4 cx
    add edi 6
ret


Proc WriteLibImportObjItem:
    Arguments @Text, @Flag
    Uses esi

        Call WriteObjIndice

        Mov esi D@Text | While B$esi <> 0 | movsb | End_While

        If D@Text = ImpObjHdrMachineText
            Call WriteIMAGE_FILE_MACHINE eax

        Else_If D@Text = ImpObjHdrType
            ; Need to increase edi with CRLF at the end, because when  the function returns, it
            ; decreases edi by 2. And we need to close the bracket after the paragraph, due to the commented
            ; Hexadecimal Value below.
            Push eax
            Call WriteLibImportObjType eax
            Pop eax
            zCopy {B$ ' ; Hex Value:  ' EOS}
            Call WriteEax
            Mov W$edi CRLF | add edi 2

        Else_If D@Text = ImpObjHdrSizeOfDataText

            Push esi
                Call WriteObjIndice
                zCopy {B$ 'ImportStringsEnd' EOS}
            Pop esi

            Mov D$edi ' - ' | add edi 3
            Push esi
                Call WriteObjIndice
                zCopy {B$ 'ImportStrings ; Hex Value:  ' EOS}
            Pop esi
            Call WriteEax

        Else_If B@Flag = &TRUE
            Call WriteEax

        End_If

        Mov W$edi CRLF | add edi 2
EndP

____________________________________________________________________________________________



;LibImportObjType:
; Bits 0 and 1:
[IMPORT_OBJECT_CODE: B$ '&IMPORT_OBJECT_CODE' EOS]
[IMPORT_OBJECT_DATA: B$ '&IMPORT_OBJECT_DATA' EOS]
[IMPORT_OBJECT_CONST: B$ '&IMPORT_OBJECT_CONST' EOS]

; Bits 2 to 3 (SHRed) >>> 0 to 1
[IMPORT_OBJECT_NAME: B$ '&IMPORT_OBJECT_NAME' EOS]
[IMPORT_OBJECT_NAME_NO_PREFIX: B$ '&IMPORT_OBJECT_NAME_NO_PREFIX' EOS]
[IMPORT_OBJECT_NAME_UNDECORATE: B$ '&IMPORT_OBJECT_NAME_UNDECORATE' EOS]
[IMPORT_OBJECT_ORDINAL: B$ '&IMPORT_OBJECT_ORDINAL' EOS]
;;
;;
  Example, if a Type Word would be:
  
  '&IMPORT_OBJECT_DATA' and '&IMPORT_OBJECT_NAME_NO_PREFIX'
  
  The Assembly representation would be:
  
  &IMPORT_OBJECT_DATA + (&IMPORT_OBJECT_NAME_NO_PREFIX shl 2)
;;

;;

    We have at eax the ImpObjHdr.Type member that is a WORD data. Accordying to the documentation, we only
    are interested in Bits 0 to 3 to use for Type and NameType members interpretations.
    Bit4 is for Unknown Type and should not be considered to analysis at the present moment.
    Bits 5 to 15 are reserved and should be setlled to 0 accordying to the docs, because they are not
    interpreteded and are not used whatsoever.
    
    A Word data have a maximum value of 0FFFF (65535), meaning that bits 0 to 15 are all settled to 1.
    
    Since bits 5 to 15 are not used, we can set them all to 0, that will result on a maximum value for this member of
    31 (Bits 0 to 4 are all settled to 1, then).
    
    Now, our WORD have a maximum range of 31.
    
    Accordying to the docs, we can have a possible set of Equates under the following form:
 
    EQUATES Forms                                               Value   Bits Sets                       Union
    
    &IMPORT_OBJECT_CODE+(&IMPORT_OBJECT_ORDINAL shl 2)          = 0     No Bits are Flaged              Ordinal
    &IMPORT_OBJECT_CODE+(&IMPORT_OBJECT_NAME shl 2)             = 4     Only Bit2 is flaged             Hint
    &IMPORT_OBJECT_CODE+(&IMPORT_OBJECT_NAME_NO_PREFIX shl 2)   = 8     Only Bit3 is flaged             Hint
    &IMPORT_OBJECT_CODE+(&IMPORT_OBJECT_NAME_UNDECORATE shl 2)  = 12    Only Bit2 and Bit3 are flaged   Hint
     
    &IMPORT_OBJECT_DATA+(&IMPORT_OBJECT_ORDINAL shl 2)          = 1     Only Bit0 is flaged             Ordinal
    &IMPORT_OBJECT_DATA+(&IMPORT_OBJECT_NAME shl 2)             = 5     Only Bit0 and Bit2 are flaged   Hint
    &IMPORT_OBJECT_DATA+(&IMPORT_OBJECT_NAME_NO_PREFIX shl 2)   = 9     Only Bit0 and Bit3 are flaged   Hint
    &IMPORT_OBJECT_DATA+(&IMPORT_OBJECT_NAME_UNDECORATE shl 2)  = 13    Only Bit0,Bit2,Bit3 are flaged  Hint
 
    &IMPORT_OBJECT_CONST+(&IMPORT_OBJECT_ORDINAL shl 2)         = 2     Only Bit1 is flaged             Ordinal
    &IMPORT_OBJECT_CONST+(&IMPORT_OBJECT_NAME shl 2)            = 6     Only Bit1 and Bit2 are flaged   Hint
    &IMPORT_OBJECT_CONST+(&IMPORT_OBJECT_NAME_NO_PREFIX shl 2)  = 10    Only Bit1 and Bit3 are flaged   Hint
    &IMPORT_OBJECT_CONST+(&IMPORT_OBJECT_NAME_UNDECORATE shl 2) = 14    Only Bit1,Bit2,Bit3 are flaged  Hint

    
    So, All values equal or above 14 are not allowed and also we can not have the following values and interpretations:
    So, from values between 31 and 14 we have an Unknown Type. All Values bigger or equal then 32 we have a corrupted
    Library because the reserved Fields are not 0.
    
    The list of Uknown Types are:
    03; 07; 11, 15 to 31

   Ex.: We have a WORD with the value of 4073. So we clean the high bits resulting, like this:
                Mov eax 4073 | Mov ah 0 ; Bits 8 to 15 settled to 0)
        
        Now we must clear the bits 5 to 7, because they are unused. Like this:
         btr eax 5 | btr eax 6 | btr eax 7 ; I´m using this, because it is probably faster on big files.
         
        Or we can also do this:
        shl eax 3 | Mov ah 0 | shr eax 3
        
   
   
;;
;;
[SymNameType: B$ 0] ; Holds the NameType value to be used to Skip the leading chars on NameType member.

Proc WriteLibImportObjType:
    Argument @Flags
    Uses esi, ebx

        Mov eax D@Flags

        .If_And eax >= 32, eax <= 65535 ; Check for Corrupted library. Reserved Bits are not 0

            Call LibScan_ErrManager IMP_OBJ_RESBIT_ERR

            If eax = &FALSE ; The user pressed No

EndP

            Else_If eax = &TRUE ; The user pressed Yes. We will Zero all reserved bits for him continue the parsing.
                Mov eax D@Flags ; Restore the original value of eax to be fixed
                Mov ah 0 ; Clear High Bits Flags
                btr eax 5 | btr eax 6 | btr eax 7 ; Clear Bits 5 to 7

            End_If

        .End_If

        ; Check for Unknown Types


        test eax 010 | jz A1> ; Is Bit4 Flagged ? So, is eax = 16 to 31 ? No, jmp over
            Call LibScan_ErrManager IMP_OBJ_UNKTYPE_ERR

EndP

A1:
        test eax 1 | jz A2> ; Is bit0 flagged ? No...Ok, we don´ have any unknown types (15, 11, 7, 3)
            test eax 2 | jz A2> ; is bit1 also Flagged ? No...Ok, we don´ have any unknown types (15, 11, 7, 3) jmp over.

            Call LibScan_ErrManager IMP_OBJ_UNKTYPE_ERR

            ; Yes bit0 and bit1 are flagged, we have unknown types (15, 11, 7, 3)
EndP

A2:


    ; We are Ok. We have only the values 0,1,2,4,5,6,8,9,10,12,13,14 on eax

          ; First lower two Bits (Code / Data / Constant). We can only have one of the 02 bits set, or none of them.

            test eax &IMPORT_OBJECT_DATA | jz L1> ; Is Bit0 Flaged ? Yes, do next line. Values = 1,5,9,13
                Mov esi IMPORT_OBJECT_DATA
                jmp L2>

L1:         test eax &IMPORT_OBJECT_CONST | jz L1> ; Is Bit1 Flaged ? Yes, do next line. Values = 2,6,10,14
                Mov esi IMPORT_OBJECT_CONST
                jmp L2>

L1:         ; we don´ have bit0 and bit1 flagged. Values = 0,4,8,12
                Mov esi IMPORT_OBJECT_CODE

L2:
                While B$esi <> 0 | movsb | End_While
                Mov W$edi '+(' | add edi 2


          ; Second Part of the Record of Bits 2,3 (Ordinal, Name, NoPrefix, Undecorated)
          ; We can have all of the 02 bits set, or none of them.

                shr eax 2


            cmp eax &IMPORT_OBJECT_NAME_UNDECORATE | jnz L1> ; Is Bit0 and 1 Flaged ? Yes, do next line
                                                            ; Values = 12, 13, 14
                Mov esi IMPORT_OBJECT_NAME_UNDECORATE
                Mov B$SymNameType &IMPORT_OBJECT_NAME_UNDECORATE ; Save for later skip leading chars
                jmp L2>


L1:         test eax &IMPORT_OBJECT_NAME | jz L1> ; Is Bit0 Flaged ? Yes, do next line. Values = 4,5,6
                Mov esi IMPORT_OBJECT_NAME
                jmp L2>

L1:         test eax &IMPORT_OBJECT_NAME_NO_PREFIX | jz L1> ; Is Bit1 Flaged ? Yes, do next line. Values = 8,9,10
                Mov esi IMPORT_OBJECT_NAME_NO_PREFIX
                Mov B$SymNameType &IMPORT_OBJECT_NAME_NO_PREFIX ; Save for later skip leading chars
                jmp L2>

L1:         ; we don't have bit0 and bit1 flagged. Values = 0,1,2
                Mov esi IMPORT_OBJECT_ORDINAL

L2:
                While B$esi <> 0 | movsb | End_While
                Mov D$edi ' shl', D$edi+4 ' 2)' | add edi 7

EndP


____________________________________________________________________________________________

Proc WriteImportObjHdrTimeDateStamp:
    Arguments @TimeDate
    Uses esi

        sub edi 2 ; We need to subtract 02 Bytes, to bypass the previous CRLF
        Mov esi {B$ ' ; - TimeDate Stamp: ' EOS}
        While B$esi <> 0 | movsb | End_While

        ; Get the DateTime Stamp

        ; Time date stamp to string Function
        Call TimeDateStampToString D@TimeDate {B$ "yyyy/MM/dd ddd " EOS} {B$ "HH:mm:ss UTC" EOS} szDateString szTimeString

        ; Write the TimeDate Stamp strings
        Mov esi szDateString
        While B$esi <> 0 | movsb | End_While

        Mov esi szTimeString
        While B$esi <> 0 | movsb | End_While

        Mov W$edi CRLF | add edi 2 ; We now Add the paragraphs marks, and add 02 Bytes at edi

EndP
____________________________________________________________________________________________

[ImpObjDateStamp: D$ ?]

WriteLibImportObj:

    Push esi
        Mov esi CoffListingTitle
        While B$esi <> 0 | movsb | End_While
        Call WriteIndiceOnly
        Mov B$edi ':', W$edi+1 CRLF | add edi 3
    Pop esi

    ; To be used in AddListviewItem
    Push esi
        Mov D$LvOffsetCOFF 0 ; always initialize at 0 1st, due to the several loopings for each object.
        sub esi D$LibFileMemory
        Mov D$LvOffsetCOFF esi
    Pop esi

    Push esi
;        Mov B$edi '[' | inc edi

        Call WriteLibImportObjItem ImpObjHdrSig1Text, &FALSE | add esi 2

        Call WriteLibImportObjItem ImpObjHdrSig2Text, &FALSE | add esi 2

        movzx eax W$esi | add esi 2
        Call WriteLibImportObjItem ImpObjHdrVersionText, &TRUE

        ; To be used in AddListviewItem
        Mov W$CoffMachineType 0 ; always initialize at 0 1st, due to the several loopings for each object.
        Move W$CoffMachineType W$esi

        movzx eax W$esi | add esi 2
        Call WriteLibImportObjItem ImpObjHdrMachineText, &TRUE

        lodsd
        Mov D$ImpObjDateStamp eax
        Call WriteLibImportObjItem ImpObjHdrTimeDateStampText, &TRUE
        Call WriteImportObjHdrTimeDateStamp D$ImpObjDateStamp

        lodsd
        If D$esi-4 <> 0
            Call WriteLibImportObjItem ImpObjHdrSizeOfDataText, &TRUE
        Else

            Push esi
                Call WriteObjIndice
                zCopy ImpObjHdrSizeOfDataText
            Pop esi
            Call WriteEax
            Mov W$edi CRLF | add edi 2
        End_If

        movzx eax W$esi | add esi 2
        Call WriteLibImportObjItem ImpObjHdrOrdinalText, &TRUE

        movzx eax W$esi | add esi 2
        Call WriteLibImportObjItem ImpObjHdrType, &TRUE

        Mov B$edi-2 ']' | dec edi | Mov D$edi CRLF2 | add edi 4
    Pop esi
ret


[ImportStringsText: B$ "ImportStrings: B$ '" EOS]
[RosAsmInterpretation: B$ "; RosAsm Interpretation: '" EOS]
[RosAsmUndecoratedName: B$ "; Full Undecorated Name: " EOS]

;[UndecNameBuffer: D$ 0 # 4000]
;[Size_Of_UndecNameBuffer 4000]

Proc WriteImportObjStrings:
    Uses ecx, esi

    Mov D$edi '[' | inc edi
    Mov D$edi 'Obj',
        eax D$LibObjIndice, D$edi+3 eax,
        ax W$LibObjIndice+4, W$edi+7 ax,
        B$edi+9 '.' | add edi 10
    Push esi
        Mov esi ImportStringsText | While B$esi <> 0 | movsb | End_While
    Pop esi

    Push esi
        ; to be added in AddListviewItem
        Push esi
        Push edi
            ; Always clear the loaded data before use.
            Call ClearDwordBuffer ExportedLibraryStr,
                                  (256/DWORD)
            
            Mov D$ExportedLibrary 1
            Mov edi ExportedLibraryStr
            While B$esi <> 0 | movsb | End_While
        Pop edi
        Pop esi


        ; Copy the Function Name:
        While B$esi <> 0 | movsb | End_While
        Mov D$edi "', 0", D$edi+4 ", '" | add edi 7
        While B$esi = 0 | inc esi | End_While

        ; Copy the Module Name:
        Push esi
            While B$esi <> 0 | movsb | End_While
            Mov D$edi "', 0" | add edi 4
            Mov W$edi CRLF | add edi 2
            Push esi
                Call WriteObjIndice
                zCopy {B$ 'ImportStringsEnd:]' EOS}
            Pop esi
            Mov D$edi CRLF2 | add edi 4

            Mov esi RosAsmInterpretation | While B$esi <> 0 | movsb | End_While
        Pop esi

        ; Copy the Commented Module Name:
        While B$esi <> 0 | movsb | End_While
        Mov eax D$edi-4 | or eax 020202000
        If eax = '.dll'
            sub edi 4
        End_If

        Mov B$edi '.' | inc edi
    Pop esi

    Mov ecx esi ; Copy esi String to be used for name undecoration

  ; Copy the Commented Function Name:

    ; Remove 1st '_'; '@'; '?'
    .If B$SymNameType = &IMPORT_OBJECT_NAME_NO_PREFIX

        On B$esi = '_', inc esi
        On B$esi = '@', inc esi
        On B$esi = '?', inc esi

       While B$esi <> 0 | movsb | End_While

    ; Remove 1st '_'; '@'; '?' and truncate after next '@'.
    ; Ex:   _AbortPath@4 to AbortPath
    ;       ?WSCWriteProviderOrder@@YGHPAKK@Z to WSCWriteProviderOrder WS2_32.lib
    ;       ___CxxLongjmpUnwind@4 to __CxxLongjmpUnwind (MSVCRT.LIB)

    .Else_If B$SymNameType = &IMPORT_OBJECT_NAME_UNDECORATE

        On B$esi = '_', inc esi
        On B$esi = '@', inc esi
        On B$esi = '?', inc esi
        ; Ok, removed the above chars. No we need to truncate after findng the @
        While B$esi <> '@'

            On B$esi = 0, jmp L0> ; Sometimes we have No @ char here (Pelles\advapi32.lib)
                                  ; [Obj000397.ImportStrings: B$ '_SetServiceBits' EOS, 'ADVAPI32.dll' EOS]
            movsb

        End_While

        L0:

    .Else
        ; For all other cases, keep the lib name intact
       While B$esi <> 0 | movsb | End_While

    .End_If

    Mov B$edi "'" | inc edi

    Mov D$edi CRLF2 | add edi 4

    ; Write the full Undecorated name. Ecx ecx points to {B$ '?wndTopMost@CWnd@@2V1@B' EOS}

    Push esi
        Mov esi RosAsmUndecoratedName | While B$esi <> 0 | movsb | End_While
    Pop esi

    Push ecx
    Call 'IMAGEHLP.UnDecorateSymbolName' ecx, Trash, 4000, &UNDNAME_COMPLETE
    Pop ecx

    Call StrCmp ecx Trash

    ; If the strings are the same it means that the above function failed, because the undecoretated name is not the same
    ; as the original loaded name.
    If eax = 0
        Call Simple_UndecorateSymbolName ecx, Trash
    End_If

    Push esi
        Mov esi Trash | While B$esi <> 0 | movsb | End_While
    Pop esi


    Mov D$edi CRLF2 | add edi 4
EndP
___________________________________________________________________________
;;
;;
Bad Values

[Obj000004.ImportStrings: B$ '?ClearFontManager@@YAXXZ' EOS, 'AYGSHELL.dll' EOS
Obj000004.ImportStringsEnd:]

; RosAsm Interpretation: 'AYGSHELL.?ClearFontManager@@YAXXZ'

; Full Undecorated Name: void __cdecl ClearFontManager(void)


Good values


; RosAsm Interpretation: B$ 'ACLUI.EditSecurity'

; Full Undecorated Name: _EditSecurity@8
;;
;;
Proc Simple_UndecorateSymbolName:
    Arguments @Input, @Output
    Local @ParamCount

    pushad

    Mov D@ParamCount 0
    Mov edi D@Input

    While B$edi <> 0
        On B$edi = '?', jmp L4>> ; On this simplified versin we cannot have this char
        On B$edi = '$', jmp L4>> ; On this simplified versin we cannot have this char
        On B$edi = '@', jmp L1> ; This is possible to have, but a good symbols can only have this once.
        inc edi
    End_While

    jmp L2>
L1:
   inc edi

    While B$edi <> 0
        On B$edi = '@', jmp L4>> ; If we found this value again, we have a bad symbol
        If_And B$edi < '0', B$edi > '9' ; the values after the '@' char must be numbers from 0 to 9. Otherwise it is a bad symbol
            jmp L4>
        End_If
        inc edi
    End_While

    ; If we reach here we have a Good Symbol.
L2:

    Mov esi D@Input
    Mov edi D@Output

    If B$esi = '_'
        inc esi
    End_If

    If B$esi = 0
        Push esi | ZCopy {B$ "Invalid ! Null Symbol Name." EOS} | Pop esi
        jmp L4>
    End_If

    .While B$esi <> 0

        .If B$esi = '@' ; We found our delimiter for the Parameters amount.
            inc esi ; Bypass the '@' char.
            Call DecimalStringToDword esi
            shr eax 2 ; divide the result by 4
            Push esi | ZCopy {B$ " - Amount of Parameters: " EOS} | Pop esi

            ; Convert Dword to Decimal String
            Push edi
                Mov D@ParamCount eax
                lea esi D@ParamCount
                Mov ecx 4
                Call toUDword
                Mov esi edi
            Pop edi

            Do | movsb | LoopUntil B$esi-1 = 0
            dec edi
            jmp L3>
        .End_If

        movsb
    .End_While

L3:
    Mov B$edi 0

   L4:

    popad

EndP

___________________________________________________________________________
___________________________________________________________________________

; based on GetMemberSize

Proc DecimalStringToDword:
    Arguments @String
    Uses, esi, ebx, ecx, edx

    Mov esi D@String
    Mov ecx 10, ebx 0, eax 0

    .While B$esi <> 0
        on B$esi = SPC, ExitP
        mul ecx
        Push eax
            lodsb | sub al '0' | Mov bl al
        Pop eax
        add eax ebx
    .End_While

EndP
___________________________________________________________________________
___________________________________________________________________________

Proc WriteImportObjStringAndOrdinal:
    Argument @Ordinal

        Mov D$edi '[' | inc edi
        Mov D$edi 'Obj',
            eax D$LibObjIndice, D$edi+3 eax,
            ax W$LibObjIndice+4, W$edi+7 ax,
            B$edi+9 '.' | add edi 10
        Push esi
            Mov esi ImportStringsText | While B$esi <> 0 | movsb | End_While
        Pop esi


        ; to be added in AddListviewItem
        Push esi,
             edi

            ; Always clear the loaded data before use.
            Call ClearDwordBuffer ExportedLibraryStr,
                                  (256/DWORD)
            
            Mov D$ExportedLibrary 1
            
            Mov edi ExportedLibraryStr
            
            While B$esi <> 0 | movsb | End_While
        
        Pop edi,
            esi


        ; Copy the Module Name:
        Push esi
            While B$esi <> 0 | movsb | End_While
            Mov D$edi "', 0" | add edi 4
            Mov W$edi CRLF | add edi 2
            Push esi
                Call WriteObjIndice
                zCopy {B$ 'ImportStringsEnd:]' EOS}
            Pop esi
            Mov D$edi CRLF2 | add edi 4

            Mov esi RosAsmInterpretation | While B$esi <> 0 | movsb | End_While

        Pop esi

      ; Copy the Commented Module Name:
        While B$esi <> 0 | movsb | End_While
        Mov eax D$edi-4 | or eax 020202000
        If eax = '.dll'
            sub edi 4
        End_If

        Mov B$edi '.' | inc edi
    Pop esi
  ; Copy the Commented Function Ordinal:
    Mov eax D@Ordinal | Call WriteEax

    Mov D$edi CRLF2 | add edi 4
EndP



[LookUpValidNameCharsTable: B$ ? # 0100]

InitLookUpValidNameCharsTable:
    Mov edi LookUpValidNameCharsTable, eax 0, ecx 0100

  ; Build a normal Asicii Table:
L0: Mov B$edi+eax al | inc eax | loop L0<
ret

  ; Replace everything above 127 by '_'
    Mov ecx 080, ebx 080, al '_'
L0: Mov B$edi+ebx al | inc ebx | loop L0<

  ; Replace Ascii 127 by '_'
    Mov B$edi+07F '_'

    Mov eax '\' | Mov B$edi+eax '.'

    Mov eax '?' | Mov B$edi+eax '.'

    Mov eax '_' | Mov B$edi+eax '.'

    Mov eax '$' | Mov B$edi+eax '.'

    Mov eax '|' | Mov B$edi+eax '.'
ret
;;
  ; Other possibility:
;;
  
    Mov al '_', ecx 0100, edi LookUpValidNameCharsTable | rep stosb
    
    Mov edi LookUpValidNameCharsTable, eax '0'
    While eax <= '9'
        Mov B$edi+eax al | inc al
    End_While
    
    Mov eax 'A'
    While eax <= 'Z'
        Mov B$edi+eax al | inc al
    End_While
    
    Mov eax 'a'
    While eax <= 'z'
        Mov B$edi+eax al | inc al
    End_While
ret
;;
;;
[LookUpValidNameChars | lodsb | and eax 0FF | Mov al B$LookUpValidNameCharsTable+eax | stosb]

[IMAGE_ARCHIVE_MEMBER_SIZE 030]

GetLongNamesPointer:  ; GetMemberSize
    ...If D$LongNamesBase = 0
        pushad
          ;  Mov esi D$LibFileMemory | add esi 8

L0:         If W$esi = '//'
                add esi 03C
                Mov D$LongNamesBase esi

            Else_If B$esi = '/'
                Push D$MemberSize
                    add esi IMAGE_ARCHIVE_MEMBER_SIZE
                    Call GetMemberSize
                    sub esi IMAGE_ARCHIVE_MEMBER_SIZE
                    add esi 03C | add esi D$MemberSize
                Pop D$MemberSize | jmp L0<

            End_If
        popad
    ...End_If
ret


CheckLongNameDisplacement:
    Push esi
        While B$esi <> SPC
            lodsb
            If al < '0'
                Mov eax &FALSE | jmp L9>
            Else_If al > '9'
                Mov eax &FALSE | jmp L9>
            End_If
        End_While
        Mov eax &TRUE
L9: Pop esi
ret


Proc WriteLongName:  ; GetMemberSize
    Argument @Dis
    Uses ebx, ecx, edx

    Push esi
        Mov esi {B$ 'Long Name: ' EOS};IMAGE_ARCHIVE_MEMBER_HEADERstring
        While B$esi <> 0 | movsb | End_While
    Pop esi

        Mov esi D@Dis, ecx 10, ebx 0, eax 0

        While B$esi > SPC
            mul ecx
            Push eax
                lodsb | sub al '0' | Mov bl al
            Pop eax
            add eax ebx
        End_While

        Mov esi D$LongNamesBase | add esi eax

        While B$esi >= SPC | movsb | End_While
        On B$edi-1 = '/', dec edi
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[LongNamesBase: D$ ?]

GetLongNamesBase:
    Mov D$LongNamesBase 0
   ____________________________________________
  ; Lib Tag:
    Mov esi D$LibFileMemory | add esi 8

    If W$esi = '/ '
        Push esi
            add esi LIB_MEMBER_SIZE | Call GetMemberSize
        Pop esi
        add esi COFF_HEADER_SIZE
        add esi D$MemberSize | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Second optional Lib Header:
    If W$esi = '/ '
        Push esi
            add esi LIB_MEMBER_SIZE | Call GetMemberSize
        Pop esi
        add esi COFF_HEADER_SIZE
        add esi D$MemberSize | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Third optional Lib Header:
    If W$esi = '//'
        add esi COFF_HEADER_SIZE
        Mov D$LongNamesBase esi
    End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
;;
;;
                      Write the Tag and first Library Header
;;
;;
____________________________________________________________________________________________

[WriteNotice: ";;

RosAsm Development Team presents:
________________________________________________

______________ Lib Scanner v 1.0  ______________
__________________  Set/05  ____________________
________________________________________________

This file was generated by RosAsm Library File Dumper,
aka known as Lib Scanner v 1.0.

http://www.rosasm.org
http://rosasm.org
http://betov.free.fr

If you have any questions about this file, read RosAsm's
Help file (B_U_Asm.exe), or feel free to contact us at:

http://www.quanta-it.com/easbell/RosAsmForum/index.php

_______________________

Author(s):

René Tournois (Betov)
Gustavo Trigueiros (Beyond2000!)

;;
________________________________________________

;;
" EOS]


[LibTag: ";;

________________________________________________

    Tag Data. The Magic String
________________________________________________
________________________________________________
;;
;;
[Magic: B$   '!<arch>', 0A]


;;
;;
________________________________________________

    First Linker Header - Names Linker Member
________________________________________________
________________________________________________
;;
;;

; This is the IMAGE_ARCHIVE_MEMBER_HEADER Structure.

" EOS]
____________________________________________________________________________________________

WriteLibTag:
  ; (Includes the First Headers comments at once):
    Mov esi LibTag | While B$esi <> 0 | movsb | End_While

    Mov esi D$LibFileMemory | add esi 8
ret
____________________________________________________________________________________________

[AmountOfMembers: B$ "; Amount of Members on the file.

[PublicSymbols1: D$ " EOS]

[NumberOfSymbols: D$ ?]

ShowAmountOfSymbols1:
;;
;;
  Show the Amount of Symbols (a dWord stored the other way round):
;;
;;
    Push esi
        Mov esi AmountOfMembers | While B$esi <> 0 | movsb | End_While
    Pop esi
    lodsd | bswap eax | Mov D$NumberOfSymbols eax | Call WriteEax

    Mov B$edi ']', D$edi+1 CRLF2 | add edi 5
ret
____________________________________________________________________________________________

[AmountOfOffsets1: B$ "; Amount of Offsets of the Public Symbols.

[SymOffset:
 " EOS]

ShowOffsetTable1: ; 'ShowOffsetTable2'
;;
;;
  Show the Offset Table (where each dWord is a Displacement from Top of File,
  to the IMAGE_ARCHIVE_MEMBER_HEADER of the .Obj File concerned with the
  matching Name found in the next "Symbols Table" String):
;;
;;
    Push esi
        Mov esi AmountOfOffsets1 | While B$esi <> 0 | movsb | End_While
    Pop esi

    Mov ecx D$NumberOfSymbols

L0: lodsd
    Push esi
    ; Eax: Displacement to the SymOffset array Data. If it is 0, jmp over.
        ..If eax = 0
            Mov esi {B$ '&NULL ; Null Pointer. Does not point to any Object in this file.' EOS}

        ..Else
            Mov esi D$LibFileMemory | bswap eax | add esi eax

            .If B$esi = '/'
L1:             Push ecx
                    Call GetLongNamesPointer
                    Call CopyCoffIndice | inc esi
                    If D$LongNamesBase <> 0
                       ;                     Mov esi D$LongNamesBase
                        Call CheckLongNameDisplacement | On eax = &FALSE, jmp L1>
                        Call WriteLongName esi
                    Else
L1:                     Call CopySymbolName
                    End_If
                Pop ecx

            .Else
                Call CopyCoffIndice | Call CopySymbolName

            .End_If

            Mov esi IMAGE_ARCHIVE_MEMBER_HEADERstring

        ..End_If

        While B$esi <> 0 | movsb | End_While
    Pop esi
    Mov W$edi CRLF, B$edi+2 SPC | add edi 3 | dec ecx | jnz L0<<
ret


CopySymbolName:
  ; Copy the ARCHIVE_MEMBER_HEADER Name:
  Push ecx
  Mov ecx 1 ; It is used as a counter. Starting with 1 (The 1st byte)


    Push esi
        Mov esi {B$ 'Short Name: ' EOS}
        While B$esi <> 0 | movsb | End_While
    Pop esi

    Push esi

    While B$esi > SPC
        movsb
            ; Short Names always ends with an "/ ". Or sometimes with an "/"
            If W$esi+1 = '/ '
                movsW
                jmp L2>
            Else_If ecx = 16; Did we reached the 16th byte ? ON that case we may still have "/" as the last char
                jmp L2>
            End_If
        inc ecx
    End_While


L2:     On B$edi-1 = '/', dec edi ; Clean Up the last "/" char

    Pop esi

    ; We need to retrieve the Function Name in case for the Import Header (The non common Coff format)
    ; To avoid inserting the ".directive" strings etc. We need only the real function name for this type
    ; of structure.

    ..If W$esi+58+2 = &IMAGE_FILE_MACHINE_UNKNOWN
        .If W$esi+58+2+2 = &IMPORT_OBJECT_HDR_SIG2

            Push esi
                Mov esi {B$ ' Function Name: ' EOS}
                While B$esi <> 0 | movsb | End_While
            Pop esi

            lea esi D$esi+60+20
            On B$esi = '/', inc esi
            While B$esi > '/' | LookUpValidNameChars | End_While

        .End_If
    ..End_If

   ; If this is a common Coff Format, we compute the Function name it follows it here
    Pop ecx
ret


CopyObjSymbolName:
  ; Copy the ARCHIVE_MEMBER_HEADER Name:
  Push ecx
  Mov ecx 1 ; It is used as a counter. Starting with 1 (The 1st byte)

    Push esi
        Mov esi {B$ 'Short Name: ' EOS}
        While B$esi <> 0 | movsb | End_While
    Pop esi

    Push esi

    While B$esi > SPC
        movsb
            ; Short Names always ends with an "/ ". Or sometimes with an "/"
            If W$esi+1 = '/ '
                movsW
                jmp L2>
            Else_If ecx = 16; Did we reached the 16th byte ? ON that case we may still have "/" as the last char
                jmp L2>
            End_If
        inc ecx
    End_While


L2:     On B$edi-1 = '/', dec edi ; Clean Up the last "/" char

    Pop esi
    Mov D$ExportedLibrary 0
    ; We need to retrieve the Function Name in case for the Import Header (The non common Coff format)
    ; To avoid inserting the ".directive" strings etc. We need only the real function name for this type
    ; of structure.

    ..If W$esi+58+2 = &IMAGE_FILE_MACHINE_UNKNOWN
        .If W$esi+58+2+2 = &IMPORT_OBJECT_HDR_SIG2

        Mov D$ExportedLibrary edi

        Push esi
            Mov esi {B$ ' Function Name: ' EOS}
            While B$esi <> 0 | movsb | End_While
        Pop esi

        lea esi D$esi+60+20
        While B$esi >= SPC | LookUpValidNameChars | End_While

        .End_If

    ..End_If

   ; If this is a common Coff Format, we compute the Function Name it follows it here
    Pop ecx

ret
____________________________________________________________________________________________

[StringsArrayComments1: "]

; Array of null terminated strings that are the name of
;the Symbols List (The value of the array is defined by PublicSymbols member).

[Symname1:
 " EOS]

[Symname1.Data: B$   "Symname1.Data"
 SymName1Counter: "000001: B$   '" EOS]

ShowSymbolsTable1:
;;
;;

  Show the Symbols Table, that is a simple zero-ended string array. Each String
  is a Symbol used, in order, by the .Obj File, which the IMAGE_ARCHIVE_MEMBER_HEADER
  is pointed to, by the above Offset Table:
;;
;;
    Push esi
        Mov esi StringsArrayComments1
        While B$esi <> 0 | movsb | End_While
    Pop esi

    Mov D$SymName1Counter '0000', W$SymName1Counter+4 '01', ecx D$NumberOfSymbols

L0: Push esi
        Mov esi Symname1.Data
        While B$esi <> 0 | movsb | End_While
    Pop esi
    While B$esi <> 0 | LookUpValidNameChars | End_While | inc esi
    Mov D$edi "', 0", W$edi+4 CRLF, B$edi+6 SPC | add edi 7
    lea ebx D$SymName1Counter+5
    inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx
        inc B$ebx
    End_While
    loop L0<
    sub edi 3
    Mov B$edi ']', D$edi+1 CRLF2 | add edi 5
ret
____________________________________________________________________________________________

WriteHeaderMember1:
    Call ShowAmountOfSymbols1
    If D$NumberOfSymbols > 0
        Call ShowOffsetTable1
        Call ShowSymbolsTable1
    End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
;;
;;

                              Write the Second Library Header
;;
;;
____________________________________________________________________________________________

[SecondLibHeaderComment: ";;
_____________________________________________________

    Secondary Linker Header - Names Linker Member
_____________________________________________________
_____________________________________________________
;;
;;
; This is the IMAGE_ARCHIVE_MEMBER_HEADER Structure.

" EOS]
____________________________________________________________________________________________

WriteSecondLibHeaderComment:
    Push esi
        Mov esi SecondLibHeaderComment
        While B$esi <> 0 | movsb | End_While
    Pop esi
ret
____________________________________________________________________________________________

[AmountOfSymbols2: "; Total amount of Objects files.

[PublicSymbols2: D$ " EOS]

ShowAmountOfSymbols2:
;;
;;
  Show the Amount of Symbols (a dWord stored the other way round):
;;
;;
    Push esi
        Mov esi AmountOfSymbols2 | While B$esi <> 0 | movsb | End_While
    Pop esi
    lodsd | Mov D$NumberOfSymbols eax | Call WriteEax

    Mov B$edi ']', D$edi+1 CRLF2 | add edi 5
ret
____________________________________________________________________________________________

[AmountOfOffsets2: "; Amount of Offsets of the Object Files Found.

[SymOffset2:
 " EOS]

ShowOffsetTable2:  ; 'ShowOffsetTable1'
;;

;;
  Show the Offset Table (where each dWord is a Displacement from Top of File,
  to the IMAGE_ARCHIVE_MEMBER_HEADER of the .Obj File concerned with the
  matching Name found in the next "Symbols Table" String):
;;
;;
    Push esi
        Mov esi AmountOfOffsets2 | While B$esi <> 0 | movsb | End_While
    Pop esi

    Mov ecx D$NumberOfSymbols

L0: lodsd
    Push esi
  ; Eax: Displacement to the SymOffset array Data. If it is 0, jmp over.

        ..If eax = 0
            Mov esi {B$ '&NULL ; Null Pointer. Does not point to any Object in this file.' EOS}

        ..Else
            Mov esi D$LibFileMemory | add esi eax
            .If B$esi = '/'
                Call GetLongNamesPointer
                Call CopyCoffIndice | inc esi
                If D$LongNamesBase <> 0
                    Call CheckLongNameDisplacement | On eax = &FALSE, jmp L1>
                    Call WriteLongName esi
                Else
L1:                 Call CopySymbolName
                End_If

            .Else
                Call CopyCoffIndice | Call CopySymbolName

            .End_If

            Mov esi IMAGE_ARCHIVE_MEMBER_HEADERstring

        ..End_If

        While B$esi <> 0 | movsb | End_While

    Pop esi
    Mov W$edi CRLF, B$edi+2 SPC | add edi 3 | dec ecx | jnz L0<< ;loop L0<
    Mov B$edi ']', D$edi+1 CRLF2 | add edi 5
ret
____________________________________________________________________________________________

[AmountOfSymbols3: "; Amount of Public Symbols on the file.

[PublicSymbols3: D$ " EOS]

ShowAmountOfSymbols2Bis:
;;
;;
  Show the Amount of Members (a dWord stored the other way round), for Second Header:
;;
;;
    Push esi
        Mov esi AmountOfSymbols3 | While B$esi <> 0 | movsb | End_While
    Pop esi
    lodsd | Mov D$NumberOfSymbols eax | Call WriteEax

    Mov B$edi ']', D$edi+1 CRLF2 | add edi 5
ret
____________________________________________________________________________________________

[IndexString2: "; Array of the Word data, representing the Index of the exported functions of the Symbols List.
; It points to the object files inside the lib.
; (The amount of the elements in the array is defined by the PublicSymbols2 member)

[SymIndex:
 " EOS]

[SymIndex2.Data: "SymIndex.Data"
 SymIndex2Counter: "000001:  W$    " EOS]


ShowIndexTable2:
;;
;;

  Flow of reversed Words. They are indexes to point out what String goes with what Obj File:
;;
;;
    Push esi
        Mov esi IndexString2 | While B$esi <> 0 | movsb | End_While
    Pop esi

    Mov ecx D$NumberOfSymbols, D$SymIndex2Counter '0000', W$SymIndex2Counter+4 '01'

L0: Push esi
        Mov esi SymIndex2.Data
        While B$esi <> 0 | movsb | End_While
    Pop esi
  ; This one is not reversed:
    lodsw | and eax 0FFFF | Call WriteEax



    lea ebx D$SymIndex2Counter+5
    inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx
        inc B$ebx
    End_While

    Mov W$edi CRLF, B$edi+2 SPC | add edi 3 | loop L0<

    sub edi 3
ret
____________________________________________________________________________________________

[StringsArrayComments2: "]

; Array of null terminated strings that are the name of
;the Symbols List (The value of the array is defined by PublicSymbols member).

[Symname2:
 " EOS]

[Symname2.Data: B$   "Symname2.Data"
 SymName2Counter: "000001: B$   '" EOS]

ShowSymbolsTable2:
;;
;;

  Show the Symbols Table, that is a simple zero-ended string array. Each String
  is a Symbol used, in order, by the .Obj File, which the IMAGE_ARCHIVE_MEMBER_HEADER
  is pointed to, by the above Offset Table:

;;
;;
    Push esi
        Mov esi StringsArrayComments2
        While B$esi <> 0 | movsb | End_While
    Pop esi

    Mov D$SymName2Counter '0000', W$SymName2Counter+4 '01', ecx D$NumberOfSymbols

L0: Push esi
        Mov esi Symname2.Data
        While B$esi <> 0 | movsb | End_While
    Pop esi
    While B$esi <> 0 | LookUpValidNameChars | End_While | inc esi
    Mov D$edi "', 0", W$edi+4 CRLF, B$edi+6 SPC | add edi 7
    lea ebx D$SymName2Counter+5
    inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx
        inc B$ebx
    End_While
    loop L0<
    sub edi 3
    Mov B$edi ']', D$edi+1 CRLF2 | add edi 5
ret
____________________________________________________________________________________________

WriteHeaderMember2:
    Call ShowAmountOfSymbols2
    On D$NumberOfSymbols > 0, Call ShowOffsetTable2
    Call ShowAmountOfSymbols2Bis
    If D$NumberOfSymbols > 0
        Call ShowIndexTable2
        Call ShowSymbolsTable2
    End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
;;
;;
   Write the third Library Header
;;
;;
____________________________________________________________________________________________


[ThirdLibHeaderComment: ";;
_____________________________________________________

    Tertiary Linker Header - Names Linker Member
_____________________________________________________
_____________________________________________________
;;
;;
; This is the IMAGE_ARCHIVE_MEMBER_HEADER Structure.

" EOS]
____________________________________________________________________________________________

WriteThirdLibHeaderComment:
    Push esi
        Mov esi ThirdLibHeaderComment
        While B$esi <> 0 | movsb | End_While
    Pop esi
ret
____________________________________________________________________________________________

[LongNamesTableComment3:
"; Amount of Null Terminated String related to the Objects with LongNames.

[" EOS]

[LongObjectNames: "LongObjectNames.data"

LongObjectNamesCounter: "000001: B$ '" EOS]
____________________________________________________________________________________________

WriteLongNameTableComment3:
    Mov D$LongObjectNamesCounter '0000', W$LongObjectNamesCounter+4 '01'

    Push esi
        Mov esi LongNamesTableComment3
        While B$esi <> 0 | movsb | End_While
    Pop esi
ret

ShowLongNamesTable3:
    Mov edx esi | add edx D$MemberSize

    ..While esi < edx
        Push esi
            Mov esi LongObjectNames
            While B$esi <> 0 | movsb | End_While

            lea ebx D$LongObjectNamesCounter+5
            inc B$ebx
            While B$ebx > '9'
                Mov B$ebx '0' | dec ebx | inc B$ebx
            End_While
        Pop esi

        While B$esi >= SPC | LookUpValidNameChars | End_While | inc esi
        While B$esi < SPC | inc esi | End_While
        Mov D$edi "', 0", W$edi+4 CRLF | add edi 6
    ..End_While

    sub edi 2 | Mov B$edi ']', D$edi+1 CRLF2 | add edi 5
ret


WriteHeaderMember3:
    If D$MemberSize > 0
        Call WriteLongNameTableComment3
        Call ShowLongNamesTable3
    End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; Coff

[CoffComment: ";;
_____________________________________________________

Coff File Headers:
_____________________________________________________
_____________________________________________________
;;
;;
" EOS]

____________________________________________________________________________________________
____________________________________________________________________________________________
____________________________________________________________________________________________
____________________________________________________________________________________________
____________________________________________________________________________________________
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
;;
                                      Lib jobs
;;
;;
[LibSymbolsMap: D$ ?]

[SymbolsNumber: D$ ?
 CoffIndice: D$ ?]

GetLibCode:
    Mov D$SymbolsNumber 0, D$LibNumberOfBytes 0
    Call GetLibSymbolsNumber | On D$SymbolsNumber = 0, jmp L9>>

    Call CreateLibBuffers
    Move D$LibDisassemblyPtr D$LibDisassembly, D$LibBytesCopyPtr D$LibBytesCopy
    Mov D$CoffIndice 0

L0: Call GetCoffBase D$CoffIndice
    .If W$esi <> 0-1
        If W$esi+2 <> 0-1
            Call ScanCoff
        End_If
    .End_If
    inc D$CoffIndice | Mov eax D$CoffIndice | cmp eax D$SymbolsNumber | jb L0<<

    Call DecodeLib
L9: ret


GetLibSymbolsNumber:
    Mov esi D$LibFileMemory

  ; Number of SYMBOLs in ecx:
    Mov eax D$esi+COFF_HEADER_SIZE+ARCH_TAG | bswap eax
    Mov D$SymbolsNumber eax
ret

; esi point to Coff Base (014C):

[CoffHeaderBase: D$ ?]

[LibNumberOfBytes: D$ ?]

ScanCoff:
    ..If W$esi <> 0-1 ; 'PeHeader'
        Mov W$esi 0-1
        Mov D$CoffHeaderBase esi
      ; Number of Coff Sections in ecx:
        movzx ecx W$esi+2
        add esi 014 ; COFF_HEADER_SIZE ; example: '.text'

L0:     and D$esi+SECTION_FLAG &IMAGE_SCN_CNT_CODE

        .If D$esi+SECTION_FLAG = &IMAGE_SCN_CNT_CODE
            Push ecx, esi
                Mov ecx D$esi+SECTION_FILESIZE, esi D$esi+SECTION_FILEPOINTER

                If ecx <> 0
                    add esi D$CoffHeaderBase
                    Mov edi D$LibBytesCopyPtr
                    Mov D$edi ecx | add edi 4
                    add D$LibNumberOfBytes ecx
                    rep movsb
                    Mov D$LibBytesCopyPtr edi
                End_If
            Pop esi, ecx
        .End_If

        add esi SECTIONHEADERSIZE | loop L0<
    ..End_If
ret
;;
;;
B$ '.text' EOS, 0, 0
AppTrueCodeSize: D$   0     ; true size of code in file
AppCodeRVAoffset: D$   0    ; RVA offset (aligned on 01000 boundary)
AppFileSizeOfCode: D$   0   ; file aligned size of code (0200 aligned)
AppStartOfCode: D$   00     ; pointer to code (true first code in file - not entry point-)
D$   00                     ; dummy reloc ptr
D$   00                     ; dummy line number ptr
W$   00                     ; dummy reloc number
W$   00                     ; dummy number of line number
CodeCharacteristics:
D$   0_60000020             ; characteristics (readable, runable, code)
;;
;;
[LibBytesCopy: D$ ?
 LibBytesCopyPtr: D$ ?
 LibDisassembly: D$ ?
 LibDisassemblyPtr: D$ ?]

CreateLibBuffers:

    Call VirtualAlloc LibBytesCopy,
                      D$LibFileLength

  ; VirtualAlloc LibSymbolsMap, D$LibFileLength

    Mov ecx D$LibFileLength | shl ecx 5

    Call VirtualAlloc LibDisassembly,
                      ecx

    Move D$LibDisassemblyPtr D$LibDisassembly

    add D$LibDisassembly 4

ret


Proc GetCoffBase:
    Argument @Indice

        Mov esi D$LibFileMemory, eax D@Indice
        Mov esi D$esi+eax*4+COFF_HEADER_SIZE+ARCH_TAG+4
        bswap esi | add esi D$LibFileMemory

      ; esi now points to a COFF Object:
        add esi COFF_HEADER_SIZE

      ; esi now point, typically, to 014C
EndP



Proc SetStringPointer:
    Arguments @Base, @Offset, @String
    Uses edi
      ; Write the Pointer to String directly on the Code "0, 0, 0, 0":
        Mov edi D@Base
        add edi D$esi+SECTION_FILEPOINTER
        add edi D@Offset
        Move D$edi D@String
EndP

____________________________________________________________________________________________



__________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________
;;
;;

----------------------------------------------------------------------
        Data used to build the Main dialog and Tab controls.
----------------------------------------------------------------------
----------------------------------------------------------------------

;;

__________________________________________________________________________________________________________________

;;
Proc WriteSectionHeaderSymbolConstantIndex:
    uses eax, ecx, ebx, esi

    Call InitSymbolIndexRecord
    Call WriteObjIndice

    ; Fix the label to show in Caps and replace the '." with an "_"
    ; The 1st char in "Obj000000." is in Caps, so we don't need to overwrite the "O" char

    Push edi
    Mov B$edi-1 '_', W$edi-9 'BJ'
    Pop edi

    Push esi
    zCopy {B$ 'SYMBOLINDEX' EOS}
    Pop esi

    Mov ecx D$esi

    ; Note to René: Replacing this with a hex to decimal ascii string is better,
    ; but i couldn't make it be on the same style as SymbolTableIndex

    While ecx <> 0
        Call IncrementSymbolIndexRecord
        dec ecx
    End_While

    zCopy SymbolTableIndex

    ; restore the SymbolTableIndex
    Call InitSymbolIndexRecord

EndP
;;

;;
; LV_ITEM Structure

[buffer2: B$ ? # &MAX_PATH]

[lvi:
 lvi.imask: D$ &LVIF_TEXT
 lvi.iItem: D$ 0
 lvi.iSubItem: D$ 0
 lvi.state: D$ &LVIS_FOCUSED
 lvi.stateMask: D$ 0
 lvi.pszText: D$ buffer2
 lvi.cchTextMax: D$ &MAX_PATH
 lvi.iImage: D$ 0
 lvi.lParam: D$ 0
 lvi.iIndent: D$ 0]

;&LVCF_ORDER

[LvOffsetCOFF: D$ 0]
;GetCoffIMAGE_FILE_HEADER

[DecimalBuffer: B$ ? # 16];B$ 020 #10 0]
[HexaDecimalBuffer: B$ ? # 16]

[ObjSymbolsNumber: D$ ?]

[CoffMachineType: D$ ?]

[ObjFileNameType: D$ ?]


; The decimal and hexadecimal convertion routines comes from MouseHintDrawWindow

Proc AddListviewItem:
    Arguments @h2List
    pushad


    ; Calculate and Display Index Value
    Mov edi buffer2
    Mov esi LibObjIndice
    While B$esi <> 0 | movsb | End_While

    sub edi 6
    Mov D$lvi.pszText edi
    Mov D$lvi.iSubItem, 0
    Call 'USER32.SendMessageA', D@h2list, &LVM_INSERTITEM, 0, lvi

    ; Calculate and Display FileName

    Move D$lvi.pszText ObjectName
    inc D$lvi.iSubItem
    Call 'USER32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ; Calculate and Display Extension

    If D$UseObjExtension = 0
        Mov D$lvi.pszText {B$ "No extension" EOS}
    Else
        Move D$lvi.pszText ObjExtensionStr
    End_If
    inc D$lvi.iSubItem
    Call 'USER32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi


    ; Display File Name Type
    ; Definition of values in Write_Obj_IMAGE_ARCHIVE_MEMBER_HEADER

    If D$ObjFileNameType = 1
        Mov D$lvi.pszText {B$ "Long Name" EOS}
    Else
        Mov D$lvi.pszText {B$ "Short Name" EOS}
    End_If
    inc D$lvi.iSubItem
    Call 'USER32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi


    ; Display the Path of the Object file
    If D$UseObjPath = 0
        Mov D$lvi.pszText {B$ "Not used" EOS}
    Else
        Mov D$lvi.pszText ObjPathStr
    End_If

    inc D$lvi.iSubItem
    Call 'USER32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

   ; Calculate and Display Offset (Convert hexa dword to string)

    Mov edi HexaDecimalBuffer
    DwordToHex D$LvOffsetCOFF
    Mov B$edi 0

    Move D$lvi.pszText HexaDecimalBuffer
    inc D$lvi.iSubItem
    Call 'USER32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ; Calculate and Display Size (Convert Hexa do Decimal String)

    Mov esi MemberSize, ecx 4
    Call toUDword
    Mov esi edi, edi DecimalBuffer
    Do | movsb | LoopUntil B$esi-1 = 0

    Move D$lvi.pszText DecimalBuffer
    inc D$lvi.iSubItem
    Call 'USER32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ; Display Object Type
    If D$ExportedLibrary = 0
        Mov D$lvi.pszText {B$ "Runtime Object" EOS}
    Else
        Mov D$lvi.pszText {B$ "Exported Object" EOS}
    End_If

    inc D$lvi.iSubItem
    Call 'USER32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ; Display Function Name used in Exported Library
    If D$ExportedLibrary = 0
        Mov D$lvi.pszText {B$ "Not used" EOS}
    Else
        Move D$lvi.pszText ExportedLibraryStr
    End_If

    inc D$lvi.iSubItem
    Call 'USER32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi


    ; Display the Machine Type

    Mov D$buffer2 edi ; eax holds the address of the initial Equate String

    Call Write_IMAGE_FILE_MACHINE D$CoffMachineType
    Mov B$edi 0 ; Fix the end of edi in all cases. Force Null Terminated String
    Mov eax D$buffer2

    If B$eax = '&'
        inc D$buffer2
        Move D$lvi.pszText D$buffer2
    Else
        Mov D$lvi.pszText {B$ "Unknown or Corrupted Machine Type" EOS}
    End_If
    inc D$lvi.iSubItem
    Call 'USER32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ;  Calculate and Display Number of Sections (Convert Hexa do Decimal String)

    .If D$ExportedLibrary = 0
        Mov esi ObjNumberOfSections, ecx 4
        Call toUDword
        Mov esi edi, edi DecimalBuffer
        Do | movsb | LoopUntil B$esi-1 = 0

        Mov D$lvi.pszText DecimalBuffer
    .Else
        Mov D$lvi.pszText {B$ "No Sections" EOS}
    .End_If

    inc D$lvi.iSubItem
    Call 'USER32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ; Display Time and Date Stamp
    ; This came from WriteImportObjHdrTimeDateStamp
    ;TimeDateStringtoDword
    Call Concatenation szDateString, szTimeString, buffer2
    Move D$lvi.pszText buffer2
    inc D$lvi.iSubItem
    Call 'USER32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi


    ;  Calculate and Display Number of Symbols (Convert Hexa do Decimal String) CoffSymbolsNumber
    .If D$ExportedLibrary = 0
        Mov esi ObjSymbolsNumber, ecx 4
        Call toUDword
        Mov esi edi, edi DecimalBuffer
        Do | movsb | Loop_Until B$esi-1 = 0

        Mov D$lvi.pszText DecimalBuffer
    .Else
        Mov D$lvi.pszText {B$ "No Symbols" EOS}
    .End_If

    inc D$lvi.iSubItem
    Call 'USER32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ; Show Optional Header Options (False if it don't use Optional Header, True otherwise)

    If D$SizeOfOptionalHeaderInObj = 0
        Mov D$lvi.pszText {B$ "False" EOS}
    Else
        Mov D$lvi.pszText {B$ "True" EOS}
    End_If
    inc D$lvi.iSubItem
    Call 'USER32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ; Clear the Buffer before exit

    Mov ecx &MAX_PATH
    Mov edi 0
    L0:
        Mov B$buffer2+edi 0
        inc edi
    Loop L0<

    popad

EndP


___________________________________________

; Used Macros


; Amount of Columns of the ListView
[Lib_LVTotalCol 14]

; String Data

[Header1: B$ 'Index' EOS]
[Header2: B$ 'File Name' EOS]
[Header3: B$ 'Extension' EOS]
[Header4: B$ 'FileName Type' EOS]
[Header5: B$ 'Path' EOS]
[Header6: B$ 'Offset' EOS]
[Header7: B$ 'Size' EOS]
[Header8: B$ 'Object Type' EOS]
[Header9: B$ 'Exported Function' EOS]
[Header10: B$ 'Machine Type' EOS]
[Header11: B$ 'Sections' EOS]
[Header12: B$ 'Time and Date' EOS]
[Header13: B$ 'Symbols' EOS]
[Header14: B$ 'Optional Header' EOS]

; Our used Constants to identify what field is what
[LVIEW_INDEX 0]
[LVIEW_FILENAME 01]
[LVIEW_EXTENSION 02]
[LVIEW_NAMETYPE 03]
[LVIEW_PATH 04]
[LVIEW_OFFSET 05]
[LVIEW_SIZE 06]
[LVIEW_OBJTYPE 07]
[LVIEW_EXPORTEDFUNCTION 08]
[LVIEW_MACHINE 09]
[LVIEW_SECTION 10]
[LVIEW_TIME 11]
[LVIEW_SYMBOL 12]
[LVIEW_OPTIONAL 13]

[H.Header: D$ ?]
[H.List: D$ ?]

; LV_COLUMN Structure

[lvc:
 lvc.imask: D$ 0
 lvc.fmt: D$ &LVCFMT_LEFT
 lvc.lx: D$ 80  ; columnwidth
 lvc.pszText: D$ 0
 lvc.cchTextMax: D$ 0
 lvc.iSubItem: D$ 0
 lvc.iImage: D$ 0
 lvc.iOrder: D$ 0]

Proc SetupListview:
    Arguments @h2List

    ; /*Listview setup */
    Mov D$lvc.imask, &LVCF_TEXT+&LVCF_WIDTH
    Mov D$lvc.pszText, Header1
    Call 'USER32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_INDEX, lvc
    or D$lvc.imask, &LVCF_FMT
    Mov D$lvc.pszText, Header2
    Call 'USER32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_FILENAME, lvc
    or D$lvc.imask, &LVCF_FMT
    Mov D$lvc.pszText, Header3
    Call 'USER32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_EXTENSION, lvc
    or D$lvc.imask, &LVCF_FMT
    Mov D$lvc.pszText, Header4
    Call 'USER32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_NAMETYPE, lvc
    or D$lvc.imask, &LVCF_FMT
    Mov D$lvc.pszText, Header5
    Call 'USER32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_PATH, lvc
    or D$lvc.imask, &LVCF_FMT
    Mov D$lvc.pszText, Header6
    Call 'USER32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_OFFSET, lvc
    or D$lvc.imask, &LVCF_FMT
    Mov D$lvc.pszText, Header7
    Call 'USER32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_SIZE, lvc
    or D$lvc.imask, &LVCF_FMT
    Mov D$lvc.pszText, Header8
    Call 'USER32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_OBJTYPE, lvc
    or D$lvc.imask, &LVCF_FMT
    Mov D$lvc.pszText, Header9
    Call 'USER32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_EXPORTEDFUNCTION, lvc
    or D$lvc.imask, &LVCF_FMT
    Mov D$lvc.pszText, Header10
    Call 'USER32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_MACHINE, lvc
    or D$lvc.imask, &LVCF_FMT
    Mov D$lvc.pszText, Header11
    Call 'USER32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_SECTION, lvc
    or D$lvc.imask, &LVCF_FMT
    Mov D$lvc.pszText, Header12
    Call 'USER32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_TIME, lvc
    or D$lvc.imask, &LVCF_FMT
    Mov D$lvc.pszText, Header13
    Call 'USER32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_SYMBOL, lvc
    or D$lvc.imask, &LVCF_FMT
    Mov D$lvc.pszText, Header14
    Call 'USER32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_OPTIONAL, lvc

    ;/* these 5 lines create a FLAT columnheader */
    Call 'USER32.SendMessageA', D@h2List, &LVM_GETHEADER__&LVM_ENSUREVISIBLE__&LVM_SETCOLUMNORDERARRAY, 0, 0 ;// get handle to header;&LVM_GETHEADER, 0, 0 ;// get handle to header
    Mov D$H.Header, eax ;// preserve header handle
    Call 'USER32.GetWindowLongA', D$H.Header, &GWL_STYLE ;// get current window styles
    xor eax, &HDS_BUTTONS
    Call 'USER32.SetWindowLongA', D$H.Header, &GWL_STYLE, eax ;// set the new header styles

    ;/* Setup extended styles like gridlines, back-foregroundcolors */
    Call 'USER32.SendMessageA', D@h2List, &LVM_SETEXTENDEDLISTVIEWSTYLE, 0, &LVS_EX_FULLROWSELECT__&LVS_EX_HEADERDRAGDROP__&LVS_EX_SUBITEMIMAGES__&LVS_EX_GRIDLINES__&LVS_EX_FLATSB
    Call 'USER32.SendMessageA', D@h2List, &LVM_SETTEXTCOLOR, 0, {RGB 0_BA 0_30 0_26 0_00}
    Call 'USER32.SendMessageA', D@h2List, &LVM_SETBKCOLOR, 0, {RGB 0_FF 0_FF 0FF 0_00}
    Call 'USER32.SendMessageA', D@h2List, &LVM_SETTEXTBKCOLOR, 0, {RGB 0_F0 0_F7 0_A6 0_00}

EndP

___________________________________________________________________________________________________________

; ----------------------------------------------
; 2nd Dialog Tab Frame Procedure
; This is to show the Object Listing
; ----------------------------------------------


Proc Tab2Proc:
    Arguments @hWin, @uMsg, @wParam, @lParam

    pushad

    If D@uMsg = &WM_INITDIALOG
        Call 'USER32.SendMessageW' D@lParam, &EM_SETSEL, 0-1, 0
        Call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | ExitP
    Else_If D@uMsg = &WM_NOTIFY
        Call LibScanDialog_OnNotify D@hWin, D@lParam
    Else_If D@uMsg = &WM_CTLCOLOREDIT
        Call 'GDI32.SetBkColor' D@wParam, D$DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | ExitP
    Else
        popad | Mov eax &FALSE | ExitP
    End_If

    popad | Mov eax &TRUE
EndP


; ----------------------------------------------
; 1st Dialog Tab Frame Procedure
; This is where the MZ Header dialog is used
; ----------------------------------------------


Proc Tab1Proc:
    Arguments @hWin, @uMsg, @wParam, @lParam

    pushad

    .If D@uMsg = &WM_INITDIALOG
        Call 'USER32.SendMessageW' D@lParam, &EM_SETSEL, 0-1, 0
        Call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | ExitP
    .Else_If D@uMsg = &WM_NOTIFY
        Call LibScanDialog_OnNotify D@hWin, D@lParam
    .Else_If D@uMsg = &WM_CTLCOLOREDIT
        Call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | ExitP
    .Else
        popad | Mov eax &FALSE | ExitP
    .End_If

    popad | Mov eax &TRUE
EndP




______________________________________________________________________________________________

; constants for the library dialogs

; Dialog Controls

[IDD_MAINLIB 20] ; Main Dialog where it will hold the tabs.

; Internal controls for this dialog

[IDC_LIBFILESIZE 4] ; The Edit Control where the path name is displayed
[IDC_OPENLIBFILE 5] ; The Edit Control where the path name is displayed
[IDC_TABCTRL 38]  ; Main Tab Control Resource.
[IDC_LOADLIB 3]     ; The "Open" Button.

[IDD_TAB1 21] ; Id of the 1st Dialog "Library Structure"

; Internal controls for this dialog

[IDC_LIB_TARGET 11] ; 1 59 199 188 . ES_MULTI ES_AUTOVS ES_AUTOH WS_VS WS_HSC WS_TAB WS_BO
[IDC_LIB_SOURCE 10] ; 202 57 178 188. ES_MULTI ES_AUTOVS WS_VS WS_BO


[IDD_TAB2 22]  ; Id of the 2nd Dialog "Object Listing"
; Internal controls for this dialog
[IDC_LVIEW 30] ; Id for the listview control

[IDD_TAB3 23] ; Id of the 3rd Dialog other Header
[IDD_TAB4 24] ; Id of the 4th Dialog Section Images


; Menu Equates

[M03_Menu  4000                  M03_Open  4001                  M03_Close  4002
 M03_Save_Report  4003           M03_Exit  4004                  M03_Single_Object_File  4005
 M03_Runtime_Objects_Only  4006  M03_Exported_Objects_Only  4007 M03_All_Object_Files  4008
 M03_Build_Dis_File  4009        M03_Next_Tab  4010              M03_Previous_Tab  4011
 M03_First_Tab  4012             M03_Last_Tab  4013              M03_Show_ToolBarText  4014
 M03_Hover_ToolBar  4015         M03_About  4016]

; Structures used

[NMHDR.hwndFromDis 0
 NMHDR.idFromDis 4
 NMHDR.codeDis 8]


[hInst: D$ ?]

[SortDecimal: D$ ?] ; Sort Buffer

[flag_TB_00: D$ ?]

; Tab Selection
[LibScanSelTabStruc 0]
[LibScanSelTabObj 1]
[LibScanSelTabDisasm 2]
[LibScanSelTabDisBuild 3]

[LibScanTab_ImageList: D$ ?]
; Tag Dialog 20

Proc ScanLibFile:
    Arguments @hwnd, @msg, @wParam, @lParam

     pushad

    ...If D@msg = &WM_COMMAND                  ; User action

        ..If_Or D@wParam = &IDCANCEL, D@wParam = M03_Exit  ; User clicks on upper right [X] or Exited through the menu
            Call LibScanCleanUp D@hwnd
            Call 'COMCTL32.ImageList_Destroy' D$LibScanDialog_ImageList
            Call 'COMCTL32.ImageList_Destroy' D$LibScanTab_ImageList
            Call 'USER32.EndDialog' D@hwnd 0
            Mov D$LibScanToolbarHandle 0
            Mov B$LibScanIsFileOpen &FALSE

        ..Else_If D@wParam = M03_Close
            Call LibScanCleanUp D@hwnd
            Mov B$LibScanIsFileOpen &FALSE
            Call LibScanDialog_EnableContinueMenu &FALSE
            jmp L5>>

        ..Else_If D@wParam = M03_Save_Report
            Call SaveLibFileAs D@hwnd, D$hLibReportEdit, D$hLibReportEditLength

        ..Else_If D@wParam = M03_Single_Object_File
            Call SaveOneObjectFile D@hwnd

        ..Else_If D@wParam = M03_Runtime_Objects_Only
            Call SaveAllObjectFile D@hwnd, EXPORT_RUNTIME_OBJECTS

        ..Else_If D@wParam = M03_Exported_Objects_Only
            Call SaveAllObjectFile D@hwnd, EXPORT_EXPORTED_OBJECTS

        ..Else_If D@wParam = M03_All_Object_Files
            Call SaveAllObjectFile D@hwnd, EXPORT_ALL_OBJECTS

        ..Else_If D@wParam = M03_Show_ToolBarText
            Call LibScanDialog_ToggleToolbarText D@hwnd

        ..Else_If D@wParam = M03_Hover_ToolBar
            Call LibScanDialog_HoverToolbarText D@hwnd

        ..Else_If D@wParam = M03_Next_Tab
            Call LibScanDialog_EnableContinuePrevTabMenu &TRUE
            Call 'USER32.SendMessageA' D$hTab &TCM_GETCURSEL 0 0
            .If eax <> LibScanSelTabDisBuild
                inc eax
                Call 'USER32.SendMessageA' D$hTab &TCM_SETCURSEL eax eax
                inc eax

                If eax <> D$SelTab
                    Push eax
                    Mov eax D$SelTab
                    Call 'USER32.ShowWindow' D$eax*4+H.TabDlg1 &SW_HIDE
                    Pop eax
                    Mov D$SelTab eax
                    Call 'USER32.ShowWindow' D$eax*4+H.TabDlg1 &SW_SHOWDEFAULT
                End_If
            .End_If

            If D$SelTab = LibScanSelTabDisBuild
                Call LibScanDialog_EnableContinueNextTabMenu &FALSE
            End_If

        ..Else_If D@wParam = M03_Previous_Tab

            Call 'USER32.SendMessageA' D$hTab &TCM_GETCURSEL 0 0
            .If eax <> LibScanSelTabStruc
                dec eax
                Call 'USER32.SendMessageA' D$hTab &TCM_SETCURSEL eax eax
                dec eax

                If eax <> D$SelTab
                    Push eax
                    Mov eax D$SelTab
                    Call 'USER32.ShowWindow' D$eax*4+H.TabDlg1 &SW_HIDE
                    Pop eax
                    Mov D$SelTab eax
                    Call 'USER32.ShowWindow' D$eax*4+H.TabDlg1 &SW_SHOWDEFAULT
                End_If
                Call LibScanDialog_EnableContinueNextTabMenu &TRUE
            .End_If

            If D$SelTab = LibScanSelTabStruc
                Call LibScanDialog_EnableContinuePrevTabMenu &FALSE
            End_If

        ..Else_If D@wParam = M03_First_Tab
L5:
                Call 'USER32.SendMessageA' D$hTab &TCM_SETCURSEL LibScanSelTabStruc LibScanSelTabStruc
                Mov eax LibScanSelTabStruc
                Mov D$SelTab LibScanSelTabObj

                If eax <> D$SelTab
                    Push eax
                    Mov eax D$SelTab
                    Call 'USER32.ShowWindow' D$eax*4+H.TabDlg1 &SW_HIDE
                    Pop eax
                    Mov D$SelTab eax
                    Call 'USER32.ShowWindow' D$eax*4+H.TabDlg1 &SW_SHOWDEFAULT
                End_If
                Call LibScanDialog_EnableContinueNextTabMenu &TRUE
                Call LibScanDialog_EnableContinuePrevTabMenu &FALSE

        ..Else_If D@wParam = M03_Last_Tab

                Call 'USER32.SendMessageA' D$hTab &TCM_SETCURSEL LibScanSelTabDisBuild LibScanSelTabDisBuild
                Mov ecx LibScanSelTabDisBuild
                Mov eax D$SelTab
                If eax = D$SelTab
                    Push eax
                    Mov eax D$SelTab
                    Call 'USER32.ShowWindow' D$eax*4+H.TabDlg1 &SW_HIDE
                    Pop eax
                    Mov eax LibScanSelTabDisBuild
                    Mov D$SelTab eax
                    Call 'USER32.ShowWindow' D$eax*4+H.TabDlg1 &SW_SHOWDEFAULT
                End_If
                Call LibScanDialog_EnableContinueNextTabMenu &FALSE
                Call LibScanDialog_EnableContinuePrevTabMenu &TRUE

        ..Else_If D@wParam = M03_Open

            Mov D$ChoosenLibFile 0
            Move D$OPENLIB@hwndOwner D@hwnd
            Move D$OPENLIB@hInstance D$H.Instance
            Move D$OPENLIB@lpstrFilter LibsFileFilter
            Call 'COMDLG32.GetOpenFileNameA' OPENLIB

            .If D$ChoosenLibFile <> 0
                Call LibScanCleanUp D@hwnd
                Call LibScanDialog_EnableContinueMenu &TRUE

                Call 'USER32.SendDlgItemMessageA' D@hwnd IDC_OPENLIBFILE &WM_SETTEXT 0 LibSaveFilter
                Call 'USER32.SendDlgItemMessageA' D@hwnd IDC_OPENLIBFILE &WM_GETTEXT 0 LibSaveFilter ; GET THE FILENAME

                ; The user is opening the file, Clean the list view.
                Call 'USER32.SendMessageA', D$H.List, &LVM_DELETEALLITEMS, 0, lvi

                Call OpenLibFile D@hwnd
                On D$LibFileLength = 0, jmp L9>> ; Exit when the file size is 0.

                Call LibSignatureCheck

                If D$ValidLib = UNKNOWN_LIB_FILE
                    ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
                    Call LibScanDialog_EnableContinueMenu &FALSE
                    Call 'USER32.DialogBoxParamA' D$H.Instance, IDD_LIBSCANWARNINGMSG, D@hwnd, LibScanWarning, &NULL
                    jmp L9>>
                End_If

                Call ParseIdentifiedLibs D@hwnd

                ; Below we can only remove after we build the parser for each one of these libraries.
                ; But we can leave this lines here, in the meanwhile
                If_Or D$ValidLib = DCU1_KILYX_OBJ_FILE, D$ValidLib = DCU2_KILYX_OBJ_FILE,
                      D$ValidLib = DCU3_KILYX_OBJ_FILE, D$ValidLib = DCU2_OBJ_FILE,
                      D$ValidLib = DCU3_OBJ_FILE, D$ValidLib = DCU4_OBJ_FILE,
                      D$ValidLib = DCU5_OBJ_FILE, D$ValidLib = DCU6_OBJ_FILE,
                      D$ValidLib = DCU7_OBJ_FILE, D$ValidLib = OMF_OBJ_FILE,
                      D$ValidLib = PDB_OBJ_FILE, D$ValidLib = DBG_OBJ_FILE
                    jmp L9>>
                End_If
            .End_If

            Call CoolControl_LVBeginSort ListViewLibSort, SortDecimal, D$H.List, 1
      ;  ..Else_If D@wParam = &IDHELP
      ;      Call Help, B_U_AsmName, DisassemblerHelp, ContextHlpMessage

        ..End_If


    ...Else_If D@msg = &WM_NOTIFY
        Call LibScanDialog_OnNotify D@hwnd, D@lParam

    ...Else_If D@msg = &WM_NCMOUSEMOVE
        ..If B$LibScanHoverTBText <> &MF_UNCHECKED
            .If D$flag_TB_00 = 0                    ;check flag toolbar
                Call 'USER32.ShowWindow' D$LibScanToolbarHandle &SW_SHOW
                Mov D$flag_TB_00 1                  ;set flag toolbar
            .End_If
        ..End_If
    ...Else_If D@msg = &WM_MOUSEMOVE
        ..If B$LibScanHoverTBText <> &MF_UNCHECKED
            .If D$flag_TB_00 = 1                    ;check flag toolbar
                Call 'USER32.ShowWindow' D$LibScanToolbarHandle &SW_HIDE
                Mov D$flag_TB_00 0                  ;set flag toolbar
            .End_If
        ..End_If

    ...Else_If D@msg = &WM_INITDIALOG

        Call 'USER32.GetMenu' D@hwnd | Mov D$LibScanMenuHandle eax

        ; Create the image list
        Call CoolControlTB_CreateImageList LibScanDialog_ImageList, IDB_LibScanEnableTB, IDB_LibScanDisableTB, 20, 20, &ILC_COLOR32+&ILC_MASK, LibScanToolButtonsNumber, LibScanToolButtonsNumber

        Call CoolControlTB_CreateImageList LibScanTab_ImageList, IDB_LibScanTABEnable, IDB_LibScanTABDisable, 20, 20, &ILC_COLOR32+&ILC_MASK, LibScanTabControlsNumber, LibScanTabControlsNumber

        ;Create the tabs
        Call CoolControlDlg_CreateTab D@hwnd, IDC_TABCTRL, hTab, LibScanTabControl

        ;Create the tab dialogs
        Call 'USER32.CreateDialogParamA' D$H.Instance IDD_TAB1 D$hTab Tab1Proc 0
        Mov D$H.TabDlg1 eax

        Call 'USER32.CreateDialogParamA' D$H.Instance IDD_TAB2 D$hTab Tab2Proc 0
        Mov D$H.TabDlg2 eax


        Call 'USER32.GetDlgItem' D$H.TabDlg2 IDC_LVIEW ; Get the ListView Control in the 2nd TAB resources, and
                                                    ; use it on the handle of the main window
        Mov D$H.List eax                              ; Now we return the result (found in eax), copying it to
                                                    ; the Handle of the Tab Control in the resource.
                                                    ; So, all we did was get the TAB Control and save it to the Tab handle.

        ; Create the toolbar
        Call CoolControlWin_CreateToolbar D@hwnd, LibScanToolbarHandle, LibScanToolbarButtons,
        LibScanToolButtonsNumber, LibScanToolTipsStrings, LSTBWin_Cmd

        ; Initialize the Menu state
        Call LibScanDialog_EnableContinueMenu &FALSE
        Call LibScanDialog_EnableContinuePrevTabMenu &FALSE

        ;/* Setup listview */
        Call SetupListview, D$H.List
        Call CoolControl_LVBeginSort ListViewLibSort, SortDecimal, D$H.List, 1
;;
;;
        Call 'USER32.CreateDialogParamA' D$H.Instance IDD_TAB3 D$hTab Tab3Proc 0
        Mov D$H.TabDlg3 eax
        Call 'USER32.CreateDialogParamA' D$H.Instance IDD_TAB4 D$hTab Tab4Proc 0
        Mov D$H.TabDlg4 eax
;;
;;

    ...Else_If D@msg = &WM_CLOSE
        Call LibScanCleanUp D@hwnd
        Call 'COMCTL32.ImageList_Destroy' D$LibScanDialog_ImageList
        Call 'COMCTL32.ImageList_Destroy' D$LibScanTab_ImageList
        Call 'USER32.EndDialog' D@hwnd &NULL
        Mov D$LibScanToolbarHandle 0
        Mov B$LibScanIsFileOpen &FALSE

    ...Else_If D@msg = &WM_CTLCOLOREDIT
        Call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | Mov eax D$H.DialogsBackGroundBrush | ExitP

    ...Else
        popad | Mov eax &FALSE | ExitP

    ...End_If

L9: popad | Mov eax &TRUE
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; This function handles all Notifications messages from all controls in the different Tabs
; It is mandatory to they be called inside each Tab Procedure (Tab1Proc, Tab2Proc ....)
; because we need they behave as a callback to handle the proper messages from each control Tab

Proc LibScanDialog_OnNotify:
    Arguments @hwnd, @Notification

    Mov ebx D@Notification
    Mov edx D$ebx+NMHDR.idFromDis
    Mov eax D$ebx+NMHDR.codeDis

    .If edx = IDC_TABCTRL
        If eax = &TCN_SELCHANGE
            Call CoolControlTabChange_OnNotify D@Notification, SelTab, D$hTab
        End_If

    .Else_If edx = IDC_LVIEW
        If eax = &LVN_COLUMNCLICK
            Call CoolControl_ListViewAlternateSort ListViewLibSort, D@Notification, SortDecimal, D$H.List, Lib_LVTotalCol
        Else_If eax = &NM_DBLCLK
            Call SaveOneObjectFile D@hwnd
        End_If

    .Else_If eax = &TTN_NEEDTEXT

        If_And edx >= D$LSTB01.idCommand, edx <= D$LSTB10.idCommand
            Call CoolControlTB_OnNotify D@hwnd, D@Notification, LibScanToolbarButtons, LibScanToolButtonsNumber, LibScanToolTipsStrings
        Else_If_And edx >= LibScanSelTabStruc, edx <= LibScanSelTabDisBuild
            Call CoolControlTabToolTip_OnNotify D@Notification, LibScanTabNumber, LibScanTabToolTipStrings
        End_If

    .End_If

EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc SaveOneObjectFile:
    Arguments @hwnd

    pushad

    Call 'USER32.SendMessageA' D$H.List, &LVM_GETNEXTITEM, 0-1, &LVNI_SELECTED
    If eax <> 0-1
        Call SaveSingleObjectFileAs D@hwnd, eax
    Else
        Call 'USER32.MessageBoxA' D@hwnd, {B$ "No field selected or empty fields.", D$ CRLF2, B$ "You must select one field in the ListControl to allow exporting the Selected Object file." EOS}, {B$ "Attention !" EOS}, &MB_ICONEXCLAMATION
    End_If

    popad
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________


[ObjSaveFileFilter: B$ 'Object File (*.obj)' EOS  '*.obj' EOS 0]
[ObjSaveFilter: D$ ? # &MAX_PATH]

Proc SaveSingleObjectFileAs:
    Arguments @hwnd, @SelectedItem
    pushad

    ; 1st we get the FileName

    Move D$lvi.iItem D@SelectedItem
    Mov D$lvi.iSubItem 1 ; [Header2: B$ 'File Name' EOS] ; string
    Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEM, D@SelectedItem, lvi
    ; the result is in szBuff0

    Mov edi ObjSaveFilter
    Push esi | ZCopy szBuff0 | Pop esi
    Mov B$edi 0

    Mov D$ChoosenLibFile 0
    Move D$SAVELIB.lpstrFile ObjSaveFilter
    Move D$SAVELIB.hwndOwner D@hwnd
    Move D$SAVELIB.hInstance D$H.Instance
    Move D$SAVELIB.lpstrFilter ObjSaveFileFilter
    Call 'Comdlg32.GetSaveFileNameA' SAVELIB

    ..If eax <> 0
        .If D$ChoosenLibFile <> 0
            Call ForceExtension ObjSaveFilter, '.obj'

            ; Get the Offset
            Move D$lvi.iItem D@SelectedItem
            Mov D$lvi.iSubItem 5 ; [Header6: B$ 'Offset' EOS] ; hexadecimal value string
            Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEM, D@SelectedItem, lvi
            Call AsciiBase szBuff0 BASE_HEX
            Mov edi eax

            ; Get the size
            Move D$lvi.iItem D@SelectedItem
            Mov D$lvi.iSubItem 6 ; [Header7: B$ 'Size' EOS] ; decimal value
            Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEM, D@SelectedItem, lvi
            Call String2Dword szBuff0

            Mov esi D$LibFileMemory
            add esi edi
            Call SaveLibFile, esi, eax, ObjSaveFilter
        .End_If
    ..End_If

    popad
EndP


____________________________________________________________________________________________
____________________________________________________________________________________________

[ObjPathTitle: B$ 'For the Exported Object Files' EOS]
[MultipleObjectPath: B$ ? # &MAX_PATH]

[EXPORT_ALL_OBJECTS 0]
[EXPORT_RUNTIME_OBJECTS 1]
[EXPORT_EXPORTED_OBJECTS 2]
; Flag = 0 (Save all Objects)
; Flag = 1 (Save all Runtime Objects)
; Flag = 2 (Save all Exported Objects)
Proc SaveAllObjectFile:
    Arguments @hwnd, @Flag
    Local @SelectedItem, @CountItens, @FolderPathStart, @RepeatedName

; More examples here MultipleCompileTests SaveSingleObjectFileAs
    pushad

    Call BrowseForFolder D@hwnd, ObjPathTitle
    ...If B$BrowseForFolderAborted <> &TRUE

        ; Initialize all revelant Data
        Mov D@RepeatedName 0
        Mov D@CountItens 0
        Mov D$RepeatedObjIndice '0000', D$RepeatedObjIndice+4 '00'
        ; 1st we calculate the amount of objectsinside the lib
        Call String2Dword LibObjIndice
        Mov D@CountItens eax

        Mov D@SelectedItem 0 ; always starts at the 1st item (that have the value of 0)
        Mov esi FolderPath, edi MultipleObjectPath
        While B$esi <> 0 | movsb | End_While | Mov B$edi '\' | inc edi
        Mov D@FolderPathStart edi

        .Do

            .If D@Flag = EXPORT_RUNTIME_OBJECTS
                Move D$lvi.iItem D@SelectedItem
                Mov D$lvi.iSubItem 7 ; [Header8: B$ 'Object Type' EOS] ; string
                Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEM, D@SelectedItem, lvi
                On D$szBuff0 <> 'Runt', jmp L1>> ; Not a runtime Object, jmp over it
            .Else_If D@Flag = EXPORT_EXPORTED_OBJECTS
                Move D$lvi.iItem D@SelectedItem
                Mov D$lvi.iSubItem 7 ; [Header8: B$ 'Object Type' EOS] ; string
                Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEM, D@SelectedItem, lvi
                On D$szBuff0 <> 'Expo', jmp L1>> ; Not a Export Object, jmp over it
            .End_If
            ; 1st we get the FileName

            Move D$lvi.iItem D@SelectedItem
            Mov D$lvi.iSubItem 1 ; [Header2: B$ 'File Name' EOS] ; string
            Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEM, D@SelectedItem, lvi

            ; Copy the filename to the path and append the '.obj' extension
            ; the result is in szBuff0
            Mov esi szBuff0
            While B$esi <> 0 | movsb | End_While
            Mov D$edi '.obj' | add edi 4 | Mov B$edi 0

            Call 'KERNEL32.FindFirstFileA' MultipleObjectPath, FindFile

            If eax <> &INVALID_HANDLE_VALUE ; do we have an existing file with this name ?
                ; Yes...append a new name for it
                Mov D$edi-4 '_New'
                Call IncrementObjExportNameIndex
                Mov esi RepeatedObjIndice
                While B$esi <> 0 | movsb | End_While
                Mov D$edi '.obj' | add edi 4 | Mov B$edi 0

            End_If

            ; Get the Offset
            Move D$lvi.iItem D@SelectedItem
            Mov D$lvi.iSubItem 5 ; [Header6: B$ 'Offset' EOS] ; hexadecimal value string
            Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEM, D@SelectedItem, lvi
            Call AsciiBase szBuff0 BASE_HEX
            Mov edi eax

            ; Get the size
            Move D$lvi.iItem D@SelectedItem
            Mov D$lvi.iSubItem 6 ; [Header7: B$ 'Size' EOS] ; decimal value
            Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEM, D@SelectedItem, lvi
            Call String2Dword szBuff0

            Mov esi D$LibFileMemory
            add esi edi
            Call SaveLibFile, esi, eax, MultipleObjectPath
L1:
            Mov edi D@FolderPathStart
            inc D@SelectedItem
            dec D@CountItens
        .Loop_Until D@CountItens = 0

    ...End_If
    popad
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[RepeatedObjIndice: B$ '000000' EOS]

IncrementObjExportNameIndex:
    lea ebx D$RepeatedObjIndice+5 | inc B$ebx
    While B$ebx > '9'
        Mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret

____________________________________________________________________________________________
____________________________________________________________________________________________



[LibSaveFileFilter: B$ 'Text File (*.txt)' EOS  '*.txt' EOS
                    B$ 'Assembly File (*.asm)' EOS  '*.asm' EOS
                    B$ 'All Files' EOS  '*.*' EOS 0]

[CustomLibFileFilter:  ? # &MAX_PATH]

[SaveLibFileTitle: B$ 'Save Library Structure report as...' EOS]

; OPENFILENAMEA Structure

[SAVELIB:
 SAVELIB.lStructSize: D$ Len
 SAVELIB.hwndOwner: D$ 0
 SAVELIB.hInstance: D$ 0
 SAVELIB.lpstrFilter: D$ LibSaveFileFilter
 SAVELIB.lpstrCustomFilter: D$ CustomLibFileFilter
 SAVELIB.nMaxCustFilter: D$ 260
 SAVELIB.nFilterIndex: D$ 1
 SAVELIB.lpstrFile: D$ LibSaveFilter
 SAVELIB.nMaxFile: D$ 260
 SAVELIB.lpstrFileTitle: D$ ChoosenLibFile
 SAVELIB.nMaxFileTitle: D$ 260
 SAVELIB.lpstrInitialDir: D$ 0
 SAVELIB.lpstrTitle: D$ SaveLibFileTitle
 SAVELIB.Flags: D$ &OFN_EXPLORER__&OFN_FILEMUSTEXIST__&OFN_LONGNAMES__&OFN_PATHMUSTEXIST
 SAVELIB.nFileOffset: W$ 0
 SAVELIB.nFileExtension: W$ 0
 SAVELIB.lpstrDefExt: D$ 0
 SAVELIB.lCustData: D$ 0
 SAVELIB.lpfnHook: D$ 0
 SAVELIB.lpTemplateName: D$ 0]

[LibScanIsFileOpen: B$ &FALSE]

Proc SaveLibFileAs:
    Arguments @hwnd, @OutPut, @OutPutSize
    uses eax

    ; To Insert the Appended String. We inset it, when the user opens a new file only. On case the user presses Clear Button
    ; the Buffer is emptyed.
    If_And B$LibScanIsFileOpen = &FALSE, D$hLibReportEdit <> 0
        Call LibScanAppendReportName LibSaveFilter
    End_If

    Mov D$ChoosenLibFile 0
    Move D$SAVELIB.lpstrFile LibSaveFilter
    Move D$SAVELIB.hwndOwner D@hwnd
    Move D$SAVELIB.hInstance D$H.Instance
    Move D$SAVELIB.lpstrFilter LibSaveFileFilter
    Call 'Comdlg32.GetSaveFileNameA' SAVELIB

    On eax = 0, ExitP
    .If D$ChoosenLibFile <> 0
        If D$SAVELIB.nFilterIndex = 1 ; extension .txt
            Call ForceExtension LibSaveFilter, '.txt'
        Else_If D$SAVELIB.nFilterIndex = 2 ; extension .asm
            Call ForceExtension LibSaveFilter, '.asm'
        Else ; Force txt extensino if the user is trying to save as "all"
            Call ForceExtension LibSaveFilter, '.txt'
        End_If
        Call SaveLibFile, D@OutPut, D@OutPutSize, LibSaveFilter
    .End_If

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

Proc LibScanAppendReportName:
    Arguments @String
    Uses eax, ecx, edi

    Mov edi D@String
    ;sub edi 2     ; edi points to the end of the string 2

    .While edi >= D@String

        .If_Or B$edi = ':', B$edi = '/', B$edi = '\'

            Do
                On B$edi = '.', jmp L1>
                inc edi
            Loop_Until B$edi = 0
            jmp L1>
        .End_If

        ;dec edi
        inc edi
    .End_While
    L1:
        Push esi | ZCopy {B$ "Report.txt" EOS} | Pop esi
        Mov D$edi 0
    Mov B$LibScanIsFileOpen &TRUE
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc SaveLibFile:
    Arguments @OutPut, @OutPutSize, @FileFilter

    pushad

    Call 'KERNEL32.CreateFileA' D@FileFilter, &GENERIC_WRITE,
                                &FILE_SHARE_READ__&FILE_SHARE_WRITE, &NULL, &CREATE_ALWAYS,
                                &FILE_ATTRIBUTE_NORMAL, &NULL

    Mov D$H.LibFile eax

    If eax = &INVALID_HANDLE_VALUE
        Mov eax D$BusyFilePtr | Call MessageBox | popad | ret
    End_If

    Mov D$H.Destination eax, D$NumberOfReadBytes 0

    Call 'KERNEL32.WriteFile' D$H.Destination, D@OutPut, D@OutPutSize, NumberOfReadBytes  0
    Call 'KERNEL32.CloseHandle' D$H.Destination | Mov D$H.Destination 0

    popad

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; This function will cleanup all previously loaded Data in case the user reopens the file without
; closing the CharMap Dialog

Proc LibScanCleanUp:

    Arguments @hwnd

    ; Free LibFileMemory

    Call VirtualFree LibFileMemory

    ; Free hLibReportEdit Report
    Call VirtualFree hLibReportEdit

    Call 'USER32.SendDlgItemMessageA' D@hwnd, IDC_OPENLIBFILE, &WM_SETTEXT, 0, &NULL

    Call 'USER32.SendDlgItemMessageA' D@hwnd, IDC_LIBFILESIZE, &WM_SETTEXT, 0, &NULL

    Call 'USER32.SendDlgItemMessageA' D$H.TabDlg1, IDC_LIB_SOURCE, &WM_SETTEXT, 0, &NULL

    Call 'USER32.SendMessageA', D$H.List, &LVM_DELETEALLITEMS, 0, lvi

    Call 'USER32.SendMessageA' D@hwnd, &WM_SETTEXT, 0, {B$ "ScanLib v 1.0" EOS}

    Call ClearDwordBuffer szBuff0,
                          (256/DWORD)

    Call ClearDwordBuffer szBuff1,
                          (256/DWORD)

    ; Must clean these listview itens to avoid that we have errors on the resequence
    Mov D$lvi.iItem 0

    Mov D$lvi.iSubItem 0

EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc CoolControlDlg_CreateTab:
    Arguments @hwnd, @nIDDlgItem, @H.Output, @CCTabStructure
    Local @TabsAmount, @UseImage


    Mov D@TabsAmount 0
    Mov D@UseImage 0

    Call 'USER32.GetDlgItem' D@hwnd, D@nIDDlgItem ; Get the Tab Control in the resources, and
                                                    ; use it on the handle of the main window
                                                    ; of this procedure.
    lea edi D@H.Output
    Mov edi D$edi
    Mov D$edi eax                                   ; Now we return the result (found in eax), copying it to
                                                    ; the Handle of the Tab Control in the resource.
                                                    ; So, all we did was get the TAB Control and save it to the Tab handle.

    Mov ecx D@CCTabStructure
    Mov eax D$ecx+CCTabOrganize.ImageListDis

    If eax = 0
        Mov D@UseImage &FALSE
    Else
        Mov D@UseImage &TRUE
        Push ecx | SendMessage D$edi, &TCM_SETIMAGELIST, 0, D$eax | Pop ecx
    End_If

    Mov edx D$ecx+CCTabOrganize.TCITEMDis
    Move D$edx+TC_ITEM.imaskDis D$ecx+CCTabOrganize.iMaskFlagDis

    Mov eax D$ecx+CCTabOrganize.TabsAmountDis
    Move D@TabsAmount D$eax

    Mov ebx 0

    .Do

        ; TabTitle copied to ts.pszText
        Mov esi D$ecx+CCTabOrganize.StringArrayDis
        Mov esi D$esi+ebx*4
        Mov D$edx+TC_ITEM.pszTextDis esi

        ; TabTitleLen copied to ts.cchTextMax
        Mov esi D$ecx+CCTabOrganize.StringLenArrayDis
        Mov esi D$esi+ebx*4
        Move D$edx+TC_ITEM.cchTextMaxDis D$esi

        If D@UseImage = &TRUE
            ; Image ID copied to ts.iImage
            Mov D$edx+TC_ITEM.iImageDis ebx
        End_If

        Push edx
        Push ecx
        Call 'USER32.SendMessageA' D$edi &TCM_INSERTITEM ebx edx
        Pop ecx
        Pop edx

        inc ebx
    .Loop_Until ebx = D@TabsAmount
;;

;;
[TC_ITEM.imaskDis 0
 TC_ITEM.lpReserved1Dis 4
 TC_ITEM.lpReserved2Dis 8
 TC_ITEM.pszTextDis 12
 TC_ITEM.cchTextMaxDis 16
 TC_ITEM.iImageDis 20
 TC_ITEM.lParamDis 24]
     
;;
;;

        Mov D$ts.imask &TCIF_TEXT__&TCIF_IMAGE ; Mask text & image
        Mov D$ts.pszText TabTitle1
        Mov D$ts.cchTextMax TabTitle1Len
        Mov D$ts.iImage 0
        Call 'USER32.SendMessageA' D$edi &TCM_INSERTITEM 0 ts

        Mov D$ts.imask &TCIF_TEXT__&TCIF_IMAGE ; Mask text & image
        Mov D$ts.pszText TabTitle2
        Mov D$ts.cchTextMax TabTitle2Len
        Mov D$ts.iImage 1
        Call 'USER32.SendMessageA' D$edi &TCM_INSERTITEM 1 ts

        Mov D$ts.imask &TCIF_TEXT__&TCIF_IMAGE ; Mask text & image
        Mov D$ts.pszText TabTitle3
        Mov D$ts.cchTextMax TabTitle3Len
        Mov D$ts.iImage 2
        Call 'USER32.SendMessageA' D$edi &TCM_INSERTITEM 2 ts


        Mov D$ts.imask &TCIF_TEXT__&TCIF_IMAGE ; Mask text & image
        Mov D$ts.pszText TabTitle4
        Mov D$ts.cchTextMax TabTitle4Len
        Mov D$ts.iImage 3
        Call 'USER32.SendMessageA' D$edi &TCM_INSERTITEM 3 ts
;;
;;
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________


[LibScannerTitle: B$ ? # 100]

Proc WriteObjectTypeinTitle:
    Arguments @hwnd, @TextTitle

    pushad

    Mov eax D@TextTitle
    Mov edi LibScannerTitle
    Push esi | Zcopy {B$ "ScanLib v 1.0 - " EOS} | Pop esi

    Push esi | ZCopy eax | Pop eax
    Push esi | Zcopy {B$ " Format" EOS} | Pop esi

    Mov B$edi 0
    Call 'USER32.SendMessageA' D@hwnd, &WM_SETTEXT, 0, LibScannerTitle

    popad

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; Enable / Gray-out execution control commands.

Proc LibScanDialog_EnableContinueMenu:
    Arguments @Enable

    If D@Enable = 1
        Mov ebx &MF_ENABLED
    Else
        Mov ebx &MF_GRAYED
    End_If

    Call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Close, ebx
    Call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Save_Report, ebx
    Call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Single_Object_File, ebx
    Call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_All_Object_Files, ebx
    Call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Runtime_Objects_Only, ebx
    Call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Exported_Objects_Only, ebx
    Call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Build_Dis_File, ebx

    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Close, D@Enable
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Save_Report, D@Enable
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Single_Object_File, D@Enable
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_All_Object_Files, D@Enable
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Runtime_Objects_Only, D@Enable
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Exported_Objects_Only, D@Enable
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Build_Dis_File, D@Enable

  ; Invert
    If D@Enable = 1
        Mov ebx &MF_GRAYED
        Mov D@Enable 0
    Else
        Mov ebx &MF_ENABLED
        Mov D@Enable 1
    End_If

EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc LibScanDialog_EnableContinueNextTabMenu:
    Arguments @Enable

    If D@Enable = 1
        Mov ebx &MF_ENABLED
    Else
        Mov ebx &MF_GRAYED
    End_If

    Call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Next_Tab, ebx
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Next_Tab, D@Enable

    Call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Last_Tab, ebx
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Last_Tab, D@Enable
  ; Invert
    If D@Enable = 1
        Mov ebx &MF_GRAYED
        Mov D@Enable 0
    Else
        Mov ebx &MF_ENABLED
        Mov D@Enable 1
    End_If

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

Proc LibScanDialog_EnableContinuePrevTabMenu:
    Arguments @Enable
    uses eax, ecx, edx

    If D@Enable = 1
        Mov ebx &MF_ENABLED
    Else
        Mov ebx &MF_GRAYED
    End_If

    Call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Previous_Tab, ebx
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Previous_Tab, D@Enable

    Call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_First_Tab, ebx
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_First_Tab, D@Enable


  ; Invert
    If D@Enable = 1
        Mov ebx &MF_GRAYED
        Mov D@Enable 0
    Else
        Mov ebx &MF_ENABLED
        Mov D@Enable 1
    End_If

EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc LibScanDisplayFileSize:
    Arguments @hwnd

    pushad
    ; Calculate and Display File Size
    Mov edi buffer2
    lea esi D$LibFileLength

    Mov ecx 4
    Call toUDword
    Mov esi edi, edi DecimalBuffer
    Do | movsb | LoopUntil B$esi = 0
    Push esi | ZCopy {B$ ' Bytes' EOS} | Pop esi
    Mov B$edi 0

    Call 'USER32.SendDlgItemMessageA' D@hwnd IDC_LIBFILESIZE &WM_SETTEXT 0 DecimalBuffer
    Call 'USER32.SendDlgItemMessageA' D@hwnd IDC_LIBFILESIZE &WM_GETTEXT 0 DecimalBuffer ; GET THE FILENAME
    popad
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

Proc LibScanDialog_ToggleToolbarText:
    Arguments @Addresse
    Structure @TBButtonInfo 32, @Size 0, @Mask 4, @Text 24

    Mov D@Size 32, D@Mask &TBIF_TEXT

  ; get check state of menu item, invert, toggle band and set inverted check state
    Call 'USER32.GetMenuState' D$LibScanMenuHandle, M03_Show_ToolBarText, &MF_BYCOMMAND
    Push eax
        xor edx edx | test eax &MF_CHECKED | setz dl
        Mov B$LibScanShowTBText dl
        Call CoolControlWin_CreateCommandTB D@Addresse, LibScanToolbarHandle, LibScanToolbarButtons, LibScanToolButtonsNumber, LibScanToolTipsStrings, LSTBWin_Cmd
    Pop eax
    xor eax &MF_CHECKED | and eax &MF_CHECKED
    Call 'USER32.CheckMenuItem' D$LibScanMenuHandle, M03_Show_ToolBarText, eax
    SendMessage D$LibScanMenuHandle, &TB_AUTOSIZE, 0, 0

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[LibScanHoverTBText: D$ ?]

Proc LibScanDialog_HoverToolbarText:
    Arguments @Addresse
    Structure @TBButtonInfo 32, @Size 0, @Mask 4, @Text 24

    Mov D@Size 32, D@Mask &TBIF_TEXT

  ; get check state of menu item, invert, toggle band and set inverted check state
    Call 'USER32.GetMenuState' D$LibScanMenuHandle, M03_Hover_ToolBar, &MF_BYCOMMAND
    Push eax
        xor edx edx | test eax &MF_CHECKED | setz dl
        Mov B$LibScanHoverTBText dl
        ;Call CoolControlWin_CreateCommandTB D@Addresse, LibScanToolbarHandle, LibScanToolbarButtons, LibScanToolButtonsNumber, LibScanToolTipsStrings, LSTBWin_Cmd
    Pop eax
    xor eax &MF_CHECKED | and eax &MF_CHECKED
    Call 'USER32.CheckMenuItem' D$LibScanMenuHandle, M03_Hover_ToolBar, eax
    SendMessage D$LibScanMenuHandle, &TB_AUTOSIZE, 0, 0

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

DecodeLib:   ; EncodeDecode
    Mov B$WeAreInTheCodeBox &TRUE

        Mov esi D$LibBytesCopy, edi D$LibDisassemblyPtr

      ; Disassemble: (DisMain)
        .While D$esi <> 0
            lodsd | Mov edx esi | add edx eax

            While esi < edx
                Push edx
                    Mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
                    Mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
                    Mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE

L1:                 movzx eax B$esi | inc esi | Call D$DisOp1+eax*4
                    On B$DisFlag = DISDONE, jmp L1<

                    Mov W$edi CRLF | add edi 2
                Pop edx
            End_While

            Mov D$edi CRLF2 | add edi 4 | Mov esi edx
        .End_While

        Mov D$LibDisassemblyPtr edi

    Mov B$WeAreInTheCodeBox &FALSE
ret




__________________________________________________________________________________________________________________



; Tag Dialog 20

LibScanner:
    Call 'USER32.DialogBoxParamA' D$H.Instance, IDD_MAINLIB, &NULL, ScanLibFile, &NULL
ret

____________________________________________________________________________________________

[IDD_LIBSCANWARNINGMSG 23]
[IDC_DISPLAYWARNINGMSG 10]
[IDC_DISPLAYWARNINGHEXA 20]

[IDB_LIBWARNING_BITMAP 200]
[IDC_LIBWARNING_SHOWICON 6]

[LibScanWarnMsg: B$ "The Magic Signature Tag was not found.

This is not a Object File supported by this dumper
__________________________________________________" EOS]

[LibScanHexaMsg: D$ ? # 256]
[LibWarningStaticImage: D$ ?]
[LibScanhIcon: D$ ?]

Proc LibScanWarning:
    Arguments @hwnd, @msg, @wParam, @lParam

     pushad


    ..If D@msg = &WM_INITDIALOG

        Call 'USER32.GetDlgItem' D@hwnd IDC_LIBWARNING_SHOWICON ; Get the handle of the Static Image
        Mov D$LibWarningStaticImage eax
        Call 'USER32.LoadBitmapA' D$H.Instance, IDB_LIBWARNING_BITMAP
        Mov D$LibScanhIcon eax

        Call 'USER32.SendMessageA' D$LibWarningStaticImage, &STM_SETIMAGE, &IMAGE_BITMAP, D$LibScanhIcon
        Call 'USER32.SendDlgItemMessageA' D@hwnd IDC_DISPLAYWARNINGMSG &WM_SETTEXT 0 LibScanWarnMsg
        Call 'USER32.SendDlgItemMessageA' D@hwnd IDC_DISPLAYWARNINGMSG &WM_GETTEXT 0 LibScanWarnMsg

        ; Calculate and Display File Size
        Mov edi LibScanHexaMsg
        Mov ecx D$LibFileLength
        Mov esi D$LibFileMemory

        If D$LibFileLength < 80  ; Maximum amount of bytes
            Mov ecx D$LibFileLength
        Else_If ecx = 0 ; This shouldn´t happen, because we already have a Zero Size check, but...security is never too much ;)
            Mov ecx 1
        Else
            Mov ecx 80
        End_If

        ; Convert the 1st 80 Bytes to Decimal String notation.
        xor eax eax
        Mov edx 0
        Do
            lodsb
            Call writeeax
            xor eax eax
            Mov B$edi SPC | inc edi
            dec ecx
        Loop_Until ecx = 0
        Mov B$edi 0

        Call 'USER32.SetDlgItemTextA' D@hwnd, IDC_DISPLAYWARNINGHEXA, LibScanHexaMsg

    ..Else_If D@msg = &WM_CLOSE
        
        Call ClearDwordBuffer LibScanHexaMsg,
                              (256/DWORD)
        
        Call 'USER32.EndDialog' D@hwnd &NULL

    ..Else_If D@msg = &WM_COMMAND
        .If D@wParam = &IDOK

            Call ClearDwordBuffer LibScanHexaMsg,
                                  (256/DWORD)

            Call 'USER32.EndDialog' D@hwnd &NULL

         .End_If

    ..Else

       popad | Mov eax &FALSE | ExitP

    ..End_If

    popad
    Mov eax &TRUE
EndP

____________________________________________________________

[szBuff1: B$ ? # 256]

Proc ListViewLibSort:
    Arguments @lParam1, @lParam2, @lParamSort
    Local @Dir1, @Dir2
    Uses edi, ebx, esi, ecx, edx

;    Call ClearCharMapData szBuff0, 256
;    Call ClearCharMapData szBuff1, 256

    and D@Dir1 0
    and D@Dir2 0
    Mov D$lvi.imask &LVIF_TEXT
    lea eax D$szBuff0
    Mov D$lvi.pszText eax
    Mov D$lvi.cchTextMax 256

    Mov D$lvi.iSubItem 01
    Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam1, lvi
    xor eax eax
    Mov al B$szBuff0
    Mov D@Dir1 eax
    Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam2, lvi
    xor eax eax
    Mov al B$szBuff0
    Mov D@Dir2 eax

    ; Decimal Value [Header1: B$ 'Index' EOS]
    ..If_Or D@lParamSort = 01, D@lParamSort = 02

        Mov D$lvi.iSubItem 0
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam1, lvi
        Call String2Dword szBuff0
        Mov edi eax
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam2, lvi
        Call String2Dword szBuff0

        If D@lParamSort = 1
            sub edi eax
            Mov eax edi
        Else
            sub eax edi
        End_If

    ; Hexadecimal Value [Header2: B$ 'File Name' EOS] ; string
    ..Else_If_Or D@lParamSort = 3, D@lParamSort = 4

        Mov D$lvi.iSubItem 1
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam1, lvi
        Call strcpy szBuff1, szBuff0
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam2, lvi

        If D@lParamSort = 3
            Call lstrcmpi szBuff1, szBuff0
        Else
            Call lstrcmpi szBuff0, szBuff1
        End_If

    ; [Header3: B$ 'Extension' EOS] ; string
    ..Else_If_Or D@lParamSort = 5, D@lParamSort = 6

        Mov D$lvi.iSubItem 2
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam1, lvi
        Call strcpy szBuff1, szBuff0
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam2, lvi

        If D@lParamSort = 5
            Call stricmp szBuff1, szBuff0
        Else
            Call stricmp szBuff0, szBuff1
        End_If

    ; [Header4: B$ 'FileName Type' EOS] ; string
    ..Else_If_Or D@lParamSort = 7, D@lParamSort = 8

        Mov D$lvi.iSubItem 3
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam1, lvi
        Call strcpy szBuff1, szBuff0
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam2, lvi

        If D@lParamSort = 7
            Call stricmp szBuff1, szBuff0
        Else
            Call stricmp szBuff0, szBuff1
        End_If

    ; [Header5: B$ 'Path' EOS] ; string
    ..Else_If_Or D@lParamSort = 9, D@lParamSort = 10

        Mov D$lvi.iSubItem 4
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam1, lvi
        Call strcpy szBuff1, szBuff0
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam2, lvi

        If D@lParamSort = 9
            Call lstrcmpi szBuff1, szBuff0
        Else
            Call lstrcmpi szBuff0, szBuff1
        End_If

    ; [Header6: B$ 'Offset' EOS] ; hexadecimal value string
    ..Else_If_Or D@lParamSort = 11, D@lParamSort = 12

        Mov D$lvi.iSubItem 5
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam1, lvi
        Call AsciiBase szBuff0 BASE_HEX
        Mov edi eax
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam2, lvi
        Call AsciiBase szBuff0 BASE_HEX

        If D@lParamSort = 11
            sub edi eax
            Mov eax edi
        Else
            sub eax edi
        End_If


    ; [Header7: B$ 'Size' EOS] ; decimal value
    ..Else_If_Or D@lParamSort = 13, D@lParamSort = 14

        Mov D$lvi.iSubItem 6
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam1, lvi
        Call String2Dword szBuff0
        Mov edi eax
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam2, lvi
        Call String2Dword szBuff0

        If D@lParamSort = 13
            sub edi eax
            Mov eax edi
        Else
            sub eax edi
        End_If

    ; [Header8: B$ 'Object Type' EOS] ; string
    ..Else_If_Or D@lParamSort = 15, D@lParamSort = 16

        Mov D$lvi.iSubItem 7
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam1, lvi
        Call strcpy szBuff1, szBuff0
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam2, lvi

        If D@lParamSort = 15
            Call stricmp szBuff1, szBuff0
        Else
            Call stricmp szBuff0, szBuff1
        End_If

    ; [Header9: B$ 'Exported Function' EOS] ; string
    ..Else_If_Or D@lParamSort = 17, D@lParamSort = 18

        Mov D$lvi.iSubItem 8
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam1, lvi
        Call strcpy szBuff1, szBuff0
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam2, lvi

        If D@lParamSort = 17
            Call lstrcmpi szBuff1, szBuff0
        Else
            Call lstrcmpi szBuff0, szBuff1
        End_If

    ; [Header10: B$ 'Machine Type' EOS] ; string
    ..Else_If_Or D@lParamSort = 19, D@lParamSort = 20

        Mov D$lvi.iSubItem 9
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam1, lvi
        Call strcpy szBuff1, szBuff0
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam2, lvi

        If D@lParamSort = 19
            Call lstrcmpi szBuff1, szBuff0
        Else
            Call lstrcmpi szBuff0, szBuff1
        End_If

    ; [Header11: B$ 'Sections' EOS] ; decimal value
    ..Else_If_Or D@lParamSort = 21, D@lParamSort = 22

        Mov D$lvi.iSubItem 10
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam1, lvi
            If_And D$szBuff0 = 'No S', D$szBuff0+4 = 'ecti' ; "No Sections" string = 0
                Mov eax 0
            Else
                Call String2Dword szBuff0
            End_If
        Mov edi eax
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam2, lvi
            If_And D$szBuff0 = 'No S', D$szBuff0+4 = 'ecti' ; "No Sections" string = 0
                Mov eax 0
            Else
                Call String2Dword szBuff0
            End_If
        If D@lParamSort = 21
            sub edi eax
            Mov eax edi
        Else
            sub eax edi
        End_If

    ; [Header12: B$ 'Time and Date' EOS] ; time and date string - convert it to dword
    ..Else_If_Or D@lParamSort = 23, D@lParamSort = 24

        Mov D$lvi.iSubItem 11
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam1, lvi
        ;TimeDateStringtoDword
        Call strcpy szBuff1, szBuff0
        Mov edi eax
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam2, lvi
        Call String2Dword szBuff0

        If D@lParamSort = 23
            Call lstrcmpi szBuff1, szBuff0
        Else
            Call lstrcmpi szBuff0, szBuff1
        End_If

    ; [Header13: B$ 'Symbols' EOS] ; decimal value
    ..Else_If_Or D@lParamSort = 25, D@lParamSort = 26
        Mov D$lvi.iSubItem 12
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam1, lvi
            If_And D$szBuff0 = 'No S', D$szBuff0+4 = 'ymbo' ; "No Symbols" String = 0
                Mov eax 0
            Else
                Call String2Dword szBuff0
            End_If
        Mov edi eax
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam2, lvi
            If_And D$szBuff0 = 'No S', D$szBuff0+4 = 'ymbo' ; "No Symbols" String = 0
                Mov eax 0
            Else
                Call String2Dword szBuff0
            End_If
        If D@lParamSort = 25
            sub edi eax
            Mov eax edi
        Else
            sub eax edi
        End_If

    ; [Header14: B$ 'Optional Header' EOS] ; string
    ..Else_If_Or D@lParamSort = 27, D@lParamSort = 28
        ; Optional Header can be only True or False.
        Mov D$lvi.iSubItem 13
        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam1, lvi
            If D$szBuff0 = 'True'
                Mov eax 1
            Else
                Mov eax 0
            End_If
        Mov edi eax

        Call 'USER32.SendMessageA' D$H.List, &LVM_GETITEMTEXT, D@lParam2, lvi
            If D$szBuff0 = 'True'
                Mov eax 1
            Else
                Mov eax 0
            End_If

        If D@lParamSort = 27
            sub edi eax
            Mov eax edi
        Else
            sub eax edi
        End_If



    ..End_If
;---------- [Keep the folders on top] ----------

    .If_And B@Dir1 = '<', B@Dir2 <> '<'
        xor eax eax
        dec eax
        ExitP
    .Else_If_And B@Dir2 = '<', B@Dir1 <> '<'
        xor eax eax
        inc eax
        ExitP
    .Else_If_And B@Dir1 = '<', B@Dir2 = '<'
        xor eax eax
    .End_If

EndP


________________________________________________________________________________________


; ToolBar Data and Functions

[LibScanMenuHandle: D$ ?]
[LibScanDialog_ImageList: D$ ?]
[IDB_LibScanEnableTB 30]
[IDB_LibScanDisableTB 31]
[LibScanToolbarHandle: D$ 0]

[LIBSCANDLG_TOOLBAR 400]

; Flow control buttons ; TBBUTTON Structure

[LibScanToolbarButtons:
    LSTB01.iBitmap: D$ 0
    LSTB01.idCommand: D$ M03_Open
    LSTB01.fsState: B$ &TBSTATE_ENABLED
    LSTB01.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB01._wPad1: W$ 0
    LSTB01.dwData: D$ 0
    LSTB01.iString: D$ 0

    LSTB02.iBitmap: D$ 1
    LSTB02.idCommand: D$ M03_Close
    LSTB02.fsState: B$ &TBSTATE_ENABLED
    LSTB02.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB02._wPad1: W$ 0
    LSTB02.dwData: D$ 0
    LSTB02.iString: D$ 0

    LSTB03.iBitmap: D$ 2
    LSTB03.idCommand: D$ M03_Save_Report
    LSTB03.fsState: B$ &TBSTATE_ENABLED
    LSTB03.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB03._wPad1: W$ 0
    LSTB03.dwData: D$ 0
    LSTB03.iString: D$ 0

    LSTB04.iBitmap: D$ 3
    LSTB04.idCommand: D$ M03_Single_Object_File
    LSTB04.fsState: B$ &TBSTATE_ENABLED
    LSTB04.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB04._wPad1: W$ 0
    LSTB04.dwData: D$ 0
    LSTB04.iString: D$ 0

    LSTB05.iBitmap: D$ 4
    LSTB05.idCommand: D$ M03_All_Object_Files
    LSTB05.fsState: B$ &TBSTATE_ENABLED
    LSTB05.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB05._wPad1: W$ 0
    LSTB05.dwData: D$ 0
    LSTB05.iString: D$ 0

    LSTB06.iBitmap: D$ 5
    LSTB06.idCommand: D$ M03_Build_Dis_File
    LSTB06.fsState: B$ &TBSTATE_ENABLED
    LSTB06.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB06._wPad1: W$ 0
    LSTB06.dwData: D$ 0
    LSTB06.iString: D$ 0

    LSTB07.iBitmap: D$ 6
    LSTB07.idCommand: D$ M03_Next_Tab
    LSTB07.fsState: B$ &TBSTATE_ENABLED
    LSTB07.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB07._wPad1: W$ 0
    LSTB07.dwData: D$ 0
    LSTB07.iString: D$ 0

    LSTB08.iBitmap: D$ 7
    LSTB08.idCommand: D$ M03_Previous_Tab
    LSTB08.fsState: B$ &TBSTATE_ENABLED
    LSTB08.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB08._wPad1: W$ 0
    LSTB08.dwData: D$ 0
    LSTB08.iString: D$ 0

    LSTB09.iBitmap: D$ 8
    LSTB09.idCommand: D$ M03_First_Tab
    LSTB09.fsState: B$ &TBSTATE_ENABLED
    LSTB09.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB09._wPad1: W$ 0
    LSTB09.dwData: D$ 0
    LSTB09.iString: D$ 0

    LSTB10.iBitmap: D$ 9
    LSTB10.idCommand: D$ M03_Last_Tab
    LSTB10.fsState: B$ &TBSTATE_ENABLED
    LSTB10.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB10._wPad1: W$ 0
    LSTB10.dwData: D$ 0
    LSTB10.iString: D$ 0]


[LIBSCAN_TOOLBAR_STYLE &WS_CHILD__&WS_VISIBLE__&TBSTYLE_FLAT__&TBSTYLE_LIST__&TBSTYLE_AUTOSIZE__&TBSTYLE_TRANSPARENT__&TBSTYLE_TOOLTIPS__&CCS_TOP]

[LibScanShowTBText: D$ ?]

[LibScanToolButtonsNumber 10]

[LibScanToolTipsStrings:
 StrLibScanOpen
 StrLibScanClose
 StrLibScanSave
 StrLibScanSingleObj
 StrLibScanAllObj
 StrLibScanDIS
 StrLibScanNextTab
 StrLibScanPrevTab
 StrLibScanFirstTab
 StrLibScanLastTab]

[StrLibScanOpen: B$ 'Open' EOS]
[StrLibScanClose: B$ 'Close' EOS]
[StrLibScanSave: B$ 'Save Report' EOS]
[StrLibScanSingleObj: B$ 'Extract Single Object' EOS]
[StrLibScanAllObj: B$ 'Extract All Objects' EOS]
[StrLibScanDIS: B$ 'Build DIS File' EOS]
[StrLibScanNextTab: B$ 'Goto Next tab' EOS]
[StrLibScanPrevTab: B$ 'Goto Previous tab' EOS]
[StrLibScanFirstTab: B$ 'Goto First tab' EOS]
[StrLibScanLastTab: B$ 'Goto Last tab' EOS]

[LSTBWin_Cmd:
 LSTBWin_Cmd.bWidth: D$ 20
 LSTBWin_Cmd.dwStyle: D$ LIBSCAN_TOOLBAR_STYLE
 LSTBWin_Cmd.hMenu: D$ LIBSCANDLG_TOOLBAR
 LSTBWin_Cmd.hIml: D$ LibScanDialog_ImageList
 LSTBWin_Cmd.ShowTxtFlag: D$ LibScanShowTBText]

__________________________________________________________________________________________

; Tab Control Data and Functions

[IDB_LibScanTABEnable 40]
[IDB_LibScanTABDisable 41]

[LibScanTabControlsNumber 4]

; This structure is of the type TC_ITEM
[ts:
 ts.imask: D$ &TCIF_TEXT
 ts.lpReserved1: D$ 0
 ts.lpReserved2: D$ 0
 ts.pszText: D$ 0
 ts.cchTextMax: len
 ts.iImage: D$ 0-01
 ts.lParam: D$ 0]

[TC_ITEM.imaskDis 0
 TC_ITEM.lpReserved1Dis 4
 TC_ITEM.lpReserved2Dis 8
 TC_ITEM.pszTextDis 12
 TC_ITEM.cchTextMaxDis 16
 TC_ITEM.iImageDis 20
 TC_ITEM.lParamDis 24]

; Tab Dialog Messages and Data

[TabTitle1: B$ "Library Structure" EOS
TabTitle1Len: D$ len]

[TabTitle2: B$ "Object Files" EOS
TabTitle2Len: D$ len]

[TabTitle3: B$ "Disassembled Display" EOS
TabTitle3Len: D$ len]

[TabTitle4: B$ "DIS Builder" EOS
TabTitle4Len: D$ len]

[LibScanTabToolTipStrings: TabTitle1 TabTitle2 TabTitle3 TabTitle4]
[LibScanTabToolTipStringsLen: TabTitle1Len TabTitle2Len TabTitle3Len TabTitle4Len]

; CCTabOrganize Structure

[LibScanTabControl:
 LibScanTabControl.TCITEM: D$ ts
 LibScanTabControl.iMaskFlag: D$ &TCIF_TEXT__&TCIF_IMAGE
 LibScanTabControl.ImageList: D$ LibScanTab_ImageList
 LibScanTabControl.TabsAmount: D$ LibScanTabNumber
 LibScanTabControl.StringArray: D$ LibScanTabToolTipStrings
 LibScanTabControl.StringLenArray: D$ LibScanTabToolTipStringsLen]

[CCTabOrganize.TCITEMDis 0
 CCTabOrganize.iMaskFlagDis 4
 CCTabOrganize.ImageListDis 8
 CCTabOrganize.TabsAmountDis 12
 CCTabOrganize.StringArrayDis 16
 CCTabOrganize.StringLenArrayDis 20]

[Size_Of_CCTabOrganize 24]


[LibScanTabNumber: 4]

[hTab: D$ 0] ; Handle of the Tab Control in the resource, that is inside the main Dialog

[SelTab: D$ 0] ; Selection Tab Flag.

[H.TabDlg1: D$ 0 ; Handle of the 1st Dialog MZ Header !!! Attention, utilisé en tant que Lp -> TABLE.H.TabDlg...
 H.TabDlg2: D$ 0 ; Handle of the 2nd Dialog PE Header
 H.TabDlg3: D$ 0 ; Handle of the 3rd Dialog PE DataDirectory Header
 H.TabDlg4: D$ 0] ; Handle of the 4th Dialog Image Section Headers

__________________________________________________________________________________________


; RunTime Functions


;;
;;
    Concatenation
    
    This function concatenates (join) 02 strings, and save the result on a buffer.

 Parameters:
 
    Source1: The 1st string to be joined
  
    Source2: The 2nd string to be joined
    
    Destination: The outputed buffer where the new string is stored
 

 Usage Example:
 
 
    Call Concatenation {B$ "HY ! My name is" EOS} {B$ "Guga" EOS}  edi

_______________________________________________________________

  Author:
    
    RobotBob (Eric) - Original Author

;;
;;

Proc Concatenation:
    Arguments @Source1, @Source2, @Destination
    Uses esi, edi

        Mov esi D@Source1, edi D@Destination
        While B$esi <> 0 | movsb | End_While

        Mov esi D@Source2
        While B$esi <> 0 | movsb | End_While

        movsb
EndP
____________________________________________________________________________________________________________

; Guga CodeView Equates


;;
;;
#define MAKESIG(a,b,c,d)        ((a) | ((b) << 8) | ((c) << 16) | ((d) << 24))
#define CODEVIEW_NB09_SIG       MAKESIG('N','B','0','9')
#define CODEVIEW_NB10_SIG       MAKESIG('N','B','1','0')
#define CODEVIEW_NB11_SIG       MAKESIG('N','B','1','1')
#define CODEVIEW_RSDS_SIG       MAKESIG('R','S','D','S')
;;
;;

[MAKESIG | (#1 or (#2 shl 8) or (#3 shl 16) or (#4 shl 24))]

[CODEVIEW_NB09_SIG 03930424E] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','9'] ; The result is reversed NB09
[CODEVIEW_NB10_SIG 03031424E] ; [CODEVIEW_NB10_SIG  MAKESIG 'N','B','1','0'] ; The result is reversed NB10
[CODEVIEW_NB11_SIG 03131424E] ; [CODEVIEW_NB11_SIG  MAKESIG 'N','B','1','1'] ; The result is reversed NB11
[CODEVIEW_RSDS_SIG 053445352] ; [CODEVIEW_RSDS_SIG  MAKESIG 'R','S','D','S'] ; The result is reversed RSDS

;;
; weird. The real signature (pdb files) in hexadecimal is not reversed. It is the regular order, Like:
;;
[CODEVIEW_NB00_SIG 04E423030] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','0'] ; The result is NB00
[CODEVIEW_NB01_SIG 04E423031] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','1'] ; The result is NB01
[CODEVIEW_NB02_SIG 04E423032] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','2'] ; The result is NB02
[CODEVIEW_NB03_SIG 04E423033] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','3'] ; The result is NB03
[CODEVIEW_NB04_SIG 04E423034] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','4'] ; The result is NB04
[CODEVIEW_NB05_SIG 04E423035] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','5'] ; The result is NB05
[CODEVIEW_NB06_SIG 04E423036] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','6'] ; The result is NB06
[CODEVIEW_NB07_SIG 04E423037] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','7'] ; The result is NB07
[CODEVIEW_NB08_SIG 04E423038] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','8'] ; The result is NB08
[CODEVIEW_NB09_SIG 04E423039] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','9'] ; The result is NB09
[CODEVIEW_NB10_SIG 04E423130] ; [CODEVIEW_NB10_SIG  MAKESIG 'N','B','1','0'] ; The result is NB10
[CODEVIEW_NB11_SIG 04E423131] ; [CODEVIEW_NB11_SIG  MAKESIG 'N','B','1','1'] ; The result is NB11
[CODEVIEW_RSDS_SIG 052534453] ; [CODEVIEW_RSDS_SIG  MAKESIG 'R','S','D','S'] ; The result is RSDS
;;


;;

Note to Guga:

It seems that when a Lib file is used by the linker, it inserts the whole object file that
uses a specific function that was called by the source.

For example, if we have a source file with a Call to a external lib containing "Function01", and this lib file
have 45 different Object files. The only Object file that will be used and "linked" is the one containing the 
"Functino01" function. (Example, if this function exists only in Object 32.

What happens is that the whole Object32.obj (Inside that lib) is used and linked/injected inside to produce the new
application. This explains why some applications have too many nested data inside code. Because the Object file that
is injected is fixed. And it contains theit own Code and Data sectinos, but the final application interprets it as 
Code only to inject the function on the final code section.

Sometimes it don´ happens, because when you build your file, the 1st to be done is to use the linked object/libs,
and after it is used, the compiler translates the Source code to produce the new object file. So this new object
file is surrounding the fixed object files. Like:


1st step:

Source Code
 --- Fixed Object File (Code Section)
 ----Fixed Object File (Data Section)
 
 2nd step , Linking
 
 Resultant Object File from source file. (Code Section from the new Object file) --|
 --- Fixed Object File (Code Section)                                              |
 ----Fixed Object File (Data Section)                                              |
 Resultant Object File from source file. (Data Section from the new Object file) --|
 
 Or something Like this.
 
 So, what we can do for the DIS ?
 
 Maybe the better is we once we identify a specific function, we check which Object File (Inside or not a lib)
 it belongs to, and then we just need to disassemble that whole object file that is evidently inside the exe.

Bingo !!!
This is exactly this :):):)
Check on ml.exe

We will see this function:
_flsall at 0043E359

It belongs to a specific object file 394 inside that consists in only this function.

Immediatelly after this function we have another one:

__mbsdec at 0043E3C6

This one belongs to other object file. (On the same lib)

Also, check the function _memcpy it contains nested code and data, and no debug info, but the relocs, and symbols seems
to be enough to find what are the data and code part of it.

;;



;;
 Note to René

a) Assembler Errors

        Call 'KERNEL32.WriteFile' D@File, RegContent, 14, BytesTransfered, 0

        Mov edi RegContent | Mov W$edi+1 'DX' | add edi 4
"       DwordToHex D$ebx+0A8
        Call 'KERNEL32.WriteFile' D@File, RegContent, 14, BytesTransfered, 0


When i try to assemble a copy of RoAsm2028b with RosAsm2028b, it keeps inserting a " char like above.
It causes rosasm to now assemble the file. The reason is because after assemblying it and RosAsm do
his job, it changes the lines of the source code and adds this extra ".


LibScannner

a) Errors: 

In several places of the whole RosAsm source i found a mismatch of size in CRLF displacement.
It was displaying this:

Mov D$edi CRLF | add edi 2

When the correct is:

Mov W$edi CRLF | add edi 2

Like in the Error Tab, here:

Mov esi D@Text1, edi Trash1, ecx 0 | Mov D$edi CRLF | add edi 2
(...)
Mov esi D@Text2, edi Trash2, ecx 0 | Mov D$edi CRLF | add edi 2


b) On file libgccguga.a, and on libgcc.a it was crashing due to an memory error.


I Fixed it increasing allocated memory here:

  ; Allocate mem for Strings ('CompletionTable')
  ; and for list of pointers to Strings ('CompletionPointers'):

    Push ecx
        ;inc ecx | shl ecx 2 | or ecx 1
        inc ecx | shl ecx 5 | or ecx 1 ; -----------> Added this
        VirtualAlloc CompletionPointers ecx
    Pop ecx

    ;shl ecx 5 | or ecx 1
    shl ecx 8 | or ecx 1 ; -------------------------> Added this
    VirtualAlloc CompletionTable ecx | inc D$CompletionTable

  ; Fill the Tables:
    Mov edi D$CompletionTable, ebx D$CompletionPointers


Note: Although it is fixed, the same memory problem hapens on UAFXCWD.LIB
The file does not load completelly on the object listing and also don't load on the structure editor.
So, maybe we need to calculate and extend memory like in ReMapSourceMemoryIfNeeded
The reason is because the generated text file is something around 0C0D3407 bytes (202,20 Mb)

c) Even fixing the above memory problem. It still crashes on LIBCMTD.LIB
THis one i couldn't fix 

Proc SetQwordCheckSum:
    Argument @Pointer

    pushad

        Mov esi D@Pointer

        If B$esi < '0'
            ;
        Else_If B$esi <= '9'
            error D$NumerAsSymbolPtr
        End_If

        Call CheckSum64 | Call NoDuplication D@Pointer | Call CheckSum16

      ; The List Pointer is used to test empty Records (Lists Pointers can never be zero):
        .If D$CheckSumsRecords+ecx = 0
            On D$CheckSumsRecords+ecx+4 <> 0, jmp L1>
            Mov D$CheckSumsRecords+ecx eax
            Mov D$CheckSumsRecords+ecx+4 ebx
            Move D$CheckSumsRecords+ecx+8 D@Pointer
          ; D$CheckSumsRecords+ecx+12 = 0
        .Else
L1:         If D$CheckSumsRecords+ecx+12 = 0
                Move D$CheckSumsRecords+ecx+12 D$PointerToCheckSumsLinkedRecords
            Else
                Mov edi D$CheckSumsRecords+ecx+12
                While D$edi+12 <> 0 | Mov edi D$edi+12 | End_While
                Move D$edi+12 D$PointerToCheckSumsLinkedRecords
            End_If

            Mov edi D$PointerToCheckSumsLinkedRecords
            Mov D$edi eax ; -----------------------------> Crashes here

d) Fixed Loading BookMarks when Loading the MRU files.

When i loaded a file through the MRU List, the bookmarks where not being loaded.
I fixed here (MainProc TAB):



            .Else_If eax > 3000             ; Most Recently Used Files.
                If eax < 3005
                    Push eax
                        Call Security       ; 'Security' also uses eax as return Value.
                    Pop ebx
                    On eax = &IDCANCEL, jmp L9>>
                        Mov eax ebx         ; ... and 'LoadRMUfile' as input.
                        Call LoadRMUfile | Call EnableMenutems | Call LoadBookMarks ; added the Call to LoadBookmarks


e) Small codecomplete error.

I added some new equates for CodeView 4, but if i start typing:

"&CV4_" and press control space an error messagebox shows up saying that it can´ find the equate and ask me to build a list.

But, if i type only: "&CV" and press control+space, the list displays properly

I added some equates like: &CV4_COMPILE_MACHINE_I80


f) RosAsm is crashing on Preparse Equal

If i write at the top of this lib "PREPARSE Equal" (After the Title) RosAsm crashes badly

g) Disassembler error on Floating Point Data.

Here:

[Data04D17F4: T$ 1.414214]
[<Data04D17FE: B$ 0, 0, 080, 07F  B$ 0, 0]
[Data04D1804: B$ 0, 048, 0C0, 0FF, F$ 0.5, F$ -1.443411e+035, F$ -4.952773e-007
                 F$ 2.295747e-041, F$ 4.573838e-041]
                 
Should be:

[Data04D17F4: T$ 1.414214]
[Data04D17FE: F$ 3.4028237e+038]
[Data04D1804: F$ -5.1117124e+038, F$ 0.5, F$ -1.443411e+035, F$ -4.952773e-007
                 F$ 2.295747e-041, F$ 4.573838e-041]

This is because all of them points to Fld instructions, like:

here:
    fld F$Data04D17FE
jmp E4>  ; Code04AAF8C
    
Code04AAF1B: J1:


and here:
    
Code04AAFD2: L4:
    fstp ST0
    fld F$Data04D1804
    
Code04AAFDA: M2:

h) Disassembler error on MMX mnemonic.

On testing.exe from C:\Guga\EvilHomerNewSite\site\stig.servehttp.com\homer\DirectX\Example1, ehit is being disasembled:

    cvtpq2ps XMM0 XMM2                ; 0F 5B C2 
    cvtpq2ps XMM2 XMM7                ; 0F 5B D7 
    mulps XMM0 XMM1                   ; 0F 59 C1 
    mulps XMM3 XMM2                   ; 0F 59 DA 
    Pop ecx                           ; 59 
    ret                               ; C3 
    
Code040A4CC: B2:

But the correct is cvtdq2ps, like:

    cvtdq2ps XMM0 XMM2                ; 0F 5B C2 
    cvtdq2ps XMM2 XMM7                ; 0F 5B D7 
    mulps XMM0 XMM1                   ; 0F 59 C1 
    mulps XMM3 XMM2                   ; 0F 59 DA 
    Pop ecx                           ; 59 
    ret                               ; C3 
    
Code040A4CC: B2:

I changed here:


cvtdq2ps

Op5B:
    .If B$EscapePrefix = &FALSE
        Mov D$edi 'Pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            Mov D$edi 'ebx ' | add edi 3
        Else
           ; inc D$UnLikelyCode
            Mov W$edi 'bx' | add edi 2
        End_If

    .Else

        ;inc D$UnLikelyCode
;        Mov D$edi 'cvtp'
        If B$OperandSizeOverride = &TRUE ; CVTPS2DQ xmm1, xmm2/m128
            Mov D$edi 'cvtp'
            Mov D$edi+4 's2dq'
        Else                             ; CVTDQ2PS xmm1, xmm2/m128
            Mov D$edi 'cvtd'            ; Guga fix. It must be cvtd
            Mov D$edi+4 'q2ps'          ; Guga Error Here. It is d2ps and not q2ps
        End_If
        Mov B$edi+8 SPC | add edi 9 | jmp Dis_xmm1__xmm2_m128

Also on this same file we have several problems of bad interpretations of code as data. It comes for example from here:

All of the Pointers are to Code and Not data, like "Mov D$ecx  Code04124BB" ; "Mov D$ecx+04 Code0411707" etc etc

Code0406E53: O7:
    Call Code0406D6F
    test al 020
    Mov ecx D$esp+04 | je Code040708C
    test al al | jns Code040708C
    test ah 01
    Mov D$ecx  Data04124BB ; error here it is a pointer to code and not to data
    Mov D$ecx+04 Data0411707 ; error here it is a pointer to code and not to data
    Mov D$ecx+08 Data041277C ; error here it is a pointer to code and not to data
    Mov D$ecx+0C Data040D957 ; error here it is a pointer to code and not to data
    Mov D$ecx+014 Data0412510 ; error here it is a pointer to code and not to data
    Mov D$ecx+018 Data0411778 ; error here it is a pointer to code and not to data
    Mov D$ecx+01C Code04117DF
    Mov D$ecx+020 Data04127FE ; error here it is a pointer to code and not to data
    Mov D$ecx+024 Data0412549 ; error here it is a pointer to code and not to data
    Mov D$ecx+028 Code0411CBF
    Mov D$ecx+02C Data040DB89 ; error here it is a pointer to code and not to data
    Mov D$ecx+030 Data0412BA6 ; error here it is a pointer to code and not to data
    Mov D$ecx+034 Data0412BE9 ; error here it is a pointer to code and not to data
    Mov D$ecx+038 Code0411CC4
    Mov D$ecx+03C Code0411E4C
    Mov D$ecx+040 Data041285D ; error here it is a pointer to code and not to data
    Mov D$ecx+044 Data04125AD ; error here it is a pointer to code and not to data
    Mov D$ecx+048 Data04116EB ; error here it is a pointer to code and not to data
    Mov D$ecx+04C Data040C47C ; error here it is a pointer to code and not to data
    Mov D$ecx+050 Data040C515 ; error here it is a pointer to code and not to data
    Mov D$ecx+054 Code0412D8B
    Mov D$ecx+058 Data0412CCD ; error here it is a pointer to code and not to data
    Mov D$ecx+05C Data040C572 ; error here it is a pointer to code and not to data
    Mov D$ecx+060 Data040C5B6 ; error here it is a pointer to code and not to data
    Mov D$ecx+064 Data040C9E7 ; error here it is a pointer to code and not to data
    Mov D$ecx+068 Data040DC58 ; error here it is a pointer to code and not to data
    Mov D$ecx+06C Data040DCA8 ; error here it is a pointer to code and not to data
    Mov D$ecx+070 Data040DD93 ; error here it is a pointer to code and not to data
    Mov D$ecx+074 Data040CAAC ; error here it is a pointer to code and not to data
    Mov D$ecx+078 Data040DE6F ; error here it is a pointer to code and not to data
    Mov D$ecx+07C Data040DED2 ; error here it is a pointer to code and not to data
    Mov D$ecx+080 Data040DF30 ; error here it is a pointer to code and not to data
    Mov D$ecx+084 Data040DF89 ; error here it is a pointer to code and not to data
    Mov D$ecx+088 Data0412DEF ; error here it is a pointer to code and not to data
    Mov D$ecx+08C Code040CB18
    Mov D$ecx+090 Data040CC4F ; error here it is a pointer to code and not to data
    Mov D$ecx+094 Data040DFD0 ; error here it is a pointer to code and not to data
    Mov D$ecx+098 Data040E078 ; error here it is a pointer to code and not to data
    Mov D$ecx+09C Code040E1FF
    Mov D$ecx+0A0 Data040F397 ; error here it is a pointer to code and not to data
    Mov D$ecx+0A4 Data040F53C ; error here it is a pointer to code and not to data
    Mov D$ecx+0A8 Code040FA70
    Mov D$ecx+0AC Data040CCDC ; error here it is a pointer to code and not to data
    Mov D$ecx+0B0 Data040CD6E ; error here it is a pointer to code and not to data
    Mov D$ecx+0D8 Data041298F ; error here it is a pointer to code and not to data
    Mov D$ecx+0CC Data041183E ; error here it is a pointer to code and not to data
    Mov D$ecx+0C0 Data0412645 ; error here it is a pointer to code and not to data
    Mov D$ecx+0B8 Data041268E ; error here it is a pointer to code and not to data
    Mov D$ecx+0D0 Data0412A00 ; error here it is a pointer to code and not to data
    Mov D$ecx+0C4 Data04118AF ; error here it is a pointer to code and not to data
    Mov D$ecx+0DC Data040CDD2 ; error here it is a pointer to code and not to data
    Mov D$ecx+0E0 Data040CE79 ; error here it is a pointer to code and not to data
    Mov D$ecx+0D4 Data0412AC8 ; error here it is a pointer to code and not to data
    Mov D$ecx+0BC Data04126D1 ; error here it is a pointer to code and not to data
    Mov D$ecx+0C8 Data0411983 ; error here it is a pointer to code and not to data
    Mov D$ecx+010 Data0410FBF ; error here it is a pointer to code and not to data
    Mov D$ecx+0B4 Code040CF1E
    Mov D$ecx+0E8 Code0412200
    Mov D$ecx+0E4 Code0412340 | je H6>  ; Code040708C
    test ah 02 | je H6>  ; Code040708C
    Mov D$ecx+03C Code0412072
    Mov D$ecx+048 Code0410CDD
    Mov D$ecx+098 Data040E14A ; error here it is a pointer to code and not to data
    Mov D$ecx+09C Code040FB89
    Mov D$ecx+060 Data040C7D2 ; error here it is a pointer to code and not to data
    
Code040708C: H6:
    test al 040 | je A0>  ; Code04070E0
    Mov D$ecx+0F8 Code040BE40
    Mov D$ecx+0FC Code040BEE0
    Mov D$ecx+0100 Data040C200 ; error here it is a pointer to code and not to data
    Mov D$ecx+0EC Data040B7C0 ; error here it is a pointer to code and not to data
    Mov D$ecx+0F0 Data040BA20 ; error here it is a pointer to code and not to data
    Mov D$ecx+0F4 Data040BC80 ; error here it is a pointer to code and not to data
    Mov D$ecx+0104 Code040B700
    Mov D$ecx+0110 Code040B640
    
Code04070E0: A0:
    ret


You will also note that even fixing this we have other errors like it may result in this (After fixing the Data to Code problem):

Code040C47C: M4:
    Mov edx D$esp+0C
    Mov eax D$esp+08
    movq MM2 Q$edx 
    movq MM3 Q$edx+08
    movq MM4 MM2
    movq MM5 MM3
    movq MM0 Q$eax 
    punpckhdq MM4 MM2
    punpckhdq MM5 MM3
    movq MM1 Q$eax+08
    punpckldq MM4 MM2
    punpckldq MM5 MM3
    Mov eax D$esp+04
    movq MM6 MM4
    movq MM7 MM5
    psrlw MM6 Q$edi+ecx+089E02DEF ; Error Here
    inc ecx
    add B$edi  cl
    psubusb MM6 Q$edi+ecx+089E015EF
    inc ecx
    add B$edi  cl
    psubsb MM6 Q$edi+ecx+0FB4E10F
    psrlq MM3 Q$esi+0F1A6F0F
    pmulhw MM3 Q$edx+086A6F0F
    psubw MM6 Q$edi+ecx+089E035EF
    inc ecx
    add B$edi  cl
    psrad MM5 Q$esi+0B4F00F0F
    pxor MM5 Q$Data04189E0
    psubusb MM6 Q$edi+ecx+0F0F207F
jmp 0F74FD4B7

But the correct is:
Code040C47C: M4:

.text:0040C47C                 Mov     edx, [esp+0Ch]
.text:0040C480                 Mov     eax, [esp+8]
.text:0040C484                 movq    mm2, qword ptr [edx]
.text:0040C487                 movq    mm3, qword ptr [edx+8]
.text:0040C48B                 movq    mm4, mm2
.text:0040C48E                 movq    mm5, mm3
.text:0040C491                 movq    mm0, qword ptr [eax]
.text:0040C494                 punpckhdq mm4, mm2
.text:0040C497                 punpckhdq mm5, mm3
.text:0040C49A                 movq    mm1, qword ptr [eax+8]
.text:0040C49E                 punpckldq mm4, mm2
.text:0040C4A1                 punpckldq mm5, mm3
.text:0040C4A4                 Mov     eax, [esp+4]
.text:0040C4A8                 movq    mm6, mm4
.text:0040C4AB                 movq    mm7, mm5
.text:0040C4AE                 pfmul   mm2, mm1
.text:0040C4B2                 pxor    mm5, ds:qword_4189E0
.text:0040C4B9                 pfmul   mm3, mm0
.text:0040C4BD                 pxor    mm2, ds:qword_4189E0
.text:0040C4C4                 pfmul   mm5, mm0
.text:0040C4C8                 pfmul   mm4, mm1
.text:0040C4CC                 pfadd   mm2, mm3
.text:0040C4D0                 movq    mm3, qword ptr [edx]
.text:0040C4D3                 pfsub   mm4, mm5
.text:0040C4D7                 movq    mm5, qword ptr [edx+8]
.text:0040C4DB                 pfmul   mm7, mm1
.text:0040C4DF                 pxor    mm6, ds:qword_4189E0
.text:0040C4E6                 pfacc   mm4, mm2
.text:0040C4EA                 pfmul   mm6, mm0
.text:0040C4EE                 pxor    mm5, ds:qword_4189E0
.text:0040C4F5                 pfmul   mm3, mm0
.text:0040C4F9                 movq    qword ptr [eax], mm4
.text:0040C4FC                 pfmul   mm5, mm1
.text:0040C500                 pfadd   mm6, mm7
.text:0040C504                 pfsub   mm5, mm3
.text:0040C508                 pfacc   mm6, mm5
.text:0040C50C                 movq    qword ptr [eax+8], mm6
.text:0040C510                 femms
.text:0040C512                 retn    0Ch
.text:0040C515 ; ---------------------------------------------------------------------------


;;




;;

Guga changes
a)

                    Else_If B$esi-1 = 0E9
                        test B$eax EVOCATED | jz L1>
                      ; 2 or more JMP Instructions to the same location:
                        ;or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                        ; GugaNote This is a jmp Call
                        or B$eax NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                        Mov ebx eax | sub ebx D$RoutingMap | add ebx D$SectionsMap
                        Mov B$ebx CODEFLAG
                        jmp L5>
                        
b)

This is for the JCC
    While edi < edx
        If B$esi > 3
            On B$edi = 0, Mov B$edi CODEFLAG
            On B$edi = CODEFLAG, Mov B$ebx INSTRUCTION+EVOCATED+LABEL+ACCESSED;+PUSH_EBP
        End_If
        inc esi, edi, ebx
    End_While
;;


;;

More errors.

On ntdll.dll (D:\RosAsm\dlls\NewDlls)

Here:

    Mov D$eax+0BC es                  ; 8C 88 BC 00 00 00 
    Mov D$eax+098 es                  ; 8C 98 98 00 00 00 
    Mov D$eax+094 es                  ; 8C 80 94 00 00 00 
    Mov D$eax+090 es                  ; 8C A0 90 00 00 00 
    Mov D$eax+08C es                  ; 8C A8 8C 00 00 00 
    Mov D$eax+0C8 es                  ; 8C 90 C8 00 00 00 
    Mov D$eax  010007                 ; C7 00 07 00 01 00 
    Push 01                           ; 6A 01 
    Push eax                          ; 50 
    Push D$ebp+08                     ; FF 75 08 
    Call Code078468A5C                ; E8 29 C5 FD FF 
(...)
    Call Code07848C4A0                ; E8 48 FF FF FF 
RtlRaiseStatus:: Code07848C558: P2:

The "es" is repeated. It dhould be:

    Mov D$eax+0BC cs                  ; 8C 88 BC 00 00 00 
    Mov D$eax+098 ds                  ; 8C 98 98 00 00 00 
    Mov D$eax+094 es                  ; 8C 80 94 00 00 00 
    Mov D$eax+090 fs                  ; 8C A0 90 00 00 00 
    Mov D$eax+08C gs                  ; 8C A8 8C 00 00 00 
    Mov D$eax+0C8 ss                  ; 8C 90 C8 00 00 00 
    Mov D$eax  010007                 ; C7 00 07 00 01 00 
    Push 01                           ; 6A 01 
    Push eax                          ; 50 
    Push D$ebp+08                     ; FF 75 08 
    Call Code078468A5C                ; E8 29 C5 FD FF 
(...)
    Call Code07848C4A0                ; E8 48 FF FF FF 
RtlRaiseStatus:: Code07848C558: P2:


The error was here:

WriteEffectiveAddressFromModRm:  ; 044 00_100_100
(...)

    .Else_If al = 2
        Call StartEffectiveAddress | RmMask bl To al

        If al = 0      | Mov D$edi 'eax+' | add edi 4
        Else_If al = 1 | Mov D$edi 'ecx+' | add edi 4
        Else_If al = 2 | Mov D$edi 'edx+' | add edi 4
        Else_If al = 3 | Mov D$edi 'ebx+' | add edi 4
        Else_If al = 4 | Call WriteFromSib
            ..If B$edi-1 <> '+'
                Mov B$edi '+' | inc edi
            ..End_If
        Else_If al = 5 | Mov D$edi 'ebp+' | add edi 4
        Else_If al = 6 | Mov D$edi 'esi+' | add edi 4
        Else           | Mov D$edi 'edi+' | add edi 4
        End_If

        ; Call Writedis32 ; ----> Here was the error. The values of eax and ebx was changing
        Push ebx | Push eax | Call Writedis32 | Pop eax | Pop ebx ; --> This was my preliminary fix.

    .Else ; bl = 3

The 1st fix i made was only a palleative way to retrieve back the values of eax and ebx in order to don´t change
the values of bl and al, but this is not the proper way to go, because we have several other functions that Call to
this Writedis32 and also in some functions below or after it.

All of those surrounding functions changes the values, because they are not preserved. The functions are top-down, like:

WriteBase5dis32: ; starting address
    If B$edi-1 <> '+'
        Mov B$edi '+' | inc edi
    End_If

WriteDis32:
    If B$AddressSizeOverride = &FALSE
        lodsd
    Else
        lodsw | and eax 0FFFF | Call WriteEax | ret
    End_If

WriteDisRelative:
    Mov D$LastCodeRef eax | On eax = 0, jmp L8>>

L0: If B$SimpleScan = &TRUE
        Mov B$DisFlag DISDONE+DISLINEOVER | ret
    End_If

So i fix it all only adding a Proc macro and a use macro in all functinos and adding a Call to the next function in sequence,
like this:


Proc WriteBase5dis32:
    Uses eax, ebx, ecx, edx
    
    If B$edi-1 <> '+'
        Mov B$edi '+' | inc edi
    End_If
    Call WriteDis32
EndP

Proc WriteDis32:
    Uses eax, ebx, ecx, edx

    If B$AddressSizeOverride = &FALSE
        lodsd
    Else
        lodsw | and eax 0FFFF | Call WriteEax | ExitP;ret
    End_If
    Call WriteDisRelative
EndP

Proc WriteDisRelative:
    ;Uses eax, ebx, ecx, edx ; Maybe not use eax here bccause of  | jnz WriteDisRelative
    Uses ebx, ecx, edx ; Maybe not use eax here

    Mov D$LastCodeRef eax | On eax = 0, jmp L8>>

L0: If B$SimpleScan = &TRUE
        Mov B$DisFlag DISDONE+DISLINEOVER | ExitP;ret
    End_If

L0: On B$WeAreInTheCodeBox = &TRUE, jmp L8>>

    sub eax D$DisImageBase | add eax D$SectionsMap

    On eax >= D$EndOfSectionsMap, jmp L8>>
    On eax <= D$SectionsMap, jmp L8>>

    Mov B$ToJumpsTable &FALSE
    Mov al B$eax | and al DATAFLAG+VIRTUALFLAG+IMPORTFLAG+CODEFLAG+CONSTANTFLAG

    ..If al = 0
        Mov eax D$LastCodeRef

        Mov ebx eax | sub ebx D$DisImageBase | add ebx D$SizesMap

            .If B$LeaInstruction = &TRUE
               ; or B$ebx POINTER | Mov B$LeaInstruction &FALSE
            .Else_If W$edi-2 = 'B$'
                or B$ebx BYTE
                sub ebx D$SizesMap | add ebx D$SectionsMap | Mov B$ebx DATAFLAG
            .Else_If W$edi-2 = 'W$'
                or B$ebx WORD
                sub ebx D$SizesMap | add ebx D$SectionsMap
                Mov B$ebx DATAFLAG, B$ebx+1 DATAFLAG
            .Else_If W$edi-2 = 'D$'
                or B$ebx DWORD
                sub ebx D$SizesMap | add ebx D$SectionsMap
                Mov D$ebx FOURDATAFLAGS
            .Else_If W$edi-2 = 'F$'
                or B$ebx FP4
                sub ebx D$SizesMap | add ebx D$SectionsMap
                Mov D$ebx FOURDATAFLAGS
            .Else_If W$edi-2 = 'R$'
                or B$ebx FP8
                sub ebx D$SizesMap | add ebx D$SectionsMap
                Mov D$ebx FOURDATAFLAGS, D$ebx+4 FOURDATAFLAGS
            .Else_If W$edi-2 = 'T$'
                or B$ebx FP10
                sub ebx D$SizesMap | add ebx D$SectionsMap
                Mov D$ebx FOURDATAFLAGS, D$ebx+4 FOURDATAFLAGS, D$ebx+6 FOURDATAFLAGS
            .Else
                jmp L8>>
               ; or B$ebx POINTER
            .End_If

    ..Else_If al = DATAFLAG
        Mov eax D$LastCodeRef | Call StoreDisSize
        sub eax D$DisImageBase | add eax D$RoutingMap | or B$eax LABEL+EVOCATED
        Mov D$edi 'Data' | add edi 4 | jmp L8>>

    ..Else_If al = CODEFLAG
      ; Is it a Call to a Jumps Table?
        Mov eax D$LastCodeRef
        sub eax D$DisImageBase | add eax D$UserPeStart

        If W$eax = 025FF ; Code of jmp relative long
            Mov ebx D$eax+2 | sub ebx D$DisImageBase | add ebx D$SectionsMap
            On ebx > D$EndOfSectionsMap, jmp L1>
            On ebx < D$SectionsMap, jmp L1>
                On B$ebx <> IMPORTFLAG, jmp L1>

                    Mov B$ApiCommentWanted &TRUE, ebx D$eax+2, D$PtrToApiName ebx

                  ; On B$WithSymbolicsAnalyzes = &FALSE, Mov B$ToJumpsTable &TRUE
;                    Push eax
;                        Mov al B$WithSymbolicsAnalyzes | xor al &TRUE
;                        Mov B$ToJumpsTable al
;                        On B$WithoutJumpsTableCalls = &TRUE, Mov B$ToJumpsTable &FALSE
;                    Pop eax
;                    Mov ebx D$eax+2 | jmp L5>>
        End_If

L1:     Mov eax D$LastCodeRef
        sub eax D$DisImageBase | add eax D$RoutingMap
        test B$eax INSTRUCTION | jz L8>>
        or B$eax NODE+LABEL | Mov D$edi 'Code' | add edi 4 | jmp L8>>

    ..Else_If al = VIRTUALFLAG
        Mov eax D$LastCodeRef | Call StoreDisSize
        sub eax D$DisImageBase | add eax D$RoutingMap | or B$eax LABEL+EVOCATED
        Mov D$edi 'Virt', D$edi+4 'ual ' | add edi 7 | jmp L8>>

    ..Else_If al = CONSTANTFLAG
L1:     Mov eax D$LastCodeRef | Call StoreDisSize
        sub eax D$DisImageBase | add eax D$RoutingMap | or B$eax LABEL+EVOCATED
        Mov D$edi 'Cons', D$edi+4 'tant', B$edi+8 SPC | add edi 8 | jmp L8>>

    ..Else_If al = IMPORTFLAG
        Mov ebx D$LastCodeRef
L5:     sub ebx D$DisImageBase | add ebx D$UserPeStart | Mov ebx D$ebx
      ; May be a wrong pointing inside the .Import!
      ; Add a Pointer test!
        On ebx < D$ApiBuffer, ExitP;ret
        On ebx >= D$EndOfApiBuffer, ExitP;ret

        Push esi

            On W$edi-2 = 'D$', sub edi 2

            Mov esi ebx

            .If D$edi-4 = 'jmp '    ; Jumps Table?
                Call WriteApiJmpTableLabel

                While B$esi <> 0 | movsb | End_While

            .Else_If D$edi-4 = 'all '  ; Call api?
                Call FlagNoReturnApi
                Call FlagApiProcedures
                While B$esi <> 0 | movsb | End_While

          ; Other case: Either "Mov eax D$ApiCall" or "Mov D$eax ApiCall"
            .Else
                Push edi
                    Mov al "'"
                    While B$edi > LF
                        dec edi
                        On B$edi = '$', Mov al 0
                    End_While
                Pop edi
                Mov esi ebx
                If al = 0
                    While B$esi <> '.' | inc esi | End_While | inc esi
                End_If
                While B$esi <> 0 | movsb | End_While
                On al = 0, dec edi

            .End_If
        Pop esi

     ..End_If

    ExitP;ret
______________________________________________
; Note to René: All of this is for your Tests ?

L7:         Pop ebx, eax, esi
            Mov B$edi ':' | inc edi | NextDisLine

            Mov D$edi 'jmp ' | add edi 4
        .End_If
ExitP;ret

       ; If B$ToJumpsTable = &FALSE
       ;     Mov B$edi "'" | inc edi
       ; End_If
        Push esi
            Mov esi ebx | While B$esi <> 0 | movsb | End_While
        Pop esi
      ;  Mov eax D$edi-4 | or eax 0202020 | On eax = '.dll' | sub edi 4
      ;  Mov B$edi '.' | inc edi
;      ; Switch to the real Import for reading the Pointer to Function Name:
;        sub ebx D$RoutingMap | add ebx D$UserPeStart
;        Test D$ebx 0_8000_0000 | jnz L6>
;            Push esi
;                Mov esi D$ebx | add esi 2 | add esi D$UserPeStart
;                If esi < D$UserPeStart
;D0:                 Mov B$DisFlag DISFAILED | Pop esi | ret
;                Else_If esi > D$UserPeEnd
;                    jmp D0<
;                End_If
;                While B$esi <> 0 | movsb | End_While
;            Pop esi
;            If B$ToJumpsTable = &FALSE
;                Mov B$edi "'" | inc edi
;            End_If
            ExitP;ret

;L6:     Mov eax D$ebx | xor eax 0_8000_0000 | Call WriteEax
;        If B$ToJumpsTable = &FALSE
;            Mov B$edi "'" | inc edi
;        End_If
        ExitP;ret

    ..Else_If al = 0
        Mov ebx D$LastCodeRef
        sub ebx D$DisImageBase | add ebx D$RoutingMap
        Mov eax D$ebx
        If eax = 0
            sub ebx D$RoutingMap | add ebx D$SectionsMap
            Mov B$ebx CONSTANTFLAG | jmp L1<<
        End_If
    ..End_If
_______________________________________

L8: On B$WeAreInTheCodeBox = &FALSE, jmp L8>
    On D$LibFileMemory = 0, jmp L8>
        Push esi
            Mov esi D$LastCodeRef
            .If esi > D$LibFileMemory
                Mov eax D$LibFileMemory | add eax D$LibFileLength
                If esi < eax
                    While B$esi <> 0 | movsb | End_While
                   ; Mov D$edi ' ; <', D$edi+4 '<<<<' | add edi 8
                Else
                    Pop esi | jmp L8>
                End_If
            .Else
                Pop esi | jmp L8>
            .End_If
        Pop esi
        ExitP;ret

L8: ;On D$LastCodeRef = 0438E28, int3

    .If B$edi-1 = '+'
        If W$edi-3 = '*2'
            Call TryWithIndice 2
        Else_If W$edi-3 = '*4'
            Call TryWithIndice 4
        Else_If W$edi-3 = '*8'
            Call TryWithIndice 8
        End_If
    .End_If

    If W$DisplacementFromLabel = 0
        Mov eax D$LastCodeRef | sub eax D$DisImageBase | add eax D$SizesMap
        Mov ebx D$SizesMap | add ebx 4
        On eax < ebx, jmp L8>
        On eax > D$EndOfSizesMap, jmp L8>
        test B$eax-4 FP8 | jz L8>
            sub D$LastCodeRef 4 | Mov W$DisplacementFromLabel '+4'
    End_If

L8: Push 0-1

    Mov ebx D$LastCodeRef

L0: Mov eax ebx | shr ebx 4 | and eax 0F
    add eax '0' | On eax > '9', add eax 7
    Push eax
    cmp ebx 0 | ja L0<

    Mov B$edi '0' | inc edi
L0: Pop eax | cmp eax 0-1 | je L9>
    Mov B$edi al | inc edi | jmp L0<

L9: If W$DisplacementFromLabel <> 0
        Mov ax W$DisplacementFromLabel | stosw
        Mov W$DisplacementFromLabel 0
    End_If

    Mov eax D$LastCodeRef | sub eax D$DisImageBase | add eax D$SectionsMap

    .If eax < D$SectionsMap
        ;
    .Else_If eax < D$EndOfSectionsMap
        If B$eax = DATAFLAG
            sub eax D$SectionsMap | add eax D$RoutingMap | or B$eax LABEL+EVOCATED
        End_If
    .End_If

    On B$ApiCommentWanted = &TRUE, Call WriteApiLabelComment
;ret
EndP



------------------------

i Also changed here:


BuildTruthAsciiTable:
    VirtualAlloc TruthAsciiTable 256
    Mov edi D$TruthAsciiTable, al BADASCII, ecx 256 | rep stosb

    Mov edi D$TruthAsciiTable, B$edi 0
    Mov B$edi+LF GOODASCII, B$edi+CR GOODASCII,
        B$edi+0A7 GOODASCII,    ; $
        B$edi+025 GOODASCII,    ; %
        B$edi+0A9 GOODASCII,    ; ®
        B$edi+02F GOODASCII     ; /

    Mov ebx 32, ecx 127;8
    While ebx =< ecx
        Mov B$edi+ebx GOODASCII | inc ebx
    End_While

  ; 128 - 32 + 6 > 102
ret

Chars 127 and 128 are not Good Ascii
;;







;;
    lstrcmpi

    This function compare two Null Terminated Ascii strings (With the same size or not). It looks for the
    Language version of your system to order the Strings.
    The functionality is exactly the same as on lstrcmpiA inside Kernel32.dll.
    
    Arguments:
    
    String1:    First ascii null terminated to be inputed
    String2:    Second ascii null terminated to be inputed
    
    Return Values:
        If the Strings are the same, eax returns 0
        If the 1st String alphabetically preceeds the 2nd String, eax returns 0-1.
        If the 1st String is alphabetically located after the 2nd String, eax returns 1.
        
    Example of usage and their return values:

    Call lstrcmpi {B$ "AB" EOS} {B$ "AB" EOS} ; Eax = 0
    Call lstrcmpi {B$ "AB" EOS} {B$ "CD" EOS} ; Eax = 0-1
    Call lstrcmpi {B$ "CD" EOS} {B$ "AB" EOS} ; Eax = 1
    Call lstrcmpi {B$ "RosAsm" EOS} {B$ "Assembly" EOS} ; Eax = 1
    Call lstrcmpi {B$ "Assembly" EOS} {B$ "RosAsm" EOS} ; Eax = 0-1
    
    Note: If you are using this function to organize (list) strings. The starting order in crescent sttrings.
    Like the following list of strings:
        
        Home, House, Indian, RosAsm, Slovak, Story

    If you are trying to build a list of strings without having to use the Languiage definitions of your system, use
    the functions:
    
    strcmp - The same functionality as this lstrcmpi, but built on a simplified way to not use the Lang definitions.
             It will displays the order of strings in crescent order.

    stricmp - The same functionality as this lstrcmpi, but built on a simplified way to not use the Lang definitions.
             It will displays the order of strings in decrescent order.
;;
;;
Proc lstrcmpi:
    Arguments @String1, @String2
    uses ebx, esi, ecx, edx

    Call 'KERNEL32.GetThreadLocale'
    Call 'KERNEL32.CompareStringA' eax, &LOCALE_ILANGUAGE__&LOCALE_USE_CP_ACP, D@String1, 0-01, D@String2, 0-1

    ...If eax = 0

        Call 'KERNEL32.GetSystemDefaultLCID'
        Call 'KERNEL32.CompareStringA' eax, &LOCALE_ILANGUAGE__&LOCALE_USE_CP_ACP, D@String1, 0-01, D@String2, 0-1

        ..If eax = 0

            .If D@String1 <> 0

                If D@String2 <> 0
                    Call stricmp D@String1, D@String2
                Else_If D@String1 <> 0 ; There is an error on the original dll. This may be eax and not String1
                    Mov eax 1
                Else
                    Mov eax D@String2
                    neg eax
                    sbb eax eax
                End_If
                ExitP

            .End_If

            Mov eax D@String2
            neg eax
            sbb eax eax
            ExitP

        ..End_If

    ...End_If

    add eax 0-02

EndP




;;
;;
    Stricmp

    This function compare two Null Terminated Ascii strings (With the same size or not). It is a simplified version
    of lstrcmpi from kernel32.dll, with the diference that in this function it does not look for the
    Language version of your system, and also it reverses the order if a user is building a List of Strings.
    For example, on lstrcmpi the initial order of a String Listings is crescent. On this function the starting order
    is decrescent.
    The functionality is exactly the same as on _stricmp and _strcmpi inside ntdll.dll.
    It handle only latin alphabet without accents. So, only vowels and consonants from A to Z.
    
    To display a list of files in crescent alphabetical order, use Strcmp function.
    
    Arguments:
    
    String1:    First ascii null terminated to be inputed
    String2:    Second ascii null terminated to be inputed
    
    Return Values:
        If the Strings are the same, eax returns 0
        If the 1st String alphabetically preceeds the 2nd String, eax returns 1.
        If the 1st String is alphabetically located after the 2nd String, eax returns 0-1.
        
    Example of usage and their return values:
        
    Call stricmp {B$ "AB" EOS} {B$ "AB" EOS} ; Eax = 0
    Call stricmp {B$ "AB" EOS} {B$ "CD" EOS} ; Eax = 1
    Call stricmp {B$ "CD" EOS} {B$ "AB" EOS} ; Eax = 0-1
    Call stricmp {B$ "RosAsm" EOS} {B$ "Assembly" EOS} ; Eax = 0-1
    Call stricmp {B$ "Assembly" EOS} {B$ "RosAsm" EOS} ; Eax = 1
    
    Note: Used Macros. Default RosAsm macro system, plus:
    
    [If_And    | If #1 #2 #3    | #+3]
    [.If_And   | .If #1 #2 #3   | #+3]
    [..If_And  | ..If #1 #2 #3  | #+3]
    [...If_And | ...If #1 #2 #3 | #+3]

    [Else_If_And    | Else    | If_And    #F>L]
    [.Else_If_And   | .Else   | .If_And   #F>L]
    [..Else_If_And  | ..Else  | ..If_And  #F>L]
    [...Else_If_And | ...Else | ...If_And #F>L]

    If you are using this function to organize (list) strings. The starting order in decrescent strings.
    Like the following list of strings:
        
        Story, Slovak, RosAsm, Indian, House, Home

;;
;;
Proc stricmp:
    Arguments @String1, @String2
    Uses edi, esi, ebx

    Mov esi D@String2
    Mov edi D@String1
    Mov al 0FF


    .Do
        Do
            On al = 0, jmp L2>
            Mov al B$esi
            inc esi
            Mov ah B$edi
            inc edi
        Loop_Until ah <> al

        ; Lower case convertion
        If_And al >= 'A', al <= 'Z'
            xor al 32
        End_If

        If_And ah >= 'A', ah <= 'Z'
            xor ah 32
        End_If

    .Loop_Until al <> ah
    sbb al al
    sbb al 0-1
L2:
    movsx eax al

EndP
;;
____________________________________________________________________________________________

;;
    String2Dword

    This function converts a Null Terminated Decimal Ascii String to a 32 Bits Dword Value.
    
    Arguments:
    
    String:    The inputed String to be converted
    
    Return Values:
        If the function suceeds eax returns the value of the dword string.
        If the function fails eax returns 0.
;;
;;
Proc String2Dword:
    Arguments @String
    Local @Result
    Uses ecx, edi, edx, esi

    Mov D@Result 0
    Mov edi D@String
    Mov ecx D@String
    On ecx = 0, ExitP

    Call StrLenProc edi

    .While B$ecx <> 0

        xor edx edx
        Mov dl B$edi
        sub dl '0'  ; subtrack each digit with "0" to convert it to hex value
        Mov esi eax
        dec esi
        Push eax
            Mov eax edx
            Push ebx
                Mov ebx 10;0A
                While esi > 0
                    mul ebx
                    dec esi
                End_While
            Pop ebx
            add D@Result eax
        Pop eax
        inc edi
        dec eax
        inc ecx
    .End_While
    Mov eax D@Result

EndP
;;
____________________________________________________________________________________________

;;
    Strcmp

    This function compare two Null Terminated Ascii strings (With the same size or not). It is a simplified version
    of lstrcmpi from kernel32.dll, with the diference that in this function it does not look for the
    Language version of your system. It also displays the same order if a user is building a List of Strings.
    For example, on lstrcmpi the initial order of a String Listings is crescent. On this function the starting order
    is also crescent.
    It handle only latin alphabet without accents. So, only vowels and consonants from A to Z.
    
    To display a list of files in decrescent alphabetical order, use Stricmp function.
        
    Arguments:
    
    String1:    First ascii null terminated to be inputed
    String2:    Second ascii null terminated to be inputed
    
    Return Values:
        If the Strings are the same, eax returns 0
        If the 1st String alphabetically preceeds the 2nd String, eax returns 0-1.
        If the 1st String is alphabetically located after the 2nd String, eax returns 1.
        
    Example of usage and their return values:
        
    Call strcmp {B$ "AB" EOS} {B$ "AB" EOS} ; Eax = 0
    Call strcmp {B$ "AB" EOS} {B$ "CD" EOS} ; Eax = 0-1
    Call strcmp {B$ "CD" EOS} {B$ "AB" EOS} ; Eax = 1
    Call strcmp {B$ "RosAsm" EOS} {B$ "Assembly" EOS} ; Eax = 1
    Call strcmp {B$ "Assembly" EOS} {B$ "RosAsm" EOS} ; Eax = 0-1
    
    Note: Used Macros. Default RosAsm macro system, plus:
    
    [If_And    | If #1 #2 #3    | #+3]
    [.If_And   | .If #1 #2 #3   | #+3]
    [..If_And  | ..If #1 #2 #3  | #+3]
    [...If_And | ...If #1 #2 #3 | #+3]

    [Else_If_And    | Else    | If_And    #F>L]
    [.Else_If_And   | .Else   | .If_And   #F>L]
    [..Else_If_And  | ..Else  | ..If_And  #F>L]
    [...Else_If_And | ...Else | ...If_And #F>L]

    Note: If you are using this function to organize (list) strings. The starting order in crescent sttrings.
    Like the following list of strings:
        
        Home, House, Indian, RosAsm, Slovak, Story

;;
;;
Proc strcmp:
    Arguments @String1, @String2
    Uses edi, esi, ebx

    Mov esi D@String1
    Mov edi D@String2
    Mov al 0FF


    .Do
        Do
            On al = 0, jmp L2>
            Mov al B$esi
            inc esi
            Mov ah B$edi
            inc edi
        Loop_Until ah <> al

        ; Lower case convertion
        If_And al >= 'A', al <= 'Z'
            xor al 32
        End_If

        If_And ah >= 'A', ah <= 'Z'
            xor ah 32
        End_If

    .Loop_Until al <> ah
    sbb al al
    sbb al 0-1
L2:
    movsx eax al

EndP


[szBuff0: B$ ? # &MAX_PATH]

[BASE_HEX 16, BASE_DEC 10, BASE_OCT 8, BASE_FOUR 4, BASE_BIN 2]

Proc AsciiBase:
    Arguments @String, @Base
    Uses esi, ebx, edx

        Mov esi D@String, eax 0, ebx 0

        While B$esi <> 0
            Mov eax ebx | mul D@Base | Mov ebx eax, eax 0
            Mov al B$esi | sub al '0'
          ; Cases of Hexa Notation:
            On al > 9, sub al 7
            add ebx eax | inc esi
        End_While

        Mov eax ebx
EndP
;;
;;
    Strcpy

    This function copies a Null Terminated String to a Buffer. The size of the Buffer must be bigger or equal to the
    size of the string.
    It have the same functionality as lstrcpyA in kernel32.dll
    
    Arguments:
    
    InBound:    The inputed String
    
    OutBound:   The Buffer which will hold the String.
    
;;
;;
Proc strcpy:
    Arguments @OutBound, @InBound
    Uses ecx, esi, edi

    xor ecx ecx
    Mov esi D@InBound

    Do
        inc ecx
        inc esi
    Loop_Until B$esi = 0

    Mov esi D@InBound | Mov edi D@OutBound | rep movsb
    Mov B$edi 0

EndP
;;
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE DATAS           ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

@PREFIXES:

;;
    
    !!! Pay attention, this is very important:
    
    - All global data declarations must be placed in this TITLE:
      Wether data or structures of data, initialized or virtuel
     
    - All variable's names are implicitly Lp(pointers)
     
    - Never create a variable name without a Prefix.
      ~~~~~                        ~~~~~~~~~~~~~~~~
    - Data must stay aligned with their types : 16 ,8 , 4 , 2 , 1 bytes
    
    - They also MUST be in their category:
    
    
    !!! Attention très important:

    - TOUTES les déclarations de datas à portée globale doivent se trouver dans ce TITLE:
      Que ce soit des datas ou des structures de datas, initialisées ou vituelles

    - Tous les noms de variables sont des Lp implicites
   
    - Ne créez jamais de nom de variable sans préfixe
               ~~~~~~                    ~~~~~~~~~~~~ 
    - Les datas doivent rester alignées selon leur type: 16, 8, 4, 2, 1 octets/bytes

    - Etre rangées dans leur catégorie:

       <16 [INITIALISED_DATAS_128]           [VIRTUAL_DATAS_128]
       
       <8  [INITIALISED_TABLES_64]           [VIRTUAL_TABLES_64]

       <8  [INITIALISED_DATAS_64]            [VIRTUAL_DATAS_64]

       <4  [INITIALISED_DATAS_32]            [VIRTUAL_DATAS_32]

       <4  [INITIALISED_STRUCTURES_32]       [VIRTUAL_STRUCTURES_32]
     
       <4  [INITIALISED_TABLES_32]           [VIRTUAL_TABLES_32]
      
       <4  [INITIALISED_BUFFER_32]           [VIRTUAL_BUFFER_32]
 
       <4  [INITIALISED_STRINGS_ASCII_32]    [VIRTUAL_STRINGS_ASCII_32]

       <4  [INITIALISED_STRINGS_UNICODE_32]  [VIRTUAL_STRINGS_UNICODE_32]

       <2  [INITIALISED_DATAS_16]            [VIRTUAL_DATAS_16]

       <1  [INITIALISED_DATAS_8]             [VIRTUAL_DATAS_8]

    - Be sorted out by prefixs / Etre rangées par préfixe

      Préfix:  Type:   Align: Signé/Non-signé:     Initialisée:  Virtuelle:
      BS.      [BYTE]  <01... +/-................. [BS.i]....... [BS.v]
      BU.      [BYTE]  <01... + .................. [BU.i]....... [BU.v]
      BUFFER.x [DWORD] <04... Lp -> BUFFER.Type... [BUFFER.BU.i] [BUFFER.BU.v] 
      DS.      [DWORD] <04... +/-................. [DS.i]....... [DS.v]
      DU.      [DWORD] <04... +  ................. [DU.i]....... [DU.v]
      F.       [FLOAT] <04... +/-................. [F.i]........ [F.v]
      FL.      [DWORD] <04... Flag TRUE/FALSE..... [FL.i]....... [FL.v]
      FLM.     [DWORD] <04... Flags masque........ [FLM.i]...... [FLM.v]
      H.       [DWORD] <04... Handle.............. [H.i]........ [H.v]
      HDC      [DWORD] <04... H display........... [HDC.i]...... [HDC.v]
      HCDC     [DWORD] <04... H display compatible [HCDC.i]..... [HCDC.v]
      ID.      [DWORD] <04... Id +/- +............ [ID.i]....... [ID.v]
      LP.      [DWORD] <04... Lp -> Lp............ [LP.i]....... [LP.v]
      Q.       [QWORD] <08....+................... [Q.i]........ [Q.v]
      R.       [REEL]  <08... +/-................. [R.i]........ [R.v]
      STRUC.   [DWORD] <04... Lp -> Structure..... [STRUC.i].... [STRUC.v]
      STR.x    [DWORD] <04... String ASCII/UNICODE [STR.A.i]...  [STR.A.v]
      TABLE.x  [DWORD] <04/08 Lp -> TABLE.Type.... [TABLE.BU.i]. [TABLE.BU.v]
      WS.      [WORD]  <02... +/-................. [WU.i]....... [WU.v]
      WU.      [WORD]  <02... + .................. [WS.i]....... [WS.v]
      XR.      [XWORD] <16... 02*[REEL] +/-....... [XR.i]....... [XR.v]
      XF.      [XWORD] <16... 04*[FLOAT] +/-...... [XF.i]....... [XF.v]
      XDS.     [XWORD] <16... 04*[DWORD] +/-...... [XDS.i]...... [XDS.v]
      XDU.     [XWORD] <16... 04*[DWORD] +........ [XDU.i]...... [XDU.v]
      XW.      [XWORD] <16... 08*[WORD] +......... [XW.i]....... [XW.v]
      XB.      [XWORD] <16... 16*[BYTE] +......... [XB.i]....... [XB.v]

    - In their Prefix, they must be in alphabetic order 
    
    - Etre, au sein des préfixes, rangées en ordre alphabétique 
    
     For numbers (FLOAT}{REEL} refer to: / Pour les nombres [FLOAT][REEL]
     -> http://en.wikipedia.org/wiki/IEEE_754-1985
    
    OS structures have NO Prefix but are written intierly in CAP_ITAL letters 
    Les structure de l'OS n'ont pas de préfixe mais s'écrivent entièrement en MAJ_USCULES

;;
______________________

; Datas initialisées:
______________________

; Alignement sur 128 bits
[<16 @INITIALISED_DATAS_128:

 ; [BYTE] 0/255
 @XB.i: B$ 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255

 ; [DWORD] Signed / Signé 0-2147483648/+2147483647
 @XDS.i: D$ 0-2147483648 0-2147483648 0-2147483648 0-2147483648

 ; [DWORD] Unsigned / Non-signé 0/4294967295
 @XDU.i: D$ 4294967295 4294967295 4294967295 4294967295

 ; [FLOAT]
 @XF.i: F$ 3.14 3.14 3.14 3.14

 ; [REEL]
 @XR.i: R$ 3.14 3.14

 ; [WORD] 0/65535
 @XW.i: W$ 65535 65535 65535 65535 65535 65535 65535 65535

]

; Alignement sur 64 bits
[<8 @INITIALISED_TABLES_64:
 @TABLE.Q.i: Q$ 0 # 8]

; [<8...@TABLE

; Alignement sur 64 bits
[<8 @INITIALISED_DATAS_64:

 ; [QWORD] 00/0_FFFF_FFFF_FFFF_FFFF
 @Q.i: Q$ 0_FFFF_FFFF_FFFF_FFFF

 ; [REEL]
 @R.i: R$ 3.14

]

; Alignement sur 32 bits
[<4 @INITIALISED_DATAS_32:

 ; [DWORD] Signed / Signé 0-2147483648/+2147483647
 @DS.i: D$ 0-2147483648

 ; [DWORD] Unsigned / Non-signé 0/4294967295
 @DU.i: D$ 4294967295

 ; [FLOAT]
 @F.i: F$ 3.14

 ; [DWORD] Flag
 @FL.i: D$ &TRUE ; [YES]/[NO]

 ; [DWORD] Flags mask / Flags masque 00/00_11111111111111111111111111111111
 @FLM.i: D$ 00_11111111111111111111111111111111

 ; [DWORD]
 @H.i: D$ &NULL

 ; [DWORD]
 @HDC.i: D$ &NULL

 ; [DWORD]
 @HCDC.i: D$ &NULL

 ; [DWORD] Signed-Unsigned / Signé-Non-signé 0/4294967295 Ou 0-2147483648/+2147483647
 @ID.i: D$ 4294967295

 ; [DWORD]
 @LP.i: D$ &NULL

]

; Alignement sur 32 bits
[<4 @INITIALISED_STRUCTURES_32:
 @STRUC.i:
 @DU.i1: D$ 0
 @DU.i2: D$ 2
 ;...
 @BU.ix: B$ 0]

; [<4...@STC.Xxx

; Alignement sur 32 bits
[<4 @INITIALISED_TABLES_32: ; BU. BS. WU. WS. DU. DS. F. FL. FM. Q. R. LP.
 @TABLE.BU.i:
 B$ 00
 B$ 01
 B$ 02
 B$ 03
 B$ 04
 B$ 05
 B$ 06
 B$ 07
 B$ 08
 B$ 09]

; [<4...TABLE.PX.Xxx

; Alignement sur 32 bits
[<4 @INITIALISED_BUFFER_32: ; BU. BS. WU. WS. DU. DS. F. FL. FM. Q. R. LP.
 @BUFFER.BU.i: B$ 255 # 16]

; [<4...BUFFER.PX.Xxx

; Alignement sur 32 bits Lp -> ASCII
[<4 @INITIALISED_STRINGS_ASCII_32:
 @STR.A.i: B$ "*******" EOS]

; [<4...STR.A.Xxx

; Alignement sur 32 bits Lp -> UNICODE
[<4 @INITIALISED_STRINGS_UNICODE_32:
 @STR.U.i: U$ "*******" EOS]

; [<4...STR.U.Xxx

; Alignement sur 16 bits
[<2 @INITIALISED_DATAS_16:

 ; [WORD] Signed / Signé 0-32768/32767
 @WS.i: W$ 0-32767

 ; [WORD] Unsigned / Non-signé 0/65535
 @WU.i: W$ 65535

]

; Alignement sur 8 bits
[@INITIALISED_DATAS_8:

 ; [BYTE] Signed / Signé 0-128/+127
 @BS.i: B$ 0-128

 ; [BYTE] Unsigned / Non-signé 0/255
 @BU.i: B$ 255

]
____________________________________________________________________________________________
____________________

; Datas virtuelles:
____________________

; Alignement sur 128 bits
[<16 @VIRTUAL_DATAS_128:

 ; [BYTE] 0/255
 @XB.v: B$ ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?

 ; [DWORD] Signed / Signé 0-2147483648/+2147483647
 @XDS.v: D$ ? ? ? ?

 ; [DWORD] Unsigned / Non-signé 0/4294967295
 @XDU.v: D$ ? ? ? ?

 ; [FLOAT]
 @XF.v: F$ ? ? ? ?

 ; [REEL]
 @XR.v: R$ ? ?

 ; [WORD] 0/65535
 @XW.v: W$ ? ? ? ? ? ? ? ?

]

; Alignement sur 64 bits
[<8 @VIRTUAL_TABLES_64:
 @TABLE.Q.v: Q$ ? # 8]

; [<4...@TABLE

; Alignement sur 64 bits
[<8 @VIRTUAL_DATAS_64:

 ; [QWORD] 00/0_FFFF_FFFF_FFFF_FFFF
 @Q.v: Q$ ?

 ; [REEL]
 @R.v: R$ ?

]

; Alignement sur 32 bits
[<4 @VIRTUAL_DATAS_32:

 ; [DWORD] Signed / Signé 0-2147483648/+2147483647
 @DS.v: D$ ?

 ; [DWORD] Unsigned / Non-signé 0/4294967295
 @DU.v: D$ ?

 ; [FLOAT]
 @F.v: F$ ?

 ; [DWORD] Flag &TRUE/&FALSE [YES]/[NO]
 @FL.v: F$ ?

 ; [DWORD] Flags masque 00/00_11111111111111111111111111111111
 @FLM.v: D$ ?

 ; [DWORD]
 @H.v: D$ ?

 ; [DWORD]
 @HDC.v: D$ ?

 ; [DWORD]
 @HCDC.v: D$ ?

 ; [DWORD] Signed-Unsigned / Signé-Non-signé 0-2147483648/+2147483647 ou 0/4294967295
 @ID.v: D$ ?

 ; [DWORD]
 @LP.v: D$ ?

]

; Alignement sur 32 bits
[<4 @VIRTUAL_STRUCTURES_32:
 @STRUC.v:
 @DU.v1: D$ ?
 @DU.v2: D$ ?
 ;...
 @BU.vx: B$ ?]

; [<4...@STC.Xxx

; Alignement sur 32 bits
[<4 @VIRTUAL_TABLES_32: ; BU. BS. WU. WS. DU. DS. F. FL. FM. Q. R. LP.
 @TABLE.BU.v:
 B$ ? # 10]

; [<4...TABLE.PX.Xxxx

; Alignement sur 32 bits
[<4 @VIRTUAL_BUFFER_32: ; BU. BS. WU. WS. DU. DS. F. FL. FM. Q. R. LP.
 @BUFFER.BU.v: B$ ? # 16]

; [<4...BUFFER.PX.Xxx

; Alignement sur 32 bits chaînes ASCII
[<4 @VIRTUAL_STRINGS_ASCII_32:
 @STR.A.v: B$ ? # &MAX_PATH]

; [<4...STR.A.Xxxx

; Alignement sur 32 bits chaînes UNICODE
[<4 @VIRTUAL_STRINGS_UNICODE_32:
 @STR.U.v: U$ ? # &MAX_PATH]

; [<4...STR.U.Xxxx

; Alignement sur 16 bits
[<2 @VIRTUAL_DATAS_16:

 ; [WORD] Signed / Signé 0-32768 /+32767
 @WS.v: W$ ?

 ; [WORD] Unsigned / Non-signé 0/65535
 @WU.v: W$ ?

]

[@VIRTUAL_DATAS_8:

 ; [BYTE] Signed / Signé 0-128/+127
 @BS.v: B$ ?

 ; [BYTE] Unsigned / Non-signé 0/255
 @BU.v: B$ ?

]
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE ToDo            ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

;;
____________________________________________________________________________________________

What is this strange 'MemSaveFilter'?
____________________________________________________________________________________________

In some cases of RegistryData modifications, it may be corrupted.
____________________________________________________________________________________________

il manque la fonction clic droit sur les API terminées par W.

____________________________________________________________________________________________

NOPE addition on case of "empty" Macro Evocation: File with:

RosAsm/Ludwig/Noname.exe and debug_me.exe

Needs a re-organization of the Macros jobs, with intermediate copy of one Statement.
____________________________________________________________________________________________

Disassembler: Win32Dasm. At 040796E, there is a list of Pointers. Internaly, the
first one should be Flagged Code, and not Data.
____________________________________________________________________________________________

Disassembler: One Export may have severl Names Exported. Example:

        MyAdvapi32.dll: BuildExplicitAccessWithNameW / A

'WriteExportedFunctionLabel' needs another loop somewhere.
____________________________________________________________________________________________

For Guga:

Dllscanner Tool: It fails showing all Imports on WZCAB.DLL (in the [Disassembled] Folder).
____________________________________________________________________________________________

Review all EBX preservations, from 'Dis_rm8_r8'

____________________________________________________________________________________________

Review the Strings analyzes in the Disassembler. Some 9, 10, 13, are replaced by
Space, when isolated (should be the reverse).
____________________________________________________________________________________________

>     Mov D$eax+0BC   ; ----------------> Here missing the register. It 
> should be Mov D$eax+0BC es
>     Mov D$eax+098 ds
>     Mov D$eax+094 ss
>     Mov D$eax+090 ss
>     Mov D$eax+08C cs
>     Mov D$eax+0C8 cs

!!!!!!!!!!!!!!!!!!!!!!!!
____________________________________________________________________________________________

Search for (OpD1) PFMUL 3D Now.
____________________________________________________________________________________________

Extend the "Right-Click on Numbers" Functionalities (FPU? Signed Values?...)
____________________________________________________________________________________________


nop  ; <<<<<<<<< Error manager pointing here, because of the Duplication of
     ; 'SIZEOF_materials'

DeclareTable materials 1 1 SAMPLE_Material.size

[sizeof_materials 34]
[DeclareTable| {SIZEOF_#1 #2  SIZEOF_#1_CHUNK #3   SIZEOF_#1_ELEMENT #4}]

Main: Call 'KERNEL32.ExitProcess'

____________________________________________________________________________________________

I didn't realise that Q$ is only used for integers.
Maybe an entry into B_U_Asm along the lines of Scarmatil's explanation would be
appropriate?
____________________________________________________________________________________________

From 'MAXDIALOG', and friends... Make it all Dynamic as soon as possible.
____________________________________________________________________________________________

When setting a bp, the caret moves to that line.
Should not happen.
____________________________________________________________________________________________

Clip File:

Review the Doc.
____________________________________________________________________________________________

Disassembler: Looki Report, in ...\Eudora\Attach\Looki.

The last Point is a real miss-interpretation.
____________________________________________________________________________________________

'DeleteIcon':

Looki says it is possible to have left over data after removal. to be Reviewed.

____________________________________________________________________________________________


fnstv D$eax sbb D$eax <<< RightClick SBB eax 'OpCodeList' / 'SearchMneMonic'

____________________________________________________________________________________________

Linux-LINE: Chuck reports:

> As it turns out, there is a problem with the debugger. Wine handles the
> KERNEL32.VirtualQueryEx Call with its NtQueryVirtualMemory routine, and
> returns "Unsupported on other process", causing the debugger to display
> "VirtualQueryEx reported error".
____________________________________________________________________________________________

[list - tree/import/export] Not assuming anything but Call '...'.
____________________________________________________________________________________________

Error-Box with Copy&Paste enable.
____________________________________________________________________________________________

Error Message window:
It should be possible to copy text from the edits.
There should be no cursor.
The window should be fixed. Not sizeable. 
____________________________________________________________________________________________

2. There is a cursor in the error message window, and it is possible to read and write inside the EDITs.
What for? It's funny...
____________________________________________________________________________________________

Code Completion:
When RosAsm can't find the equate, a messagebox pops and asks if you want to build a list, and takes the focus from the Editor.
This is a VERY annoying way to tell you that you mistyped an equate.
It has do be done maybe like that:
* If matched completion found, underline (and bold?).
* when no longer matches, remove the line (or if choosed to bold, unbold?).
* If the last chars were deleted and it matches again, put the underline back.
For example:
&CW_USED
&CW_USEDEDAU
&CW_USEDE
and the option to build the list will appear... (sorry, no idea. maybe as text telling you that it's optional in the main menu).
It can't remain like that.
What do you think?
____________________________________________________________________________________________

B_U_Asm Selection should not reload the actual page.
____________________________________________________________________________________________

We have found out one user not understanding the Cnfiguration Dialog Tab:

>>> ToDo: Make the [Companion Files] Tab the first open one.
____________________________________________________________________________________________

Is the Header KILLFALGed?

____________________________________________________________________________________________

 Disassembler: With the Tests DLL, the Exported Names are wrongly two Byte backwarded.

____________________________________________________________________________________________

A user reports having seen a hang at:

>Proc DataView_FillDataLabelCombo:
>    Arguments @ComboHandle @SortByName
>
>    SendMessage D@ComboHandle, &CB_RESETCONTENT, 0, 0
>    Move D$H.DataLabelCombo D@ComboHandle
>
>    Mov esi D$PlainLabelList
>    lodsd ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

... which is quite "strange"...

____________________________________________________________________________________________

>- dans RosAsm (je sais pas si c'est toujours le cas) me semble
>que quand on sélectionne replace source, il ne travaille plus
>sur le fichier initialement chargé mais sur l'exe correspondant
>au .asm chargé. Moi j'aurai plutôt vu qu'il remplaçait le source
>et c'est tout. (pour open source only, là je suis d'accord qu'il
>le fasse par contre)
____________________________________________________________________________________________

'OpA3': "Mov D$FS:0, eax", with 0 in Word form >>> Other cases.

____________________________________________________________________________________________


Review the 'IsItCode' tuning, from the 'IsItNoReturnCall' comments.

____________________________________________________________________________________________

Implement a PUSHW for pushing imm 16 with negative cases assumed.
____________________________________________________________________________________________

Review 'CheckBracketExpression'
____________________________________________________________________________________________

In 'AnalyzeOfCmParameter' study the possibility of branching Imm reals, from the
'memMarker' Case
____________________________________________________________________________________________

Try to improve the Blocks saving, and to separate into some isolated Folders.
Mabe depending on a Time&Date Stamp.
____________________________________________________________________________________________

once RosAsm has tried to install, and failed to,
even if the the "RosAsmFiles" Folder is copied aside, with all required
Files, it does not try to Auto-Install, the way it does, at the very
first try.
____________________________________________________________________________________________

Review the 'CompileErrorHappend' Flag (not always effective, and does not work for
the last Dialog of the Unfolder (wishable to not show an empty bow after error),
at the end of 'UnfoldMacro'
____________________________________________________________________________________________

With some Selected Blocks (ex: Double-Click), the ScrollBar does not work.

____________________________________________________________________________________________

Name001
Name002
Name003
Name004

utiliser :

Remplace Name par EQUATE_Name (par exemple)...

____________________________________________________________________________________________

> In most schemes, you can define a macro called "at-compile-time" which
> will do calculations at compile time.  So, we could do:
> 
> (define sqrt-table (at-compile-time (list->vector (map (lambda (x)
> (sqrt x)) (range 0 500)))))

____________________________________________________________________________________________

In "Proc @ReplaceEquate:" don't forget to tell Ludwig to do:

Call GetFromQwordCheckSum esi, D$EquateList, D$EquateListLimit

____________________________________________________________________________________________

Il me semble que dans un source utilisant les TITLES, si une erreur de type :
"Symbol ne correspondant à aucun label" pointe vers une page différente de celle
où tu te trouves quand tu refermes la fenêtre de message d'erreur tu ne te retrouves
pas sur l'erreur comme d'habitude...

; -----------------------------------------------------------

In 'WriteFloatingPointOperationCode'

...Test_If_Not_And bx FloatingPointOperand, dx FloatingPointOperand
;...

..Test_Else_If_And bx ConstantOperand, dx ConstantOperand
       ; Mov eax merde
            EPP_Code '{??:R$ #1}|FLD R$?|{??:R$ #2}|FLD R$?|' | 
        Mov eax merde

The error Manager seesm to be perverted by this "EPP_Code" Macro

As the same Macro is Evocated upward, can is be something inside
the String, when parsing Conditional Macros (???!!!...), or can
it be something wrong in the ParaMacros Parser (???!!!...).

What relationship with the Statements Counter?

____________________________________________________________________________________________

Tools -> Configuration -> Help Files

Serait-il possible de d finir le r pertoire courant comme r pertoire par d faut et d'attribuer au diff rents chemins d'Help :
RosAsm\RosAsmFiles\xxxxx.xxx si ils sont pr sents.
____________________________________________________________________________________________

Wish list: 

- Remember the width of the debugger window. 

- Make the Edit functions works while using multiple instances of RosAsm, or at least an option to not show the "You are running multiple instances of Rosasm"... box. 

- For new files ask for the name of the exe the first time it compiles and not before. 
- and for the "New File" box allow user-defined templates for new files. Or a menu item called "New from template". 


Also, and most important: 

- Error in B_U_Asm > Mnemonics Ref: In Strings_Op and List_All_Op, MOVSD incorrectly links to the SSE mnemonic. And in SSE_Op, MOVSD is missed. 

- Limitation: Deleting all String resources in a PE is not allowed. 

____________________________________________________________________________________________

A short lesson in Correct code benchmarking:

CLI        ;not yet  
CPUID      ;or any other serialising
RDTSC
...        ;store edx:eax
test:
...        ;code to test (no loops here, execpt if part of test)
RDTSC      
STI        ;if 
...        ;sub edx:eax,[stored]
           ;sub 11 (the time for one RDTSC)
result in edx:eax, and that's the only true figure.


____________________________________________________________________________________________


'OQregRegImm8'

to do List:

Hello Betov, 

Your quite right in doubting the mnemonic for 

1) pextrw 

Mov al B$SecondReg | shl al 3 | or al 0011_000_000 | or al B$FirstReg 
should be 
Mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg 

2) pinsrw - though there's an error in the doc's we've got this one right. 

3) movm$kps - this one doesn't seem to work the way they've described, 
possibly been corrupted by microsoft and friends... :) :) :) 


Werewolf
____________________________________________________________________________________________

In 'WriteMacroVariable', i comment out the 5th line, without recalling why i wrote
this, previously (it was for the Conditional macros, anyway, but it seems to work
the same without... Wait and see...)

Also to be reviewed, in 'ReplaceFromMacroData', after the 'Call StoreMacroVariableByNumber',
the 'NOPE' output should probably not be there, but after the 'Call WriteMacroVariableByNumber'
Seems out of logic...
____________________________________________________________________________________________

For Debug Tool-Tips: keep the Equates List alive the same way as the CheckSum Table,
so that the Expression could be parsed?

How to re-Encode? What of the Label?

____________________________________________________________________________________________

Add an error message for Macros stripping the last String Delimiter.

____________________________________________________________________________________________

Encode / Decode Box does not parse the Win32 Equates.

____________________________________________________________________________________________


If you really want me to report the small errors, I will of course start 
doing this. But, as I can fully happily edit all my templates, and my 
apps, to my heart contents with RosAsm, at no problems in 99.9% of cases, 
I do not figure these small details to be important.

As it is to me, a much greater irritant, to use the working windows OS 
menues, than to use a RosAsm that has some rare crash states. Dont know if 
you found the SHIFT+DELETE problem yet. Sometimes, it seems to accumulate 
an error that makes the REPLACE function misbehave.

If I reset RosAsm, by a restart, the REPLACE function works correctly, but 
after some time using it, the replacement function can replace more than 
the exact number of chars. Sometimes it means that a SPACE is added so 
that when I use labels like Button.Close , and I want to replace it with
SkinButton.Close, I end up with SkinButton .Close (which does not compile).

I try to make a list from now on, and post it each week.

But theese small problemes with RosAsm has workarounds, that I use 
instead. For instance, I rarly need the replace functions, so when I do, I 
save, and exit, and restart, because I know it works perfectly then.

____________________________________________________________________________________________

I remember trying to find this in RosAsm's source (long ago) but I couldn't fix it .
Perhaps you could try calling LoadLibrary explicitly with the full path
c:\path\to\program\LibraryToLoad.dll?
It is obvious that there's something funky with setting the current directory.
Btw, I'm also using XP.

____________________________________________________________________________________________


SSE3 Instructions:

FISTTP  DF /1 FISTTP m16int
FISTTP  DB /1 FISTTP m32int
FISTTP  DD /1 FISTTP m64int
LDDQU
MOVSHDUP, MOVSLDUP, MOVDDUP
ADDSUBPS, ADDSUBPD
HADDPS, HSUBPS
HADDPD, HSUBPD
MONITOR
MWAIT

____________________________________________________________________________________________


>@ PI2FW  AMD 3Dnow Packed Integer Word to Floating-Point Conversion-  0Fh 0Fh / 0Ch
>                   - Found in Disassembler ONLY


____________________________________________________________________________________________

What i can do, is, in case of overflow error, go on checking up to the end, so that, 
in case of trailing specifier, it could forward it to the appropriated Routine.

Done for 'TranslateDecimal'.
____________________________________________________________________________________________

Review the BitMap Types. Example, Cursor sizes.
____________________________________________________________________________________________

After the new release of ludwig Debugger (coming after V.2.007d), recall of
the problem of TD_170Graph Demo, that aborts, when trying to Load/Save a File.
____________________________________________________________________________________________

si tu tapes "b tement" &NUL au lieu de &NULL dans un source en contenant plusieurs, 
l'erreur point e est incorrecte :

&NUL

Unknown Win equate name

Certes, mais le saut dans le code se fait, apparemment, sur la premi re  vocation et non sur l'erreur.
____________________________________________________________________________________________

le clic droit sur les appels Api fait appara tre une fen tre "Api Call infos" qui
n'est plus redimensionnable. Le probl me est que dans plusieurs cas la largeur 
n'est pas suffisante pour afficher tout le contenu sans retours   la lignes qui 
rendent confus et mal ais  la lecture...

____________________________________________________________________________________________

If the selection is not 3 line after the TITLE, in Search Functions, it is not
shown, because of the pos computation.
____________________________________________________________________________________________

>Apr s un test de d sassemblage d'une petite application utilisant
des TrackBars (r alis e avec RosAsm) tout le code est correctement
>restitu  mais il manque le :
>
>Call 'COMCTL32.InitCommonControls'

____________________________________________________________________________________________


>ici, avec PREPARSE Equal
>
>eax  = 0-32768 produit une erreur
>eax = -32768 produit une erreur
>eax = (-32768) ne produit pas d'erreur
____________________________________________________________________________________________

Hugin/ Nessie/ Nessie.asm: Problem of error not pointed out on Bad Dec. because
of the Dash-Lines considerations, to be implemented, first, into the [Search] Box.
____________________________________________________________________________________________

'LenghtOfBracketStatements' is bad since the modification of the Local Labels
expansions. Used only in 'SearchForApis'. Maybe not worthy the complication...
____________________________________________________________________________________________

For me personally, it would be good if we could configure code completion to match
after a certain, userselectable char. Or maybe match in the whole string ? I write 
"Application.WMSize" or "Application.WMMove", or "SkinSection.GetVisible" or 
"SkinSection.SetText". So code compeltion is a bit useless to me. If I could write 
"WMS" and RosAsm suggested : Application.WMSize, then code completion would be 
_very_ useful. 

And also if matching more than one identifier, the list could be cycled by just 
pressing CTRL+SPACE a second time, or third time. 
____________________________________________________________________________________________

Disassembler: 'NamedIdSubstitution' is wrong with MASM ShowDib2 Demo
____________________________________________________________________________________________

There is a issue in rosasm with local label calls:

Proc DoThis:
 ;code
 Call @locall; DoThis@locall
 ;code

Endp
@locall:
 ;code
 ;code
ret

Proc DoThat:
 ;code
 Call @locall; DoThat@locall
 ;code

Endp
@locall:
 ;code
 ;code
ret

The code works as espected.
The issue is with right click and tree navigation tools: They go to the  
first label always. Tree shows calls to locals sometimes as childs (as  
must be) but sometimes as orphans.
____________________________________________________________________________________________

[IMAGE_SECTION_HEADER:]
[Name1: B$ 0 #&IMAGE_SIZEOF_SHORT_NAME]
[MiscPhysicalAddress: MiscVirtualSize: D$ 0
 VirtualAddress: D$ 0
 SizeOfRawData: D$ 0
 PointerToRawData: D$ 0
 PointerToRelocations: D$ 0
 PointerToLinenumbers: D$ 0
 NumberOfRelocations: W$ 0
 NumberOfLinenumbers: W$ 0
 Characteristics: D$ 0]

[Name1Dis 0
 VirtualAddressDis 1
 SizeOfRawDataDis 5
 PointerToRawDataDis 9
 PointerToRelocationsDis 13
 PointerToLinenumbersDis 17
 NumberOfRelocationsDis 21
 NumberOfLinenumbersDis 23
 CharacteristicsDis 25]
 
____________________________________________________________________________________________

Is the 066 Prefix whishable or not for the encoding of ARPL ???
 
____________________________________________________________________________________________

add a [Save all TITLEs as Asm Files] in the [Ctrl] [S] feature Dialog
____________________________________________________________________________________________

Resize the Choose Menu Dialog at 90% of the Screen Width.
____________________________________________________________________________________________

Reuse the Trash1/2 Buffers everywhere possible.
____________________________________________________________________________________________

Add a Warning Edit Control in the Statistics.

When Building .Import, with calls to Comctl32.dll, verify that InitCommonControls
is called. If not, output a warning Message.

See: 'StoreDllName' >>> After the .Import is built, search for COMCTL32.
Found >>> Search for in InitCommonControls in 'ApiListB'.
____________________________________________________________________________________________

The "Peter Ctrl-Z" Bug has been fixed by implementing a security in the 'TextPos'
Routine >>> Rewrite all of the Ctrl-Z Functionalities from scratch when possible.
____________________________________________________________________________________________

Titles after failure of a Disassembling attempt >> Todo List
____________________________________________________________________________________________

Extend the sensitive area of Blank-Right-Click in the four directions.
____________________________________________________________________________________________

Redifine the 'FloatToUString' with Ludwig. ecx is not preserved.
____________________________________________________________________________________________

Is there a limit to the Data Alignment ([<??? ...) ? Is there a validity check for
the Number ?
____________________________________________________________________________________________

In the search/Replace Dialog the Tab-Key will not work properly,
the focus will set only on the selected radio button and can only moved with the arrow keys
____________________________________________________________________________________________

It would be very good to have more files in the MRU list, 
perhaps user- defined in the config setting?
____________________________________________________________________________________________

Implement a Table Switch for Strings Recognitions Table (for foreign languages).
____________________________________________________________________________________________

add a Routine to verify that (in Data) a Pointer does not break a pointer.
Examples in the Disasembly of Guga H2INC.
____________________________________________________________________________________________

Re-Assembling C:\ProgramFiles\... '7zFM' and '7zFM' hangs in 'ResetForNewBrackets'. 
A missing Bracket undetected problem.

To fix: Borbid any use of '?' in Code.
____________________________________________________________________________________________

lea al B$esi ; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
____________________________________________________________________________________________

Old: Dialog Editor: The Child Style is broken when re-organising a set of Dialogs 
 (insertion of a new Dialog in a List of Dialogs with ID modified >>> WS_POPUP.
 
 Something is wrong in Dialog Editor. Mouse Pointing to the various Controls inside
 [Other Files] Configuration Tab... This seems to be a problem with Group Boxes.
 
 To be verified first: Where must the Group box be in the Z order, in order to enable
 groups of Radio Buttons to work by themselves. JohnFound said, by placing the Group
 Box *after* the Radio Buttons... (???...).
 
 
 --------------
 
 Answer from Wilhelm Zadrapa:
 
 The Group Box must have the WS_GROUP style.

 The controls after that box, up the the next WS_GROUP style are part of the group.
 
 --------------

Dialog Editor:

* Sort the Dialogs each time we leave the Resources Editor.

* When Loading the Debugger's Dialogs Files, problems:

- Child Style not preserved (!!!???...)

- The is a bug outputing weird char(s) in the Class Record.
____________________________________________________________________________________________

Simplify 'IsItaLabel' and 'StoreBookMark': Store the Label to be BookMarked,
in all cases, to a renamed 'LocalBookMark'.

____________________________________________________________________________________________

Yes, Bookmarking Local Data Labels is not implemented. I never though of it, but this is,
evidently, a must have.

"Number forms"... EditControl, for easy copy paste... Yes.


____________________________________________________________________________________________
____________________________________________________________________________________________



; (8 ) 

How come this is not ok? 

Code:



[Label: ? #50 
 EndOfLabel: ?] 
Mov ecx EndOfLabel-Label ; Unable to resolve this parameter 
Mov ecx (EndOfLabel-Label) ; Immediate only in expressions

____________________________________________________________________________________________

Add a content Checking in the Function for loading a .dlg (not a RosAsm File > Abort).

____________________________________________________________________________________________

When creating a drop-down combo box in the dialog editor, it will not allow you to select the &CBS_DROPDOWNLIST flag - clicking this will only select the &CBS_DROPDOWN flag. 
____________________________________________________________________________________________

Rewrite 'RightClick', 'InternalRightClick', 'InternSearch'. More modular, more actual
Style.
____________________________________________________________________________________________


 To be verified:
 
 When parsing the Sources, there may be a problem with Comments vs MLC, that is:
 
 When skipping Comment it must stop at CR, not at LF, as this might eat a following
 MLC.
____________________________________________________________________________________________

i try to compile your 06midi sample and
it give me this message.
Orphan colon encoun....
at Proc Midi Stream.
Is it bug or something is change the 
assembler?
____________________________________________________________________________________________


____________________________________________________________________________________________


____________________________________________________________________________________________

 
____________________________________________________________________________________________

review the upper char in Clip operations.
 
____________________________________________________________________________________________

 
____________________________________________________________________________________________

What is this:

; 1 = My MF_POPUP substitution.

Example in 'ResetThisMenuIDs', 'TurnThisMenuToExType'. Why did i substitute 1 to 010 ?
____________________________________________________________________________________________

 
 
 Do not send an error message for Api Call by number with same Number in two different
 DLL. Force DLL Name for such calls.
 Disassembler, set the Jumps Table Labels' Names in the form of: "DllName0xxx:"
 
 PMULLW > (done)

____________________________________________________________________________________________

'ResetForNewBrackets' diserves a complete rewrite
";!!!!!!!!!" was the thing that made 'Base3 Uses' (without any parameter) hang. I turn it:
"jae L9>>", but i don't understand what the comment means (!!!...). The hell!
 
____________________________________________________________________________________________


____________________________________________________________________________________________


____________________________________________________________________________________________


____________________________________________________________________________________________

____________________________________________________________________________________________

default icon might be removed from the PE
____________________________________________________________________________________________


____________________________________________________________________________________________

 
____________________________________________________________________________________________

 Occasional Problems with Registry Modifications. Is it possible to directely 'refresh'?
 (Delete // re-Create)?

____________________________________________________________________________________________



____________________________________________________________________________________________

In Iczelion 31ListView.exe:

WIN32_FIND_DATA

[WFD_cAlternate: B$ 0 #14] hangs (in Find File Functions), under 2000, with long Names.
____________________________________________________________________________________________

 
error in the Dx Demo:

I think i found a very serious Errors in (RosAsm414b version). i using this macro

[DxCall | Mov eax D$#1 | Mov eax D$eax | Call D$eax+#3 D$#1 #4>L]

when i write this code ( DxCall lpdd '->' Release) , by unfolding or showing in Debuger
it looks so: 

Mov eax D$lpdd 
Mov eax D$eax 

where is the rest!!! > ; that's because there is no fourth Parameter !! 

instead i use this one:

[DxCall | Mov eax D$#1 | Mov eax D$eax | Push #L>3 | Push D$#1 | Call D$eax+#2]

____________________________________________________________________________________________

____________________________________________________________________________________________

    
____________________________________________________________________________________________

 
 Long Jumps optimized to short, when possible by Configuration Flag???...

____________________________________________________________________________________________
 
 
 Namings Check on [Include].

 implement a Memory remaping instead of 1 Mega Limit.
 
 ____________________________________________________________________________________________
 
 
 Scrolling text horizontally sucks
 
 By the way, i don't know how the Errors Manager deals with Run-Time errors
 in DB... I'll have to take a look at this... (To-Do List...)

____________________________________________________________________________________________
____________________________________________________________________________________________

 
 Unify ProgressBar creations, scaling, destructions. 
 
______________________________________________
 
 >[Data: DD 0] , without PREPARSE alternate >>> error pointing to the very first 'D' in
 the Source (!!!) (unknown symbol in 'BuildRelocationAndFillSymbols')... So, revue the
 way the Error Management in that computing search for the faultive Statement.
 
 General clean up of the Sources Editor needed. For example, 'StripBackSpace' is no
 more of any use. 
 
 Follow up with Jonne about Prefetch. 
 (Commenting out "cmp B$EregInside &TRUE | je L1>"  OK ???).
 
 File name when loading .asm!!!! Whishable to change? Without Title... yes...
 
 Bug inside the User Menu definition: Only the first Item was effective. Set *all*
 Paths to &MAX_PATH.
 
 Tree View: suppress the reduce Button in the bar, when runing in Auto-Hide Mode.

 Turn all Api calls into Macros, and store all system calls in one [System] TITLE.

 'DebugActiveProcessStop' >>> Download a more recent Win Help...
 
 Might hangs on upload of a non RosAsm written PE. Maybe the concerned PE did got a '.scr'
 section... See this next time.

 May hang when loading sources with broken resources.

 
 To do???: turn [ ... | ... #1>L | ... | #+1] possible. Actually, only #1, #2,...
 can be rolled.

 Problem with CreateDialog... vs DialogBox... Exit does not behave as Win Doc says.

 We could have a 'ReDo' feature if commenting out the 'ClearNextUndoRecord' Call in
 'ControlZ' (keep one for the 'TitleMoveFlag'), and implemeting a 'ControlShiftZ' Routine.

 Add something for Extended Styles in the Dialog Editor. Usefull, for example
 for having a ToolWindow Style Dialog, without modifying in Init.

 In the Dialog Editor: Save to ClipBord >>> turn Styles into Win Equates expressions.

 Reset the overall -general purpose- Comments at Top of each TITLE Parts (partially done).
 
 DLL without anything to Reloc > RelocSize = 8 !!!!!!!!!!!!!!!!! (seems to work OK).
 May be this is even required by the OS (it seems to effectively be required).


__________________
 
 The Api Function calls by Numbers seems wrong in the Disassembly.
 

Disassembler Menus: Menu of Win32Dasm incomplete.
 
____________________________

Add a 0 to 9 UpAndDown Control in the Structure Dialog for multiple Structures.

Re-Write the DkStructures.rtf. Add Examples with Equates forms.

compatible symb.table for external Debuggers

____________________________

The 'EditDialogBoxProc' organisation is now unreadable. An important enhancement
should be done with implementing a Tab Control, under the Main List Box. This Tab 
should say [Style][Dim][ID/Menu][Class][Title][Font/Cdata]. Then, Holding the Tab
Index would much simplify and organise the holding of incoming Messages from the 
various Definitions Controls.

Add the Extended Styles. Search first for what Extended Styles may be coming
with the controls. (Even unsure for the Dialog...). Limit to the ensured ones.

Rewrite, in B_U_Asm [Editors][Dialog_Editor], because the guys do not understand
why some things available in RadAsm are not made available in RosAsm Dialog Editor,
Explain the 'MustHaveBitTable', and the 'ExcludeBitTable' implementation (it
seems nobody noticed this... :().

____________________________________________________________________________________________
____________________________________________________________________________________________

In Asm32Tuts:

Strings: Description / Cases / Endings // Length // Searches //
Copying // Pasting / manipulation.
__________________

 Re-Write C_To_Asm, as HLL_To_Asm. Memory / Pointers / Data / Constructs / Size vs Types
 ...

____________________________________________________________________________________________
____________________________________________________________________________________________

Main Implementations to be entirely done:

* HLL Parser(s). -Non Assembly syntax- . Anybody can do it. A Start point is at 'NewParser'.

* OOA Parsers. -Non Assembly syntax- . Experiment a "Couple of hours" tasks managment.

* Conditional Assembly. Start point at 'MacroWithIf'.

* Version Info Resource. I do not know what this Resource is, physically, but there is
  a description in GorC Resources Compiler Manual.

* Code symbolic Profiler. Only me can do do it.

* Source Ripper. Only me can do it.

* Wizards. (Visual Editors sets, in a DLL, for ToolBars, all Windows Types, from simple
  Buttons to MDI Editors, the various readers and players,... ). Anybody can do it. As
  soon as a volunteer raises his hand up for one of these, open a [User Project] for the
  Wizard Collection, at the Board.
  
* Flirt recognition in the Disassembler. Download and study IdaPro and Dede Disassemblers
  first...
  
* Implement ROS Drivers output. First, find the NT Drivers specifications.
  - They are PEs, but, for example, NT KeyBoard.sys seems a raw Binary.
  - How many Types of Drivers? What .ext?
  - 'PeHeaderCharacteristics' should have something specific.
  - 'ImageBase' ?
  - What Entry Point organisation?
  - What developements rules?
  - What Sections?
  
* A new tool would be great for 'tracking' a Variable. Example, after xxx modifications
  of the Assembler, when fixing a bug inside 'StoreVirtualData, i don't remember what i 
  am doing with 'D$DataListPtr''. The question i wish the answer to is: "Do i make any 
  use of this Variable *after* this given point of the Computation? If yes, where?".
  I think i don't use any more this Variable downward, but, if i turn it zero, nothing
  works... So, i must use it somewhere... Maybe 're-use' for something completely 
  different, that would better require another name...
  
  I imagine an added Double-Click Menu Option saying [Track] and outputing something 
  like a Tree-View of the outines making use of it. It should work the same way for Labels
  (Data and Code), Equates and Macros, and would be great for restructuring, renaming,
  and so on. May be, simply the existing Tree-View, but with the concerned Routines 
  written in Red, or something like this.

;;
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT
TITLE CONVENTIONS     ; Version A.Bvvv DD.MM.YY maintainer email and version number go here
____________________________________________________________________________________________

@CONVENTIONS:

;;

    Displacements marks/ Balises de déplacements:
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        TODO <- Double-Click Left and "Search from Top"in order to jump to the points being developped
                Double clic gauche et "Search from Top" pour sauter aux points en cours de dev.

        [-Xxxxx-] <- Right Click to reach the explanation
                     Right clic pour atteindre l'explication

        [Xxxx] <- Right Click to reach the Label
                  Right clic pour atteindre le Label

        Arguments <- Macro (Mmmm): Right Click to reach the Macro Declarationou
                                 : Clic droit pour atteindre la déclaration de la Macro

        If, Mov, Call, Move <- Macro (Mmmm): Double Click to Unfold the Code Created by the Macro
                                           : Double-clic pour Unfold le code substitué par la Macro 

        &WM_SETFOCUS <- Right Click to Show the Hex/Dec Value of the Equate
                        Clic droit pour afficher la valeur Hex/Dec de l'Equate

        eax test movq <- Right Click to Show integrated Help
                         Clic droit pour afficher l'aide intégrée

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Labels et @Labels:
    ~~~~~~~~~~~~~~~~~

        In order to increase (if necessary)the legibility of your loops and keep the jumps short,
        use reserved local labels S0 ~ S9 and L0 to L9(pourquoi difference)and add to them ,
        on the same line , a Localized Global Label:  @MyLocalLabel.

        Pour augmenter (si besoin) la lisibilité de vos boucles et maintenir des sauts courts,
        utilisez les labels locaux réservés S0 ~ S9 et L0 à L9 et adjoignez-leur, sur la même
        ligne, un Label global localisé: @MyLocalLabel

        L0:@DO: ; ou  @DO:L0:

                ...

                ...

                sub ecx DWORD ; [-DWORD-]

            test ecx ecx | jns L0< ; jns @DO generate a long jump equivalent to jns L0<<
                                   ; jns @DO génère un saut long équivalent à jns L0<<

        !!! ALWAYS watch the Orphan list and KEEP IT EMPTY
        !!! Dans tous les cas, veillez à conserver l'Orphans List constament vide

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Diverse Typing rules/ Typos diverses:
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        "!!!" PAY ATTENTION: Important Remark / Attention, remarque importante

        Macros evocation:
        - Mov eax 45, Call, If, Comp:
          All Macros invocations have a CAPITAL First Letter        

        Macro évocation:
        - Mov eax 45, Call, If, Comp:
          Toutes les invocations de Macros ont une majuscule

        eax cmp test -> Right-clic open BUAsm
        Comp Call Push -> Right-clic Unfolding
        
        eax cmp test -> Clic-droit ouvre BUAsm
        Comp Call Push -> Clic-droit Unfold la Macro
         
    
        EQUATE ALWAYS in CAPITAL LETTERS / EQUATE toujours en majuscules

        '_' is allowed in Equates: MY_EQUATE @MY_EQUATE
        '_' autorisé dans les Equates: MY_EQUATE @MY_EQUATE 

        NO  '_' in the datas's names: MyData  OR My.Data but NOT My_Data NOR my_data
        Pas '_' dans les noms de datas: MaData ou Ma.Data mais pas Ma_Data ou ma_data

        Always : PREFIX.NameOfMyVariable @PREFIX.NameOfMyVariable Label@PREFIX.NameOfMyVariable
        NEVER: NameOfMyVariable @NameOfMyVariable Label@NameOfMyVariable
        * see [-PREFIXES-]

        Toujours: PREFIX.NomDeMaVariable @PREFIX.NomDeMaVariable Label@PREFIX.NomDeMaVariable
        Jamais: NomDeMaVariable @NomDeMaVariable Label@NomDeMaVariable (sans préfixe)
        * voir [-PREFIXES-]

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Separation and comments / Séparations et commentaires:
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        TITLE Commun: XXXXXXXX

             ; Version A.Bvvv DD.MM.YY maintainer email   
 TITLE DATAS ; Version A.Bxxx DD.MM.YY Nom(s) mainteneur(s) adresse(s) de courriel
____________________________________________________________________________________________

; ...
____________________________________________________________________________________________

        TITLE Spécifique: XxxxxxXxxx

                  ; Version A.Bvvv DD.MM.YY maintainer email
 TITLE MainWindow ; Version A.Bxxx DD.MM.YY Nom(s) mainteneur(s) adresse(s) de courriel
____________________________________________________________________________________________

;; 

    Global multilangual explanation of the architecture and workings of diverse mechanisms
    implemented in the specific TITLE

    Explication globale et multilingue de l'architecture et du fonctionement des divers
    mécanismes implémentés dans le TITLE Commun:

    - Use of module present in the TITLE, what it does, who for, why, how
    - Utilité du module présent dans le TITLE, ce qu'il fait, pour qui, pourquoi, comment

    - Simplified tree / Arborescence simplifiée:

    [XxxxA0]
    |   
    |--->[XxxxB0]
    |     |
    |     |--->[XxxxB1] 
    |     |
    |     |--->[XxxxB2]
    |     |  
    |     |--->[XxxxB3]
    |     °     |
    |           |--->[XxxxB3.1]
    |           |    | The branch carries on outside the TITLE / La branche continue en dehors du TITLE
    |           |
    |           |--->[XxxxB3.2]
    | suite...  °    ° End of branch / fin de branche

;;  
____________________________________________________________________________________________

LabelX:

    Code

L1: ...

        Code

    jmp L1<

L2: ...

        Code

L3:     ...

            Code

        jmp L3<

   jmp L2<
____________________________________________________________________________________________

LableY:

    Code

ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOT

 (End Of Title)
    _________________________________

    ; Comments for code section
    ; Commentaire de section de code
    _________________________________

    ; Local comment on the line above the code / Commentaire local sur la ligne au dessus du code
    Mov eax 45 | xor edx edx | div..

    ; Global comment Call / Commentaire global Call
    Call 'MODULE.Api' P1,
                      P2, ; Specific comment for P2 / Commentaire spécifique sur P2
                      ...
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Structuration:
    ~~~~~~~~~~~~~

LabelRoutine:

    [If] A
 
        If A1

            Call TraitementA1 ; !!! NEVER any Code / Jamais de code

        [Else_If] A2

            Call TraitementA2

        [Else]
        
            [ExitR]

        [End_If]

    Else_If B

        Call TraitementB

    Else_If X

        !!! NEVER any Code / Jamais de code

    End_If

[RetR]   
     ______________________________________ F8

TraitementB:

    If B1

        Call TraitementB1

    Else_If X

        !!! NEVER any Code / Jamais de code

    Else_If B2

        Call TraitementB2

    Else_If B3

        Call TraitementB3

    End_If
    _________________________________________________________________

    ; Identation illustration, here with local labels, A "spaghetti"
    ; construct a little complicated without comments
 
    ; Illustration d'indentations, ici avec Labels localisés, d'une
    ; imbrications spaghetti un peu compliquée et non commentée
    _________________________________________________________________

L1: @Debut:

        Code

        [Comp] eax edx je L1<,
                          js S1>,
                          jz S2>>

    sub ecx [DWORD] | jns L1<
 
        Code

        L2: @OK

                Mov ecx 16

S1: @OK sub edx 1 | jnz L1<

            sub edx 1 | jnz L2<

S2: @Fin

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;;
____________________________________________________________________________________________
____________________________________________________________________________________________
; EOF

; (End Of File)











